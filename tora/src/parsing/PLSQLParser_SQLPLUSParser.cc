/** \file
 *  This C++ source file was generated by $ANTLR version 3.5.2-SNAPSHOT
 *
 *     -  From the grammar source file : SQLPLUSParser.g
 *     -                            On : 2013-10-27 10:36:01
 *     -                for the parser : PLSQLParser_SQLPLUSParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "PLSQLParser_SQLPLUSParser.hpp"
// Include delegator definition header files
//
#include "PLSQLParser.hpp" 

/* ----------------------------------------- */

/**
 * Oracle(c) SQL*Plus 11g Parser
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *                         Tomi Pakarinen <tomi.pakarinen@iki.fi>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

namespace  Antlr3BackendImpl  {
using namespace antlr3;

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "SQLPLUSParser.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* PLSQLParser_SQLPLUSParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new PLSQLParser_SQLPLUSParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PLSQLParser_SQLPLUSParser::PLSQLParser_SQLPLUSParser( StreamType* instream, PLSQLParser* gPLSQLParser)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream, gPLSQLParser);
}

/** \brief Create a new PLSQLParser_SQLPLUSParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PLSQLParser_SQLPLUSParser::PLSQLParser_SQLPLUSParser( StreamType* instream, RecognizerSharedStateType* state, PLSQLParser* gPLSQLParser)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream , gPLSQLParser);
}

void PLSQLParser_SQLPLUSParser::init(StreamType* instream, PLSQLParser* gPLSQLParser)
{
     	// Install the pointers back to lexers that will delegate us to perform certain functions
     	// for them.
     	//
     		m_gPLSQLParser = gPLSQLParser;
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( PLSQLParserTokenNames );


}

void
PLSQLParser_SQLPLUSParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
PLSQLParser_SQLPLUSParser::~PLSQLParser_SQLPLUSParser()
 {
}

/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return PLSQLParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_SOLIDUS_in_sql_plus_command33_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_SOLIDUS_in_sql_plus_command33( FOLLOW_SOLIDUS_in_sql_plus_command33_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_whenever_command_in_sql_plus_command35_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_whenever_command_in_sql_plus_command35( FOLLOW_whenever_command_in_sql_plus_command35_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_exit_command_in_sql_plus_command37_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_exit_command_in_sql_plus_command37( FOLLOW_exit_command_in_sql_plus_command37_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_prompt_command_in_sql_plus_command39_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_prompt_command_in_sql_plus_command39( FOLLOW_prompt_command_in_sql_plus_command39_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_set_command_in_sql_plus_command41_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_set_command_in_sql_plus_command41( FOLLOW_set_command_in_sql_plus_command41_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_sql_plus_command44_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_sql_plus_command44( FOLLOW_SEMICOLON_in_sql_plus_command44_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_whenever_key_in_whenever_command65_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_whenever_key_in_whenever_command65( FOLLOW_whenever_key_in_whenever_command65_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_sqlerror_key_in_whenever_command68_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_sqlerror_key_in_whenever_command68( FOLLOW_sqlerror_key_in_whenever_command68_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_oserror_key_in_whenever_command70_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_oserror_key_in_whenever_command70( FOLLOW_oserror_key_in_whenever_command70_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_exit_key_in_whenever_command74_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_exit_key_in_whenever_command74( FOLLOW_exit_key_in_whenever_command74_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_success_key_in_whenever_command77_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_success_key_in_whenever_command77( FOLLOW_success_key_in_whenever_command77_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_failure_key_in_whenever_command79_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_failure_key_in_whenever_command79( FOLLOW_failure_key_in_whenever_command79_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_warning_key_in_whenever_command81_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_warning_key_in_whenever_command81( FOLLOW_warning_key_in_whenever_command81_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_commit_key_in_whenever_command85_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_commit_key_in_whenever_command85( FOLLOW_commit_key_in_whenever_command85_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_rollback_key_in_whenever_command87_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_rollback_key_in_whenever_command87( FOLLOW_rollback_key_in_whenever_command87_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_continue_key_in_whenever_command92_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_continue_key_in_whenever_command92( FOLLOW_continue_key_in_whenever_command92_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_commit_key_in_whenever_command95_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_commit_key_in_whenever_command95( FOLLOW_commit_key_in_whenever_command95_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_rollback_key_in_whenever_command97_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_rollback_key_in_whenever_command97( FOLLOW_rollback_key_in_whenever_command97_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_none_key_in_whenever_command99_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_none_key_in_whenever_command99( FOLLOW_none_key_in_whenever_command99_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_set_key_in_set_command121_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_set_key_in_set_command121( FOLLOW_set_key_in_set_command121_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_set_command123_bits[]	= { ANTLR_UINT64_LIT(0x0000000000401000), ANTLR_UINT64_LIT(0x2000000000000400) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_set_command123( FOLLOW_REGULAR_ID_in_set_command123_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_CHAR_STRING_in_set_command126_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_CHAR_STRING_in_set_command126( FOLLOW_CHAR_STRING_in_set_command126_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_on_key_in_set_command128_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_on_key_in_set_command128( FOLLOW_on_key_in_set_command128_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_off_key_in_set_command130_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_off_key_in_set_command130( FOLLOW_off_key_in_set_command130_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_EXACT_NUM_LIT_in_set_command132_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_EXACT_NUM_LIT_in_set_command132( FOLLOW_EXACT_NUM_LIT_in_set_command132_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_set_command134_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_set_command134( FOLLOW_REGULAR_ID_in_set_command134_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_exit_key_in_exit_command155_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_exit_key_in_exit_command155( FOLLOW_exit_key_in_exit_command155_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_SQLPLUSParser  */
static	ANTLR_BITWORD FOLLOW_PROMPT_in_prompt_command176_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_SQLPLUSParserImplTraits::BitsetListType FOLLOW_PROMPT_in_prompt_command176( FOLLOW_PROMPT_in_prompt_command176_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start sql_plus_command
 * SQLPLUSParser.g:27:1: sql_plus_command : ( SOLIDUS | whenever_command | exit_command | prompt_command | set_command ) ( SEMICOLON )? ;
 */
void
PLSQLParser_SQLPLUSParser::sql_plus_command()
{
        PLSQLParser_SQLPLUSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // SQLPLUSParser.g:28:5: ( ( SOLIDUS | whenever_command | exit_command | prompt_command | set_command ) ( SEMICOLON )? )
        // SQLPLUSParser.g:28:10: ( SOLIDUS | whenever_command | exit_command | prompt_command | set_command ) ( SEMICOLON )?
        {
            // SQLPLUSParser.g:28:10: ( SOLIDUS | whenever_command | exit_command | prompt_command | set_command )
            {
                int alt1=5;
                switch ( this->LA(1) )
                {
                case SOLIDUS:
                	{
                		alt1=1;
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    int LA1_2 = this->LA(2);
                		    if ( (LA1_2 == EOF || LA1_2 == LEFT_PAREN || LA1_2 == PLSQL_RESERVED_LOCK || LA1_2 == PROMPT || LA1_2 == SEMICOLON || LA1_2 == SOLIDUS || LA1_2 == SQL92_RESERVED_ALTER || LA1_2 == SQL92_RESERVED_CREATE || LA1_2 == SQL92_RESERVED_DELETE || LA1_2 == SQL92_RESERVED_DROP || LA1_2 == SQL92_RESERVED_INSERT || LA1_2 == SQL92_RESERVED_PROCEDURE || LA1_2 == SQL92_RESERVED_SELECT || LA1_2 == SQL92_RESERVED_UPDATE || LA1_2 == SQL92_RESERVED_WITH))
                		    {
                		        alt1=3;
                		    }
                		    else if ( (LA1_2 == REGULAR_ID))
                		    {
                		        {
                		            int LA1_5 = this->LA(3);
                		            if ( (LA1_5 == EOF || LA1_5 == DELIMITED_ID || LA1_5 == INTRODUCER || LA1_5 == LEFT_PAREN || LA1_5 == PLSQL_RESERVED_LOCK || LA1_5 == PROMPT || LA1_5 == SEMICOLON || LA1_5 == SOLIDUS || LA1_5 == SQL92_RESERVED_ALTER || LA1_5 == SQL92_RESERVED_CREATE || LA1_5 == SQL92_RESERVED_DELETE || LA1_5 == SQL92_RESERVED_DROP || LA1_5 == SQL92_RESERVED_INSERT || LA1_5 == SQL92_RESERVED_INTO || LA1_5 == SQL92_RESERVED_PROCEDURE || LA1_5 == SQL92_RESERVED_SELECT || LA1_5 == SQL92_RESERVED_UPDATE || LA1_5 == SQL92_RESERVED_WITH))
                		            {
                		                alt1=3;
                		            }
                		            else if ( (LA1_5 == REGULAR_ID))
                		            {
                		                {
                		                    int LA1_6 = this->LA(4);
                		                    if ( (LA1_6 == REGULAR_ID))
                		                    {
                		                        alt1=2;
                		                    }
                		                    else if ( ((equalsIgnoreCase(LT(1)->getText(), "EXIT"))))
                		                    {
                		                        alt1=3;
                		                    }
                		                    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SET"))))
                		                    {
                		                        alt1=5;
                		                    }
                		                    else
                		                    {
                		                        if (this->get_backtracking()>0)
                		                        {
                		                            this->set_failedflag( true );
                		                            return ;
                		                        }


                		                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_SQLPLUSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		                        ex->set_decisionNum( 1 );
                		                        ex->set_state( 6 );


                		                        goto rulesql_plus_commandEx;

                		                    }
                		                }
                		            }
                		            else if ( (LA1_5 == CHAR_STRING || LA1_5 == EXACT_NUM_LIT || LA1_5 == SQL92_RESERVED_ON) && ((equalsIgnoreCase(LT(1)->getText(), "SET"))))
                		            {
                		                alt1=5;
                		            }
                		            else
                		            {
                		                if (this->get_backtracking()>0)
                		                {
                		                    this->set_failedflag( true );
                		                    return ;
                		                }


                		                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_SQLPLUSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		                ex->set_decisionNum( 1 );
                		                ex->set_state( 5 );


                		                goto rulesql_plus_commandEx;

                		            }
                		        }
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_SQLPLUSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 1 );
                		        ex->set_state( 2 );


                		        goto rulesql_plus_commandEx;

                		    }
                		}
                	}
                    break;
                case PROMPT:
                	{
                		alt1=4;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_SQLPLUSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 1 );
                    ex->set_state( 0 );


                    goto rulesql_plus_commandEx;

                }

                switch (alt1)
                {
            	case 1:
            	    // SQLPLUSParser.g:28:11: SOLIDUS
            	    {
            	         this->matchToken(SOLIDUS, &FOLLOW_SOLIDUS_in_sql_plus_command33);
            	        if  (this->hasException())
            	        {
            	            goto rulesql_plus_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // SQLPLUSParser.g:28:19: whenever_command
            	    {
            	        this->followPush(FOLLOW_whenever_command_in_sql_plus_command35);
            	        whenever_command();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesql_plus_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // SQLPLUSParser.g:28:36: exit_command
            	    {
            	        this->followPush(FOLLOW_exit_command_in_sql_plus_command37);
            	        exit_command();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesql_plus_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 4:
            	    // SQLPLUSParser.g:28:49: prompt_command
            	    {
            	        this->followPush(FOLLOW_prompt_command_in_sql_plus_command39);
            	        prompt_command();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesql_plus_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 5:
            	    // SQLPLUSParser.g:28:64: set_command
            	    {
            	        this->followPush(FOLLOW_set_command_in_sql_plus_command41);
            	        set_command();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesql_plus_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // SQLPLUSParser.g:28:77: ( SEMICOLON )?
            {
                int alt2=2;
                {
                    int LA2_0 = this->LA(1);
                    if ( (LA2_0 == SEMICOLON))
                    {
                        alt2=1;
                    }
                }
                switch (alt2)
                {
            	case 1:
            	    // SQLPLUSParser.g:28:77: SEMICOLON
            	    {
            	         this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_sql_plus_command44);
            	        if  (this->hasException())
            	        {
            	            goto rulesql_plus_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesql_plus_commandEx; /* Prevent compiler warnings */
    rulesql_plus_commandEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sql_plus_command */

/**
 * $ANTLR start whenever_command
 * SQLPLUSParser.g:31:1: whenever_command : whenever_key ( sqlerror_key | oserror_key ) ( exit_key ( success_key | failure_key | warning_key ) ( commit_key | rollback_key ) | continue_key ( commit_key | rollback_key | none_key ) ) ;
 */
void
PLSQLParser_SQLPLUSParser::whenever_command()
{
        PLSQLParser_SQLPLUSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // SQLPLUSParser.g:32:5: ( whenever_key ( sqlerror_key | oserror_key ) ( exit_key ( success_key | failure_key | warning_key ) ( commit_key | rollback_key ) | continue_key ( commit_key | rollback_key | none_key ) ) )
        // SQLPLUSParser.g:32:10: whenever_key ( sqlerror_key | oserror_key ) ( exit_key ( success_key | failure_key | warning_key ) ( commit_key | rollback_key ) | continue_key ( commit_key | rollback_key | none_key ) )
        {
            this->followPush(FOLLOW_whenever_key_in_whenever_command65);
            m_gPLSQLParser->whenever_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulewhenever_commandEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // SQLPLUSParser.g:32:23: ( sqlerror_key | oserror_key )
            {
                int alt3=2;
                {
                    int LA3_0 = this->LA(1);
                    if ( (LA3_0 == REGULAR_ID))
                    {
                        {
                            int LA3_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "SQLERROR"))))
                            {
                                alt3=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "OSERROR"))))
                            {
                                alt3=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_SQLPLUSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 3 );
                                ex->set_state( 1 );


                                goto rulewhenever_commandEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_SQLPLUSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 3 );
                        ex->set_state( 0 );


                        goto rulewhenever_commandEx;

                    }
                }
                switch (alt3)
                {
            	case 1:
            	    // SQLPLUSParser.g:32:24: sqlerror_key
            	    {
            	        this->followPush(FOLLOW_sqlerror_key_in_whenever_command68);
            	        m_gPLSQLParser->sqlerror_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewhenever_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // SQLPLUSParser.g:32:37: oserror_key
            	    {
            	        this->followPush(FOLLOW_oserror_key_in_whenever_command70);
            	        m_gPLSQLParser->oserror_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewhenever_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // SQLPLUSParser.g:32:50: ( exit_key ( success_key | failure_key | warning_key ) ( commit_key | rollback_key ) | continue_key ( commit_key | rollback_key | none_key ) )
            {
                int alt7=2;
                {
                    int LA7_0 = this->LA(1);
                    if ( (LA7_0 == REGULAR_ID))
                    {
                        {
                            int LA7_1 = this->LA(2);
                            if ( (LA7_1 == REGULAR_ID))
                            {
                                {
                                    int LA7_2 = this->LA(3);
                                    if ( (LA7_2 == EOF || LA7_2 == LEFT_PAREN || LA7_2 == PLSQL_RESERVED_LOCK || LA7_2 == PROMPT || LA7_2 == SEMICOLON || LA7_2 == SOLIDUS || LA7_2 == SQL92_RESERVED_ALTER || LA7_2 == SQL92_RESERVED_CREATE || LA7_2 == SQL92_RESERVED_DELETE || LA7_2 == SQL92_RESERVED_DROP || LA7_2 == SQL92_RESERVED_INSERT || LA7_2 == SQL92_RESERVED_PROCEDURE || LA7_2 == SQL92_RESERVED_SELECT || LA7_2 == SQL92_RESERVED_UPDATE || LA7_2 == SQL92_RESERVED_WITH) && ((equalsIgnoreCase(LT(1)->getText(), "CONTINUE"))))
                                    {
                                        alt7=2;
                                    }
                                    else if ( (LA7_2 == REGULAR_ID))
                                    {
                                        {
                                            int LA7_4 = this->LA(4);
                                            if ( ((equalsIgnoreCase(LT(1)->getText(), "EXIT"))))
                                            {
                                                alt7=1;
                                            }
                                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "CONTINUE"))))
                                            {
                                                alt7=2;
                                            }
                                            else
                                            {
                                                if (this->get_backtracking()>0)
                                                {
                                                    this->set_failedflag( true );
                                                    return ;
                                                }


                                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_SQLPLUSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                                ex->set_decisionNum( 7 );
                                                ex->set_state( 4 );


                                                goto rulewhenever_commandEx;

                                            }
                                        }
                                    }
                                    else
                                    {
                                        if (this->get_backtracking()>0)
                                        {
                                            this->set_failedflag( true );
                                            return ;
                                        }


                                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_SQLPLUSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                        ex->set_decisionNum( 7 );
                                        ex->set_state( 2 );


                                        goto rulewhenever_commandEx;

                                    }
                                }
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_SQLPLUSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 7 );
                                ex->set_state( 1 );


                                goto rulewhenever_commandEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_SQLPLUSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 7 );
                        ex->set_state( 0 );


                        goto rulewhenever_commandEx;

                    }
                }
                switch (alt7)
                {
            	case 1:
            	    // SQLPLUSParser.g:32:51: exit_key ( success_key | failure_key | warning_key ) ( commit_key | rollback_key )
            	    {
            	        this->followPush(FOLLOW_exit_key_in_whenever_command74);
            	        m_gPLSQLParser->exit_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewhenever_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // SQLPLUSParser.g:32:60: ( success_key | failure_key | warning_key )
            	        {
            	            int alt4=3;
            	            {
            	                int LA4_0 = this->LA(1);
            	                if ( (LA4_0 == REGULAR_ID))
            	                {
            	                    {
            	                        int LA4_1 = this->LA(2);
            	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "SUCCESS"))))
            	                        {
            	                            alt4=1;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "FAILURE"))))
            	                        {
            	                            alt4=2;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "WARNING"))))
            	                        {
            	                            alt4=3;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_SQLPLUSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 4 );
            	                            ex->set_state( 1 );


            	                            goto rulewhenever_commandEx;

            	                        }
            	                    }
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_SQLPLUSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 4 );
            	                    ex->set_state( 0 );


            	                    goto rulewhenever_commandEx;

            	                }
            	            }
            	            switch (alt4)
            	            {
            	        	case 1:
            	        	    // SQLPLUSParser.g:32:61: success_key
            	        	    {
            	        	        this->followPush(FOLLOW_success_key_in_whenever_command77);
            	        	        m_gPLSQLParser->success_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulewhenever_commandEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // SQLPLUSParser.g:32:73: failure_key
            	        	    {
            	        	        this->followPush(FOLLOW_failure_key_in_whenever_command79);
            	        	        m_gPLSQLParser->failure_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulewhenever_commandEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // SQLPLUSParser.g:32:85: warning_key
            	        	    {
            	        	        this->followPush(FOLLOW_warning_key_in_whenever_command81);
            	        	        m_gPLSQLParser->warning_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulewhenever_commandEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // SQLPLUSParser.g:32:98: ( commit_key | rollback_key )
            	        {
            	            int alt5=2;
            	            {
            	                int LA5_0 = this->LA(1);
            	                if ( (LA5_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "COMMIT")))||((equalsIgnoreCase(LT(1)->getText(), "ROLLBACK"))))))
            	                {
            	                    {
            	                        int LA5_1 = this->LA(2);
            	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "COMMIT"))))
            	                        {
            	                            alt5=1;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "ROLLBACK"))))
            	                        {
            	                            alt5=2;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_SQLPLUSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 5 );
            	                            ex->set_state( 1 );


            	                            goto rulewhenever_commandEx;

            	                        }
            	                    }
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_SQLPLUSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 5 );
            	                    ex->set_state( 0 );


            	                    goto rulewhenever_commandEx;

            	                }
            	            }
            	            switch (alt5)
            	            {
            	        	case 1:
            	        	    // SQLPLUSParser.g:32:99: commit_key
            	        	    {
            	        	        this->followPush(FOLLOW_commit_key_in_whenever_command85);
            	        	        m_gPLSQLParser->commit_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulewhenever_commandEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // SQLPLUSParser.g:32:110: rollback_key
            	        	    {
            	        	        this->followPush(FOLLOW_rollback_key_in_whenever_command87);
            	        	        m_gPLSQLParser->rollback_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulewhenever_commandEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // SQLPLUSParser.g:32:126: continue_key ( commit_key | rollback_key | none_key )
            	    {
            	        this->followPush(FOLLOW_continue_key_in_whenever_command92);
            	        m_gPLSQLParser->continue_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewhenever_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // SQLPLUSParser.g:32:139: ( commit_key | rollback_key | none_key )
            	        {
            	            int alt6=3;
            	            {
            	                int LA6_0 = this->LA(1);
            	                if ( (LA6_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "COMMIT")))||((equalsIgnoreCase(LT(1)->getText(), "NONE")))||((equalsIgnoreCase(LT(1)->getText(), "ROLLBACK"))))))
            	                {
            	                    {
            	                        int LA6_1 = this->LA(2);
            	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "COMMIT"))))
            	                        {
            	                            alt6=1;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "ROLLBACK"))))
            	                        {
            	                            alt6=2;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NONE"))))
            	                        {
            	                            alt6=3;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_SQLPLUSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 6 );
            	                            ex->set_state( 1 );


            	                            goto rulewhenever_commandEx;

            	                        }
            	                    }
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_SQLPLUSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 6 );
            	                    ex->set_state( 0 );


            	                    goto rulewhenever_commandEx;

            	                }
            	            }
            	            switch (alt6)
            	            {
            	        	case 1:
            	        	    // SQLPLUSParser.g:32:140: commit_key
            	        	    {
            	        	        this->followPush(FOLLOW_commit_key_in_whenever_command95);
            	        	        m_gPLSQLParser->commit_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulewhenever_commandEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // SQLPLUSParser.g:32:151: rollback_key
            	        	    {
            	        	        this->followPush(FOLLOW_rollback_key_in_whenever_command97);
            	        	        m_gPLSQLParser->rollback_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulewhenever_commandEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // SQLPLUSParser.g:32:164: none_key
            	        	    {
            	        	        this->followPush(FOLLOW_none_key_in_whenever_command99);
            	        	        m_gPLSQLParser->none_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulewhenever_commandEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulewhenever_commandEx; /* Prevent compiler warnings */
    rulewhenever_commandEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end whenever_command */

/**
 * $ANTLR start set_command
 * SQLPLUSParser.g:35:1: set_command : set_key REGULAR_ID ( CHAR_STRING | on_key | off_key | EXACT_NUM_LIT | REGULAR_ID ) ;
 */
void
PLSQLParser_SQLPLUSParser::set_command()
{
        PLSQLParser_SQLPLUSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // SQLPLUSParser.g:36:5: ( set_key REGULAR_ID ( CHAR_STRING | on_key | off_key | EXACT_NUM_LIT | REGULAR_ID ) )
        // SQLPLUSParser.g:36:10: set_key REGULAR_ID ( CHAR_STRING | on_key | off_key | EXACT_NUM_LIT | REGULAR_ID )
        {
            this->followPush(FOLLOW_set_key_in_set_command121);
            m_gPLSQLParser->set_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleset_commandEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_set_command123);
            if  (this->hasException())
            {
                goto ruleset_commandEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // SQLPLUSParser.g:36:29: ( CHAR_STRING | on_key | off_key | EXACT_NUM_LIT | REGULAR_ID )
            {
                int alt8=5;
                switch ( this->LA(1) )
                {
                case CHAR_STRING:
                	{
                		alt8=1;
                	}
                    break;
                case SQL92_RESERVED_ON:
                	{
                		alt8=2;
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    int LA8_3 = this->LA(2);
                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "OFF"))))
                		    {
                		        alt8=3;
                		    }
                		    else if ( (true))
                		    {
                		        alt8=5;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_SQLPLUSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 8 );
                		        ex->set_state( 3 );


                		        goto ruleset_commandEx;

                		    }
                		}
                	}
                    break;
                case EXACT_NUM_LIT:
                	{
                		alt8=4;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_SQLPLUSParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 8 );
                    ex->set_state( 0 );


                    goto ruleset_commandEx;

                }

                switch (alt8)
                {
            	case 1:
            	    // SQLPLUSParser.g:36:30: CHAR_STRING
            	    {
            	         this->matchToken(CHAR_STRING, &FOLLOW_CHAR_STRING_in_set_command126);
            	        if  (this->hasException())
            	        {
            	            goto ruleset_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // SQLPLUSParser.g:36:42: on_key
            	    {
            	        this->followPush(FOLLOW_on_key_in_set_command128);
            	        m_gPLSQLParser->on_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleset_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // SQLPLUSParser.g:36:49: off_key
            	    {
            	        this->followPush(FOLLOW_off_key_in_set_command130);
            	        m_gPLSQLParser->off_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleset_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 4:
            	    // SQLPLUSParser.g:36:57: EXACT_NUM_LIT
            	    {
            	         this->matchToken(EXACT_NUM_LIT, &FOLLOW_EXACT_NUM_LIT_in_set_command132);
            	        if  (this->hasException())
            	        {
            	            goto ruleset_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 5:
            	    // SQLPLUSParser.g:36:71: REGULAR_ID
            	    {
            	         this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_set_command134);
            	        if  (this->hasException())
            	        {
            	            goto ruleset_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleset_commandEx; /* Prevent compiler warnings */
    ruleset_commandEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end set_command */

/**
 * $ANTLR start exit_command
 * SQLPLUSParser.g:39:1: exit_command : exit_key ;
 */
void
PLSQLParser_SQLPLUSParser::exit_command()
{
        PLSQLParser_SQLPLUSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // SQLPLUSParser.g:40:5: ( exit_key )
        // SQLPLUSParser.g:40:10: exit_key
        {
            this->followPush(FOLLOW_exit_key_in_exit_command155);
            m_gPLSQLParser->exit_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexit_commandEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexit_commandEx; /* Prevent compiler warnings */
    ruleexit_commandEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exit_command */

/**
 * $ANTLR start prompt_command
 * SQLPLUSParser.g:43:1: prompt_command : PROMPT ;
 */
void
PLSQLParser_SQLPLUSParser::prompt_command()
{
        PLSQLParser_SQLPLUSParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // SQLPLUSParser.g:44:5: ( PROMPT )
        // SQLPLUSParser.g:44:10: PROMPT
        {
             this->matchToken(PROMPT, &FOLLOW_PROMPT_in_prompt_command176);
            if  (this->hasException())
            {
                goto ruleprompt_commandEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprompt_commandEx; /* Prevent compiler warnings */
    ruleprompt_commandEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prompt_command */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

}

/* End of code
 * =============================================================================
 */
