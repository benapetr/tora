/** \file
 *  This C++ source file was generated by $ANTLR version 3.5.2-SNAPSHOT
 *
 *     -  From the grammar source file : PLSQLCommons.g
 *     -                            On : 2013-10-27 10:35:54
 *     -                for the parser : PLSQLParser_PLSQLCommonsParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "PLSQLParser_PLSQLCommons.hpp"
// Include delegator definition header files
//
#include "PLSQLParser.hpp" 

/* ----------------------------------------- */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

namespace  Antlr3BackendImpl  {
using namespace antlr3;

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "PLSQLCommons.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* PLSQLParser_PLSQLCommons::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new PLSQLParser_PLSQLCommons parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PLSQLParser_PLSQLCommons::PLSQLParser_PLSQLCommons( StreamType* instream, PLSQLParser* gPLSQLParser)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream, gPLSQLParser);
}

/** \brief Create a new PLSQLParser_PLSQLCommons parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PLSQLParser_PLSQLCommons::PLSQLParser_PLSQLCommons( StreamType* instream, RecognizerSharedStateType* state, PLSQLParser* gPLSQLParser)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream , gPLSQLParser);
}

void PLSQLParser_PLSQLCommons::init(StreamType* instream, PLSQLParser* gPLSQLParser)
{
     	// Install the pointers back to lexers that will delegate us to perform certain functions
     	// for them.
     	//
     		m_gPLSQLParser = gPLSQLParser;
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( PLSQLParserTokenNames );


}

void
PLSQLParser_PLSQLCommons::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
PLSQLParser_PLSQLCommons::~PLSQLParser_PLSQLCommons()
 {
}

/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return PLSQLParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_subpartition_key_in_partition_extension_clause36_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_subpartition_key_in_partition_extension_clause36( FOLLOW_subpartition_key_in_partition_extension_clause36_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_partition_key_in_partition_extension_clause40_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_partition_key_in_partition_extension_clause40( FOLLOW_partition_key_in_partition_extension_clause40_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_for_key_in_partition_extension_clause53_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_for_key_in_partition_extension_clause53( FOLLOW_for_key_in_partition_extension_clause53_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_partition_extension_clause56_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_expression_list_in_partition_extension_clause56( FOLLOW_expression_list_in_partition_extension_clause56_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_as_key_in_column_alias85_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_as_key_in_column_alias85( FOLLOW_as_key_in_column_alias85_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_column_alias90_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_column_alias90( FOLLOW_id_in_column_alias90_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_alias_quoted_string_in_column_alias94_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_alias_quoted_string_in_column_alias94( FOLLOW_alias_quoted_string_in_column_alias94_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_as_key_in_column_alias107_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_as_key_in_column_alias107( FOLLOW_as_key_in_column_alias107_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_table_alias129_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_table_alias129( FOLLOW_id_in_table_alias129_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_alias_quoted_string_in_table_alias133_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_alias_quoted_string_in_table_alias133( FOLLOW_alias_quoted_string_in_table_alias133_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_alias_quoted_string155_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_alias_quoted_string155( FOLLOW_quoted_string_in_alias_quoted_string155_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_where_key_in_where_clause175_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B88240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_where_key_in_where_clause175( FOLLOW_where_key_in_where_clause175_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_current_of_clause_in_where_clause178_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_current_of_clause_in_where_clause178( FOLLOW_current_of_clause_in_where_clause178_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_condition_wrapper_in_where_clause180_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_condition_wrapper_in_where_clause180( FOLLOW_condition_wrapper_in_where_clause180_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_current_key_in_current_of_clause201_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1000000000000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_current_key_in_current_of_clause201( FOLLOW_current_key_in_current_of_clause201_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_of_key_in_current_of_clause203_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_of_key_in_current_of_clause203( FOLLOW_of_key_in_current_of_clause203_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_cursor_name_in_current_of_clause205_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_cursor_name_in_current_of_clause205( FOLLOW_cursor_name_in_current_of_clause205_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_into_key_in_into_clause225_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_into_key_in_into_clause225( FOLLOW_into_key_in_into_clause225_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_variable_name_in_into_clause227_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_variable_name_in_into_clause227( FOLLOW_variable_name_in_into_clause227_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_into_clause230_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_into_clause230( FOLLOW_COMMA_in_into_clause230_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_variable_name_in_into_clause232_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_variable_name_in_into_clause232( FOLLOW_variable_name_in_into_clause232_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bulk_key_in_into_clause246_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bulk_key_in_into_clause246( FOLLOW_bulk_key_in_into_clause246_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_collect_key_in_into_clause248_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_collect_key_in_into_clause248( FOLLOW_collect_key_in_into_clause248_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_into_key_in_into_clause250_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_into_key_in_into_clause250( FOLLOW_into_key_in_into_clause250_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_variable_name_in_into_clause252_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_variable_name_in_into_clause252( FOLLOW_variable_name_in_into_clause252_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_into_clause255_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_into_clause255( FOLLOW_COMMA_in_into_clause255_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_variable_name_in_into_clause257_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_variable_name_in_into_clause257( FOLLOW_variable_name_in_into_clause257_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_xml_column_name284_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_xml_column_name284( FOLLOW_id_in_xml_column_name284_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_xml_column_name295_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_xml_column_name295( FOLLOW_quoted_string_in_xml_column_name295_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_cost_class_name315_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_cost_class_name315( FOLLOW_id_in_cost_class_name315_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_attribute_name335_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_attribute_name335( FOLLOW_id_in_attribute_name335_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_savepoint_name355_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_savepoint_name355( FOLLOW_id_in_savepoint_name355_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_rollback_segment_name375_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_rollback_segment_name375( FOLLOW_id_in_rollback_segment_name375_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_table_var_name396_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_table_var_name396( FOLLOW_id_in_table_var_name396_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_schema_name416_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_schema_name416( FOLLOW_id_in_schema_name416_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_routine_name436_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000102) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_routine_name436( FOLLOW_id_in_routine_name436_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_routine_name446_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_routine_name446( FOLLOW_PERIOD_in_routine_name446_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_routine_name448_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000102) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_routine_name448( FOLLOW_id_expression_in_routine_name448_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_AT_SIGN_in_routine_name453_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_AT_SIGN_in_routine_name453( FOLLOW_AT_SIGN_in_routine_name453_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_link_name_in_routine_name455_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_link_name_in_routine_name455( FOLLOW_link_name_in_routine_name455_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_package_name477_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_package_name477( FOLLOW_id_in_package_name477_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_implementation_type_name497_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_implementation_type_name497( FOLLOW_id_in_implementation_type_name497_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_implementation_type_name507_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_implementation_type_name507( FOLLOW_PERIOD_in_implementation_type_name507_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_implementation_type_name509_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_implementation_type_name509( FOLLOW_id_expression_in_implementation_type_name509_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_parameter_name531_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_parameter_name531( FOLLOW_id_in_parameter_name531_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_reference_model_name551_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_reference_model_name551( FOLLOW_id_in_reference_model_name551_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_main_model_name571_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_main_model_name571( FOLLOW_id_in_main_model_name571_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_aggregate_function_name591_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_aggregate_function_name591( FOLLOW_id_in_aggregate_function_name591_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_aggregate_function_name601_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_aggregate_function_name601( FOLLOW_PERIOD_in_aggregate_function_name601_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_aggregate_function_name603_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_aggregate_function_name603( FOLLOW_id_expression_in_aggregate_function_name603_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_query_name625_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_query_name625( FOLLOW_id_in_query_name625_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_constraint_name645_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000102) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_constraint_name645( FOLLOW_id_in_constraint_name645_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_constraint_name655_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_constraint_name655( FOLLOW_PERIOD_in_constraint_name655_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_constraint_name657_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000102) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_constraint_name657( FOLLOW_id_expression_in_constraint_name657_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_AT_SIGN_in_constraint_name662_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_AT_SIGN_in_constraint_name662( FOLLOW_AT_SIGN_in_constraint_name662_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_link_name_in_constraint_name664_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_link_name_in_constraint_name664( FOLLOW_link_name_in_constraint_name664_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_label_name686_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_label_name686( FOLLOW_id_expression_in_label_name686_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_type_name706_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_type_name706( FOLLOW_id_expression_in_type_name706_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_type_name716_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_type_name716( FOLLOW_PERIOD_in_type_name716_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_type_name718_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_type_name718( FOLLOW_id_expression_in_type_name718_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_sequence_name740_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_sequence_name740( FOLLOW_id_expression_in_sequence_name740_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_sequence_name750_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_sequence_name750( FOLLOW_PERIOD_in_sequence_name750_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_sequence_name752_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_sequence_name752( FOLLOW_id_expression_in_sequence_name752_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_exception_name774_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_exception_name774( FOLLOW_id_in_exception_name774_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_exception_name784_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_exception_name784( FOLLOW_PERIOD_in_exception_name784_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_exception_name786_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_exception_name786( FOLLOW_id_expression_in_exception_name786_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_function_name809_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_function_name809( FOLLOW_id_in_function_name809_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_function_name819_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_function_name819( FOLLOW_PERIOD_in_function_name819_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_function_name821_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_function_name821( FOLLOW_id_expression_in_function_name821_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_procedure_name843_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_procedure_name843( FOLLOW_id_in_procedure_name843_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_procedure_name853_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_procedure_name853( FOLLOW_PERIOD_in_procedure_name853_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_procedure_name855_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_procedure_name855( FOLLOW_id_expression_in_procedure_name855_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_trigger_name877_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_trigger_name877( FOLLOW_id_in_trigger_name877_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_trigger_name887_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_trigger_name887( FOLLOW_PERIOD_in_trigger_name887_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_trigger_name889_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_trigger_name889( FOLLOW_id_expression_in_trigger_name889_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_INTRODUCER_in_variable_name912_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_INTRODUCER_in_variable_name912( FOLLOW_INTRODUCER_in_variable_name912_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_char_set_name_in_variable_name914_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_char_set_name_in_variable_name914( FOLLOW_char_set_name_in_variable_name914_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_variable_name930_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_variable_name930( FOLLOW_id_expression_in_variable_name930_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_variable_name940_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_variable_name940( FOLLOW_PERIOD_in_variable_name940_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_variable_name942_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_variable_name942( FOLLOW_id_expression_in_variable_name942_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_variable_name955_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_variable_name955( FOLLOW_bind_variable_in_variable_name955_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_index_name975_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_index_name975( FOLLOW_id_in_index_name975_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_cursor_name995_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_cursor_name995( FOLLOW_id_in_cursor_name995_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_cursor_name1006_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_cursor_name1006( FOLLOW_bind_variable_in_cursor_name1006_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_record_name1026_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_record_name1026( FOLLOW_id_in_record_name1026_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_record_name1037_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_record_name1037( FOLLOW_bind_variable_in_record_name1037_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_collection_name1057_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_collection_name1057( FOLLOW_id_in_collection_name1057_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_collection_name1067_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_collection_name1067( FOLLOW_PERIOD_in_collection_name1067_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_collection_name1069_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_collection_name1069( FOLLOW_id_expression_in_collection_name1069_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_link_name1091_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_link_name1091( FOLLOW_id_in_link_name1091_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_column_name1111_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_column_name1111( FOLLOW_id_in_column_name1111_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_column_name1121_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_column_name1121( FOLLOW_PERIOD_in_column_name1121_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_column_name1123_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_column_name1123( FOLLOW_id_expression_in_column_name1123_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_tableview_name1145_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000102), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_tableview_name1145( FOLLOW_id_in_tableview_name1145_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_tableview_name1155_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_tableview_name1155( FOLLOW_PERIOD_in_tableview_name1155_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_tableview_name1157_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000102), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_tableview_name1157( FOLLOW_id_expression_in_tableview_name1157_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_AT_SIGN_in_tableview_name1171_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_AT_SIGN_in_tableview_name1171( FOLLOW_AT_SIGN_in_tableview_name1171_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_link_name_in_tableview_name1173_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_link_name_in_tableview_name1173( FOLLOW_link_name_in_tableview_name1173_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_partition_extension_clause_in_tableview_name1187_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_partition_extension_clause_in_tableview_name1187( FOLLOW_partition_extension_clause_in_tableview_name1187_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_char_set_name1214_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_char_set_name1214( FOLLOW_id_expression_in_char_set_name1214_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_char_set_name1224_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_char_set_name1224( FOLLOW_PERIOD_in_char_set_name1224_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_char_set_name1226_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_char_set_name1226( FOLLOW_id_expression_in_char_set_name1226_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_keep_key_in_keep_clause1252_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_keep_key_in_keep_clause1252( FOLLOW_keep_key_in_keep_clause1252_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_keep_clause1262_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_keep_clause1262( FOLLOW_LEFT_PAREN_in_keep_clause1262_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_dense_rank_key_in_keep_clause1276_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_dense_rank_key_in_keep_clause1276( FOLLOW_dense_rank_key_in_keep_clause1276_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_first_key_in_keep_clause1279_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_first_key_in_keep_clause1279( FOLLOW_first_key_in_keep_clause1279_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_last_key_in_keep_clause1281_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_last_key_in_keep_clause1281( FOLLOW_last_key_in_keep_clause1281_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_keep_clause1297_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_order_by_clause_in_keep_clause1297( FOLLOW_order_by_clause_in_keep_clause1297_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_keep_clause1307_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_keep_clause1307( FOLLOW_RIGHT_PAREN_in_keep_clause1307_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_over_clause_in_keep_clause1309_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_over_clause_in_keep_clause1309( FOLLOW_over_clause_in_keep_clause1309_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_function_argument1330_bits[]	= { ANTLR_UINT64_LIT(0x000000865044F220), ANTLR_UINT64_LIT(0x0C00184B08241401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_function_argument1330( FOLLOW_LEFT_PAREN_in_function_argument1330_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_argument_in_function_argument1345_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_argument_in_function_argument1345( FOLLOW_argument_in_function_argument1345_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_function_argument1349_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_function_argument1349( FOLLOW_COMMA_in_function_argument1349_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_argument_in_function_argument1351_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_argument_in_function_argument1351( FOLLOW_argument_in_function_argument1351_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_function_argument1365_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_function_argument1365( FOLLOW_RIGHT_PAREN_in_function_argument1365_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_keep_clause_in_function_argument1375_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_keep_clause_in_function_argument1375( FOLLOW_keep_clause_in_function_argument1375_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_function_argument_analytic1396_bits[]	= { ANTLR_UINT64_LIT(0x000000865044F220), ANTLR_UINT64_LIT(0x0C00184B08241401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_function_argument_analytic1396( FOLLOW_LEFT_PAREN_in_function_argument_analytic1396_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_argument_in_function_argument_analytic1411_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_argument_in_function_argument_analytic1411( FOLLOW_argument_in_function_argument_analytic1411_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic1413_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic1413( FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic1413_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_function_argument_analytic1431_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_function_argument_analytic1431( FOLLOW_COMMA_in_function_argument_analytic1431_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_argument_in_function_argument_analytic1433_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_argument_in_function_argument_analytic1433( FOLLOW_argument_in_function_argument_analytic1433_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic1435_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic1435( FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic1435_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_function_argument_analytic1450_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_function_argument_analytic1450( FOLLOW_RIGHT_PAREN_in_function_argument_analytic1450_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_keep_clause_in_function_argument_analytic1461_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_keep_clause_in_function_argument_analytic1461( FOLLOW_keep_clause_in_function_argument_analytic1461_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_function_argument_modeling1482_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_function_argument_modeling1482( FOLLOW_LEFT_PAREN_in_function_argument_modeling1482_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_column_name_in_function_argument_modeling1496_bits[]	= { ANTLR_UINT64_LIT(0x0000100000008000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_column_name_in_function_argument_modeling1496( FOLLOW_column_name_in_function_argument_modeling1496_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_function_argument_modeling1499_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400020), ANTLR_UINT64_LIT(0x0800000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_function_argument_modeling1499( FOLLOW_COMMA_in_function_argument_modeling1499_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_numeric_in_function_argument_modeling1502_bits[]	= { ANTLR_UINT64_LIT(0x0000100000008000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_numeric_in_function_argument_modeling1502( FOLLOW_numeric_in_function_argument_modeling1502_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_null_key_in_function_argument_modeling1504_bits[]	= { ANTLR_UINT64_LIT(0x0000100000008000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_null_key_in_function_argument_modeling1504( FOLLOW_null_key_in_function_argument_modeling1504_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_function_argument_modeling1508_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400020), ANTLR_UINT64_LIT(0x0800000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_function_argument_modeling1508( FOLLOW_COMMA_in_function_argument_modeling1508_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_numeric_in_function_argument_modeling1511_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_numeric_in_function_argument_modeling1511( FOLLOW_numeric_in_function_argument_modeling1511_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_null_key_in_function_argument_modeling1513_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_null_key_in_function_argument_modeling1513( FOLLOW_null_key_in_function_argument_modeling1513_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_using_key_in_function_argument_modeling1534_bits[]	= { ANTLR_UINT64_LIT(0x00000086504472A0), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_using_key_in_function_argument_modeling1534( FOLLOW_using_key_in_function_argument_modeling1534_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_function_argument_modeling1563_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_tableview_name_in_function_argument_modeling1563( FOLLOW_tableview_name_in_function_argument_modeling1563_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_function_argument_modeling1565_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_function_argument_modeling1565( FOLLOW_PERIOD_in_function_argument_modeling1565_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_function_argument_modeling1567_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_ASTERISK_in_function_argument_modeling1567( FOLLOW_ASTERISK_in_function_argument_modeling1567_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_function_argument_modeling1587_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_ASTERISK_in_function_argument_modeling1587( FOLLOW_ASTERISK_in_function_argument_modeling1587_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_expression_in_function_argument_modeling1607_bits[]	= { ANTLR_UINT64_LIT(0x000000041004B000), ANTLR_UINT64_LIT(0x0000000000401400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_expression_in_function_argument_modeling1607( FOLLOW_expression_in_function_argument_modeling1607_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_function_argument_modeling1609_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_column_alias_in_function_argument_modeling1609( FOLLOW_column_alias_in_function_argument_modeling1609_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_function_argument_modeling1613_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_function_argument_modeling1613( FOLLOW_COMMA_in_function_argument_modeling1613_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_expression_in_function_argument_modeling1615_bits[]	= { ANTLR_UINT64_LIT(0x000000041004B000), ANTLR_UINT64_LIT(0x0000000000401400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_expression_in_function_argument_modeling1615( FOLLOW_expression_in_function_argument_modeling1615_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_function_argument_modeling1617_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_column_alias_in_function_argument_modeling1617( FOLLOW_column_alias_in_function_argument_modeling1617_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_function_argument_modeling1649_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_function_argument_modeling1649( FOLLOW_RIGHT_PAREN_in_function_argument_modeling1649_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_keep_clause_in_function_argument_modeling1660_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_keep_clause_in_function_argument_modeling1660( FOLLOW_keep_clause_in_function_argument_modeling1660_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_respect_key_in_respect_or_ignore_nulls1682_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_respect_key_in_respect_or_ignore_nulls1682( FOLLOW_respect_key_in_respect_or_ignore_nulls1682_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_ignore_key_in_respect_or_ignore_nulls1686_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_ignore_key_in_respect_or_ignore_nulls1686( FOLLOW_ignore_key_in_respect_or_ignore_nulls1686_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_respect_or_ignore_nulls1689_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_nulls_key_in_respect_or_ignore_nulls1689( FOLLOW_nulls_key_in_respect_or_ignore_nulls1689_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_argument1719_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_argument1719( FOLLOW_id_in_argument1719_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_argument1721_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_argument1721( FOLLOW_EQUALS_OP_in_argument1721_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OP_in_argument1723_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_GREATER_THAN_OP_in_argument1723( FOLLOW_GREATER_THAN_OP_in_argument1723_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_argument1727_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_expression_wrapper_in_argument1727( FOLLOW_expression_wrapper_in_argument1727_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_datatype_in_type_spec1748_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_datatype_in_type_spec1748( FOLLOW_datatype_in_type_spec1748_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_ref_key_in_type_spec1759_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_ref_key_in_type_spec1759( FOLLOW_ref_key_in_type_spec1759_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_type_name_in_type_spec1762_bits[]	= { ANTLR_UINT64_LIT(0x0000002000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_type_name_in_type_spec1762( FOLLOW_type_name_in_type_spec1762_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_percent_rowtype_key_in_type_spec1765_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_percent_rowtype_key_in_type_spec1765( FOLLOW_percent_rowtype_key_in_type_spec1765_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_percent_type_key_in_type_spec1767_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_percent_type_key_in_type_spec1767( FOLLOW_percent_type_key_in_type_spec1767_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_native_datatype_element_in_datatype1789_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_native_datatype_element_in_datatype1789( FOLLOW_native_datatype_element_in_datatype1789_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_precision_part_in_datatype1799_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_precision_part_in_datatype1799( FOLLOW_precision_part_in_datatype1799_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_with_key_in_datatype1811_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_with_key_in_datatype1811( FOLLOW_with_key_in_datatype1811_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_local_key_in_datatype1813_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_local_key_in_datatype1813( FOLLOW_local_key_in_datatype1813_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_time_key_in_datatype1816_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_time_key_in_datatype1816( FOLLOW_time_key_in_datatype1816_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_zone_key_in_datatype1818_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_zone_key_in_datatype1818( FOLLOW_zone_key_in_datatype1818_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_interval_key_in_datatype1831_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_interval_key_in_datatype1831( FOLLOW_interval_key_in_datatype1831_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_year_key_in_datatype1834_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_year_key_in_datatype1834( FOLLOW_year_key_in_datatype1834_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_day_key_in_datatype1836_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_day_key_in_datatype1836( FOLLOW_day_key_in_datatype1836_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_datatype1856_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_datatype1856( FOLLOW_LEFT_PAREN_in_datatype1856_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_datatype1858_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_expression_wrapper_in_datatype1858( FOLLOW_expression_wrapper_in_datatype1858_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_datatype1860_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_datatype1860( FOLLOW_RIGHT_PAREN_in_datatype1860_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_to_key_in_datatype1877_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_to_key_in_datatype1877( FOLLOW_to_key_in_datatype1877_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_month_key_in_datatype1880_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_month_key_in_datatype1880( FOLLOW_month_key_in_datatype1880_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_second_key_in_datatype1882_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_second_key_in_datatype1882( FOLLOW_second_key_in_datatype1882_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_datatype1903_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_datatype1903( FOLLOW_LEFT_PAREN_in_datatype1903_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_datatype1905_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_expression_wrapper_in_datatype1905( FOLLOW_expression_wrapper_in_datatype1905_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_datatype1907_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_datatype1907( FOLLOW_RIGHT_PAREN_in_datatype1907_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_precision_part1929_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400020), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_precision_part1929( FOLLOW_LEFT_PAREN_in_precision_part1929_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_numeric_in_precision_part1931_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_numeric_in_precision_part1931( FOLLOW_numeric_in_precision_part1931_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_precision_part1934_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400020), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_precision_part1934( FOLLOW_COMMA_in_precision_part1934_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_numeric_in_precision_part1936_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_numeric_in_precision_part1936( FOLLOW_numeric_in_precision_part1936_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_char_key_in_precision_part1941_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_char_key_in_precision_part1941( FOLLOW_char_key_in_precision_part1941_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_byte_key_in_precision_part1945_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_byte_key_in_precision_part1945( FOLLOW_byte_key_in_precision_part1945_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_precision_part1949_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_precision_part1949( FOLLOW_RIGHT_PAREN_in_precision_part1949_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_binary_integer_key_in_native_datatype_element1969_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_binary_integer_key_in_native_datatype_element1969( FOLLOW_binary_integer_key_in_native_datatype_element1969_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_pls_integer_key_in_native_datatype_element1980_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_pls_integer_key_in_native_datatype_element1980( FOLLOW_pls_integer_key_in_native_datatype_element1980_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_natural_key_in_native_datatype_element1991_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_natural_key_in_native_datatype_element1991( FOLLOW_natural_key_in_native_datatype_element1991_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_binary_float_key_in_native_datatype_element2002_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_binary_float_key_in_native_datatype_element2002( FOLLOW_binary_float_key_in_native_datatype_element2002_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_binary_double_key_in_native_datatype_element2013_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_binary_double_key_in_native_datatype_element2013( FOLLOW_binary_double_key_in_native_datatype_element2013_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_naturaln_key_in_native_datatype_element2024_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_naturaln_key_in_native_datatype_element2024( FOLLOW_naturaln_key_in_native_datatype_element2024_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_positive_key_in_native_datatype_element2035_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_positive_key_in_native_datatype_element2035( FOLLOW_positive_key_in_native_datatype_element2035_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_positiven_key_in_native_datatype_element2046_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_positiven_key_in_native_datatype_element2046( FOLLOW_positiven_key_in_native_datatype_element2046_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_signtype_key_in_native_datatype_element2057_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_signtype_key_in_native_datatype_element2057( FOLLOW_signtype_key_in_native_datatype_element2057_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_simple_integer_key_in_native_datatype_element2068_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_simple_integer_key_in_native_datatype_element2068( FOLLOW_simple_integer_key_in_native_datatype_element2068_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_nvarchar2_key_in_native_datatype_element2079_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_nvarchar2_key_in_native_datatype_element2079( FOLLOW_nvarchar2_key_in_native_datatype_element2079_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_dec_key_in_native_datatype_element2090_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_dec_key_in_native_datatype_element2090( FOLLOW_dec_key_in_native_datatype_element2090_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_integer_key_in_native_datatype_element2101_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_integer_key_in_native_datatype_element2101( FOLLOW_integer_key_in_native_datatype_element2101_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_int_key_in_native_datatype_element2112_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_int_key_in_native_datatype_element2112( FOLLOW_int_key_in_native_datatype_element2112_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_numeric_key_in_native_datatype_element2123_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_numeric_key_in_native_datatype_element2123( FOLLOW_numeric_key_in_native_datatype_element2123_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_smallint_key_in_native_datatype_element2134_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_smallint_key_in_native_datatype_element2134( FOLLOW_smallint_key_in_native_datatype_element2134_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_number_key_in_native_datatype_element2145_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_number_key_in_native_datatype_element2145( FOLLOW_number_key_in_native_datatype_element2145_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_decimal_key_in_native_datatype_element2156_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_decimal_key_in_native_datatype_element2156( FOLLOW_decimal_key_in_native_datatype_element2156_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_double_key_in_native_datatype_element2168_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_double_key_in_native_datatype_element2168( FOLLOW_double_key_in_native_datatype_element2168_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_precision_key_in_native_datatype_element2170_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_precision_key_in_native_datatype_element2170( FOLLOW_precision_key_in_native_datatype_element2170_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_float_key_in_native_datatype_element2182_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_float_key_in_native_datatype_element2182( FOLLOW_float_key_in_native_datatype_element2182_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_real_key_in_native_datatype_element2193_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_real_key_in_native_datatype_element2193( FOLLOW_real_key_in_native_datatype_element2193_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_nchar_key_in_native_datatype_element2204_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_nchar_key_in_native_datatype_element2204( FOLLOW_nchar_key_in_native_datatype_element2204_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_long_key_in_native_datatype_element2215_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_long_key_in_native_datatype_element2215( FOLLOW_long_key_in_native_datatype_element2215_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_raw_key_in_native_datatype_element2217_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_raw_key_in_native_datatype_element2217( FOLLOW_raw_key_in_native_datatype_element2217_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_char_key_in_native_datatype_element2229_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_char_key_in_native_datatype_element2229( FOLLOW_char_key_in_native_datatype_element2229_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_character_key_in_native_datatype_element2242_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_character_key_in_native_datatype_element2242( FOLLOW_character_key_in_native_datatype_element2242_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_varchar2_key_in_native_datatype_element2254_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_varchar2_key_in_native_datatype_element2254( FOLLOW_varchar2_key_in_native_datatype_element2254_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_varchar_key_in_native_datatype_element2265_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_varchar_key_in_native_datatype_element2265( FOLLOW_varchar_key_in_native_datatype_element2265_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_string_key_in_native_datatype_element2276_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_string_key_in_native_datatype_element2276( FOLLOW_string_key_in_native_datatype_element2276_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_raw_key_in_native_datatype_element2287_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_raw_key_in_native_datatype_element2287( FOLLOW_raw_key_in_native_datatype_element2287_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_boolean_key_in_native_datatype_element2298_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_boolean_key_in_native_datatype_element2298( FOLLOW_boolean_key_in_native_datatype_element2298_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_date_key_in_native_datatype_element2309_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_date_key_in_native_datatype_element2309( FOLLOW_date_key_in_native_datatype_element2309_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_rowid_key_in_native_datatype_element2320_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_rowid_key_in_native_datatype_element2320( FOLLOW_rowid_key_in_native_datatype_element2320_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_urowid_key_in_native_datatype_element2331_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_urowid_key_in_native_datatype_element2331( FOLLOW_urowid_key_in_native_datatype_element2331_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_year_key_in_native_datatype_element2342_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_year_key_in_native_datatype_element2342( FOLLOW_year_key_in_native_datatype_element2342_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_month_key_in_native_datatype_element2353_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_month_key_in_native_datatype_element2353( FOLLOW_month_key_in_native_datatype_element2353_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_day_key_in_native_datatype_element2364_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_day_key_in_native_datatype_element2364( FOLLOW_day_key_in_native_datatype_element2364_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_hour_key_in_native_datatype_element2375_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_hour_key_in_native_datatype_element2375( FOLLOW_hour_key_in_native_datatype_element2375_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_minute_key_in_native_datatype_element2386_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_minute_key_in_native_datatype_element2386( FOLLOW_minute_key_in_native_datatype_element2386_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_second_key_in_native_datatype_element2397_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_second_key_in_native_datatype_element2397( FOLLOW_second_key_in_native_datatype_element2397_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_timezone_hour_key_in_native_datatype_element2408_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_timezone_hour_key_in_native_datatype_element2408( FOLLOW_timezone_hour_key_in_native_datatype_element2408_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_timezone_minute_key_in_native_datatype_element2419_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_timezone_minute_key_in_native_datatype_element2419( FOLLOW_timezone_minute_key_in_native_datatype_element2419_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_timezone_region_key_in_native_datatype_element2430_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_timezone_region_key_in_native_datatype_element2430( FOLLOW_timezone_region_key_in_native_datatype_element2430_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_timezone_abbr_key_in_native_datatype_element2441_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_timezone_abbr_key_in_native_datatype_element2441( FOLLOW_timezone_abbr_key_in_native_datatype_element2441_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_timestamp_key_in_native_datatype_element2452_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_timestamp_key_in_native_datatype_element2452( FOLLOW_timestamp_key_in_native_datatype_element2452_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_timestamp_unconstrained_key_in_native_datatype_element2463_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_timestamp_unconstrained_key_in_native_datatype_element2463( FOLLOW_timestamp_unconstrained_key_in_native_datatype_element2463_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_timestamp_tz_unconstrained_key_in_native_datatype_element2474_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_timestamp_tz_unconstrained_key_in_native_datatype_element2474( FOLLOW_timestamp_tz_unconstrained_key_in_native_datatype_element2474_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_timestamp_ltz_unconstrained_key_in_native_datatype_element2485_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_timestamp_ltz_unconstrained_key_in_native_datatype_element2485( FOLLOW_timestamp_ltz_unconstrained_key_in_native_datatype_element2485_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_yminterval_unconstrained_key_in_native_datatype_element2496_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_yminterval_unconstrained_key_in_native_datatype_element2496( FOLLOW_yminterval_unconstrained_key_in_native_datatype_element2496_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_dsinterval_unconstrained_key_in_native_datatype_element2507_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_dsinterval_unconstrained_key_in_native_datatype_element2507( FOLLOW_dsinterval_unconstrained_key_in_native_datatype_element2507_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bfile_key_in_native_datatype_element2518_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bfile_key_in_native_datatype_element2518( FOLLOW_bfile_key_in_native_datatype_element2518_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_blob_key_in_native_datatype_element2529_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_blob_key_in_native_datatype_element2529( FOLLOW_blob_key_in_native_datatype_element2529_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_clob_key_in_native_datatype_element2540_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_clob_key_in_native_datatype_element2540( FOLLOW_clob_key_in_native_datatype_element2540_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_nclob_key_in_native_datatype_element2551_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_nclob_key_in_native_datatype_element2551( FOLLOW_nclob_key_in_native_datatype_element2551_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_mlslabel_key_in_native_datatype_element2562_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_mlslabel_key_in_native_datatype_element2562( FOLLOW_mlslabel_key_in_native_datatype_element2562_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_BINDVAR_in_bind_variable2584_bits[]	= { ANTLR_UINT64_LIT(0x0000004000004202), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_BINDVAR_in_bind_variable2584( FOLLOW_BINDVAR_in_bind_variable2584_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COLON_in_bind_variable2588_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COLON_in_bind_variable2588( FOLLOW_COLON_in_bind_variable2588_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_bind_variable2590_bits[]	= { ANTLR_UINT64_LIT(0x0000004000004202), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_bind_variable2590( FOLLOW_UNSIGNED_INTEGER_in_bind_variable2590_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_indicator_key_in_bind_variable2604_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004200) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_indicator_key_in_bind_variable2604( FOLLOW_indicator_key_in_bind_variable2604_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_BINDVAR_in_bind_variable2608_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_BINDVAR_in_bind_variable2608( FOLLOW_BINDVAR_in_bind_variable2608_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COLON_in_bind_variable2612_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COLON_in_bind_variable2612( FOLLOW_COLON_in_bind_variable2612_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_bind_variable2614_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_bind_variable2614( FOLLOW_UNSIGNED_INTEGER_in_bind_variable2614_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_bind_variable2636_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_bind_variable2636( FOLLOW_PERIOD_in_bind_variable2636_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_bind_variable2638_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_general_element_part_in_bind_variable2638( FOLLOW_general_element_part_in_bind_variable2638_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_general_element2660_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_general_element_part_in_general_element2660( FOLLOW_general_element_part_in_general_element2660_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_general_element2670_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_general_element2670( FOLLOW_PERIOD_in_general_element2670_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_general_element2672_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_general_element_part_in_general_element2672( FOLLOW_general_element_part_in_general_element2672_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_INTRODUCER_in_general_element_part2695_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_INTRODUCER_in_general_element_part2695( FOLLOW_INTRODUCER_in_general_element_part2695_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_char_set_name_in_general_element_part2697_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_char_set_name_in_general_element_part2697( FOLLOW_char_set_name_in_general_element_part2697_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_general_element_part2701_bits[]	= { ANTLR_UINT64_LIT(0x0000004040000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_general_element_part2701( FOLLOW_id_expression_in_general_element_part2701_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_general_element_part2723_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_general_element_part2723( FOLLOW_PERIOD_in_general_element_part2723_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_general_element_part2725_bits[]	= { ANTLR_UINT64_LIT(0x0000004040000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_general_element_part2725( FOLLOW_id_expression_in_general_element_part2725_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_function_argument_in_general_element_part2729_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_function_argument_in_general_element_part2729( FOLLOW_function_argument_in_general_element_part2729_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_INTRODUCER_in_table_element2751_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_INTRODUCER_in_table_element2751( FOLLOW_INTRODUCER_in_table_element2751_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_char_set_name_in_table_element2753_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_char_set_name_in_table_element2753( FOLLOW_char_set_name_in_table_element2753_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_table_element2757_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_table_element2757( FOLLOW_id_expression_in_table_element2757_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_table_element2760_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_table_element2760( FOLLOW_PERIOD_in_table_element2760_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_table_element2762_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_table_element2762( FOLLOW_id_expression_in_table_element2762_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_timestamp_key_in_constant2788_bits[]	= { ANTLR_UINT64_LIT(0x0000000400007200) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_timestamp_key_in_constant2788( FOLLOW_timestamp_key_in_constant2788_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_constant2791_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_constant2791( FOLLOW_quoted_string_in_constant2791_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_constant2795_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_constant2795( FOLLOW_bind_variable_in_constant2795_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_at_key_in_constant2799_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_at_key_in_constant2799( FOLLOW_at_key_in_constant2799_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_time_key_in_constant2801_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_time_key_in_constant2801( FOLLOW_time_key_in_constant2801_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_zone_key_in_constant2803_bits[]	= { ANTLR_UINT64_LIT(0x0000000400003000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_zone_key_in_constant2803( FOLLOW_zone_key_in_constant2803_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_constant2805_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_constant2805( FOLLOW_quoted_string_in_constant2805_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_interval_key_in_constant2818_bits[]	= { ANTLR_UINT64_LIT(0x0000000410047200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_interval_key_in_constant2818( FOLLOW_interval_key_in_constant2818_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_constant2821_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_constant2821( FOLLOW_quoted_string_in_constant2821_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_constant2825_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_constant2825( FOLLOW_bind_variable_in_constant2825_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_constant2829_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_general_element_part_in_constant2829( FOLLOW_general_element_part_in_constant2829_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_day_key_in_constant2843_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_day_key_in_constant2843( FOLLOW_day_key_in_constant2843_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_hour_key_in_constant2847_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_hour_key_in_constant2847( FOLLOW_hour_key_in_constant2847_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_minute_key_in_constant2851_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_minute_key_in_constant2851( FOLLOW_minute_key_in_constant2851_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_second_key_in_constant2855_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_second_key_in_constant2855( FOLLOW_second_key_in_constant2855_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_constant2869_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004200), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_constant2869( FOLLOW_LEFT_PAREN_in_constant2869_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_constant2872_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_constant2872( FOLLOW_UNSIGNED_INTEGER_in_constant2872_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_constant2876_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_constant2876( FOLLOW_bind_variable_in_constant2876_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_constant2880_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004200), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_constant2880( FOLLOW_COMMA_in_constant2880_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_constant2883_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_constant2883( FOLLOW_UNSIGNED_INTEGER_in_constant2883_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_constant2887_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_constant2887( FOLLOW_bind_variable_in_constant2887_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_constant2893_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_constant2893( FOLLOW_RIGHT_PAREN_in_constant2893_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_to_key_in_constant2908_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_to_key_in_constant2908( FOLLOW_to_key_in_constant2908_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_day_key_in_constant2925_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_day_key_in_constant2925( FOLLOW_day_key_in_constant2925_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_hour_key_in_constant2929_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_hour_key_in_constant2929( FOLLOW_hour_key_in_constant2929_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_minute_key_in_constant2933_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_minute_key_in_constant2933( FOLLOW_minute_key_in_constant2933_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_second_key_in_constant2937_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_second_key_in_constant2937( FOLLOW_second_key_in_constant2937_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_constant2940_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004200), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_constant2940( FOLLOW_LEFT_PAREN_in_constant2940_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_constant2943_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_constant2943( FOLLOW_UNSIGNED_INTEGER_in_constant2943_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_constant2947_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_constant2947( FOLLOW_bind_variable_in_constant2947_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_constant2950_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_constant2950( FOLLOW_RIGHT_PAREN_in_constant2950_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_numeric_in_constant2977_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_numeric_in_constant2977( FOLLOW_numeric_in_constant2977_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_date_key_in_constant2988_bits[]	= { ANTLR_UINT64_LIT(0x0000000400003000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_date_key_in_constant2988( FOLLOW_date_key_in_constant2988_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_constant2990_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_constant2990( FOLLOW_quoted_string_in_constant2990_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_constant3001_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_constant3001( FOLLOW_quoted_string_in_constant3001_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_null_key_in_constant3012_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_null_key_in_constant3012( FOLLOW_null_key_in_constant3012_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_true_key_in_constant3023_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_true_key_in_constant3023( FOLLOW_true_key_in_constant3023_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_false_key_in_constant3034_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_false_key_in_constant3034( FOLLOW_false_key_in_constant3034_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_dbtimezone_key_in_constant3045_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_dbtimezone_key_in_constant3045( FOLLOW_dbtimezone_key_in_constant3045_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_sessiontimezone_key_in_constant3057_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_sessiontimezone_key_in_constant3057( FOLLOW_sessiontimezone_key_in_constant3057_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_minvalue_key_in_constant3068_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_minvalue_key_in_constant3068( FOLLOW_minvalue_key_in_constant3068_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_maxvalue_key_in_constant3079_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_maxvalue_key_in_constant3079( FOLLOW_maxvalue_key_in_constant3079_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_default_key_in_constant3090_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_default_key_in_constant3090( FOLLOW_default_key_in_constant3090_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_INTRODUCER_in_id3190_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_INTRODUCER_in_id3190( FOLLOW_INTRODUCER_in_id3190_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_char_set_name_in_id3192_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_char_set_name_in_id3192( FOLLOW_char_set_name_in_id3192_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_id3204_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_id3204( FOLLOW_id_expression_in_id3204_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_NOT_EQUAL_OP_in_not_equal_op3255_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_NOT_EQUAL_OP_in_not_equal_op3255( FOLLOW_NOT_EQUAL_OP_in_not_equal_op3255_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LESS_THAN_OP_in_not_equal_op3266_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LESS_THAN_OP_in_not_equal_op3266( FOLLOW_LESS_THAN_OP_in_not_equal_op3266_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OP_in_not_equal_op3268_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_GREATER_THAN_OP_in_not_equal_op3268( FOLLOW_GREATER_THAN_OP_in_not_equal_op3268_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_EXCLAMATION_OPERATOR_PART_in_not_equal_op3279_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_EXCLAMATION_OPERATOR_PART_in_not_equal_op3279( FOLLOW_EXCLAMATION_OPERATOR_PART_in_not_equal_op3279_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_not_equal_op3281_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_not_equal_op3281( FOLLOW_EQUALS_OP_in_not_equal_op3281_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_CARRET_OPERATOR_PART_in_not_equal_op3292_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_CARRET_OPERATOR_PART_in_not_equal_op3292( FOLLOW_CARRET_OPERATOR_PART_in_not_equal_op3292_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_not_equal_op3294_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_not_equal_op3294( FOLLOW_EQUALS_OP_in_not_equal_op3294_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OR_EQUALS_OP_in_greater_than_or_equals_op3314_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_GREATER_THAN_OR_EQUALS_OP_in_greater_than_or_equals_op3314( FOLLOW_GREATER_THAN_OR_EQUALS_OP_in_greater_than_or_equals_op3314_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OP_in_greater_than_or_equals_op3325_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_GREATER_THAN_OP_in_greater_than_or_equals_op3325( FOLLOW_GREATER_THAN_OP_in_greater_than_or_equals_op3325_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_greater_than_or_equals_op3327_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_greater_than_or_equals_op3327( FOLLOW_EQUALS_OP_in_greater_than_or_equals_op3327_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LESS_THAN_OR_EQUALS_OP_in_less_than_or_equals_op3347_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LESS_THAN_OR_EQUALS_OP_in_less_than_or_equals_op3347( FOLLOW_LESS_THAN_OR_EQUALS_OP_in_less_than_or_equals_op3347_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LESS_THAN_OP_in_less_than_or_equals_op3358_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LESS_THAN_OP_in_less_than_or_equals_op3358( FOLLOW_LESS_THAN_OP_in_less_than_or_equals_op3358_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_less_than_or_equals_op3360_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_less_than_or_equals_op3360( FOLLOW_EQUALS_OP_in_less_than_or_equals_op3360_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_CONCATENATION_OP_in_concatenation_op3380_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_CONCATENATION_OP_in_concatenation_op3380( FOLLOW_CONCATENATION_OP_in_concatenation_op3380_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_VERTICAL_BAR_in_concatenation_op3391_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000001000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_VERTICAL_BAR_in_concatenation_op3391( FOLLOW_VERTICAL_BAR_in_concatenation_op3391_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_VERTICAL_BAR_in_concatenation_op3393_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_VERTICAL_BAR_in_concatenation_op3393( FOLLOW_VERTICAL_BAR_in_concatenation_op3393_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_multiset_key_in_multiset_op3414_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0040000000000400), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_multiset_key_in_multiset_op3414( FOLLOW_multiset_key_in_multiset_op3414_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_except_key_in_multiset_op3427_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000004000040000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_except_key_in_multiset_op3427( FOLLOW_except_key_in_multiset_op3427_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_intersect_key_in_multiset_op3431_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000004000040000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_intersect_key_in_multiset_op3431( FOLLOW_intersect_key_in_multiset_op3431_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_union_key_in_multiset_op3435_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000004000040000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_union_key_in_multiset_op3435( FOLLOW_union_key_in_multiset_op3435_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_all_key_in_multiset_op3450_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_all_key_in_multiset_op3450( FOLLOW_all_key_in_multiset_op3450_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_distinct_key_in_multiset_op3454_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_distinct_key_in_multiset_op3454( FOLLOW_distinct_key_in_multiset_op3454_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_outer_join_sign3477_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_outer_join_sign3477( FOLLOW_LEFT_PAREN_in_outer_join_sign3477_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PLUS_SIGN_in_outer_join_sign3479_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PLUS_SIGN_in_outer_join_sign3479( FOLLOW_PLUS_SIGN_in_outer_join_sign3479_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_outer_join_sign3481_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_outer_join_sign3481( FOLLOW_RIGHT_PAREN_in_outer_join_sign3481_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_as_key_in_synpred1_PLSQLCommons85_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_as_key_in_synpred1_PLSQLCommons85( FOLLOW_as_key_in_synpred1_PLSQLCommons85_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_synpred1_PLSQLCommons90_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_synpred1_PLSQLCommons90( FOLLOW_id_in_synpred1_PLSQLCommons90_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_alias_quoted_string_in_synpred1_PLSQLCommons94_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_alias_quoted_string_in_synpred1_PLSQLCommons94( FOLLOW_alias_quoted_string_in_synpred1_PLSQLCommons94_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred2_PLSQLCommons440_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred2_PLSQLCommons440( FOLLOW_PERIOD_in_synpred2_PLSQLCommons440_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred2_PLSQLCommons442_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred2_PLSQLCommons442( FOLLOW_id_expression_in_synpred2_PLSQLCommons442_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred3_PLSQLCommons501_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred3_PLSQLCommons501( FOLLOW_PERIOD_in_synpred3_PLSQLCommons501_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred3_PLSQLCommons503_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred3_PLSQLCommons503( FOLLOW_id_expression_in_synpred3_PLSQLCommons503_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred4_PLSQLCommons595_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred4_PLSQLCommons595( FOLLOW_PERIOD_in_synpred4_PLSQLCommons595_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred4_PLSQLCommons597_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred4_PLSQLCommons597( FOLLOW_id_expression_in_synpred4_PLSQLCommons597_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred5_PLSQLCommons649_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred5_PLSQLCommons649( FOLLOW_PERIOD_in_synpred5_PLSQLCommons649_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred5_PLSQLCommons651_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred5_PLSQLCommons651( FOLLOW_id_expression_in_synpred5_PLSQLCommons651_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred6_PLSQLCommons710_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred6_PLSQLCommons710( FOLLOW_PERIOD_in_synpred6_PLSQLCommons710_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred6_PLSQLCommons712_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred6_PLSQLCommons712( FOLLOW_id_expression_in_synpred6_PLSQLCommons712_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred7_PLSQLCommons744_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred7_PLSQLCommons744( FOLLOW_PERIOD_in_synpred7_PLSQLCommons744_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred7_PLSQLCommons746_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred7_PLSQLCommons746( FOLLOW_id_expression_in_synpred7_PLSQLCommons746_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred8_PLSQLCommons778_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred8_PLSQLCommons778( FOLLOW_PERIOD_in_synpred8_PLSQLCommons778_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred8_PLSQLCommons780_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred8_PLSQLCommons780( FOLLOW_id_expression_in_synpred8_PLSQLCommons780_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred9_PLSQLCommons813_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred9_PLSQLCommons813( FOLLOW_PERIOD_in_synpred9_PLSQLCommons813_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred9_PLSQLCommons815_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred9_PLSQLCommons815( FOLLOW_id_expression_in_synpred9_PLSQLCommons815_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred10_PLSQLCommons847_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred10_PLSQLCommons847( FOLLOW_PERIOD_in_synpred10_PLSQLCommons847_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred10_PLSQLCommons849_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred10_PLSQLCommons849( FOLLOW_id_expression_in_synpred10_PLSQLCommons849_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred11_PLSQLCommons881_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred11_PLSQLCommons881( FOLLOW_PERIOD_in_synpred11_PLSQLCommons881_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred11_PLSQLCommons883_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred11_PLSQLCommons883( FOLLOW_id_expression_in_synpred11_PLSQLCommons883_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred12_PLSQLCommons934_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred12_PLSQLCommons934( FOLLOW_PERIOD_in_synpred12_PLSQLCommons934_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred12_PLSQLCommons936_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred12_PLSQLCommons936( FOLLOW_id_expression_in_synpred12_PLSQLCommons936_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred13_PLSQLCommons1061_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred13_PLSQLCommons1061( FOLLOW_PERIOD_in_synpred13_PLSQLCommons1061_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred13_PLSQLCommons1063_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred13_PLSQLCommons1063( FOLLOW_id_expression_in_synpred13_PLSQLCommons1063_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred14_PLSQLCommons1115_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred14_PLSQLCommons1115( FOLLOW_PERIOD_in_synpred14_PLSQLCommons1115_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred14_PLSQLCommons1117_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred14_PLSQLCommons1117( FOLLOW_id_expression_in_synpred14_PLSQLCommons1117_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred15_PLSQLCommons1149_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred15_PLSQLCommons1149( FOLLOW_PERIOD_in_synpred15_PLSQLCommons1149_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred15_PLSQLCommons1151_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred15_PLSQLCommons1151( FOLLOW_id_expression_in_synpred15_PLSQLCommons1151_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred16_PLSQLCommons1218_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred16_PLSQLCommons1218( FOLLOW_PERIOD_in_synpred16_PLSQLCommons1218_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred16_PLSQLCommons1220_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred16_PLSQLCommons1220( FOLLOW_id_expression_in_synpred16_PLSQLCommons1220_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_synpred17_PLSQLCommons1555_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_tableview_name_in_synpred17_PLSQLCommons1555( FOLLOW_tableview_name_in_synpred17_PLSQLCommons1555_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred17_PLSQLCommons1557_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred17_PLSQLCommons1557( FOLLOW_PERIOD_in_synpred17_PLSQLCommons1557_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_synpred17_PLSQLCommons1559_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_ASTERISK_in_synpred17_PLSQLCommons1559( FOLLOW_ASTERISK_in_synpred17_PLSQLCommons1559_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_synpred18_PLSQLCommons1711_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_synpred18_PLSQLCommons1711( FOLLOW_id_in_synpred18_PLSQLCommons1711_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_synpred18_PLSQLCommons1713_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_synpred18_PLSQLCommons1713( FOLLOW_EQUALS_OP_in_synpred18_PLSQLCommons1713_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OP_in_synpred18_PLSQLCommons1715_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_GREATER_THAN_OP_in_synpred18_PLSQLCommons1715( FOLLOW_GREATER_THAN_OP_in_synpred18_PLSQLCommons1715_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred19_PLSQLCommons2630_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred19_PLSQLCommons2630( FOLLOW_PERIOD_in_synpred19_PLSQLCommons2630_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_synpred19_PLSQLCommons2632_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_general_element_part_in_synpred19_PLSQLCommons2632( FOLLOW_general_element_part_in_synpred19_PLSQLCommons2632_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred20_PLSQLCommons2664_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred20_PLSQLCommons2664( FOLLOW_PERIOD_in_synpred20_PLSQLCommons2664_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_synpred20_PLSQLCommons2666_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_general_element_part_in_synpred20_PLSQLCommons2666( FOLLOW_general_element_part_in_synpred20_PLSQLCommons2666_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred21_PLSQLCommons2717_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred21_PLSQLCommons2717( FOLLOW_PERIOD_in_synpred21_PLSQLCommons2717_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred21_PLSQLCommons2719_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred21_PLSQLCommons2719( FOLLOW_id_expression_in_synpred21_PLSQLCommons2719_bits, 1 );



/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    196:5: ( AT_SIGN link_name |{...}? => partition_extension_clause )?
 */
static const ANTLR_INT32 dfa32_eot[95] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa32_eof[95] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa32_min[95] =
    {
	5, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1
    };
static const ANTLR_INT32 dfa32_max[95] =
    {
	152, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa32_accept[95] =
    {
	-1, 1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 2
    };
static const ANTLR_INT32 dfa32_special[95] =
    {
	-1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa32_T_empty	 =   NULL;

static const ANTLR_INT32 dfa32_T0[] =
    {
	3, -1, 3, 1, 3, -1, 3, 3, 3, 3, 3, -1, 3, 3, -1, 3, 3, 3, 3, -1, 3, 3, 
	-1, 3, 3, 3, 3, 3, 3, 3, -1, 3, -1, 3, 3, -1, 3, 3, 3, 3, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, -1, -1, 
	-1, -1, -1, -1, -1, -1, 2, 3, 3, 3, -1, -1, 3, -1, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, -1, 3, 3, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, 3, 3, 3, 3, 3, 
	-1, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, 3, 3, -1, 3, 3, -1, -1, 
	3, -1, -1, -1, 3, 3, 3, 3, -1, 3, 3, -1, 3, 3, 3, -1, -1, 3, 3
    };

static const ANTLR_INT32 dfa32_T1[] =
    {
	-1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa32_transitions[] =
{
    dfa32_T0, NULL, dfa32_T1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL
};


/* Declare tracking structure for Cyclic DFA 32
 */
class PLSQLParser_PLSQLCommonsCyclicDFA32 : public CyclicDFA< PLSQLParser_PLSQLCommonsImplTraits, PLSQLParser_PLSQLCommons >, public PLSQLParser_PLSQLCommonsTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQLCommonsImplTraits, PLSQLParser_PLSQLCommons >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParser_PLSQLCommonsCyclicDFA32( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA32_2;

	    		    ANTLR_MARKER index32_2;


	    		    LA32_2 = ctx->LA(1);

	    		     
	    		        index32_2 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (( ((((equalsIgnoreCase(LT(1)->getText(), "PARTITION")))||((equalsIgnoreCase(LT(1)->getText(), "SUBPARTITION"))))) && ((!(LA(2) == SQL92_RESERVED_BY))) ))  )
	    		    {
	    		        s = 94;
	    		    }

	    		    else if ( (true)  )
	    		    {
	    		        s = 3;
	    		    }

	    			 
	    				ctx->seek(index32_2);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "196:5: ( AT_SIGN link_name |{...}? => partition_extension_clause )?" );
	    ex->set_decisionNum( 32 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParser_PLSQLCommonsCyclicDFA32  cdfa32(
	    32,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"196:5: ( AT_SIGN link_name |{...}? => partition_extension_clause )?",
	    dfa32_eot,	    /* EOT table			    */
	    dfa32_eof,	    /* EOF table			    */
	    dfa32_min,	    /* Minimum tokens for each state    */
	    dfa32_max,	    /* Maximum tokens for each state    */
	    dfa32_accept,	/* Accept table			    */
	    dfa32_special,	/* Special transition states	    */
	    dfa32_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 32
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    215:21: ( over_clause )?
 */
static const ANTLR_INT32 dfa35_eot[76] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1
    };
static const ANTLR_INT32 dfa35_eof[76] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1
    };
static const ANTLR_INT32 dfa35_min[76] =
    {
	6, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1
    };
static const ANTLR_INT32 dfa35_max[76] =
    {
	152, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1
    };
static const ANTLR_INT32 dfa35_accept[76] =
    {
	-1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 1
    };
static const ANTLR_INT32 dfa35_special[76] =
    {
	-1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa35_T_empty	 =   NULL;

static const ANTLR_INT32 dfa35_T0[] =
    {
	2, 2, -1, -1, -1, 2, 2, 2, -1, 2, -1, 2, 2, -1, 2, 2, -1, 2, -1, 2, 2, 
	-1, 2, 2, 2, 2, 2, 2, 2, -1, 2, -1, 2, -1, -1, 2, 2, 2, 2, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 2, 2, -1, -1, -1, -1, -1, 2, -1, -1, 2, 2, -1, 
	-1, -1, -1, -1, -1, -1, -1, 1, 2, 2, 2, -1, -1, 2, -1, -1, 2, 2, -1, 2, 
	2, -1, 2, 2, -1, -1, 2, 2, -1, -1, 2, -1, 2, 2, 2, -1, 2, 2, 2, -1, -1, 
	-1, 2, 2, 2, -1, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, -1, -1, 2, -1, 2, 2, -1, 
	-1, 2, -1, -1, 2, -1, -1, -1, 2, 2, -1, 2, -1, 2, -1, -1, 2, 2, 2, -1, 
	-1, -1, 2
    };

static const ANTLR_INT32 dfa35_T1[] =
    {
	-1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa35_transitions[] =
{
    dfa35_T0, dfa35_T1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL
};


/* Declare tracking structure for Cyclic DFA 35
 */
class PLSQLParser_PLSQLCommonsCyclicDFA35 : public CyclicDFA< PLSQLParser_PLSQLCommonsImplTraits, PLSQLParser_PLSQLCommons >, public PLSQLParser_PLSQLCommonsTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQLCommonsImplTraits, PLSQLParser_PLSQLCommons >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParser_PLSQLCommonsCyclicDFA35( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA35_1;

	    		    ANTLR_MARKER index35_1;


	    		    LA35_1 = ctx->LA(1);

	    		     
	    		        index35_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "OVER")))  )
	    		    {
	    		        s = 75;
	    		    }

	    		    else if ( (true)  )
	    		    {
	    		        s = 2;
	    		    }

	    			 
	    				ctx->seek(index35_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "215:21: ( over_clause )?" );
	    ex->set_decisionNum( 35 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParser_PLSQLCommonsCyclicDFA35  cdfa35(
	    35,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"215:21: ( over_clause )?",
	    dfa35_eot,	    /* EOT table			    */
	    dfa35_eof,	    /* EOF table			    */
	    dfa35_min,	    /* Minimum tokens for each state    */
	    dfa35_max,	    /* Maximum tokens for each state    */
	    dfa35_accept,	/* Accept table			    */
	    dfa35_special,	/* Special transition states	    */
	    dfa35_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 35
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    250:10: ( ( id EQUALS_OP GREATER_THAN_OP )=> id EQUALS_OP GREATER_THAN_OP )?
 */
static const ANTLR_INT32 dfa54_eot[24] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa54_eof[24] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa54_min[24] =
    {
	5, 18, 5, -1, 7, 18, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	5, 18, 7, -1, 18
    };
static const ANTLR_INT32 dfa54_max[24] =
    {
	151, 74, 152, -1, 152, 74, 151, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 151, 74, 152, -1, 74
    };
static const ANTLR_INT32 dfa54_accept[24] =
    {
	-1, -1, -1, 2, -1, -1, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, -1, -1, 
	-1, 1, -1
    };
static const ANTLR_INT32 dfa54_special[24] =
    {
	-1, -1, 2, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa54_T_empty	 =   NULL;

static const ANTLR_INT32 dfa54_T0[] =
    {
	18, -1, -1, -1, 18, -1, -1, -1, 18, -1, 18, -1, -1, -1, 19, -1, 18, -1, 
	18, 18, -1, -1, 18, 18, 18, 18, 18, -1, -1, 18, -1, 18, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, 18, -1, -1, 
	-1, 18, -1, -1, -1, 18, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 18, -1, -1, -1, 18, 18, 18, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 18
    };

static const ANTLR_INT32 dfa54_T1[] =
    {
	18, -1, -1, -1, 18, -1, -1, 18, 18, 18, -1, -1, -1, 18, -1, -1, -1, 18, 
	-1, -1, 22, -1, -1, 18, -1, 18, -1, -1, 18, 18, -1, -1, -1, -1, 18, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, -1, 
	-1, -1, -1, -1, -1, 18, -1, -1, 18, -1, -1, -1, -1, -1, 18, -1, -1, -1, 
	-1, -1, 18, -1, 18, -1, -1, 18, -1, -1, -1, -1, 18, 18, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, 18, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 18
    };

static const ANTLR_INT32 dfa54_T2[] =
    {
	23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 23
    };

static const ANTLR_INT32 dfa54_T3[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 5
    };

static const ANTLR_INT32 dfa54_T4[] =
    {
	21, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 21
    };

static const ANTLR_INT32 dfa54_T5[] =
    {
	3, -1, -1, -1, 3, -1, -1, 3, 3, 3, -1, -1, -1, 4, -1, -1, -1, 3, -1, -1, 
	-1, -1, -1, 1, -1, 3, -1, -1, 3, 3, -1, -1, -1, -1, 3, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, 
	-1, 3, -1, -1, 3, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, -1, 3, -1, 
	-1, 3, -1, -1, -1, -1, 3, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 3, 3, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3
    };

static const ANTLR_INT32 dfa54_T6[] =
    {
	15, -1, 18, -1, 14, -1, 18, 16, 16, 14, 18, -1, 18, 10, -1, -1, 6, 15, 
	18, -1, 18, 18, -1, 13, 18, 18, 18, 18, 3, 16, -1, 18, -1, 18, 7, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, 18, -1, -1, 
	-1, 18, -1, 9, -1, 18, 12, -1, -1, -1, 18, -1, 11, -1, -1, -1, -1, -1, 
	15, -1, 17, -1, -1, 9, -1, -1, -1, -1, 12, 17, -1, -1, -1, -1, -1, -1, 
	-1, 18, -1, -1, -1, 18, 18, 18, 17, -1, -1, -1, 18, -1, -1, 7, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	15, 18
    };

static const ANTLR_INT32 dfa54_T7[] =
    {
	18, -1, -1, -1, 18, -1, -1, -1, 18, -1, 18, -1, -1, -1, 19, -1, 18, -1, 
	18, 18, -1, -1, 18, 18, 18, 18, 18, -1, -1, 18, -1, 18, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, 18, -1, -1, 
	-1, 18, -1, -1, -1, 18, -1, -1, -1, -1, 18, -1, 18, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 18, -1, -1, -1, 18, 18, 18, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 18
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa54_transitions[] =
{
    dfa54_T5, dfa54_T3, dfa54_T6, NULL, dfa54_T7, dfa54_T4, dfa54_T1, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, dfa54_T1, 
    dfa54_T2, dfa54_T0, NULL, dfa54_T4
};


/* Declare tracking structure for Cyclic DFA 54
 */
class PLSQLParser_PLSQLCommonsCyclicDFA54 : public CyclicDFA< PLSQLParser_PLSQLCommonsImplTraits, PLSQLParser_PLSQLCommons >, public PLSQLParser_PLSQLCommonsTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQLCommonsImplTraits, PLSQLParser_PLSQLCommons >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParser_PLSQLCommonsCyclicDFA54( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA54_6;

	    		    ANTLR_MARKER index54_6;


	    		    LA54_6 = ctx->LA(1);

	    		     
	    		        index54_6 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA54_6 == GREATER_THAN_OP) && (this->msynpred( antlr3::ClassForwarder<synpred18_PLSQLCommons>() )) )
	    		    {
	    		        s = 22;
	    		    }

	    		    else if ( (LA54_6 == APPROXIMATE_NUM_LIT || LA54_6 == BINDVAR || ((LA54_6 >= CHAR_STRING) && (LA54_6 <= COLON)) || LA54_6 == DELIMITED_ID || LA54_6 == EXACT_NUM_LIT || LA54_6 == INTRODUCER || LA54_6 == LEFT_PAREN || ((LA54_6 >= MINUS_SIGN) && (LA54_6 <= NATIONAL_CHAR_STRING_LIT)) || LA54_6 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA54_6 == PLUS_SIGN || LA54_6 == REGULAR_ID || LA54_6 == SQL92_RESERVED_ALL || LA54_6 == SQL92_RESERVED_ANY || LA54_6 == SQL92_RESERVED_CASE || LA54_6 == SQL92_RESERVED_DATE || LA54_6 == SQL92_RESERVED_DEFAULT || LA54_6 == SQL92_RESERVED_DISTINCT || ((LA54_6 >= SQL92_RESERVED_EXISTS) && (LA54_6 <= SQL92_RESERVED_FALSE)) || LA54_6 == SQL92_RESERVED_NULL || LA54_6 == SQL92_RESERVED_PRIOR || LA54_6 == SQL92_RESERVED_TRUE || LA54_6 == UNSIGNED_INTEGER)  )
	    		    {
	    		        s = 18;
	    		    }

	    			 
	    				ctx->seek(index54_6);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA54_19;

	    		    ANTLR_MARKER index54_19;


	    		    LA54_19 = ctx->LA(1);

	    		     
	    		        index54_19 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA54_19 == GREATER_THAN_OP) && (this->msynpred( antlr3::ClassForwarder<synpred18_PLSQLCommons>() )) )
	    		    {
	    		        s = 22;
	    		    }

	    		    else if ( (LA54_19 == APPROXIMATE_NUM_LIT || LA54_19 == BINDVAR || ((LA54_19 >= CHAR_STRING) && (LA54_19 <= COLON)) || LA54_19 == DELIMITED_ID || LA54_19 == EXACT_NUM_LIT || LA54_19 == INTRODUCER || LA54_19 == LEFT_PAREN || ((LA54_19 >= MINUS_SIGN) && (LA54_19 <= NATIONAL_CHAR_STRING_LIT)) || LA54_19 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA54_19 == PLUS_SIGN || LA54_19 == REGULAR_ID || LA54_19 == SQL92_RESERVED_ALL || LA54_19 == SQL92_RESERVED_ANY || LA54_19 == SQL92_RESERVED_CASE || LA54_19 == SQL92_RESERVED_DATE || LA54_19 == SQL92_RESERVED_DEFAULT || LA54_19 == SQL92_RESERVED_DISTINCT || ((LA54_19 >= SQL92_RESERVED_EXISTS) && (LA54_19 <= SQL92_RESERVED_FALSE)) || LA54_19 == SQL92_RESERVED_NULL || LA54_19 == SQL92_RESERVED_PRIOR || LA54_19 == SQL92_RESERVED_TRUE || LA54_19 == UNSIGNED_INTEGER)  )
	    		    {
	    		        s = 18;
	    		    }

	    			 
	    				ctx->seek(index54_19);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA54_2;

	    		    ANTLR_MARKER index54_2;


	    		    LA54_2 = ctx->LA(1);

	    		     
	    		        index54_2 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA54_2 == EQUALS_OP)  )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA54_2 == MINUS_SIGN || LA54_2 == PLUS_SIGN)  )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA54_2 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA54_2 == SQL92_RESERVED_PRIOR) && (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
	    		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
	    		             )) )) )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( (LA54_2 == REGULAR_ID)  )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA54_2 == SQL92_RESERVED_ALL || LA54_2 == SQL92_RESERVED_DISTINCT) && (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
	    		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
	    		             )) )) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA54_2 == DELIMITED_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||(( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
	    		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
	    		             )) )))) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA54_2 == SQL92_RESERVED_CASE)  )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA54_2 == SQL92_RESERVED_ANY || LA54_2 == SQL92_RESERVED_EXISTS) && (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
	    		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
	    		             )) )) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA54_2 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||(( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
	    		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
	    		             )) )))) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( (LA54_2 == BINDVAR || LA54_2 == COLON)  )
	    		    {
	    		        s = 14;
	    		    }

	    		    else if ( (LA54_2 == APPROXIMATE_NUM_LIT || LA54_2 == EXACT_NUM_LIT || LA54_2 == SQL92_RESERVED_DATE || LA54_2 == UNSIGNED_INTEGER) && (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
	    		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
	    		             )) )) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (((LA54_2 >= CHAR_STRING) && (LA54_2 <= CHAR_STRING_PERL)) || LA54_2 == NATIONAL_CHAR_STRING_LIT)  )
	    		    {
	    		        s = 16;
	    		    }

	    		    else if ( (LA54_2 == SQL92_RESERVED_DEFAULT || LA54_2 == SQL92_RESERVED_FALSE || LA54_2 == SQL92_RESERVED_NULL || LA54_2 == SQL92_RESERVED_TRUE) && (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
	    		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
	    		             )) )) )
	    		    {
	    		        s = 17;
	    		    }

	    		    else if ( (LA54_2 == ASTERISK || LA54_2 == CARRET_OPERATOR_PART || LA54_2 == COMMA || LA54_2 == CONCATENATION_OP || LA54_2 == EXCLAMATION_OPERATOR_PART || ((LA54_2 >= GREATER_THAN_OP) && (LA54_2 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA54_2 >= LEFT_BRACKET) && (LA54_2 <= LESS_THAN_OR_EQUALS_OP)) || LA54_2 == NOT_EQUAL_OP || LA54_2 == PERIOD || LA54_2 == RIGHT_PAREN || LA54_2 == SOLIDUS || LA54_2 == SQL92_RESERVED_AND || LA54_2 == SQL92_RESERVED_BETWEEN || LA54_2 == SQL92_RESERVED_IN || ((LA54_2 >= SQL92_RESERVED_IS) && (LA54_2 <= SQL92_RESERVED_NOT)) || LA54_2 == SQL92_RESERVED_OR || LA54_2 == VERTICAL_BAR)  )
	    		    {
	    		        s = 18;
	    		    }

	    			 
	    				ctx->seek(index54_2);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "250:10: ( ( id EQUALS_OP GREATER_THAN_OP )=> id EQUALS_OP GREATER_THAN_OP )?" );
	    ex->set_decisionNum( 54 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParser_PLSQLCommonsCyclicDFA54  cdfa54(
	    54,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"250:10: ( ( id EQUALS_OP GREATER_THAN_OP )=> id EQUALS_OP GREATER_THAN_OP )?",
	    dfa54_eot,	    /* EOT table			    */
	    dfa54_eof,	    /* EOF table			    */
	    dfa54_min,	    /* Minimum tokens for each state    */
	    dfa54_max,	    /* Maximum tokens for each state    */
	    dfa54_accept,	/* Accept table			    */
	    dfa54_special,	/* Special transition states	    */
	    dfa54_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 54
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    341:62: ( function_argument )?
 */
static const ANTLR_INT32 dfa79_eot[75] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1
    };
static const ANTLR_INT32 dfa79_eof[75] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1
    };
static const ANTLR_INT32 dfa79_min[75] =
    {
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1
    };
static const ANTLR_INT32 dfa79_max[75] =
    {
	152, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1
    };
static const ANTLR_INT32 dfa79_accept[75] =
    {
	-1, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1
    };
static const ANTLR_INT32 dfa79_special[75] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa79_T_empty	 =   NULL;

static const ANTLR_INT32 dfa79_T0[] =
    {
	2, 2, -1, -1, -1, 2, 2, 2, -1, 2, -1, 2, 2, -1, 2, 2, -1, 2, -1, 2, 2, 
	-1, 2, 2, 1, 2, 2, 2, 2, -1, 2, -1, 2, -1, -1, 2, 2, 2, 2, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 2, 2, -1, -1, -1, -1, -1, 2, -1, -1, 2, 2, -1, 
	-1, -1, -1, -1, -1, -1, -1, 2, 2, 2, 2, -1, -1, 2, -1, -1, 2, 2, -1, 2, 
	2, -1, 2, 2, -1, -1, 2, 2, -1, -1, 2, -1, 2, 2, 2, -1, 2, 2, 2, -1, -1, 
	-1, 2, 2, 2, -1, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, -1, -1, 2, -1, 2, 2, -1, 
	-1, 2, -1, -1, 2, -1, -1, -1, 2, 2, -1, 2, -1, 2, -1, -1, 2, 2, 2, -1, 
	-1, -1, 2
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa79_transitions[] =
{
    dfa79_T0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL
};


/* Declare tracking structure for Cyclic DFA 79
 */
class PLSQLParser_PLSQLCommonsCyclicDFA79 : public CyclicDFA< PLSQLParser_PLSQLCommonsImplTraits, PLSQLParser_PLSQLCommons >, public PLSQLParser_PLSQLCommonsTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQLCommonsImplTraits, PLSQLParser_PLSQLCommons >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	

public:
	PLSQLParser_PLSQLCommonsCyclicDFA79( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		
	}

};

static PLSQLParser_PLSQLCommonsCyclicDFA79  cdfa79(
	    79,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"341:62: ( function_argument )?",
	    dfa79_eot,	    /* EOT table			    */
	    dfa79_eof,	    /* EOF table			    */
	    dfa79_min,	    /* Minimum tokens for each state    */
	    dfa79_max,	    /* Maximum tokens for each state    */
	    dfa79_accept,	/* Accept table			    */
	    dfa79_special,	/* Special transition states	    */
	    dfa79_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 79
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */

/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start partition_extension_clause
 * PLSQLCommons.g:29:1: partition_extension_clause : ( subpartition_key | partition_key ) ( for_key )? expression_list ;
 */
void
PLSQLParser_PLSQLCommons::partition_extension_clause()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:30:5: ( ( subpartition_key | partition_key ) ( for_key )? expression_list )
        // PLSQLCommons.g:30:10: ( subpartition_key | partition_key ) ( for_key )? expression_list
        {
            // PLSQLCommons.g:30:10: ( subpartition_key | partition_key )
            {
                int alt1=2;
                {
                    int LA1_0 = this->LA(1);
                    if ( (LA1_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "PARTITION")))||((equalsIgnoreCase(LT(1)->getText(), "SUBPARTITION"))))))
                    {
                        {
                            int LA1_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "SUBPARTITION"))))
                            {
                                alt1=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "PARTITION"))))
                            {
                                alt1=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 1 );
                                ex->set_state( 1 );


                                goto rulepartition_extension_clauseEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 1 );
                        ex->set_state( 0 );


                        goto rulepartition_extension_clauseEx;

                    }
                }
                switch (alt1)
                {
            	case 1:
            	    // PLSQLCommons.g:30:12: subpartition_key
            	    {
            	        this->followPush(FOLLOW_subpartition_key_in_partition_extension_clause36);
            	        m_gPLSQLParser->subpartition_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepartition_extension_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:30:31: partition_key
            	    {
            	        this->followPush(FOLLOW_partition_key_in_partition_extension_clause40);
            	        m_gPLSQLParser->partition_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepartition_extension_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLCommons.g:31:9: ( for_key )?
            {
                int alt2=2;
                {
                    int LA2_0 = this->LA(1);
                    if ( (LA2_0 == SQL92_RESERVED_FOR))
                    {
                        alt2=1;
                    }
                }
                switch (alt2)
                {
            	case 1:
            	    // PLSQLCommons.g:31:9: for_key
            	    {
            	        this->followPush(FOLLOW_for_key_in_partition_extension_clause53);
            	        m_gPLSQLParser->for_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepartition_extension_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_expression_list_in_partition_extension_clause56);
            m_gPLSQLParser->expression_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepartition_extension_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepartition_extension_clauseEx; /* Prevent compiler warnings */
    rulepartition_extension_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end partition_extension_clause */

/**
 * $ANTLR start column_alias
 * PLSQLCommons.g:34:1: column_alias options {backtrack=true; } : ( ( as_key )? ( id | alias_quoted_string ) | as_key );
 */
void
PLSQLParser_PLSQLCommons::column_alias()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:39:5: ( ( as_key )? ( id | alias_quoted_string ) | as_key )

            ANTLR_UINT32 alt5;

            alt5=2;

            {
                int LA5_0 = this->LA(1);
                if ( (LA5_0 == SQL92_RESERVED_AS))
                {
                    {
                        int LA5_1 = this->LA(2);
                        if ( (this->msynpred( antlr3::ClassForwarder<synpred1_PLSQLCommons>() )))
                        {
                            alt5=1;
                        }
                        else if ( (true))
                        {
                            alt5=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 5 );
                            ex->set_state( 1 );


                            goto rulecolumn_aliasEx;

                        }
                    }
                }
                else if ( (((LA5_0 >= CHAR_STRING) && (LA5_0 <= CHAR_STRING_PERL)) || LA5_0 == DELIMITED_ID || LA5_0 == INTRODUCER || LA5_0 == NATIONAL_CHAR_STRING_LIT || LA5_0 == REGULAR_ID))
                {
                    alt5=1;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 5 );
                    ex->set_state( 0 );


                    goto rulecolumn_aliasEx;

                }
            }
            switch (alt5)
            {
        	case 1:
        	    // PLSQLCommons.g:39:10: ( as_key )? ( id | alias_quoted_string )
        	    {
        	        // PLSQLCommons.g:39:10: ( as_key )?
        	        {
        	            int alt3=2;
        	            {
        	                int LA3_0 = this->LA(1);
        	                if ( (LA3_0 == SQL92_RESERVED_AS))
        	                {
        	                    alt3=1;
        	                }
        	            }
        	            switch (alt3)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:39:10: as_key
        	        	    {
        	        	        this->followPush(FOLLOW_as_key_in_column_alias85);
        	        	        m_gPLSQLParser->as_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecolumn_aliasEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLCommons.g:39:18: ( id | alias_quoted_string )
        	        {
        	            int alt4=2;
        	            {
        	                int LA4_0 = this->LA(1);
        	                if ( (LA4_0 == DELIMITED_ID || LA4_0 == INTRODUCER || LA4_0 == REGULAR_ID))
        	                {
        	                    alt4=1;
        	                }
        	                else if ( (((LA4_0 >= CHAR_STRING) && (LA4_0 <= CHAR_STRING_PERL)) || LA4_0 == NATIONAL_CHAR_STRING_LIT))
        	                {
        	                    alt4=2;
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 4 );
        	                    ex->set_state( 0 );


        	                    goto rulecolumn_aliasEx;

        	                }
        	            }
        	            switch (alt4)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:39:20: id
        	        	    {
        	        	        this->followPush(FOLLOW_id_in_column_alias90);
        	        	        id();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecolumn_aliasEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQLCommons.g:39:25: alias_quoted_string
        	        	    {
        	        	        this->followPush(FOLLOW_alias_quoted_string_in_column_alias94);
        	        	        alias_quoted_string();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecolumn_aliasEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:40:10: as_key
        	    {
        	        this->followPush(FOLLOW_as_key_in_column_alias107);
        	        m_gPLSQLParser->as_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_aliasEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulecolumn_aliasEx; /* Prevent compiler warnings */
    rulecolumn_aliasEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end column_alias */

/**
 * $ANTLR start table_alias
 * PLSQLCommons.g:43:1: table_alias : ( id | alias_quoted_string ) ;
 */
void
PLSQLParser_PLSQLCommons::table_alias()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:44:5: ( ( id | alias_quoted_string ) )
        // PLSQLCommons.g:44:10: ( id | alias_quoted_string )
        {
            // PLSQLCommons.g:44:10: ( id | alias_quoted_string )
            {
                int alt6=2;
                {
                    int LA6_0 = this->LA(1);
                    if ( (LA6_0 == DELIMITED_ID || LA6_0 == INTRODUCER || LA6_0 == REGULAR_ID))
                    {
                        alt6=1;
                    }
                    else if ( (((LA6_0 >= CHAR_STRING) && (LA6_0 <= CHAR_STRING_PERL)) || LA6_0 == NATIONAL_CHAR_STRING_LIT))
                    {
                        alt6=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 6 );
                        ex->set_state( 0 );


                        goto ruletable_aliasEx;

                    }
                }
                switch (alt6)
                {
            	case 1:
            	    // PLSQLCommons.g:44:12: id
            	    {
            	        this->followPush(FOLLOW_id_in_table_alias129);
            	        id();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_aliasEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:44:17: alias_quoted_string
            	    {
            	        this->followPush(FOLLOW_alias_quoted_string_in_table_alias133);
            	        alias_quoted_string();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_aliasEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_aliasEx; /* Prevent compiler warnings */
    ruletable_aliasEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_alias */

/**
 * $ANTLR start alias_quoted_string
 * PLSQLCommons.g:47:1: alias_quoted_string : quoted_string ;
 */
void
PLSQLParser_PLSQLCommons::alias_quoted_string()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:48:5: ( quoted_string )
        // PLSQLCommons.g:48:10: quoted_string
        {
            this->followPush(FOLLOW_quoted_string_in_alias_quoted_string155);
            quoted_string();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealias_quoted_stringEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealias_quoted_stringEx; /* Prevent compiler warnings */
    rulealias_quoted_stringEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end alias_quoted_string */

/**
 * $ANTLR start where_clause
 * PLSQLCommons.g:51:1: where_clause : where_key ( current_of_clause | condition_wrapper ) ;
 */
void
PLSQLParser_PLSQLCommons::where_clause()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:52:5: ( where_key ( current_of_clause | condition_wrapper ) )
        // PLSQLCommons.g:52:10: where_key ( current_of_clause | condition_wrapper )
        {
            this->followPush(FOLLOW_where_key_in_where_clause175);
            m_gPLSQLParser->where_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulewhere_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:52:20: ( current_of_clause | condition_wrapper )
            {
                int alt7=2;
                {
                    int LA7_0 = this->LA(1);
                    if ( (LA7_0 == SQL92_RESERVED_CURRENT))
                    {
                        alt7=1;
                    }
                    else if ( (LA7_0 == APPROXIMATE_NUM_LIT || LA7_0 == BINDVAR || ((LA7_0 >= CHAR_STRING) && (LA7_0 <= COLON)) || LA7_0 == DELIMITED_ID || LA7_0 == EXACT_NUM_LIT || LA7_0 == INTRODUCER || LA7_0 == LEFT_PAREN || ((LA7_0 >= MINUS_SIGN) && (LA7_0 <= NATIONAL_CHAR_STRING_LIT)) || LA7_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA7_0 == PLUS_SIGN || LA7_0 == REGULAR_ID || LA7_0 == SQL92_RESERVED_ALL || LA7_0 == SQL92_RESERVED_ANY || LA7_0 == SQL92_RESERVED_CASE || ((LA7_0 >= SQL92_RESERVED_CURSOR) && (LA7_0 <= SQL92_RESERVED_DATE)) || LA7_0 == SQL92_RESERVED_DEFAULT || LA7_0 == SQL92_RESERVED_DISTINCT || ((LA7_0 >= SQL92_RESERVED_EXISTS) && (LA7_0 <= SQL92_RESERVED_FALSE)) || ((LA7_0 >= SQL92_RESERVED_NOT) && (LA7_0 <= SQL92_RESERVED_NULL)) || LA7_0 == SQL92_RESERVED_PRIOR || LA7_0 == SQL92_RESERVED_TRUE || LA7_0 == UNSIGNED_INTEGER))
                    {
                        alt7=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 7 );
                        ex->set_state( 0 );


                        goto rulewhere_clauseEx;

                    }
                }
                switch (alt7)
                {
            	case 1:
            	    // PLSQLCommons.g:52:21: current_of_clause
            	    {
            	        this->followPush(FOLLOW_current_of_clause_in_where_clause178);
            	        current_of_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewhere_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:52:39: condition_wrapper
            	    {
            	        this->followPush(FOLLOW_condition_wrapper_in_where_clause180);
            	        m_gPLSQLParser->condition_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewhere_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulewhere_clauseEx; /* Prevent compiler warnings */
    rulewhere_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end where_clause */

/**
 * $ANTLR start current_of_clause
 * PLSQLCommons.g:55:1: current_of_clause : current_key of_key cursor_name ;
 */
void
PLSQLParser_PLSQLCommons::current_of_clause()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:56:5: ( current_key of_key cursor_name )
        // PLSQLCommons.g:56:10: current_key of_key cursor_name
        {
            this->followPush(FOLLOW_current_key_in_current_of_clause201);
            m_gPLSQLParser->current_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecurrent_of_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_of_key_in_current_of_clause203);
            m_gPLSQLParser->of_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecurrent_of_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_cursor_name_in_current_of_clause205);
            cursor_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecurrent_of_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecurrent_of_clauseEx; /* Prevent compiler warnings */
    rulecurrent_of_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end current_of_clause */

/**
 * $ANTLR start into_clause
 * PLSQLCommons.g:59:1: into_clause : ( into_key variable_name ( COMMA variable_name )* | bulk_key collect_key into_key variable_name ( COMMA variable_name )* );
 */
void
PLSQLParser_PLSQLCommons::into_clause()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:60:5: ( into_key variable_name ( COMMA variable_name )* | bulk_key collect_key into_key variable_name ( COMMA variable_name )* )

            ANTLR_UINT32 alt10;

            alt10=2;

            {
                int LA10_0 = this->LA(1);
                if ( (LA10_0 == SQL92_RESERVED_INTO))
                {
                    alt10=1;
                }
                else if ( (LA10_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "BULK"))))
                {
                    alt10=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 10 );
                    ex->set_state( 0 );


                    goto ruleinto_clauseEx;

                }
            }
            switch (alt10)
            {
        	case 1:
        	    // PLSQLCommons.g:60:10: into_key variable_name ( COMMA variable_name )*
        	    {
        	        this->followPush(FOLLOW_into_key_in_into_clause225);
        	        m_gPLSQLParser->into_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinto_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_variable_name_in_into_clause227);
        	        variable_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinto_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:60:33: ( COMMA variable_name )*

        	        for (;;)
        	        {
        	            int alt8=2;
        	            {
        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                */
        	                int LA8_0 = this->LA(1);
        	                if ( (LA8_0 == COMMA))
        	                {
        	                    alt8=1;
        	                }

        	            }
        	            switch (alt8)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:60:34: COMMA variable_name
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_into_clause230);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinto_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_variable_name_in_into_clause232);
        	        	        variable_name();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinto_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop8;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop8: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:61:10: bulk_key collect_key into_key variable_name ( COMMA variable_name )*
        	    {
        	        this->followPush(FOLLOW_bulk_key_in_into_clause246);
        	        m_gPLSQLParser->bulk_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinto_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_collect_key_in_into_clause248);
        	        m_gPLSQLParser->collect_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinto_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_into_key_in_into_clause250);
        	        m_gPLSQLParser->into_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinto_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_variable_name_in_into_clause252);
        	        variable_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinto_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:61:54: ( COMMA variable_name )*

        	        for (;;)
        	        {
        	            int alt9=2;
        	            {
        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                */
        	                int LA9_0 = this->LA(1);
        	                if ( (LA9_0 == COMMA))
        	                {
        	                    alt9=1;
        	                }

        	            }
        	            switch (alt9)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:61:55: COMMA variable_name
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_into_clause255);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinto_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_variable_name_in_into_clause257);
        	        	        variable_name();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinto_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop9;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop9: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleinto_clauseEx; /* Prevent compiler warnings */
    ruleinto_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end into_clause */

/**
 * $ANTLR start xml_column_name
 * PLSQLCommons.g:68:1: xml_column_name : ( id | quoted_string );
 */
void
PLSQLParser_PLSQLCommons::xml_column_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:69:5: ( id | quoted_string )

            ANTLR_UINT32 alt11;

            alt11=2;

            {
                int LA11_0 = this->LA(1);
                if ( (LA11_0 == DELIMITED_ID || LA11_0 == INTRODUCER || LA11_0 == REGULAR_ID))
                {
                    alt11=1;
                }
                else if ( (((LA11_0 >= CHAR_STRING) && (LA11_0 <= CHAR_STRING_PERL)) || LA11_0 == NATIONAL_CHAR_STRING_LIT))
                {
                    alt11=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 11 );
                    ex->set_state( 0 );


                    goto rulexml_column_nameEx;

                }
            }
            switch (alt11)
            {
        	case 1:
        	    // PLSQLCommons.g:69:10: id
        	    {
        	        this->followPush(FOLLOW_id_in_xml_column_name284);
        	        id();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulexml_column_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:70:10: quoted_string
        	    {
        	        this->followPush(FOLLOW_quoted_string_in_xml_column_name295);
        	        quoted_string();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulexml_column_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulexml_column_nameEx; /* Prevent compiler warnings */
    rulexml_column_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xml_column_name */

/**
 * $ANTLR start cost_class_name
 * PLSQLCommons.g:73:1: cost_class_name : id ;
 */
void
PLSQLParser_PLSQLCommons::cost_class_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:74:5: ( id )
        // PLSQLCommons.g:74:10: id
        {
            this->followPush(FOLLOW_id_in_cost_class_name315);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecost_class_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecost_class_nameEx; /* Prevent compiler warnings */
    rulecost_class_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cost_class_name */

/**
 * $ANTLR start attribute_name
 * PLSQLCommons.g:77:1: attribute_name : id ;
 */
void
PLSQLParser_PLSQLCommons::attribute_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:78:5: ( id )
        // PLSQLCommons.g:78:10: id
        {
            this->followPush(FOLLOW_id_in_attribute_name335);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleattribute_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleattribute_nameEx; /* Prevent compiler warnings */
    ruleattribute_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end attribute_name */

/**
 * $ANTLR start savepoint_name
 * PLSQLCommons.g:81:1: savepoint_name : id ;
 */
void
PLSQLParser_PLSQLCommons::savepoint_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:82:5: ( id )
        // PLSQLCommons.g:82:10: id
        {
            this->followPush(FOLLOW_id_in_savepoint_name355);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesavepoint_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesavepoint_nameEx; /* Prevent compiler warnings */
    rulesavepoint_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end savepoint_name */

/**
 * $ANTLR start rollback_segment_name
 * PLSQLCommons.g:85:1: rollback_segment_name : id ;
 */
void
PLSQLParser_PLSQLCommons::rollback_segment_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:86:5: ( id )
        // PLSQLCommons.g:86:10: id
        {
            this->followPush(FOLLOW_id_in_rollback_segment_name375);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerollback_segment_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerollback_segment_nameEx; /* Prevent compiler warnings */
    rulerollback_segment_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rollback_segment_name */

/**
 * $ANTLR start table_var_name
 * PLSQLCommons.g:90:1: table_var_name : id ;
 */
void
PLSQLParser_PLSQLCommons::table_var_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:91:5: ( id )
        // PLSQLCommons.g:91:10: id
        {
            this->followPush(FOLLOW_id_in_table_var_name396);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_var_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_var_nameEx; /* Prevent compiler warnings */
    ruletable_var_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_var_name */

/**
 * $ANTLR start schema_name
 * PLSQLCommons.g:94:1: schema_name : id ;
 */
void
PLSQLParser_PLSQLCommons::schema_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:95:5: ( id )
        // PLSQLCommons.g:95:10: id
        {
            this->followPush(FOLLOW_id_in_schema_name416);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleschema_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleschema_nameEx; /* Prevent compiler warnings */
    ruleschema_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end schema_name */

/**
 * $ANTLR start routine_name
 * PLSQLCommons.g:98:1: routine_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )* ( AT_SIGN link_name )? ;
 */
void
PLSQLParser_PLSQLCommons::routine_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:99:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )* ( AT_SIGN link_name )? )
        // PLSQLCommons.g:99:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )* ( AT_SIGN link_name )?
        {
            this->followPush(FOLLOW_id_in_routine_name436);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleroutine_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:99:13: ( ( PERIOD id_expression )=> PERIOD id_expression )*

            for (;;)
            {
                int alt12=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA12_0 = this->LA(1);
                    if ( (LA12_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred2_PLSQLCommons>() )))
                    {
                        alt12=1;
                    }

                }
                switch (alt12)
                {
            	case 1:
            	    // PLSQLCommons.g:99:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_routine_name446);
            	        if  (this->hasException())
            	        {
            	            goto ruleroutine_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_routine_name448);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleroutine_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop12;	/* break out of the loop */
            	    break;
                }
            }
            loop12: ; /* Jump out to here if this rule does not match */


            // PLSQLCommons.g:99:62: ( AT_SIGN link_name )?
            {
                int alt13=2;
                {
                    int LA13_0 = this->LA(1);
                    if ( (LA13_0 == AT_SIGN))
                    {
                        alt13=1;
                    }
                }
                switch (alt13)
                {
            	case 1:
            	    // PLSQLCommons.g:99:63: AT_SIGN link_name
            	    {
            	         this->matchToken(AT_SIGN, &FOLLOW_AT_SIGN_in_routine_name453);
            	        if  (this->hasException())
            	        {
            	            goto ruleroutine_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_link_name_in_routine_name455);
            	        link_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleroutine_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleroutine_nameEx; /* Prevent compiler warnings */
    ruleroutine_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end routine_name */

/**
 * $ANTLR start package_name
 * PLSQLCommons.g:102:1: package_name : id ;
 */
void
PLSQLParser_PLSQLCommons::package_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:103:5: ( id )
        // PLSQLCommons.g:103:10: id
        {
            this->followPush(FOLLOW_id_in_package_name477);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepackage_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepackage_nameEx; /* Prevent compiler warnings */
    rulepackage_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end package_name */

/**
 * $ANTLR start implementation_type_name
 * PLSQLCommons.g:106:1: implementation_type_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )? ;
 */
void
PLSQLParser_PLSQLCommons::implementation_type_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:107:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )? )
        // PLSQLCommons.g:107:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )?
        {
            this->followPush(FOLLOW_id_in_implementation_type_name497);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleimplementation_type_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:107:13: ( ( PERIOD id_expression )=> PERIOD id_expression )?
            {
                int alt14=2;
                {
                    int LA14_0 = this->LA(1);
                    if ( (LA14_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred3_PLSQLCommons>() )))
                    {
                        alt14=1;
                    }
                }
                switch (alt14)
                {
            	case 1:
            	    // PLSQLCommons.g:107:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_implementation_type_name507);
            	        if  (this->hasException())
            	        {
            	            goto ruleimplementation_type_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_implementation_type_name509);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleimplementation_type_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleimplementation_type_nameEx; /* Prevent compiler warnings */
    ruleimplementation_type_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end implementation_type_name */

/**
 * $ANTLR start parameter_name
 * PLSQLCommons.g:110:1: parameter_name : id ;
 */
void
PLSQLParser_PLSQLCommons::parameter_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:111:5: ( id )
        // PLSQLCommons.g:111:10: id
        {
            this->followPush(FOLLOW_id_in_parameter_name531);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleparameter_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleparameter_nameEx; /* Prevent compiler warnings */
    ruleparameter_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end parameter_name */

/**
 * $ANTLR start reference_model_name
 * PLSQLCommons.g:114:1: reference_model_name : id ;
 */
void
PLSQLParser_PLSQLCommons::reference_model_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:115:5: ( id )
        // PLSQLCommons.g:115:10: id
        {
            this->followPush(FOLLOW_id_in_reference_model_name551);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereference_model_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereference_model_nameEx; /* Prevent compiler warnings */
    rulereference_model_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end reference_model_name */

/**
 * $ANTLR start main_model_name
 * PLSQLCommons.g:118:1: main_model_name : id ;
 */
void
PLSQLParser_PLSQLCommons::main_model_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:119:5: ( id )
        // PLSQLCommons.g:119:10: id
        {
            this->followPush(FOLLOW_id_in_main_model_name571);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemain_model_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemain_model_nameEx; /* Prevent compiler warnings */
    rulemain_model_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end main_model_name */

/**
 * $ANTLR start aggregate_function_name
 * PLSQLCommons.g:122:1: aggregate_function_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )* ;
 */
void
PLSQLParser_PLSQLCommons::aggregate_function_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:123:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )* )
        // PLSQLCommons.g:123:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )*
        {
            this->followPush(FOLLOW_id_in_aggregate_function_name591);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleaggregate_function_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:123:13: ( ( PERIOD id_expression )=> PERIOD id_expression )*

            for (;;)
            {
                int alt15=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA15_0 = this->LA(1);
                    if ( (LA15_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred4_PLSQLCommons>() )))
                    {
                        alt15=1;
                    }

                }
                switch (alt15)
                {
            	case 1:
            	    // PLSQLCommons.g:123:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_aggregate_function_name601);
            	        if  (this->hasException())
            	        {
            	            goto ruleaggregate_function_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_aggregate_function_name603);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleaggregate_function_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop15;	/* break out of the loop */
            	    break;
                }
            }
            loop15: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleaggregate_function_nameEx; /* Prevent compiler warnings */
    ruleaggregate_function_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end aggregate_function_name */

/**
 * $ANTLR start query_name
 * PLSQLCommons.g:126:1: query_name : id ;
 */
void
PLSQLParser_PLSQLCommons::query_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:127:5: ( id )
        // PLSQLCommons.g:127:10: id
        {
            this->followPush(FOLLOW_id_in_query_name625);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulequery_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulequery_nameEx; /* Prevent compiler warnings */
    rulequery_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end query_name */

/**
 * $ANTLR start constraint_name
 * PLSQLCommons.g:130:1: constraint_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )* ( AT_SIGN link_name )? ;
 */
void
PLSQLParser_PLSQLCommons::constraint_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:131:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )* ( AT_SIGN link_name )? )
        // PLSQLCommons.g:131:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )* ( AT_SIGN link_name )?
        {
            this->followPush(FOLLOW_id_in_constraint_name645);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstraint_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:131:13: ( ( PERIOD id_expression )=> PERIOD id_expression )*

            for (;;)
            {
                int alt16=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA16_0 = this->LA(1);
                    if ( (LA16_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred5_PLSQLCommons>() )))
                    {
                        alt16=1;
                    }

                }
                switch (alt16)
                {
            	case 1:
            	    // PLSQLCommons.g:131:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_constraint_name655);
            	        if  (this->hasException())
            	        {
            	            goto ruleconstraint_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_constraint_name657);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstraint_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop16;	/* break out of the loop */
            	    break;
                }
            }
            loop16: ; /* Jump out to here if this rule does not match */


            // PLSQLCommons.g:131:62: ( AT_SIGN link_name )?
            {
                int alt17=2;
                {
                    int LA17_0 = this->LA(1);
                    if ( (LA17_0 == AT_SIGN))
                    {
                        alt17=1;
                    }
                }
                switch (alt17)
                {
            	case 1:
            	    // PLSQLCommons.g:131:63: AT_SIGN link_name
            	    {
            	         this->matchToken(AT_SIGN, &FOLLOW_AT_SIGN_in_constraint_name662);
            	        if  (this->hasException())
            	        {
            	            goto ruleconstraint_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_link_name_in_constraint_name664);
            	        link_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstraint_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconstraint_nameEx; /* Prevent compiler warnings */
    ruleconstraint_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end constraint_name */

/**
 * $ANTLR start label_name
 * PLSQLCommons.g:134:1: label_name : id_expression ;
 */
void
PLSQLParser_PLSQLCommons::label_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:135:5: ( id_expression )
        // PLSQLCommons.g:135:10: id_expression
        {
            this->followPush(FOLLOW_id_expression_in_label_name686);
            id_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelabel_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelabel_nameEx; /* Prevent compiler warnings */
    rulelabel_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end label_name */

/**
 * $ANTLR start type_name
 * PLSQLCommons.g:138:1: type_name : id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )* ;
 */
void
PLSQLParser_PLSQLCommons::type_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:139:5: ( id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )* )
        // PLSQLCommons.g:139:10: id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )*
        {
            this->followPush(FOLLOW_id_expression_in_type_name706);
            id_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletype_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:139:24: ( ( PERIOD id_expression )=> PERIOD id_expression )*

            for (;;)
            {
                int alt18=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA18_0 = this->LA(1);
                    if ( (LA18_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred6_PLSQLCommons>() )))
                    {
                        alt18=1;
                    }

                }
                switch (alt18)
                {
            	case 1:
            	    // PLSQLCommons.g:139:25: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_type_name716);
            	        if  (this->hasException())
            	        {
            	            goto ruletype_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_type_name718);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop18;	/* break out of the loop */
            	    break;
                }
            }
            loop18: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletype_nameEx; /* Prevent compiler warnings */
    ruletype_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end type_name */

/**
 * $ANTLR start sequence_name
 * PLSQLCommons.g:142:1: sequence_name : id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )* ;
 */
void
PLSQLParser_PLSQLCommons::sequence_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:143:5: ( id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )* )
        // PLSQLCommons.g:143:10: id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )*
        {
            this->followPush(FOLLOW_id_expression_in_sequence_name740);
            id_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesequence_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:143:24: ( ( PERIOD id_expression )=> PERIOD id_expression )*

            for (;;)
            {
                int alt19=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA19_0 = this->LA(1);
                    if ( (LA19_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred7_PLSQLCommons>() )))
                    {
                        alt19=1;
                    }

                }
                switch (alt19)
                {
            	case 1:
            	    // PLSQLCommons.g:143:25: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_sequence_name750);
            	        if  (this->hasException())
            	        {
            	            goto rulesequence_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_sequence_name752);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesequence_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop19;	/* break out of the loop */
            	    break;
                }
            }
            loop19: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesequence_nameEx; /* Prevent compiler warnings */
    rulesequence_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sequence_name */

/**
 * $ANTLR start exception_name
 * PLSQLCommons.g:146:1: exception_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )* ;
 */
void
PLSQLParser_PLSQLCommons::exception_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:147:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )* )
        // PLSQLCommons.g:147:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )*
        {
            this->followPush(FOLLOW_id_in_exception_name774);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexception_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:147:13: ( ( PERIOD id_expression )=> PERIOD id_expression )*

            for (;;)
            {
                int alt20=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA20_0 = this->LA(1);
                    if ( (LA20_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred8_PLSQLCommons>() )))
                    {
                        alt20=1;
                    }

                }
                switch (alt20)
                {
            	case 1:
            	    // PLSQLCommons.g:147:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_exception_name784);
            	        if  (this->hasException())
            	        {
            	            goto ruleexception_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_exception_name786);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexception_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop20;	/* break out of the loop */
            	    break;
                }
            }
            loop20: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexception_nameEx; /* Prevent compiler warnings */
    ruleexception_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exception_name */

/**
 * $ANTLR start function_name
 * PLSQLCommons.g:150:1: function_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )? ;
 */
void
PLSQLParser_PLSQLCommons::function_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:151:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )? )
        // PLSQLCommons.g:151:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )?
        {
            this->followPush(FOLLOW_id_in_function_name809);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunction_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:151:13: ( ( PERIOD id_expression )=> PERIOD id_expression )?
            {
                int alt21=2;
                {
                    int LA21_0 = this->LA(1);
                    if ( (LA21_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred9_PLSQLCommons>() )))
                    {
                        alt21=1;
                    }
                }
                switch (alt21)
                {
            	case 1:
            	    // PLSQLCommons.g:151:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_function_name819);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_function_name821);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunction_nameEx; /* Prevent compiler warnings */
    rulefunction_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end function_name */

/**
 * $ANTLR start procedure_name
 * PLSQLCommons.g:154:1: procedure_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )? ;
 */
void
PLSQLParser_PLSQLCommons::procedure_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:155:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )? )
        // PLSQLCommons.g:155:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )?
        {
            this->followPush(FOLLOW_id_in_procedure_name843);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprocedure_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:155:13: ( ( PERIOD id_expression )=> PERIOD id_expression )?
            {
                int alt22=2;
                {
                    int LA22_0 = this->LA(1);
                    if ( (LA22_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred10_PLSQLCommons>() )))
                    {
                        alt22=1;
                    }
                }
                switch (alt22)
                {
            	case 1:
            	    // PLSQLCommons.g:155:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_procedure_name853);
            	        if  (this->hasException())
            	        {
            	            goto ruleprocedure_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_procedure_name855);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprocedure_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprocedure_nameEx; /* Prevent compiler warnings */
    ruleprocedure_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end procedure_name */

/**
 * $ANTLR start trigger_name
 * PLSQLCommons.g:158:1: trigger_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )? ;
 */
void
PLSQLParser_PLSQLCommons::trigger_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:159:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )? )
        // PLSQLCommons.g:159:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )?
        {
            this->followPush(FOLLOW_id_in_trigger_name877);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletrigger_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:159:13: ( ( PERIOD id_expression )=> PERIOD id_expression )?
            {
                int alt23=2;
                {
                    int LA23_0 = this->LA(1);
                    if ( (LA23_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred11_PLSQLCommons>() )))
                    {
                        alt23=1;
                    }
                }
                switch (alt23)
                {
            	case 1:
            	    // PLSQLCommons.g:159:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_trigger_name887);
            	        if  (this->hasException())
            	        {
            	            goto ruletrigger_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_trigger_name889);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletrigger_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruletrigger_nameEx; /* Prevent compiler warnings */
    ruletrigger_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end trigger_name */

/**
 * $ANTLR start variable_name
 * PLSQLCommons.g:162:1: variable_name : ( ( INTRODUCER char_set_name )? id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )? | bind_variable );
 */
void
PLSQLParser_PLSQLCommons::variable_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:163:5: ( ( INTRODUCER char_set_name )? id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )? | bind_variable )

            ANTLR_UINT32 alt26;

            alt26=2;

            {
                int LA26_0 = this->LA(1);
                if ( (LA26_0 == DELIMITED_ID || LA26_0 == INTRODUCER || LA26_0 == REGULAR_ID))
                {
                    alt26=1;
                }
                else if ( (LA26_0 == BINDVAR || LA26_0 == COLON))
                {
                    alt26=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 26 );
                    ex->set_state( 0 );


                    goto rulevariable_nameEx;

                }
            }
            switch (alt26)
            {
        	case 1:
        	    // PLSQLCommons.g:163:10: ( INTRODUCER char_set_name )? id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )?
        	    {
        	        // PLSQLCommons.g:163:10: ( INTRODUCER char_set_name )?
        	        {
        	            int alt24=2;
        	            {
        	                int LA24_0 = this->LA(1);
        	                if ( (LA24_0 == INTRODUCER))
        	                {
        	                    alt24=1;
        	                }
        	            }
        	            switch (alt24)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:163:11: INTRODUCER char_set_name
        	        	    {
        	        	         this->matchToken(INTRODUCER, &FOLLOW_INTRODUCER_in_variable_name912);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulevariable_nameEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_char_set_name_in_variable_name914);
        	        	        char_set_name();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulevariable_nameEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_id_expression_in_variable_name930);
        	        id_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:164:27: ( ( PERIOD id_expression )=> PERIOD id_expression )?
        	        {
        	            int alt25=2;
        	            {
        	                int LA25_0 = this->LA(1);
        	                if ( (LA25_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred12_PLSQLCommons>() )))
        	                {
        	                    alt25=1;
        	                }
        	            }
        	            switch (alt25)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:164:28: ( PERIOD id_expression )=> PERIOD id_expression
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_variable_name940);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulevariable_nameEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_id_expression_in_variable_name942);
        	        	        id_expression();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulevariable_nameEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:165:10: bind_variable
        	    {
        	        this->followPush(FOLLOW_bind_variable_in_variable_name955);
        	        bind_variable();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulevariable_nameEx; /* Prevent compiler warnings */
    rulevariable_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end variable_name */

/**
 * $ANTLR start index_name
 * PLSQLCommons.g:168:1: index_name : id ;
 */
void
PLSQLParser_PLSQLCommons::index_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:169:5: ( id )
        // PLSQLCommons.g:169:10: id
        {
            this->followPush(FOLLOW_id_in_index_name975);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleindex_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleindex_nameEx; /* Prevent compiler warnings */
    ruleindex_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end index_name */

/**
 * $ANTLR start cursor_name
 * PLSQLCommons.g:172:1: cursor_name : ( id | bind_variable );
 */
void
PLSQLParser_PLSQLCommons::cursor_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:173:5: ( id | bind_variable )

            ANTLR_UINT32 alt27;

            alt27=2;

            {
                int LA27_0 = this->LA(1);
                if ( (LA27_0 == DELIMITED_ID || LA27_0 == INTRODUCER || LA27_0 == REGULAR_ID))
                {
                    alt27=1;
                }
                else if ( (LA27_0 == BINDVAR || LA27_0 == COLON))
                {
                    alt27=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 27 );
                    ex->set_state( 0 );


                    goto rulecursor_nameEx;

                }
            }
            switch (alt27)
            {
        	case 1:
        	    // PLSQLCommons.g:173:10: id
        	    {
        	        this->followPush(FOLLOW_id_in_cursor_name995);
        	        id();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecursor_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:174:10: bind_variable
        	    {
        	        this->followPush(FOLLOW_bind_variable_in_cursor_name1006);
        	        bind_variable();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecursor_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulecursor_nameEx; /* Prevent compiler warnings */
    rulecursor_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cursor_name */

/**
 * $ANTLR start record_name
 * PLSQLCommons.g:177:1: record_name : ( id | bind_variable );
 */
void
PLSQLParser_PLSQLCommons::record_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:178:5: ( id | bind_variable )

            ANTLR_UINT32 alt28;

            alt28=2;

            {
                int LA28_0 = this->LA(1);
                if ( (LA28_0 == DELIMITED_ID || LA28_0 == INTRODUCER || LA28_0 == REGULAR_ID))
                {
                    alt28=1;
                }
                else if ( (LA28_0 == BINDVAR || LA28_0 == COLON))
                {
                    alt28=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 28 );
                    ex->set_state( 0 );


                    goto rulerecord_nameEx;

                }
            }
            switch (alt28)
            {
        	case 1:
        	    // PLSQLCommons.g:178:10: id
        	    {
        	        this->followPush(FOLLOW_id_in_record_name1026);
        	        id();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulerecord_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:179:10: bind_variable
        	    {
        	        this->followPush(FOLLOW_bind_variable_in_record_name1037);
        	        bind_variable();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulerecord_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulerecord_nameEx; /* Prevent compiler warnings */
    rulerecord_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end record_name */

/**
 * $ANTLR start collection_name
 * PLSQLCommons.g:182:1: collection_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )? ;
 */
void
PLSQLParser_PLSQLCommons::collection_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:183:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )? )
        // PLSQLCommons.g:183:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )?
        {
            this->followPush(FOLLOW_id_in_collection_name1057);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecollection_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:183:13: ( ( PERIOD id_expression )=> PERIOD id_expression )?
            {
                int alt29=2;
                {
                    int LA29_0 = this->LA(1);
                    if ( (LA29_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred13_PLSQLCommons>() )))
                    {
                        alt29=1;
                    }
                }
                switch (alt29)
                {
            	case 1:
            	    // PLSQLCommons.g:183:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_collection_name1067);
            	        if  (this->hasException())
            	        {
            	            goto rulecollection_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_collection_name1069);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecollection_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulecollection_nameEx; /* Prevent compiler warnings */
    rulecollection_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end collection_name */

/**
 * $ANTLR start link_name
 * PLSQLCommons.g:186:1: link_name : id ;
 */
void
PLSQLParser_PLSQLCommons::link_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:187:5: ( id )
        // PLSQLCommons.g:187:10: id
        {
            this->followPush(FOLLOW_id_in_link_name1091);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelink_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelink_nameEx; /* Prevent compiler warnings */
    rulelink_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end link_name */

/**
 * $ANTLR start column_name
 * PLSQLCommons.g:190:1: column_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )* ;
 */
void
PLSQLParser_PLSQLCommons::column_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:191:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )* )
        // PLSQLCommons.g:191:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )*
        {
            this->followPush(FOLLOW_id_in_column_name1111);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecolumn_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:191:13: ( ( PERIOD id_expression )=> PERIOD id_expression )*

            for (;;)
            {
                int alt30=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA30_0 = this->LA(1);
                    if ( (LA30_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred14_PLSQLCommons>() )))
                    {
                        alt30=1;
                    }

                }
                switch (alt30)
                {
            	case 1:
            	    // PLSQLCommons.g:191:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_column_name1121);
            	        if  (this->hasException())
            	        {
            	            goto rulecolumn_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_column_name1123);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecolumn_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop30;	/* break out of the loop */
            	    break;
                }
            }
            loop30: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecolumn_nameEx; /* Prevent compiler warnings */
    rulecolumn_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end column_name */

/**
 * $ANTLR start tableview_name
 * PLSQLCommons.g:194:1: tableview_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )? ( AT_SIGN link_name |{...}? => partition_extension_clause )? ;
 */
void
PLSQLParser_PLSQLCommons::tableview_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:195:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )? ( AT_SIGN link_name |{...}? => partition_extension_clause )? )
        // PLSQLCommons.g:195:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )? ( AT_SIGN link_name |{...}? => partition_extension_clause )?
        {
            this->followPush(FOLLOW_id_in_tableview_name1145);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletableview_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:195:13: ( ( PERIOD id_expression )=> PERIOD id_expression )?
            {
                int alt31=2;
                {
                    int LA31_0 = this->LA(1);
                    if ( (LA31_0 == PERIOD))
                    {
                        {
                            int LA31_1 = this->LA(2);
                            if ( (LA31_1 == DELIMITED_ID || LA31_1 == REGULAR_ID) && (this->msynpred( antlr3::ClassForwarder<synpred15_PLSQLCommons>() )))
                            {
                                alt31=1;
                            }
                        }
                    }
                }
                switch (alt31)
                {
            	case 1:
            	    // PLSQLCommons.g:195:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_tableview_name1155);
            	        if  (this->hasException())
            	        {
            	            goto ruletableview_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_tableview_name1157);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletableview_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLCommons.g:196:5: ( AT_SIGN link_name |{...}? => partition_extension_clause )?
            {
                int alt32=3;
                alt32 = cdfa32.predict(this, this->get_rec(), this->get_istream(), cdfa32 );
                if  (this->hasException())
                {
                    goto ruletableview_nameEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }

                switch (alt32)
                {
            	case 1:
            	    // PLSQLCommons.g:196:10: AT_SIGN link_name
            	    {
            	         this->matchToken(AT_SIGN, &FOLLOW_AT_SIGN_in_tableview_name1171);
            	        if  (this->hasException())
            	        {
            	            goto ruletableview_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_link_name_in_tableview_name1173);
            	        link_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletableview_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:197:10: {...}? => partition_extension_clause
            	    {
            	        if ( !((!(LA(2) == SQL92_RESERVED_BY))) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return ;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "!(LA(2) == SQL92_RESERVED_BY)" );
            	                ex->set_ruleName( "tableview_name" );


            	        }

            	        this->followPush(FOLLOW_partition_extension_clause_in_tableview_name1187);
            	        partition_extension_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletableview_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruletableview_nameEx; /* Prevent compiler warnings */
    ruletableview_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end tableview_name */

/**
 * $ANTLR start char_set_name
 * PLSQLCommons.g:201:1: char_set_name : id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )* ;
 */
void
PLSQLParser_PLSQLCommons::char_set_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:202:5: ( id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )* )
        // PLSQLCommons.g:202:10: id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )*
        {
            this->followPush(FOLLOW_id_expression_in_char_set_name1214);
            id_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulechar_set_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:202:24: ( ( PERIOD id_expression )=> PERIOD id_expression )*

            for (;;)
            {
                int alt33=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA33_0 = this->LA(1);
                    if ( (LA33_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred16_PLSQLCommons>() )))
                    {
                        alt33=1;
                    }

                }
                switch (alt33)
                {
            	case 1:
            	    // PLSQLCommons.g:202:25: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_char_set_name1224);
            	        if  (this->hasException())
            	        {
            	            goto rulechar_set_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_char_set_name1226);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulechar_set_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop33;	/* break out of the loop */
            	    break;
                }
            }
            loop33: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulechar_set_nameEx; /* Prevent compiler warnings */
    rulechar_set_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end char_set_name */

/**
 * $ANTLR start keep_clause
 * PLSQLCommons.g:210:1: keep_clause : keep_key LEFT_PAREN dense_rank_key ( first_key | last_key ) order_by_clause RIGHT_PAREN ( over_clause )? ;
 */
void
PLSQLParser_PLSQLCommons::keep_clause()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:211:5: ( keep_key LEFT_PAREN dense_rank_key ( first_key | last_key ) order_by_clause RIGHT_PAREN ( over_clause )? )
        // PLSQLCommons.g:211:9: keep_key LEFT_PAREN dense_rank_key ( first_key | last_key ) order_by_clause RIGHT_PAREN ( over_clause )?
        {
            this->followPush(FOLLOW_keep_key_in_keep_clause1252);
            m_gPLSQLParser->keep_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulekeep_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_keep_clause1262);
            if  (this->hasException())
            {
                goto rulekeep_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_dense_rank_key_in_keep_clause1276);
            m_gPLSQLParser->dense_rank_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulekeep_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:213:28: ( first_key | last_key )
            {
                int alt34=2;
                {
                    int LA34_0 = this->LA(1);
                    if ( (LA34_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FIRST")))||((equalsIgnoreCase(LT(1)->getText(), "LAST"))))))
                    {
                        {
                            int LA34_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "FIRST"))))
                            {
                                alt34=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "LAST"))))
                            {
                                alt34=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 34 );
                                ex->set_state( 1 );


                                goto rulekeep_clauseEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 34 );
                        ex->set_state( 0 );


                        goto rulekeep_clauseEx;

                    }
                }
                switch (alt34)
                {
            	case 1:
            	    // PLSQLCommons.g:213:29: first_key
            	    {
            	        this->followPush(FOLLOW_first_key_in_keep_clause1279);
            	        m_gPLSQLParser->first_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulekeep_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:213:39: last_key
            	    {
            	        this->followPush(FOLLOW_last_key_in_keep_clause1281);
            	        m_gPLSQLParser->last_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulekeep_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_order_by_clause_in_keep_clause1297);
            m_gPLSQLParser->order_by_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulekeep_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_keep_clause1307);
            if  (this->hasException())
            {
                goto rulekeep_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:215:21: ( over_clause )?
            {
                int alt35=2;
                alt35 = cdfa35.predict(this, this->get_rec(), this->get_istream(), cdfa35 );
                if  (this->hasException())
                {
                    goto rulekeep_clauseEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }

                switch (alt35)
                {
            	case 1:
            	    // PLSQLCommons.g:215:21: over_clause
            	    {
            	        this->followPush(FOLLOW_over_clause_in_keep_clause1309);
            	        m_gPLSQLParser->over_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulekeep_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulekeep_clauseEx; /* Prevent compiler warnings */
    rulekeep_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end keep_clause */

/**
 * $ANTLR start function_argument
 * PLSQLCommons.g:218:1: function_argument : LEFT_PAREN ( argument )? ( COMMA argument )* RIGHT_PAREN ( keep_clause )? ;
 */
void
PLSQLParser_PLSQLCommons::function_argument()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:219:5: ( LEFT_PAREN ( argument )? ( COMMA argument )* RIGHT_PAREN ( keep_clause )? )
        // PLSQLCommons.g:219:10: LEFT_PAREN ( argument )? ( COMMA argument )* RIGHT_PAREN ( keep_clause )?
        {
             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_function_argument1330);
            if  (this->hasException())
            {
                goto rulefunction_argumentEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:220:13: ( argument )?
            {
                int alt36=2;
                {
                    int LA36_0 = this->LA(1);
                    if ( (LA36_0 == APPROXIMATE_NUM_LIT || LA36_0 == BINDVAR || ((LA36_0 >= CHAR_STRING) && (LA36_0 <= COLON)) || LA36_0 == DELIMITED_ID || LA36_0 == EXACT_NUM_LIT || LA36_0 == INTRODUCER || LA36_0 == LEFT_PAREN || ((LA36_0 >= MINUS_SIGN) && (LA36_0 <= NATIONAL_CHAR_STRING_LIT)) || LA36_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA36_0 == PLUS_SIGN || LA36_0 == REGULAR_ID || LA36_0 == SQL92_RESERVED_ALL || LA36_0 == SQL92_RESERVED_ANY || LA36_0 == SQL92_RESERVED_CASE || ((LA36_0 >= SQL92_RESERVED_CURSOR) && (LA36_0 <= SQL92_RESERVED_DATE)) || LA36_0 == SQL92_RESERVED_DEFAULT || LA36_0 == SQL92_RESERVED_DISTINCT || ((LA36_0 >= SQL92_RESERVED_EXISTS) && (LA36_0 <= SQL92_RESERVED_FALSE)) || ((LA36_0 >= SQL92_RESERVED_NOT) && (LA36_0 <= SQL92_RESERVED_NULL)) || LA36_0 == SQL92_RESERVED_PRIOR || LA36_0 == SQL92_RESERVED_TRUE || LA36_0 == UNSIGNED_INTEGER))
                    {
                        alt36=1;
                    }
                }
                switch (alt36)
                {
            	case 1:
            	    // PLSQLCommons.g:220:13: argument
            	    {
            	        this->followPush(FOLLOW_argument_in_function_argument1345);
            	        argument();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLCommons.g:220:23: ( COMMA argument )*

            for (;;)
            {
                int alt37=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA37_0 = this->LA(1);
                    if ( (LA37_0 == COMMA))
                    {
                        alt37=1;
                    }

                }
                switch (alt37)
                {
            	case 1:
            	    // PLSQLCommons.g:220:24: COMMA argument
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_function_argument1349);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_argument_in_function_argument1351);
            	        argument();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop37;	/* break out of the loop */
            	    break;
                }
            }
            loop37: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_function_argument1365);
            if  (this->hasException())
            {
                goto rulefunction_argumentEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:222:9: ( keep_clause )?
            {
                int alt38=2;
                {
                    int LA38_0 = this->LA(1);
                    if ( (LA38_0 == REGULAR_ID))
                    {
                        {
                            int LA38_1 = this->LA(2);
                            if ( (LA38_1 == LEFT_PAREN))
                            {
                                {
                                    int LA38_3 = this->LA(3);
                                    if ( (LA38_3 == REGULAR_ID))
                                    {
                                        {
                                            int LA38_10 = this->LA(4);
                                            if ( (LA38_10 == REGULAR_ID))
                                            {
                                                {
                                                    int LA38_15 = this->LA(5);
                                                    if ( (LA38_15 == SQL92_RESERVED_ORDER) && ((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))
                                                    {
                                                        alt38=1;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt38)
                {
            	case 1:
            	    // PLSQLCommons.g:222:9: keep_clause
            	    {
            	        this->followPush(FOLLOW_keep_clause_in_function_argument1375);
            	        keep_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunction_argumentEx; /* Prevent compiler warnings */
    rulefunction_argumentEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end function_argument */

/**
 * $ANTLR start function_argument_analytic
 * PLSQLCommons.g:225:1: function_argument_analytic : LEFT_PAREN ( argument ( respect_or_ignore_nulls )? )? ( COMMA argument ( respect_or_ignore_nulls )? )* RIGHT_PAREN ( keep_clause )? ;
 */
void
PLSQLParser_PLSQLCommons::function_argument_analytic()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:226:5: ( LEFT_PAREN ( argument ( respect_or_ignore_nulls )? )? ( COMMA argument ( respect_or_ignore_nulls )? )* RIGHT_PAREN ( keep_clause )? )
        // PLSQLCommons.g:226:10: LEFT_PAREN ( argument ( respect_or_ignore_nulls )? )? ( COMMA argument ( respect_or_ignore_nulls )? )* RIGHT_PAREN ( keep_clause )?
        {
             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_function_argument_analytic1396);
            if  (this->hasException())
            {
                goto rulefunction_argument_analyticEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:227:13: ( argument ( respect_or_ignore_nulls )? )?
            {
                int alt40=2;
                {
                    int LA40_0 = this->LA(1);
                    if ( (LA40_0 == APPROXIMATE_NUM_LIT || LA40_0 == BINDVAR || ((LA40_0 >= CHAR_STRING) && (LA40_0 <= COLON)) || LA40_0 == DELIMITED_ID || LA40_0 == EXACT_NUM_LIT || LA40_0 == INTRODUCER || LA40_0 == LEFT_PAREN || ((LA40_0 >= MINUS_SIGN) && (LA40_0 <= NATIONAL_CHAR_STRING_LIT)) || LA40_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA40_0 == PLUS_SIGN || LA40_0 == REGULAR_ID || LA40_0 == SQL92_RESERVED_ALL || LA40_0 == SQL92_RESERVED_ANY || LA40_0 == SQL92_RESERVED_CASE || ((LA40_0 >= SQL92_RESERVED_CURSOR) && (LA40_0 <= SQL92_RESERVED_DATE)) || LA40_0 == SQL92_RESERVED_DEFAULT || LA40_0 == SQL92_RESERVED_DISTINCT || ((LA40_0 >= SQL92_RESERVED_EXISTS) && (LA40_0 <= SQL92_RESERVED_FALSE)) || ((LA40_0 >= SQL92_RESERVED_NOT) && (LA40_0 <= SQL92_RESERVED_NULL)) || LA40_0 == SQL92_RESERVED_PRIOR || LA40_0 == SQL92_RESERVED_TRUE || LA40_0 == UNSIGNED_INTEGER))
                    {
                        alt40=1;
                    }
                }
                switch (alt40)
                {
            	case 1:
            	    // PLSQLCommons.g:227:14: argument ( respect_or_ignore_nulls )?
            	    {
            	        this->followPush(FOLLOW_argument_in_function_argument_analytic1411);
            	        argument();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_analyticEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLCommons.g:227:23: ( respect_or_ignore_nulls )?
            	        {
            	            int alt39=2;
            	            {
            	                int LA39_0 = this->LA(1);
            	                if ( (LA39_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "RESPECT"))))))
            	                {
            	                    alt39=1;
            	                }
            	            }
            	            switch (alt39)
            	            {
            	        	case 1:
            	        	    // PLSQLCommons.g:227:23: respect_or_ignore_nulls
            	        	    {
            	        	        this->followPush(FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic1413);
            	        	        respect_or_ignore_nulls();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_analyticEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // PLSQLCommons.g:228:13: ( COMMA argument ( respect_or_ignore_nulls )? )*

            for (;;)
            {
                int alt42=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA42_0 = this->LA(1);
                    if ( (LA42_0 == COMMA))
                    {
                        alt42=1;
                    }

                }
                switch (alt42)
                {
            	case 1:
            	    // PLSQLCommons.g:228:14: COMMA argument ( respect_or_ignore_nulls )?
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_function_argument_analytic1431);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_analyticEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_argument_in_function_argument_analytic1433);
            	        argument();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_analyticEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLCommons.g:228:29: ( respect_or_ignore_nulls )?
            	        {
            	            int alt41=2;
            	            {
            	                int LA41_0 = this->LA(1);
            	                if ( (LA41_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "RESPECT"))))))
            	                {
            	                    alt41=1;
            	                }
            	            }
            	            switch (alt41)
            	            {
            	        	case 1:
            	        	    // PLSQLCommons.g:228:29: respect_or_ignore_nulls
            	        	    {
            	        	        this->followPush(FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic1435);
            	        	        respect_or_ignore_nulls();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_analyticEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop42;	/* break out of the loop */
            	    break;
                }
            }
            loop42: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_function_argument_analytic1450);
            if  (this->hasException())
            {
                goto rulefunction_argument_analyticEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:230:10: ( keep_clause )?
            {
                int alt43=2;
                {
                    int LA43_0 = this->LA(1);
                    if ( (LA43_0 == REGULAR_ID))
                    {
                        {
                            int LA43_1 = this->LA(2);
                            if ( (LA43_1 == LEFT_PAREN))
                            {
                                {
                                    int LA43_3 = this->LA(3);
                                    if ( (LA43_3 == REGULAR_ID))
                                    {
                                        {
                                            int LA43_11 = this->LA(4);
                                            if ( (LA43_11 == REGULAR_ID))
                                            {
                                                {
                                                    int LA43_16 = this->LA(5);
                                                    if ( (LA43_16 == SQL92_RESERVED_ORDER) && ((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))
                                                    {
                                                        alt43=1;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt43)
                {
            	case 1:
            	    // PLSQLCommons.g:230:10: keep_clause
            	    {
            	        this->followPush(FOLLOW_keep_clause_in_function_argument_analytic1461);
            	        keep_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_analyticEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunction_argument_analyticEx; /* Prevent compiler warnings */
    rulefunction_argument_analyticEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end function_argument_analytic */

/**
 * $ANTLR start function_argument_modeling
 * PLSQLCommons.g:233:1: function_argument_modeling : LEFT_PAREN column_name ( COMMA ( numeric | null_key ) ( COMMA ( numeric | null_key ) )? )? using_key ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK | ASTERISK | expression ( column_alias )? ( COMMA expression ( column_alias )? )* ) RIGHT_PAREN ( keep_clause )? ;
 */
void
PLSQLParser_PLSQLCommons::function_argument_modeling()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:234:5: ( LEFT_PAREN column_name ( COMMA ( numeric | null_key ) ( COMMA ( numeric | null_key ) )? )? using_key ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK | ASTERISK | expression ( column_alias )? ( COMMA expression ( column_alias )? )* ) RIGHT_PAREN ( keep_clause )? )
        // PLSQLCommons.g:234:10: LEFT_PAREN column_name ( COMMA ( numeric | null_key ) ( COMMA ( numeric | null_key ) )? )? using_key ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK | ASTERISK | expression ( column_alias )? ( COMMA expression ( column_alias )? )* ) RIGHT_PAREN ( keep_clause )?
        {
             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_function_argument_modeling1482);
            if  (this->hasException())
            {
                goto rulefunction_argument_modelingEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_function_argument_modeling1496);
            column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunction_argument_modelingEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:235:25: ( COMMA ( numeric | null_key ) ( COMMA ( numeric | null_key ) )? )?
            {
                int alt47=2;
                {
                    int LA47_0 = this->LA(1);
                    if ( (LA47_0 == COMMA))
                    {
                        alt47=1;
                    }
                }
                switch (alt47)
                {
            	case 1:
            	    // PLSQLCommons.g:235:26: COMMA ( numeric | null_key ) ( COMMA ( numeric | null_key ) )?
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_function_argument_modeling1499);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLCommons.g:235:32: ( numeric | null_key )
            	        {
            	            int alt44=2;
            	            {
            	                int LA44_0 = this->LA(1);
            	                if ( (LA44_0 == APPROXIMATE_NUM_LIT || LA44_0 == EXACT_NUM_LIT || LA44_0 == UNSIGNED_INTEGER))
            	                {
            	                    alt44=1;
            	                }
            	                else if ( (LA44_0 == SQL92_RESERVED_NULL))
            	                {
            	                    alt44=2;
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 44 );
            	                    ex->set_state( 0 );


            	                    goto rulefunction_argument_modelingEx;

            	                }
            	            }
            	            switch (alt44)
            	            {
            	        	case 1:
            	        	    // PLSQLCommons.g:235:33: numeric
            	        	    {
            	        	        this->followPush(FOLLOW_numeric_in_function_argument_modeling1502);
            	        	        numeric();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_modelingEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQLCommons.g:235:41: null_key
            	        	    {
            	        	        this->followPush(FOLLOW_null_key_in_function_argument_modeling1504);
            	        	        m_gPLSQLParser->null_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_modelingEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQLCommons.g:235:51: ( COMMA ( numeric | null_key ) )?
            	        {
            	            int alt46=2;
            	            {
            	                int LA46_0 = this->LA(1);
            	                if ( (LA46_0 == COMMA))
            	                {
            	                    alt46=1;
            	                }
            	            }
            	            switch (alt46)
            	            {
            	        	case 1:
            	        	    // PLSQLCommons.g:235:52: COMMA ( numeric | null_key )
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_function_argument_modeling1508);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_modelingEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // PLSQLCommons.g:235:58: ( numeric | null_key )
            	        	        {
            	        	            int alt45=2;
            	        	            {
            	        	                int LA45_0 = this->LA(1);
            	        	                if ( (LA45_0 == APPROXIMATE_NUM_LIT || LA45_0 == EXACT_NUM_LIT || LA45_0 == UNSIGNED_INTEGER))
            	        	                {
            	        	                    alt45=1;
            	        	                }
            	        	                else if ( (LA45_0 == SQL92_RESERVED_NULL))
            	        	                {
            	        	                    alt45=2;
            	        	                }
            	        	                else
            	        	                {
            	        	                    if (this->get_backtracking()>0)
            	        	                    {
            	        	                        this->set_failedflag( true );
            	        	                        return ;
            	        	                    }


            	        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	        	                    ex->set_decisionNum( 45 );
            	        	                    ex->set_state( 0 );


            	        	                    goto rulefunction_argument_modelingEx;

            	        	                }
            	        	            }
            	        	            switch (alt45)
            	        	            {
            	        	        	case 1:
            	        	        	    // PLSQLCommons.g:235:59: numeric
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_numeric_in_function_argument_modeling1511);
            	        	        	        numeric();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto rulefunction_argument_modelingEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // PLSQLCommons.g:235:67: null_key
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_null_key_in_function_argument_modeling1513);
            	        	        	        m_gPLSQLParser->null_key();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto rulefunction_argument_modelingEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_using_key_in_function_argument_modeling1534);
            m_gPLSQLParser->using_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunction_argument_modelingEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:237:17: ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK | ASTERISK | expression ( column_alias )? ( COMMA expression ( column_alias )? )* )
            {
                int alt51=3;
                switch ( this->LA(1) )
                {
                case INTRODUCER:
                	{
                		{
                		    int LA51_1 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred17_PLSQLCommons>() )))
                		    {
                		        alt51=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt51=3;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 51 );
                		        ex->set_state( 1 );


                		        goto rulefunction_argument_modelingEx;

                		    }
                		}
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    int LA51_2 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred17_PLSQLCommons>() )))
                		    {
                		        alt51=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt51=3;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 51 );
                		        ex->set_state( 2 );


                		        goto rulefunction_argument_modelingEx;

                		    }
                		}
                	}
                    break;
                case ASTERISK:
                	{
                		alt51=2;
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case EXACT_NUM_LIT:
                case LEFT_PAREN:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURSOR:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt51=3;
                	}
                    break;
                case DELIMITED_ID:
                	{
                		{
                		    int LA51_10 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred17_PLSQLCommons>() )))
                		    {
                		        alt51=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt51=3;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 51 );
                		        ex->set_state( 10 );


                		        goto rulefunction_argument_modelingEx;

                		    }
                		}
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 51 );
                    ex->set_state( 0 );


                    goto rulefunction_argument_modelingEx;

                }

                switch (alt51)
                {
            	case 1:
            	    // PLSQLCommons.g:237:19: ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK
            	    {
            	        this->followPush(FOLLOW_tableview_name_in_function_argument_modeling1563);
            	        tableview_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_function_argument_modeling1565);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_function_argument_modeling1567);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:238:19: ASTERISK
            	    {
            	         this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_function_argument_modeling1587);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLCommons.g:239:19: expression ( column_alias )? ( COMMA expression ( column_alias )? )*
            	    {
            	        this->followPush(FOLLOW_expression_in_function_argument_modeling1607);
            	        m_gPLSQLParser->expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLCommons.g:239:30: ( column_alias )?
            	        {
            	            int alt48=2;
            	            {
            	                int LA48_0 = this->LA(1);
            	                if ( (((LA48_0 >= CHAR_STRING) && (LA48_0 <= CHAR_STRING_PERL)) || LA48_0 == DELIMITED_ID || LA48_0 == INTRODUCER || LA48_0 == NATIONAL_CHAR_STRING_LIT || LA48_0 == REGULAR_ID || LA48_0 == SQL92_RESERVED_AS))
            	                {
            	                    alt48=1;
            	                }
            	            }
            	            switch (alt48)
            	            {
            	        	case 1:
            	        	    // PLSQLCommons.g:239:30: column_alias
            	        	    {
            	        	        this->followPush(FOLLOW_column_alias_in_function_argument_modeling1609);
            	        	        column_alias();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_modelingEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQLCommons.g:239:44: ( COMMA expression ( column_alias )? )*

            	        for (;;)
            	        {
            	            int alt50=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA50_0 = this->LA(1);
            	                if ( (LA50_0 == COMMA))
            	                {
            	                    alt50=1;
            	                }

            	            }
            	            switch (alt50)
            	            {
            	        	case 1:
            	        	    // PLSQLCommons.g:239:45: COMMA expression ( column_alias )?
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_function_argument_modeling1613);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_modelingEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_expression_in_function_argument_modeling1615);
            	        	        m_gPLSQLParser->expression();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_modelingEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // PLSQLCommons.g:239:62: ( column_alias )?
            	        	        {
            	        	            int alt49=2;
            	        	            {
            	        	                int LA49_0 = this->LA(1);
            	        	                if ( (((LA49_0 >= CHAR_STRING) && (LA49_0 <= CHAR_STRING_PERL)) || LA49_0 == DELIMITED_ID || LA49_0 == INTRODUCER || LA49_0 == NATIONAL_CHAR_STRING_LIT || LA49_0 == REGULAR_ID || LA49_0 == SQL92_RESERVED_AS))
            	        	                {
            	        	                    alt49=1;
            	        	                }
            	        	            }
            	        	            switch (alt49)
            	        	            {
            	        	        	case 1:
            	        	        	    // PLSQLCommons.g:239:62: column_alias
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_column_alias_in_function_argument_modeling1617);
            	        	        	        column_alias();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto rulefunction_argument_modelingEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop50;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop50: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_function_argument_modeling1649);
            if  (this->hasException())
            {
                goto rulefunction_argument_modelingEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:242:10: ( keep_clause )?
            {
                int alt52=2;
                {
                    int LA52_0 = this->LA(1);
                    if ( (LA52_0 == REGULAR_ID))
                    {
                        {
                            int LA52_1 = this->LA(2);
                            if ( (LA52_1 == LEFT_PAREN))
                            {
                                {
                                    int LA52_3 = this->LA(3);
                                    if ( (LA52_3 == REGULAR_ID))
                                    {
                                        {
                                            int LA52_11 = this->LA(4);
                                            if ( (LA52_11 == REGULAR_ID))
                                            {
                                                {
                                                    int LA52_15 = this->LA(5);
                                                    if ( (LA52_15 == SQL92_RESERVED_ORDER) && ((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))
                                                    {
                                                        alt52=1;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt52)
                {
            	case 1:
            	    // PLSQLCommons.g:242:10: keep_clause
            	    {
            	        this->followPush(FOLLOW_keep_clause_in_function_argument_modeling1660);
            	        keep_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunction_argument_modelingEx; /* Prevent compiler warnings */
    rulefunction_argument_modelingEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end function_argument_modeling */

/**
 * $ANTLR start respect_or_ignore_nulls
 * PLSQLCommons.g:245:1: respect_or_ignore_nulls : ( respect_key | ignore_key ) nulls_key ;
 */
void
PLSQLParser_PLSQLCommons::respect_or_ignore_nulls()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:246:5: ( ( respect_key | ignore_key ) nulls_key )
        // PLSQLCommons.g:246:10: ( respect_key | ignore_key ) nulls_key
        {
            // PLSQLCommons.g:246:10: ( respect_key | ignore_key )
            {
                int alt53=2;
                {
                    int LA53_0 = this->LA(1);
                    if ( (LA53_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "RESPECT"))))))
                    {
                        {
                            int LA53_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "RESPECT"))))
                            {
                                alt53=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "IGNORE"))))
                            {
                                alt53=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 53 );
                                ex->set_state( 1 );


                                goto rulerespect_or_ignore_nullsEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 53 );
                        ex->set_state( 0 );


                        goto rulerespect_or_ignore_nullsEx;

                    }
                }
                switch (alt53)
                {
            	case 1:
            	    // PLSQLCommons.g:246:11: respect_key
            	    {
            	        this->followPush(FOLLOW_respect_key_in_respect_or_ignore_nulls1682);
            	        m_gPLSQLParser->respect_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerespect_or_ignore_nullsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:246:25: ignore_key
            	    {
            	        this->followPush(FOLLOW_ignore_key_in_respect_or_ignore_nulls1686);
            	        m_gPLSQLParser->ignore_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerespect_or_ignore_nullsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_nulls_key_in_respect_or_ignore_nulls1689);
            m_gPLSQLParser->nulls_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerespect_or_ignore_nullsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerespect_or_ignore_nullsEx; /* Prevent compiler warnings */
    rulerespect_or_ignore_nullsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end respect_or_ignore_nulls */

/**
 * $ANTLR start argument
 * PLSQLCommons.g:249:1: argument : ( ( id EQUALS_OP GREATER_THAN_OP )=> id EQUALS_OP GREATER_THAN_OP )? expression_wrapper ;
 */
void
PLSQLParser_PLSQLCommons::argument()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:250:5: ( ( ( id EQUALS_OP GREATER_THAN_OP )=> id EQUALS_OP GREATER_THAN_OP )? expression_wrapper )
        // PLSQLCommons.g:250:10: ( ( id EQUALS_OP GREATER_THAN_OP )=> id EQUALS_OP GREATER_THAN_OP )? expression_wrapper
        {
            // PLSQLCommons.g:250:10: ( ( id EQUALS_OP GREATER_THAN_OP )=> id EQUALS_OP GREATER_THAN_OP )?
            {
                int alt54=2;
                alt54 = cdfa54.predict(this, this->get_rec(), this->get_istream(), cdfa54 );
                if  (this->hasException())
                {
                    goto ruleargumentEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }

                switch (alt54)
                {
            	case 1:
            	    // PLSQLCommons.g:250:11: ( id EQUALS_OP GREATER_THAN_OP )=> id EQUALS_OP GREATER_THAN_OP
            	    {
            	        this->followPush(FOLLOW_id_in_argument1719);
            	        id();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleargumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_argument1721);
            	        if  (this->hasException())
            	        {
            	            goto ruleargumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(GREATER_THAN_OP, &FOLLOW_GREATER_THAN_OP_in_argument1723);
            	        if  (this->hasException())
            	        {
            	            goto ruleargumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_expression_wrapper_in_argument1727);
            m_gPLSQLParser->expression_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleargumentEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleargumentEx; /* Prevent compiler warnings */
    ruleargumentEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end argument */

/**
 * $ANTLR start type_spec
 * PLSQLCommons.g:253:1: type_spec : ( datatype | ( ref_key )? type_name ( percent_rowtype_key | percent_type_key )? );
 */
void
PLSQLParser_PLSQLCommons::type_spec()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:254:5: ( datatype | ( ref_key )? type_name ( percent_rowtype_key | percent_type_key )? )

            ANTLR_UINT32 alt57;

            alt57=2;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    int LA57_1 = this->LA(2);
            		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "DAY")))||((equalsIgnoreCase(LT(1)->getText(), "NUMERIC")))||((equalsIgnoreCase(LT(1)->getText(), "BINARY_INTEGER")))||((equalsIgnoreCase(LT(1)->getText(), "REAL")))||((equalsIgnoreCase(LT(1)->getText(), "STRING")))||((equalsIgnoreCase(LT(1)->getText(), "POSITIVE")))||((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_ABBR")))||((equalsIgnoreCase(LT(1)->getText(), "DEC")))||((equalsIgnoreCase(LT(1)->getText(), "ROWID")))||((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_HOUR")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_TZ_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "SIGNTYPE")))||((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE")))||((equalsIgnoreCase(LT(1)->getText(), "LONG")))||((equalsIgnoreCase(LT(1)->getText(), "RAW")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_LTZ_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "VARCHAR")))||((equalsIgnoreCase(LT(1)->getText(), "CLOB")))||((equalsIgnoreCase(LT(1)->getText(), "YEAR")))||((equalsIgnoreCase(LT(1)->getText(), "CHAR")))||((equalsIgnoreCase(LT(1)->getText(), "CHARACTER")))||((equalsIgnoreCase(LT(1)->getText(), "PLS_INTEGER")))||((equalsIgnoreCase(LT(1)->getText(), "SECOND")))||((equalsIgnoreCase(LT(1)->getText(), "NVARCHAR2")))||((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_MINUTE")))||((equalsIgnoreCase(LT(1)->getText(), "NATURAL")))||((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||((equalsIgnoreCase(LT(1)->getText(), "HOUR")))||((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_REGION")))||((equalsIgnoreCase(LT(1)->getText(), "POSITIVEN")))||((equalsIgnoreCase(LT(1)->getText(), "YMINTERVAL_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "INT")))||((equalsIgnoreCase(LT(1)->getText(), "INTEGER")))||((equalsIgnoreCase(LT(1)->getText(), "VARCHAR2")))||((equalsIgnoreCase(LT(1)->getText(), "MINUTE")))||((equalsIgnoreCase(LT(1)->getText(), "DOUBLE")))||((equalsIgnoreCase(LT(1)->getText(), "FLOAT")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "NCLOB")))||((equalsIgnoreCase(LT(1)->getText(), "NATURALN")))||((equalsIgnoreCase(LT(1)->getText(), "NUMBER")))||((equalsIgnoreCase(LT(1)->getText(), "DECIMAL")))||((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT")))||((equalsIgnoreCase(LT(1)->getText(), "NCHAR")))||((equalsIgnoreCase(LT(1)->getText(), "MONTH")))||((equalsIgnoreCase(LT(1)->getText(), "SMALLINT")))||((equalsIgnoreCase(LT(1)->getText(), "MLSLABEL")))||((equalsIgnoreCase(LT(1)->getText(), "UROWID")))||((equalsIgnoreCase(LT(1)->getText(), "BOOLEAN")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP")))||((equalsIgnoreCase(LT(1)->getText(), "DSINTERVAL_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "SIMPLE_INTEGER")))||((equalsIgnoreCase(LT(1)->getText(), "BLOB")))||((equalsIgnoreCase(LT(1)->getText(), "BFILE"))))))
            		    {
            		        alt57=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt57=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 57 );
            		        ex->set_state( 1 );


            		        goto ruletype_specEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_DATE:
            	{
            		alt57=1;
            	}
                break;
            case DELIMITED_ID:
            	{
            		alt57=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 57 );
                ex->set_state( 0 );


                goto ruletype_specEx;

            }

            switch (alt57)
            {
        	case 1:
        	    // PLSQLCommons.g:254:11: datatype
        	    {
        	        this->followPush(FOLLOW_datatype_in_type_spec1748);
        	        datatype();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletype_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:255:10: ( ref_key )? type_name ( percent_rowtype_key | percent_type_key )?
        	    {
        	        // PLSQLCommons.g:255:10: ( ref_key )?
        	        {
        	            int alt55=2;
        	            {
        	                int LA55_0 = this->LA(1);
        	                if ( (LA55_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA55_1 = this->LA(2);
        	                        if ( (LA55_1 == REGULAR_ID))
        	                        {
        	                            {
        	                                int LA55_3 = this->LA(3);
        	                                if ( ((equalsIgnoreCase(LT(1)->getText(), "REF"))))
        	                                {
        	                                    alt55=1;
        	                                }
        	                            }
        	                        }
        	                        else if ( (LA55_1 == DELIMITED_ID) && ((equalsIgnoreCase(LT(1)->getText(), "REF"))))
        	                        {
        	                            alt55=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt55)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:255:10: ref_key
        	        	    {
        	        	        this->followPush(FOLLOW_ref_key_in_type_spec1759);
        	        	        m_gPLSQLParser->ref_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruletype_specEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_type_name_in_type_spec1762);
        	        type_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletype_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:255:29: ( percent_rowtype_key | percent_type_key )?
        	        {
        	            int alt56=3;
        	            {
        	                int LA56_0 = this->LA(1);
        	                if ( (LA56_0 == PERCENT) && ((((equalsIgnoreCase(LT(2)->getText(), "TYPE")))||((equalsIgnoreCase(LT(2)->getText(), "ROWTYPE"))))))
        	                {
        	                    {
        	                        int LA56_1 = this->LA(2);
        	                        if ( (LA56_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(2)->getText(), "TYPE")))||((equalsIgnoreCase(LT(2)->getText(), "ROWTYPE"))))))
        	                        {
        	                            {
        	                                int LA56_3 = this->LA(3);
        	                                if ( ((equalsIgnoreCase(LT(2)->getText(), "ROWTYPE"))))
        	                                {
        	                                    alt56=1;
        	                                }
        	                                else if ( ((equalsIgnoreCase(LT(2)->getText(), "TYPE"))))
        	                                {
        	                                    alt56=2;
        	                                }
        	                            }
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt56)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:255:30: percent_rowtype_key
        	        	    {
        	        	        this->followPush(FOLLOW_percent_rowtype_key_in_type_spec1765);
        	        	        m_gPLSQLParser->percent_rowtype_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruletype_specEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQLCommons.g:255:50: percent_type_key
        	        	    {
        	        	        this->followPush(FOLLOW_percent_type_key_in_type_spec1767);
        	        	        m_gPLSQLParser->percent_type_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruletype_specEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruletype_specEx; /* Prevent compiler warnings */
    ruletype_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end type_spec */

/**
 * $ANTLR start datatype
 * PLSQLCommons.g:258:1: datatype : ( native_datatype_element ( precision_part )? ( with_key ( local_key )? time_key zone_key )? | interval_key ( year_key | day_key ) ( LEFT_PAREN expression_wrapper RIGHT_PAREN )? to_key ( month_key | second_key ) ( LEFT_PAREN expression_wrapper RIGHT_PAREN )? );
 */
void
PLSQLParser_PLSQLCommons::datatype()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:259:5: ( native_datatype_element ( precision_part )? ( with_key ( local_key )? time_key zone_key )? | interval_key ( year_key | day_key ) ( LEFT_PAREN expression_wrapper RIGHT_PAREN )? to_key ( month_key | second_key ) ( LEFT_PAREN expression_wrapper RIGHT_PAREN )? )

            ANTLR_UINT32 alt65;

            alt65=2;

            {
                int LA65_0 = this->LA(1);
                if ( (LA65_0 == REGULAR_ID))
                {
                    {
                        int LA65_1 = this->LA(2);
                        if ( ((((equalsIgnoreCase(LT(1)->getText(), "DAY")))||((equalsIgnoreCase(LT(1)->getText(), "NUMERIC")))||((equalsIgnoreCase(LT(1)->getText(), "BINARY_INTEGER")))||((equalsIgnoreCase(LT(1)->getText(), "REAL")))||((equalsIgnoreCase(LT(1)->getText(), "STRING")))||((equalsIgnoreCase(LT(1)->getText(), "POSITIVE")))||((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_ABBR")))||((equalsIgnoreCase(LT(1)->getText(), "DEC")))||((equalsIgnoreCase(LT(1)->getText(), "ROWID")))||((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_HOUR")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_TZ_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "SIGNTYPE")))||((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE")))||((equalsIgnoreCase(LT(1)->getText(), "LONG")))||((equalsIgnoreCase(LT(1)->getText(), "RAW")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_LTZ_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "CLOB")))||((equalsIgnoreCase(LT(1)->getText(), "VARCHAR")))||((equalsIgnoreCase(LT(1)->getText(), "CHARACTER")))||((equalsIgnoreCase(LT(1)->getText(), "CHAR")))||((equalsIgnoreCase(LT(1)->getText(), "YEAR")))||((equalsIgnoreCase(LT(1)->getText(), "PLS_INTEGER")))||((equalsIgnoreCase(LT(1)->getText(), "SECOND")))||((equalsIgnoreCase(LT(1)->getText(), "NVARCHAR2")))||((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_MINUTE")))||((equalsIgnoreCase(LT(1)->getText(), "NATURAL")))||((equalsIgnoreCase(LT(1)->getText(), "HOUR")))||((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_REGION")))||((equalsIgnoreCase(LT(1)->getText(), "POSITIVEN")))||((equalsIgnoreCase(LT(1)->getText(), "YMINTERVAL_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "INT")))||((equalsIgnoreCase(LT(1)->getText(), "INTEGER")))||((equalsIgnoreCase(LT(1)->getText(), "VARCHAR2")))||((equalsIgnoreCase(LT(1)->getText(), "MINUTE")))||((equalsIgnoreCase(LT(1)->getText(), "DOUBLE")))||((equalsIgnoreCase(LT(1)->getText(), "FLOAT")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "NCLOB")))||((equalsIgnoreCase(LT(1)->getText(), "NATURALN")))||((equalsIgnoreCase(LT(1)->getText(), "NUMBER")))||((equalsIgnoreCase(LT(1)->getText(), "DECIMAL")))||((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT")))||((equalsIgnoreCase(LT(1)->getText(), "NCHAR")))||((equalsIgnoreCase(LT(1)->getText(), "MONTH")))||((equalsIgnoreCase(LT(1)->getText(), "SMALLINT")))||((equalsIgnoreCase(LT(1)->getText(), "MLSLABEL")))||((equalsIgnoreCase(LT(1)->getText(), "UROWID")))||((equalsIgnoreCase(LT(1)->getText(), "BOOLEAN")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP")))||((equalsIgnoreCase(LT(1)->getText(), "DSINTERVAL_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "SIMPLE_INTEGER")))||((equalsIgnoreCase(LT(1)->getText(), "BFILE")))||((equalsIgnoreCase(LT(1)->getText(), "BLOB"))))))
                        {
                            alt65=1;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "INTERVAL"))))
                        {
                            alt65=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 65 );
                            ex->set_state( 1 );


                            goto ruledatatypeEx;

                        }
                    }
                }
                else if ( (LA65_0 == SQL92_RESERVED_DATE))
                {
                    alt65=1;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 65 );
                    ex->set_state( 0 );


                    goto ruledatatypeEx;

                }
            }
            switch (alt65)
            {
        	case 1:
        	    // PLSQLCommons.g:259:10: native_datatype_element ( precision_part )? ( with_key ( local_key )? time_key zone_key )?
        	    {
        	        this->followPush(FOLLOW_native_datatype_element_in_datatype1789);
        	        native_datatype_element();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledatatypeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:260:9: ( precision_part )?
        	        {
        	            int alt58=2;
        	            {
        	                int LA58_0 = this->LA(1);
        	                if ( (LA58_0 == LEFT_PAREN))
        	                {
        	                    {
        	                        int LA58_1 = this->LA(2);
        	                        if ( (LA58_1 == APPROXIMATE_NUM_LIT || LA58_1 == EXACT_NUM_LIT || LA58_1 == UNSIGNED_INTEGER))
        	                        {
        	                            alt58=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt58)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:260:9: precision_part
        	        	    {
        	        	        this->followPush(FOLLOW_precision_part_in_datatype1799);
        	        	        precision_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLCommons.g:261:9: ( with_key ( local_key )? time_key zone_key )?
        	        {
        	            int alt60=2;
        	            {
        	                int LA60_0 = this->LA(1);
        	                if ( (LA60_0 == SQL92_RESERVED_WITH))
        	                {
        	                    alt60=1;
        	                }
        	            }
        	            switch (alt60)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:261:10: with_key ( local_key )? time_key zone_key
        	        	    {
        	        	        this->followPush(FOLLOW_with_key_in_datatype1811);
        	        	        m_gPLSQLParser->with_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQLCommons.g:261:19: ( local_key )?
        	        	        {
        	        	            int alt59=2;
        	        	            {
        	        	                int LA59_0 = this->LA(1);
        	        	                if ( (LA59_0 == REGULAR_ID))
        	        	                {
        	        	                    {
        	        	                        int LA59_1 = this->LA(2);
        	        	                        if ( (LA59_1 == REGULAR_ID))
        	        	                        {
        	        	                            {
        	        	                                int LA59_2 = this->LA(3);
        	        	                                if ( (LA59_2 == REGULAR_ID))
        	        	                                {
        	        	                                    {
        	        	                                        int LA59_4 = this->LA(4);
        	        	                                        if ( ((equalsIgnoreCase(LT(1)->getText(), "LOCAL"))))
        	        	                                        {
        	        	                                            alt59=1;
        	        	                                        }
        	        	                                    }
        	        	                                }
        	        	                            }
        	        	                        }
        	        	                    }
        	        	                }
        	        	            }
        	        	            switch (alt59)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQLCommons.g:261:19: local_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_local_key_in_datatype1813);
        	        	        	        m_gPLSQLParser->local_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruledatatypeEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        this->followPush(FOLLOW_time_key_in_datatype1816);
        	        	        m_gPLSQLParser->time_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_zone_key_in_datatype1818);
        	        	        m_gPLSQLParser->zone_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:262:10: interval_key ( year_key | day_key ) ( LEFT_PAREN expression_wrapper RIGHT_PAREN )? to_key ( month_key | second_key ) ( LEFT_PAREN expression_wrapper RIGHT_PAREN )?
        	    {
        	        this->followPush(FOLLOW_interval_key_in_datatype1831);
        	        m_gPLSQLParser->interval_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledatatypeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:262:23: ( year_key | day_key )
        	        {
        	            int alt61=2;
        	            {
        	                int LA61_0 = this->LA(1);
        	                if ( (LA61_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "DAY")))||((equalsIgnoreCase(LT(1)->getText(), "YEAR"))))))
        	                {
        	                    {
        	                        int LA61_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "YEAR"))))
        	                        {
        	                            alt61=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "DAY"))))
        	                        {
        	                            alt61=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 61 );
        	                            ex->set_state( 1 );


        	                            goto ruledatatypeEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 61 );
        	                    ex->set_state( 0 );


        	                    goto ruledatatypeEx;

        	                }
        	            }
        	            switch (alt61)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:262:24: year_key
        	        	    {
        	        	        this->followPush(FOLLOW_year_key_in_datatype1834);
        	        	        m_gPLSQLParser->year_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQLCommons.g:262:33: day_key
        	        	    {
        	        	        this->followPush(FOLLOW_day_key_in_datatype1836);
        	        	        m_gPLSQLParser->day_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLCommons.g:263:17: ( LEFT_PAREN expression_wrapper RIGHT_PAREN )?
        	        {
        	            int alt62=2;
        	            {
        	                int LA62_0 = this->LA(1);
        	                if ( (LA62_0 == LEFT_PAREN))
        	                {
        	                    alt62=1;
        	                }
        	            }
        	            switch (alt62)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:263:18: LEFT_PAREN expression_wrapper RIGHT_PAREN
        	        	    {
        	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_datatype1856);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_expression_wrapper_in_datatype1858);
        	        	        m_gPLSQLParser->expression_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_datatype1860);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_to_key_in_datatype1877);
        	        m_gPLSQLParser->to_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledatatypeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:264:20: ( month_key | second_key )
        	        {
        	            int alt63=2;
        	            {
        	                int LA63_0 = this->LA(1);
        	                if ( (LA63_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA63_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "MONTH"))))
        	                        {
        	                            alt63=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "SECOND"))))
        	                        {
        	                            alt63=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 63 );
        	                            ex->set_state( 1 );


        	                            goto ruledatatypeEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 63 );
        	                    ex->set_state( 0 );


        	                    goto ruledatatypeEx;

        	                }
        	            }
        	            switch (alt63)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:264:21: month_key
        	        	    {
        	        	        this->followPush(FOLLOW_month_key_in_datatype1880);
        	        	        m_gPLSQLParser->month_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQLCommons.g:264:31: second_key
        	        	    {
        	        	        this->followPush(FOLLOW_second_key_in_datatype1882);
        	        	        m_gPLSQLParser->second_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLCommons.g:265:17: ( LEFT_PAREN expression_wrapper RIGHT_PAREN )?
        	        {
        	            int alt64=2;
        	            {
        	                int LA64_0 = this->LA(1);
        	                if ( (LA64_0 == LEFT_PAREN))
        	                {
        	                    alt64=1;
        	                }
        	            }
        	            switch (alt64)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:265:18: LEFT_PAREN expression_wrapper RIGHT_PAREN
        	        	    {
        	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_datatype1903);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_expression_wrapper_in_datatype1905);
        	        	        m_gPLSQLParser->expression_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_datatype1907);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruledatatypeEx; /* Prevent compiler warnings */
    ruledatatypeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end datatype */

/**
 * $ANTLR start precision_part
 * PLSQLCommons.g:268:1: precision_part : LEFT_PAREN numeric ( COMMA numeric )? ( char_key | byte_key )? RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQLCommons::precision_part()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:269:5: ( LEFT_PAREN numeric ( COMMA numeric )? ( char_key | byte_key )? RIGHT_PAREN )
        // PLSQLCommons.g:269:10: LEFT_PAREN numeric ( COMMA numeric )? ( char_key | byte_key )? RIGHT_PAREN
        {
             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_precision_part1929);
            if  (this->hasException())
            {
                goto ruleprecision_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_numeric_in_precision_part1931);
            numeric();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprecision_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:269:29: ( COMMA numeric )?
            {
                int alt66=2;
                {
                    int LA66_0 = this->LA(1);
                    if ( (LA66_0 == COMMA))
                    {
                        alt66=1;
                    }
                }
                switch (alt66)
                {
            	case 1:
            	    // PLSQLCommons.g:269:30: COMMA numeric
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_precision_part1934);
            	        if  (this->hasException())
            	        {
            	            goto ruleprecision_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_numeric_in_precision_part1936);
            	        numeric();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprecision_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLCommons.g:269:46: ( char_key | byte_key )?
            {
                int alt67=3;
                {
                    int LA67_0 = this->LA(1);
                    if ( (LA67_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "BYTE")))||((equalsIgnoreCase(LT(1)->getText(), "CHAR"))))))
                    {
                        {
                            int LA67_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "CHAR"))))
                            {
                                alt67=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "BYTE"))))
                            {
                                alt67=2;
                            }
                        }
                    }
                }
                switch (alt67)
                {
            	case 1:
            	    // PLSQLCommons.g:269:47: char_key
            	    {
            	        this->followPush(FOLLOW_char_key_in_precision_part1941);
            	        m_gPLSQLParser->char_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprecision_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:269:58: byte_key
            	    {
            	        this->followPush(FOLLOW_byte_key_in_precision_part1945);
            	        m_gPLSQLParser->byte_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprecision_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_precision_part1949);
            if  (this->hasException())
            {
                goto ruleprecision_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprecision_partEx; /* Prevent compiler warnings */
    ruleprecision_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end precision_part */

/**
 * $ANTLR start native_datatype_element
 * PLSQLCommons.g:272:1: native_datatype_element : ( binary_integer_key | pls_integer_key | natural_key | binary_float_key | binary_double_key | naturaln_key | positive_key | positiven_key | signtype_key | simple_integer_key | nvarchar2_key | dec_key | integer_key | int_key | numeric_key | smallint_key | number_key | decimal_key | double_key ( precision_key )? | float_key | real_key | nchar_key | long_key ( raw_key )? | char_key | character_key | varchar2_key | varchar_key | string_key | raw_key | boolean_key | date_key | rowid_key | urowid_key | year_key | month_key | day_key | hour_key | minute_key | second_key | timezone_hour_key | timezone_minute_key | timezone_region_key | timezone_abbr_key | timestamp_key | timestamp_unconstrained_key | timestamp_tz_unconstrained_key | timestamp_ltz_unconstrained_key | yminterval_unconstrained_key | dsinterval_unconstrained_key | bfile_key | blob_key | clob_key | nclob_key | mlslabel_key );
 */
void
PLSQLParser_PLSQLCommons::native_datatype_element()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:273:5: ( binary_integer_key | pls_integer_key | natural_key | binary_float_key | binary_double_key | naturaln_key | positive_key | positiven_key | signtype_key | simple_integer_key | nvarchar2_key | dec_key | integer_key | int_key | numeric_key | smallint_key | number_key | decimal_key | double_key ( precision_key )? | float_key | real_key | nchar_key | long_key ( raw_key )? | char_key | character_key | varchar2_key | varchar_key | string_key | raw_key | boolean_key | date_key | rowid_key | urowid_key | year_key | month_key | day_key | hour_key | minute_key | second_key | timezone_hour_key | timezone_minute_key | timezone_region_key | timezone_abbr_key | timestamp_key | timestamp_unconstrained_key | timestamp_tz_unconstrained_key | timestamp_ltz_unconstrained_key | yminterval_unconstrained_key | dsinterval_unconstrained_key | bfile_key | blob_key | clob_key | nclob_key | mlslabel_key )

            ANTLR_UINT32 alt70;

            alt70=54;

            {
                int LA70_0 = this->LA(1);
                if ( (LA70_0 == REGULAR_ID))
                {
                    {
                        int LA70_1 = this->LA(2);
                        if ( ((equalsIgnoreCase(LT(1)->getText(), "BINARY_INTEGER"))))
                        {
                            alt70=1;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "PLS_INTEGER"))))
                        {
                            alt70=2;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NATURAL"))))
                        {
                            alt70=3;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT"))))
                        {
                            alt70=4;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE"))))
                        {
                            alt70=5;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NATURALN"))))
                        {
                            alt70=6;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "POSITIVE"))))
                        {
                            alt70=7;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "POSITIVEN"))))
                        {
                            alt70=8;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "SIGNTYPE"))))
                        {
                            alt70=9;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "SIMPLE_INTEGER"))))
                        {
                            alt70=10;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NVARCHAR2"))))
                        {
                            alt70=11;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "DEC"))))
                        {
                            alt70=12;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "INTEGER"))))
                        {
                            alt70=13;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "INT"))))
                        {
                            alt70=14;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NUMERIC"))))
                        {
                            alt70=15;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "SMALLINT"))))
                        {
                            alt70=16;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NUMBER"))))
                        {
                            alt70=17;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "DECIMAL"))))
                        {
                            alt70=18;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "DOUBLE"))))
                        {
                            alt70=19;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "FLOAT"))))
                        {
                            alt70=20;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "REAL"))))
                        {
                            alt70=21;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NCHAR"))))
                        {
                            alt70=22;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "LONG"))))
                        {
                            alt70=23;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "CHAR"))))
                        {
                            alt70=24;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "CHARACTER"))))
                        {
                            alt70=25;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "VARCHAR2"))))
                        {
                            alt70=26;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "VARCHAR"))))
                        {
                            alt70=27;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "STRING"))))
                        {
                            alt70=28;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "RAW"))))
                        {
                            alt70=29;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "BOOLEAN"))))
                        {
                            alt70=30;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "ROWID"))))
                        {
                            alt70=32;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "UROWID"))))
                        {
                            alt70=33;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "YEAR"))))
                        {
                            alt70=34;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "MONTH"))))
                        {
                            alt70=35;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "DAY"))))
                        {
                            alt70=36;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "HOUR"))))
                        {
                            alt70=37;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "MINUTE"))))
                        {
                            alt70=38;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "SECOND"))))
                        {
                            alt70=39;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_HOUR"))))
                        {
                            alt70=40;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_MINUTE"))))
                        {
                            alt70=41;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_REGION"))))
                        {
                            alt70=42;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_ABBR"))))
                        {
                            alt70=43;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP"))))
                        {
                            alt70=44;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_UNCONSTRAINED"))))
                        {
                            alt70=45;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_TZ_UNCONSTRAINED"))))
                        {
                            alt70=46;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_LTZ_UNCONSTRAINED"))))
                        {
                            alt70=47;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "YMINTERVAL_UNCONSTRAINED"))))
                        {
                            alt70=48;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "DSINTERVAL_UNCONSTRAINED"))))
                        {
                            alt70=49;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "BFILE"))))
                        {
                            alt70=50;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "BLOB"))))
                        {
                            alt70=51;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "CLOB"))))
                        {
                            alt70=52;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NCLOB"))))
                        {
                            alt70=53;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "MLSLABEL"))))
                        {
                            alt70=54;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 70 );
                            ex->set_state( 1 );


                            goto rulenative_datatype_elementEx;

                        }
                    }
                }
                else if ( (LA70_0 == SQL92_RESERVED_DATE))
                {
                    alt70=31;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 70 );
                    ex->set_state( 0 );


                    goto rulenative_datatype_elementEx;

                }
            }
            switch (alt70)
            {
        	case 1:
        	    // PLSQLCommons.g:273:10: binary_integer_key
        	    {
        	        this->followPush(FOLLOW_binary_integer_key_in_native_datatype_element1969);
        	        m_gPLSQLParser->binary_integer_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:274:10: pls_integer_key
        	    {
        	        this->followPush(FOLLOW_pls_integer_key_in_native_datatype_element1980);
        	        m_gPLSQLParser->pls_integer_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLCommons.g:275:10: natural_key
        	    {
        	        this->followPush(FOLLOW_natural_key_in_native_datatype_element1991);
        	        m_gPLSQLParser->natural_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQLCommons.g:276:10: binary_float_key
        	    {
        	        this->followPush(FOLLOW_binary_float_key_in_native_datatype_element2002);
        	        m_gPLSQLParser->binary_float_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQLCommons.g:277:10: binary_double_key
        	    {
        	        this->followPush(FOLLOW_binary_double_key_in_native_datatype_element2013);
        	        m_gPLSQLParser->binary_double_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // PLSQLCommons.g:278:10: naturaln_key
        	    {
        	        this->followPush(FOLLOW_naturaln_key_in_native_datatype_element2024);
        	        m_gPLSQLParser->naturaln_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 7:
        	    // PLSQLCommons.g:279:10: positive_key
        	    {
        	        this->followPush(FOLLOW_positive_key_in_native_datatype_element2035);
        	        m_gPLSQLParser->positive_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 8:
        	    // PLSQLCommons.g:280:10: positiven_key
        	    {
        	        this->followPush(FOLLOW_positiven_key_in_native_datatype_element2046);
        	        m_gPLSQLParser->positiven_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 9:
        	    // PLSQLCommons.g:281:10: signtype_key
        	    {
        	        this->followPush(FOLLOW_signtype_key_in_native_datatype_element2057);
        	        m_gPLSQLParser->signtype_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 10:
        	    // PLSQLCommons.g:282:10: simple_integer_key
        	    {
        	        this->followPush(FOLLOW_simple_integer_key_in_native_datatype_element2068);
        	        m_gPLSQLParser->simple_integer_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 11:
        	    // PLSQLCommons.g:283:10: nvarchar2_key
        	    {
        	        this->followPush(FOLLOW_nvarchar2_key_in_native_datatype_element2079);
        	        m_gPLSQLParser->nvarchar2_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 12:
        	    // PLSQLCommons.g:284:10: dec_key
        	    {
        	        this->followPush(FOLLOW_dec_key_in_native_datatype_element2090);
        	        m_gPLSQLParser->dec_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 13:
        	    // PLSQLCommons.g:285:10: integer_key
        	    {
        	        this->followPush(FOLLOW_integer_key_in_native_datatype_element2101);
        	        m_gPLSQLParser->integer_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 14:
        	    // PLSQLCommons.g:286:10: int_key
        	    {
        	        this->followPush(FOLLOW_int_key_in_native_datatype_element2112);
        	        m_gPLSQLParser->int_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 15:
        	    // PLSQLCommons.g:287:10: numeric_key
        	    {
        	        this->followPush(FOLLOW_numeric_key_in_native_datatype_element2123);
        	        m_gPLSQLParser->numeric_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 16:
        	    // PLSQLCommons.g:288:10: smallint_key
        	    {
        	        this->followPush(FOLLOW_smallint_key_in_native_datatype_element2134);
        	        m_gPLSQLParser->smallint_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 17:
        	    // PLSQLCommons.g:289:10: number_key
        	    {
        	        this->followPush(FOLLOW_number_key_in_native_datatype_element2145);
        	        m_gPLSQLParser->number_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 18:
        	    // PLSQLCommons.g:290:10: decimal_key
        	    {
        	        this->followPush(FOLLOW_decimal_key_in_native_datatype_element2156);
        	        m_gPLSQLParser->decimal_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 19:
        	    // PLSQLCommons.g:291:10: double_key ( precision_key )?
        	    {
        	        this->followPush(FOLLOW_double_key_in_native_datatype_element2168);
        	        m_gPLSQLParser->double_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:291:21: ( precision_key )?
        	        {
        	            int alt68=2;
        	            {
        	                int LA68_0 = this->LA(1);
        	                if ( (LA68_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA68_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "PRECISION"))))
        	                        {
        	                            alt68=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt68)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:291:21: precision_key
        	        	    {
        	        	        this->followPush(FOLLOW_precision_key_in_native_datatype_element2170);
        	        	        m_gPLSQLParser->precision_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulenative_datatype_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 20:
        	    // PLSQLCommons.g:292:10: float_key
        	    {
        	        this->followPush(FOLLOW_float_key_in_native_datatype_element2182);
        	        m_gPLSQLParser->float_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 21:
        	    // PLSQLCommons.g:293:10: real_key
        	    {
        	        this->followPush(FOLLOW_real_key_in_native_datatype_element2193);
        	        m_gPLSQLParser->real_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 22:
        	    // PLSQLCommons.g:294:10: nchar_key
        	    {
        	        this->followPush(FOLLOW_nchar_key_in_native_datatype_element2204);
        	        m_gPLSQLParser->nchar_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 23:
        	    // PLSQLCommons.g:295:10: long_key ( raw_key )?
        	    {
        	        this->followPush(FOLLOW_long_key_in_native_datatype_element2215);
        	        m_gPLSQLParser->long_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:295:19: ( raw_key )?
        	        {
        	            int alt69=2;
        	            {
        	                int LA69_0 = this->LA(1);
        	                if ( (LA69_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA69_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "RAW"))))
        	                        {
        	                            alt69=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt69)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:295:19: raw_key
        	        	    {
        	        	        this->followPush(FOLLOW_raw_key_in_native_datatype_element2217);
        	        	        m_gPLSQLParser->raw_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulenative_datatype_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 24:
        	    // PLSQLCommons.g:296:10: char_key
        	    {
        	        this->followPush(FOLLOW_char_key_in_native_datatype_element2229);
        	        m_gPLSQLParser->char_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 25:
        	    // PLSQLCommons.g:297:10: character_key
        	    {
        	        this->followPush(FOLLOW_character_key_in_native_datatype_element2242);
        	        m_gPLSQLParser->character_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 26:
        	    // PLSQLCommons.g:298:10: varchar2_key
        	    {
        	        this->followPush(FOLLOW_varchar2_key_in_native_datatype_element2254);
        	        m_gPLSQLParser->varchar2_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 27:
        	    // PLSQLCommons.g:299:10: varchar_key
        	    {
        	        this->followPush(FOLLOW_varchar_key_in_native_datatype_element2265);
        	        m_gPLSQLParser->varchar_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 28:
        	    // PLSQLCommons.g:300:10: string_key
        	    {
        	        this->followPush(FOLLOW_string_key_in_native_datatype_element2276);
        	        m_gPLSQLParser->string_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 29:
        	    // PLSQLCommons.g:301:10: raw_key
        	    {
        	        this->followPush(FOLLOW_raw_key_in_native_datatype_element2287);
        	        m_gPLSQLParser->raw_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 30:
        	    // PLSQLCommons.g:302:10: boolean_key
        	    {
        	        this->followPush(FOLLOW_boolean_key_in_native_datatype_element2298);
        	        m_gPLSQLParser->boolean_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 31:
        	    // PLSQLCommons.g:303:10: date_key
        	    {
        	        this->followPush(FOLLOW_date_key_in_native_datatype_element2309);
        	        m_gPLSQLParser->date_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 32:
        	    // PLSQLCommons.g:304:10: rowid_key
        	    {
        	        this->followPush(FOLLOW_rowid_key_in_native_datatype_element2320);
        	        m_gPLSQLParser->rowid_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 33:
        	    // PLSQLCommons.g:305:10: urowid_key
        	    {
        	        this->followPush(FOLLOW_urowid_key_in_native_datatype_element2331);
        	        m_gPLSQLParser->urowid_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 34:
        	    // PLSQLCommons.g:306:10: year_key
        	    {
        	        this->followPush(FOLLOW_year_key_in_native_datatype_element2342);
        	        m_gPLSQLParser->year_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 35:
        	    // PLSQLCommons.g:307:10: month_key
        	    {
        	        this->followPush(FOLLOW_month_key_in_native_datatype_element2353);
        	        m_gPLSQLParser->month_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 36:
        	    // PLSQLCommons.g:308:10: day_key
        	    {
        	        this->followPush(FOLLOW_day_key_in_native_datatype_element2364);
        	        m_gPLSQLParser->day_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 37:
        	    // PLSQLCommons.g:309:10: hour_key
        	    {
        	        this->followPush(FOLLOW_hour_key_in_native_datatype_element2375);
        	        m_gPLSQLParser->hour_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 38:
        	    // PLSQLCommons.g:310:10: minute_key
        	    {
        	        this->followPush(FOLLOW_minute_key_in_native_datatype_element2386);
        	        m_gPLSQLParser->minute_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 39:
        	    // PLSQLCommons.g:311:10: second_key
        	    {
        	        this->followPush(FOLLOW_second_key_in_native_datatype_element2397);
        	        m_gPLSQLParser->second_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 40:
        	    // PLSQLCommons.g:312:10: timezone_hour_key
        	    {
        	        this->followPush(FOLLOW_timezone_hour_key_in_native_datatype_element2408);
        	        m_gPLSQLParser->timezone_hour_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 41:
        	    // PLSQLCommons.g:313:10: timezone_minute_key
        	    {
        	        this->followPush(FOLLOW_timezone_minute_key_in_native_datatype_element2419);
        	        m_gPLSQLParser->timezone_minute_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 42:
        	    // PLSQLCommons.g:314:10: timezone_region_key
        	    {
        	        this->followPush(FOLLOW_timezone_region_key_in_native_datatype_element2430);
        	        m_gPLSQLParser->timezone_region_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 43:
        	    // PLSQLCommons.g:315:10: timezone_abbr_key
        	    {
        	        this->followPush(FOLLOW_timezone_abbr_key_in_native_datatype_element2441);
        	        m_gPLSQLParser->timezone_abbr_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 44:
        	    // PLSQLCommons.g:316:10: timestamp_key
        	    {
        	        this->followPush(FOLLOW_timestamp_key_in_native_datatype_element2452);
        	        m_gPLSQLParser->timestamp_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 45:
        	    // PLSQLCommons.g:317:10: timestamp_unconstrained_key
        	    {
        	        this->followPush(FOLLOW_timestamp_unconstrained_key_in_native_datatype_element2463);
        	        m_gPLSQLParser->timestamp_unconstrained_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 46:
        	    // PLSQLCommons.g:318:10: timestamp_tz_unconstrained_key
        	    {
        	        this->followPush(FOLLOW_timestamp_tz_unconstrained_key_in_native_datatype_element2474);
        	        m_gPLSQLParser->timestamp_tz_unconstrained_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 47:
        	    // PLSQLCommons.g:319:10: timestamp_ltz_unconstrained_key
        	    {
        	        this->followPush(FOLLOW_timestamp_ltz_unconstrained_key_in_native_datatype_element2485);
        	        m_gPLSQLParser->timestamp_ltz_unconstrained_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 48:
        	    // PLSQLCommons.g:320:10: yminterval_unconstrained_key
        	    {
        	        this->followPush(FOLLOW_yminterval_unconstrained_key_in_native_datatype_element2496);
        	        m_gPLSQLParser->yminterval_unconstrained_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 49:
        	    // PLSQLCommons.g:321:10: dsinterval_unconstrained_key
        	    {
        	        this->followPush(FOLLOW_dsinterval_unconstrained_key_in_native_datatype_element2507);
        	        m_gPLSQLParser->dsinterval_unconstrained_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 50:
        	    // PLSQLCommons.g:322:10: bfile_key
        	    {
        	        this->followPush(FOLLOW_bfile_key_in_native_datatype_element2518);
        	        m_gPLSQLParser->bfile_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 51:
        	    // PLSQLCommons.g:323:10: blob_key
        	    {
        	        this->followPush(FOLLOW_blob_key_in_native_datatype_element2529);
        	        m_gPLSQLParser->blob_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 52:
        	    // PLSQLCommons.g:324:10: clob_key
        	    {
        	        this->followPush(FOLLOW_clob_key_in_native_datatype_element2540);
        	        m_gPLSQLParser->clob_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 53:
        	    // PLSQLCommons.g:325:10: nclob_key
        	    {
        	        this->followPush(FOLLOW_nclob_key_in_native_datatype_element2551);
        	        m_gPLSQLParser->nclob_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 54:
        	    // PLSQLCommons.g:326:10: mlslabel_key
        	    {
        	        this->followPush(FOLLOW_mlslabel_key_in_native_datatype_element2562);
        	        m_gPLSQLParser->mlslabel_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulenative_datatype_elementEx; /* Prevent compiler warnings */
    rulenative_datatype_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end native_datatype_element */

/**
 * $ANTLR start bind_variable
 * PLSQLCommons.g:329:1: bind_variable : ( BINDVAR | COLON UNSIGNED_INTEGER ) ( ( indicator_key )? ( BINDVAR | COLON UNSIGNED_INTEGER ) )? ( ( PERIOD general_element_part )=> PERIOD general_element_part )* ;
 */
void
PLSQLParser_PLSQLCommons::bind_variable()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:330:5: ( ( BINDVAR | COLON UNSIGNED_INTEGER ) ( ( indicator_key )? ( BINDVAR | COLON UNSIGNED_INTEGER ) )? ( ( PERIOD general_element_part )=> PERIOD general_element_part )* )
        // PLSQLCommons.g:330:10: ( BINDVAR | COLON UNSIGNED_INTEGER ) ( ( indicator_key )? ( BINDVAR | COLON UNSIGNED_INTEGER ) )? ( ( PERIOD general_element_part )=> PERIOD general_element_part )*
        {
            // PLSQLCommons.g:330:10: ( BINDVAR | COLON UNSIGNED_INTEGER )
            {
                int alt71=2;
                {
                    int LA71_0 = this->LA(1);
                    if ( (LA71_0 == BINDVAR))
                    {
                        alt71=1;
                    }
                    else if ( (LA71_0 == COLON))
                    {
                        alt71=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 71 );
                        ex->set_state( 0 );


                        goto rulebind_variableEx;

                    }
                }
                switch (alt71)
                {
            	case 1:
            	    // PLSQLCommons.g:330:12: BINDVAR
            	    {
            	         this->matchToken(BINDVAR, &FOLLOW_BINDVAR_in_bind_variable2584);
            	        if  (this->hasException())
            	        {
            	            goto rulebind_variableEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:330:22: COLON UNSIGNED_INTEGER
            	    {
            	         this->matchToken(COLON, &FOLLOW_COLON_in_bind_variable2588);
            	        if  (this->hasException())
            	        {
            	            goto rulebind_variableEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_bind_variable2590);
            	        if  (this->hasException())
            	        {
            	            goto rulebind_variableEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLCommons.g:331:10: ( ( indicator_key )? ( BINDVAR | COLON UNSIGNED_INTEGER ) )?
            {
                int alt74=2;
                {
                    int LA74_0 = this->LA(1);
                    if ( (LA74_0 == REGULAR_ID))
                    {
                        {
                            int LA74_1 = this->LA(2);
                            if ( (LA74_1 == BINDVAR))
                            {
                                {
                                    int LA74_4 = this->LA(3);
                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "INDICATOR"))))
                                    {
                                        alt74=1;
                                    }
                                }
                            }
                            else if ( (LA74_1 == COLON))
                            {
                                {
                                    int LA74_5 = this->LA(3);
                                    if ( (LA74_5 == UNSIGNED_INTEGER))
                                    {
                                        {
                                            int LA74_12 = this->LA(4);
                                            if ( ((equalsIgnoreCase(LT(1)->getText(), "INDICATOR"))))
                                            {
                                                alt74=1;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else if ( (LA74_0 == BINDVAR || LA74_0 == COLON))
                    {
                        alt74=1;
                    }
                }
                switch (alt74)
                {
            	case 1:
            	    // PLSQLCommons.g:331:12: ( indicator_key )? ( BINDVAR | COLON UNSIGNED_INTEGER )
            	    {
            	        // PLSQLCommons.g:331:12: ( indicator_key )?
            	        {
            	            int alt72=2;
            	            {
            	                int LA72_0 = this->LA(1);
            	                if ( (LA72_0 == REGULAR_ID))
            	                {
            	                    alt72=1;
            	                }
            	            }
            	            switch (alt72)
            	            {
            	        	case 1:
            	        	    // PLSQLCommons.g:331:12: indicator_key
            	        	    {
            	        	        this->followPush(FOLLOW_indicator_key_in_bind_variable2604);
            	        	        m_gPLSQLParser->indicator_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulebind_variableEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQLCommons.g:331:27: ( BINDVAR | COLON UNSIGNED_INTEGER )
            	        {
            	            int alt73=2;
            	            {
            	                int LA73_0 = this->LA(1);
            	                if ( (LA73_0 == BINDVAR))
            	                {
            	                    alt73=1;
            	                }
            	                else if ( (LA73_0 == COLON))
            	                {
            	                    alt73=2;
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 73 );
            	                    ex->set_state( 0 );


            	                    goto rulebind_variableEx;

            	                }
            	            }
            	            switch (alt73)
            	            {
            	        	case 1:
            	        	    // PLSQLCommons.g:331:28: BINDVAR
            	        	    {
            	        	         this->matchToken(BINDVAR, &FOLLOW_BINDVAR_in_bind_variable2608);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulebind_variableEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQLCommons.g:331:38: COLON UNSIGNED_INTEGER
            	        	    {
            	        	         this->matchToken(COLON, &FOLLOW_COLON_in_bind_variable2612);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulebind_variableEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	         this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_bind_variable2614);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulebind_variableEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // PLSQLCommons.g:332:10: ( ( PERIOD general_element_part )=> PERIOD general_element_part )*

            for (;;)
            {
                int alt75=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA75_0 = this->LA(1);
                    if ( (LA75_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred19_PLSQLCommons>() )))
                    {
                        alt75=1;
                    }

                }
                switch (alt75)
                {
            	case 1:
            	    // PLSQLCommons.g:332:11: ( PERIOD general_element_part )=> PERIOD general_element_part
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_bind_variable2636);
            	        if  (this->hasException())
            	        {
            	            goto rulebind_variableEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_general_element_part_in_bind_variable2638);
            	        general_element_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulebind_variableEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop75;	/* break out of the loop */
            	    break;
                }
            }
            loop75: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebind_variableEx; /* Prevent compiler warnings */
    rulebind_variableEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end bind_variable */

/**
 * $ANTLR start general_element
 * PLSQLCommons.g:335:1: general_element : general_element_part ( ( PERIOD general_element_part )=> PERIOD general_element_part )* ;
 */
void
PLSQLParser_PLSQLCommons::general_element()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:336:5: ( general_element_part ( ( PERIOD general_element_part )=> PERIOD general_element_part )* )
        // PLSQLCommons.g:336:10: general_element_part ( ( PERIOD general_element_part )=> PERIOD general_element_part )*
        {
            this->followPush(FOLLOW_general_element_part_in_general_element2660);
            general_element_part();

            this->followPop();
            if  (this->hasException())
            {
                goto rulegeneral_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:336:31: ( ( PERIOD general_element_part )=> PERIOD general_element_part )*

            for (;;)
            {
                int alt76=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA76_0 = this->LA(1);
                    if ( (LA76_0 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred20_PLSQLCommons>() )))
                    {
                        alt76=1;
                    }

                }
                switch (alt76)
                {
            	case 1:
            	    // PLSQLCommons.g:336:32: ( PERIOD general_element_part )=> PERIOD general_element_part
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_general_element2670);
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_general_element_part_in_general_element2672);
            	        general_element_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop76;	/* break out of the loop */
            	    break;
                }
            }
            loop76: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulegeneral_elementEx; /* Prevent compiler warnings */
    rulegeneral_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end general_element */

/**
 * $ANTLR start general_element_part
 * PLSQLCommons.g:339:1: general_element_part : ( INTRODUCER char_set_name )? id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )* ( function_argument )? ;
 */
void
PLSQLParser_PLSQLCommons::general_element_part()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:340:5: ( ( INTRODUCER char_set_name )? id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )* ( function_argument )? )
        // PLSQLCommons.g:340:10: ( INTRODUCER char_set_name )? id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )* ( function_argument )?
        {
            // PLSQLCommons.g:340:10: ( INTRODUCER char_set_name )?
            {
                int alt77=2;
                {
                    int LA77_0 = this->LA(1);
                    if ( (LA77_0 == INTRODUCER))
                    {
                        alt77=1;
                    }
                }
                switch (alt77)
                {
            	case 1:
            	    // PLSQLCommons.g:340:11: INTRODUCER char_set_name
            	    {
            	         this->matchToken(INTRODUCER, &FOLLOW_INTRODUCER_in_general_element_part2695);
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_element_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_char_set_name_in_general_element_part2697);
            	        char_set_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_element_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_id_expression_in_general_element_part2701);
            id_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulegeneral_element_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:341:13: ( ( PERIOD id_expression )=> PERIOD id_expression )*

            for (;;)
            {
                int alt78=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA78_0 = this->LA(1);
                    if ( (LA78_0 == PERIOD))
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA78_2 = this->LA(2);
                            if ( (LA78_2 == DELIMITED_ID || LA78_2 == REGULAR_ID))
                            {
                                {
                                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                                    */
                                    int LA78_3 = this->LA(3);
                                    if ( (this->msynpred( antlr3::ClassForwarder<synpred21_PLSQLCommons>() )))
                                    {
                                        alt78=1;
                                    }

                                }
                            }

                        }
                    }

                }
                switch (alt78)
                {
            	case 1:
            	    // PLSQLCommons.g:341:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_general_element_part2723);
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_element_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_general_element_part2725);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_element_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop78;	/* break out of the loop */
            	    break;
                }
            }
            loop78: ; /* Jump out to here if this rule does not match */


            // PLSQLCommons.g:341:62: ( function_argument )?
            {
                int alt79=2;
                alt79 = cdfa79.predict(this, this->get_rec(), this->get_istream(), cdfa79 );
                if  (this->hasException())
                {
                    goto rulegeneral_element_partEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }

                switch (alt79)
                {
            	case 1:
            	    // PLSQLCommons.g:341:62: function_argument
            	    {
            	        this->followPush(FOLLOW_function_argument_in_general_element_part2729);
            	        function_argument();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_element_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulegeneral_element_partEx; /* Prevent compiler warnings */
    rulegeneral_element_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end general_element_part */

/**
 * $ANTLR start table_element
 * PLSQLCommons.g:344:1: table_element : ( INTRODUCER char_set_name )? id_expression ( PERIOD id_expression )* ;
 */
void
PLSQLParser_PLSQLCommons::table_element()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:345:5: ( ( INTRODUCER char_set_name )? id_expression ( PERIOD id_expression )* )
        // PLSQLCommons.g:345:10: ( INTRODUCER char_set_name )? id_expression ( PERIOD id_expression )*
        {
            // PLSQLCommons.g:345:10: ( INTRODUCER char_set_name )?
            {
                int alt80=2;
                {
                    int LA80_0 = this->LA(1);
                    if ( (LA80_0 == INTRODUCER))
                    {
                        alt80=1;
                    }
                }
                switch (alt80)
                {
            	case 1:
            	    // PLSQLCommons.g:345:11: INTRODUCER char_set_name
            	    {
            	         this->matchToken(INTRODUCER, &FOLLOW_INTRODUCER_in_table_element2751);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_char_set_name_in_table_element2753);
            	        char_set_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_id_expression_in_table_element2757);
            id_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:345:52: ( PERIOD id_expression )*

            for (;;)
            {
                int alt81=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA81_0 = this->LA(1);
                    if ( (LA81_0 == PERIOD))
                    {
                        alt81=1;
                    }

                }
                switch (alt81)
                {
            	case 1:
            	    // PLSQLCommons.g:345:53: PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_table_element2760);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_table_element2762);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop81;	/* break out of the loop */
            	    break;
                }
            }
            loop81: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_elementEx; /* Prevent compiler warnings */
    ruletable_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_element */

/**
 * $ANTLR start constant
 * PLSQLCommons.g:352:1: constant : ( timestamp_key ( quoted_string | bind_variable ) ( at_key time_key zone_key quoted_string )? | interval_key ( quoted_string | bind_variable | general_element_part ) ( day_key | hour_key | minute_key | second_key ) ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) ( COMMA ( UNSIGNED_INTEGER | bind_variable ) )? RIGHT_PAREN )? ( to_key ( day_key | hour_key | minute_key | second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )? ) )? | numeric | date_key quoted_string | quoted_string | null_key | true_key | false_key | dbtimezone_key | sessiontimezone_key | minvalue_key | maxvalue_key | default_key );
 */
void
PLSQLParser_PLSQLCommons::constant()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:353:5: ( timestamp_key ( quoted_string | bind_variable ) ( at_key time_key zone_key quoted_string )? | interval_key ( quoted_string | bind_variable | general_element_part ) ( day_key | hour_key | minute_key | second_key ) ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) ( COMMA ( UNSIGNED_INTEGER | bind_variable ) )? RIGHT_PAREN )? ( to_key ( day_key | hour_key | minute_key | second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )? ) )? | numeric | date_key quoted_string | quoted_string | null_key | true_key | false_key | dbtimezone_key | sessiontimezone_key | minvalue_key | maxvalue_key | default_key )

            ANTLR_UINT32 alt94;

            alt94=13;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    int LA94_1 = this->LA(2);
            		    if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP"))))
            		    {
            		        alt94=1;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "INTERVAL"))))
            		    {
            		        alt94=2;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "DBTIMEZONE"))))
            		    {
            		        alt94=9;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SESSIONTIMEZONE"))))
            		    {
            		        alt94=10;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "MINVALUE"))))
            		    {
            		        alt94=11;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "MAXVALUE"))))
            		    {
            		        alt94=12;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 94 );
            		        ex->set_state( 1 );


            		        goto ruleconstantEx;

            		    }
            		}
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case EXACT_NUM_LIT:
            case UNSIGNED_INTEGER:
            	{
            		alt94=3;
            	}
                break;
            case SQL92_RESERVED_DATE:
            	{
            		alt94=4;
            	}
                break;
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case NATIONAL_CHAR_STRING_LIT:
            	{
            		alt94=5;
            	}
                break;
            case SQL92_RESERVED_NULL:
            	{
            		alt94=6;
            	}
                break;
            case SQL92_RESERVED_TRUE:
            	{
            		alt94=7;
            	}
                break;
            case SQL92_RESERVED_FALSE:
            	{
            		alt94=8;
            	}
                break;
            case SQL92_RESERVED_DEFAULT:
            	{
            		alt94=13;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 94 );
                ex->set_state( 0 );


                goto ruleconstantEx;

            }

            switch (alt94)
            {
        	case 1:
        	    // PLSQLCommons.g:353:10: timestamp_key ( quoted_string | bind_variable ) ( at_key time_key zone_key quoted_string )?
        	    {
        	        this->followPush(FOLLOW_timestamp_key_in_constant2788);
        	        m_gPLSQLParser->timestamp_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:353:24: ( quoted_string | bind_variable )
        	        {
        	            int alt82=2;
        	            {
        	                int LA82_0 = this->LA(1);
        	                if ( (((LA82_0 >= CHAR_STRING) && (LA82_0 <= CHAR_STRING_PERL)) || LA82_0 == NATIONAL_CHAR_STRING_LIT))
        	                {
        	                    alt82=1;
        	                }
        	                else if ( (LA82_0 == BINDVAR || LA82_0 == COLON))
        	                {
        	                    alt82=2;
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 82 );
        	                    ex->set_state( 0 );


        	                    goto ruleconstantEx;

        	                }
        	            }
        	            switch (alt82)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:353:25: quoted_string
        	        	    {
        	        	        this->followPush(FOLLOW_quoted_string_in_constant2791);
        	        	        quoted_string();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQLCommons.g:353:41: bind_variable
        	        	    {
        	        	        this->followPush(FOLLOW_bind_variable_in_constant2795);
        	        	        bind_variable();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLCommons.g:353:56: ( at_key time_key zone_key quoted_string )?
        	        {
        	            int alt83=2;
        	            {
        	                int LA83_0 = this->LA(1);
        	                if ( (LA83_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA83_1 = this->LA(2);
        	                        if ( (LA83_1 == REGULAR_ID))
        	                        {
        	                            {
        	                                int LA83_3 = this->LA(3);
        	                                if ( (LA83_3 == REGULAR_ID))
        	                                {
        	                                    {
        	                                        int LA83_12 = this->LA(4);
        	                                        if ( (LA83_12 == CHAR_STRING))
        	                                        {
        	                                            {
        	                                                int LA83_13 = this->LA(5);
        	                                                if ( ((equalsIgnoreCase(LT(1)->getText(), "AT"))))
        	                                                {
        	                                                    alt83=1;
        	                                                }
        	                                            }
        	                                        }
        	                                        else if ( (LA83_12 == CHAR_STRING_PERL || LA83_12 == NATIONAL_CHAR_STRING_LIT))
        	                                        {
        	                                            {
        	                                                int LA83_14 = this->LA(5);
        	                                                if ( ((equalsIgnoreCase(LT(1)->getText(), "AT"))))
        	                                                {
        	                                                    alt83=1;
        	                                                }
        	                                            }
        	                                        }
        	                                    }
        	                                }
        	                            }
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt83)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:353:57: at_key time_key zone_key quoted_string
        	        	    {
        	        	        this->followPush(FOLLOW_at_key_in_constant2799);
        	        	        m_gPLSQLParser->at_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_time_key_in_constant2801);
        	        	        m_gPLSQLParser->time_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_zone_key_in_constant2803);
        	        	        m_gPLSQLParser->zone_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_quoted_string_in_constant2805);
        	        	        quoted_string();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:354:10: interval_key ( quoted_string | bind_variable | general_element_part ) ( day_key | hour_key | minute_key | second_key ) ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) ( COMMA ( UNSIGNED_INTEGER | bind_variable ) )? RIGHT_PAREN )? ( to_key ( day_key | hour_key | minute_key | second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )? ) )?
        	    {
        	        this->followPush(FOLLOW_interval_key_in_constant2818);
        	        m_gPLSQLParser->interval_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:354:23: ( quoted_string | bind_variable | general_element_part )
        	        {
        	            int alt84=3;
        	            switch ( this->LA(1) )
        	            {
        	            case CHAR_STRING:
        	            case CHAR_STRING_PERL:
        	            case NATIONAL_CHAR_STRING_LIT:
        	            	{
        	            		alt84=1;
        	            	}
        	                break;
        	            case BINDVAR:
        	            case COLON:
        	            	{
        	            		alt84=2;
        	            	}
        	                break;
        	            case DELIMITED_ID:
        	            case INTRODUCER:
        	            case REGULAR_ID:
        	            	{
        	            		alt84=3;
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return ;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 84 );
        	                ex->set_state( 0 );


        	                goto ruleconstantEx;

        	            }

        	            switch (alt84)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:354:24: quoted_string
        	        	    {
        	        	        this->followPush(FOLLOW_quoted_string_in_constant2821);
        	        	        quoted_string();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQLCommons.g:354:40: bind_variable
        	        	    {
        	        	        this->followPush(FOLLOW_bind_variable_in_constant2825);
        	        	        bind_variable();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // PLSQLCommons.g:354:56: general_element_part
        	        	    {
        	        	        this->followPush(FOLLOW_general_element_part_in_constant2829);
        	        	        general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLCommons.g:355:10: ( day_key | hour_key | minute_key | second_key )
        	        {
        	            int alt85=4;
        	            {
        	                int LA85_0 = this->LA(1);
        	                if ( (LA85_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA85_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "DAY"))))
        	                        {
        	                            alt85=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "HOUR"))))
        	                        {
        	                            alt85=2;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "MINUTE"))))
        	                        {
        	                            alt85=3;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "SECOND"))))
        	                        {
        	                            alt85=4;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 85 );
        	                            ex->set_state( 1 );


        	                            goto ruleconstantEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 85 );
        	                    ex->set_state( 0 );


        	                    goto ruleconstantEx;

        	                }
        	            }
        	            switch (alt85)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:355:12: day_key
        	        	    {
        	        	        this->followPush(FOLLOW_day_key_in_constant2843);
        	        	        m_gPLSQLParser->day_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQLCommons.g:355:22: hour_key
        	        	    {
        	        	        this->followPush(FOLLOW_hour_key_in_constant2847);
        	        	        m_gPLSQLParser->hour_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // PLSQLCommons.g:355:33: minute_key
        	        	    {
        	        	        this->followPush(FOLLOW_minute_key_in_constant2851);
        	        	        m_gPLSQLParser->minute_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // PLSQLCommons.g:355:46: second_key
        	        	    {
        	        	        this->followPush(FOLLOW_second_key_in_constant2855);
        	        	        m_gPLSQLParser->second_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLCommons.g:356:10: ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) ( COMMA ( UNSIGNED_INTEGER | bind_variable ) )? RIGHT_PAREN )?
        	        {
        	            int alt89=2;
        	            {
        	                int LA89_0 = this->LA(1);
        	                if ( (LA89_0 == LEFT_PAREN))
        	                {
        	                    {
        	                        int LA89_1 = this->LA(2);
        	                        if ( (LA89_1 == BINDVAR || LA89_1 == COLON || LA89_1 == UNSIGNED_INTEGER))
        	                        {
        	                            alt89=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt89)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:356:12: LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) ( COMMA ( UNSIGNED_INTEGER | bind_variable ) )? RIGHT_PAREN
        	        	    {
        	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_constant2869);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQLCommons.g:356:23: ( UNSIGNED_INTEGER | bind_variable )
        	        	        {
        	        	            int alt86=2;
        	        	            {
        	        	                int LA86_0 = this->LA(1);
        	        	                if ( (LA86_0 == UNSIGNED_INTEGER))
        	        	                {
        	        	                    alt86=1;
        	        	                }
        	        	                else if ( (LA86_0 == BINDVAR || LA86_0 == COLON))
        	        	                {
        	        	                    alt86=2;
        	        	                }
        	        	                else
        	        	                {
        	        	                    if (this->get_backtracking()>0)
        	        	                    {
        	        	                        this->set_failedflag( true );
        	        	                        return ;
        	        	                    }


        	        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                    ex->set_decisionNum( 86 );
        	        	                    ex->set_state( 0 );


        	        	                    goto ruleconstantEx;

        	        	                }
        	        	            }
        	        	            switch (alt86)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQLCommons.g:356:24: UNSIGNED_INTEGER
        	        	        	    {
        	        	        	         this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_constant2872);
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // PLSQLCommons.g:356:43: bind_variable
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_bind_variable_in_constant2876);
        	        	        	        bind_variable();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        // PLSQLCommons.g:356:58: ( COMMA ( UNSIGNED_INTEGER | bind_variable ) )?
        	        	        {
        	        	            int alt88=2;
        	        	            {
        	        	                int LA88_0 = this->LA(1);
        	        	                if ( (LA88_0 == COMMA))
        	        	                {
        	        	                    alt88=1;
        	        	                }
        	        	            }
        	        	            switch (alt88)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQLCommons.g:356:59: COMMA ( UNSIGNED_INTEGER | bind_variable )
        	        	        	    {
        	        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_constant2880);
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        // PLSQLCommons.g:356:65: ( UNSIGNED_INTEGER | bind_variable )
        	        	        	        {
        	        	        	            int alt87=2;
        	        	        	            {
        	        	        	                int LA87_0 = this->LA(1);
        	        	        	                if ( (LA87_0 == UNSIGNED_INTEGER))
        	        	        	                {
        	        	        	                    alt87=1;
        	        	        	                }
        	        	        	                else if ( (LA87_0 == BINDVAR || LA87_0 == COLON))
        	        	        	                {
        	        	        	                    alt87=2;
        	        	        	                }
        	        	        	                else
        	        	        	                {
        	        	        	                    if (this->get_backtracking()>0)
        	        	        	                    {
        	        	        	                        this->set_failedflag( true );
        	        	        	                        return ;
        	        	        	                    }


        	        	        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	        	                    ex->set_decisionNum( 87 );
        	        	        	                    ex->set_state( 0 );


        	        	        	                    goto ruleconstantEx;

        	        	        	                }
        	        	        	            }
        	        	        	            switch (alt87)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // PLSQLCommons.g:356:66: UNSIGNED_INTEGER
        	        	        	        	    {
        	        	        	        	         this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_constant2883);
        	        	        	        	        if  (this->hasException())
        	        	        	        	        {
        	        	        	        	            goto ruleconstantEx;
        	        	        	        	        }
        	        	        	        	        if (this->hasFailed())
        	        	        	        	        {
        	        	        	        	            return ;
        	        	        	        	        }


        	        	        	        	    }
        	        	        	        	    break;
        	        	        	        	case 2:
        	        	        	        	    // PLSQLCommons.g:356:85: bind_variable
        	        	        	        	    {
        	        	        	        	        this->followPush(FOLLOW_bind_variable_in_constant2887);
        	        	        	        	        bind_variable();

        	        	        	        	        this->followPop();
        	        	        	        	        if  (this->hasException())
        	        	        	        	        {
        	        	        	        	            goto ruleconstantEx;
        	        	        	        	        }
        	        	        	        	        if (this->hasFailed())
        	        	        	        	        {
        	        	        	        	            return ;
        	        	        	        	        }


        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_constant2893);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLCommons.g:357:10: ( to_key ( day_key | hour_key | minute_key | second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )? ) )?
        	        {
        	            int alt93=2;
        	            {
        	                int LA93_0 = this->LA(1);
        	                if ( (LA93_0 == SQL92_RESERVED_TO))
        	                {
        	                    {
        	                        int LA93_1 = this->LA(2);
        	                        if ( (LA93_1 == REGULAR_ID))
        	                        {
        	                            alt93=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt93)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:357:12: to_key ( day_key | hour_key | minute_key | second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )? )
        	        	    {
        	        	        this->followPush(FOLLOW_to_key_in_constant2908);
        	        	        m_gPLSQLParser->to_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQLCommons.g:358:14: ( day_key | hour_key | minute_key | second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )? )
        	        	        {
        	        	            int alt92=4;
        	        	            {
        	        	                int LA92_0 = this->LA(1);
        	        	                if ( (LA92_0 == REGULAR_ID))
        	        	                {
        	        	                    {
        	        	                        int LA92_1 = this->LA(2);
        	        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "DAY"))))
        	        	                        {
        	        	                            alt92=1;
        	        	                        }
        	        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "HOUR"))))
        	        	                        {
        	        	                            alt92=2;
        	        	                        }
        	        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "MINUTE"))))
        	        	                        {
        	        	                            alt92=3;
        	        	                        }
        	        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "SECOND"))))
        	        	                        {
        	        	                            alt92=4;
        	        	                        }
        	        	                        else
        	        	                        {
        	        	                            if (this->get_backtracking()>0)
        	        	                            {
        	        	                                this->set_failedflag( true );
        	        	                                return ;
        	        	                            }


        	        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                            ex->set_decisionNum( 92 );
        	        	                            ex->set_state( 1 );


        	        	                            goto ruleconstantEx;

        	        	                        }
        	        	                    }
        	        	                }
        	        	                else
        	        	                {
        	        	                    if (this->get_backtracking()>0)
        	        	                    {
        	        	                        this->set_failedflag( true );
        	        	                        return ;
        	        	                    }


        	        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                    ex->set_decisionNum( 92 );
        	        	                    ex->set_state( 0 );


        	        	                    goto ruleconstantEx;

        	        	                }
        	        	            }
        	        	            switch (alt92)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQLCommons.g:358:16: day_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_day_key_in_constant2925);
        	        	        	        m_gPLSQLParser->day_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // PLSQLCommons.g:358:26: hour_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_hour_key_in_constant2929);
        	        	        	        m_gPLSQLParser->hour_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 3:
        	        	        	    // PLSQLCommons.g:358:37: minute_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_minute_key_in_constant2933);
        	        	        	        m_gPLSQLParser->minute_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 4:
        	        	        	    // PLSQLCommons.g:358:50: second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )?
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_second_key_in_constant2937);
        	        	        	        m_gPLSQLParser->second_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        // PLSQLCommons.g:358:61: ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )?
        	        	        	        {
        	        	        	            int alt91=2;
        	        	        	            {
        	        	        	                int LA91_0 = this->LA(1);
        	        	        	                if ( (LA91_0 == LEFT_PAREN))
        	        	        	                {
        	        	        	                    {
        	        	        	                        int LA91_1 = this->LA(2);
        	        	        	                        if ( (LA91_1 == BINDVAR || LA91_1 == COLON || LA91_1 == UNSIGNED_INTEGER))
        	        	        	                        {
        	        	        	                            alt91=1;
        	        	        	                        }
        	        	        	                    }
        	        	        	                }
        	        	        	            }
        	        	        	            switch (alt91)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // PLSQLCommons.g:358:62: LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN
        	        	        	        	    {
        	        	        	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_constant2940);
        	        	        	        	        if  (this->hasException())
        	        	        	        	        {
        	        	        	        	            goto ruleconstantEx;
        	        	        	        	        }
        	        	        	        	        if (this->hasFailed())
        	        	        	        	        {
        	        	        	        	            return ;
        	        	        	        	        }


        	        	        	        	        // PLSQLCommons.g:358:73: ( UNSIGNED_INTEGER | bind_variable )
        	        	        	        	        {
        	        	        	        	            int alt90=2;
        	        	        	        	            {
        	        	        	        	                int LA90_0 = this->LA(1);
        	        	        	        	                if ( (LA90_0 == UNSIGNED_INTEGER))
        	        	        	        	                {
        	        	        	        	                    alt90=1;
        	        	        	        	                }
        	        	        	        	                else if ( (LA90_0 == BINDVAR || LA90_0 == COLON))
        	        	        	        	                {
        	        	        	        	                    alt90=2;
        	        	        	        	                }
        	        	        	        	                else
        	        	        	        	                {
        	        	        	        	                    if (this->get_backtracking()>0)
        	        	        	        	                    {
        	        	        	        	                        this->set_failedflag( true );
        	        	        	        	                        return ;
        	        	        	        	                    }


        	        	        	        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	        	        	                    ex->set_decisionNum( 90 );
        	        	        	        	                    ex->set_state( 0 );


        	        	        	        	                    goto ruleconstantEx;

        	        	        	        	                }
        	        	        	        	            }
        	        	        	        	            switch (alt90)
        	        	        	        	            {
        	        	        	        	        	case 1:
        	        	        	        	        	    // PLSQLCommons.g:358:74: UNSIGNED_INTEGER
        	        	        	        	        	    {
        	        	        	        	        	         this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_constant2943);
        	        	        	        	        	        if  (this->hasException())
        	        	        	        	        	        {
        	        	        	        	        	            goto ruleconstantEx;
        	        	        	        	        	        }
        	        	        	        	        	        if (this->hasFailed())
        	        	        	        	        	        {
        	        	        	        	        	            return ;
        	        	        	        	        	        }


        	        	        	        	        	    }
        	        	        	        	        	    break;
        	        	        	        	        	case 2:
        	        	        	        	        	    // PLSQLCommons.g:358:93: bind_variable
        	        	        	        	        	    {
        	        	        	        	        	        this->followPush(FOLLOW_bind_variable_in_constant2947);
        	        	        	        	        	        bind_variable();

        	        	        	        	        	        this->followPop();
        	        	        	        	        	        if  (this->hasException())
        	        	        	        	        	        {
        	        	        	        	        	            goto ruleconstantEx;
        	        	        	        	        	        }
        	        	        	        	        	        if (this->hasFailed())
        	        	        	        	        	        {
        	        	        	        	        	            return ;
        	        	        	        	        	        }


        	        	        	        	        	    }
        	        	        	        	        	    break;

        	        	        	        	            }
        	        	        	        	        }

        	        	        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_constant2950);
        	        	        	        	        if  (this->hasException())
        	        	        	        	        {
        	        	        	        	            goto ruleconstantEx;
        	        	        	        	        }
        	        	        	        	        if (this->hasFailed())
        	        	        	        	        {
        	        	        	        	            return ;
        	        	        	        	        }


        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // PLSQLCommons.g:360:10: numeric
        	    {
        	        this->followPush(FOLLOW_numeric_in_constant2977);
        	        numeric();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQLCommons.g:361:10: date_key quoted_string
        	    {
        	        this->followPush(FOLLOW_date_key_in_constant2988);
        	        m_gPLSQLParser->date_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_quoted_string_in_constant2990);
        	        quoted_string();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQLCommons.g:362:10: quoted_string
        	    {
        	        this->followPush(FOLLOW_quoted_string_in_constant3001);
        	        quoted_string();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // PLSQLCommons.g:363:10: null_key
        	    {
        	        this->followPush(FOLLOW_null_key_in_constant3012);
        	        m_gPLSQLParser->null_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 7:
        	    // PLSQLCommons.g:364:10: true_key
        	    {
        	        this->followPush(FOLLOW_true_key_in_constant3023);
        	        m_gPLSQLParser->true_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 8:
        	    // PLSQLCommons.g:365:10: false_key
        	    {
        	        this->followPush(FOLLOW_false_key_in_constant3034);
        	        m_gPLSQLParser->false_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 9:
        	    // PLSQLCommons.g:366:10: dbtimezone_key
        	    {
        	        this->followPush(FOLLOW_dbtimezone_key_in_constant3045);
        	        m_gPLSQLParser->dbtimezone_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 10:
        	    // PLSQLCommons.g:367:10: sessiontimezone_key
        	    {
        	        this->followPush(FOLLOW_sessiontimezone_key_in_constant3057);
        	        m_gPLSQLParser->sessiontimezone_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 11:
        	    // PLSQLCommons.g:368:10: minvalue_key
        	    {
        	        this->followPush(FOLLOW_minvalue_key_in_constant3068);
        	        m_gPLSQLParser->minvalue_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 12:
        	    // PLSQLCommons.g:369:10: maxvalue_key
        	    {
        	        this->followPush(FOLLOW_maxvalue_key_in_constant3079);
        	        m_gPLSQLParser->maxvalue_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 13:
        	    // PLSQLCommons.g:370:10: default_key
        	    {
        	        this->followPush(FOLLOW_default_key_in_constant3090);
        	        m_gPLSQLParser->default_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleconstantEx; /* Prevent compiler warnings */
    ruleconstantEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end constant */

/**
 * $ANTLR start numeric
 * PLSQLCommons.g:373:1: numeric : ( UNSIGNED_INTEGER | EXACT_NUM_LIT | APPROXIMATE_NUM_LIT );
 */
void
PLSQLParser_PLSQLCommons::numeric()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:374:5: ( UNSIGNED_INTEGER | EXACT_NUM_LIT | APPROXIMATE_NUM_LIT )
        // PLSQLCommons.g:
        {
            if ( this->LA(1) == APPROXIMATE_NUM_LIT || this->LA(1) == EXACT_NUM_LIT || this->LA(1) == UNSIGNED_INTEGER )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulenumericEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenumericEx; /* Prevent compiler warnings */
    rulenumericEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end numeric */

/**
 * $ANTLR start quoted_string
 * PLSQLCommons.g:378:1: quoted_string : ( CHAR_STRING | CHAR_STRING_PERL | NATIONAL_CHAR_STRING_LIT );
 */
void
PLSQLParser_PLSQLCommons::quoted_string()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:379:5: ( CHAR_STRING | CHAR_STRING_PERL | NATIONAL_CHAR_STRING_LIT )
        // PLSQLCommons.g:
        {
            if ( ((this->LA(1) >= CHAR_STRING) && (this->LA(1) <= CHAR_STRING_PERL)) || this->LA(1) == NATIONAL_CHAR_STRING_LIT )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulequoted_stringEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulequoted_stringEx; /* Prevent compiler warnings */
    rulequoted_stringEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end quoted_string */

/**
 * $ANTLR start id
 * PLSQLCommons.g:384:1: id : ( INTRODUCER char_set_name )? id_expression ;
 */
void
PLSQLParser_PLSQLCommons::id()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:385:5: ( ( INTRODUCER char_set_name )? id_expression )
        // PLSQLCommons.g:385:10: ( INTRODUCER char_set_name )? id_expression
        {
            // PLSQLCommons.g:385:10: ( INTRODUCER char_set_name )?
            {
                int alt95=2;
                {
                    int LA95_0 = this->LA(1);
                    if ( (LA95_0 == INTRODUCER))
                    {
                        alt95=1;
                    }
                }
                switch (alt95)
                {
            	case 1:
            	    // PLSQLCommons.g:385:11: INTRODUCER char_set_name
            	    {
            	         this->matchToken(INTRODUCER, &FOLLOW_INTRODUCER_in_id3190);
            	        if  (this->hasException())
            	        {
            	            goto ruleidEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_char_set_name_in_id3192);
            	        char_set_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleidEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_id_expression_in_id3204);
            id_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleidEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleidEx; /* Prevent compiler warnings */
    ruleidEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end id */

/**
 * $ANTLR start id_expression
 * PLSQLCommons.g:389:1: id_expression : ( REGULAR_ID | DELIMITED_ID );
 */
void
PLSQLParser_PLSQLCommons::id_expression()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:390:5: ( REGULAR_ID | DELIMITED_ID )
        // PLSQLCommons.g:
        {
            if ( this->LA(1) == DELIMITED_ID || this->LA(1) == REGULAR_ID )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto ruleid_expressionEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleid_expressionEx; /* Prevent compiler warnings */
    ruleid_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end id_expression */

/**
 * $ANTLR start not_equal_op
 * PLSQLCommons.g:394:1: not_equal_op : ( NOT_EQUAL_OP | LESS_THAN_OP GREATER_THAN_OP | EXCLAMATION_OPERATOR_PART EQUALS_OP | CARRET_OPERATOR_PART EQUALS_OP );
 */
void
PLSQLParser_PLSQLCommons::not_equal_op()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:395:5: ( NOT_EQUAL_OP | LESS_THAN_OP GREATER_THAN_OP | EXCLAMATION_OPERATOR_PART EQUALS_OP | CARRET_OPERATOR_PART EQUALS_OP )

            ANTLR_UINT32 alt96;

            alt96=4;

            switch ( this->LA(1) )
            {
            case NOT_EQUAL_OP:
            	{
            		alt96=1;
            	}
                break;
            case LESS_THAN_OP:
            	{
            		alt96=2;
            	}
                break;
            case EXCLAMATION_OPERATOR_PART:
            	{
            		alt96=3;
            	}
                break;
            case CARRET_OPERATOR_PART:
            	{
            		alt96=4;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 96 );
                ex->set_state( 0 );


                goto rulenot_equal_opEx;

            }

            switch (alt96)
            {
        	case 1:
        	    // PLSQLCommons.g:395:10: NOT_EQUAL_OP
        	    {
        	         this->matchToken(NOT_EQUAL_OP, &FOLLOW_NOT_EQUAL_OP_in_not_equal_op3255);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:396:10: LESS_THAN_OP GREATER_THAN_OP
        	    {
        	         this->matchToken(LESS_THAN_OP, &FOLLOW_LESS_THAN_OP_in_not_equal_op3266);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(GREATER_THAN_OP, &FOLLOW_GREATER_THAN_OP_in_not_equal_op3268);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLCommons.g:397:10: EXCLAMATION_OPERATOR_PART EQUALS_OP
        	    {
        	         this->matchToken(EXCLAMATION_OPERATOR_PART, &FOLLOW_EXCLAMATION_OPERATOR_PART_in_not_equal_op3279);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_not_equal_op3281);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQLCommons.g:398:10: CARRET_OPERATOR_PART EQUALS_OP
        	    {
        	         this->matchToken(CARRET_OPERATOR_PART, &FOLLOW_CARRET_OPERATOR_PART_in_not_equal_op3292);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_not_equal_op3294);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulenot_equal_opEx; /* Prevent compiler warnings */
    rulenot_equal_opEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end not_equal_op */

/**
 * $ANTLR start greater_than_or_equals_op
 * PLSQLCommons.g:401:1: greater_than_or_equals_op : ( GREATER_THAN_OR_EQUALS_OP | GREATER_THAN_OP EQUALS_OP );
 */
void
PLSQLParser_PLSQLCommons::greater_than_or_equals_op()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:402:5: ( GREATER_THAN_OR_EQUALS_OP | GREATER_THAN_OP EQUALS_OP )

            ANTLR_UINT32 alt97;

            alt97=2;

            {
                int LA97_0 = this->LA(1);
                if ( (LA97_0 == GREATER_THAN_OR_EQUALS_OP))
                {
                    alt97=1;
                }
                else if ( (LA97_0 == GREATER_THAN_OP))
                {
                    alt97=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 97 );
                    ex->set_state( 0 );


                    goto rulegreater_than_or_equals_opEx;

                }
            }
            switch (alt97)
            {
        	case 1:
        	    // PLSQLCommons.g:402:10: GREATER_THAN_OR_EQUALS_OP
        	    {
        	         this->matchToken(GREATER_THAN_OR_EQUALS_OP, &FOLLOW_GREATER_THAN_OR_EQUALS_OP_in_greater_than_or_equals_op3314);
        	        if  (this->hasException())
        	        {
        	            goto rulegreater_than_or_equals_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:403:10: GREATER_THAN_OP EQUALS_OP
        	    {
        	         this->matchToken(GREATER_THAN_OP, &FOLLOW_GREATER_THAN_OP_in_greater_than_or_equals_op3325);
        	        if  (this->hasException())
        	        {
        	            goto rulegreater_than_or_equals_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_greater_than_or_equals_op3327);
        	        if  (this->hasException())
        	        {
        	            goto rulegreater_than_or_equals_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulegreater_than_or_equals_opEx; /* Prevent compiler warnings */
    rulegreater_than_or_equals_opEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end greater_than_or_equals_op */

/**
 * $ANTLR start less_than_or_equals_op
 * PLSQLCommons.g:406:1: less_than_or_equals_op : ( LESS_THAN_OR_EQUALS_OP | LESS_THAN_OP EQUALS_OP );
 */
void
PLSQLParser_PLSQLCommons::less_than_or_equals_op()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:407:5: ( LESS_THAN_OR_EQUALS_OP | LESS_THAN_OP EQUALS_OP )

            ANTLR_UINT32 alt98;

            alt98=2;

            {
                int LA98_0 = this->LA(1);
                if ( (LA98_0 == LESS_THAN_OR_EQUALS_OP))
                {
                    alt98=1;
                }
                else if ( (LA98_0 == LESS_THAN_OP))
                {
                    alt98=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 98 );
                    ex->set_state( 0 );


                    goto ruleless_than_or_equals_opEx;

                }
            }
            switch (alt98)
            {
        	case 1:
        	    // PLSQLCommons.g:407:10: LESS_THAN_OR_EQUALS_OP
        	    {
        	         this->matchToken(LESS_THAN_OR_EQUALS_OP, &FOLLOW_LESS_THAN_OR_EQUALS_OP_in_less_than_or_equals_op3347);
        	        if  (this->hasException())
        	        {
        	            goto ruleless_than_or_equals_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:408:10: LESS_THAN_OP EQUALS_OP
        	    {
        	         this->matchToken(LESS_THAN_OP, &FOLLOW_LESS_THAN_OP_in_less_than_or_equals_op3358);
        	        if  (this->hasException())
        	        {
        	            goto ruleless_than_or_equals_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_less_than_or_equals_op3360);
        	        if  (this->hasException())
        	        {
        	            goto ruleless_than_or_equals_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleless_than_or_equals_opEx; /* Prevent compiler warnings */
    ruleless_than_or_equals_opEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end less_than_or_equals_op */

/**
 * $ANTLR start concatenation_op
 * PLSQLCommons.g:411:1: concatenation_op : ( CONCATENATION_OP | VERTICAL_BAR VERTICAL_BAR );
 */
void
PLSQLParser_PLSQLCommons::concatenation_op()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:412:5: ( CONCATENATION_OP | VERTICAL_BAR VERTICAL_BAR )

            ANTLR_UINT32 alt99;

            alt99=2;

            {
                int LA99_0 = this->LA(1);
                if ( (LA99_0 == CONCATENATION_OP))
                {
                    alt99=1;
                }
                else if ( (LA99_0 == VERTICAL_BAR))
                {
                    alt99=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 99 );
                    ex->set_state( 0 );


                    goto ruleconcatenation_opEx;

                }
            }
            switch (alt99)
            {
        	case 1:
        	    // PLSQLCommons.g:412:10: CONCATENATION_OP
        	    {
        	         this->matchToken(CONCATENATION_OP, &FOLLOW_CONCATENATION_OP_in_concatenation_op3380);
        	        if  (this->hasException())
        	        {
        	            goto ruleconcatenation_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:413:10: VERTICAL_BAR VERTICAL_BAR
        	    {
        	         this->matchToken(VERTICAL_BAR, &FOLLOW_VERTICAL_BAR_in_concatenation_op3391);
        	        if  (this->hasException())
        	        {
        	            goto ruleconcatenation_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(VERTICAL_BAR, &FOLLOW_VERTICAL_BAR_in_concatenation_op3393);
        	        if  (this->hasException())
        	        {
        	            goto ruleconcatenation_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleconcatenation_opEx; /* Prevent compiler warnings */
    ruleconcatenation_opEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end concatenation_op */

/**
 * $ANTLR start multiset_op
 * PLSQLCommons.g:416:2: multiset_op : multiset_key ( except_key | intersect_key | union_key ) ( all_key | distinct_key )? ;
 */
void
PLSQLParser_PLSQLCommons::multiset_op()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:417:5: ( multiset_key ( except_key | intersect_key | union_key ) ( all_key | distinct_key )? )
        // PLSQLCommons.g:417:10: multiset_key ( except_key | intersect_key | union_key ) ( all_key | distinct_key )?
        {
            this->followPush(FOLLOW_multiset_key_in_multiset_op3414);
            m_gPLSQLParser->multiset_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemultiset_opEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:418:10: ( except_key | intersect_key | union_key )
            {
                int alt100=3;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		alt100=1;
                	}
                    break;
                case SQL92_RESERVED_INTERSECT:
                	{
                		alt100=2;
                	}
                    break;
                case SQL92_RESERVED_UNION:
                	{
                		alt100=3;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 100 );
                    ex->set_state( 0 );


                    goto rulemultiset_opEx;

                }

                switch (alt100)
                {
            	case 1:
            	    // PLSQLCommons.g:418:12: except_key
            	    {
            	        this->followPush(FOLLOW_except_key_in_multiset_op3427);
            	        m_gPLSQLParser->except_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_opEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:418:25: intersect_key
            	    {
            	        this->followPush(FOLLOW_intersect_key_in_multiset_op3431);
            	        m_gPLSQLParser->intersect_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_opEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLCommons.g:418:41: union_key
            	    {
            	        this->followPush(FOLLOW_union_key_in_multiset_op3435);
            	        m_gPLSQLParser->union_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_opEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLCommons.g:419:10: ( all_key | distinct_key )?
            {
                int alt101=3;
                {
                    int LA101_0 = this->LA(1);
                    if ( (LA101_0 == SQL92_RESERVED_ALL))
                    {
                        alt101=1;
                    }
                    else if ( (LA101_0 == SQL92_RESERVED_DISTINCT))
                    {
                        alt101=2;
                    }
                }
                switch (alt101)
                {
            	case 1:
            	    // PLSQLCommons.g:419:12: all_key
            	    {
            	        this->followPush(FOLLOW_all_key_in_multiset_op3450);
            	        m_gPLSQLParser->all_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_opEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:419:22: distinct_key
            	    {
            	        this->followPush(FOLLOW_distinct_key_in_multiset_op3454);
            	        m_gPLSQLParser->distinct_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_opEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemultiset_opEx; /* Prevent compiler warnings */
    rulemultiset_opEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multiset_op */

/**
 * $ANTLR start outer_join_sign
 * PLSQLCommons.g:422:1: outer_join_sign : LEFT_PAREN PLUS_SIGN RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQLCommons::outer_join_sign()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:423:5: ( LEFT_PAREN PLUS_SIGN RIGHT_PAREN )
        // PLSQLCommons.g:423:10: LEFT_PAREN PLUS_SIGN RIGHT_PAREN
        {
             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_outer_join_sign3477);
            if  (this->hasException())
            {
                goto ruleouter_join_signEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(PLUS_SIGN, &FOLLOW_PLUS_SIGN_in_outer_join_sign3479);
            if  (this->hasException())
            {
                goto ruleouter_join_signEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_outer_join_sign3481);
            if  (this->hasException())
            {
                goto ruleouter_join_signEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleouter_join_signEx; /* Prevent compiler warnings */
    ruleouter_join_signEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end outer_join_sign */

// $ANTLR start synpred1_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred1_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:39:10: ( ( as_key )? ( id | alias_quoted_string ) )
    // PLSQLCommons.g:39:10: ( as_key )? ( id | alias_quoted_string )
    {
        // PLSQLCommons.g:39:10: ( as_key )?
        {
            int alt102=2;
            {
                int LA102_0 = this->LA(1);
                if ( (LA102_0 == SQL92_RESERVED_AS))
                {
                    alt102=1;
                }
            }
            switch (alt102)
            {
        	case 1:
        	    // PLSQLCommons.g:39:10: as_key
        	    {
        	        this->followPush(FOLLOW_as_key_in_synpred1_PLSQLCommons85);
        	        m_gPLSQLParser->as_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred1_PLSQLCommonsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

        // PLSQLCommons.g:39:18: ( id | alias_quoted_string )
        {
            int alt103=2;
            {
                int LA103_0 = this->LA(1);
                if ( (LA103_0 == DELIMITED_ID || LA103_0 == INTRODUCER || LA103_0 == REGULAR_ID))
                {
                    alt103=1;
                }
                else if ( (((LA103_0 >= CHAR_STRING) && (LA103_0 <= CHAR_STRING_PERL)) || LA103_0 == NATIONAL_CHAR_STRING_LIT))
                {
                    alt103=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 103 );
                    ex->set_state( 0 );


                    goto rulesynpred1_PLSQLCommonsEx;

                }
            }
            switch (alt103)
            {
        	case 1:
        	    // PLSQLCommons.g:39:20: id
        	    {
        	        this->followPush(FOLLOW_id_in_synpred1_PLSQLCommons90);
        	        id();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred1_PLSQLCommonsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:39:25: alias_quoted_string
        	    {
        	        this->followPush(FOLLOW_alias_quoted_string_in_synpred1_PLSQLCommons94);
        	        alias_quoted_string();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred1_PLSQLCommonsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

    }


goto rulesynpred1_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred1_PLSQLCommonsEx: ;
}
// $ANTLR end synpred1_PLSQLCommons

// $ANTLR start synpred2_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred2_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:99:14: ( PERIOD id_expression )
    // PLSQLCommons.g:99:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred2_PLSQLCommons440);
        if  (this->hasException())
        {
            goto rulesynpred2_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred2_PLSQLCommons442);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred2_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred2_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred2_PLSQLCommonsEx: ;
}
// $ANTLR end synpred2_PLSQLCommons

// $ANTLR start synpred3_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred3_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:107:14: ( PERIOD id_expression )
    // PLSQLCommons.g:107:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred3_PLSQLCommons501);
        if  (this->hasException())
        {
            goto rulesynpred3_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred3_PLSQLCommons503);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred3_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred3_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred3_PLSQLCommonsEx: ;
}
// $ANTLR end synpred3_PLSQLCommons

// $ANTLR start synpred4_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred4_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:123:14: ( PERIOD id_expression )
    // PLSQLCommons.g:123:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred4_PLSQLCommons595);
        if  (this->hasException())
        {
            goto rulesynpred4_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred4_PLSQLCommons597);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred4_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred4_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred4_PLSQLCommonsEx: ;
}
// $ANTLR end synpred4_PLSQLCommons

// $ANTLR start synpred5_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred5_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:131:14: ( PERIOD id_expression )
    // PLSQLCommons.g:131:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred5_PLSQLCommons649);
        if  (this->hasException())
        {
            goto rulesynpred5_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred5_PLSQLCommons651);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred5_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred5_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred5_PLSQLCommonsEx: ;
}
// $ANTLR end synpred5_PLSQLCommons

// $ANTLR start synpred6_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred6_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:139:25: ( PERIOD id_expression )
    // PLSQLCommons.g:139:26: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred6_PLSQLCommons710);
        if  (this->hasException())
        {
            goto rulesynpred6_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred6_PLSQLCommons712);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred6_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred6_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred6_PLSQLCommonsEx: ;
}
// $ANTLR end synpred6_PLSQLCommons

// $ANTLR start synpred7_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred7_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:143:25: ( PERIOD id_expression )
    // PLSQLCommons.g:143:26: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred7_PLSQLCommons744);
        if  (this->hasException())
        {
            goto rulesynpred7_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred7_PLSQLCommons746);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred7_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred7_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred7_PLSQLCommonsEx: ;
}
// $ANTLR end synpred7_PLSQLCommons

// $ANTLR start synpred8_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred8_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:147:14: ( PERIOD id_expression )
    // PLSQLCommons.g:147:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred8_PLSQLCommons778);
        if  (this->hasException())
        {
            goto rulesynpred8_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred8_PLSQLCommons780);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred8_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred8_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred8_PLSQLCommonsEx: ;
}
// $ANTLR end synpred8_PLSQLCommons

// $ANTLR start synpred9_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred9_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:151:14: ( PERIOD id_expression )
    // PLSQLCommons.g:151:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred9_PLSQLCommons813);
        if  (this->hasException())
        {
            goto rulesynpred9_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred9_PLSQLCommons815);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred9_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred9_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred9_PLSQLCommonsEx: ;
}
// $ANTLR end synpred9_PLSQLCommons

// $ANTLR start synpred10_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred10_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:155:14: ( PERIOD id_expression )
    // PLSQLCommons.g:155:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred10_PLSQLCommons847);
        if  (this->hasException())
        {
            goto rulesynpred10_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred10_PLSQLCommons849);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred10_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred10_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred10_PLSQLCommonsEx: ;
}
// $ANTLR end synpred10_PLSQLCommons

// $ANTLR start synpred11_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred11_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:159:14: ( PERIOD id_expression )
    // PLSQLCommons.g:159:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred11_PLSQLCommons881);
        if  (this->hasException())
        {
            goto rulesynpred11_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred11_PLSQLCommons883);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred11_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred11_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred11_PLSQLCommonsEx: ;
}
// $ANTLR end synpred11_PLSQLCommons

// $ANTLR start synpred12_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred12_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:164:28: ( PERIOD id_expression )
    // PLSQLCommons.g:164:29: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred12_PLSQLCommons934);
        if  (this->hasException())
        {
            goto rulesynpred12_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred12_PLSQLCommons936);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred12_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred12_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred12_PLSQLCommonsEx: ;
}
// $ANTLR end synpred12_PLSQLCommons

// $ANTLR start synpred13_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred13_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:183:14: ( PERIOD id_expression )
    // PLSQLCommons.g:183:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred13_PLSQLCommons1061);
        if  (this->hasException())
        {
            goto rulesynpred13_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred13_PLSQLCommons1063);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred13_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred13_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred13_PLSQLCommonsEx: ;
}
// $ANTLR end synpred13_PLSQLCommons

// $ANTLR start synpred14_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred14_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:191:14: ( PERIOD id_expression )
    // PLSQLCommons.g:191:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred14_PLSQLCommons1115);
        if  (this->hasException())
        {
            goto rulesynpred14_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred14_PLSQLCommons1117);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred14_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred14_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred14_PLSQLCommonsEx: ;
}
// $ANTLR end synpred14_PLSQLCommons

// $ANTLR start synpred15_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred15_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:195:14: ( PERIOD id_expression )
    // PLSQLCommons.g:195:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred15_PLSQLCommons1149);
        if  (this->hasException())
        {
            goto rulesynpred15_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred15_PLSQLCommons1151);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred15_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred15_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred15_PLSQLCommonsEx: ;
}
// $ANTLR end synpred15_PLSQLCommons

// $ANTLR start synpred16_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred16_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:202:25: ( PERIOD id_expression )
    // PLSQLCommons.g:202:26: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred16_PLSQLCommons1218);
        if  (this->hasException())
        {
            goto rulesynpred16_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred16_PLSQLCommons1220);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred16_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred16_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred16_PLSQLCommonsEx: ;
}
// $ANTLR end synpred16_PLSQLCommons

// $ANTLR start synpred17_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred17_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:237:19: ( tableview_name PERIOD ASTERISK )
    // PLSQLCommons.g:237:20: tableview_name PERIOD ASTERISK
    {
        this->followPush(FOLLOW_tableview_name_in_synpred17_PLSQLCommons1555);
        tableview_name();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred17_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred17_PLSQLCommons1557);
        if  (this->hasException())
        {
            goto rulesynpred17_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_synpred17_PLSQLCommons1559);
        if  (this->hasException())
        {
            goto rulesynpred17_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred17_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred17_PLSQLCommonsEx: ;
}
// $ANTLR end synpred17_PLSQLCommons

// $ANTLR start synpred18_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred18_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:250:11: ( id EQUALS_OP GREATER_THAN_OP )
    // PLSQLCommons.g:250:12: id EQUALS_OP GREATER_THAN_OP
    {
        this->followPush(FOLLOW_id_in_synpred18_PLSQLCommons1711);
        id();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred18_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_synpred18_PLSQLCommons1713);
        if  (this->hasException())
        {
            goto rulesynpred18_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(GREATER_THAN_OP, &FOLLOW_GREATER_THAN_OP_in_synpred18_PLSQLCommons1715);
        if  (this->hasException())
        {
            goto rulesynpred18_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred18_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred18_PLSQLCommonsEx: ;
}
// $ANTLR end synpred18_PLSQLCommons

// $ANTLR start synpred19_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred19_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:332:11: ( PERIOD general_element_part )
    // PLSQLCommons.g:332:12: PERIOD general_element_part
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred19_PLSQLCommons2630);
        if  (this->hasException())
        {
            goto rulesynpred19_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_general_element_part_in_synpred19_PLSQLCommons2632);
        general_element_part();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred19_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred19_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred19_PLSQLCommonsEx: ;
}
// $ANTLR end synpred19_PLSQLCommons

// $ANTLR start synpred20_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred20_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:336:32: ( PERIOD general_element_part )
    // PLSQLCommons.g:336:33: PERIOD general_element_part
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred20_PLSQLCommons2664);
        if  (this->hasException())
        {
            goto rulesynpred20_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_general_element_part_in_synpred20_PLSQLCommons2666);
        general_element_part();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred20_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred20_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred20_PLSQLCommonsEx: ;
}
// $ANTLR end synpred20_PLSQLCommons

// $ANTLR start synpred21_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred21_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:341:14: ( PERIOD id_expression )
    // PLSQLCommons.g:341:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred21_PLSQLCommons2717);
        if  (this->hasException())
        {
            goto rulesynpred21_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred21_PLSQLCommons2719);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred21_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred21_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred21_PLSQLCommonsEx: ;
}
// $ANTLR end synpred21_PLSQLCommons
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred4_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred4_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred14_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred14_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred7_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred7_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred5_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred5_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred12_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred12_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred8_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred8_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred10_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred10_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred11_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred11_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred21_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred21_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred1_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred1_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred3_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred3_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred9_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred9_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred15_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred15_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred20_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred20_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred18_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred18_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred17_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred17_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred19_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred19_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred2_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred2_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred16_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred16_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred6_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred6_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred13_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred13_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

}

/* End of code
 * =============================================================================
 */
