/** \file
 *  This C++ source file was generated by $ANTLR version 3.5.1-SNAPSHOT
 *
 *     -  From the grammar source file : PLSQLCommons.g
 *     -                            On : 2013-06-21 14:01:27
 *     -                for the parser : PLSQLParser_PLSQLCommonsParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "PLSQLParser_PLSQLCommons.hpp"
// Include delegator definition header files
//
#include "PLSQLParser.hpp" 

/* ----------------------------------------- */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

namespace 
        User
 {
using namespace antlr3;

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "PLSQLCommons.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* PLSQLParser_PLSQLCommons::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new PLSQLParser_PLSQLCommons parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PLSQLParser_PLSQLCommons::PLSQLParser_PLSQLCommons( StreamType* instream, PLSQLParser* gPLSQLParser)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream, gPLSQLParser);
}

/** \brief Create a new PLSQLParser_PLSQLCommons parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PLSQLParser_PLSQLCommons::PLSQLParser_PLSQLCommons( StreamType* instream, RecognizerSharedStateType* state, PLSQLParser* gPLSQLParser)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream , gPLSQLParser);
}

void PLSQLParser_PLSQLCommons::init(StreamType* instream, PLSQLParser* gPLSQLParser)
{
     	// Install the pointers back to lexers that will delegate us to perform certain functions
     	// for them.
     	//
     		m_gPLSQLParser = gPLSQLParser;
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( PLSQLParserTokenNames );


}

void
PLSQLParser_PLSQLCommons::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
PLSQLParser_PLSQLCommons::~PLSQLParser_PLSQLCommons()
 {
}

/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return PLSQLParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_subpartition_key_in_partition_extension_clause37_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_subpartition_key_in_partition_extension_clause37( FOLLOW_subpartition_key_in_partition_extension_clause37_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_partition_key_in_partition_extension_clause41_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_partition_key_in_partition_extension_clause41( FOLLOW_partition_key_in_partition_extension_clause41_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_for_key_in_partition_extension_clause54_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_for_key_in_partition_extension_clause54( FOLLOW_for_key_in_partition_extension_clause54_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_partition_extension_clause57_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_expression_list_in_partition_extension_clause57( FOLLOW_expression_list_in_partition_extension_clause57_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_as_key_in_column_alias86_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_as_key_in_column_alias86( FOLLOW_as_key_in_column_alias86_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_column_alias91_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_column_alias91( FOLLOW_id_in_column_alias91_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_alias_quoted_string_in_column_alias95_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_alias_quoted_string_in_column_alias95( FOLLOW_alias_quoted_string_in_column_alias95_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_as_key_in_column_alias108_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_as_key_in_column_alias108( FOLLOW_as_key_in_column_alias108_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_table_alias130_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_table_alias130( FOLLOW_id_in_table_alias130_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_alias_quoted_string_in_table_alias134_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_alias_quoted_string_in_table_alias134( FOLLOW_alias_quoted_string_in_table_alias134_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_alias_quoted_string156_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_alias_quoted_string156( FOLLOW_quoted_string_in_alias_quoted_string156_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_where_key_in_where_clause176_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B88240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_where_key_in_where_clause176( FOLLOW_where_key_in_where_clause176_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_current_of_clause_in_where_clause179_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_current_of_clause_in_where_clause179( FOLLOW_current_of_clause_in_where_clause179_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_condition_wrapper_in_where_clause181_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_condition_wrapper_in_where_clause181( FOLLOW_condition_wrapper_in_where_clause181_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_current_key_in_current_of_clause202_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1000000000000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_current_key_in_current_of_clause202( FOLLOW_current_key_in_current_of_clause202_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_of_key_in_current_of_clause204_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_of_key_in_current_of_clause204( FOLLOW_of_key_in_current_of_clause204_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_cursor_name_in_current_of_clause206_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_cursor_name_in_current_of_clause206( FOLLOW_cursor_name_in_current_of_clause206_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_into_key_in_into_clause226_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_into_key_in_into_clause226( FOLLOW_into_key_in_into_clause226_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_variable_name_in_into_clause228_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_variable_name_in_into_clause228( FOLLOW_variable_name_in_into_clause228_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_into_clause231_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_into_clause231( FOLLOW_COMMA_in_into_clause231_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_variable_name_in_into_clause233_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_variable_name_in_into_clause233( FOLLOW_variable_name_in_into_clause233_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bulk_key_in_into_clause247_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bulk_key_in_into_clause247( FOLLOW_bulk_key_in_into_clause247_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_collect_key_in_into_clause249_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_collect_key_in_into_clause249( FOLLOW_collect_key_in_into_clause249_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_into_key_in_into_clause251_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_into_key_in_into_clause251( FOLLOW_into_key_in_into_clause251_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_variable_name_in_into_clause253_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_variable_name_in_into_clause253( FOLLOW_variable_name_in_into_clause253_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_into_clause256_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_into_clause256( FOLLOW_COMMA_in_into_clause256_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_variable_name_in_into_clause258_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_variable_name_in_into_clause258( FOLLOW_variable_name_in_into_clause258_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_xml_column_name285_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_xml_column_name285( FOLLOW_id_in_xml_column_name285_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_xml_column_name296_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_xml_column_name296( FOLLOW_quoted_string_in_xml_column_name296_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_cost_class_name316_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_cost_class_name316( FOLLOW_id_in_cost_class_name316_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_attribute_name336_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_attribute_name336( FOLLOW_id_in_attribute_name336_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_savepoint_name356_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_savepoint_name356( FOLLOW_id_in_savepoint_name356_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_rollback_segment_name376_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_rollback_segment_name376( FOLLOW_id_in_rollback_segment_name376_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_table_var_name397_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_table_var_name397( FOLLOW_id_in_table_var_name397_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_schema_name417_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_schema_name417( FOLLOW_id_in_schema_name417_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_routine_name437_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000102) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_routine_name437( FOLLOW_id_in_routine_name437_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_routine_name447_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_routine_name447( FOLLOW_PERIOD_in_routine_name447_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_routine_name449_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000102) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_routine_name449( FOLLOW_id_expression_in_routine_name449_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_AT_SIGN_in_routine_name454_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_AT_SIGN_in_routine_name454( FOLLOW_AT_SIGN_in_routine_name454_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_link_name_in_routine_name456_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_link_name_in_routine_name456( FOLLOW_link_name_in_routine_name456_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_package_name478_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_package_name478( FOLLOW_id_in_package_name478_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_implementation_type_name498_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_implementation_type_name498( FOLLOW_id_in_implementation_type_name498_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_implementation_type_name508_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_implementation_type_name508( FOLLOW_PERIOD_in_implementation_type_name508_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_implementation_type_name510_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_implementation_type_name510( FOLLOW_id_expression_in_implementation_type_name510_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_parameter_name532_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_parameter_name532( FOLLOW_id_in_parameter_name532_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_reference_model_name552_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_reference_model_name552( FOLLOW_id_in_reference_model_name552_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_main_model_name572_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_main_model_name572( FOLLOW_id_in_main_model_name572_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_aggregate_function_name592_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_aggregate_function_name592( FOLLOW_id_in_aggregate_function_name592_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_aggregate_function_name602_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_aggregate_function_name602( FOLLOW_PERIOD_in_aggregate_function_name602_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_aggregate_function_name604_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_aggregate_function_name604( FOLLOW_id_expression_in_aggregate_function_name604_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_query_name626_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_query_name626( FOLLOW_id_in_query_name626_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_constraint_name646_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000102) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_constraint_name646( FOLLOW_id_in_constraint_name646_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_constraint_name656_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_constraint_name656( FOLLOW_PERIOD_in_constraint_name656_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_constraint_name658_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000102) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_constraint_name658( FOLLOW_id_expression_in_constraint_name658_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_AT_SIGN_in_constraint_name663_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_AT_SIGN_in_constraint_name663( FOLLOW_AT_SIGN_in_constraint_name663_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_link_name_in_constraint_name665_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_link_name_in_constraint_name665( FOLLOW_link_name_in_constraint_name665_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_label_name687_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_label_name687( FOLLOW_id_expression_in_label_name687_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_type_name707_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_type_name707( FOLLOW_id_expression_in_type_name707_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_type_name717_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_type_name717( FOLLOW_PERIOD_in_type_name717_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_type_name719_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_type_name719( FOLLOW_id_expression_in_type_name719_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_sequence_name741_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_sequence_name741( FOLLOW_id_expression_in_sequence_name741_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_sequence_name751_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_sequence_name751( FOLLOW_PERIOD_in_sequence_name751_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_sequence_name753_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_sequence_name753( FOLLOW_id_expression_in_sequence_name753_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_exception_name775_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_exception_name775( FOLLOW_id_in_exception_name775_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_exception_name785_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_exception_name785( FOLLOW_PERIOD_in_exception_name785_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_exception_name787_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_exception_name787( FOLLOW_id_expression_in_exception_name787_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_function_name810_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_function_name810( FOLLOW_id_in_function_name810_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_function_name820_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_function_name820( FOLLOW_PERIOD_in_function_name820_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_function_name822_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_function_name822( FOLLOW_id_expression_in_function_name822_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_procedure_name844_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_procedure_name844( FOLLOW_id_in_procedure_name844_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_procedure_name854_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_procedure_name854( FOLLOW_PERIOD_in_procedure_name854_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_procedure_name856_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_procedure_name856( FOLLOW_id_expression_in_procedure_name856_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_trigger_name878_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_trigger_name878( FOLLOW_id_in_trigger_name878_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_trigger_name888_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_trigger_name888( FOLLOW_PERIOD_in_trigger_name888_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_trigger_name890_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_trigger_name890( FOLLOW_id_expression_in_trigger_name890_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_INTRODUCER_in_variable_name913_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_INTRODUCER_in_variable_name913( FOLLOW_INTRODUCER_in_variable_name913_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_char_set_name_in_variable_name915_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_char_set_name_in_variable_name915( FOLLOW_char_set_name_in_variable_name915_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_variable_name931_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_variable_name931( FOLLOW_id_expression_in_variable_name931_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_variable_name941_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_variable_name941( FOLLOW_PERIOD_in_variable_name941_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_variable_name943_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_variable_name943( FOLLOW_id_expression_in_variable_name943_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_variable_name956_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_variable_name956( FOLLOW_bind_variable_in_variable_name956_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_index_name976_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_index_name976( FOLLOW_id_in_index_name976_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_cursor_name996_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_cursor_name996( FOLLOW_id_in_cursor_name996_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_cursor_name1007_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_cursor_name1007( FOLLOW_bind_variable_in_cursor_name1007_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_record_name1027_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_record_name1027( FOLLOW_id_in_record_name1027_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_record_name1038_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_record_name1038( FOLLOW_bind_variable_in_record_name1038_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_collection_name1058_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_collection_name1058( FOLLOW_id_in_collection_name1058_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_collection_name1068_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_collection_name1068( FOLLOW_PERIOD_in_collection_name1068_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_collection_name1070_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_collection_name1070( FOLLOW_id_expression_in_collection_name1070_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_link_name1092_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_link_name1092( FOLLOW_id_in_link_name1092_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_column_name1112_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_column_name1112( FOLLOW_id_in_column_name1112_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_column_name1122_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_column_name1122( FOLLOW_PERIOD_in_column_name1122_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_column_name1124_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_column_name1124( FOLLOW_id_expression_in_column_name1124_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_tableview_name1146_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000102), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_tableview_name1146( FOLLOW_id_in_tableview_name1146_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_tableview_name1156_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_tableview_name1156( FOLLOW_PERIOD_in_tableview_name1156_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_tableview_name1158_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000102), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_tableview_name1158( FOLLOW_id_expression_in_tableview_name1158_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_AT_SIGN_in_tableview_name1172_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_AT_SIGN_in_tableview_name1172( FOLLOW_AT_SIGN_in_tableview_name1172_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_link_name_in_tableview_name1174_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_link_name_in_tableview_name1174( FOLLOW_link_name_in_tableview_name1174_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_partition_extension_clause_in_tableview_name1188_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_partition_extension_clause_in_tableview_name1188( FOLLOW_partition_extension_clause_in_tableview_name1188_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_char_set_name1215_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_char_set_name1215( FOLLOW_id_expression_in_char_set_name1215_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_char_set_name1225_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_char_set_name1225( FOLLOW_PERIOD_in_char_set_name1225_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_char_set_name1227_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_char_set_name1227( FOLLOW_id_expression_in_char_set_name1227_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_keep_key_in_keep_clause1253_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_keep_key_in_keep_clause1253( FOLLOW_keep_key_in_keep_clause1253_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_keep_clause1263_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_keep_clause1263( FOLLOW_LEFT_PAREN_in_keep_clause1263_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_dense_rank_key_in_keep_clause1277_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_dense_rank_key_in_keep_clause1277( FOLLOW_dense_rank_key_in_keep_clause1277_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_first_key_in_keep_clause1280_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_first_key_in_keep_clause1280( FOLLOW_first_key_in_keep_clause1280_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_last_key_in_keep_clause1282_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_last_key_in_keep_clause1282( FOLLOW_last_key_in_keep_clause1282_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_keep_clause1298_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_order_by_clause_in_keep_clause1298( FOLLOW_order_by_clause_in_keep_clause1298_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_keep_clause1308_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_keep_clause1308( FOLLOW_RIGHT_PAREN_in_keep_clause1308_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_over_clause_in_keep_clause1310_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_over_clause_in_keep_clause1310( FOLLOW_over_clause_in_keep_clause1310_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_function_argument1331_bits[]	= { ANTLR_UINT64_LIT(0x000000865044F220), ANTLR_UINT64_LIT(0x0C00184B08241401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_function_argument1331( FOLLOW_LEFT_PAREN_in_function_argument1331_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_argument_in_function_argument1346_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_argument_in_function_argument1346( FOLLOW_argument_in_function_argument1346_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_function_argument1350_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_function_argument1350( FOLLOW_COMMA_in_function_argument1350_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_argument_in_function_argument1352_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_argument_in_function_argument1352( FOLLOW_argument_in_function_argument1352_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_function_argument1366_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_function_argument1366( FOLLOW_RIGHT_PAREN_in_function_argument1366_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_keep_clause_in_function_argument1376_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_keep_clause_in_function_argument1376( FOLLOW_keep_clause_in_function_argument1376_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_function_argument_analytic1397_bits[]	= { ANTLR_UINT64_LIT(0x000000865044F220), ANTLR_UINT64_LIT(0x0C00184B08241401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_function_argument_analytic1397( FOLLOW_LEFT_PAREN_in_function_argument_analytic1397_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_argument_in_function_argument_analytic1412_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_argument_in_function_argument_analytic1412( FOLLOW_argument_in_function_argument_analytic1412_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic1414_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic1414( FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic1414_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_function_argument_analytic1432_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_function_argument_analytic1432( FOLLOW_COMMA_in_function_argument_analytic1432_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_argument_in_function_argument_analytic1434_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_argument_in_function_argument_analytic1434( FOLLOW_argument_in_function_argument_analytic1434_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic1436_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic1436( FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic1436_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_function_argument_analytic1451_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_function_argument_analytic1451( FOLLOW_RIGHT_PAREN_in_function_argument_analytic1451_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_keep_clause_in_function_argument_analytic1462_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_keep_clause_in_function_argument_analytic1462( FOLLOW_keep_clause_in_function_argument_analytic1462_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_function_argument_modeling1483_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_function_argument_modeling1483( FOLLOW_LEFT_PAREN_in_function_argument_modeling1483_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_column_name_in_function_argument_modeling1497_bits[]	= { ANTLR_UINT64_LIT(0x0000100000008000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_column_name_in_function_argument_modeling1497( FOLLOW_column_name_in_function_argument_modeling1497_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_function_argument_modeling1500_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400020), ANTLR_UINT64_LIT(0x0800000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_function_argument_modeling1500( FOLLOW_COMMA_in_function_argument_modeling1500_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_numeric_in_function_argument_modeling1503_bits[]	= { ANTLR_UINT64_LIT(0x0000100000008000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_numeric_in_function_argument_modeling1503( FOLLOW_numeric_in_function_argument_modeling1503_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_null_key_in_function_argument_modeling1505_bits[]	= { ANTLR_UINT64_LIT(0x0000100000008000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_null_key_in_function_argument_modeling1505( FOLLOW_null_key_in_function_argument_modeling1505_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_function_argument_modeling1509_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400020), ANTLR_UINT64_LIT(0x0800000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_function_argument_modeling1509( FOLLOW_COMMA_in_function_argument_modeling1509_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_numeric_in_function_argument_modeling1512_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_numeric_in_function_argument_modeling1512( FOLLOW_numeric_in_function_argument_modeling1512_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_null_key_in_function_argument_modeling1514_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_null_key_in_function_argument_modeling1514( FOLLOW_null_key_in_function_argument_modeling1514_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_using_key_in_function_argument_modeling1535_bits[]	= { ANTLR_UINT64_LIT(0x00000086504472A0), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_using_key_in_function_argument_modeling1535( FOLLOW_using_key_in_function_argument_modeling1535_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_function_argument_modeling1564_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_tableview_name_in_function_argument_modeling1564( FOLLOW_tableview_name_in_function_argument_modeling1564_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_function_argument_modeling1566_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_function_argument_modeling1566( FOLLOW_PERIOD_in_function_argument_modeling1566_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_function_argument_modeling1568_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_ASTERISK_in_function_argument_modeling1568( FOLLOW_ASTERISK_in_function_argument_modeling1568_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_function_argument_modeling1588_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_ASTERISK_in_function_argument_modeling1588( FOLLOW_ASTERISK_in_function_argument_modeling1588_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_expression_in_function_argument_modeling1608_bits[]	= { ANTLR_UINT64_LIT(0x000000041004B000), ANTLR_UINT64_LIT(0x0000000000401400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_expression_in_function_argument_modeling1608( FOLLOW_expression_in_function_argument_modeling1608_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_function_argument_modeling1610_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_column_alias_in_function_argument_modeling1610( FOLLOW_column_alias_in_function_argument_modeling1610_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_function_argument_modeling1614_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_function_argument_modeling1614( FOLLOW_COMMA_in_function_argument_modeling1614_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_expression_in_function_argument_modeling1616_bits[]	= { ANTLR_UINT64_LIT(0x000000041004B000), ANTLR_UINT64_LIT(0x0000000000401400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_expression_in_function_argument_modeling1616( FOLLOW_expression_in_function_argument_modeling1616_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_function_argument_modeling1618_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_column_alias_in_function_argument_modeling1618( FOLLOW_column_alias_in_function_argument_modeling1618_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_function_argument_modeling1650_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_function_argument_modeling1650( FOLLOW_RIGHT_PAREN_in_function_argument_modeling1650_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_keep_clause_in_function_argument_modeling1661_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_keep_clause_in_function_argument_modeling1661( FOLLOW_keep_clause_in_function_argument_modeling1661_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_respect_key_in_respect_or_ignore_nulls1683_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_respect_key_in_respect_or_ignore_nulls1683( FOLLOW_respect_key_in_respect_or_ignore_nulls1683_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_ignore_key_in_respect_or_ignore_nulls1687_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_ignore_key_in_respect_or_ignore_nulls1687( FOLLOW_ignore_key_in_respect_or_ignore_nulls1687_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_respect_or_ignore_nulls1690_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_nulls_key_in_respect_or_ignore_nulls1690( FOLLOW_nulls_key_in_respect_or_ignore_nulls1690_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_argument1720_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_argument1720( FOLLOW_id_in_argument1720_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_argument1722_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_argument1722( FOLLOW_EQUALS_OP_in_argument1722_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OP_in_argument1724_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_GREATER_THAN_OP_in_argument1724( FOLLOW_GREATER_THAN_OP_in_argument1724_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_argument1728_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_expression_wrapper_in_argument1728( FOLLOW_expression_wrapper_in_argument1728_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_datatype_in_type_spec1749_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_datatype_in_type_spec1749( FOLLOW_datatype_in_type_spec1749_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_ref_key_in_type_spec1760_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_ref_key_in_type_spec1760( FOLLOW_ref_key_in_type_spec1760_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_type_name_in_type_spec1763_bits[]	= { ANTLR_UINT64_LIT(0x0000002000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_type_name_in_type_spec1763( FOLLOW_type_name_in_type_spec1763_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_percent_rowtype_key_in_type_spec1766_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_percent_rowtype_key_in_type_spec1766( FOLLOW_percent_rowtype_key_in_type_spec1766_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_percent_type_key_in_type_spec1768_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_percent_type_key_in_type_spec1768( FOLLOW_percent_type_key_in_type_spec1768_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_native_datatype_element_in_datatype1790_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_native_datatype_element_in_datatype1790( FOLLOW_native_datatype_element_in_datatype1790_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_precision_part_in_datatype1800_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_precision_part_in_datatype1800( FOLLOW_precision_part_in_datatype1800_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_with_key_in_datatype1812_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_with_key_in_datatype1812( FOLLOW_with_key_in_datatype1812_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_local_key_in_datatype1814_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_local_key_in_datatype1814( FOLLOW_local_key_in_datatype1814_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_time_key_in_datatype1817_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_time_key_in_datatype1817( FOLLOW_time_key_in_datatype1817_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_zone_key_in_datatype1819_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_zone_key_in_datatype1819( FOLLOW_zone_key_in_datatype1819_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_interval_key_in_datatype1832_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_interval_key_in_datatype1832( FOLLOW_interval_key_in_datatype1832_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_year_key_in_datatype1835_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_year_key_in_datatype1835( FOLLOW_year_key_in_datatype1835_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_day_key_in_datatype1837_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_day_key_in_datatype1837( FOLLOW_day_key_in_datatype1837_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_datatype1857_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_datatype1857( FOLLOW_LEFT_PAREN_in_datatype1857_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_datatype1859_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_expression_wrapper_in_datatype1859( FOLLOW_expression_wrapper_in_datatype1859_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_datatype1861_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_datatype1861( FOLLOW_RIGHT_PAREN_in_datatype1861_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_to_key_in_datatype1878_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_to_key_in_datatype1878( FOLLOW_to_key_in_datatype1878_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_month_key_in_datatype1881_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_month_key_in_datatype1881( FOLLOW_month_key_in_datatype1881_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_second_key_in_datatype1883_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_second_key_in_datatype1883( FOLLOW_second_key_in_datatype1883_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_datatype1904_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_datatype1904( FOLLOW_LEFT_PAREN_in_datatype1904_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_datatype1906_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_expression_wrapper_in_datatype1906( FOLLOW_expression_wrapper_in_datatype1906_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_datatype1908_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_datatype1908( FOLLOW_RIGHT_PAREN_in_datatype1908_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_precision_part1930_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400020), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_precision_part1930( FOLLOW_LEFT_PAREN_in_precision_part1930_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_numeric_in_precision_part1932_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_numeric_in_precision_part1932( FOLLOW_numeric_in_precision_part1932_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_precision_part1935_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400020), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_precision_part1935( FOLLOW_COMMA_in_precision_part1935_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_numeric_in_precision_part1937_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_numeric_in_precision_part1937( FOLLOW_numeric_in_precision_part1937_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_char_key_in_precision_part1942_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_char_key_in_precision_part1942( FOLLOW_char_key_in_precision_part1942_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_byte_key_in_precision_part1946_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_byte_key_in_precision_part1946( FOLLOW_byte_key_in_precision_part1946_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_precision_part1950_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_precision_part1950( FOLLOW_RIGHT_PAREN_in_precision_part1950_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_binary_integer_key_in_native_datatype_element1970_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_binary_integer_key_in_native_datatype_element1970( FOLLOW_binary_integer_key_in_native_datatype_element1970_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_pls_integer_key_in_native_datatype_element1981_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_pls_integer_key_in_native_datatype_element1981( FOLLOW_pls_integer_key_in_native_datatype_element1981_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_natural_key_in_native_datatype_element1992_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_natural_key_in_native_datatype_element1992( FOLLOW_natural_key_in_native_datatype_element1992_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_binary_float_key_in_native_datatype_element2003_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_binary_float_key_in_native_datatype_element2003( FOLLOW_binary_float_key_in_native_datatype_element2003_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_binary_double_key_in_native_datatype_element2014_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_binary_double_key_in_native_datatype_element2014( FOLLOW_binary_double_key_in_native_datatype_element2014_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_naturaln_key_in_native_datatype_element2025_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_naturaln_key_in_native_datatype_element2025( FOLLOW_naturaln_key_in_native_datatype_element2025_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_positive_key_in_native_datatype_element2036_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_positive_key_in_native_datatype_element2036( FOLLOW_positive_key_in_native_datatype_element2036_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_positiven_key_in_native_datatype_element2047_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_positiven_key_in_native_datatype_element2047( FOLLOW_positiven_key_in_native_datatype_element2047_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_signtype_key_in_native_datatype_element2058_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_signtype_key_in_native_datatype_element2058( FOLLOW_signtype_key_in_native_datatype_element2058_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_simple_integer_key_in_native_datatype_element2069_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_simple_integer_key_in_native_datatype_element2069( FOLLOW_simple_integer_key_in_native_datatype_element2069_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_nvarchar2_key_in_native_datatype_element2080_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_nvarchar2_key_in_native_datatype_element2080( FOLLOW_nvarchar2_key_in_native_datatype_element2080_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_dec_key_in_native_datatype_element2091_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_dec_key_in_native_datatype_element2091( FOLLOW_dec_key_in_native_datatype_element2091_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_integer_key_in_native_datatype_element2102_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_integer_key_in_native_datatype_element2102( FOLLOW_integer_key_in_native_datatype_element2102_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_int_key_in_native_datatype_element2113_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_int_key_in_native_datatype_element2113( FOLLOW_int_key_in_native_datatype_element2113_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_numeric_key_in_native_datatype_element2124_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_numeric_key_in_native_datatype_element2124( FOLLOW_numeric_key_in_native_datatype_element2124_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_smallint_key_in_native_datatype_element2135_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_smallint_key_in_native_datatype_element2135( FOLLOW_smallint_key_in_native_datatype_element2135_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_number_key_in_native_datatype_element2146_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_number_key_in_native_datatype_element2146( FOLLOW_number_key_in_native_datatype_element2146_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_decimal_key_in_native_datatype_element2157_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_decimal_key_in_native_datatype_element2157( FOLLOW_decimal_key_in_native_datatype_element2157_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_double_key_in_native_datatype_element2169_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_double_key_in_native_datatype_element2169( FOLLOW_double_key_in_native_datatype_element2169_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_precision_key_in_native_datatype_element2171_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_precision_key_in_native_datatype_element2171( FOLLOW_precision_key_in_native_datatype_element2171_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_float_key_in_native_datatype_element2183_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_float_key_in_native_datatype_element2183( FOLLOW_float_key_in_native_datatype_element2183_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_real_key_in_native_datatype_element2194_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_real_key_in_native_datatype_element2194( FOLLOW_real_key_in_native_datatype_element2194_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_nchar_key_in_native_datatype_element2205_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_nchar_key_in_native_datatype_element2205( FOLLOW_nchar_key_in_native_datatype_element2205_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_long_key_in_native_datatype_element2216_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_long_key_in_native_datatype_element2216( FOLLOW_long_key_in_native_datatype_element2216_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_raw_key_in_native_datatype_element2218_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_raw_key_in_native_datatype_element2218( FOLLOW_raw_key_in_native_datatype_element2218_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_char_key_in_native_datatype_element2230_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_char_key_in_native_datatype_element2230( FOLLOW_char_key_in_native_datatype_element2230_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_character_key_in_native_datatype_element2243_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_character_key_in_native_datatype_element2243( FOLLOW_character_key_in_native_datatype_element2243_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_varchar2_key_in_native_datatype_element2255_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_varchar2_key_in_native_datatype_element2255( FOLLOW_varchar2_key_in_native_datatype_element2255_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_varchar_key_in_native_datatype_element2266_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_varchar_key_in_native_datatype_element2266( FOLLOW_varchar_key_in_native_datatype_element2266_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_string_key_in_native_datatype_element2277_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_string_key_in_native_datatype_element2277( FOLLOW_string_key_in_native_datatype_element2277_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_raw_key_in_native_datatype_element2288_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_raw_key_in_native_datatype_element2288( FOLLOW_raw_key_in_native_datatype_element2288_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_boolean_key_in_native_datatype_element2299_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_boolean_key_in_native_datatype_element2299( FOLLOW_boolean_key_in_native_datatype_element2299_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_date_key_in_native_datatype_element2310_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_date_key_in_native_datatype_element2310( FOLLOW_date_key_in_native_datatype_element2310_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_rowid_key_in_native_datatype_element2321_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_rowid_key_in_native_datatype_element2321( FOLLOW_rowid_key_in_native_datatype_element2321_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_urowid_key_in_native_datatype_element2332_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_urowid_key_in_native_datatype_element2332( FOLLOW_urowid_key_in_native_datatype_element2332_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_year_key_in_native_datatype_element2343_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_year_key_in_native_datatype_element2343( FOLLOW_year_key_in_native_datatype_element2343_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_month_key_in_native_datatype_element2354_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_month_key_in_native_datatype_element2354( FOLLOW_month_key_in_native_datatype_element2354_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_day_key_in_native_datatype_element2365_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_day_key_in_native_datatype_element2365( FOLLOW_day_key_in_native_datatype_element2365_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_hour_key_in_native_datatype_element2376_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_hour_key_in_native_datatype_element2376( FOLLOW_hour_key_in_native_datatype_element2376_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_minute_key_in_native_datatype_element2387_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_minute_key_in_native_datatype_element2387( FOLLOW_minute_key_in_native_datatype_element2387_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_second_key_in_native_datatype_element2398_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_second_key_in_native_datatype_element2398( FOLLOW_second_key_in_native_datatype_element2398_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_timezone_hour_key_in_native_datatype_element2409_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_timezone_hour_key_in_native_datatype_element2409( FOLLOW_timezone_hour_key_in_native_datatype_element2409_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_timezone_minute_key_in_native_datatype_element2420_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_timezone_minute_key_in_native_datatype_element2420( FOLLOW_timezone_minute_key_in_native_datatype_element2420_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_timezone_region_key_in_native_datatype_element2431_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_timezone_region_key_in_native_datatype_element2431( FOLLOW_timezone_region_key_in_native_datatype_element2431_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_timezone_abbr_key_in_native_datatype_element2442_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_timezone_abbr_key_in_native_datatype_element2442( FOLLOW_timezone_abbr_key_in_native_datatype_element2442_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_timestamp_key_in_native_datatype_element2453_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_timestamp_key_in_native_datatype_element2453( FOLLOW_timestamp_key_in_native_datatype_element2453_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_timestamp_unconstrained_key_in_native_datatype_element2464_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_timestamp_unconstrained_key_in_native_datatype_element2464( FOLLOW_timestamp_unconstrained_key_in_native_datatype_element2464_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_timestamp_tz_unconstrained_key_in_native_datatype_element2475_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_timestamp_tz_unconstrained_key_in_native_datatype_element2475( FOLLOW_timestamp_tz_unconstrained_key_in_native_datatype_element2475_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_timestamp_ltz_unconstrained_key_in_native_datatype_element2486_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_timestamp_ltz_unconstrained_key_in_native_datatype_element2486( FOLLOW_timestamp_ltz_unconstrained_key_in_native_datatype_element2486_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_yminterval_unconstrained_key_in_native_datatype_element2497_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_yminterval_unconstrained_key_in_native_datatype_element2497( FOLLOW_yminterval_unconstrained_key_in_native_datatype_element2497_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_dsinterval_unconstrained_key_in_native_datatype_element2508_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_dsinterval_unconstrained_key_in_native_datatype_element2508( FOLLOW_dsinterval_unconstrained_key_in_native_datatype_element2508_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bfile_key_in_native_datatype_element2519_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bfile_key_in_native_datatype_element2519( FOLLOW_bfile_key_in_native_datatype_element2519_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_blob_key_in_native_datatype_element2530_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_blob_key_in_native_datatype_element2530( FOLLOW_blob_key_in_native_datatype_element2530_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_clob_key_in_native_datatype_element2541_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_clob_key_in_native_datatype_element2541( FOLLOW_clob_key_in_native_datatype_element2541_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_nclob_key_in_native_datatype_element2552_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_nclob_key_in_native_datatype_element2552( FOLLOW_nclob_key_in_native_datatype_element2552_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_mlslabel_key_in_native_datatype_element2563_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_mlslabel_key_in_native_datatype_element2563( FOLLOW_mlslabel_key_in_native_datatype_element2563_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_BINDVAR_in_bind_variable2585_bits[]	= { ANTLR_UINT64_LIT(0x0000004000004202), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_BINDVAR_in_bind_variable2585( FOLLOW_BINDVAR_in_bind_variable2585_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COLON_in_bind_variable2589_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COLON_in_bind_variable2589( FOLLOW_COLON_in_bind_variable2589_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_bind_variable2591_bits[]	= { ANTLR_UINT64_LIT(0x0000004000004202), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_bind_variable2591( FOLLOW_UNSIGNED_INTEGER_in_bind_variable2591_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_indicator_key_in_bind_variable2605_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004200) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_indicator_key_in_bind_variable2605( FOLLOW_indicator_key_in_bind_variable2605_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_BINDVAR_in_bind_variable2609_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_BINDVAR_in_bind_variable2609( FOLLOW_BINDVAR_in_bind_variable2609_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COLON_in_bind_variable2613_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COLON_in_bind_variable2613( FOLLOW_COLON_in_bind_variable2613_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_bind_variable2615_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_bind_variable2615( FOLLOW_UNSIGNED_INTEGER_in_bind_variable2615_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_bind_variable2637_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_bind_variable2637( FOLLOW_PERIOD_in_bind_variable2637_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_bind_variable2639_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_general_element_part_in_bind_variable2639( FOLLOW_general_element_part_in_bind_variable2639_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_general_element2661_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_general_element_part_in_general_element2661( FOLLOW_general_element_part_in_general_element2661_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_general_element2671_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_general_element2671( FOLLOW_PERIOD_in_general_element2671_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_general_element2673_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_general_element_part_in_general_element2673( FOLLOW_general_element_part_in_general_element2673_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_INTRODUCER_in_general_element_part2696_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_INTRODUCER_in_general_element_part2696( FOLLOW_INTRODUCER_in_general_element_part2696_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_char_set_name_in_general_element_part2698_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_char_set_name_in_general_element_part2698( FOLLOW_char_set_name_in_general_element_part2698_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_general_element_part2702_bits[]	= { ANTLR_UINT64_LIT(0x0000004040000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_general_element_part2702( FOLLOW_id_expression_in_general_element_part2702_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_general_element_part2724_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_general_element_part2724( FOLLOW_PERIOD_in_general_element_part2724_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_general_element_part2726_bits[]	= { ANTLR_UINT64_LIT(0x0000004040000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_general_element_part2726( FOLLOW_id_expression_in_general_element_part2726_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_function_argument_in_general_element_part2730_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_function_argument_in_general_element_part2730( FOLLOW_function_argument_in_general_element_part2730_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_INTRODUCER_in_table_element2752_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_INTRODUCER_in_table_element2752( FOLLOW_INTRODUCER_in_table_element2752_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_char_set_name_in_table_element2754_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_char_set_name_in_table_element2754( FOLLOW_char_set_name_in_table_element2754_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_table_element2758_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_table_element2758( FOLLOW_id_expression_in_table_element2758_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_table_element2761_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_table_element2761( FOLLOW_PERIOD_in_table_element2761_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_table_element2763_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_table_element2763( FOLLOW_id_expression_in_table_element2763_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_timestamp_key_in_constant2789_bits[]	= { ANTLR_UINT64_LIT(0x0000000400007200) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_timestamp_key_in_constant2789( FOLLOW_timestamp_key_in_constant2789_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_constant2792_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_constant2792( FOLLOW_quoted_string_in_constant2792_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_constant2796_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_constant2796( FOLLOW_bind_variable_in_constant2796_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_at_key_in_constant2800_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_at_key_in_constant2800( FOLLOW_at_key_in_constant2800_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_time_key_in_constant2802_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_time_key_in_constant2802( FOLLOW_time_key_in_constant2802_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_zone_key_in_constant2804_bits[]	= { ANTLR_UINT64_LIT(0x0000000400003000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_zone_key_in_constant2804( FOLLOW_zone_key_in_constant2804_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_constant2806_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_constant2806( FOLLOW_quoted_string_in_constant2806_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_interval_key_in_constant2819_bits[]	= { ANTLR_UINT64_LIT(0x0000000410047200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_interval_key_in_constant2819( FOLLOW_interval_key_in_constant2819_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_constant2822_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_constant2822( FOLLOW_quoted_string_in_constant2822_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_constant2826_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_constant2826( FOLLOW_bind_variable_in_constant2826_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_constant2830_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_general_element_part_in_constant2830( FOLLOW_general_element_part_in_constant2830_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_day_key_in_constant2844_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_day_key_in_constant2844( FOLLOW_day_key_in_constant2844_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_hour_key_in_constant2848_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_hour_key_in_constant2848( FOLLOW_hour_key_in_constant2848_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_minute_key_in_constant2852_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_minute_key_in_constant2852( FOLLOW_minute_key_in_constant2852_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_second_key_in_constant2856_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_second_key_in_constant2856( FOLLOW_second_key_in_constant2856_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_constant2870_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004200), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_constant2870( FOLLOW_LEFT_PAREN_in_constant2870_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_constant2873_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_constant2873( FOLLOW_UNSIGNED_INTEGER_in_constant2873_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_constant2877_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_constant2877( FOLLOW_bind_variable_in_constant2877_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_constant2881_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004200), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_COMMA_in_constant2881( FOLLOW_COMMA_in_constant2881_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_constant2884_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_constant2884( FOLLOW_UNSIGNED_INTEGER_in_constant2884_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_constant2888_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_constant2888( FOLLOW_bind_variable_in_constant2888_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_constant2894_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_constant2894( FOLLOW_RIGHT_PAREN_in_constant2894_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_to_key_in_constant2909_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_to_key_in_constant2909( FOLLOW_to_key_in_constant2909_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_day_key_in_constant2926_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_day_key_in_constant2926( FOLLOW_day_key_in_constant2926_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_hour_key_in_constant2930_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_hour_key_in_constant2930( FOLLOW_hour_key_in_constant2930_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_minute_key_in_constant2934_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_minute_key_in_constant2934( FOLLOW_minute_key_in_constant2934_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_second_key_in_constant2938_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_second_key_in_constant2938( FOLLOW_second_key_in_constant2938_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_constant2941_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004200), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_constant2941( FOLLOW_LEFT_PAREN_in_constant2941_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_constant2944_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_constant2944( FOLLOW_UNSIGNED_INTEGER_in_constant2944_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_constant2948_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_bind_variable_in_constant2948( FOLLOW_bind_variable_in_constant2948_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_constant2951_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_constant2951( FOLLOW_RIGHT_PAREN_in_constant2951_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_numeric_in_constant2978_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_numeric_in_constant2978( FOLLOW_numeric_in_constant2978_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_date_key_in_constant2989_bits[]	= { ANTLR_UINT64_LIT(0x0000000400003000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_date_key_in_constant2989( FOLLOW_date_key_in_constant2989_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_constant2991_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_constant2991( FOLLOW_quoted_string_in_constant2991_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_constant3002_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_quoted_string_in_constant3002( FOLLOW_quoted_string_in_constant3002_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_null_key_in_constant3013_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_null_key_in_constant3013( FOLLOW_null_key_in_constant3013_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_true_key_in_constant3024_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_true_key_in_constant3024( FOLLOW_true_key_in_constant3024_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_false_key_in_constant3035_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_false_key_in_constant3035( FOLLOW_false_key_in_constant3035_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_dbtimezone_key_in_constant3046_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_dbtimezone_key_in_constant3046( FOLLOW_dbtimezone_key_in_constant3046_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_sessiontimezone_key_in_constant3058_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_sessiontimezone_key_in_constant3058( FOLLOW_sessiontimezone_key_in_constant3058_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_minvalue_key_in_constant3069_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_minvalue_key_in_constant3069( FOLLOW_minvalue_key_in_constant3069_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_maxvalue_key_in_constant3080_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_maxvalue_key_in_constant3080( FOLLOW_maxvalue_key_in_constant3080_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_default_key_in_constant3091_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_default_key_in_constant3091( FOLLOW_default_key_in_constant3091_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_INTRODUCER_in_id3191_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_INTRODUCER_in_id3191( FOLLOW_INTRODUCER_in_id3191_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_char_set_name_in_id3193_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_char_set_name_in_id3193( FOLLOW_char_set_name_in_id3193_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_id3205_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_id3205( FOLLOW_id_expression_in_id3205_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_NOT_EQUAL_OP_in_not_equal_op3256_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_NOT_EQUAL_OP_in_not_equal_op3256( FOLLOW_NOT_EQUAL_OP_in_not_equal_op3256_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LESS_THAN_OP_in_not_equal_op3267_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LESS_THAN_OP_in_not_equal_op3267( FOLLOW_LESS_THAN_OP_in_not_equal_op3267_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OP_in_not_equal_op3269_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_GREATER_THAN_OP_in_not_equal_op3269( FOLLOW_GREATER_THAN_OP_in_not_equal_op3269_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_EXCLAMATION_OPERATOR_PART_in_not_equal_op3280_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_EXCLAMATION_OPERATOR_PART_in_not_equal_op3280( FOLLOW_EXCLAMATION_OPERATOR_PART_in_not_equal_op3280_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_not_equal_op3282_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_not_equal_op3282( FOLLOW_EQUALS_OP_in_not_equal_op3282_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_CARRET_OPERATOR_PART_in_not_equal_op3293_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_CARRET_OPERATOR_PART_in_not_equal_op3293( FOLLOW_CARRET_OPERATOR_PART_in_not_equal_op3293_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_not_equal_op3295_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_not_equal_op3295( FOLLOW_EQUALS_OP_in_not_equal_op3295_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OR_EQUALS_OP_in_greater_than_or_equals_op3315_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_GREATER_THAN_OR_EQUALS_OP_in_greater_than_or_equals_op3315( FOLLOW_GREATER_THAN_OR_EQUALS_OP_in_greater_than_or_equals_op3315_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OP_in_greater_than_or_equals_op3326_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_GREATER_THAN_OP_in_greater_than_or_equals_op3326( FOLLOW_GREATER_THAN_OP_in_greater_than_or_equals_op3326_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_greater_than_or_equals_op3328_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_greater_than_or_equals_op3328( FOLLOW_EQUALS_OP_in_greater_than_or_equals_op3328_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LESS_THAN_OR_EQUALS_OP_in_less_than_or_equals_op3348_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LESS_THAN_OR_EQUALS_OP_in_less_than_or_equals_op3348( FOLLOW_LESS_THAN_OR_EQUALS_OP_in_less_than_or_equals_op3348_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LESS_THAN_OP_in_less_than_or_equals_op3359_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LESS_THAN_OP_in_less_than_or_equals_op3359( FOLLOW_LESS_THAN_OP_in_less_than_or_equals_op3359_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_less_than_or_equals_op3361_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_less_than_or_equals_op3361( FOLLOW_EQUALS_OP_in_less_than_or_equals_op3361_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_CONCATENATION_OP_in_concatenation_op3381_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_CONCATENATION_OP_in_concatenation_op3381( FOLLOW_CONCATENATION_OP_in_concatenation_op3381_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_VERTICAL_BAR_in_concatenation_op3392_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000001000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_VERTICAL_BAR_in_concatenation_op3392( FOLLOW_VERTICAL_BAR_in_concatenation_op3392_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_VERTICAL_BAR_in_concatenation_op3394_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_VERTICAL_BAR_in_concatenation_op3394( FOLLOW_VERTICAL_BAR_in_concatenation_op3394_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_multiset_key_in_multiset_op3415_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0040000000000400), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_multiset_key_in_multiset_op3415( FOLLOW_multiset_key_in_multiset_op3415_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_except_key_in_multiset_op3428_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000004000040000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_except_key_in_multiset_op3428( FOLLOW_except_key_in_multiset_op3428_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_intersect_key_in_multiset_op3432_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000004000040000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_intersect_key_in_multiset_op3432( FOLLOW_intersect_key_in_multiset_op3432_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_union_key_in_multiset_op3436_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000004000040000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_union_key_in_multiset_op3436( FOLLOW_union_key_in_multiset_op3436_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_all_key_in_multiset_op3451_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_all_key_in_multiset_op3451( FOLLOW_all_key_in_multiset_op3451_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_distinct_key_in_multiset_op3455_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_distinct_key_in_multiset_op3455( FOLLOW_distinct_key_in_multiset_op3455_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_outer_join_sign3478_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_outer_join_sign3478( FOLLOW_LEFT_PAREN_in_outer_join_sign3478_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PLUS_SIGN_in_outer_join_sign3480_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PLUS_SIGN_in_outer_join_sign3480( FOLLOW_PLUS_SIGN_in_outer_join_sign3480_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_outer_join_sign3482_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_outer_join_sign3482( FOLLOW_RIGHT_PAREN_in_outer_join_sign3482_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_as_key_in_synpred1_PLSQLCommons86_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_as_key_in_synpred1_PLSQLCommons86( FOLLOW_as_key_in_synpred1_PLSQLCommons86_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_synpred1_PLSQLCommons91_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_synpred1_PLSQLCommons91( FOLLOW_id_in_synpred1_PLSQLCommons91_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_alias_quoted_string_in_synpred1_PLSQLCommons95_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_alias_quoted_string_in_synpred1_PLSQLCommons95( FOLLOW_alias_quoted_string_in_synpred1_PLSQLCommons95_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred2_PLSQLCommons441_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred2_PLSQLCommons441( FOLLOW_PERIOD_in_synpred2_PLSQLCommons441_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred2_PLSQLCommons443_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred2_PLSQLCommons443( FOLLOW_id_expression_in_synpred2_PLSQLCommons443_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred3_PLSQLCommons502_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred3_PLSQLCommons502( FOLLOW_PERIOD_in_synpred3_PLSQLCommons502_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred3_PLSQLCommons504_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred3_PLSQLCommons504( FOLLOW_id_expression_in_synpred3_PLSQLCommons504_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred4_PLSQLCommons596_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred4_PLSQLCommons596( FOLLOW_PERIOD_in_synpred4_PLSQLCommons596_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred4_PLSQLCommons598_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred4_PLSQLCommons598( FOLLOW_id_expression_in_synpred4_PLSQLCommons598_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred5_PLSQLCommons650_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred5_PLSQLCommons650( FOLLOW_PERIOD_in_synpred5_PLSQLCommons650_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred5_PLSQLCommons652_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred5_PLSQLCommons652( FOLLOW_id_expression_in_synpred5_PLSQLCommons652_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred6_PLSQLCommons711_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred6_PLSQLCommons711( FOLLOW_PERIOD_in_synpred6_PLSQLCommons711_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred6_PLSQLCommons713_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred6_PLSQLCommons713( FOLLOW_id_expression_in_synpred6_PLSQLCommons713_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred7_PLSQLCommons745_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred7_PLSQLCommons745( FOLLOW_PERIOD_in_synpred7_PLSQLCommons745_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred7_PLSQLCommons747_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred7_PLSQLCommons747( FOLLOW_id_expression_in_synpred7_PLSQLCommons747_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred8_PLSQLCommons779_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred8_PLSQLCommons779( FOLLOW_PERIOD_in_synpred8_PLSQLCommons779_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred8_PLSQLCommons781_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred8_PLSQLCommons781( FOLLOW_id_expression_in_synpred8_PLSQLCommons781_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred9_PLSQLCommons814_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred9_PLSQLCommons814( FOLLOW_PERIOD_in_synpred9_PLSQLCommons814_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred9_PLSQLCommons816_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred9_PLSQLCommons816( FOLLOW_id_expression_in_synpred9_PLSQLCommons816_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred10_PLSQLCommons848_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred10_PLSQLCommons848( FOLLOW_PERIOD_in_synpred10_PLSQLCommons848_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred10_PLSQLCommons850_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred10_PLSQLCommons850( FOLLOW_id_expression_in_synpred10_PLSQLCommons850_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred11_PLSQLCommons882_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred11_PLSQLCommons882( FOLLOW_PERIOD_in_synpred11_PLSQLCommons882_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred11_PLSQLCommons884_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred11_PLSQLCommons884( FOLLOW_id_expression_in_synpred11_PLSQLCommons884_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred12_PLSQLCommons935_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred12_PLSQLCommons935( FOLLOW_PERIOD_in_synpred12_PLSQLCommons935_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred12_PLSQLCommons937_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred12_PLSQLCommons937( FOLLOW_id_expression_in_synpred12_PLSQLCommons937_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred13_PLSQLCommons1062_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred13_PLSQLCommons1062( FOLLOW_PERIOD_in_synpred13_PLSQLCommons1062_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred13_PLSQLCommons1064_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred13_PLSQLCommons1064( FOLLOW_id_expression_in_synpred13_PLSQLCommons1064_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred14_PLSQLCommons1116_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred14_PLSQLCommons1116( FOLLOW_PERIOD_in_synpred14_PLSQLCommons1116_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred14_PLSQLCommons1118_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred14_PLSQLCommons1118( FOLLOW_id_expression_in_synpred14_PLSQLCommons1118_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred15_PLSQLCommons1150_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred15_PLSQLCommons1150( FOLLOW_PERIOD_in_synpred15_PLSQLCommons1150_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred15_PLSQLCommons1152_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred15_PLSQLCommons1152( FOLLOW_id_expression_in_synpred15_PLSQLCommons1152_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred16_PLSQLCommons1219_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred16_PLSQLCommons1219( FOLLOW_PERIOD_in_synpred16_PLSQLCommons1219_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred16_PLSQLCommons1221_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred16_PLSQLCommons1221( FOLLOW_id_expression_in_synpred16_PLSQLCommons1221_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_synpred17_PLSQLCommons1556_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_tableview_name_in_synpred17_PLSQLCommons1556( FOLLOW_tableview_name_in_synpred17_PLSQLCommons1556_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred17_PLSQLCommons1558_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred17_PLSQLCommons1558( FOLLOW_PERIOD_in_synpred17_PLSQLCommons1558_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_synpred17_PLSQLCommons1560_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_ASTERISK_in_synpred17_PLSQLCommons1560( FOLLOW_ASTERISK_in_synpred17_PLSQLCommons1560_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_in_synpred18_PLSQLCommons1712_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_in_synpred18_PLSQLCommons1712( FOLLOW_id_in_synpred18_PLSQLCommons1712_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_synpred18_PLSQLCommons1714_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_synpred18_PLSQLCommons1714( FOLLOW_EQUALS_OP_in_synpred18_PLSQLCommons1714_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OP_in_synpred18_PLSQLCommons1716_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_GREATER_THAN_OP_in_synpred18_PLSQLCommons1716( FOLLOW_GREATER_THAN_OP_in_synpred18_PLSQLCommons1716_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred19_PLSQLCommons2631_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred19_PLSQLCommons2631( FOLLOW_PERIOD_in_synpred19_PLSQLCommons2631_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_synpred19_PLSQLCommons2633_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_general_element_part_in_synpred19_PLSQLCommons2633( FOLLOW_general_element_part_in_synpred19_PLSQLCommons2633_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred20_PLSQLCommons2665_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred20_PLSQLCommons2665( FOLLOW_PERIOD_in_synpred20_PLSQLCommons2665_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_synpred20_PLSQLCommons2667_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_general_element_part_in_synpred20_PLSQLCommons2667( FOLLOW_general_element_part_in_synpred20_PLSQLCommons2667_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred21_PLSQLCommons2718_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred21_PLSQLCommons2718( FOLLOW_PERIOD_in_synpred21_PLSQLCommons2718_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLCommons  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_synpred21_PLSQLCommons2720_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLCommonsImplTraits::BitsetListType FOLLOW_id_expression_in_synpred21_PLSQLCommons2720( FOLLOW_id_expression_in_synpred21_PLSQLCommons2720_bits, 1 );



/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    253:10: ( ( id EQUALS_OP GREATER_THAN_OP )=> id EQUALS_OP GREATER_THAN_OP )?
 */
static const ANTLR_INT32 dfa54_eot[24] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa54_eof[24] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa54_min[24] =
    {
	5, 18, 5, -1, 7, 18, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	5, 18, 7, -1, 18
    };
static const ANTLR_INT32 dfa54_max[24] =
    {
	151, 74, 152, -1, 152, 74, 151, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 151, 74, 152, -1, 74
    };
static const ANTLR_INT32 dfa54_accept[24] =
    {
	-1, -1, -1, 2, -1, -1, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, -1, -1, 
	-1, 1, -1
    };
static const ANTLR_INT32 dfa54_special[24] =
    {
	-1, -1, 2, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa54_T_empty	 =   NULL;

static const ANTLR_INT32 dfa54_T0[] =
    {
	18, -1, -1, -1, 18, -1, -1, -1, 18, -1, 18, -1, -1, -1, 19, -1, 18, -1, 
	18, 18, -1, -1, 18, 18, 18, 18, 18, -1, -1, 18, -1, 18, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, 18, -1, -1, 
	-1, 18, -1, -1, -1, 18, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 18, -1, -1, -1, 18, 18, 18, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 18
    };

static const ANTLR_INT32 dfa54_T1[] =
    {
	18, -1, -1, -1, 18, -1, -1, 18, 18, 18, -1, -1, -1, 18, -1, -1, -1, 18, 
	-1, -1, 22, -1, -1, 18, -1, 18, -1, -1, 18, 18, -1, -1, -1, -1, 18, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, -1, 
	-1, -1, -1, -1, -1, 18, -1, -1, 18, -1, -1, -1, -1, -1, 18, -1, -1, -1, 
	-1, -1, 18, -1, 18, -1, -1, 18, -1, -1, -1, -1, 18, 18, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, 18, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 18
    };

static const ANTLR_INT32 dfa54_T2[] =
    {
	23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 23
    };

static const ANTLR_INT32 dfa54_T3[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 5
    };

static const ANTLR_INT32 dfa54_T4[] =
    {
	21, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 21
    };

static const ANTLR_INT32 dfa54_T5[] =
    {
	3, -1, -1, -1, 3, -1, -1, 3, 3, 3, -1, -1, -1, 4, -1, -1, -1, 3, -1, -1, 
	-1, -1, -1, 1, -1, 3, -1, -1, 3, 3, -1, -1, -1, -1, 3, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, 
	-1, 3, -1, -1, 3, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, 3, 3, -1, 3, -1, 
	-1, 3, -1, -1, -1, -1, 3, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 3, 3, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3
    };

static const ANTLR_INT32 dfa54_T6[] =
    {
	15, -1, 18, -1, 14, -1, 18, 16, 16, 14, 18, -1, 18, 10, -1, -1, 6, 15, 
	18, -1, 18, 18, -1, 13, 18, 18, 18, 18, 3, 16, -1, 18, -1, 18, 7, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, 18, -1, -1, 
	-1, 18, -1, 9, -1, 18, 12, -1, -1, -1, 18, -1, 11, -1, -1, -1, -1, -1, 
	15, -1, 17, -1, -1, 9, -1, -1, -1, -1, 12, 17, -1, -1, -1, -1, -1, -1, 
	-1, 18, -1, -1, -1, 18, 18, 18, 17, -1, -1, -1, 18, -1, -1, 7, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	15, 18
    };

static const ANTLR_INT32 dfa54_T7[] =
    {
	18, -1, -1, -1, 18, -1, -1, -1, 18, -1, 18, -1, -1, -1, 19, -1, 18, -1, 
	18, 18, -1, -1, 18, 18, 18, 18, 18, -1, -1, 18, -1, 18, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, 18, -1, -1, 
	-1, 18, -1, -1, -1, 18, -1, -1, -1, -1, 18, -1, 18, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 18, -1, -1, -1, 18, 18, 18, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 18
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa54_transitions[] =
{
    dfa54_T5, dfa54_T3, dfa54_T6, NULL, dfa54_T7, dfa54_T4, dfa54_T1, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, dfa54_T1, 
    dfa54_T2, dfa54_T0, NULL, dfa54_T4
};


/* Declare tracking structure for Cyclic DFA 54
 */
class PLSQLParser_PLSQLCommonsCyclicDFA54 : public CyclicDFA< PLSQLParser_PLSQLCommonsImplTraits, PLSQLParser_PLSQLCommons >, public PLSQLParser_PLSQLCommonsTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQLCommonsImplTraits, PLSQLParser_PLSQLCommons >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParser_PLSQLCommonsCyclicDFA54( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA54_6;

	    		    ANTLR_MARKER index54_6;


	    		    LA54_6 = ctx->LA(1);

	    		     
	    		        index54_6 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (this->msynpred( antlr3::ClassForwarder<synpred18_PLSQLCommons>() )) && (LA54_6 == GREATER_THAN_OP) )
	    		    {
	    		        s = 22;
	    		    }

	    		    else if ( (LA54_6 == APPROXIMATE_NUM_LIT || LA54_6 == BINDVAR || ((LA54_6 >= CHAR_STRING) && (LA54_6 <= COLON)) || LA54_6 == DELIMITED_ID || LA54_6 == EXACT_NUM_LIT || LA54_6 == INTRODUCER || LA54_6 == LEFT_PAREN || ((LA54_6 >= MINUS_SIGN) && (LA54_6 <= NATIONAL_CHAR_STRING_LIT)) || LA54_6 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA54_6 == PLUS_SIGN || LA54_6 == REGULAR_ID || LA54_6 == SQL92_RESERVED_ALL || LA54_6 == SQL92_RESERVED_ANY || LA54_6 == SQL92_RESERVED_CASE || LA54_6 == SQL92_RESERVED_DATE || LA54_6 == SQL92_RESERVED_DEFAULT || LA54_6 == SQL92_RESERVED_DISTINCT || ((LA54_6 >= SQL92_RESERVED_EXISTS) && (LA54_6 <= SQL92_RESERVED_FALSE)) || LA54_6 == SQL92_RESERVED_NULL || LA54_6 == SQL92_RESERVED_PRIOR || LA54_6 == SQL92_RESERVED_TRUE || LA54_6 == UNSIGNED_INTEGER) )
	    		    {
	    		        s = 18;
	    		    }

	    			 
	    				ctx->seek(index54_6);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA54_19;

	    		    ANTLR_MARKER index54_19;


	    		    LA54_19 = ctx->LA(1);

	    		     
	    		        index54_19 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (this->msynpred( antlr3::ClassForwarder<synpred18_PLSQLCommons>() )) && (LA54_19 == GREATER_THAN_OP) )
	    		    {
	    		        s = 22;
	    		    }

	    		    else if ( (LA54_19 == APPROXIMATE_NUM_LIT || LA54_19 == BINDVAR || ((LA54_19 >= CHAR_STRING) && (LA54_19 <= COLON)) || LA54_19 == DELIMITED_ID || LA54_19 == EXACT_NUM_LIT || LA54_19 == INTRODUCER || LA54_19 == LEFT_PAREN || ((LA54_19 >= MINUS_SIGN) && (LA54_19 <= NATIONAL_CHAR_STRING_LIT)) || LA54_19 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA54_19 == PLUS_SIGN || LA54_19 == REGULAR_ID || LA54_19 == SQL92_RESERVED_ALL || LA54_19 == SQL92_RESERVED_ANY || LA54_19 == SQL92_RESERVED_CASE || LA54_19 == SQL92_RESERVED_DATE || LA54_19 == SQL92_RESERVED_DEFAULT || LA54_19 == SQL92_RESERVED_DISTINCT || ((LA54_19 >= SQL92_RESERVED_EXISTS) && (LA54_19 <= SQL92_RESERVED_FALSE)) || LA54_19 == SQL92_RESERVED_NULL || LA54_19 == SQL92_RESERVED_PRIOR || LA54_19 == SQL92_RESERVED_TRUE || LA54_19 == UNSIGNED_INTEGER) )
	    		    {
	    		        s = 18;
	    		    }

	    			 
	    				ctx->seek(index54_19);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA54_2;

	    		    ANTLR_MARKER index54_2;


	    		    LA54_2 = ctx->LA(1);

	    		     
	    		        index54_2 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA54_2 == EQUALS_OP) )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA54_2 == MINUS_SIGN || LA54_2 == PLUS_SIGN) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
	    		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
	    		             )) )) && (LA54_2 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA54_2 == SQL92_RESERVED_PRIOR) )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( (LA54_2 == REGULAR_ID) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
	    		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
	    		             )) )) && (LA54_2 == SQL92_RESERVED_ALL || LA54_2 == SQL92_RESERVED_DISTINCT) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||(( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
	    		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
	    		             )) )))) && (LA54_2 == DELIMITED_ID) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA54_2 == SQL92_RESERVED_CASE) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
	    		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
	    		             )) )) && (LA54_2 == SQL92_RESERVED_ANY || LA54_2 == SQL92_RESERVED_EXISTS) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||(( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
	    		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
	    		             )) )))) && (LA54_2 == INTRODUCER) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( (LA54_2 == BINDVAR || LA54_2 == COLON) )
	    		    {
	    		        s = 14;
	    		    }

	    		    else if ( (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
	    		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
	    		             )) )) && (LA54_2 == APPROXIMATE_NUM_LIT || LA54_2 == EXACT_NUM_LIT || LA54_2 == SQL92_RESERVED_DATE || LA54_2 == UNSIGNED_INTEGER) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (((LA54_2 >= CHAR_STRING) && (LA54_2 <= CHAR_STRING_PERL)) || LA54_2 == NATIONAL_CHAR_STRING_LIT) )
	    		    {
	    		        s = 16;
	    		    }

	    		    else if ( (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
	    		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
	    		             )) )) && (LA54_2 == SQL92_RESERVED_DEFAULT || LA54_2 == SQL92_RESERVED_FALSE || LA54_2 == SQL92_RESERVED_NULL || LA54_2 == SQL92_RESERVED_TRUE) )
	    		    {
	    		        s = 17;
	    		    }

	    		    else if ( (LA54_2 == ASTERISK || LA54_2 == CARRET_OPERATOR_PART || LA54_2 == COMMA || LA54_2 == CONCATENATION_OP || LA54_2 == EXCLAMATION_OPERATOR_PART || ((LA54_2 >= GREATER_THAN_OP) && (LA54_2 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA54_2 >= LEFT_BRACKET) && (LA54_2 <= LESS_THAN_OR_EQUALS_OP)) || LA54_2 == NOT_EQUAL_OP || LA54_2 == PERIOD || LA54_2 == RIGHT_PAREN || LA54_2 == SOLIDUS || LA54_2 == SQL92_RESERVED_AND || LA54_2 == SQL92_RESERVED_BETWEEN || LA54_2 == SQL92_RESERVED_IN || ((LA54_2 >= SQL92_RESERVED_IS) && (LA54_2 <= SQL92_RESERVED_NOT)) || LA54_2 == SQL92_RESERVED_OR || LA54_2 == VERTICAL_BAR) )
	    		    {
	    		        s = 18;
	    		    }

	    			 
	    				ctx->seek(index54_2);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "253:10: ( ( id EQUALS_OP GREATER_THAN_OP )=> id EQUALS_OP GREATER_THAN_OP )?" );
	    ex->set_decisionNum( 54 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParser_PLSQLCommonsCyclicDFA54  cdfa54(
	    54,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"253:10: ( ( id EQUALS_OP GREATER_THAN_OP )=> id EQUALS_OP GREATER_THAN_OP )?",
	    dfa54_eot,	    /* EOT table			    */
	    dfa54_eof,	    /* EOF table			    */
	    dfa54_min,	    /* Minimum tokens for each state    */
	    dfa54_max,	    /* Maximum tokens for each state    */
	    dfa54_accept,	/* Accept table			    */
	    dfa54_special,	/* Special transition states	    */
	    dfa54_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 54
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */

/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start partition_extension_clause
 * PLSQLCommons.g:32:1: partition_extension_clause : ( subpartition_key | partition_key ) ( for_key )? expression_list ;
 */
void
PLSQLParser_PLSQLCommons::partition_extension_clause()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:33:5: ( ( subpartition_key | partition_key ) ( for_key )? expression_list )
        // PLSQLCommons.g:33:10: ( subpartition_key | partition_key ) ( for_key )? expression_list
        {
            // PLSQLCommons.g:33:10: ( subpartition_key | partition_key )
            {
                int alt1=2;
                {
                    int LA1_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "PARTITION")))||((equalsIgnoreCase(LT(1)->getText(), "SUBPARTITION"))))) && (LA1_0 == REGULAR_ID))
                    {
                        {
                            int LA1_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "SUBPARTITION"))))
                            {
                                alt1=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "PARTITION"))))
                            {
                                alt1=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 1 );
                                ex->set_state( 1 );


                                goto rulepartition_extension_clauseEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 1 );
                        ex->set_state( 0 );


                        goto rulepartition_extension_clauseEx;

                    }
                }
                switch (alt1)
                {
            	case 1:
            	    // PLSQLCommons.g:33:12: subpartition_key
            	    {
            	        this->followPush(FOLLOW_subpartition_key_in_partition_extension_clause37);
            	        m_gPLSQLParser->subpartition_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepartition_extension_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:33:31: partition_key
            	    {
            	        this->followPush(FOLLOW_partition_key_in_partition_extension_clause41);
            	        m_gPLSQLParser->partition_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepartition_extension_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLCommons.g:34:9: ( for_key )?
            {
                int alt2=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_FOR:
                    	{
                    		alt2=1;
                    	}
                        break;
                }

                switch (alt2)
                {
            	case 1:
            	    // PLSQLCommons.g:34:9: for_key
            	    {
            	        this->followPush(FOLLOW_for_key_in_partition_extension_clause54);
            	        m_gPLSQLParser->for_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepartition_extension_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_expression_list_in_partition_extension_clause57);
            m_gPLSQLParser->expression_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepartition_extension_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepartition_extension_clauseEx; /* Prevent compiler warnings */
    rulepartition_extension_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end partition_extension_clause */

/**
 * $ANTLR start column_alias
 * PLSQLCommons.g:37:1: column_alias options {backtrack=true; } : ( ( as_key )? ( id | alias_quoted_string ) | as_key );
 */
void
PLSQLParser_PLSQLCommons::column_alias()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:42:5: ( ( as_key )? ( id | alias_quoted_string ) | as_key )

            ANTLR_UINT32 alt5;

            alt5=2;

            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_AS:
            	{
            		{
            		    int LA5_1 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred1_PLSQLCommons>() )))
            		    {
            		        alt5=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt5=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 5 );
            		        ex->set_state( 1 );


            		        goto rulecolumn_aliasEx;

            		    }
            		}
            	}
                break;
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case DELIMITED_ID:
            case INTRODUCER:
            case NATIONAL_CHAR_STRING_LIT:
            case REGULAR_ID:
            	{
            		alt5=1;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 5 );
                ex->set_state( 0 );


                goto rulecolumn_aliasEx;

            }

            switch (alt5)
            {
        	case 1:
        	    // PLSQLCommons.g:42:10: ( as_key )? ( id | alias_quoted_string )
        	    {
        	        // PLSQLCommons.g:42:10: ( as_key )?
        	        {
        	            int alt3=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_AS:
        	                	{
        	                		alt3=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt3)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:42:10: as_key
        	        	    {
        	        	        this->followPush(FOLLOW_as_key_in_column_alias86);
        	        	        m_gPLSQLParser->as_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecolumn_aliasEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLCommons.g:42:18: ( id | alias_quoted_string )
        	        {
        	            int alt4=2;
        	            switch ( this->LA(1) )
        	            {
        	            case DELIMITED_ID:
        	            case INTRODUCER:
        	            case REGULAR_ID:
        	            	{
        	            		alt4=1;
        	            	}
        	                break;
        	            case CHAR_STRING:
        	            case CHAR_STRING_PERL:
        	            case NATIONAL_CHAR_STRING_LIT:
        	            	{
        	            		alt4=2;
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return ;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 4 );
        	                ex->set_state( 0 );


        	                goto rulecolumn_aliasEx;

        	            }

        	            switch (alt4)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:42:20: id
        	        	    {
        	        	        this->followPush(FOLLOW_id_in_column_alias91);
        	        	        id();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecolumn_aliasEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQLCommons.g:42:25: alias_quoted_string
        	        	    {
        	        	        this->followPush(FOLLOW_alias_quoted_string_in_column_alias95);
        	        	        alias_quoted_string();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecolumn_aliasEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:43:10: as_key
        	    {
        	        this->followPush(FOLLOW_as_key_in_column_alias108);
        	        m_gPLSQLParser->as_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_aliasEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulecolumn_aliasEx; /* Prevent compiler warnings */
    rulecolumn_aliasEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end column_alias */

/**
 * $ANTLR start table_alias
 * PLSQLCommons.g:46:1: table_alias : ( id | alias_quoted_string ) ;
 */
void
PLSQLParser_PLSQLCommons::table_alias()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:47:5: ( ( id | alias_quoted_string ) )
        // PLSQLCommons.g:47:10: ( id | alias_quoted_string )
        {
            // PLSQLCommons.g:47:10: ( id | alias_quoted_string )
            {
                int alt6=2;
                switch ( this->LA(1) )
                {
                case DELIMITED_ID:
                case INTRODUCER:
                case REGULAR_ID:
                	{
                		alt6=1;
                	}
                    break;
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case NATIONAL_CHAR_STRING_LIT:
                	{
                		alt6=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 6 );
                    ex->set_state( 0 );


                    goto ruletable_aliasEx;

                }

                switch (alt6)
                {
            	case 1:
            	    // PLSQLCommons.g:47:12: id
            	    {
            	        this->followPush(FOLLOW_id_in_table_alias130);
            	        id();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_aliasEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:47:17: alias_quoted_string
            	    {
            	        this->followPush(FOLLOW_alias_quoted_string_in_table_alias134);
            	        alias_quoted_string();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_aliasEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_aliasEx; /* Prevent compiler warnings */
    ruletable_aliasEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_alias */

/**
 * $ANTLR start alias_quoted_string
 * PLSQLCommons.g:50:1: alias_quoted_string : quoted_string ;
 */
void
PLSQLParser_PLSQLCommons::alias_quoted_string()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:51:5: ( quoted_string )
        // PLSQLCommons.g:51:10: quoted_string
        {
            this->followPush(FOLLOW_quoted_string_in_alias_quoted_string156);
            quoted_string();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealias_quoted_stringEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealias_quoted_stringEx; /* Prevent compiler warnings */
    rulealias_quoted_stringEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end alias_quoted_string */

/**
 * $ANTLR start where_clause
 * PLSQLCommons.g:54:1: where_clause : where_key ( current_of_clause | condition_wrapper ) ;
 */
void
PLSQLParser_PLSQLCommons::where_clause()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:55:5: ( where_key ( current_of_clause | condition_wrapper ) )
        // PLSQLCommons.g:55:10: where_key ( current_of_clause | condition_wrapper )
        {
            this->followPush(FOLLOW_where_key_in_where_clause176);
            m_gPLSQLParser->where_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulewhere_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:55:20: ( current_of_clause | condition_wrapper )
            {
                int alt7=2;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_CURRENT:
                	{
                		alt7=1;
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case DELIMITED_ID:
                case EXACT_NUM_LIT:
                case INTRODUCER:
                case LEFT_PAREN:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case REGULAR_ID:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURSOR:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt7=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 7 );
                    ex->set_state( 0 );


                    goto rulewhere_clauseEx;

                }

                switch (alt7)
                {
            	case 1:
            	    // PLSQLCommons.g:55:21: current_of_clause
            	    {
            	        this->followPush(FOLLOW_current_of_clause_in_where_clause179);
            	        current_of_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewhere_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:55:39: condition_wrapper
            	    {
            	        this->followPush(FOLLOW_condition_wrapper_in_where_clause181);
            	        m_gPLSQLParser->condition_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewhere_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulewhere_clauseEx; /* Prevent compiler warnings */
    rulewhere_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end where_clause */

/**
 * $ANTLR start current_of_clause
 * PLSQLCommons.g:58:1: current_of_clause : current_key of_key cursor_name ;
 */
void
PLSQLParser_PLSQLCommons::current_of_clause()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:59:5: ( current_key of_key cursor_name )
        // PLSQLCommons.g:59:10: current_key of_key cursor_name
        {
            this->followPush(FOLLOW_current_key_in_current_of_clause202);
            m_gPLSQLParser->current_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecurrent_of_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_of_key_in_current_of_clause204);
            m_gPLSQLParser->of_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecurrent_of_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_cursor_name_in_current_of_clause206);
            cursor_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecurrent_of_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecurrent_of_clauseEx; /* Prevent compiler warnings */
    rulecurrent_of_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end current_of_clause */

/**
 * $ANTLR start into_clause
 * PLSQLCommons.g:62:1: into_clause : ( into_key variable_name ( COMMA variable_name )* | bulk_key collect_key into_key variable_name ( COMMA variable_name )* );
 */
void
PLSQLParser_PLSQLCommons::into_clause()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:63:5: ( into_key variable_name ( COMMA variable_name )* | bulk_key collect_key into_key variable_name ( COMMA variable_name )* )

            ANTLR_UINT32 alt10;

            alt10=2;

            {
                int LA10_0 = this->LA(1);
                if ( (LA10_0 == SQL92_RESERVED_INTO))
                {
                    alt10=1;
                }
                else if ( ((equalsIgnoreCase(LT(1)->getText(), "BULK"))) && (LA10_0 == REGULAR_ID))
                {
                    alt10=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 10 );
                    ex->set_state( 0 );


                    goto ruleinto_clauseEx;

                }
            }
            switch (alt10)
            {
        	case 1:
        	    // PLSQLCommons.g:63:10: into_key variable_name ( COMMA variable_name )*
        	    {
        	        this->followPush(FOLLOW_into_key_in_into_clause226);
        	        m_gPLSQLParser->into_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinto_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_variable_name_in_into_clause228);
        	        variable_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinto_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:63:33: ( COMMA variable_name )*

        	        for (;;)
        	        {
        	            int alt8=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt8=1;
        	            	}
        	                break;

        	            }

        	            switch (alt8)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:63:34: COMMA variable_name
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_into_clause231);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinto_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_variable_name_in_into_clause233);
        	        	        variable_name();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinto_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop8;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop8: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:64:10: bulk_key collect_key into_key variable_name ( COMMA variable_name )*
        	    {
        	        this->followPush(FOLLOW_bulk_key_in_into_clause247);
        	        m_gPLSQLParser->bulk_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinto_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_collect_key_in_into_clause249);
        	        m_gPLSQLParser->collect_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinto_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_into_key_in_into_clause251);
        	        m_gPLSQLParser->into_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinto_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_variable_name_in_into_clause253);
        	        variable_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinto_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:64:54: ( COMMA variable_name )*

        	        for (;;)
        	        {
        	            int alt9=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt9=1;
        	            	}
        	                break;

        	            }

        	            switch (alt9)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:64:55: COMMA variable_name
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_into_clause256);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinto_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_variable_name_in_into_clause258);
        	        	        variable_name();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinto_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop9;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop9: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleinto_clauseEx; /* Prevent compiler warnings */
    ruleinto_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end into_clause */

/**
 * $ANTLR start xml_column_name
 * PLSQLCommons.g:71:1: xml_column_name : ( id | quoted_string );
 */
void
PLSQLParser_PLSQLCommons::xml_column_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:72:5: ( id | quoted_string )

            ANTLR_UINT32 alt11;

            alt11=2;

            switch ( this->LA(1) )
            {
            case DELIMITED_ID:
            case INTRODUCER:
            case REGULAR_ID:
            	{
            		alt11=1;
            	}
                break;
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case NATIONAL_CHAR_STRING_LIT:
            	{
            		alt11=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 11 );
                ex->set_state( 0 );


                goto rulexml_column_nameEx;

            }

            switch (alt11)
            {
        	case 1:
        	    // PLSQLCommons.g:72:10: id
        	    {
        	        this->followPush(FOLLOW_id_in_xml_column_name285);
        	        id();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulexml_column_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:73:10: quoted_string
        	    {
        	        this->followPush(FOLLOW_quoted_string_in_xml_column_name296);
        	        quoted_string();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulexml_column_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulexml_column_nameEx; /* Prevent compiler warnings */
    rulexml_column_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xml_column_name */

/**
 * $ANTLR start cost_class_name
 * PLSQLCommons.g:76:1: cost_class_name : id ;
 */
void
PLSQLParser_PLSQLCommons::cost_class_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:77:5: ( id )
        // PLSQLCommons.g:77:10: id
        {
            this->followPush(FOLLOW_id_in_cost_class_name316);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecost_class_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecost_class_nameEx; /* Prevent compiler warnings */
    rulecost_class_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cost_class_name */

/**
 * $ANTLR start attribute_name
 * PLSQLCommons.g:80:1: attribute_name : id ;
 */
void
PLSQLParser_PLSQLCommons::attribute_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:81:5: ( id )
        // PLSQLCommons.g:81:10: id
        {
            this->followPush(FOLLOW_id_in_attribute_name336);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleattribute_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleattribute_nameEx; /* Prevent compiler warnings */
    ruleattribute_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end attribute_name */

/**
 * $ANTLR start savepoint_name
 * PLSQLCommons.g:84:1: savepoint_name : id ;
 */
void
PLSQLParser_PLSQLCommons::savepoint_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:85:5: ( id )
        // PLSQLCommons.g:85:10: id
        {
            this->followPush(FOLLOW_id_in_savepoint_name356);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesavepoint_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesavepoint_nameEx; /* Prevent compiler warnings */
    rulesavepoint_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end savepoint_name */

/**
 * $ANTLR start rollback_segment_name
 * PLSQLCommons.g:88:1: rollback_segment_name : id ;
 */
void
PLSQLParser_PLSQLCommons::rollback_segment_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:89:5: ( id )
        // PLSQLCommons.g:89:10: id
        {
            this->followPush(FOLLOW_id_in_rollback_segment_name376);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerollback_segment_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerollback_segment_nameEx; /* Prevent compiler warnings */
    rulerollback_segment_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rollback_segment_name */

/**
 * $ANTLR start table_var_name
 * PLSQLCommons.g:93:1: table_var_name : id ;
 */
void
PLSQLParser_PLSQLCommons::table_var_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:94:5: ( id )
        // PLSQLCommons.g:94:10: id
        {
            this->followPush(FOLLOW_id_in_table_var_name397);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_var_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_var_nameEx; /* Prevent compiler warnings */
    ruletable_var_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_var_name */

/**
 * $ANTLR start schema_name
 * PLSQLCommons.g:97:1: schema_name : id ;
 */
void
PLSQLParser_PLSQLCommons::schema_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:98:5: ( id )
        // PLSQLCommons.g:98:10: id
        {
            this->followPush(FOLLOW_id_in_schema_name417);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleschema_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleschema_nameEx; /* Prevent compiler warnings */
    ruleschema_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end schema_name */

/**
 * $ANTLR start routine_name
 * PLSQLCommons.g:101:1: routine_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )* ( AT_SIGN link_name )? ;
 */
void
PLSQLParser_PLSQLCommons::routine_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:102:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )* ( AT_SIGN link_name )? )
        // PLSQLCommons.g:102:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )* ( AT_SIGN link_name )?
        {
            this->followPush(FOLLOW_id_in_routine_name437);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleroutine_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:102:13: ( ( PERIOD id_expression )=> PERIOD id_expression )*

            for (;;)
            {
                int alt12=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA12_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred2_PLSQLCommons>() )) && (LA12_0 == PERIOD))
                    {
                        alt12=1;
                    }

                }
                switch (alt12)
                {
            	case 1:
            	    // PLSQLCommons.g:102:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_routine_name447);
            	        if  (this->hasException())
            	        {
            	            goto ruleroutine_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_routine_name449);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleroutine_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop12;	/* break out of the loop */
            	    break;
                }
            }
            loop12: ; /* Jump out to here if this rule does not match */


            // PLSQLCommons.g:102:62: ( AT_SIGN link_name )?
            {
                int alt13=2;
                switch ( this->LA(1) )
                {
                    case AT_SIGN:
                    	{
                    		alt13=1;
                    	}
                        break;
                }

                switch (alt13)
                {
            	case 1:
            	    // PLSQLCommons.g:102:63: AT_SIGN link_name
            	    {
            	         this->matchToken(AT_SIGN, &FOLLOW_AT_SIGN_in_routine_name454);
            	        if  (this->hasException())
            	        {
            	            goto ruleroutine_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_link_name_in_routine_name456);
            	        link_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleroutine_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleroutine_nameEx; /* Prevent compiler warnings */
    ruleroutine_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end routine_name */

/**
 * $ANTLR start package_name
 * PLSQLCommons.g:105:1: package_name : id ;
 */
void
PLSQLParser_PLSQLCommons::package_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:106:5: ( id )
        // PLSQLCommons.g:106:10: id
        {
            this->followPush(FOLLOW_id_in_package_name478);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepackage_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepackage_nameEx; /* Prevent compiler warnings */
    rulepackage_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end package_name */

/**
 * $ANTLR start implementation_type_name
 * PLSQLCommons.g:109:1: implementation_type_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )? ;
 */
void
PLSQLParser_PLSQLCommons::implementation_type_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:110:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )? )
        // PLSQLCommons.g:110:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )?
        {
            this->followPush(FOLLOW_id_in_implementation_type_name498);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleimplementation_type_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:110:13: ( ( PERIOD id_expression )=> PERIOD id_expression )?
            {
                int alt14=2;
                {
                    int LA14_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_PLSQLCommons>() )) && (LA14_0 == PERIOD))
                    {
                        alt14=1;
                    }
                }
                switch (alt14)
                {
            	case 1:
            	    // PLSQLCommons.g:110:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_implementation_type_name508);
            	        if  (this->hasException())
            	        {
            	            goto ruleimplementation_type_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_implementation_type_name510);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleimplementation_type_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleimplementation_type_nameEx; /* Prevent compiler warnings */
    ruleimplementation_type_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end implementation_type_name */

/**
 * $ANTLR start parameter_name
 * PLSQLCommons.g:113:1: parameter_name : id ;
 */
void
PLSQLParser_PLSQLCommons::parameter_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:114:5: ( id )
        // PLSQLCommons.g:114:10: id
        {
            this->followPush(FOLLOW_id_in_parameter_name532);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleparameter_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleparameter_nameEx; /* Prevent compiler warnings */
    ruleparameter_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end parameter_name */

/**
 * $ANTLR start reference_model_name
 * PLSQLCommons.g:117:1: reference_model_name : id ;
 */
void
PLSQLParser_PLSQLCommons::reference_model_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:118:5: ( id )
        // PLSQLCommons.g:118:10: id
        {
            this->followPush(FOLLOW_id_in_reference_model_name552);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereference_model_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereference_model_nameEx; /* Prevent compiler warnings */
    rulereference_model_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end reference_model_name */

/**
 * $ANTLR start main_model_name
 * PLSQLCommons.g:121:1: main_model_name : id ;
 */
void
PLSQLParser_PLSQLCommons::main_model_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:122:5: ( id )
        // PLSQLCommons.g:122:10: id
        {
            this->followPush(FOLLOW_id_in_main_model_name572);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemain_model_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemain_model_nameEx; /* Prevent compiler warnings */
    rulemain_model_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end main_model_name */

/**
 * $ANTLR start aggregate_function_name
 * PLSQLCommons.g:125:1: aggregate_function_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )* ;
 */
void
PLSQLParser_PLSQLCommons::aggregate_function_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:126:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )* )
        // PLSQLCommons.g:126:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )*
        {
            this->followPush(FOLLOW_id_in_aggregate_function_name592);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleaggregate_function_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:126:13: ( ( PERIOD id_expression )=> PERIOD id_expression )*

            for (;;)
            {
                int alt15=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA15_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_PLSQLCommons>() )) && (LA15_0 == PERIOD))
                    {
                        alt15=1;
                    }

                }
                switch (alt15)
                {
            	case 1:
            	    // PLSQLCommons.g:126:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_aggregate_function_name602);
            	        if  (this->hasException())
            	        {
            	            goto ruleaggregate_function_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_aggregate_function_name604);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleaggregate_function_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop15;	/* break out of the loop */
            	    break;
                }
            }
            loop15: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleaggregate_function_nameEx; /* Prevent compiler warnings */
    ruleaggregate_function_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end aggregate_function_name */

/**
 * $ANTLR start query_name
 * PLSQLCommons.g:129:1: query_name : id ;
 */
void
PLSQLParser_PLSQLCommons::query_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:130:5: ( id )
        // PLSQLCommons.g:130:10: id
        {
            this->followPush(FOLLOW_id_in_query_name626);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulequery_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulequery_nameEx; /* Prevent compiler warnings */
    rulequery_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end query_name */

/**
 * $ANTLR start constraint_name
 * PLSQLCommons.g:133:1: constraint_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )* ( AT_SIGN link_name )? ;
 */
void
PLSQLParser_PLSQLCommons::constraint_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:134:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )* ( AT_SIGN link_name )? )
        // PLSQLCommons.g:134:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )* ( AT_SIGN link_name )?
        {
            this->followPush(FOLLOW_id_in_constraint_name646);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstraint_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:134:13: ( ( PERIOD id_expression )=> PERIOD id_expression )*

            for (;;)
            {
                int alt16=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA16_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred5_PLSQLCommons>() )) && (LA16_0 == PERIOD))
                    {
                        alt16=1;
                    }

                }
                switch (alt16)
                {
            	case 1:
            	    // PLSQLCommons.g:134:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_constraint_name656);
            	        if  (this->hasException())
            	        {
            	            goto ruleconstraint_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_constraint_name658);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstraint_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop16;	/* break out of the loop */
            	    break;
                }
            }
            loop16: ; /* Jump out to here if this rule does not match */


            // PLSQLCommons.g:134:62: ( AT_SIGN link_name )?
            {
                int alt17=2;
                switch ( this->LA(1) )
                {
                    case AT_SIGN:
                    	{
                    		alt17=1;
                    	}
                        break;
                }

                switch (alt17)
                {
            	case 1:
            	    // PLSQLCommons.g:134:63: AT_SIGN link_name
            	    {
            	         this->matchToken(AT_SIGN, &FOLLOW_AT_SIGN_in_constraint_name663);
            	        if  (this->hasException())
            	        {
            	            goto ruleconstraint_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_link_name_in_constraint_name665);
            	        link_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstraint_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconstraint_nameEx; /* Prevent compiler warnings */
    ruleconstraint_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end constraint_name */

/**
 * $ANTLR start label_name
 * PLSQLCommons.g:137:1: label_name : id_expression ;
 */
void
PLSQLParser_PLSQLCommons::label_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:138:5: ( id_expression )
        // PLSQLCommons.g:138:10: id_expression
        {
            this->followPush(FOLLOW_id_expression_in_label_name687);
            id_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelabel_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelabel_nameEx; /* Prevent compiler warnings */
    rulelabel_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end label_name */

/**
 * $ANTLR start type_name
 * PLSQLCommons.g:141:1: type_name : id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )* ;
 */
void
PLSQLParser_PLSQLCommons::type_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:142:5: ( id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )* )
        // PLSQLCommons.g:142:10: id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )*
        {
            this->followPush(FOLLOW_id_expression_in_type_name707);
            id_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletype_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:142:24: ( ( PERIOD id_expression )=> PERIOD id_expression )*

            for (;;)
            {
                int alt18=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA18_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred6_PLSQLCommons>() )) && (LA18_0 == PERIOD))
                    {
                        alt18=1;
                    }

                }
                switch (alt18)
                {
            	case 1:
            	    // PLSQLCommons.g:142:25: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_type_name717);
            	        if  (this->hasException())
            	        {
            	            goto ruletype_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_type_name719);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop18;	/* break out of the loop */
            	    break;
                }
            }
            loop18: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletype_nameEx; /* Prevent compiler warnings */
    ruletype_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end type_name */

/**
 * $ANTLR start sequence_name
 * PLSQLCommons.g:145:1: sequence_name : id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )* ;
 */
void
PLSQLParser_PLSQLCommons::sequence_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:146:5: ( id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )* )
        // PLSQLCommons.g:146:10: id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )*
        {
            this->followPush(FOLLOW_id_expression_in_sequence_name741);
            id_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesequence_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:146:24: ( ( PERIOD id_expression )=> PERIOD id_expression )*

            for (;;)
            {
                int alt19=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA19_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred7_PLSQLCommons>() )) && (LA19_0 == PERIOD))
                    {
                        alt19=1;
                    }

                }
                switch (alt19)
                {
            	case 1:
            	    // PLSQLCommons.g:146:25: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_sequence_name751);
            	        if  (this->hasException())
            	        {
            	            goto rulesequence_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_sequence_name753);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesequence_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop19;	/* break out of the loop */
            	    break;
                }
            }
            loop19: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesequence_nameEx; /* Prevent compiler warnings */
    rulesequence_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sequence_name */

/**
 * $ANTLR start exception_name
 * PLSQLCommons.g:149:1: exception_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )* ;
 */
void
PLSQLParser_PLSQLCommons::exception_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:150:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )* )
        // PLSQLCommons.g:150:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )*
        {
            this->followPush(FOLLOW_id_in_exception_name775);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexception_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:150:13: ( ( PERIOD id_expression )=> PERIOD id_expression )*

            for (;;)
            {
                int alt20=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA20_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred8_PLSQLCommons>() )) && (LA20_0 == PERIOD))
                    {
                        alt20=1;
                    }

                }
                switch (alt20)
                {
            	case 1:
            	    // PLSQLCommons.g:150:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_exception_name785);
            	        if  (this->hasException())
            	        {
            	            goto ruleexception_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_exception_name787);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexception_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop20;	/* break out of the loop */
            	    break;
                }
            }
            loop20: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexception_nameEx; /* Prevent compiler warnings */
    ruleexception_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exception_name */

/**
 * $ANTLR start function_name
 * PLSQLCommons.g:153:1: function_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )? ;
 */
void
PLSQLParser_PLSQLCommons::function_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:154:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )? )
        // PLSQLCommons.g:154:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )?
        {
            this->followPush(FOLLOW_id_in_function_name810);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunction_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:154:13: ( ( PERIOD id_expression )=> PERIOD id_expression )?
            {
                int alt21=2;
                {
                    int LA21_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred9_PLSQLCommons>() )) && (LA21_0 == PERIOD))
                    {
                        alt21=1;
                    }
                }
                switch (alt21)
                {
            	case 1:
            	    // PLSQLCommons.g:154:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_function_name820);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_function_name822);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunction_nameEx; /* Prevent compiler warnings */
    rulefunction_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end function_name */

/**
 * $ANTLR start procedure_name
 * PLSQLCommons.g:157:1: procedure_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )? ;
 */
void
PLSQLParser_PLSQLCommons::procedure_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:158:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )? )
        // PLSQLCommons.g:158:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )?
        {
            this->followPush(FOLLOW_id_in_procedure_name844);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprocedure_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:158:13: ( ( PERIOD id_expression )=> PERIOD id_expression )?
            {
                int alt22=2;
                {
                    int LA22_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred10_PLSQLCommons>() )) && (LA22_0 == PERIOD))
                    {
                        alt22=1;
                    }
                }
                switch (alt22)
                {
            	case 1:
            	    // PLSQLCommons.g:158:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_procedure_name854);
            	        if  (this->hasException())
            	        {
            	            goto ruleprocedure_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_procedure_name856);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprocedure_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprocedure_nameEx; /* Prevent compiler warnings */
    ruleprocedure_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end procedure_name */

/**
 * $ANTLR start trigger_name
 * PLSQLCommons.g:161:1: trigger_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )? ;
 */
void
PLSQLParser_PLSQLCommons::trigger_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:162:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )? )
        // PLSQLCommons.g:162:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )?
        {
            this->followPush(FOLLOW_id_in_trigger_name878);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletrigger_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:162:13: ( ( PERIOD id_expression )=> PERIOD id_expression )?
            {
                int alt23=2;
                {
                    int LA23_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred11_PLSQLCommons>() )) && (LA23_0 == PERIOD))
                    {
                        alt23=1;
                    }
                }
                switch (alt23)
                {
            	case 1:
            	    // PLSQLCommons.g:162:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_trigger_name888);
            	        if  (this->hasException())
            	        {
            	            goto ruletrigger_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_trigger_name890);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletrigger_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruletrigger_nameEx; /* Prevent compiler warnings */
    ruletrigger_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end trigger_name */

/**
 * $ANTLR start variable_name
 * PLSQLCommons.g:165:1: variable_name : ( ( INTRODUCER char_set_name )? id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )? | bind_variable );
 */
void
PLSQLParser_PLSQLCommons::variable_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:166:5: ( ( INTRODUCER char_set_name )? id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )? | bind_variable )

            ANTLR_UINT32 alt26;

            alt26=2;

            switch ( this->LA(1) )
            {
            case DELIMITED_ID:
            case INTRODUCER:
            case REGULAR_ID:
            	{
            		alt26=1;
            	}
                break;
            case BINDVAR:
            case COLON:
            	{
            		alt26=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 26 );
                ex->set_state( 0 );


                goto rulevariable_nameEx;

            }

            switch (alt26)
            {
        	case 1:
        	    // PLSQLCommons.g:166:10: ( INTRODUCER char_set_name )? id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )?
        	    {
        	        // PLSQLCommons.g:166:10: ( INTRODUCER char_set_name )?
        	        {
        	            int alt24=2;
        	            switch ( this->LA(1) )
        	            {
        	                case INTRODUCER:
        	                	{
        	                		alt24=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt24)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:166:11: INTRODUCER char_set_name
        	        	    {
        	        	         this->matchToken(INTRODUCER, &FOLLOW_INTRODUCER_in_variable_name913);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulevariable_nameEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_char_set_name_in_variable_name915);
        	        	        char_set_name();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulevariable_nameEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_id_expression_in_variable_name931);
        	        id_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:167:27: ( ( PERIOD id_expression )=> PERIOD id_expression )?
        	        {
        	            int alt25=2;
        	            {
        	                int LA25_0 = this->LA(1);
        	                if ( (this->msynpred( antlr3::ClassForwarder<synpred12_PLSQLCommons>() )) && (LA25_0 == PERIOD))
        	                {
        	                    alt25=1;
        	                }
        	            }
        	            switch (alt25)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:167:28: ( PERIOD id_expression )=> PERIOD id_expression
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_variable_name941);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulevariable_nameEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_id_expression_in_variable_name943);
        	        	        id_expression();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulevariable_nameEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:168:10: bind_variable
        	    {
        	        this->followPush(FOLLOW_bind_variable_in_variable_name956);
        	        bind_variable();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulevariable_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulevariable_nameEx; /* Prevent compiler warnings */
    rulevariable_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end variable_name */

/**
 * $ANTLR start index_name
 * PLSQLCommons.g:171:1: index_name : id ;
 */
void
PLSQLParser_PLSQLCommons::index_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:172:5: ( id )
        // PLSQLCommons.g:172:10: id
        {
            this->followPush(FOLLOW_id_in_index_name976);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleindex_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleindex_nameEx; /* Prevent compiler warnings */
    ruleindex_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end index_name */

/**
 * $ANTLR start cursor_name
 * PLSQLCommons.g:175:1: cursor_name : ( id | bind_variable );
 */
void
PLSQLParser_PLSQLCommons::cursor_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:176:5: ( id | bind_variable )

            ANTLR_UINT32 alt27;

            alt27=2;

            switch ( this->LA(1) )
            {
            case DELIMITED_ID:
            case INTRODUCER:
            case REGULAR_ID:
            	{
            		alt27=1;
            	}
                break;
            case BINDVAR:
            case COLON:
            	{
            		alt27=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 27 );
                ex->set_state( 0 );


                goto rulecursor_nameEx;

            }

            switch (alt27)
            {
        	case 1:
        	    // PLSQLCommons.g:176:10: id
        	    {
        	        this->followPush(FOLLOW_id_in_cursor_name996);
        	        id();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecursor_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:177:10: bind_variable
        	    {
        	        this->followPush(FOLLOW_bind_variable_in_cursor_name1007);
        	        bind_variable();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecursor_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulecursor_nameEx; /* Prevent compiler warnings */
    rulecursor_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cursor_name */

/**
 * $ANTLR start record_name
 * PLSQLCommons.g:180:1: record_name : ( id | bind_variable );
 */
void
PLSQLParser_PLSQLCommons::record_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:181:5: ( id | bind_variable )

            ANTLR_UINT32 alt28;

            alt28=2;

            switch ( this->LA(1) )
            {
            case DELIMITED_ID:
            case INTRODUCER:
            case REGULAR_ID:
            	{
            		alt28=1;
            	}
                break;
            case BINDVAR:
            case COLON:
            	{
            		alt28=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 28 );
                ex->set_state( 0 );


                goto rulerecord_nameEx;

            }

            switch (alt28)
            {
        	case 1:
        	    // PLSQLCommons.g:181:10: id
        	    {
        	        this->followPush(FOLLOW_id_in_record_name1027);
        	        id();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulerecord_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:182:10: bind_variable
        	    {
        	        this->followPush(FOLLOW_bind_variable_in_record_name1038);
        	        bind_variable();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulerecord_nameEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulerecord_nameEx; /* Prevent compiler warnings */
    rulerecord_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end record_name */

/**
 * $ANTLR start collection_name
 * PLSQLCommons.g:185:1: collection_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )? ;
 */
void
PLSQLParser_PLSQLCommons::collection_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:186:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )? )
        // PLSQLCommons.g:186:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )?
        {
            this->followPush(FOLLOW_id_in_collection_name1058);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecollection_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:186:13: ( ( PERIOD id_expression )=> PERIOD id_expression )?
            {
                int alt29=2;
                {
                    int LA29_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred13_PLSQLCommons>() )) && (LA29_0 == PERIOD))
                    {
                        alt29=1;
                    }
                }
                switch (alt29)
                {
            	case 1:
            	    // PLSQLCommons.g:186:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_collection_name1068);
            	        if  (this->hasException())
            	        {
            	            goto rulecollection_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_collection_name1070);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecollection_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulecollection_nameEx; /* Prevent compiler warnings */
    rulecollection_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end collection_name */

/**
 * $ANTLR start link_name
 * PLSQLCommons.g:189:1: link_name : id ;
 */
void
PLSQLParser_PLSQLCommons::link_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:190:5: ( id )
        // PLSQLCommons.g:190:10: id
        {
            this->followPush(FOLLOW_id_in_link_name1092);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelink_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelink_nameEx; /* Prevent compiler warnings */
    rulelink_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end link_name */

/**
 * $ANTLR start column_name
 * PLSQLCommons.g:193:1: column_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )* ;
 */
void
PLSQLParser_PLSQLCommons::column_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:194:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )* )
        // PLSQLCommons.g:194:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )*
        {
            this->followPush(FOLLOW_id_in_column_name1112);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecolumn_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:194:13: ( ( PERIOD id_expression )=> PERIOD id_expression )*

            for (;;)
            {
                int alt30=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA30_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred14_PLSQLCommons>() )) && (LA30_0 == PERIOD))
                    {
                        alt30=1;
                    }

                }
                switch (alt30)
                {
            	case 1:
            	    // PLSQLCommons.g:194:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_column_name1122);
            	        if  (this->hasException())
            	        {
            	            goto rulecolumn_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_column_name1124);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecolumn_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop30;	/* break out of the loop */
            	    break;
                }
            }
            loop30: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecolumn_nameEx; /* Prevent compiler warnings */
    rulecolumn_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end column_name */

/**
 * $ANTLR start tableview_name
 * PLSQLCommons.g:197:1: tableview_name : id ( ( PERIOD id_expression )=> PERIOD id_expression )? ( AT_SIGN link_name |{...}? => partition_extension_clause )? ;
 */
void
PLSQLParser_PLSQLCommons::tableview_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:198:5: ( id ( ( PERIOD id_expression )=> PERIOD id_expression )? ( AT_SIGN link_name |{...}? => partition_extension_clause )? )
        // PLSQLCommons.g:198:10: id ( ( PERIOD id_expression )=> PERIOD id_expression )? ( AT_SIGN link_name |{...}? => partition_extension_clause )?
        {
            this->followPush(FOLLOW_id_in_tableview_name1146);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletableview_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:198:13: ( ( PERIOD id_expression )=> PERIOD id_expression )?
            {
                int alt31=2;
                switch ( this->LA(1) )
                {
                    case PERIOD:
                    	{
                    		{
                    		    int LA31_1 = this->LA(2);
                    		    if ( (this->msynpred( antlr3::ClassForwarder<synpred15_PLSQLCommons>() )) && (LA31_1 == DELIMITED_ID || LA31_1 == REGULAR_ID))
                    		    {
                    		        alt31=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt31)
                {
            	case 1:
            	    // PLSQLCommons.g:198:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_tableview_name1156);
            	        if  (this->hasException())
            	        {
            	            goto ruletableview_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_tableview_name1158);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletableview_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLCommons.g:199:5: ( AT_SIGN link_name |{...}? => partition_extension_clause )?
            {
                int alt32=3;
                switch ( this->LA(1) )
                {
                    case AT_SIGN:
                    	{
                    		alt32=1;
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA32_2 = this->LA(2);
                    		    if ( (( ((((equalsIgnoreCase(LT(1)->getText(), "PARTITION")))||((equalsIgnoreCase(LT(1)->getText(), "SUBPARTITION"))))) && ((!(LA(2) == SQL92_RESERVED_BY))) )))
                    		    {
                    		        alt32=2;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt32)
                {
            	case 1:
            	    // PLSQLCommons.g:199:10: AT_SIGN link_name
            	    {
            	         this->matchToken(AT_SIGN, &FOLLOW_AT_SIGN_in_tableview_name1172);
            	        if  (this->hasException())
            	        {
            	            goto ruletableview_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_link_name_in_tableview_name1174);
            	        link_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletableview_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:200:10: {...}? => partition_extension_clause
            	    {
            	        if ( !((!(LA(2) == SQL92_RESERVED_BY))) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return ;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "!(LA(2) == SQL92_RESERVED_BY)" );
            	                ex->set_ruleName( "tableview_name" );


            	        }

            	        this->followPush(FOLLOW_partition_extension_clause_in_tableview_name1188);
            	        partition_extension_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletableview_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruletableview_nameEx; /* Prevent compiler warnings */
    ruletableview_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end tableview_name */

/**
 * $ANTLR start char_set_name
 * PLSQLCommons.g:204:1: char_set_name : id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )* ;
 */
void
PLSQLParser_PLSQLCommons::char_set_name()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:205:5: ( id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )* )
        // PLSQLCommons.g:205:10: id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )*
        {
            this->followPush(FOLLOW_id_expression_in_char_set_name1215);
            id_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulechar_set_nameEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:205:24: ( ( PERIOD id_expression )=> PERIOD id_expression )*

            for (;;)
            {
                int alt33=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA33_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred16_PLSQLCommons>() )) && (LA33_0 == PERIOD))
                    {
                        alt33=1;
                    }

                }
                switch (alt33)
                {
            	case 1:
            	    // PLSQLCommons.g:205:25: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_char_set_name1225);
            	        if  (this->hasException())
            	        {
            	            goto rulechar_set_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_char_set_name1227);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulechar_set_nameEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop33;	/* break out of the loop */
            	    break;
                }
            }
            loop33: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulechar_set_nameEx; /* Prevent compiler warnings */
    rulechar_set_nameEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end char_set_name */

/**
 * $ANTLR start keep_clause
 * PLSQLCommons.g:213:1: keep_clause : keep_key LEFT_PAREN dense_rank_key ( first_key | last_key ) order_by_clause RIGHT_PAREN ( over_clause )? ;
 */
void
PLSQLParser_PLSQLCommons::keep_clause()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:214:5: ( keep_key LEFT_PAREN dense_rank_key ( first_key | last_key ) order_by_clause RIGHT_PAREN ( over_clause )? )
        // PLSQLCommons.g:214:9: keep_key LEFT_PAREN dense_rank_key ( first_key | last_key ) order_by_clause RIGHT_PAREN ( over_clause )?
        {
            this->followPush(FOLLOW_keep_key_in_keep_clause1253);
            m_gPLSQLParser->keep_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulekeep_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_keep_clause1263);
            if  (this->hasException())
            {
                goto rulekeep_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_dense_rank_key_in_keep_clause1277);
            m_gPLSQLParser->dense_rank_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulekeep_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:216:28: ( first_key | last_key )
            {
                int alt34=2;
                {
                    int LA34_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "FIRST")))||((equalsIgnoreCase(LT(1)->getText(), "LAST"))))) && (LA34_0 == REGULAR_ID))
                    {
                        {
                            int LA34_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "FIRST"))))
                            {
                                alt34=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "LAST"))))
                            {
                                alt34=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 34 );
                                ex->set_state( 1 );


                                goto rulekeep_clauseEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 34 );
                        ex->set_state( 0 );


                        goto rulekeep_clauseEx;

                    }
                }
                switch (alt34)
                {
            	case 1:
            	    // PLSQLCommons.g:216:29: first_key
            	    {
            	        this->followPush(FOLLOW_first_key_in_keep_clause1280);
            	        m_gPLSQLParser->first_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulekeep_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:216:39: last_key
            	    {
            	        this->followPush(FOLLOW_last_key_in_keep_clause1282);
            	        m_gPLSQLParser->last_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulekeep_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_order_by_clause_in_keep_clause1298);
            m_gPLSQLParser->order_by_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulekeep_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_keep_clause1308);
            if  (this->hasException())
            {
                goto rulekeep_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:218:21: ( over_clause )?
            {
                int alt35=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA35_1 = this->LA(2);
                    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "OVER"))))
                    		    {
                    		        alt35=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt35)
                {
            	case 1:
            	    // PLSQLCommons.g:218:21: over_clause
            	    {
            	        this->followPush(FOLLOW_over_clause_in_keep_clause1310);
            	        m_gPLSQLParser->over_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulekeep_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulekeep_clauseEx; /* Prevent compiler warnings */
    rulekeep_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end keep_clause */

/**
 * $ANTLR start function_argument
 * PLSQLCommons.g:221:1: function_argument : LEFT_PAREN ( argument )? ( COMMA argument )* RIGHT_PAREN ( keep_clause )? ;
 */
void
PLSQLParser_PLSQLCommons::function_argument()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:222:5: ( LEFT_PAREN ( argument )? ( COMMA argument )* RIGHT_PAREN ( keep_clause )? )
        // PLSQLCommons.g:222:10: LEFT_PAREN ( argument )? ( COMMA argument )* RIGHT_PAREN ( keep_clause )?
        {
             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_function_argument1331);
            if  (this->hasException())
            {
                goto rulefunction_argumentEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:223:13: ( argument )?
            {
                int alt36=2;
                switch ( this->LA(1) )
                {
                    case APPROXIMATE_NUM_LIT:
                    case BINDVAR:
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case COLON:
                    case DELIMITED_ID:
                    case EXACT_NUM_LIT:
                    case INTRODUCER:
                    case LEFT_PAREN:
                    case MINUS_SIGN:
                    case NATIONAL_CHAR_STRING_LIT:
                    case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                    case PLUS_SIGN:
                    case REGULAR_ID:
                    case SQL92_RESERVED_ALL:
                    case SQL92_RESERVED_ANY:
                    case SQL92_RESERVED_CASE:
                    case SQL92_RESERVED_CURSOR:
                    case SQL92_RESERVED_DATE:
                    case SQL92_RESERVED_DEFAULT:
                    case SQL92_RESERVED_DISTINCT:
                    case SQL92_RESERVED_EXISTS:
                    case SQL92_RESERVED_FALSE:
                    case SQL92_RESERVED_NOT:
                    case SQL92_RESERVED_NULL:
                    case SQL92_RESERVED_PRIOR:
                    case SQL92_RESERVED_TRUE:
                    case UNSIGNED_INTEGER:
                    	{
                    		alt36=1;
                    	}
                        break;
                }

                switch (alt36)
                {
            	case 1:
            	    // PLSQLCommons.g:223:13: argument
            	    {
            	        this->followPush(FOLLOW_argument_in_function_argument1346);
            	        argument();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLCommons.g:223:23: ( COMMA argument )*

            for (;;)
            {
                int alt37=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt37=1;
                	}
                    break;

                }

                switch (alt37)
                {
            	case 1:
            	    // PLSQLCommons.g:223:24: COMMA argument
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_function_argument1350);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_argument_in_function_argument1352);
            	        argument();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop37;	/* break out of the loop */
            	    break;
                }
            }
            loop37: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_function_argument1366);
            if  (this->hasException())
            {
                goto rulefunction_argumentEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:225:9: ( keep_clause )?
            {
                int alt38=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case LEFT_PAREN:
                    		    	{
                    		    		switch ( this->LA(3) )
                    		    		{
                    		    		    case REGULAR_ID:
                    		    		    	{
                    		    		    		switch ( this->LA(4) )
                    		    		    		{
                    		    		    		    case REGULAR_ID:
                    		    		    		    	{
                    		    		    		    		{
                    		    		    		    		    int LA38_15 = this->LA(5);
                    		    		    		    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "KEEP"))) && (LA38_15 == SQL92_RESERVED_ORDER))
                    		    		    		    		    {
                    		    		    		    		        alt38=1;
                    		    		    		    		    }
                    		    		    		    		}
                    		    		    		    	}
                    		    		    		        break;
                    		    		    		}

                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt38)
                {
            	case 1:
            	    // PLSQLCommons.g:225:9: keep_clause
            	    {
            	        this->followPush(FOLLOW_keep_clause_in_function_argument1376);
            	        keep_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunction_argumentEx; /* Prevent compiler warnings */
    rulefunction_argumentEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end function_argument */

/**
 * $ANTLR start function_argument_analytic
 * PLSQLCommons.g:228:1: function_argument_analytic : LEFT_PAREN ( argument ( respect_or_ignore_nulls )? )? ( COMMA argument ( respect_or_ignore_nulls )? )* RIGHT_PAREN ( keep_clause )? ;
 */
void
PLSQLParser_PLSQLCommons::function_argument_analytic()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:229:5: ( LEFT_PAREN ( argument ( respect_or_ignore_nulls )? )? ( COMMA argument ( respect_or_ignore_nulls )? )* RIGHT_PAREN ( keep_clause )? )
        // PLSQLCommons.g:229:10: LEFT_PAREN ( argument ( respect_or_ignore_nulls )? )? ( COMMA argument ( respect_or_ignore_nulls )? )* RIGHT_PAREN ( keep_clause )?
        {
             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_function_argument_analytic1397);
            if  (this->hasException())
            {
                goto rulefunction_argument_analyticEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:230:13: ( argument ( respect_or_ignore_nulls )? )?
            {
                int alt40=2;
                switch ( this->LA(1) )
                {
                    case APPROXIMATE_NUM_LIT:
                    case BINDVAR:
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case COLON:
                    case DELIMITED_ID:
                    case EXACT_NUM_LIT:
                    case INTRODUCER:
                    case LEFT_PAREN:
                    case MINUS_SIGN:
                    case NATIONAL_CHAR_STRING_LIT:
                    case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                    case PLUS_SIGN:
                    case REGULAR_ID:
                    case SQL92_RESERVED_ALL:
                    case SQL92_RESERVED_ANY:
                    case SQL92_RESERVED_CASE:
                    case SQL92_RESERVED_CURSOR:
                    case SQL92_RESERVED_DATE:
                    case SQL92_RESERVED_DEFAULT:
                    case SQL92_RESERVED_DISTINCT:
                    case SQL92_RESERVED_EXISTS:
                    case SQL92_RESERVED_FALSE:
                    case SQL92_RESERVED_NOT:
                    case SQL92_RESERVED_NULL:
                    case SQL92_RESERVED_PRIOR:
                    case SQL92_RESERVED_TRUE:
                    case UNSIGNED_INTEGER:
                    	{
                    		alt40=1;
                    	}
                        break;
                }

                switch (alt40)
                {
            	case 1:
            	    // PLSQLCommons.g:230:14: argument ( respect_or_ignore_nulls )?
            	    {
            	        this->followPush(FOLLOW_argument_in_function_argument_analytic1412);
            	        argument();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_analyticEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLCommons.g:230:23: ( respect_or_ignore_nulls )?
            	        {
            	            int alt39=2;
            	            {
            	                int LA39_0 = this->LA(1);
            	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "RESPECT"))))) && (LA39_0 == REGULAR_ID))
            	                {
            	                    alt39=1;
            	                }
            	            }
            	            switch (alt39)
            	            {
            	        	case 1:
            	        	    // PLSQLCommons.g:230:23: respect_or_ignore_nulls
            	        	    {
            	        	        this->followPush(FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic1414);
            	        	        respect_or_ignore_nulls();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_analyticEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // PLSQLCommons.g:231:13: ( COMMA argument ( respect_or_ignore_nulls )? )*

            for (;;)
            {
                int alt42=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt42=1;
                	}
                    break;

                }

                switch (alt42)
                {
            	case 1:
            	    // PLSQLCommons.g:231:14: COMMA argument ( respect_or_ignore_nulls )?
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_function_argument_analytic1432);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_analyticEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_argument_in_function_argument_analytic1434);
            	        argument();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_analyticEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLCommons.g:231:29: ( respect_or_ignore_nulls )?
            	        {
            	            int alt41=2;
            	            {
            	                int LA41_0 = this->LA(1);
            	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "RESPECT"))))) && (LA41_0 == REGULAR_ID))
            	                {
            	                    alt41=1;
            	                }
            	            }
            	            switch (alt41)
            	            {
            	        	case 1:
            	        	    // PLSQLCommons.g:231:29: respect_or_ignore_nulls
            	        	    {
            	        	        this->followPush(FOLLOW_respect_or_ignore_nulls_in_function_argument_analytic1436);
            	        	        respect_or_ignore_nulls();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_analyticEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop42;	/* break out of the loop */
            	    break;
                }
            }
            loop42: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_function_argument_analytic1451);
            if  (this->hasException())
            {
                goto rulefunction_argument_analyticEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:233:10: ( keep_clause )?
            {
                int alt43=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case LEFT_PAREN:
                    		    	{
                    		    		switch ( this->LA(3) )
                    		    		{
                    		    		    case REGULAR_ID:
                    		    		    	{
                    		    		    		switch ( this->LA(4) )
                    		    		    		{
                    		    		    		    case REGULAR_ID:
                    		    		    		    	{
                    		    		    		    		{
                    		    		    		    		    int LA43_16 = this->LA(5);
                    		    		    		    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "KEEP"))) && (LA43_16 == SQL92_RESERVED_ORDER))
                    		    		    		    		    {
                    		    		    		    		        alt43=1;
                    		    		    		    		    }
                    		    		    		    		}
                    		    		    		    	}
                    		    		    		        break;
                    		    		    		}

                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt43)
                {
            	case 1:
            	    // PLSQLCommons.g:233:10: keep_clause
            	    {
            	        this->followPush(FOLLOW_keep_clause_in_function_argument_analytic1462);
            	        keep_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_analyticEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunction_argument_analyticEx; /* Prevent compiler warnings */
    rulefunction_argument_analyticEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end function_argument_analytic */

/**
 * $ANTLR start function_argument_modeling
 * PLSQLCommons.g:236:1: function_argument_modeling : LEFT_PAREN column_name ( COMMA ( numeric | null_key ) ( COMMA ( numeric | null_key ) )? )? using_key ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK | ASTERISK | expression ( column_alias )? ( COMMA expression ( column_alias )? )* ) RIGHT_PAREN ( keep_clause )? ;
 */
void
PLSQLParser_PLSQLCommons::function_argument_modeling()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:237:5: ( LEFT_PAREN column_name ( COMMA ( numeric | null_key ) ( COMMA ( numeric | null_key ) )? )? using_key ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK | ASTERISK | expression ( column_alias )? ( COMMA expression ( column_alias )? )* ) RIGHT_PAREN ( keep_clause )? )
        // PLSQLCommons.g:237:10: LEFT_PAREN column_name ( COMMA ( numeric | null_key ) ( COMMA ( numeric | null_key ) )? )? using_key ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK | ASTERISK | expression ( column_alias )? ( COMMA expression ( column_alias )? )* ) RIGHT_PAREN ( keep_clause )?
        {
             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_function_argument_modeling1483);
            if  (this->hasException())
            {
                goto rulefunction_argument_modelingEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_function_argument_modeling1497);
            column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunction_argument_modelingEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:238:25: ( COMMA ( numeric | null_key ) ( COMMA ( numeric | null_key ) )? )?
            {
                int alt47=2;
                switch ( this->LA(1) )
                {
                    case COMMA:
                    	{
                    		alt47=1;
                    	}
                        break;
                }

                switch (alt47)
                {
            	case 1:
            	    // PLSQLCommons.g:238:26: COMMA ( numeric | null_key ) ( COMMA ( numeric | null_key ) )?
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_function_argument_modeling1500);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLCommons.g:238:32: ( numeric | null_key )
            	        {
            	            int alt44=2;
            	            switch ( this->LA(1) )
            	            {
            	            case APPROXIMATE_NUM_LIT:
            	            case EXACT_NUM_LIT:
            	            case UNSIGNED_INTEGER:
            	            	{
            	            		alt44=1;
            	            	}
            	                break;
            	            case SQL92_RESERVED_NULL:
            	            	{
            	            		alt44=2;
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return ;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 44 );
            	                ex->set_state( 0 );


            	                goto rulefunction_argument_modelingEx;

            	            }

            	            switch (alt44)
            	            {
            	        	case 1:
            	        	    // PLSQLCommons.g:238:33: numeric
            	        	    {
            	        	        this->followPush(FOLLOW_numeric_in_function_argument_modeling1503);
            	        	        numeric();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_modelingEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQLCommons.g:238:41: null_key
            	        	    {
            	        	        this->followPush(FOLLOW_null_key_in_function_argument_modeling1505);
            	        	        m_gPLSQLParser->null_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_modelingEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQLCommons.g:238:51: ( COMMA ( numeric | null_key ) )?
            	        {
            	            int alt46=2;
            	            switch ( this->LA(1) )
            	            {
            	                case COMMA:
            	                	{
            	                		alt46=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt46)
            	            {
            	        	case 1:
            	        	    // PLSQLCommons.g:238:52: COMMA ( numeric | null_key )
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_function_argument_modeling1509);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_modelingEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // PLSQLCommons.g:238:58: ( numeric | null_key )
            	        	        {
            	        	            int alt45=2;
            	        	            switch ( this->LA(1) )
            	        	            {
            	        	            case APPROXIMATE_NUM_LIT:
            	        	            case EXACT_NUM_LIT:
            	        	            case UNSIGNED_INTEGER:
            	        	            	{
            	        	            		alt45=1;
            	        	            	}
            	        	                break;
            	        	            case SQL92_RESERVED_NULL:
            	        	            	{
            	        	            		alt45=2;
            	        	            	}
            	        	                break;

            	        	            default:
            	        	                if (this->get_backtracking()>0)
            	        	                {
            	        	                    this->set_failedflag( true );
            	        	                    return ;
            	        	                }

            	        	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	        	                ex->set_decisionNum( 45 );
            	        	                ex->set_state( 0 );


            	        	                goto rulefunction_argument_modelingEx;

            	        	            }

            	        	            switch (alt45)
            	        	            {
            	        	        	case 1:
            	        	        	    // PLSQLCommons.g:238:59: numeric
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_numeric_in_function_argument_modeling1512);
            	        	        	        numeric();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto rulefunction_argument_modelingEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // PLSQLCommons.g:238:67: null_key
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_null_key_in_function_argument_modeling1514);
            	        	        	        m_gPLSQLParser->null_key();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto rulefunction_argument_modelingEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_using_key_in_function_argument_modeling1535);
            m_gPLSQLParser->using_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunction_argument_modelingEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:240:17: ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK | ASTERISK | expression ( column_alias )? ( COMMA expression ( column_alias )? )* )
            {
                int alt51=3;
                switch ( this->LA(1) )
                {
                case INTRODUCER:
                	{
                		{
                		    int LA51_1 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred17_PLSQLCommons>() )))
                		    {
                		        alt51=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt51=3;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 51 );
                		        ex->set_state( 1 );


                		        goto rulefunction_argument_modelingEx;

                		    }
                		}
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    int LA51_2 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred17_PLSQLCommons>() )))
                		    {
                		        alt51=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt51=3;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 51 );
                		        ex->set_state( 2 );


                		        goto rulefunction_argument_modelingEx;

                		    }
                		}
                	}
                    break;
                case ASTERISK:
                	{
                		alt51=2;
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case EXACT_NUM_LIT:
                case LEFT_PAREN:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURSOR:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt51=3;
                	}
                    break;
                case DELIMITED_ID:
                	{
                		{
                		    int LA51_10 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred17_PLSQLCommons>() )))
                		    {
                		        alt51=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt51=3;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 51 );
                		        ex->set_state( 10 );


                		        goto rulefunction_argument_modelingEx;

                		    }
                		}
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 51 );
                    ex->set_state( 0 );


                    goto rulefunction_argument_modelingEx;

                }

                switch (alt51)
                {
            	case 1:
            	    // PLSQLCommons.g:240:19: ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK
            	    {
            	        this->followPush(FOLLOW_tableview_name_in_function_argument_modeling1564);
            	        tableview_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_function_argument_modeling1566);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_function_argument_modeling1568);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:241:19: ASTERISK
            	    {
            	         this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_function_argument_modeling1588);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLCommons.g:242:19: expression ( column_alias )? ( COMMA expression ( column_alias )? )*
            	    {
            	        this->followPush(FOLLOW_expression_in_function_argument_modeling1608);
            	        m_gPLSQLParser->expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLCommons.g:242:30: ( column_alias )?
            	        {
            	            int alt48=2;
            	            switch ( this->LA(1) )
            	            {
            	                case CHAR_STRING:
            	                case CHAR_STRING_PERL:
            	                case DELIMITED_ID:
            	                case INTRODUCER:
            	                case NATIONAL_CHAR_STRING_LIT:
            	                case REGULAR_ID:
            	                case SQL92_RESERVED_AS:
            	                	{
            	                		alt48=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt48)
            	            {
            	        	case 1:
            	        	    // PLSQLCommons.g:242:30: column_alias
            	        	    {
            	        	        this->followPush(FOLLOW_column_alias_in_function_argument_modeling1610);
            	        	        column_alias();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_modelingEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQLCommons.g:242:44: ( COMMA expression ( column_alias )? )*

            	        for (;;)
            	        {
            	            int alt50=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt50=1;
            	            	}
            	                break;

            	            }

            	            switch (alt50)
            	            {
            	        	case 1:
            	        	    // PLSQLCommons.g:242:45: COMMA expression ( column_alias )?
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_function_argument_modeling1614);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_modelingEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_expression_in_function_argument_modeling1616);
            	        	        m_gPLSQLParser->expression();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_argument_modelingEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // PLSQLCommons.g:242:62: ( column_alias )?
            	        	        {
            	        	            int alt49=2;
            	        	            switch ( this->LA(1) )
            	        	            {
            	        	                case CHAR_STRING:
            	        	                case CHAR_STRING_PERL:
            	        	                case DELIMITED_ID:
            	        	                case INTRODUCER:
            	        	                case NATIONAL_CHAR_STRING_LIT:
            	        	                case REGULAR_ID:
            	        	                case SQL92_RESERVED_AS:
            	        	                	{
            	        	                		alt49=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt49)
            	        	            {
            	        	        	case 1:
            	        	        	    // PLSQLCommons.g:242:62: column_alias
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_column_alias_in_function_argument_modeling1618);
            	        	        	        column_alias();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto rulefunction_argument_modelingEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop50;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop50: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_function_argument_modeling1650);
            if  (this->hasException())
            {
                goto rulefunction_argument_modelingEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:245:10: ( keep_clause )?
            {
                int alt52=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case LEFT_PAREN:
                    		    	{
                    		    		switch ( this->LA(3) )
                    		    		{
                    		    		    case REGULAR_ID:
                    		    		    	{
                    		    		    		switch ( this->LA(4) )
                    		    		    		{
                    		    		    		    case REGULAR_ID:
                    		    		    		    	{
                    		    		    		    		{
                    		    		    		    		    int LA52_15 = this->LA(5);
                    		    		    		    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "KEEP"))) && (LA52_15 == SQL92_RESERVED_ORDER))
                    		    		    		    		    {
                    		    		    		    		        alt52=1;
                    		    		    		    		    }
                    		    		    		    		}
                    		    		    		    	}
                    		    		    		        break;
                    		    		    		}

                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt52)
                {
            	case 1:
            	    // PLSQLCommons.g:245:10: keep_clause
            	    {
            	        this->followPush(FOLLOW_keep_clause_in_function_argument_modeling1661);
            	        keep_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_argument_modelingEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunction_argument_modelingEx; /* Prevent compiler warnings */
    rulefunction_argument_modelingEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end function_argument_modeling */

/**
 * $ANTLR start respect_or_ignore_nulls
 * PLSQLCommons.g:248:1: respect_or_ignore_nulls : ( respect_key | ignore_key ) nulls_key ;
 */
void
PLSQLParser_PLSQLCommons::respect_or_ignore_nulls()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:249:5: ( ( respect_key | ignore_key ) nulls_key )
        // PLSQLCommons.g:249:10: ( respect_key | ignore_key ) nulls_key
        {
            // PLSQLCommons.g:249:10: ( respect_key | ignore_key )
            {
                int alt53=2;
                {
                    int LA53_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "RESPECT"))))) && (LA53_0 == REGULAR_ID))
                    {
                        {
                            int LA53_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "RESPECT"))))
                            {
                                alt53=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "IGNORE"))))
                            {
                                alt53=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 53 );
                                ex->set_state( 1 );


                                goto rulerespect_or_ignore_nullsEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 53 );
                        ex->set_state( 0 );


                        goto rulerespect_or_ignore_nullsEx;

                    }
                }
                switch (alt53)
                {
            	case 1:
            	    // PLSQLCommons.g:249:11: respect_key
            	    {
            	        this->followPush(FOLLOW_respect_key_in_respect_or_ignore_nulls1683);
            	        m_gPLSQLParser->respect_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerespect_or_ignore_nullsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:249:25: ignore_key
            	    {
            	        this->followPush(FOLLOW_ignore_key_in_respect_or_ignore_nulls1687);
            	        m_gPLSQLParser->ignore_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerespect_or_ignore_nullsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_nulls_key_in_respect_or_ignore_nulls1690);
            m_gPLSQLParser->nulls_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerespect_or_ignore_nullsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerespect_or_ignore_nullsEx; /* Prevent compiler warnings */
    rulerespect_or_ignore_nullsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end respect_or_ignore_nulls */

/**
 * $ANTLR start argument
 * PLSQLCommons.g:252:1: argument : ( ( id EQUALS_OP GREATER_THAN_OP )=> id EQUALS_OP GREATER_THAN_OP )? expression_wrapper ;
 */
void
PLSQLParser_PLSQLCommons::argument()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:253:5: ( ( ( id EQUALS_OP GREATER_THAN_OP )=> id EQUALS_OP GREATER_THAN_OP )? expression_wrapper )
        // PLSQLCommons.g:253:10: ( ( id EQUALS_OP GREATER_THAN_OP )=> id EQUALS_OP GREATER_THAN_OP )? expression_wrapper
        {
            // PLSQLCommons.g:253:10: ( ( id EQUALS_OP GREATER_THAN_OP )=> id EQUALS_OP GREATER_THAN_OP )?
            {
                int alt54=2;
                alt54 = cdfa54.predict(this, this->get_rec(), this->get_istream(), cdfa54 );
                if  (this->hasException())
                {
                    goto ruleargumentEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }

                switch (alt54)
                {
            	case 1:
            	    // PLSQLCommons.g:253:11: ( id EQUALS_OP GREATER_THAN_OP )=> id EQUALS_OP GREATER_THAN_OP
            	    {
            	        this->followPush(FOLLOW_id_in_argument1720);
            	        id();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleargumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_argument1722);
            	        if  (this->hasException())
            	        {
            	            goto ruleargumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(GREATER_THAN_OP, &FOLLOW_GREATER_THAN_OP_in_argument1724);
            	        if  (this->hasException())
            	        {
            	            goto ruleargumentEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_expression_wrapper_in_argument1728);
            m_gPLSQLParser->expression_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleargumentEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleargumentEx; /* Prevent compiler warnings */
    ruleargumentEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end argument */

/**
 * $ANTLR start type_spec
 * PLSQLCommons.g:256:1: type_spec : ( datatype | ( ref_key )? type_name ( percent_rowtype_key | percent_type_key )? );
 */
void
PLSQLParser_PLSQLCommons::type_spec()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:257:5: ( datatype | ( ref_key )? type_name ( percent_rowtype_key | percent_type_key )? )

            ANTLR_UINT32 alt57;

            alt57=2;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    int LA57_1 = this->LA(2);
            		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "DAY")))||((equalsIgnoreCase(LT(1)->getText(), "NUMERIC")))||((equalsIgnoreCase(LT(1)->getText(), "BINARY_INTEGER")))||((equalsIgnoreCase(LT(1)->getText(), "REAL")))||((equalsIgnoreCase(LT(1)->getText(), "STRING")))||((equalsIgnoreCase(LT(1)->getText(), "POSITIVE")))||((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_ABBR")))||((equalsIgnoreCase(LT(1)->getText(), "DEC")))||((equalsIgnoreCase(LT(1)->getText(), "ROWID")))||((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_HOUR")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_TZ_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "SIGNTYPE")))||((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE")))||((equalsIgnoreCase(LT(1)->getText(), "LONG")))||((equalsIgnoreCase(LT(1)->getText(), "RAW")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_LTZ_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "VARCHAR")))||((equalsIgnoreCase(LT(1)->getText(), "CLOB")))||((equalsIgnoreCase(LT(1)->getText(), "YEAR")))||((equalsIgnoreCase(LT(1)->getText(), "CHAR")))||((equalsIgnoreCase(LT(1)->getText(), "CHARACTER")))||((equalsIgnoreCase(LT(1)->getText(), "PLS_INTEGER")))||((equalsIgnoreCase(LT(1)->getText(), "SECOND")))||((equalsIgnoreCase(LT(1)->getText(), "NVARCHAR2")))||((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_MINUTE")))||((equalsIgnoreCase(LT(1)->getText(), "NATURAL")))||((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||((equalsIgnoreCase(LT(1)->getText(), "HOUR")))||((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_REGION")))||((equalsIgnoreCase(LT(1)->getText(), "POSITIVEN")))||((equalsIgnoreCase(LT(1)->getText(), "YMINTERVAL_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "INT")))||((equalsIgnoreCase(LT(1)->getText(), "INTEGER")))||((equalsIgnoreCase(LT(1)->getText(), "VARCHAR2")))||((equalsIgnoreCase(LT(1)->getText(), "MINUTE")))||((equalsIgnoreCase(LT(1)->getText(), "DOUBLE")))||((equalsIgnoreCase(LT(1)->getText(), "FLOAT")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "NCLOB")))||((equalsIgnoreCase(LT(1)->getText(), "NATURALN")))||((equalsIgnoreCase(LT(1)->getText(), "NUMBER")))||((equalsIgnoreCase(LT(1)->getText(), "DECIMAL")))||((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT")))||((equalsIgnoreCase(LT(1)->getText(), "NCHAR")))||((equalsIgnoreCase(LT(1)->getText(), "MONTH")))||((equalsIgnoreCase(LT(1)->getText(), "SMALLINT")))||((equalsIgnoreCase(LT(1)->getText(), "MLSLABEL")))||((equalsIgnoreCase(LT(1)->getText(), "UROWID")))||((equalsIgnoreCase(LT(1)->getText(), "BOOLEAN")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP")))||((equalsIgnoreCase(LT(1)->getText(), "DSINTERVAL_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "SIMPLE_INTEGER")))||((equalsIgnoreCase(LT(1)->getText(), "BLOB")))||((equalsIgnoreCase(LT(1)->getText(), "BFILE"))))))
            		    {
            		        alt57=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt57=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 57 );
            		        ex->set_state( 1 );


            		        goto ruletype_specEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_DATE:
            	{
            		alt57=1;
            	}
                break;
            case DELIMITED_ID:
            	{
            		alt57=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 57 );
                ex->set_state( 0 );


                goto ruletype_specEx;

            }

            switch (alt57)
            {
        	case 1:
        	    // PLSQLCommons.g:257:11: datatype
        	    {
        	        this->followPush(FOLLOW_datatype_in_type_spec1749);
        	        datatype();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletype_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:258:10: ( ref_key )? type_name ( percent_rowtype_key | percent_type_key )?
        	    {
        	        // PLSQLCommons.g:258:10: ( ref_key )?
        	        {
        	            int alt55=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    int LA55_1 = this->LA(2);
        	                		    if ( (LA55_1 == REGULAR_ID))
        	                		    {
        	                		        {
        	                		            int LA55_3 = this->LA(3);
        	                		            if ( ((equalsIgnoreCase(LT(1)->getText(), "REF"))))
        	                		            {
        	                		                alt55=1;
        	                		            }
        	                		        }
        	                		    }
        	                		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "REF"))) && (LA55_1 == DELIMITED_ID))
        	                		    {
        	                		        alt55=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt55)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:258:10: ref_key
        	        	    {
        	        	        this->followPush(FOLLOW_ref_key_in_type_spec1760);
        	        	        m_gPLSQLParser->ref_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruletype_specEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_type_name_in_type_spec1763);
        	        type_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletype_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:258:29: ( percent_rowtype_key | percent_type_key )?
        	        {
        	            int alt56=3;
        	            {
        	                int LA56_0 = this->LA(1);
        	                if ( ((((equalsIgnoreCase(LT(2)->getText(), "TYPE")))||((equalsIgnoreCase(LT(2)->getText(), "ROWTYPE"))))) && (LA56_0 == PERCENT))
        	                {
        	                    {
        	                        int LA56_1 = this->LA(2);
        	                        if ( ((((equalsIgnoreCase(LT(2)->getText(), "TYPE")))||((equalsIgnoreCase(LT(2)->getText(), "ROWTYPE"))))) && (LA56_1 == REGULAR_ID))
        	                        {
        	                            {
        	                                int LA56_3 = this->LA(3);
        	                                if ( ((equalsIgnoreCase(LT(2)->getText(), "ROWTYPE"))))
        	                                {
        	                                    alt56=1;
        	                                }
        	                                else if ( ((equalsIgnoreCase(LT(2)->getText(), "TYPE"))))
        	                                {
        	                                    alt56=2;
        	                                }
        	                            }
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt56)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:258:30: percent_rowtype_key
        	        	    {
        	        	        this->followPush(FOLLOW_percent_rowtype_key_in_type_spec1766);
        	        	        m_gPLSQLParser->percent_rowtype_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruletype_specEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQLCommons.g:258:50: percent_type_key
        	        	    {
        	        	        this->followPush(FOLLOW_percent_type_key_in_type_spec1768);
        	        	        m_gPLSQLParser->percent_type_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruletype_specEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruletype_specEx; /* Prevent compiler warnings */
    ruletype_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end type_spec */

/**
 * $ANTLR start datatype
 * PLSQLCommons.g:261:1: datatype : ( native_datatype_element ( precision_part )? ( with_key ( local_key )? time_key zone_key )? | interval_key ( year_key | day_key ) ( LEFT_PAREN expression_wrapper RIGHT_PAREN )? to_key ( month_key | second_key ) ( LEFT_PAREN expression_wrapper RIGHT_PAREN )? );
 */
void
PLSQLParser_PLSQLCommons::datatype()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:262:5: ( native_datatype_element ( precision_part )? ( with_key ( local_key )? time_key zone_key )? | interval_key ( year_key | day_key ) ( LEFT_PAREN expression_wrapper RIGHT_PAREN )? to_key ( month_key | second_key ) ( LEFT_PAREN expression_wrapper RIGHT_PAREN )? )

            ANTLR_UINT32 alt65;

            alt65=2;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    int LA65_1 = this->LA(2);
            		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "DAY")))||((equalsIgnoreCase(LT(1)->getText(), "NUMERIC")))||((equalsIgnoreCase(LT(1)->getText(), "BINARY_INTEGER")))||((equalsIgnoreCase(LT(1)->getText(), "REAL")))||((equalsIgnoreCase(LT(1)->getText(), "STRING")))||((equalsIgnoreCase(LT(1)->getText(), "POSITIVE")))||((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_ABBR")))||((equalsIgnoreCase(LT(1)->getText(), "DEC")))||((equalsIgnoreCase(LT(1)->getText(), "ROWID")))||((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_HOUR")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_TZ_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "SIGNTYPE")))||((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE")))||((equalsIgnoreCase(LT(1)->getText(), "LONG")))||((equalsIgnoreCase(LT(1)->getText(), "RAW")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_LTZ_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "CLOB")))||((equalsIgnoreCase(LT(1)->getText(), "VARCHAR")))||((equalsIgnoreCase(LT(1)->getText(), "CHARACTER")))||((equalsIgnoreCase(LT(1)->getText(), "CHAR")))||((equalsIgnoreCase(LT(1)->getText(), "YEAR")))||((equalsIgnoreCase(LT(1)->getText(), "PLS_INTEGER")))||((equalsIgnoreCase(LT(1)->getText(), "SECOND")))||((equalsIgnoreCase(LT(1)->getText(), "NVARCHAR2")))||((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_MINUTE")))||((equalsIgnoreCase(LT(1)->getText(), "NATURAL")))||((equalsIgnoreCase(LT(1)->getText(), "HOUR")))||((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_REGION")))||((equalsIgnoreCase(LT(1)->getText(), "POSITIVEN")))||((equalsIgnoreCase(LT(1)->getText(), "YMINTERVAL_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "INT")))||((equalsIgnoreCase(LT(1)->getText(), "INTEGER")))||((equalsIgnoreCase(LT(1)->getText(), "VARCHAR2")))||((equalsIgnoreCase(LT(1)->getText(), "MINUTE")))||((equalsIgnoreCase(LT(1)->getText(), "DOUBLE")))||((equalsIgnoreCase(LT(1)->getText(), "FLOAT")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "NCLOB")))||((equalsIgnoreCase(LT(1)->getText(), "NATURALN")))||((equalsIgnoreCase(LT(1)->getText(), "NUMBER")))||((equalsIgnoreCase(LT(1)->getText(), "DECIMAL")))||((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT")))||((equalsIgnoreCase(LT(1)->getText(), "NCHAR")))||((equalsIgnoreCase(LT(1)->getText(), "MONTH")))||((equalsIgnoreCase(LT(1)->getText(), "SMALLINT")))||((equalsIgnoreCase(LT(1)->getText(), "MLSLABEL")))||((equalsIgnoreCase(LT(1)->getText(), "UROWID")))||((equalsIgnoreCase(LT(1)->getText(), "BOOLEAN")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP")))||((equalsIgnoreCase(LT(1)->getText(), "DSINTERVAL_UNCONSTRAINED")))||((equalsIgnoreCase(LT(1)->getText(), "SIMPLE_INTEGER")))||((equalsIgnoreCase(LT(1)->getText(), "BFILE")))||((equalsIgnoreCase(LT(1)->getText(), "BLOB"))))))
            		    {
            		        alt65=1;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "INTERVAL"))))
            		    {
            		        alt65=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 65 );
            		        ex->set_state( 1 );


            		        goto ruledatatypeEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_DATE:
            	{
            		alt65=1;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 65 );
                ex->set_state( 0 );


                goto ruledatatypeEx;

            }

            switch (alt65)
            {
        	case 1:
        	    // PLSQLCommons.g:262:10: native_datatype_element ( precision_part )? ( with_key ( local_key )? time_key zone_key )?
        	    {
        	        this->followPush(FOLLOW_native_datatype_element_in_datatype1790);
        	        native_datatype_element();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledatatypeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:263:9: ( precision_part )?
        	        {
        	            int alt58=2;
        	            switch ( this->LA(1) )
        	            {
        	                case LEFT_PAREN:
        	                	{
        	                		switch ( this->LA(2) )
        	                		{
        	                		    case APPROXIMATE_NUM_LIT:
        	                		    case EXACT_NUM_LIT:
        	                		    case UNSIGNED_INTEGER:
        	                		    	{
        	                		    		alt58=1;
        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt58)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:263:9: precision_part
        	        	    {
        	        	        this->followPush(FOLLOW_precision_part_in_datatype1800);
        	        	        precision_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLCommons.g:264:9: ( with_key ( local_key )? time_key zone_key )?
        	        {
        	            int alt60=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_WITH:
        	                	{
        	                		alt60=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt60)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:264:10: with_key ( local_key )? time_key zone_key
        	        	    {
        	        	        this->followPush(FOLLOW_with_key_in_datatype1812);
        	        	        m_gPLSQLParser->with_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQLCommons.g:264:19: ( local_key )?
        	        	        {
        	        	            int alt59=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case REGULAR_ID:
        	        	                	{
        	        	                		switch ( this->LA(2) )
        	        	                		{
        	        	                		    case REGULAR_ID:
        	        	                		    	{
        	        	                		    		switch ( this->LA(3) )
        	        	                		    		{
        	        	                		    		    case REGULAR_ID:
        	        	                		    		    	{
        	        	                		    		    		{
        	        	                		    		    		    int LA59_4 = this->LA(4);
        	        	                		    		    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "LOCAL"))))
        	        	                		    		    		    {
        	        	                		    		    		        alt59=1;
        	        	                		    		    		    }
        	        	                		    		    		}
        	        	                		    		    	}
        	        	                		    		        break;
        	        	                		    		}

        	        	                		    	}
        	        	                		        break;
        	        	                		}

        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt59)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQLCommons.g:264:19: local_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_local_key_in_datatype1814);
        	        	        	        m_gPLSQLParser->local_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruledatatypeEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        this->followPush(FOLLOW_time_key_in_datatype1817);
        	        	        m_gPLSQLParser->time_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_zone_key_in_datatype1819);
        	        	        m_gPLSQLParser->zone_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:265:10: interval_key ( year_key | day_key ) ( LEFT_PAREN expression_wrapper RIGHT_PAREN )? to_key ( month_key | second_key ) ( LEFT_PAREN expression_wrapper RIGHT_PAREN )?
        	    {
        	        this->followPush(FOLLOW_interval_key_in_datatype1832);
        	        m_gPLSQLParser->interval_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledatatypeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:265:23: ( year_key | day_key )
        	        {
        	            int alt61=2;
        	            {
        	                int LA61_0 = this->LA(1);
        	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "DAY")))||((equalsIgnoreCase(LT(1)->getText(), "YEAR"))))) && (LA61_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA61_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "YEAR"))))
        	                        {
        	                            alt61=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "DAY"))))
        	                        {
        	                            alt61=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 61 );
        	                            ex->set_state( 1 );


        	                            goto ruledatatypeEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 61 );
        	                    ex->set_state( 0 );


        	                    goto ruledatatypeEx;

        	                }
        	            }
        	            switch (alt61)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:265:24: year_key
        	        	    {
        	        	        this->followPush(FOLLOW_year_key_in_datatype1835);
        	        	        m_gPLSQLParser->year_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQLCommons.g:265:33: day_key
        	        	    {
        	        	        this->followPush(FOLLOW_day_key_in_datatype1837);
        	        	        m_gPLSQLParser->day_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLCommons.g:266:17: ( LEFT_PAREN expression_wrapper RIGHT_PAREN )?
        	        {
        	            int alt62=2;
        	            switch ( this->LA(1) )
        	            {
        	                case LEFT_PAREN:
        	                	{
        	                		alt62=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt62)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:266:18: LEFT_PAREN expression_wrapper RIGHT_PAREN
        	        	    {
        	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_datatype1857);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_expression_wrapper_in_datatype1859);
        	        	        m_gPLSQLParser->expression_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_datatype1861);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_to_key_in_datatype1878);
        	        m_gPLSQLParser->to_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledatatypeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:267:20: ( month_key | second_key )
        	        {
        	            int alt63=2;
        	            switch ( this->LA(1) )
        	            {
        	            case REGULAR_ID:
        	            	{
        	            		{
        	            		    int LA63_1 = this->LA(2);
        	            		    if ( ((equalsIgnoreCase(LT(1)->getText(), "MONTH"))))
        	            		    {
        	            		        alt63=1;
        	            		    }
        	            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SECOND"))))
        	            		    {
        	            		        alt63=2;
        	            		    }
        	            		    else
        	            		    {
        	            		        if (this->get_backtracking()>0)
        	            		        {
        	            		            this->set_failedflag( true );
        	            		            return ;
        	            		        }


        	            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            		        ex->set_decisionNum( 63 );
        	            		        ex->set_state( 1 );


        	            		        goto ruledatatypeEx;

        	            		    }
        	            		}
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return ;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 63 );
        	                ex->set_state( 0 );


        	                goto ruledatatypeEx;

        	            }

        	            switch (alt63)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:267:21: month_key
        	        	    {
        	        	        this->followPush(FOLLOW_month_key_in_datatype1881);
        	        	        m_gPLSQLParser->month_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQLCommons.g:267:31: second_key
        	        	    {
        	        	        this->followPush(FOLLOW_second_key_in_datatype1883);
        	        	        m_gPLSQLParser->second_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLCommons.g:268:17: ( LEFT_PAREN expression_wrapper RIGHT_PAREN )?
        	        {
        	            int alt64=2;
        	            switch ( this->LA(1) )
        	            {
        	                case LEFT_PAREN:
        	                	{
        	                		alt64=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt64)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:268:18: LEFT_PAREN expression_wrapper RIGHT_PAREN
        	        	    {
        	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_datatype1904);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_expression_wrapper_in_datatype1906);
        	        	        m_gPLSQLParser->expression_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_datatype1908);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledatatypeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruledatatypeEx; /* Prevent compiler warnings */
    ruledatatypeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end datatype */

/**
 * $ANTLR start precision_part
 * PLSQLCommons.g:271:1: precision_part : LEFT_PAREN numeric ( COMMA numeric )? ( char_key | byte_key )? RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQLCommons::precision_part()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:272:5: ( LEFT_PAREN numeric ( COMMA numeric )? ( char_key | byte_key )? RIGHT_PAREN )
        // PLSQLCommons.g:272:10: LEFT_PAREN numeric ( COMMA numeric )? ( char_key | byte_key )? RIGHT_PAREN
        {
             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_precision_part1930);
            if  (this->hasException())
            {
                goto ruleprecision_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_numeric_in_precision_part1932);
            numeric();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprecision_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:272:29: ( COMMA numeric )?
            {
                int alt66=2;
                switch ( this->LA(1) )
                {
                    case COMMA:
                    	{
                    		alt66=1;
                    	}
                        break;
                }

                switch (alt66)
                {
            	case 1:
            	    // PLSQLCommons.g:272:30: COMMA numeric
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_precision_part1935);
            	        if  (this->hasException())
            	        {
            	            goto ruleprecision_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_numeric_in_precision_part1937);
            	        numeric();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprecision_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLCommons.g:272:46: ( char_key | byte_key )?
            {
                int alt67=3;
                {
                    int LA67_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "BYTE")))||((equalsIgnoreCase(LT(1)->getText(), "CHAR"))))) && (LA67_0 == REGULAR_ID))
                    {
                        {
                            int LA67_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "CHAR"))))
                            {
                                alt67=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "BYTE"))))
                            {
                                alt67=2;
                            }
                        }
                    }
                }
                switch (alt67)
                {
            	case 1:
            	    // PLSQLCommons.g:272:47: char_key
            	    {
            	        this->followPush(FOLLOW_char_key_in_precision_part1942);
            	        m_gPLSQLParser->char_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprecision_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:272:58: byte_key
            	    {
            	        this->followPush(FOLLOW_byte_key_in_precision_part1946);
            	        m_gPLSQLParser->byte_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprecision_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_precision_part1950);
            if  (this->hasException())
            {
                goto ruleprecision_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprecision_partEx; /* Prevent compiler warnings */
    ruleprecision_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end precision_part */

/**
 * $ANTLR start native_datatype_element
 * PLSQLCommons.g:275:1: native_datatype_element : ( binary_integer_key | pls_integer_key | natural_key | binary_float_key | binary_double_key | naturaln_key | positive_key | positiven_key | signtype_key | simple_integer_key | nvarchar2_key | dec_key | integer_key | int_key | numeric_key | smallint_key | number_key | decimal_key | double_key ( precision_key )? | float_key | real_key | nchar_key | long_key ( raw_key )? | char_key | character_key | varchar2_key | varchar_key | string_key | raw_key | boolean_key | date_key | rowid_key | urowid_key | year_key | month_key | day_key | hour_key | minute_key | second_key | timezone_hour_key | timezone_minute_key | timezone_region_key | timezone_abbr_key | timestamp_key | timestamp_unconstrained_key | timestamp_tz_unconstrained_key | timestamp_ltz_unconstrained_key | yminterval_unconstrained_key | dsinterval_unconstrained_key | bfile_key | blob_key | clob_key | nclob_key | mlslabel_key );
 */
void
PLSQLParser_PLSQLCommons::native_datatype_element()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:276:5: ( binary_integer_key | pls_integer_key | natural_key | binary_float_key | binary_double_key | naturaln_key | positive_key | positiven_key | signtype_key | simple_integer_key | nvarchar2_key | dec_key | integer_key | int_key | numeric_key | smallint_key | number_key | decimal_key | double_key ( precision_key )? | float_key | real_key | nchar_key | long_key ( raw_key )? | char_key | character_key | varchar2_key | varchar_key | string_key | raw_key | boolean_key | date_key | rowid_key | urowid_key | year_key | month_key | day_key | hour_key | minute_key | second_key | timezone_hour_key | timezone_minute_key | timezone_region_key | timezone_abbr_key | timestamp_key | timestamp_unconstrained_key | timestamp_tz_unconstrained_key | timestamp_ltz_unconstrained_key | yminterval_unconstrained_key | dsinterval_unconstrained_key | bfile_key | blob_key | clob_key | nclob_key | mlslabel_key )

            ANTLR_UINT32 alt70;

            alt70=54;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    int LA70_1 = this->LA(2);
            		    if ( ((equalsIgnoreCase(LT(1)->getText(), "BINARY_INTEGER"))))
            		    {
            		        alt70=1;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "PLS_INTEGER"))))
            		    {
            		        alt70=2;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "NATURAL"))))
            		    {
            		        alt70=3;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT"))))
            		    {
            		        alt70=4;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE"))))
            		    {
            		        alt70=5;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "NATURALN"))))
            		    {
            		        alt70=6;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "POSITIVE"))))
            		    {
            		        alt70=7;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "POSITIVEN"))))
            		    {
            		        alt70=8;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SIGNTYPE"))))
            		    {
            		        alt70=9;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SIMPLE_INTEGER"))))
            		    {
            		        alt70=10;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "NVARCHAR2"))))
            		    {
            		        alt70=11;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "DEC"))))
            		    {
            		        alt70=12;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "INTEGER"))))
            		    {
            		        alt70=13;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "INT"))))
            		    {
            		        alt70=14;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "NUMERIC"))))
            		    {
            		        alt70=15;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SMALLINT"))))
            		    {
            		        alt70=16;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "NUMBER"))))
            		    {
            		        alt70=17;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "DECIMAL"))))
            		    {
            		        alt70=18;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "DOUBLE"))))
            		    {
            		        alt70=19;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "FLOAT"))))
            		    {
            		        alt70=20;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "REAL"))))
            		    {
            		        alt70=21;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "NCHAR"))))
            		    {
            		        alt70=22;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "LONG"))))
            		    {
            		        alt70=23;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "CHAR"))))
            		    {
            		        alt70=24;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "CHARACTER"))))
            		    {
            		        alt70=25;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "VARCHAR2"))))
            		    {
            		        alt70=26;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "VARCHAR"))))
            		    {
            		        alt70=27;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "STRING"))))
            		    {
            		        alt70=28;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "RAW"))))
            		    {
            		        alt70=29;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "BOOLEAN"))))
            		    {
            		        alt70=30;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "ROWID"))))
            		    {
            		        alt70=32;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "UROWID"))))
            		    {
            		        alt70=33;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "YEAR"))))
            		    {
            		        alt70=34;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "MONTH"))))
            		    {
            		        alt70=35;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "DAY"))))
            		    {
            		        alt70=36;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "HOUR"))))
            		    {
            		        alt70=37;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "MINUTE"))))
            		    {
            		        alt70=38;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SECOND"))))
            		    {
            		        alt70=39;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_HOUR"))))
            		    {
            		        alt70=40;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_MINUTE"))))
            		    {
            		        alt70=41;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_REGION"))))
            		    {
            		        alt70=42;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_ABBR"))))
            		    {
            		        alt70=43;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP"))))
            		    {
            		        alt70=44;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_UNCONSTRAINED"))))
            		    {
            		        alt70=45;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_TZ_UNCONSTRAINED"))))
            		    {
            		        alt70=46;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_LTZ_UNCONSTRAINED"))))
            		    {
            		        alt70=47;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "YMINTERVAL_UNCONSTRAINED"))))
            		    {
            		        alt70=48;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "DSINTERVAL_UNCONSTRAINED"))))
            		    {
            		        alt70=49;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "BFILE"))))
            		    {
            		        alt70=50;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "BLOB"))))
            		    {
            		        alt70=51;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "CLOB"))))
            		    {
            		        alt70=52;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "NCLOB"))))
            		    {
            		        alt70=53;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "MLSLABEL"))))
            		    {
            		        alt70=54;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 70 );
            		        ex->set_state( 1 );


            		        goto rulenative_datatype_elementEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_DATE:
            	{
            		alt70=31;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 70 );
                ex->set_state( 0 );


                goto rulenative_datatype_elementEx;

            }

            switch (alt70)
            {
        	case 1:
        	    // PLSQLCommons.g:276:10: binary_integer_key
        	    {
        	        this->followPush(FOLLOW_binary_integer_key_in_native_datatype_element1970);
        	        m_gPLSQLParser->binary_integer_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:277:10: pls_integer_key
        	    {
        	        this->followPush(FOLLOW_pls_integer_key_in_native_datatype_element1981);
        	        m_gPLSQLParser->pls_integer_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLCommons.g:278:10: natural_key
        	    {
        	        this->followPush(FOLLOW_natural_key_in_native_datatype_element1992);
        	        m_gPLSQLParser->natural_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQLCommons.g:279:10: binary_float_key
        	    {
        	        this->followPush(FOLLOW_binary_float_key_in_native_datatype_element2003);
        	        m_gPLSQLParser->binary_float_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQLCommons.g:280:10: binary_double_key
        	    {
        	        this->followPush(FOLLOW_binary_double_key_in_native_datatype_element2014);
        	        m_gPLSQLParser->binary_double_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // PLSQLCommons.g:281:10: naturaln_key
        	    {
        	        this->followPush(FOLLOW_naturaln_key_in_native_datatype_element2025);
        	        m_gPLSQLParser->naturaln_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 7:
        	    // PLSQLCommons.g:282:10: positive_key
        	    {
        	        this->followPush(FOLLOW_positive_key_in_native_datatype_element2036);
        	        m_gPLSQLParser->positive_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 8:
        	    // PLSQLCommons.g:283:10: positiven_key
        	    {
        	        this->followPush(FOLLOW_positiven_key_in_native_datatype_element2047);
        	        m_gPLSQLParser->positiven_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 9:
        	    // PLSQLCommons.g:284:10: signtype_key
        	    {
        	        this->followPush(FOLLOW_signtype_key_in_native_datatype_element2058);
        	        m_gPLSQLParser->signtype_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 10:
        	    // PLSQLCommons.g:285:10: simple_integer_key
        	    {
        	        this->followPush(FOLLOW_simple_integer_key_in_native_datatype_element2069);
        	        m_gPLSQLParser->simple_integer_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 11:
        	    // PLSQLCommons.g:286:10: nvarchar2_key
        	    {
        	        this->followPush(FOLLOW_nvarchar2_key_in_native_datatype_element2080);
        	        m_gPLSQLParser->nvarchar2_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 12:
        	    // PLSQLCommons.g:287:10: dec_key
        	    {
        	        this->followPush(FOLLOW_dec_key_in_native_datatype_element2091);
        	        m_gPLSQLParser->dec_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 13:
        	    // PLSQLCommons.g:288:10: integer_key
        	    {
        	        this->followPush(FOLLOW_integer_key_in_native_datatype_element2102);
        	        m_gPLSQLParser->integer_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 14:
        	    // PLSQLCommons.g:289:10: int_key
        	    {
        	        this->followPush(FOLLOW_int_key_in_native_datatype_element2113);
        	        m_gPLSQLParser->int_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 15:
        	    // PLSQLCommons.g:290:10: numeric_key
        	    {
        	        this->followPush(FOLLOW_numeric_key_in_native_datatype_element2124);
        	        m_gPLSQLParser->numeric_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 16:
        	    // PLSQLCommons.g:291:10: smallint_key
        	    {
        	        this->followPush(FOLLOW_smallint_key_in_native_datatype_element2135);
        	        m_gPLSQLParser->smallint_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 17:
        	    // PLSQLCommons.g:292:10: number_key
        	    {
        	        this->followPush(FOLLOW_number_key_in_native_datatype_element2146);
        	        m_gPLSQLParser->number_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 18:
        	    // PLSQLCommons.g:293:10: decimal_key
        	    {
        	        this->followPush(FOLLOW_decimal_key_in_native_datatype_element2157);
        	        m_gPLSQLParser->decimal_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 19:
        	    // PLSQLCommons.g:294:10: double_key ( precision_key )?
        	    {
        	        this->followPush(FOLLOW_double_key_in_native_datatype_element2169);
        	        m_gPLSQLParser->double_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:294:21: ( precision_key )?
        	        {
        	            int alt68=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    int LA68_1 = this->LA(2);
        	                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "PRECISION"))))
        	                		    {
        	                		        alt68=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt68)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:294:21: precision_key
        	        	    {
        	        	        this->followPush(FOLLOW_precision_key_in_native_datatype_element2171);
        	        	        m_gPLSQLParser->precision_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulenative_datatype_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 20:
        	    // PLSQLCommons.g:295:10: float_key
        	    {
        	        this->followPush(FOLLOW_float_key_in_native_datatype_element2183);
        	        m_gPLSQLParser->float_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 21:
        	    // PLSQLCommons.g:296:10: real_key
        	    {
        	        this->followPush(FOLLOW_real_key_in_native_datatype_element2194);
        	        m_gPLSQLParser->real_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 22:
        	    // PLSQLCommons.g:297:10: nchar_key
        	    {
        	        this->followPush(FOLLOW_nchar_key_in_native_datatype_element2205);
        	        m_gPLSQLParser->nchar_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 23:
        	    // PLSQLCommons.g:298:10: long_key ( raw_key )?
        	    {
        	        this->followPush(FOLLOW_long_key_in_native_datatype_element2216);
        	        m_gPLSQLParser->long_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:298:19: ( raw_key )?
        	        {
        	            int alt69=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    int LA69_1 = this->LA(2);
        	                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "RAW"))))
        	                		    {
        	                		        alt69=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt69)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:298:19: raw_key
        	        	    {
        	        	        this->followPush(FOLLOW_raw_key_in_native_datatype_element2218);
        	        	        m_gPLSQLParser->raw_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulenative_datatype_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 24:
        	    // PLSQLCommons.g:299:10: char_key
        	    {
        	        this->followPush(FOLLOW_char_key_in_native_datatype_element2230);
        	        m_gPLSQLParser->char_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 25:
        	    // PLSQLCommons.g:300:10: character_key
        	    {
        	        this->followPush(FOLLOW_character_key_in_native_datatype_element2243);
        	        m_gPLSQLParser->character_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 26:
        	    // PLSQLCommons.g:301:10: varchar2_key
        	    {
        	        this->followPush(FOLLOW_varchar2_key_in_native_datatype_element2255);
        	        m_gPLSQLParser->varchar2_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 27:
        	    // PLSQLCommons.g:302:10: varchar_key
        	    {
        	        this->followPush(FOLLOW_varchar_key_in_native_datatype_element2266);
        	        m_gPLSQLParser->varchar_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 28:
        	    // PLSQLCommons.g:303:10: string_key
        	    {
        	        this->followPush(FOLLOW_string_key_in_native_datatype_element2277);
        	        m_gPLSQLParser->string_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 29:
        	    // PLSQLCommons.g:304:10: raw_key
        	    {
        	        this->followPush(FOLLOW_raw_key_in_native_datatype_element2288);
        	        m_gPLSQLParser->raw_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 30:
        	    // PLSQLCommons.g:305:10: boolean_key
        	    {
        	        this->followPush(FOLLOW_boolean_key_in_native_datatype_element2299);
        	        m_gPLSQLParser->boolean_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 31:
        	    // PLSQLCommons.g:306:10: date_key
        	    {
        	        this->followPush(FOLLOW_date_key_in_native_datatype_element2310);
        	        m_gPLSQLParser->date_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 32:
        	    // PLSQLCommons.g:307:10: rowid_key
        	    {
        	        this->followPush(FOLLOW_rowid_key_in_native_datatype_element2321);
        	        m_gPLSQLParser->rowid_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 33:
        	    // PLSQLCommons.g:308:10: urowid_key
        	    {
        	        this->followPush(FOLLOW_urowid_key_in_native_datatype_element2332);
        	        m_gPLSQLParser->urowid_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 34:
        	    // PLSQLCommons.g:309:10: year_key
        	    {
        	        this->followPush(FOLLOW_year_key_in_native_datatype_element2343);
        	        m_gPLSQLParser->year_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 35:
        	    // PLSQLCommons.g:310:10: month_key
        	    {
        	        this->followPush(FOLLOW_month_key_in_native_datatype_element2354);
        	        m_gPLSQLParser->month_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 36:
        	    // PLSQLCommons.g:311:10: day_key
        	    {
        	        this->followPush(FOLLOW_day_key_in_native_datatype_element2365);
        	        m_gPLSQLParser->day_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 37:
        	    // PLSQLCommons.g:312:10: hour_key
        	    {
        	        this->followPush(FOLLOW_hour_key_in_native_datatype_element2376);
        	        m_gPLSQLParser->hour_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 38:
        	    // PLSQLCommons.g:313:10: minute_key
        	    {
        	        this->followPush(FOLLOW_minute_key_in_native_datatype_element2387);
        	        m_gPLSQLParser->minute_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 39:
        	    // PLSQLCommons.g:314:10: second_key
        	    {
        	        this->followPush(FOLLOW_second_key_in_native_datatype_element2398);
        	        m_gPLSQLParser->second_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 40:
        	    // PLSQLCommons.g:315:10: timezone_hour_key
        	    {
        	        this->followPush(FOLLOW_timezone_hour_key_in_native_datatype_element2409);
        	        m_gPLSQLParser->timezone_hour_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 41:
        	    // PLSQLCommons.g:316:10: timezone_minute_key
        	    {
        	        this->followPush(FOLLOW_timezone_minute_key_in_native_datatype_element2420);
        	        m_gPLSQLParser->timezone_minute_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 42:
        	    // PLSQLCommons.g:317:10: timezone_region_key
        	    {
        	        this->followPush(FOLLOW_timezone_region_key_in_native_datatype_element2431);
        	        m_gPLSQLParser->timezone_region_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 43:
        	    // PLSQLCommons.g:318:10: timezone_abbr_key
        	    {
        	        this->followPush(FOLLOW_timezone_abbr_key_in_native_datatype_element2442);
        	        m_gPLSQLParser->timezone_abbr_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 44:
        	    // PLSQLCommons.g:319:10: timestamp_key
        	    {
        	        this->followPush(FOLLOW_timestamp_key_in_native_datatype_element2453);
        	        m_gPLSQLParser->timestamp_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 45:
        	    // PLSQLCommons.g:320:10: timestamp_unconstrained_key
        	    {
        	        this->followPush(FOLLOW_timestamp_unconstrained_key_in_native_datatype_element2464);
        	        m_gPLSQLParser->timestamp_unconstrained_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 46:
        	    // PLSQLCommons.g:321:10: timestamp_tz_unconstrained_key
        	    {
        	        this->followPush(FOLLOW_timestamp_tz_unconstrained_key_in_native_datatype_element2475);
        	        m_gPLSQLParser->timestamp_tz_unconstrained_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 47:
        	    // PLSQLCommons.g:322:10: timestamp_ltz_unconstrained_key
        	    {
        	        this->followPush(FOLLOW_timestamp_ltz_unconstrained_key_in_native_datatype_element2486);
        	        m_gPLSQLParser->timestamp_ltz_unconstrained_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 48:
        	    // PLSQLCommons.g:323:10: yminterval_unconstrained_key
        	    {
        	        this->followPush(FOLLOW_yminterval_unconstrained_key_in_native_datatype_element2497);
        	        m_gPLSQLParser->yminterval_unconstrained_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 49:
        	    // PLSQLCommons.g:324:10: dsinterval_unconstrained_key
        	    {
        	        this->followPush(FOLLOW_dsinterval_unconstrained_key_in_native_datatype_element2508);
        	        m_gPLSQLParser->dsinterval_unconstrained_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 50:
        	    // PLSQLCommons.g:325:10: bfile_key
        	    {
        	        this->followPush(FOLLOW_bfile_key_in_native_datatype_element2519);
        	        m_gPLSQLParser->bfile_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 51:
        	    // PLSQLCommons.g:326:10: blob_key
        	    {
        	        this->followPush(FOLLOW_blob_key_in_native_datatype_element2530);
        	        m_gPLSQLParser->blob_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 52:
        	    // PLSQLCommons.g:327:10: clob_key
        	    {
        	        this->followPush(FOLLOW_clob_key_in_native_datatype_element2541);
        	        m_gPLSQLParser->clob_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 53:
        	    // PLSQLCommons.g:328:10: nclob_key
        	    {
        	        this->followPush(FOLLOW_nclob_key_in_native_datatype_element2552);
        	        m_gPLSQLParser->nclob_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 54:
        	    // PLSQLCommons.g:329:10: mlslabel_key
        	    {
        	        this->followPush(FOLLOW_mlslabel_key_in_native_datatype_element2563);
        	        m_gPLSQLParser->mlslabel_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenative_datatype_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulenative_datatype_elementEx; /* Prevent compiler warnings */
    rulenative_datatype_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end native_datatype_element */

/**
 * $ANTLR start bind_variable
 * PLSQLCommons.g:332:1: bind_variable : ( BINDVAR | COLON UNSIGNED_INTEGER ) ( ( indicator_key )? ( BINDVAR | COLON UNSIGNED_INTEGER ) )? ( ( PERIOD general_element_part )=> PERIOD general_element_part )* ;
 */
void
PLSQLParser_PLSQLCommons::bind_variable()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:333:5: ( ( BINDVAR | COLON UNSIGNED_INTEGER ) ( ( indicator_key )? ( BINDVAR | COLON UNSIGNED_INTEGER ) )? ( ( PERIOD general_element_part )=> PERIOD general_element_part )* )
        // PLSQLCommons.g:333:10: ( BINDVAR | COLON UNSIGNED_INTEGER ) ( ( indicator_key )? ( BINDVAR | COLON UNSIGNED_INTEGER ) )? ( ( PERIOD general_element_part )=> PERIOD general_element_part )*
        {
            // PLSQLCommons.g:333:10: ( BINDVAR | COLON UNSIGNED_INTEGER )
            {
                int alt71=2;
                switch ( this->LA(1) )
                {
                case BINDVAR:
                	{
                		alt71=1;
                	}
                    break;
                case COLON:
                	{
                		alt71=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 71 );
                    ex->set_state( 0 );


                    goto rulebind_variableEx;

                }

                switch (alt71)
                {
            	case 1:
            	    // PLSQLCommons.g:333:12: BINDVAR
            	    {
            	         this->matchToken(BINDVAR, &FOLLOW_BINDVAR_in_bind_variable2585);
            	        if  (this->hasException())
            	        {
            	            goto rulebind_variableEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:333:22: COLON UNSIGNED_INTEGER
            	    {
            	         this->matchToken(COLON, &FOLLOW_COLON_in_bind_variable2589);
            	        if  (this->hasException())
            	        {
            	            goto rulebind_variableEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_bind_variable2591);
            	        if  (this->hasException())
            	        {
            	            goto rulebind_variableEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLCommons.g:334:10: ( ( indicator_key )? ( BINDVAR | COLON UNSIGNED_INTEGER ) )?
            {
                int alt74=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case BINDVAR:
                    		    	{
                    		    		{
                    		    		    int LA74_4 = this->LA(3);
                    		    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "INDICATOR"))))
                    		    		    {
                    		    		        alt74=1;
                    		    		    }
                    		    		}
                    		    	}
                    		        break;
                    		    case COLON:
                    		    	{
                    		    		switch ( this->LA(3) )
                    		    		{
                    		    		    case UNSIGNED_INTEGER:
                    		    		    	{
                    		    		    		{
                    		    		    		    int LA74_12 = this->LA(4);
                    		    		    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "INDICATOR"))))
                    		    		    		    {
                    		    		    		        alt74=1;
                    		    		    		    }
                    		    		    		}
                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                    case BINDVAR:
                    case COLON:
                    	{
                    		alt74=1;
                    	}
                        break;
                }

                switch (alt74)
                {
            	case 1:
            	    // PLSQLCommons.g:334:12: ( indicator_key )? ( BINDVAR | COLON UNSIGNED_INTEGER )
            	    {
            	        // PLSQLCommons.g:334:12: ( indicator_key )?
            	        {
            	            int alt72=2;
            	            switch ( this->LA(1) )
            	            {
            	                case REGULAR_ID:
            	                	{
            	                		alt72=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt72)
            	            {
            	        	case 1:
            	        	    // PLSQLCommons.g:334:12: indicator_key
            	        	    {
            	        	        this->followPush(FOLLOW_indicator_key_in_bind_variable2605);
            	        	        m_gPLSQLParser->indicator_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulebind_variableEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQLCommons.g:334:27: ( BINDVAR | COLON UNSIGNED_INTEGER )
            	        {
            	            int alt73=2;
            	            switch ( this->LA(1) )
            	            {
            	            case BINDVAR:
            	            	{
            	            		alt73=1;
            	            	}
            	                break;
            	            case COLON:
            	            	{
            	            		alt73=2;
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return ;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 73 );
            	                ex->set_state( 0 );


            	                goto rulebind_variableEx;

            	            }

            	            switch (alt73)
            	            {
            	        	case 1:
            	        	    // PLSQLCommons.g:334:28: BINDVAR
            	        	    {
            	        	         this->matchToken(BINDVAR, &FOLLOW_BINDVAR_in_bind_variable2609);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulebind_variableEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQLCommons.g:334:38: COLON UNSIGNED_INTEGER
            	        	    {
            	        	         this->matchToken(COLON, &FOLLOW_COLON_in_bind_variable2613);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulebind_variableEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	         this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_bind_variable2615);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulebind_variableEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // PLSQLCommons.g:335:10: ( ( PERIOD general_element_part )=> PERIOD general_element_part )*

            for (;;)
            {
                int alt75=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA75_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred19_PLSQLCommons>() )) && (LA75_0 == PERIOD))
                    {
                        alt75=1;
                    }

                }
                switch (alt75)
                {
            	case 1:
            	    // PLSQLCommons.g:335:11: ( PERIOD general_element_part )=> PERIOD general_element_part
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_bind_variable2637);
            	        if  (this->hasException())
            	        {
            	            goto rulebind_variableEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_general_element_part_in_bind_variable2639);
            	        general_element_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulebind_variableEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop75;	/* break out of the loop */
            	    break;
                }
            }
            loop75: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebind_variableEx; /* Prevent compiler warnings */
    rulebind_variableEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end bind_variable */

/**
 * $ANTLR start general_element
 * PLSQLCommons.g:338:1: general_element : general_element_part ( ( PERIOD general_element_part )=> PERIOD general_element_part )* ;
 */
void
PLSQLParser_PLSQLCommons::general_element()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:339:5: ( general_element_part ( ( PERIOD general_element_part )=> PERIOD general_element_part )* )
        // PLSQLCommons.g:339:10: general_element_part ( ( PERIOD general_element_part )=> PERIOD general_element_part )*
        {
            this->followPush(FOLLOW_general_element_part_in_general_element2661);
            general_element_part();

            this->followPop();
            if  (this->hasException())
            {
                goto rulegeneral_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:339:31: ( ( PERIOD general_element_part )=> PERIOD general_element_part )*

            for (;;)
            {
                int alt76=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA76_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred20_PLSQLCommons>() )) && (LA76_0 == PERIOD))
                    {
                        alt76=1;
                    }

                }
                switch (alt76)
                {
            	case 1:
            	    // PLSQLCommons.g:339:32: ( PERIOD general_element_part )=> PERIOD general_element_part
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_general_element2671);
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_general_element_part_in_general_element2673);
            	        general_element_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop76;	/* break out of the loop */
            	    break;
                }
            }
            loop76: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulegeneral_elementEx; /* Prevent compiler warnings */
    rulegeneral_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end general_element */

/**
 * $ANTLR start general_element_part
 * PLSQLCommons.g:342:1: general_element_part : ( INTRODUCER char_set_name )? id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )* ( function_argument )? ;
 */
void
PLSQLParser_PLSQLCommons::general_element_part()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:343:5: ( ( INTRODUCER char_set_name )? id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )* ( function_argument )? )
        // PLSQLCommons.g:343:10: ( INTRODUCER char_set_name )? id_expression ( ( PERIOD id_expression )=> PERIOD id_expression )* ( function_argument )?
        {
            // PLSQLCommons.g:343:10: ( INTRODUCER char_set_name )?
            {
                int alt77=2;
                switch ( this->LA(1) )
                {
                    case INTRODUCER:
                    	{
                    		alt77=1;
                    	}
                        break;
                }

                switch (alt77)
                {
            	case 1:
            	    // PLSQLCommons.g:343:11: INTRODUCER char_set_name
            	    {
            	         this->matchToken(INTRODUCER, &FOLLOW_INTRODUCER_in_general_element_part2696);
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_element_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_char_set_name_in_general_element_part2698);
            	        char_set_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_element_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_id_expression_in_general_element_part2702);
            id_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulegeneral_element_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:344:13: ( ( PERIOD id_expression )=> PERIOD id_expression )*

            for (;;)
            {
                int alt78=2;
                switch ( this->LA(1) )
                {
                case PERIOD:
                	{
                		switch ( this->LA(2) )
                		{
                		case DELIMITED_ID:
                		case REGULAR_ID:
                			{
                				{
                				   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                				    */
                				    int LA78_3 = this->LA(3);
                				    if ( (this->msynpred( antlr3::ClassForwarder<synpred21_PLSQLCommons>() )))
                				    {
                				        alt78=1;
                				    }

                				}
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt78)
                {
            	case 1:
            	    // PLSQLCommons.g:344:14: ( PERIOD id_expression )=> PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_general_element_part2724);
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_element_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_general_element_part2726);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_element_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop78;	/* break out of the loop */
            	    break;
                }
            }
            loop78: ; /* Jump out to here if this rule does not match */


            // PLSQLCommons.g:344:62: ( function_argument )?
            {
                int alt79=2;
                switch ( this->LA(1) )
                {
                    case LEFT_PAREN:
                    	{
                    		alt79=1;
                    	}
                        break;
                }

                switch (alt79)
                {
            	case 1:
            	    // PLSQLCommons.g:344:62: function_argument
            	    {
            	        this->followPush(FOLLOW_function_argument_in_general_element_part2730);
            	        function_argument();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_element_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulegeneral_element_partEx; /* Prevent compiler warnings */
    rulegeneral_element_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end general_element_part */

/**
 * $ANTLR start table_element
 * PLSQLCommons.g:347:1: table_element : ( INTRODUCER char_set_name )? id_expression ( PERIOD id_expression )* ;
 */
void
PLSQLParser_PLSQLCommons::table_element()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:348:5: ( ( INTRODUCER char_set_name )? id_expression ( PERIOD id_expression )* )
        // PLSQLCommons.g:348:10: ( INTRODUCER char_set_name )? id_expression ( PERIOD id_expression )*
        {
            // PLSQLCommons.g:348:10: ( INTRODUCER char_set_name )?
            {
                int alt80=2;
                switch ( this->LA(1) )
                {
                    case INTRODUCER:
                    	{
                    		alt80=1;
                    	}
                        break;
                }

                switch (alt80)
                {
            	case 1:
            	    // PLSQLCommons.g:348:11: INTRODUCER char_set_name
            	    {
            	         this->matchToken(INTRODUCER, &FOLLOW_INTRODUCER_in_table_element2752);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_char_set_name_in_table_element2754);
            	        char_set_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_id_expression_in_table_element2758);
            id_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:348:52: ( PERIOD id_expression )*

            for (;;)
            {
                int alt81=2;
                switch ( this->LA(1) )
                {
                case PERIOD:
                	{
                		alt81=1;
                	}
                    break;

                }

                switch (alt81)
                {
            	case 1:
            	    // PLSQLCommons.g:348:53: PERIOD id_expression
            	    {
            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_table_element2761);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_expression_in_table_element2763);
            	        id_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop81;	/* break out of the loop */
            	    break;
                }
            }
            loop81: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_elementEx; /* Prevent compiler warnings */
    ruletable_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_element */

/**
 * $ANTLR start constant
 * PLSQLCommons.g:355:1: constant : ( timestamp_key ( quoted_string | bind_variable ) ( at_key time_key zone_key quoted_string )? | interval_key ( quoted_string | bind_variable | general_element_part ) ( day_key | hour_key | minute_key | second_key ) ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) ( COMMA ( UNSIGNED_INTEGER | bind_variable ) )? RIGHT_PAREN )? ( to_key ( day_key | hour_key | minute_key | second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )? ) )? | numeric | date_key quoted_string | quoted_string | null_key | true_key | false_key | dbtimezone_key | sessiontimezone_key | minvalue_key | maxvalue_key | default_key );
 */
void
PLSQLParser_PLSQLCommons::constant()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:356:5: ( timestamp_key ( quoted_string | bind_variable ) ( at_key time_key zone_key quoted_string )? | interval_key ( quoted_string | bind_variable | general_element_part ) ( day_key | hour_key | minute_key | second_key ) ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) ( COMMA ( UNSIGNED_INTEGER | bind_variable ) )? RIGHT_PAREN )? ( to_key ( day_key | hour_key | minute_key | second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )? ) )? | numeric | date_key quoted_string | quoted_string | null_key | true_key | false_key | dbtimezone_key | sessiontimezone_key | minvalue_key | maxvalue_key | default_key )

            ANTLR_UINT32 alt94;

            alt94=13;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    int LA94_1 = this->LA(2);
            		    if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP"))))
            		    {
            		        alt94=1;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "INTERVAL"))))
            		    {
            		        alt94=2;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "DBTIMEZONE"))))
            		    {
            		        alt94=9;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SESSIONTIMEZONE"))))
            		    {
            		        alt94=10;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "MINVALUE"))))
            		    {
            		        alt94=11;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "MAXVALUE"))))
            		    {
            		        alt94=12;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 94 );
            		        ex->set_state( 1 );


            		        goto ruleconstantEx;

            		    }
            		}
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case EXACT_NUM_LIT:
            case UNSIGNED_INTEGER:
            	{
            		alt94=3;
            	}
                break;
            case SQL92_RESERVED_DATE:
            	{
            		alt94=4;
            	}
                break;
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case NATIONAL_CHAR_STRING_LIT:
            	{
            		alt94=5;
            	}
                break;
            case SQL92_RESERVED_NULL:
            	{
            		alt94=6;
            	}
                break;
            case SQL92_RESERVED_TRUE:
            	{
            		alt94=7;
            	}
                break;
            case SQL92_RESERVED_FALSE:
            	{
            		alt94=8;
            	}
                break;
            case SQL92_RESERVED_DEFAULT:
            	{
            		alt94=13;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 94 );
                ex->set_state( 0 );


                goto ruleconstantEx;

            }

            switch (alt94)
            {
        	case 1:
        	    // PLSQLCommons.g:356:10: timestamp_key ( quoted_string | bind_variable ) ( at_key time_key zone_key quoted_string )?
        	    {
        	        this->followPush(FOLLOW_timestamp_key_in_constant2789);
        	        m_gPLSQLParser->timestamp_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:356:24: ( quoted_string | bind_variable )
        	        {
        	            int alt82=2;
        	            switch ( this->LA(1) )
        	            {
        	            case CHAR_STRING:
        	            case CHAR_STRING_PERL:
        	            case NATIONAL_CHAR_STRING_LIT:
        	            	{
        	            		alt82=1;
        	            	}
        	                break;
        	            case BINDVAR:
        	            case COLON:
        	            	{
        	            		alt82=2;
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return ;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 82 );
        	                ex->set_state( 0 );


        	                goto ruleconstantEx;

        	            }

        	            switch (alt82)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:356:25: quoted_string
        	        	    {
        	        	        this->followPush(FOLLOW_quoted_string_in_constant2792);
        	        	        quoted_string();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQLCommons.g:356:41: bind_variable
        	        	    {
        	        	        this->followPush(FOLLOW_bind_variable_in_constant2796);
        	        	        bind_variable();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLCommons.g:356:56: ( at_key time_key zone_key quoted_string )?
        	        {
        	            int alt83=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		switch ( this->LA(2) )
        	                		{
        	                		    case REGULAR_ID:
        	                		    	{
        	                		    		switch ( this->LA(3) )
        	                		    		{
        	                		    		    case REGULAR_ID:
        	                		    		    	{
        	                		    		    		switch ( this->LA(4) )
        	                		    		    		{
        	                		    		    		    case CHAR_STRING:
        	                		    		    		    	{
        	                		    		    		    		{
        	                		    		    		    		    int LA83_13 = this->LA(5);
        	                		    		    		    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "AT"))))
        	                		    		    		    		    {
        	                		    		    		    		        alt83=1;
        	                		    		    		    		    }
        	                		    		    		    		}
        	                		    		    		    	}
        	                		    		    		        break;
        	                		    		    		    case CHAR_STRING_PERL:
        	                		    		    		    case NATIONAL_CHAR_STRING_LIT:
        	                		    		    		    	{
        	                		    		    		    		{
        	                		    		    		    		    int LA83_14 = this->LA(5);
        	                		    		    		    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "AT"))))
        	                		    		    		    		    {
        	                		    		    		    		        alt83=1;
        	                		    		    		    		    }
        	                		    		    		    		}
        	                		    		    		    	}
        	                		    		    		        break;
        	                		    		    		}

        	                		    		    	}
        	                		    		        break;
        	                		    		}

        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt83)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:356:57: at_key time_key zone_key quoted_string
        	        	    {
        	        	        this->followPush(FOLLOW_at_key_in_constant2800);
        	        	        m_gPLSQLParser->at_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_time_key_in_constant2802);
        	        	        m_gPLSQLParser->time_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_zone_key_in_constant2804);
        	        	        m_gPLSQLParser->zone_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_quoted_string_in_constant2806);
        	        	        quoted_string();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:357:10: interval_key ( quoted_string | bind_variable | general_element_part ) ( day_key | hour_key | minute_key | second_key ) ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) ( COMMA ( UNSIGNED_INTEGER | bind_variable ) )? RIGHT_PAREN )? ( to_key ( day_key | hour_key | minute_key | second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )? ) )?
        	    {
        	        this->followPush(FOLLOW_interval_key_in_constant2819);
        	        m_gPLSQLParser->interval_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLCommons.g:357:23: ( quoted_string | bind_variable | general_element_part )
        	        {
        	            int alt84=3;
        	            switch ( this->LA(1) )
        	            {
        	            case CHAR_STRING:
        	            case CHAR_STRING_PERL:
        	            case NATIONAL_CHAR_STRING_LIT:
        	            	{
        	            		alt84=1;
        	            	}
        	                break;
        	            case BINDVAR:
        	            case COLON:
        	            	{
        	            		alt84=2;
        	            	}
        	                break;
        	            case DELIMITED_ID:
        	            case INTRODUCER:
        	            case REGULAR_ID:
        	            	{
        	            		alt84=3;
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return ;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 84 );
        	                ex->set_state( 0 );


        	                goto ruleconstantEx;

        	            }

        	            switch (alt84)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:357:24: quoted_string
        	        	    {
        	        	        this->followPush(FOLLOW_quoted_string_in_constant2822);
        	        	        quoted_string();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQLCommons.g:357:40: bind_variable
        	        	    {
        	        	        this->followPush(FOLLOW_bind_variable_in_constant2826);
        	        	        bind_variable();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // PLSQLCommons.g:357:56: general_element_part
        	        	    {
        	        	        this->followPush(FOLLOW_general_element_part_in_constant2830);
        	        	        general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLCommons.g:358:10: ( day_key | hour_key | minute_key | second_key )
        	        {
        	            int alt85=4;
        	            switch ( this->LA(1) )
        	            {
        	            case REGULAR_ID:
        	            	{
        	            		{
        	            		    int LA85_1 = this->LA(2);
        	            		    if ( ((equalsIgnoreCase(LT(1)->getText(), "DAY"))))
        	            		    {
        	            		        alt85=1;
        	            		    }
        	            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "HOUR"))))
        	            		    {
        	            		        alt85=2;
        	            		    }
        	            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "MINUTE"))))
        	            		    {
        	            		        alt85=3;
        	            		    }
        	            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SECOND"))))
        	            		    {
        	            		        alt85=4;
        	            		    }
        	            		    else
        	            		    {
        	            		        if (this->get_backtracking()>0)
        	            		        {
        	            		            this->set_failedflag( true );
        	            		            return ;
        	            		        }


        	            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            		        ex->set_decisionNum( 85 );
        	            		        ex->set_state( 1 );


        	            		        goto ruleconstantEx;

        	            		    }
        	            		}
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return ;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 85 );
        	                ex->set_state( 0 );


        	                goto ruleconstantEx;

        	            }

        	            switch (alt85)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:358:12: day_key
        	        	    {
        	        	        this->followPush(FOLLOW_day_key_in_constant2844);
        	        	        m_gPLSQLParser->day_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQLCommons.g:358:22: hour_key
        	        	    {
        	        	        this->followPush(FOLLOW_hour_key_in_constant2848);
        	        	        m_gPLSQLParser->hour_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // PLSQLCommons.g:358:33: minute_key
        	        	    {
        	        	        this->followPush(FOLLOW_minute_key_in_constant2852);
        	        	        m_gPLSQLParser->minute_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // PLSQLCommons.g:358:46: second_key
        	        	    {
        	        	        this->followPush(FOLLOW_second_key_in_constant2856);
        	        	        m_gPLSQLParser->second_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLCommons.g:359:10: ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) ( COMMA ( UNSIGNED_INTEGER | bind_variable ) )? RIGHT_PAREN )?
        	        {
        	            int alt89=2;
        	            switch ( this->LA(1) )
        	            {
        	                case LEFT_PAREN:
        	                	{
        	                		switch ( this->LA(2) )
        	                		{
        	                		    case BINDVAR:
        	                		    case COLON:
        	                		    case UNSIGNED_INTEGER:
        	                		    	{
        	                		    		alt89=1;
        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt89)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:359:12: LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) ( COMMA ( UNSIGNED_INTEGER | bind_variable ) )? RIGHT_PAREN
        	        	    {
        	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_constant2870);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQLCommons.g:359:23: ( UNSIGNED_INTEGER | bind_variable )
        	        	        {
        	        	            int alt86=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	            case UNSIGNED_INTEGER:
        	        	            	{
        	        	            		alt86=1;
        	        	            	}
        	        	                break;
        	        	            case BINDVAR:
        	        	            case COLON:
        	        	            	{
        	        	            		alt86=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                if (this->get_backtracking()>0)
        	        	                {
        	        	                    this->set_failedflag( true );
        	        	                    return ;
        	        	                }

        	        	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                ex->set_decisionNum( 86 );
        	        	                ex->set_state( 0 );


        	        	                goto ruleconstantEx;

        	        	            }

        	        	            switch (alt86)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQLCommons.g:359:24: UNSIGNED_INTEGER
        	        	        	    {
        	        	        	         this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_constant2873);
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // PLSQLCommons.g:359:43: bind_variable
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_bind_variable_in_constant2877);
        	        	        	        bind_variable();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        // PLSQLCommons.g:359:58: ( COMMA ( UNSIGNED_INTEGER | bind_variable ) )?
        	        	        {
        	        	            int alt88=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case COMMA:
        	        	                	{
        	        	                		alt88=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt88)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQLCommons.g:359:59: COMMA ( UNSIGNED_INTEGER | bind_variable )
        	        	        	    {
        	        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_constant2881);
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        // PLSQLCommons.g:359:65: ( UNSIGNED_INTEGER | bind_variable )
        	        	        	        {
        	        	        	            int alt87=2;
        	        	        	            switch ( this->LA(1) )
        	        	        	            {
        	        	        	            case UNSIGNED_INTEGER:
        	        	        	            	{
        	        	        	            		alt87=1;
        	        	        	            	}
        	        	        	                break;
        	        	        	            case BINDVAR:
        	        	        	            case COLON:
        	        	        	            	{
        	        	        	            		alt87=2;
        	        	        	            	}
        	        	        	                break;

        	        	        	            default:
        	        	        	                if (this->get_backtracking()>0)
        	        	        	                {
        	        	        	                    this->set_failedflag( true );
        	        	        	                    return ;
        	        	        	                }

        	        	        	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	        	                ex->set_decisionNum( 87 );
        	        	        	                ex->set_state( 0 );


        	        	        	                goto ruleconstantEx;

        	        	        	            }

        	        	        	            switch (alt87)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // PLSQLCommons.g:359:66: UNSIGNED_INTEGER
        	        	        	        	    {
        	        	        	        	         this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_constant2884);
        	        	        	        	        if  (this->hasException())
        	        	        	        	        {
        	        	        	        	            goto ruleconstantEx;
        	        	        	        	        }
        	        	        	        	        if (this->hasFailed())
        	        	        	        	        {
        	        	        	        	            return ;
        	        	        	        	        }


        	        	        	        	    }
        	        	        	        	    break;
        	        	        	        	case 2:
        	        	        	        	    // PLSQLCommons.g:359:85: bind_variable
        	        	        	        	    {
        	        	        	        	        this->followPush(FOLLOW_bind_variable_in_constant2888);
        	        	        	        	        bind_variable();

        	        	        	        	        this->followPop();
        	        	        	        	        if  (this->hasException())
        	        	        	        	        {
        	        	        	        	            goto ruleconstantEx;
        	        	        	        	        }
        	        	        	        	        if (this->hasFailed())
        	        	        	        	        {
        	        	        	        	            return ;
        	        	        	        	        }


        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_constant2894);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLCommons.g:360:10: ( to_key ( day_key | hour_key | minute_key | second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )? ) )?
        	        {
        	            int alt93=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_TO:
        	                	{
        	                		switch ( this->LA(2) )
        	                		{
        	                		    case REGULAR_ID:
        	                		    	{
        	                		    		alt93=1;
        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt93)
        	            {
        	        	case 1:
        	        	    // PLSQLCommons.g:360:12: to_key ( day_key | hour_key | minute_key | second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )? )
        	        	    {
        	        	        this->followPush(FOLLOW_to_key_in_constant2909);
        	        	        m_gPLSQLParser->to_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleconstantEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQLCommons.g:361:14: ( day_key | hour_key | minute_key | second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )? )
        	        	        {
        	        	            int alt92=4;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	            case REGULAR_ID:
        	        	            	{
        	        	            		{
        	        	            		    int LA92_1 = this->LA(2);
        	        	            		    if ( ((equalsIgnoreCase(LT(1)->getText(), "DAY"))))
        	        	            		    {
        	        	            		        alt92=1;
        	        	            		    }
        	        	            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "HOUR"))))
        	        	            		    {
        	        	            		        alt92=2;
        	        	            		    }
        	        	            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "MINUTE"))))
        	        	            		    {
        	        	            		        alt92=3;
        	        	            		    }
        	        	            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SECOND"))))
        	        	            		    {
        	        	            		        alt92=4;
        	        	            		    }
        	        	            		    else
        	        	            		    {
        	        	            		        if (this->get_backtracking()>0)
        	        	            		        {
        	        	            		            this->set_failedflag( true );
        	        	            		            return ;
        	        	            		        }


        	        	            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	            		        ex->set_decisionNum( 92 );
        	        	            		        ex->set_state( 1 );


        	        	            		        goto ruleconstantEx;

        	        	            		    }
        	        	            		}
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                if (this->get_backtracking()>0)
        	        	                {
        	        	                    this->set_failedflag( true );
        	        	                    return ;
        	        	                }

        	        	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                ex->set_decisionNum( 92 );
        	        	                ex->set_state( 0 );


        	        	                goto ruleconstantEx;

        	        	            }

        	        	            switch (alt92)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQLCommons.g:361:16: day_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_day_key_in_constant2926);
        	        	        	        m_gPLSQLParser->day_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // PLSQLCommons.g:361:26: hour_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_hour_key_in_constant2930);
        	        	        	        m_gPLSQLParser->hour_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 3:
        	        	        	    // PLSQLCommons.g:361:37: minute_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_minute_key_in_constant2934);
        	        	        	        m_gPLSQLParser->minute_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 4:
        	        	        	    // PLSQLCommons.g:361:50: second_key ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )?
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_second_key_in_constant2938);
        	        	        	        m_gPLSQLParser->second_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleconstantEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        // PLSQLCommons.g:361:61: ( LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN )?
        	        	        	        {
        	        	        	            int alt91=2;
        	        	        	            switch ( this->LA(1) )
        	        	        	            {
        	        	        	                case LEFT_PAREN:
        	        	        	                	{
        	        	        	                		switch ( this->LA(2) )
        	        	        	                		{
        	        	        	                		    case BINDVAR:
        	        	        	                		    case COLON:
        	        	        	                		    case UNSIGNED_INTEGER:
        	        	        	                		    	{
        	        	        	                		    		alt91=1;
        	        	        	                		    	}
        	        	        	                		        break;
        	        	        	                		}

        	        	        	                	}
        	        	        	                    break;
        	        	        	            }

        	        	        	            switch (alt91)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // PLSQLCommons.g:361:62: LEFT_PAREN ( UNSIGNED_INTEGER | bind_variable ) RIGHT_PAREN
        	        	        	        	    {
        	        	        	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_constant2941);
        	        	        	        	        if  (this->hasException())
        	        	        	        	        {
        	        	        	        	            goto ruleconstantEx;
        	        	        	        	        }
        	        	        	        	        if (this->hasFailed())
        	        	        	        	        {
        	        	        	        	            return ;
        	        	        	        	        }


        	        	        	        	        // PLSQLCommons.g:361:73: ( UNSIGNED_INTEGER | bind_variable )
        	        	        	        	        {
        	        	        	        	            int alt90=2;
        	        	        	        	            switch ( this->LA(1) )
        	        	        	        	            {
        	        	        	        	            case UNSIGNED_INTEGER:
        	        	        	        	            	{
        	        	        	        	            		alt90=1;
        	        	        	        	            	}
        	        	        	        	                break;
        	        	        	        	            case BINDVAR:
        	        	        	        	            case COLON:
        	        	        	        	            	{
        	        	        	        	            		alt90=2;
        	        	        	        	            	}
        	        	        	        	                break;

        	        	        	        	            default:
        	        	        	        	                if (this->get_backtracking()>0)
        	        	        	        	                {
        	        	        	        	                    this->set_failedflag( true );
        	        	        	        	                    return ;
        	        	        	        	                }

        	        	        	        	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	        	        	                ex->set_decisionNum( 90 );
        	        	        	        	                ex->set_state( 0 );


        	        	        	        	                goto ruleconstantEx;

        	        	        	        	            }

        	        	        	        	            switch (alt90)
        	        	        	        	            {
        	        	        	        	        	case 1:
        	        	        	        	        	    // PLSQLCommons.g:361:74: UNSIGNED_INTEGER
        	        	        	        	        	    {
        	        	        	        	        	         this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_constant2944);
        	        	        	        	        	        if  (this->hasException())
        	        	        	        	        	        {
        	        	        	        	        	            goto ruleconstantEx;
        	        	        	        	        	        }
        	        	        	        	        	        if (this->hasFailed())
        	        	        	        	        	        {
        	        	        	        	        	            return ;
        	        	        	        	        	        }


        	        	        	        	        	    }
        	        	        	        	        	    break;
        	        	        	        	        	case 2:
        	        	        	        	        	    // PLSQLCommons.g:361:93: bind_variable
        	        	        	        	        	    {
        	        	        	        	        	        this->followPush(FOLLOW_bind_variable_in_constant2948);
        	        	        	        	        	        bind_variable();

        	        	        	        	        	        this->followPop();
        	        	        	        	        	        if  (this->hasException())
        	        	        	        	        	        {
        	        	        	        	        	            goto ruleconstantEx;
        	        	        	        	        	        }
        	        	        	        	        	        if (this->hasFailed())
        	        	        	        	        	        {
        	        	        	        	        	            return ;
        	        	        	        	        	        }


        	        	        	        	        	    }
        	        	        	        	        	    break;

        	        	        	        	            }
        	        	        	        	        }

        	        	        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_constant2951);
        	        	        	        	        if  (this->hasException())
        	        	        	        	        {
        	        	        	        	            goto ruleconstantEx;
        	        	        	        	        }
        	        	        	        	        if (this->hasFailed())
        	        	        	        	        {
        	        	        	        	            return ;
        	        	        	        	        }


        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // PLSQLCommons.g:363:10: numeric
        	    {
        	        this->followPush(FOLLOW_numeric_in_constant2978);
        	        numeric();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQLCommons.g:364:10: date_key quoted_string
        	    {
        	        this->followPush(FOLLOW_date_key_in_constant2989);
        	        m_gPLSQLParser->date_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_quoted_string_in_constant2991);
        	        quoted_string();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQLCommons.g:365:10: quoted_string
        	    {
        	        this->followPush(FOLLOW_quoted_string_in_constant3002);
        	        quoted_string();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // PLSQLCommons.g:366:10: null_key
        	    {
        	        this->followPush(FOLLOW_null_key_in_constant3013);
        	        m_gPLSQLParser->null_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 7:
        	    // PLSQLCommons.g:367:10: true_key
        	    {
        	        this->followPush(FOLLOW_true_key_in_constant3024);
        	        m_gPLSQLParser->true_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 8:
        	    // PLSQLCommons.g:368:10: false_key
        	    {
        	        this->followPush(FOLLOW_false_key_in_constant3035);
        	        m_gPLSQLParser->false_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 9:
        	    // PLSQLCommons.g:369:10: dbtimezone_key
        	    {
        	        this->followPush(FOLLOW_dbtimezone_key_in_constant3046);
        	        m_gPLSQLParser->dbtimezone_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 10:
        	    // PLSQLCommons.g:370:10: sessiontimezone_key
        	    {
        	        this->followPush(FOLLOW_sessiontimezone_key_in_constant3058);
        	        m_gPLSQLParser->sessiontimezone_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 11:
        	    // PLSQLCommons.g:371:10: minvalue_key
        	    {
        	        this->followPush(FOLLOW_minvalue_key_in_constant3069);
        	        m_gPLSQLParser->minvalue_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 12:
        	    // PLSQLCommons.g:372:10: maxvalue_key
        	    {
        	        this->followPush(FOLLOW_maxvalue_key_in_constant3080);
        	        m_gPLSQLParser->maxvalue_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 13:
        	    // PLSQLCommons.g:373:10: default_key
        	    {
        	        this->followPush(FOLLOW_default_key_in_constant3091);
        	        m_gPLSQLParser->default_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleconstantEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleconstantEx; /* Prevent compiler warnings */
    ruleconstantEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end constant */

/**
 * $ANTLR start numeric
 * PLSQLCommons.g:376:1: numeric : ( UNSIGNED_INTEGER | EXACT_NUM_LIT | APPROXIMATE_NUM_LIT );
 */
void
PLSQLParser_PLSQLCommons::numeric()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:377:5: ( UNSIGNED_INTEGER | EXACT_NUM_LIT | APPROXIMATE_NUM_LIT )
        // PLSQLCommons.g:
        {
            if ( this->LA(1) == APPROXIMATE_NUM_LIT || this->LA(1) == EXACT_NUM_LIT || this->LA(1) == UNSIGNED_INTEGER )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulenumericEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenumericEx; /* Prevent compiler warnings */
    rulenumericEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end numeric */

/**
 * $ANTLR start quoted_string
 * PLSQLCommons.g:381:1: quoted_string : ( CHAR_STRING | CHAR_STRING_PERL | NATIONAL_CHAR_STRING_LIT );
 */
void
PLSQLParser_PLSQLCommons::quoted_string()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:382:5: ( CHAR_STRING | CHAR_STRING_PERL | NATIONAL_CHAR_STRING_LIT )
        // PLSQLCommons.g:
        {
            if ( ((this->LA(1) >= CHAR_STRING) && (this->LA(1) <= CHAR_STRING_PERL)) || this->LA(1) == NATIONAL_CHAR_STRING_LIT )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulequoted_stringEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulequoted_stringEx; /* Prevent compiler warnings */
    rulequoted_stringEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end quoted_string */

/**
 * $ANTLR start id
 * PLSQLCommons.g:387:1: id : ( INTRODUCER char_set_name )? id_expression ;
 */
void
PLSQLParser_PLSQLCommons::id()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:388:5: ( ( INTRODUCER char_set_name )? id_expression )
        // PLSQLCommons.g:388:10: ( INTRODUCER char_set_name )? id_expression
        {
            // PLSQLCommons.g:388:10: ( INTRODUCER char_set_name )?
            {
                int alt95=2;
                switch ( this->LA(1) )
                {
                    case INTRODUCER:
                    	{
                    		alt95=1;
                    	}
                        break;
                }

                switch (alt95)
                {
            	case 1:
            	    // PLSQLCommons.g:388:11: INTRODUCER char_set_name
            	    {
            	         this->matchToken(INTRODUCER, &FOLLOW_INTRODUCER_in_id3191);
            	        if  (this->hasException())
            	        {
            	            goto ruleidEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_char_set_name_in_id3193);
            	        char_set_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleidEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_id_expression_in_id3205);
            id_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleidEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleidEx; /* Prevent compiler warnings */
    ruleidEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end id */

/**
 * $ANTLR start id_expression
 * PLSQLCommons.g:392:1: id_expression : ( REGULAR_ID | DELIMITED_ID );
 */
void
PLSQLParser_PLSQLCommons::id_expression()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:393:5: ( REGULAR_ID | DELIMITED_ID )
        // PLSQLCommons.g:
        {
            if ( this->LA(1) == DELIMITED_ID || this->LA(1) == REGULAR_ID )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto ruleid_expressionEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleid_expressionEx; /* Prevent compiler warnings */
    ruleid_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end id_expression */

/**
 * $ANTLR start not_equal_op
 * PLSQLCommons.g:397:1: not_equal_op : ( NOT_EQUAL_OP | LESS_THAN_OP GREATER_THAN_OP | EXCLAMATION_OPERATOR_PART EQUALS_OP | CARRET_OPERATOR_PART EQUALS_OP );
 */
void
PLSQLParser_PLSQLCommons::not_equal_op()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:398:5: ( NOT_EQUAL_OP | LESS_THAN_OP GREATER_THAN_OP | EXCLAMATION_OPERATOR_PART EQUALS_OP | CARRET_OPERATOR_PART EQUALS_OP )

            ANTLR_UINT32 alt96;

            alt96=4;

            switch ( this->LA(1) )
            {
            case NOT_EQUAL_OP:
            	{
            		alt96=1;
            	}
                break;
            case LESS_THAN_OP:
            	{
            		alt96=2;
            	}
                break;
            case EXCLAMATION_OPERATOR_PART:
            	{
            		alt96=3;
            	}
                break;
            case CARRET_OPERATOR_PART:
            	{
            		alt96=4;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 96 );
                ex->set_state( 0 );


                goto rulenot_equal_opEx;

            }

            switch (alt96)
            {
        	case 1:
        	    // PLSQLCommons.g:398:10: NOT_EQUAL_OP
        	    {
        	         this->matchToken(NOT_EQUAL_OP, &FOLLOW_NOT_EQUAL_OP_in_not_equal_op3256);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:399:10: LESS_THAN_OP GREATER_THAN_OP
        	    {
        	         this->matchToken(LESS_THAN_OP, &FOLLOW_LESS_THAN_OP_in_not_equal_op3267);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(GREATER_THAN_OP, &FOLLOW_GREATER_THAN_OP_in_not_equal_op3269);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLCommons.g:400:10: EXCLAMATION_OPERATOR_PART EQUALS_OP
        	    {
        	         this->matchToken(EXCLAMATION_OPERATOR_PART, &FOLLOW_EXCLAMATION_OPERATOR_PART_in_not_equal_op3280);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_not_equal_op3282);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQLCommons.g:401:10: CARRET_OPERATOR_PART EQUALS_OP
        	    {
        	         this->matchToken(CARRET_OPERATOR_PART, &FOLLOW_CARRET_OPERATOR_PART_in_not_equal_op3293);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_not_equal_op3295);
        	        if  (this->hasException())
        	        {
        	            goto rulenot_equal_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulenot_equal_opEx; /* Prevent compiler warnings */
    rulenot_equal_opEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end not_equal_op */

/**
 * $ANTLR start greater_than_or_equals_op
 * PLSQLCommons.g:404:1: greater_than_or_equals_op : ( GREATER_THAN_OR_EQUALS_OP | GREATER_THAN_OP EQUALS_OP );
 */
void
PLSQLParser_PLSQLCommons::greater_than_or_equals_op()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:405:5: ( GREATER_THAN_OR_EQUALS_OP | GREATER_THAN_OP EQUALS_OP )

            ANTLR_UINT32 alt97;

            alt97=2;

            switch ( this->LA(1) )
            {
            case GREATER_THAN_OR_EQUALS_OP:
            	{
            		alt97=1;
            	}
                break;
            case GREATER_THAN_OP:
            	{
            		alt97=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 97 );
                ex->set_state( 0 );


                goto rulegreater_than_or_equals_opEx;

            }

            switch (alt97)
            {
        	case 1:
        	    // PLSQLCommons.g:405:10: GREATER_THAN_OR_EQUALS_OP
        	    {
        	         this->matchToken(GREATER_THAN_OR_EQUALS_OP, &FOLLOW_GREATER_THAN_OR_EQUALS_OP_in_greater_than_or_equals_op3315);
        	        if  (this->hasException())
        	        {
        	            goto rulegreater_than_or_equals_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:406:10: GREATER_THAN_OP EQUALS_OP
        	    {
        	         this->matchToken(GREATER_THAN_OP, &FOLLOW_GREATER_THAN_OP_in_greater_than_or_equals_op3326);
        	        if  (this->hasException())
        	        {
        	            goto rulegreater_than_or_equals_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_greater_than_or_equals_op3328);
        	        if  (this->hasException())
        	        {
        	            goto rulegreater_than_or_equals_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulegreater_than_or_equals_opEx; /* Prevent compiler warnings */
    rulegreater_than_or_equals_opEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end greater_than_or_equals_op */

/**
 * $ANTLR start less_than_or_equals_op
 * PLSQLCommons.g:409:1: less_than_or_equals_op : ( LESS_THAN_OR_EQUALS_OP | LESS_THAN_OP EQUALS_OP );
 */
void
PLSQLParser_PLSQLCommons::less_than_or_equals_op()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:410:5: ( LESS_THAN_OR_EQUALS_OP | LESS_THAN_OP EQUALS_OP )

            ANTLR_UINT32 alt98;

            alt98=2;

            switch ( this->LA(1) )
            {
            case LESS_THAN_OR_EQUALS_OP:
            	{
            		alt98=1;
            	}
                break;
            case LESS_THAN_OP:
            	{
            		alt98=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 98 );
                ex->set_state( 0 );


                goto ruleless_than_or_equals_opEx;

            }

            switch (alt98)
            {
        	case 1:
        	    // PLSQLCommons.g:410:10: LESS_THAN_OR_EQUALS_OP
        	    {
        	         this->matchToken(LESS_THAN_OR_EQUALS_OP, &FOLLOW_LESS_THAN_OR_EQUALS_OP_in_less_than_or_equals_op3348);
        	        if  (this->hasException())
        	        {
        	            goto ruleless_than_or_equals_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:411:10: LESS_THAN_OP EQUALS_OP
        	    {
        	         this->matchToken(LESS_THAN_OP, &FOLLOW_LESS_THAN_OP_in_less_than_or_equals_op3359);
        	        if  (this->hasException())
        	        {
        	            goto ruleless_than_or_equals_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_less_than_or_equals_op3361);
        	        if  (this->hasException())
        	        {
        	            goto ruleless_than_or_equals_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleless_than_or_equals_opEx; /* Prevent compiler warnings */
    ruleless_than_or_equals_opEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end less_than_or_equals_op */

/**
 * $ANTLR start concatenation_op
 * PLSQLCommons.g:414:1: concatenation_op : ( CONCATENATION_OP | VERTICAL_BAR VERTICAL_BAR );
 */
void
PLSQLParser_PLSQLCommons::concatenation_op()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLCommons.g:415:5: ( CONCATENATION_OP | VERTICAL_BAR VERTICAL_BAR )

            ANTLR_UINT32 alt99;

            alt99=2;

            switch ( this->LA(1) )
            {
            case CONCATENATION_OP:
            	{
            		alt99=1;
            	}
                break;
            case VERTICAL_BAR:
            	{
            		alt99=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 99 );
                ex->set_state( 0 );


                goto ruleconcatenation_opEx;

            }

            switch (alt99)
            {
        	case 1:
        	    // PLSQLCommons.g:415:10: CONCATENATION_OP
        	    {
        	         this->matchToken(CONCATENATION_OP, &FOLLOW_CONCATENATION_OP_in_concatenation_op3381);
        	        if  (this->hasException())
        	        {
        	            goto ruleconcatenation_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:416:10: VERTICAL_BAR VERTICAL_BAR
        	    {
        	         this->matchToken(VERTICAL_BAR, &FOLLOW_VERTICAL_BAR_in_concatenation_op3392);
        	        if  (this->hasException())
        	        {
        	            goto ruleconcatenation_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(VERTICAL_BAR, &FOLLOW_VERTICAL_BAR_in_concatenation_op3394);
        	        if  (this->hasException())
        	        {
        	            goto ruleconcatenation_opEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleconcatenation_opEx; /* Prevent compiler warnings */
    ruleconcatenation_opEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end concatenation_op */

/**
 * $ANTLR start multiset_op
 * PLSQLCommons.g:419:2: multiset_op : multiset_key ( except_key | intersect_key | union_key ) ( all_key | distinct_key )? ;
 */
void
PLSQLParser_PLSQLCommons::multiset_op()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:420:5: ( multiset_key ( except_key | intersect_key | union_key ) ( all_key | distinct_key )? )
        // PLSQLCommons.g:420:10: multiset_key ( except_key | intersect_key | union_key ) ( all_key | distinct_key )?
        {
            this->followPush(FOLLOW_multiset_key_in_multiset_op3415);
            m_gPLSQLParser->multiset_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemultiset_opEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLCommons.g:421:10: ( except_key | intersect_key | union_key )
            {
                int alt100=3;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		alt100=1;
                	}
                    break;
                case SQL92_RESERVED_INTERSECT:
                	{
                		alt100=2;
                	}
                    break;
                case SQL92_RESERVED_UNION:
                	{
                		alt100=3;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 100 );
                    ex->set_state( 0 );


                    goto rulemultiset_opEx;

                }

                switch (alt100)
                {
            	case 1:
            	    // PLSQLCommons.g:421:12: except_key
            	    {
            	        this->followPush(FOLLOW_except_key_in_multiset_op3428);
            	        m_gPLSQLParser->except_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_opEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:421:25: intersect_key
            	    {
            	        this->followPush(FOLLOW_intersect_key_in_multiset_op3432);
            	        m_gPLSQLParser->intersect_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_opEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLCommons.g:421:41: union_key
            	    {
            	        this->followPush(FOLLOW_union_key_in_multiset_op3436);
            	        m_gPLSQLParser->union_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_opEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLCommons.g:422:10: ( all_key | distinct_key )?
            {
                int alt101=3;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_ALL:
                    	{
                    		alt101=1;
                    	}
                        break;
                    case SQL92_RESERVED_DISTINCT:
                    	{
                    		alt101=2;
                    	}
                        break;
                }

                switch (alt101)
                {
            	case 1:
            	    // PLSQLCommons.g:422:12: all_key
            	    {
            	        this->followPush(FOLLOW_all_key_in_multiset_op3451);
            	        m_gPLSQLParser->all_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_opEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLCommons.g:422:22: distinct_key
            	    {
            	        this->followPush(FOLLOW_distinct_key_in_multiset_op3455);
            	        m_gPLSQLParser->distinct_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_opEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemultiset_opEx; /* Prevent compiler warnings */
    rulemultiset_opEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multiset_op */

/**
 * $ANTLR start outer_join_sign
 * PLSQLCommons.g:425:1: outer_join_sign : LEFT_PAREN PLUS_SIGN RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQLCommons::outer_join_sign()
{
        PLSQLParser_PLSQLCommonsImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLCommons.g:426:5: ( LEFT_PAREN PLUS_SIGN RIGHT_PAREN )
        // PLSQLCommons.g:426:10: LEFT_PAREN PLUS_SIGN RIGHT_PAREN
        {
             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_outer_join_sign3478);
            if  (this->hasException())
            {
                goto ruleouter_join_signEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(PLUS_SIGN, &FOLLOW_PLUS_SIGN_in_outer_join_sign3480);
            if  (this->hasException())
            {
                goto ruleouter_join_signEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_outer_join_sign3482);
            if  (this->hasException())
            {
                goto ruleouter_join_signEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleouter_join_signEx; /* Prevent compiler warnings */
    ruleouter_join_signEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end outer_join_sign */

// $ANTLR start synpredRule synpred1_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred1_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:42:10: ( ( as_key )? ( id | alias_quoted_string ) )
    // PLSQLCommons.g:42:10: ( as_key )? ( id | alias_quoted_string )
    {
        // PLSQLCommons.g:42:10: ( as_key )?
        {
            int alt102=2;
            switch ( this->LA(1) )
            {
                case SQL92_RESERVED_AS:
                	{
                		alt102=1;
                	}
                    break;
            }

            switch (alt102)
            {
        	case 1:
        	    // PLSQLCommons.g:42:10: as_key
        	    {
        	        this->followPush(FOLLOW_as_key_in_synpred1_PLSQLCommons86);
        	        m_gPLSQLParser->as_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred1_PLSQLCommonsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

        // PLSQLCommons.g:42:18: ( id | alias_quoted_string )
        {
            int alt103=2;
            switch ( this->LA(1) )
            {
            case DELIMITED_ID:
            case INTRODUCER:
            case REGULAR_ID:
            	{
            		alt103=1;
            	}
                break;
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case NATIONAL_CHAR_STRING_LIT:
            	{
            		alt103=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLCommonsImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 103 );
                ex->set_state( 0 );


                goto rulesynpred1_PLSQLCommonsEx;

            }

            switch (alt103)
            {
        	case 1:
        	    // PLSQLCommons.g:42:20: id
        	    {
        	        this->followPush(FOLLOW_id_in_synpred1_PLSQLCommons91);
        	        id();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred1_PLSQLCommonsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLCommons.g:42:25: alias_quoted_string
        	    {
        	        this->followPush(FOLLOW_alias_quoted_string_in_synpred1_PLSQLCommons95);
        	        alias_quoted_string();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred1_PLSQLCommonsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

    }


goto rulesynpred1_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred1_PLSQLCommonsEx: ;
}
// $ANTLR end synpred1_PLSQLCommons

// $ANTLR start synpredRule synpred2_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred2_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:102:14: ( PERIOD id_expression )
    // PLSQLCommons.g:102:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred2_PLSQLCommons441);
        if  (this->hasException())
        {
            goto rulesynpred2_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred2_PLSQLCommons443);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred2_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred2_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred2_PLSQLCommonsEx: ;
}
// $ANTLR end synpred2_PLSQLCommons

// $ANTLR start synpredRule synpred3_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred3_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:110:14: ( PERIOD id_expression )
    // PLSQLCommons.g:110:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred3_PLSQLCommons502);
        if  (this->hasException())
        {
            goto rulesynpred3_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred3_PLSQLCommons504);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred3_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred3_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred3_PLSQLCommonsEx: ;
}
// $ANTLR end synpred3_PLSQLCommons

// $ANTLR start synpredRule synpred4_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred4_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:126:14: ( PERIOD id_expression )
    // PLSQLCommons.g:126:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred4_PLSQLCommons596);
        if  (this->hasException())
        {
            goto rulesynpred4_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred4_PLSQLCommons598);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred4_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred4_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred4_PLSQLCommonsEx: ;
}
// $ANTLR end synpred4_PLSQLCommons

// $ANTLR start synpredRule synpred5_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred5_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:134:14: ( PERIOD id_expression )
    // PLSQLCommons.g:134:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred5_PLSQLCommons650);
        if  (this->hasException())
        {
            goto rulesynpred5_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred5_PLSQLCommons652);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred5_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred5_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred5_PLSQLCommonsEx: ;
}
// $ANTLR end synpred5_PLSQLCommons

// $ANTLR start synpredRule synpred6_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred6_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:142:25: ( PERIOD id_expression )
    // PLSQLCommons.g:142:26: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred6_PLSQLCommons711);
        if  (this->hasException())
        {
            goto rulesynpred6_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred6_PLSQLCommons713);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred6_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred6_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred6_PLSQLCommonsEx: ;
}
// $ANTLR end synpred6_PLSQLCommons

// $ANTLR start synpredRule synpred7_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred7_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:146:25: ( PERIOD id_expression )
    // PLSQLCommons.g:146:26: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred7_PLSQLCommons745);
        if  (this->hasException())
        {
            goto rulesynpred7_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred7_PLSQLCommons747);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred7_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred7_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred7_PLSQLCommonsEx: ;
}
// $ANTLR end synpred7_PLSQLCommons

// $ANTLR start synpredRule synpred8_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred8_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:150:14: ( PERIOD id_expression )
    // PLSQLCommons.g:150:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred8_PLSQLCommons779);
        if  (this->hasException())
        {
            goto rulesynpred8_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred8_PLSQLCommons781);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred8_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred8_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred8_PLSQLCommonsEx: ;
}
// $ANTLR end synpred8_PLSQLCommons

// $ANTLR start synpredRule synpred9_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred9_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:154:14: ( PERIOD id_expression )
    // PLSQLCommons.g:154:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred9_PLSQLCommons814);
        if  (this->hasException())
        {
            goto rulesynpred9_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred9_PLSQLCommons816);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred9_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred9_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred9_PLSQLCommonsEx: ;
}
// $ANTLR end synpred9_PLSQLCommons

// $ANTLR start synpredRule synpred10_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred10_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:158:14: ( PERIOD id_expression )
    // PLSQLCommons.g:158:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred10_PLSQLCommons848);
        if  (this->hasException())
        {
            goto rulesynpred10_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred10_PLSQLCommons850);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred10_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred10_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred10_PLSQLCommonsEx: ;
}
// $ANTLR end synpred10_PLSQLCommons

// $ANTLR start synpredRule synpred11_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred11_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:162:14: ( PERIOD id_expression )
    // PLSQLCommons.g:162:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred11_PLSQLCommons882);
        if  (this->hasException())
        {
            goto rulesynpred11_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred11_PLSQLCommons884);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred11_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred11_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred11_PLSQLCommonsEx: ;
}
// $ANTLR end synpred11_PLSQLCommons

// $ANTLR start synpredRule synpred12_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred12_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:167:28: ( PERIOD id_expression )
    // PLSQLCommons.g:167:29: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred12_PLSQLCommons935);
        if  (this->hasException())
        {
            goto rulesynpred12_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred12_PLSQLCommons937);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred12_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred12_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred12_PLSQLCommonsEx: ;
}
// $ANTLR end synpred12_PLSQLCommons

// $ANTLR start synpredRule synpred13_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred13_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:186:14: ( PERIOD id_expression )
    // PLSQLCommons.g:186:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred13_PLSQLCommons1062);
        if  (this->hasException())
        {
            goto rulesynpred13_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred13_PLSQLCommons1064);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred13_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred13_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred13_PLSQLCommonsEx: ;
}
// $ANTLR end synpred13_PLSQLCommons

// $ANTLR start synpredRule synpred14_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred14_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:194:14: ( PERIOD id_expression )
    // PLSQLCommons.g:194:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred14_PLSQLCommons1116);
        if  (this->hasException())
        {
            goto rulesynpred14_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred14_PLSQLCommons1118);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred14_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred14_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred14_PLSQLCommonsEx: ;
}
// $ANTLR end synpred14_PLSQLCommons

// $ANTLR start synpredRule synpred15_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred15_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:198:14: ( PERIOD id_expression )
    // PLSQLCommons.g:198:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred15_PLSQLCommons1150);
        if  (this->hasException())
        {
            goto rulesynpred15_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred15_PLSQLCommons1152);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred15_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred15_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred15_PLSQLCommonsEx: ;
}
// $ANTLR end synpred15_PLSQLCommons

// $ANTLR start synpredRule synpred16_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred16_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:205:25: ( PERIOD id_expression )
    // PLSQLCommons.g:205:26: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred16_PLSQLCommons1219);
        if  (this->hasException())
        {
            goto rulesynpred16_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred16_PLSQLCommons1221);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred16_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred16_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred16_PLSQLCommonsEx: ;
}
// $ANTLR end synpred16_PLSQLCommons

// $ANTLR start synpredRule synpred17_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred17_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:240:19: ( tableview_name PERIOD ASTERISK )
    // PLSQLCommons.g:240:20: tableview_name PERIOD ASTERISK
    {
        this->followPush(FOLLOW_tableview_name_in_synpred17_PLSQLCommons1556);
        tableview_name();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred17_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred17_PLSQLCommons1558);
        if  (this->hasException())
        {
            goto rulesynpred17_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_synpred17_PLSQLCommons1560);
        if  (this->hasException())
        {
            goto rulesynpred17_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred17_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred17_PLSQLCommonsEx: ;
}
// $ANTLR end synpred17_PLSQLCommons

// $ANTLR start synpredRule synpred18_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred18_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:253:11: ( id EQUALS_OP GREATER_THAN_OP )
    // PLSQLCommons.g:253:12: id EQUALS_OP GREATER_THAN_OP
    {
        this->followPush(FOLLOW_id_in_synpred18_PLSQLCommons1712);
        id();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred18_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_synpred18_PLSQLCommons1714);
        if  (this->hasException())
        {
            goto rulesynpred18_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(GREATER_THAN_OP, &FOLLOW_GREATER_THAN_OP_in_synpred18_PLSQLCommons1716);
        if  (this->hasException())
        {
            goto rulesynpred18_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred18_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred18_PLSQLCommonsEx: ;
}
// $ANTLR end synpred18_PLSQLCommons

// $ANTLR start synpredRule synpred19_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred19_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:335:11: ( PERIOD general_element_part )
    // PLSQLCommons.g:335:12: PERIOD general_element_part
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred19_PLSQLCommons2631);
        if  (this->hasException())
        {
            goto rulesynpred19_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_general_element_part_in_synpred19_PLSQLCommons2633);
        general_element_part();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred19_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred19_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred19_PLSQLCommonsEx: ;
}
// $ANTLR end synpred19_PLSQLCommons

// $ANTLR start synpredRule synpred20_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred20_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:339:32: ( PERIOD general_element_part )
    // PLSQLCommons.g:339:33: PERIOD general_element_part
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred20_PLSQLCommons2665);
        if  (this->hasException())
        {
            goto rulesynpred20_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_general_element_part_in_synpred20_PLSQLCommons2667);
        general_element_part();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred20_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred20_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred20_PLSQLCommonsEx: ;
}
// $ANTLR end synpred20_PLSQLCommons

// $ANTLR start synpredRule synpred21_PLSQLCommons
void PLSQLParser_PLSQLCommons::msynpred21_PLSQLCommons_fragment(  )
{
    // PLSQLCommons.g:344:14: ( PERIOD id_expression )
    // PLSQLCommons.g:344:15: PERIOD id_expression
    {
         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred21_PLSQLCommons2718);
        if  (this->hasException())
        {
            goto rulesynpred21_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_expression_in_synpred21_PLSQLCommons2720);
        id_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred21_PLSQLCommonsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred21_PLSQLCommonsEx; /* Prevent compiler warnings */
rulesynpred21_PLSQLCommonsEx: ;
}
// $ANTLR end synpred21_PLSQLCommons
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred4_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred4_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred14_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred14_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred7_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred7_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred5_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred5_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred12_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred12_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred8_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred8_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred10_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred10_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred11_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred11_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred21_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred21_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred1_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred1_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred3_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred3_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred9_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred9_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred15_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred15_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred20_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred20_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred18_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred18_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred17_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred17_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred19_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred19_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred2_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred2_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred16_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred16_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred6_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred6_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQLCommons::msynpred( antlr3::ClassForwarder< synpred13_PLSQLCommons >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred13_PLSQLCommons_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

}

/* End of code
 * =============================================================================
 */
