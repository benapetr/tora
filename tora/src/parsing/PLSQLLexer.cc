/** \file
 *  This C++ source file was generated by $ANTLR version 3.5.2-SNAPSHOT
 *
 *     -  From the grammar source file : PLSQLLexer.g
 *     -                            On : 2013-10-27 10:35:29
 *     -                 for the lexer : PLSQLLexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/*
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "PLSQLLexer.hpp"
/* ----------------------------------------- */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


namespace  Antlr3BackendImpl  {
const ANTLR_UINT8* PLSQLLexerTokens::getTokenName(ANTLR_INT32 index) const
{
       if( EOF_TOKEN == index)
               return (ANTLR_UINT8*) "<EOF>";
       return TokenNames[index];
}

/** \brief Table of all token names in symbolic order, mainly used for debugging.
 */
ANTLR_UINT8* PLSQLLexerTokens::TokenNames[151+4]
       = {
       (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
       (ANTLR_UINT8*) "<EOR>",
       (ANTLR_UINT8*) "<DOWN>",
       (ANTLR_UINT8*) "<UP>",
       (ANTLR_UINT8*) "AMPERSAND",//4
       (ANTLR_UINT8*) "APPROXIMATE_NUM_LIT",//5
       (ANTLR_UINT8*) "ASSIGN_OP",//6
       (ANTLR_UINT8*) "ASTERISK",//7
       (ANTLR_UINT8*) "AT_SIGN",//8
       (ANTLR_UINT8*) "BINDVAR",//9
       (ANTLR_UINT8*) "BIT_STRING_LIT",//10
       (ANTLR_UINT8*) "CARRET_OPERATOR_PART",//11
       (ANTLR_UINT8*) "CHAR_STRING",//12
       (ANTLR_UINT8*) "CHAR_STRING_PERL",//13
       (ANTLR_UINT8*) "COLON",//14
       (ANTLR_UINT8*) "COMMA",//15
       (ANTLR_UINT8*) "COMMENT",//16
       (ANTLR_UINT8*) "CONCATENATION_OP",//17
       (ANTLR_UINT8*) "DELIMITED_ID",//18
       (ANTLR_UINT8*) "DOUBLE_ASTERISK",//19
       (ANTLR_UINT8*) "DOUBLE_PERIOD",//20
       (ANTLR_UINT8*) "EQUALS_OP",//21
       (ANTLR_UINT8*) "EXACT_NUM_LIT",//22
       (ANTLR_UINT8*) "EXCLAMATION_OPERATOR_PART",//23
       (ANTLR_UINT8*) "FOR_NOTATION",//24
       (ANTLR_UINT8*) "GREATER_THAN_OP",//25
       (ANTLR_UINT8*) "GREATER_THAN_OR_EQUALS_OP",//26
       (ANTLR_UINT8*) "HEX_STRING_LIT",//27
       (ANTLR_UINT8*) "INTRODUCER",//28
       (ANTLR_UINT8*) "LEFT_BRACKET",//29
       (ANTLR_UINT8*) "LEFT_PAREN",//30
       (ANTLR_UINT8*) "LESS_THAN_OP",//31
       (ANTLR_UINT8*) "LESS_THAN_OR_EQUALS_OP",//32
       (ANTLR_UINT8*) "MINUS_SIGN",//33
       (ANTLR_UINT8*) "NATIONAL_CHAR_STRING_LIT",//34
       (ANTLR_UINT8*) "NEWLINE",//35
       (ANTLR_UINT8*) "NOT_EQUAL_OP",//36
       (ANTLR_UINT8*) "PERCENT",//37
       (ANTLR_UINT8*) "PERIOD",//38
       (ANTLR_UINT8*) "PLSQL_NON_RESERVED_CONNECT_BY_ROOT",//39
       (ANTLR_UINT8*) "PLSQL_NON_RESERVED_ELSIF",//40
       (ANTLR_UINT8*) "PLSQL_NON_RESERVED_MODEL",//41
       (ANTLR_UINT8*) "PLSQL_NON_RESERVED_PIVOT",//42
       (ANTLR_UINT8*) "PLSQL_NON_RESERVED_UNPIVOT",//43
       (ANTLR_UINT8*) "PLSQL_NON_RESERVED_USING",//44
       (ANTLR_UINT8*) "PLSQL_RESERVED_CLUSTERS",//45
       (ANTLR_UINT8*) "PLSQL_RESERVED_COLAUTH",//46
       (ANTLR_UINT8*) "PLSQL_RESERVED_COMPRESS",//47
       (ANTLR_UINT8*) "PLSQL_RESERVED_CRASH",//48
       (ANTLR_UINT8*) "PLSQL_RESERVED_EXCLUSIVE",//49
       (ANTLR_UINT8*) "PLSQL_RESERVED_IDENTIFIED",//50
       (ANTLR_UINT8*) "PLSQL_RESERVED_IF",//51
       (ANTLR_UINT8*) "PLSQL_RESERVED_INDEX",//52
       (ANTLR_UINT8*) "PLSQL_RESERVED_INDEXES",//53
       (ANTLR_UINT8*) "PLSQL_RESERVED_LOCK",//54
       (ANTLR_UINT8*) "PLSQL_RESERVED_MINUS",//55
       (ANTLR_UINT8*) "PLSQL_RESERVED_MODE",//56
       (ANTLR_UINT8*) "PLSQL_RESERVED_NOCOMPRESS",//57
       (ANTLR_UINT8*) "PLSQL_RESERVED_NOWAIT",//58
       (ANTLR_UINT8*) "PLSQL_RESERVED_RESOURCE",//59
       (ANTLR_UINT8*) "PLSQL_RESERVED_SHARE",//60
       (ANTLR_UINT8*) "PLSQL_RESERVED_START",//61
       (ANTLR_UINT8*) "PLSQL_RESERVED_TABAUTH",//62
       (ANTLR_UINT8*) "PLSQL_RESERVED_VIEWS",//63
       (ANTLR_UINT8*) "PLUS_SIGN",//64
       (ANTLR_UINT8*) "PROMPT",//65
       (ANTLR_UINT8*) "QS_ANGLE",//66
       (ANTLR_UINT8*) "QS_BRACE",//67
       (ANTLR_UINT8*) "QS_BRACK",//68
       (ANTLR_UINT8*) "QS_OTHER",//69
       (ANTLR_UINT8*) "QS_OTHER_CH",//70
       (ANTLR_UINT8*) "QS_PAREN",//71
       (ANTLR_UINT8*) "QUESTION_MARK",//72
       (ANTLR_UINT8*) "QUOTE",//73
       (ANTLR_UINT8*) "REGULAR_ID",//74
       (ANTLR_UINT8*) "RIGHT_BRACKET",//75
       (ANTLR_UINT8*) "RIGHT_PAREN",//76
       (ANTLR_UINT8*) "SEMICOLON",//77
       (ANTLR_UINT8*) "SEPARATOR",//78
       (ANTLR_UINT8*) "SIMPLE_LETTER",//79
       (ANTLR_UINT8*) "SOLIDUS",//80
       (ANTLR_UINT8*) "SPACE",//81
       (ANTLR_UINT8*) "SQL92_RESERVED_ALL",//82
       (ANTLR_UINT8*) "SQL92_RESERVED_ALTER",//83
       (ANTLR_UINT8*) "SQL92_RESERVED_AND",//84
       (ANTLR_UINT8*) "SQL92_RESERVED_ANY",//85
       (ANTLR_UINT8*) "SQL92_RESERVED_AS",//86
       (ANTLR_UINT8*) "SQL92_RESERVED_ASC",//87
       (ANTLR_UINT8*) "SQL92_RESERVED_BEGIN",//88
       (ANTLR_UINT8*) "SQL92_RESERVED_BETWEEN",//89
       (ANTLR_UINT8*) "SQL92_RESERVED_BY",//90
       (ANTLR_UINT8*) "SQL92_RESERVED_CASE",//91
       (ANTLR_UINT8*) "SQL92_RESERVED_CHECK",//92
       (ANTLR_UINT8*) "SQL92_RESERVED_CONNECT",//93
       (ANTLR_UINT8*) "SQL92_RESERVED_CREATE",//94
       (ANTLR_UINT8*) "SQL92_RESERVED_CURRENT",//95
       (ANTLR_UINT8*) "SQL92_RESERVED_CURSOR",//96
       (ANTLR_UINT8*) "SQL92_RESERVED_DATE",//97
       (ANTLR_UINT8*) "SQL92_RESERVED_DECLARE",//98
       (ANTLR_UINT8*) "SQL92_RESERVED_DEFAULT",//99
       (ANTLR_UINT8*) "SQL92_RESERVED_DELETE",//100
       (ANTLR_UINT8*) "SQL92_RESERVED_DESC",//101
       (ANTLR_UINT8*) "SQL92_RESERVED_DISTINCT",//102
       (ANTLR_UINT8*) "SQL92_RESERVED_DROP",//103
       (ANTLR_UINT8*) "SQL92_RESERVED_ELSE",//104
       (ANTLR_UINT8*) "SQL92_RESERVED_END",//105
       (ANTLR_UINT8*) "SQL92_RESERVED_EXCEPTION",//106
       (ANTLR_UINT8*) "SQL92_RESERVED_EXISTS",//107
       (ANTLR_UINT8*) "SQL92_RESERVED_FALSE",//108
       (ANTLR_UINT8*) "SQL92_RESERVED_FETCH",//109
       (ANTLR_UINT8*) "SQL92_RESERVED_FOR",//110
       (ANTLR_UINT8*) "SQL92_RESERVED_FROM",//111
       (ANTLR_UINT8*) "SQL92_RESERVED_GOTO",//112
       (ANTLR_UINT8*) "SQL92_RESERVED_GRANT",//113
       (ANTLR_UINT8*) "SQL92_RESERVED_GROUP",//114
       (ANTLR_UINT8*) "SQL92_RESERVED_HAVING",//115
       (ANTLR_UINT8*) "SQL92_RESERVED_IN",//116
       (ANTLR_UINT8*) "SQL92_RESERVED_INSERT",//117
       (ANTLR_UINT8*) "SQL92_RESERVED_INTERSECT",//118
       (ANTLR_UINT8*) "SQL92_RESERVED_INTO",//119
       (ANTLR_UINT8*) "SQL92_RESERVED_IS",//120
       (ANTLR_UINT8*) "SQL92_RESERVED_LIKE",//121
       (ANTLR_UINT8*) "SQL92_RESERVED_NOT",//122
       (ANTLR_UINT8*) "SQL92_RESERVED_NULL",//123
       (ANTLR_UINT8*) "SQL92_RESERVED_OF",//124
       (ANTLR_UINT8*) "SQL92_RESERVED_ON",//125
       (ANTLR_UINT8*) "SQL92_RESERVED_OPTION",//126
       (ANTLR_UINT8*) "SQL92_RESERVED_OR",//127
       (ANTLR_UINT8*) "SQL92_RESERVED_ORDER",//128
       (ANTLR_UINT8*) "SQL92_RESERVED_OVERLAPS",//129
       (ANTLR_UINT8*) "SQL92_RESERVED_PRIOR",//130
       (ANTLR_UINT8*) "SQL92_RESERVED_PROCEDURE",//131
       (ANTLR_UINT8*) "SQL92_RESERVED_PUBLIC",//132
       (ANTLR_UINT8*) "SQL92_RESERVED_REVOKE",//133
       (ANTLR_UINT8*) "SQL92_RESERVED_SELECT",//134
       (ANTLR_UINT8*) "SQL92_RESERVED_SIZE",//135
       (ANTLR_UINT8*) "SQL92_RESERVED_TABLE",//136
       (ANTLR_UINT8*) "SQL92_RESERVED_THE",//137
       (ANTLR_UINT8*) "SQL92_RESERVED_THEN",//138
       (ANTLR_UINT8*) "SQL92_RESERVED_TO",//139
       (ANTLR_UINT8*) "SQL92_RESERVED_TRUE",//140
       (ANTLR_UINT8*) "SQL92_RESERVED_UNION",//141
       (ANTLR_UINT8*) "SQL92_RESERVED_UNIQUE",//142
       (ANTLR_UINT8*) "SQL92_RESERVED_UPDATE",//143
       (ANTLR_UINT8*) "SQL92_RESERVED_VALUES",//144
       (ANTLR_UINT8*) "SQL92_RESERVED_VIEW",//145
       (ANTLR_UINT8*) "SQL92_RESERVED_WHEN",//146
       (ANTLR_UINT8*) "SQL92_RESERVED_WHERE",//147
       (ANTLR_UINT8*) "SQL92_RESERVED_WITH",//148
       (ANTLR_UINT8*) "TILDE_OPERATOR_PART",//149
       (ANTLR_UINT8*) "UNDERSCORE",//150
       (ANTLR_UINT8*) "UNSIGNED_INTEGER",//151
       (ANTLR_UINT8*) "VERTICAL_BAR",//152
       (ANTLR_UINT8*) "ZV",//153
       };

/** String literals used by PLSQLLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR_UCHAR	lit_1[]  = { 0x2E, 0x2E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_2[]  = { 0x2A, 0x2A,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_3[]  = { 0x3A, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_4[]  = { 0x3C, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_5[]  = { 0x3E, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_6[]  = { 0x21, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_7[]  = { 0x3C, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_8[]  = { 0x5E, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_9[]  = { 0x7E, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_10[]  = { 0x7C, 0x7C,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_11[]  = { 0x2D, 0x2D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_12[]  = { 0x2F, 0x2A,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_13[]  = { 0x2A, 0x2F,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_14[]  = { 0x50, 0x52, 0x4F, 0x4D, 0x50, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_15[]  = { 0x41, 0x4C, 0x4C,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_16[]  = { 0x41, 0x4C, 0x54, 0x45, 0x52,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_17[]  = { 0x41, 0x4E, 0x44,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_18[]  = { 0x41, 0x4E, 0x59,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_19[]  = { 0x41, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_20[]  = { 0x41, 0x53, 0x43,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_21[]  = { 0x42, 0x45, 0x47, 0x49, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_22[]  = { 0x42, 0x45, 0x54, 0x57, 0x45, 0x45, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_23[]  = { 0x42, 0x59,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_24[]  = { 0x43, 0x41, 0x53, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_25[]  = { 0x43, 0x48, 0x45, 0x43, 0x4B,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_26[]  = { 0x43, 0x4C, 0x55, 0x53, 0x54, 0x45, 0x52, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_27[]  = { 0x43, 0x4F, 0x4C, 0x41, 0x55, 0x54, 0x48,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_28[]  = { 0x43, 0x4F, 0x4D, 0x50, 0x52, 0x45, 0x53, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_29[]  = { 0x43, 0x4F, 0x4E, 0x4E, 0x45, 0x43, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_30[]  = { 0x43, 0x4F, 0x4E, 0x4E, 0x45, 0x43, 0x54, 0x5F, 0x42, 0x59, 0x5F, 0x52, 0x4F, 0x4F, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_31[]  = { 0x43, 0x52, 0x41, 0x53, 0x48,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_32[]  = { 0x43, 0x52, 0x45, 0x41, 0x54, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_33[]  = { 0x43, 0x55, 0x52, 0x52, 0x45, 0x4E, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_34[]  = { 0x43, 0x55, 0x52, 0x53, 0x4F, 0x52,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_35[]  = { 0x44, 0x41, 0x54, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_36[]  = { 0x44, 0x45, 0x43, 0x4C, 0x41, 0x52, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_37[]  = { 0x44, 0x45, 0x46, 0x41, 0x55, 0x4C, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_38[]  = { 0x44, 0x45, 0x4C, 0x45, 0x54, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_39[]  = { 0x44, 0x45, 0x53, 0x43,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_40[]  = { 0x44, 0x49, 0x53, 0x54, 0x49, 0x4E, 0x43, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_41[]  = { 0x44, 0x52, 0x4F, 0x50,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_42[]  = { 0x45, 0x4C, 0x53, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_43[]  = { 0x45, 0x4E, 0x44,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_44[]  = { 0x45, 0x58, 0x43, 0x45, 0x50, 0x54, 0x49, 0x4F, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_45[]  = { 0x45, 0x58, 0x43, 0x4C, 0x55, 0x53, 0x49, 0x56, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_46[]  = { 0x45, 0x58, 0x49, 0x53, 0x54, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_47[]  = { 0x46, 0x41, 0x4C, 0x53, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_48[]  = { 0x46, 0x45, 0x54, 0x43, 0x48,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_49[]  = { 0x46, 0x4F, 0x52,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_50[]  = { 0x46, 0x52, 0x4F, 0x4D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_51[]  = { 0x47, 0x4F, 0x54, 0x4F,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_52[]  = { 0x47, 0x52, 0x41, 0x4E, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_53[]  = { 0x47, 0x52, 0x4F, 0x55, 0x50,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_54[]  = { 0x48, 0x41, 0x56, 0x49, 0x4E, 0x47,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_55[]  = { 0x49, 0x44, 0x45, 0x4E, 0x54, 0x49, 0x46, 0x49, 0x45, 0x44,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_56[]  = { 0x49, 0x46,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_57[]  = { 0x49, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_58[]  = { 0x49, 0x4E, 0x44, 0x45, 0x58,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_59[]  = { 0x49, 0x4E, 0x44, 0x45, 0x58, 0x45, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_60[]  = { 0x49, 0x4E, 0x53, 0x45, 0x52, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_61[]  = { 0x49, 0x4E, 0x54, 0x45, 0x52, 0x53, 0x45, 0x43, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_62[]  = { 0x49, 0x4E, 0x54, 0x4F,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_63[]  = { 0x49, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_64[]  = { 0x4C, 0x49, 0x4B, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_65[]  = { 0x4C, 0x4F, 0x43, 0x4B,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_66[]  = { 0x4D, 0x49, 0x4E, 0x55, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_67[]  = { 0x4D, 0x4F, 0x44, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_68[]  = { 0x4E, 0x4F, 0x43, 0x4F, 0x4D, 0x50, 0x52, 0x45, 0x53, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_69[]  = { 0x4E, 0x4F, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_70[]  = { 0x4E, 0x4F, 0x57, 0x41, 0x49, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_71[]  = { 0x4E, 0x55, 0x4C, 0x4C,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_72[]  = { 0x4F, 0x46,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_73[]  = { 0x4F, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_74[]  = { 0x4F, 0x50, 0x54, 0x49, 0x4F, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_75[]  = { 0x4F, 0x52,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_76[]  = { 0x4F, 0x52, 0x44, 0x45, 0x52,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_77[]  = { 0x4F, 0x56, 0x45, 0x52, 0x4C, 0x41, 0x50, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_78[]  = { 0x50, 0x52, 0x49, 0x4F, 0x52,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_79[]  = { 0x50, 0x52, 0x4F, 0x43, 0x45, 0x44, 0x55, 0x52, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_80[]  = { 0x50, 0x55, 0x42, 0x4C, 0x49, 0x43,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_81[]  = { 0x52, 0x45, 0x53, 0x4F, 0x55, 0x52, 0x43, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_82[]  = { 0x52, 0x45, 0x56, 0x4F, 0x4B, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_83[]  = { 0x53, 0x45, 0x4C, 0x45, 0x43, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_84[]  = { 0x53, 0x48, 0x41, 0x52, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_85[]  = { 0x53, 0x49, 0x5A, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_86[]  = { 0x53, 0x54, 0x41, 0x52, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_87[]  = { 0x54, 0x41, 0x42, 0x41, 0x55, 0x54, 0x48,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_88[]  = { 0x54, 0x41, 0x42, 0x4C, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_89[]  = { 0x54, 0x48, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_90[]  = { 0x54, 0x48, 0x45, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_91[]  = { 0x54, 0x4F,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_92[]  = { 0x54, 0x52, 0x55, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_93[]  = { 0x55, 0x4E, 0x49, 0x4F, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_94[]  = { 0x55, 0x4E, 0x49, 0x51, 0x55, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_95[]  = { 0x55, 0x50, 0x44, 0x41, 0x54, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_96[]  = { 0x56, 0x41, 0x4C, 0x55, 0x45, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_97[]  = { 0x56, 0x49, 0x45, 0x57,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_98[]  = { 0x56, 0x49, 0x45, 0x57, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_99[]  = { 0x57, 0x48, 0x45, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_100[]  = { 0x57, 0x48, 0x45, 0x52, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_101[]  = { 0x57, 0x49, 0x54, 0x48,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_102[]  = { 0x55, 0x53, 0x49, 0x4E, 0x47,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_103[]  = { 0x4D, 0x4F, 0x44, 0x45, 0x4C,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_104[]  = { 0x45, 0x4C, 0x53, 0x49, 0x46,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_105[]  = { 0x50, 0x49, 0x56, 0x4F, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_106[]  = { 0x55, 0x4E, 0x50, 0x49, 0x56, 0x4F, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_107[]  = { 0x40, 0x21,  antlr3::ANTLR_STRING_TERMINATOR};

}


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

using namespace antlr3;

namespace  Antlr3BackendImpl  {

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



//     // buffer (queue) to hold the emit()'d tokens
//     // private LinkedList<Token> tokenBuffer = new LinkedList<Token>();

//     // public void emit(Token t) {
//     //     tokenBuffer.add(t);
//     // }

//     // private void advanceInput(){
//     //     state.tokenStartCharIndex = input.index();
//     //     state.tokenStartCharPositionInLine = input.getCharPositionInLine();
//     //     state.tokenStartLine = input.getLine();
//     // }


    /**
     * Return a token from this source; i.e., match a token on the char stream.
     */
    // public Token nextToken() {
    //     while (true) {
    //         if (tokenBuffer.size() == 0) {
    //             state.token = null;
    //             state.channel = Token.DEFAULT_CHANNEL;
    //             state.tokenStartCharIndex = input.index();
    //             state.tokenStartCharPositionInLine = input.getCharPositionInLine();
    //             state.tokenStartLine = input.getLine();
    //             state.text = null;
    //             if (input.LA(1) == CharStream.EOF) {
    //                 return Token.EOF_TOKEN;
    //             }
    //             try {
    //                 int m = input.mark();
    //                 state.backtracking = 1;
    //                 state.failed = false;
    //                 mTokens();
    //                 state.backtracking = 0;

    //                 if (state.failed) {
    //                     input.rewind(m);
    //                     input.consume();
    //                 } else {
    //                     emit();
    //                 }
    //             } catch (RecognitionException re) {
    //                 // shouldn't happen in backtracking mode, but...
    //                 reportError(re);
    //                 recover(re);
    //             }
    //         } else {
    //             Token result = tokenBuffer.poll();
    //             if (result == Token.SKIP_TOKEN || result.getType() == Token.INVALID_TOKEN_TYPE || result == null)
    //             {
    //                 // discard
    //                 // SKIP & INVALID
    //                 // tokens
    //                 continue;
    //             }
    //             return result;
    //         }
    //     }
    // }


PLSQLLexer::~PLSQLLexer()
{
}

void
PLSQLLexer::reset()
{
    this->get_rec()->reset();
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "PLSQLLexer.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* PLSQLLexer::getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called PLSQLLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return
 *     - Success pPLSQLLexer initialized for the lex start
 *     - Fail NULL
 */
PLSQLLexer::PLSQLLexer(StreamType* instream)
:PLSQLLexerImplTraits::BaseLexerType(ANTLR_SIZE_HINT, instream, NULL)
{
	// See if we can create a new lexer with the standard constructor
	//
	this->init(instream );
}

/** \brief Create a new lexer called PLSQLLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return
 *     - Success pPLSQLLexer initialized for the lex start
 *     - Fail NULL
 */
PLSQLLexer::PLSQLLexer(StreamType* instream, RecognizerSharedStateType* state)
:PLSQLLexerImplTraits::BaseLexerType(ANTLR_SIZE_HINT, instream, state)
{
	this->init(instream );
}

void PLSQLLexer::init(StreamType* instream)
{
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in PLSQLLexer.h here so you can get a sense
     * of what goes where.
     */

}


/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( FOR_NOTATION | NATIONAL_CHAR_STRING_LIT | BIT_STRING_LIT | HEX_STRING_LIT | PERIOD | EXACT_NUM_LIT | CHAR_STRING | CHAR_STRING_PERL | DELIMITED_ID | PERCENT | AMPERSAND | LEFT_PAREN | RIGHT_PAREN | DOUBLE_ASTERISK | ASTERISK | PLUS_SIGN | COMMA | SOLIDUS | AT_SIGN | ASSIGN_OP | BINDVAR | COLON | SEMICOLON | LESS_THAN_OR_EQUALS_OP | LESS_THAN_OP | GREATER_THAN_OR_EQUALS_OP | NOT_EQUAL_OP | CARRET_OPERATOR_PART | TILDE_OPERATOR_PART | EXCLAMATION_OPERATOR_PART | GREATER_THAN_OP | CONCATENATION_OP | VERTICAL_BAR | EQUALS_OP | LEFT_BRACKET | RIGHT_BRACKET | INTRODUCER | SEPARATOR | PROMPT | SQL92_RESERVED_ALL | SQL92_RESERVED_ALTER | SQL92_RESERVED_AND | SQL92_RESERVED_ANY | SQL92_RESERVED_AS | SQL92_RESERVED_ASC | SQL92_RESERVED_BEGIN | SQL92_RESERVED_BETWEEN | SQL92_RESERVED_BY | SQL92_RESERVED_CASE | SQL92_RESERVED_CHECK | PLSQL_RESERVED_CLUSTERS | PLSQL_RESERVED_COLAUTH | PLSQL_RESERVED_COMPRESS | SQL92_RESERVED_CONNECT | PLSQL_NON_RESERVED_CONNECT_BY_ROOT | PLSQL_RESERVED_CRASH | SQL92_RESERVED_CREATE | SQL92_RESERVED_CURRENT | SQL92_RESERVED_CURSOR | SQL92_RESERVED_DATE | SQL92_RESERVED_DECLARE | SQL92_RESERVED_DEFAULT | SQL92_RESERVED_DELETE | SQL92_RESERVED_DESC | SQL92_RESERVED_DISTINCT | SQL92_RESERVED_DROP | SQL92_RESERVED_ELSE | SQL92_RESERVED_END | SQL92_RESERVED_EXCEPTION | PLSQL_RESERVED_EXCLUSIVE | SQL92_RESERVED_EXISTS | SQL92_RESERVED_FALSE | SQL92_RESERVED_FETCH | SQL92_RESERVED_FOR | SQL92_RESERVED_FROM | SQL92_RESERVED_GOTO | SQL92_RESERVED_GRANT | SQL92_RESERVED_GROUP | SQL92_RESERVED_HAVING | PLSQL_RESERVED_IDENTIFIED | PLSQL_RESERVED_IF | SQL92_RESERVED_IN | PLSQL_RESERVED_INDEX | PLSQL_RESERVED_INDEXES | SQL92_RESERVED_INSERT | SQL92_RESERVED_INTERSECT | SQL92_RESERVED_INTO | SQL92_RESERVED_IS | SQL92_RESERVED_LIKE | PLSQL_RESERVED_LOCK | PLSQL_RESERVED_MINUS | PLSQL_RESERVED_MODE | PLSQL_RESERVED_NOCOMPRESS | SQL92_RESERVED_NOT | PLSQL_RESERVED_NOWAIT | SQL92_RESERVED_NULL | SQL92_RESERVED_OF | SQL92_RESERVED_ON | SQL92_RESERVED_OPTION | SQL92_RESERVED_OR | SQL92_RESERVED_ORDER | SQL92_RESERVED_OVERLAPS | SQL92_RESERVED_PRIOR | SQL92_RESERVED_PROCEDURE | SQL92_RESERVED_PUBLIC | PLSQL_RESERVED_RESOURCE | SQL92_RESERVED_REVOKE | SQL92_RESERVED_SELECT | PLSQL_RESERVED_SHARE | SQL92_RESERVED_SIZE | PLSQL_RESERVED_START | PLSQL_RESERVED_TABAUTH | SQL92_RESERVED_TABLE | SQL92_RESERVED_THE | SQL92_RESERVED_THEN | SQL92_RESERVED_TO | SQL92_RESERVED_TRUE | SQL92_RESERVED_UNION | SQL92_RESERVED_UNIQUE | SQL92_RESERVED_UPDATE | SQL92_RESERVED_VALUES | SQL92_RESERVED_VIEW | PLSQL_RESERVED_VIEWS | SQL92_RESERVED_WHEN | SQL92_RESERVED_WHERE | SQL92_RESERVED_WITH | PLSQL_NON_RESERVED_USING | PLSQL_NON_RESERVED_MODEL | PLSQL_NON_RESERVED_ELSIF | PLSQL_NON_RESERVED_PIVOT | PLSQL_NON_RESERVED_UNPIVOT | REGULAR_ID | ZV );
 */
static const ANTLR_INT32 dfa40_eot[511] =
    {
	-1, 53, 52, 52, 52, 62, -1, 52, -1, -1, -1, -1, -1, 65, -1, -1, 66, 68, 
	70, -1, -1, 73, 75, 76, 77, 78, 80, -1, -1, -1, -1, -1, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, -1, -1, 
	53, -1, 52, 52, 52, 143, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 153, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	183, 187, 188, 52, 52, 52, 52, 193, 194, 52, 197, 52, 52, 52, 52, 52, 52, 
	52, 52, 207, 52, 52, 52, 52, 52, 52, 52, 52, -1, 52, 218, 52, 52, 52, 52, 
	-1, 52, 52, 52, 52, 228, 52, 230, 231, 232, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 252, 52, 52, 52, 52, 258, 52, 
	52, 52, 52, 52, 52, -1, 52, 52, 52, -1, -1, 52, 52, 52, 52, -1, -1, 52, 
	52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 285, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, -1, 52, 299, 52, 52, 52, 52, 52, 52, 52, -1, 52, -1, -1, 
	-1, 308, 52, 52, 52, 52, 52, 52, 52, 52, 52, 318, 52, 52, 52, 322, 52, 
	324, 325, 52, -1, 52, 52, 52, 52, 52, -1, 332, 333, 52, 52, 52, 52, 52, 
	52, 52, 341, 342, 343, 52, 346, 52, 52, 52, 52, 52, 52, 52, 354, 52, 52, 
	52, 358, -1, 359, 52, 52, 52, 52, 52, 52, 367, 368, 52, 370, 52, 52, -1, 
	373, 52, 52, 52, 377, 52, 379, 380, -1, 381, 52, 52, 52, 52, 386, 52, 52, 
	52, -1, 52, 52, 52, -1, 52, -1, -1, 394, 52, 52, 52, 398, 399, -1, -1, 
	400, 401, 52, 52, 405, 52, 52, -1, -1, -1, 408, 409, -1, 52, 411, 52, 52, 
	52, 52, 416, -1, 417, 52, 419, -1, -1, 420, 52, 52, 52, 424, 52, 426, -1, 
	-1, 427, -1, 52, 429, -1, 52, 52, 52, -1, 433, -1, -1, -1, 52, 52, 52, 
	52, -1, 438, 52, 440, 52, 52, 443, 52, -1, 52, 52, 447, -1, -1, -1, -1, 
	448, 52, 52, -1, 451, 52, -1, -1, 453, -1, 52, 52, 456, 457, -1, -1, 52, 
	-1, -1, 459, 52, 461, -1, 462, -1, -1, 52, -1, 464, -1, 52, -1, 52, 467, 
	52, 470, -1, 471, -1, 472, 473, -1, 52, 52, 52, -1, -1, 52, 478, -1, 52, 
	-1, 52, 52, -1, -1, 482, -1, 483, -1, -1, 52, -1, 52, 486, -1, 487, 52, 
	-1, -1, -1, -1, 489, 52, 52, 52, -1, 52, 494, 495, -1, -1, 52, 497, -1, 
	-1, 52, -1, 499, 500, 52, 502, -1, -1, 503, -1, 52, -1, -1, 505, -1, -1, 
	52, -1, 52, 52, 52, 510, -1
    };
static const ANTLR_INT32 dfa40_eof[511] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa40_min[511] =
    {
	9, 46, 39, 39, 39, 48, -1, 39, -1, -1, -1, -1, -1, 42, -1, -1, 42, 33, 
	34, -1, -1, 61, 61, 61, 61, 61, 124, -1, -1, -1, -1, -1, 73, 76, 39, 65, 
	65, 76, 65, 79, 65, 68, 73, 73, 39, 70, 69, 69, 65, 78, 65, 72, -1, -1, 
	46, -1, 67, 76, 71, 35, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 73, 66, 86, 76, 68, 35, 83, 69, 85, 
	76, 65, 82, 84, 67, 83, 79, 83, 68, 67, 76, 84, 82, 79, 84, 65, 86, 69, 
	35, 35, 35, 75, 67, 78, 68, 35, 35, 84, 35, 69, 83, 76, 65, 90, 65, 66, 
	69, 35, 85, 73, 68, 73, 76, 69, 69, 84, -1, 79, 35, 65, 76, 73, 87, -1, 
	67, 79, 76, 79, 35, 69, 35, 35, 35, -1, 69, 67, 83, 65, 80, 78, 83, 65, 
	82, 69, 76, 65, 69, 67, 84, 80, 69, 35, 69, 83, 83, 67, 35, 77, 79, 78, 
	85, 73, 78, -1, 69, 69, 69, -1, -1, 69, 75, 85, 69, -1, -1, 73, 69, -1, 
	82, 79, 79, 69, 82, 69, 82, 65, 35, -1, 69, 79, 73, 65, 78, 85, 87, 78, 
	72, 77, -1, 73, 35, 78, 69, 80, 69, 82, 73, 84, -1, 82, -1, -1, -1, 35, 
	75, 84, 85, 82, 69, 72, 84, 69, 79, 35, 65, 85, 84, 35, 73, 35, 35, 70, 
	-1, 80, 85, 84, 69, 72, -1, 35, 35, 84, 80, 78, 84, 88, 82, 82, 35, 35, 
	35, 83, 35, 79, 82, 76, 85, 75, 67, 69, 35, 84, 85, 69, 35, -1, 35, 78, 
	85, 86, 84, 71, 69, 35, 35, 69, 35, 80, 84, -1, 35, 69, 84, 68, 35, 67, 
	35, 35, -1, 35, 69, 84, 69, 67, 35, 69, 78, 82, -1, 82, 76, 69, -1, 78, 
	-1, -1, 35, 84, 83, 83, 35, 35, -1, -1, 35, 35, 71, 73, 35, 84, 83, -1, 
	-1, -1, 35, 35, -1, 78, 35, 65, 82, 69, 84, 35, -1, 35, 84, 35, -1, -1, 
	35, 69, 79, 69, 35, 83, 35, -1, -1, 35, -1, 82, 35, -1, 78, 9, 85, -1, 
	35, -1, -1, -1, 82, 72, 83, 84, -1, 35, 84, 35, 69, 84, 35, 67, -1, 73, 
	73, 35, -1, -1, -1, -1, 35, 70, 83, -1, 35, 69, -1, -1, 35, -1, 80, 67, 
	35, 35, -1, -1, 72, -1, -1, 35, 84, 35, -1, 35, -1, -1, 69, -1, 35, -1, 
	82, -1, 83, 35, 83, 35, -1, 35, -1, 35, 35, -1, 84, 79, 86, -1, -1, 73, 
	35, -1, 67, -1, 83, 69, -1, -1, 35, -1, 35, -1, -1, 83, -1, 69, 35, -1, 
	35, 66, -1, -1, -1, -1, 35, 78, 69, 69, -1, 84, 35, 35, -1, -1, 83, 35, 
	-1, -1, 89, -1, 35, 35, 68, 35, -1, -1, 35, -1, 95, -1, -1, 35, -1, -1, 
	82, -1, 79, 79, 84, 35, -1
    };
static const ANTLR_INT32 dfa40_max[511] =
    {
	126, 57, 85, 89, 39, 57, -1, 39, -1, -1, -1, -1, -1, 42, -1, -1, 42, 33, 
	122, -1, -1, 62, 61, 61, 61, 61, 124, -1, -1, -1, -1, -1, 85, 83, 39, 85, 
	82, 88, 82, 82, 65, 83, 79, 79, 39, 86, 69, 84, 82, 83, 73, 73, -1, -1, 
	46, -1, 87, 76, 84, 122, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 79, 66, 86, 84, 89, 122, 83, 69, 85, 
	78, 69, 82, 84, 83, 83, 79, 83, 68, 73, 76, 84, 82, 79, 84, 79, 86, 69, 
	122, 122, 122, 75, 67, 78, 68, 122, 122, 84, 122, 69, 86, 76, 65, 90, 65, 
	66, 69, 122, 85, 80, 68, 73, 76, 69, 69, 84, -1, 79, 122, 65, 76, 73, 87, 
	-1, 77, 79, 76, 79, 122, 69, 122, 122, 122, -1, 69, 67, 83, 65, 80, 78, 
	83, 65, 83, 69, 76, 65, 69, 67, 84, 80, 73, 122, 76, 83, 83, 67, 122, 77, 
	79, 78, 85, 73, 78, -1, 69, 69, 79, -1, -1, 69, 75, 85, 69, -1, -1, 73, 
	69, -1, 82, 79, 79, 69, 82, 69, 82, 76, 122, -1, 69, 81, 73, 65, 78, 85, 
	87, 82, 72, 77, -1, 73, 122, 78, 69, 80, 69, 82, 73, 84, -1, 82, -1, -1, 
	-1, 122, 75, 84, 85, 82, 69, 72, 84, 69, 79, 122, 65, 85, 84, 122, 73, 
	122, 122, 70, -1, 80, 85, 84, 69, 72, -1, 122, 122, 84, 80, 78, 84, 88, 
	82, 82, 122, 122, 122, 83, 122, 79, 82, 76, 85, 75, 67, 69, 122, 84, 85, 
	69, 122, -1, 122, 78, 85, 86, 84, 71, 69, 122, 122, 69, 122, 80, 84, -1, 
	122, 69, 84, 68, 122, 67, 122, 122, -1, 122, 69, 84, 69, 67, 122, 69, 78, 
	82, -1, 82, 76, 69, -1, 78, -1, -1, 122, 84, 83, 83, 122, 122, -1, -1, 
	122, 122, 71, 73, 122, 84, 83, -1, -1, -1, 122, 122, -1, 78, 122, 65, 82, 
	69, 84, 122, -1, 122, 84, 122, -1, -1, 122, 69, 79, 69, 122, 83, 122, -1, 
	-1, 122, -1, 82, 122, -1, 78, 32, 85, -1, 122, -1, -1, -1, 82, 72, 83, 
	84, -1, 122, 84, 122, 69, 84, 122, 67, -1, 73, 73, 122, -1, -1, -1, -1, 
	122, 70, 83, -1, 122, 69, -1, -1, 122, -1, 80, 67, 122, 122, -1, -1, 72, 
	-1, -1, 122, 84, 122, -1, 122, -1, -1, 69, -1, 122, -1, 82, -1, 83, 122, 
	83, 122, -1, 122, -1, 122, 122, -1, 84, 79, 86, -1, -1, 73, 122, -1, 67, 
	-1, 83, 69, -1, -1, 122, -1, 122, -1, -1, 83, -1, 69, 122, -1, 122, 66, 
	-1, -1, -1, -1, 122, 78, 69, 69, -1, 84, 122, 122, -1, -1, 83, 122, -1, 
	-1, 89, -1, 122, 122, 68, 122, -1, -1, 122, -1, 95, -1, -1, 122, -1, -1, 
	82, -1, 79, 79, 84, 122, -1
    };
static const ANTLR_INT32 dfa40_accept[511] =
    {
	-1, -1, -1, -1, -1, -1, 7, -1, 9, 10, 11, 12, 13, -1, 16, 17, -1, -1, -1, 
	21, 23, -1, -1, -1, -1, -1, -1, 34, 35, 36, 37, 38, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 132, 6, -1, 
	2, -1, -1, -1, -1, 3, 4, 5, 8, 14, 15, 18, 133, 19, 20, 22, 24, 27, 25, 
	26, 31, 30, 28, 29, 32, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, 48, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 44, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 81, -1, -1, -1, 82, 88, -1, -1, -1, -1, 97, 98, -1, -1, 100, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 116, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	94, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, -1, 42, 43, 45, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 68, -1, 
	-1, -1, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 96, -1, -1, -1, -1, -1, -1, -1, -1, 
	49, -1, -1, -1, -1, -1, -1, -1, -1, -1, 60, -1, -1, -1, 64, -1, 66, 67, 
	-1, -1, -1, -1, -1, -1, 75, 76, -1, -1, -1, -1, -1, -1, -1, 87, 89, 90, 
	-1, -1, 92, -1, -1, -1, -1, -1, -1, -1, 110, -1, -1, -1, 115, 117, -1, 
	-1, -1, -1, -1, -1, -1, 122, 124, -1, 126, -1, -1, 46, -1, -1, -1, 103, 
	-1, 130, 41, 50, -1, -1, -1, -1, 56, -1, -1, -1, -1, -1, -1, -1, 129, -1, 
	-1, -1, 72, 73, 77, 78, -1, -1, -1, 83, -1, -1, 91, 128, -1, 101, -1, -1, 
	-1, -1, 109, 111, -1, 113, 118, -1, -1, -1, 127, -1, 123, 125, -1, 95, 
	-1, 39, -1, 105, -1, -1, -1, -1, 57, -1, 59, -1, -1, 63, -1, -1, -1, 71, 
	79, -1, -1, 85, -1, 99, -1, -1, 107, 108, -1, 119, -1, 120, 121, -1, 47, 
	-1, -1, 52, -1, -1, 54, 58, 61, 62, -1, -1, -1, -1, 84, -1, -1, -1, 112, 
	131, -1, -1, 51, 53, -1, 65, -1, -1, -1, -1, 102, 106, -1, 104, -1, 69, 
	70, -1, 86, 93, -1, 80, -1, -1, -1, -1, 55
    };
static const ANTLR_INT32 dfa40_special[511] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa40_T_empty	 =   NULL;

static const ANTLR_INT32 dfa40_T0[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa40_T1[] =
    {
	199, -1, -1, 200
    };

static const ANTLR_INT32 dfa40_T2[] =
    {
	115, -1, -1, -1, -1, -1, -1, -1, 116, -1, 117, -1, 118, -1, -1, -1, 119
    };

static const ANTLR_INT32 dfa40_T3[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 196, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa40_T4[] =
    {
	150, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 151
    };

static const ANTLR_INT32 dfa40_T5[] =
    {
	137, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 138, 
	-1, -1, 139
    };

static const ANTLR_INT32 dfa40_T6[] =
    {
	272
    };

static const ANTLR_INT32 dfa40_T7[] =
    {
	192
    };

static const ANTLR_INT32 dfa40_T8[] =
    {
	141, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 142
    };

static const ANTLR_INT32 dfa40_T9[] =
    {
	437
    };

static const ANTLR_INT32 dfa40_T10[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 345, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa40_T11[] =
    {
	238
    };

static const ANTLR_INT32 dfa40_T12[] =
    {
	313
    };

static const ANTLR_INT32 dfa40_T13[] =
    {
	385
    };

static const ANTLR_INT32 dfa40_T14[] =
    {
	136
    };

static const ANTLR_INT32 dfa40_T15[] =
    {
	157, 158, 159
    };

static const ANTLR_INT32 dfa40_T16[] =
    {
	160, -1, -1, -1, 161
    };

static const ANTLR_INT32 dfa40_T17[] =
    {
	282, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 283
    };

static const ANTLR_INT32 dfa40_T18[] =
    {
	205
    };

static const ANTLR_INT32 dfa40_T19[] =
    {
	97, -1, 98, -1, -1, -1, -1, -1, -1, -1, -1, -1, 99
    };

static const ANTLR_INT32 dfa40_T20[] =
    {
	206
    };

static const ANTLR_INT32 dfa40_T21[] =
    {
	120
    };

static const ANTLR_INT32 dfa40_T22[] =
    {
	287, -1, 288
    };

static const ANTLR_INT32 dfa40_T23[] =
    {
	301
    };

static const ANTLR_INT32 dfa40_T24[] =
    {
	222
    };

static const ANTLR_INT32 dfa40_T25[] =
    {
	364
    };

static const ANTLR_INT32 dfa40_T26[] =
    {
	291
    };

static const ANTLR_INT32 dfa40_T27[] =
    {
	212
    };

static const ANTLR_INT32 dfa40_T28[] =
    {
	267, -1, -1, -1, -1, -1, -1, -1, -1, -1, 268
    };

static const ANTLR_INT32 dfa40_T29[] =
    {
	430
    };

static const ANTLR_INT32 dfa40_T30[] =
    {
	374
    };

static const ANTLR_INT32 dfa40_T31[] =
    {
	154
    };

static const ANTLR_INT32 dfa40_T32[] =
    {
	233
    };

static const ANTLR_INT32 dfa40_T33[] =
    {
	234
    };

static const ANTLR_INT32 dfa40_T34[] =
    {
	326
    };

static const ANTLR_INT32 dfa40_T35[] =
    {
	309
    };

static const ANTLR_INT32 dfa40_T36[] =
    {
	147
    };

static const ANTLR_INT32 dfa40_T37[] =
    {
	227
    };

static const ANTLR_INT32 dfa40_T38[] =
    {
	155
    };

static const ANTLR_INT32 dfa40_T39[] =
    {
	306
    };

static const ANTLR_INT32 dfa40_T40[] =
    {
	307
    };

static const ANTLR_INT32 dfa40_T41[] =
    {
	289
    };

static const ANTLR_INT32 dfa40_T42[] =
    {
	422
    };

static const ANTLR_INT32 dfa40_T43[] =
    {
	362
    };

static const ANTLR_INT32 dfa40_T44[] =
    {
	460
    };

static const ANTLR_INT32 dfa40_T45[] =
    {
	54, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    };

static const ANTLR_INT32 dfa40_T46[] =
    {
	31
    };

static const ANTLR_INT32 dfa40_T47[] =
    {
	221
    };

static const ANTLR_INT32 dfa40_T48[] =
    {
	300
    };

static const ANTLR_INT32 dfa40_T49[] =
    {
	421
    };

static const ANTLR_INT32 dfa40_T50[] =
    {
	361
    };

static const ANTLR_INT32 dfa40_T51[] =
    {
	363
    };

static const ANTLR_INT32 dfa40_T52[] =
    {
	290
    };

static const ANTLR_INT32 dfa40_T53[] =
    {
	211
    };

static const ANTLR_INT32 dfa40_T54[] =
    {
	213
    };

static const ANTLR_INT32 dfa40_T55[] =
    {
	488
    };

static const ANTLR_INT32 dfa40_T56[] =
    {
	292
    };

static const ANTLR_INT32 dfa40_T57[] =
    {
	506
    };

static const ANTLR_INT32 dfa40_T58[] =
    {
	507
    };

static const ANTLR_INT32 dfa40_T59[] =
    {
	498
    };

static const ANTLR_INT32 dfa40_T60[] =
    {
	423
    };

static const ANTLR_INT32 dfa40_T61[] =
    {
	504
    };

static const ANTLR_INT32 dfa40_T62[] =
    {
	508
    };

static const ANTLR_INT32 dfa40_T63[] =
    {
	509
    };

static const ANTLR_INT32 dfa40_T64[] =
    {
	365
    };

static const ANTLR_INT32 dfa40_T65[] =
    {
	425
    };

static const ANTLR_INT32 dfa40_T66[] =
    {
	113, -1, -1, -1, -1, -1, 114
    };

static const ANTLR_INT32 dfa40_T67[] =
    {
	156
    };

static const ANTLR_INT32 dfa40_T68[] =
    {
	310
    };

static const ANTLR_INT32 dfa40_T69[] =
    {
	235
    };

static const ANTLR_INT32 dfa40_T70[] =
    {
	434
    };

static const ANTLR_INT32 dfa40_T71[] =
    {
	382
    };

static const ANTLR_INT32 dfa40_T72[] =
    {
	466
    };

static const ANTLR_INT32 dfa40_T73[] =
    {
	236
    };

static const ANTLR_INT32 dfa40_T74[] =
    {
	311
    };

static const ANTLR_INT32 dfa40_T75[] =
    {
	383
    };

static const ANTLR_INT32 dfa40_T76[] =
    {
	435
    };

static const ANTLR_INT32 dfa40_T77[] =
    {
	369
    };

static const ANTLR_INT32 dfa40_T78[] =
    {
	125, -1, -1, -1, -1, -1, -1, 126, -1, -1, -1, -1, -1, -1, 127, -1, -1, 
	128
    };

static const ANTLR_INT32 dfa40_T79[] =
    {
	237
    };

static const ANTLR_INT32 dfa40_T80[] =
    {
	216
    };

static const ANTLR_INT32 dfa40_T81[] =
    {
	296
    };

static const ANTLR_INT32 dfa40_T82[] =
    {
	312
    };

static const ANTLR_INT32 dfa40_T83[] =
    {
	384
    };

static const ANTLR_INT32 dfa40_T84[] =
    {
	436
    };

static const ANTLR_INT32 dfa40_T85[] =
    {
	468
    };

static const ANTLR_INT32 dfa40_T86[] =
    {
	79
    };

static const ANTLR_INT32 dfa40_T87[] =
    {
	431, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 431
    };

static const ANTLR_INT32 dfa40_T88[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 284, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa40_T89[] =
    {
	84, -1, 85, -1, -1, -1, -1, 86
    };

static const ANTLR_INT32 dfa40_T90[] =
    {
	148, -1, -1, -1, -1, -1, -1, -1, 149
    };

static const ANTLR_INT32 dfa40_T91[] =
    {
	170
    };

static const ANTLR_INT32 dfa40_T92[] =
    {
	87, -1, -1, -1, -1, -1, -1, 88, -1, -1, -1, 89, -1, -1, 90, -1, -1, 91, 
	-1, -1, 92
    };

static const ANTLR_INT32 dfa40_T93[] =
    {
	250, -1, -1, -1, 251
    };

static const ANTLR_INT32 dfa40_T94[] =
    {
	55
    };

static const ANTLR_INT32 dfa40_T95[] =
    {
	209, -1, -1, -1, -1, -1, -1, 210
    };

static const ANTLR_INT32 dfa40_T96[] =
    {
	74
    };

static const ANTLR_INT32 dfa40_T97[] =
    {
	31, 31, -1, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 31, 23, 8, -1, -1, 9, 10, 6, 11, 12, 13, 14, 15, 31, 
	5, 16, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 20, 21, 27, 22, 19, 17, 33, 3, 
	35, 36, 37, 38, 39, 40, 41, 52, 52, 42, 43, 2, 45, 32, 7, 46, 47, 48, 49, 
	50, 51, 4, 52, 52, 28, -1, 29, 24, 30, -1, 52, 34, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 44, 52, 52, 7, 52, 52, 52, 52, 52, 52, 4, 52, 52, 
	-1, 26, -1, 25
    };

static const ANTLR_INT32 dfa40_T98[] =
    {
	229
    };

static const ANTLR_INT32 dfa40_T99[] =
    {
	63
    };

static const ANTLR_INT32 dfa40_T100[] =
    {
	72
    };

static const ANTLR_INT32 dfa40_T101[] =
    {
	145, -1, -1, -1, -1, -1, 144
    };

static const ANTLR_INT32 dfa40_T102[] =
    {
	302
    };

static const ANTLR_INT32 dfa40_T103[] =
    {
	375
    };

static const ANTLR_INT32 dfa40_T104[] =
    {
	275
    };

static const ANTLR_INT32 dfa40_T105[] =
    {
	349
    };

static const ANTLR_INT32 dfa40_T106[] =
    {
	198
    };

static const ANTLR_INT32 dfa40_T107[] =
    {
	480
    };

static const ANTLR_INT32 dfa40_T108[] =
    {
	412
    };

static const ANTLR_INT32 dfa40_T109[] =
    {
	454
    };

static const ANTLR_INT32 dfa40_T110[] =
    {
	410
    };

static const ANTLR_INT32 dfa40_T111[] =
    {
	347
    };

static const ANTLR_INT32 dfa40_T112[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 152, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa40_T113[] =
    {
	273
    };

static const ANTLR_INT32 dfa40_T114[] =
    {
	348
    };

static const ANTLR_INT32 dfa40_T115[] =
    {
	274
    };

static const ANTLR_INT32 dfa40_T116[] =
    {
	195
    };

static const ANTLR_INT32 dfa40_T117[] =
    {
	298
    };

static const ANTLR_INT32 dfa40_T118[] =
    {
	219
    };

static const ANTLR_INT32 dfa40_T119[] =
    {
	106
    };

static const ANTLR_INT32 dfa40_T120[] =
    {
	104, -1, -1, 105
    };

static const ANTLR_INT32 dfa40_T121[] =
    {
	220
    };

static const ANTLR_INT32 dfa40_T122[] =
    {
	140
    };

static const ANTLR_INT32 dfa40_T123[] =
    {
	372
    };

static const ANTLR_INT32 dfa40_T124[] =
    {
	217
    };

static const ANTLR_INT32 dfa40_T125[] =
    {
	428
    };

static const ANTLR_INT32 dfa40_T126[] =
    {
	463
    };

static const ANTLR_INT32 dfa40_T127[] =
    {
	297
    };

static const ANTLR_INT32 dfa40_T128[] =
    {
	371
    };

static const ANTLR_INT32 dfa40_T129[] =
    {
	484
    };

static const ANTLR_INT32 dfa40_T130[] =
    {
	496
    };

static const ANTLR_INT32 dfa40_T131[] =
    {
	191
    };

static const ANTLR_INT32 dfa40_T132[] =
    {
	111, -1, -1, -1, -1, -1, 112
    };

static const ANTLR_INT32 dfa40_T133[] =
    {
	344
    };

static const ANTLR_INT32 dfa40_T134[] =
    {
	271
    };

static const ANTLR_INT32 dfa40_T135[] =
    {
	179, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 180
    };

static const ANTLR_INT32 dfa40_T136[] =
    {
	64
    };

static const ANTLR_INT32 dfa40_T137[] =
    {
	189
    };

static const ANTLR_INT32 dfa40_T138[] =
    {
	269
    };

static const ANTLR_INT32 dfa40_T139[] =
    {
	190
    };

static const ANTLR_INT32 dfa40_T140[] =
    {
	270
    };

static const ANTLR_INT32 dfa40_T141[] =
    {
	107, -1, 108, -1, -1, -1, -1, -1, -1, -1, 109, -1, -1, -1, -1, 110
    };

static const ANTLR_INT32 dfa40_T142[] =
    {
	452
    };

static const ANTLR_INT32 dfa40_T143[] =
    {
	407
    };

static const ANTLR_INT32 dfa40_T144[] =
    {
	493
    };

static const ANTLR_INT32 dfa40_T145[] =
    {
	479
    };

static const ANTLR_INT32 dfa40_T146[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 366, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa40_T147[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 404, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa40_T148[] =
    {
	61
    };

static const ANTLR_INT32 dfa40_T149[] =
    {
	360
    };

static const ANTLR_INT32 dfa40_T150[] =
    {
	286
    };

static const ANTLR_INT32 dfa40_T151[] =
    {
	208
    };

static const ANTLR_INT32 dfa40_T152[] =
    {
	55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 56, -1, -1, -1, -1, -1, 57
    };

static const ANTLR_INT32 dfa40_T153[] =
    {
	357
    };

static const ANTLR_INT32 dfa40_T154[] =
    {
	458
    };

static const ANTLR_INT32 dfa40_T155[] =
    {
	418
    };

static const ANTLR_INT32 dfa40_T156[] =
    {
	356
    };

static const ANTLR_INT32 dfa40_T157[] =
    {
	129, -1, 130, -1, -1, 131
    };

static const ANTLR_INT32 dfa40_T158[] =
    {
	204
    };

static const ANTLR_INT32 dfa40_T159[] =
    {
	281
    };

static const ANTLR_INT32 dfa40_T160[] =
    {
	355
    };

static const ANTLR_INT32 dfa40_T161[] =
    {
	172, -1, -1, -1, -1, -1, 173
    };

static const ANTLR_INT32 dfa40_T162[] =
    {
	203
    };

static const ANTLR_INT32 dfa40_T163[] =
    {
	280
    };

static const ANTLR_INT32 dfa40_T164[] =
    {
	279
    };

static const ANTLR_INT32 dfa40_T165[] =
    {
	202
    };

static const ANTLR_INT32 dfa40_T166[] =
    {
	353
    };

static const ANTLR_INT32 dfa40_T167[] =
    {
	352
    };

static const ANTLR_INT32 dfa40_T168[] =
    {
	278
    };

static const ANTLR_INT32 dfa40_T169[] =
    {
	201
    };

static const ANTLR_INT32 dfa40_T170[] =
    {
	415
    };

static const ANTLR_INT32 dfa40_T171[] =
    {
	351
    };

static const ANTLR_INT32 dfa40_T172[] =
    {
	414
    };

static const ANTLR_INT32 dfa40_T173[] =
    {
	277
    };

static const ANTLR_INT32 dfa40_T174[] =
    {
	53, 53, 53, 53, 53, 53, 53, 53, 53, 53
    };

static const ANTLR_INT32 dfa40_T175[] =
    {
	481
    };

static const ANTLR_INT32 dfa40_T176[] =
    {
	413
    };

static const ANTLR_INT32 dfa40_T177[] =
    {
	455
    };

static const ANTLR_INT32 dfa40_T178[] =
    {
	350
    };

static const ANTLR_INT32 dfa40_T179[] =
    {
	276
    };

static const ANTLR_INT32 dfa40_T180[] =
    {
	226
    };

static const ANTLR_INT32 dfa40_T181[] =
    {
	146
    };

static const ANTLR_INT32 dfa40_T182[] =
    {
	378
    };

static const ANTLR_INT32 dfa40_T183[] =
    {
	305
    };

static const ANTLR_INT32 dfa40_T184[] =
    {
	303
    };

static const ANTLR_INT32 dfa40_T185[] =
    {
	265
    };

static const ANTLR_INT32 dfa40_T186[] =
    {
	376
    };

static const ANTLR_INT32 dfa40_T187[] =
    {
	432
    };

static const ANTLR_INT32 dfa40_T188[] =
    {
	465
    };

static const ANTLR_INT32 dfa40_T189[] =
    {
	485
    };

static const ANTLR_INT32 dfa40_T190[] =
    {
	67
    };

static const ANTLR_INT32 dfa40_T191[] =
    {
	225
    };

static const ANTLR_INT32 dfa40_T192[] =
    {
	304
    };

static const ANTLR_INT32 dfa40_T193[] =
    {
	338
    };

static const ANTLR_INT32 dfa40_T194[] =
    {
	132, -1, -1, -1, -1, -1, -1, -1, 133
    };

static const ANTLR_INT32 dfa40_T195[] =
    {
	171
    };

static const ANTLR_INT32 dfa40_T196[] =
    {
	100, -1, -1, -1, 101, -1, -1, -1, -1, -1, -1, -1, -1, -1, 102, -1, -1, 
	103
    };

static const ANTLR_INT32 dfa40_T197[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 469, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa40_T198[] =
    {
	162
    };

static const ANTLR_INT32 dfa40_T199[] =
    {
	327
    };

static const ANTLR_INT32 dfa40_T200[] =
    {
	241, 242
    };

static const ANTLR_INT32 dfa40_T201[] =
    {
	395
    };

static const ANTLR_INT32 dfa40_T202[] =
    {
	445
    };

static const ANTLR_INT32 dfa40_T203[] =
    {
	475
    };

static const ANTLR_INT32 dfa40_T204[] =
    {
	490
    };

static const ANTLR_INT32 dfa40_T205[] =
    {
	396
    };

static const ANTLR_INT32 dfa40_T206[] =
    {
	446
    };

static const ANTLR_INT32 dfa40_T207[] =
    {
	476
    };

static const ANTLR_INT32 dfa40_T208[] =
    {
	491
    };

static const ANTLR_INT32 dfa40_T209[] =
    {
	328
    };

static const ANTLR_INT32 dfa40_T210[] =
    {
	392
    };

static const ANTLR_INT32 dfa40_T211[] =
    {
	321
    };

static const ANTLR_INT32 dfa40_T212[] =
    {
	248
    };

static const ANTLR_INT32 dfa40_T213[] =
    {
	168
    };

static const ANTLR_INT32 dfa40_T214[] =
    {
	247
    };

static const ANTLR_INT32 dfa40_T215[] =
    {
	444
    };

static const ANTLR_INT32 dfa40_T216[] =
    {
	474
    };

static const ANTLR_INT32 dfa40_T217[] =
    {
	323
    };

static const ANTLR_INT32 dfa40_T218[] =
    {
	393
    };

static const ANTLR_INT32 dfa40_T219[] =
    {
	249
    };

static const ANTLR_INT32 dfa40_T220[] =
    {
	169
    };

static const ANTLR_INT32 dfa40_T221[] =
    {
	134, 135
    };

static const ANTLR_INT32 dfa40_T222[] =
    {
	163
    };

static const ANTLR_INT32 dfa40_T223[] =
    {
	243
    };

static const ANTLR_INT32 dfa40_T224[] =
    {
	244
    };

static const ANTLR_INT32 dfa40_T225[] =
    {
	390
    };

static const ANTLR_INT32 dfa40_T226[] =
    {
	319
    };

static const ANTLR_INT32 dfa40_T227[] =
    {
	60, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 59
    };

static const ANTLR_INT32 dfa40_T228[] =
    {
	441
    };

static const ANTLR_INT32 dfa40_T229[] =
    {
	60
    };

static const ANTLR_INT32 dfa40_T230[] =
    {
	245
    };

static const ANTLR_INT32 dfa40_T231[] =
    {
	320
    };

static const ANTLR_INT32 dfa40_T232[] =
    {
	391
    };

static const ANTLR_INT32 dfa40_T233[] =
    {
	442
    };

static const ANTLR_INT32 dfa40_T234[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 184, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 185, 186, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa40_T235[] =
    {
	246
    };

static const ANTLR_INT32 dfa40_T236[] =
    {
	314
    };

static const ANTLR_INT32 dfa40_T237[] =
    {
	239
    };

static const ANTLR_INT32 dfa40_T238[] =
    {
	387
    };

static const ANTLR_INT32 dfa40_T239[] =
    {
	315
    };

static const ANTLR_INT32 dfa40_T240[] =
    {
	240
    };

static const ANTLR_INT32 dfa40_T241[] =
    {
	316
    };

static const ANTLR_INT32 dfa40_T242[] =
    {
	388
    };

static const ANTLR_INT32 dfa40_T243[] =
    {
	439
    };

static const ANTLR_INT32 dfa40_T244[] =
    {
	164, -1, -1, 165, -1, -1, -1, -1, -1, 166, -1, -1, -1, -1, -1, -1, 167
    };

static const ANTLR_INT32 dfa40_T245[] =
    {
	83, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, -1, 82
    };

static const ANTLR_INT32 dfa40_T246[] =
    {
	317
    };

static const ANTLR_INT32 dfa40_T247[] =
    {
	389
    };

static const ANTLR_INT32 dfa40_T248[] =
    {
	450
    };

static const ANTLR_INT32 dfa40_T249[] =
    {
	19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 
	19, 19, 19, 19, 19, 19, -1, -1, -1, 69, -1, -1, -1, 19, 19, 19, 19, 19, 
	19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19
    };

static const ANTLR_INT32 dfa40_T250[] =
    {
	340
    };

static const ANTLR_INT32 dfa40_T251[] =
    {
	266
    };

static const ANTLR_INT32 dfa40_T252[] =
    {
	406
    };

static const ANTLR_INT32 dfa40_T253[] =
    {
	339
    };

static const ANTLR_INT32 dfa40_T254[] =
    {
	93, -1, -1, -1, 94, -1, -1, -1, 95, -1, -1, -1, -1, -1, -1, -1, -1, 96
    };

static const ANTLR_INT32 dfa40_T255[] =
    {
	403
    };

static const ANTLR_INT32 dfa40_T256[] =
    {
	449
    };

static const ANTLR_INT32 dfa40_T257[] =
    {
	264
    };

static const ANTLR_INT32 dfa40_T258[] =
    {
	337
    };

static const ANTLR_INT32 dfa40_T259[] =
    {
	182
    };

static const ANTLR_INT32 dfa40_T260[] =
    {
	294, -1, -1, -1, 295
    };

static const ANTLR_INT32 dfa40_T261[] =
    {
	215
    };

static const ANTLR_INT32 dfa40_T262[] =
    {
	336
    };

static const ANTLR_INT32 dfa40_T263[] =
    {
	402
    };

static const ANTLR_INT32 dfa40_T264[] =
    {
	181
    };

static const ANTLR_INT32 dfa40_T265[] =
    {
	263
    };

static const ANTLR_INT32 dfa40_T266[] =
    {
	71, 72
    };

static const ANTLR_INT32 dfa40_T267[] =
    {
	293
    };

static const ANTLR_INT32 dfa40_T268[] =
    {
	501
    };

static const ANTLR_INT32 dfa40_T269[] =
    {
	492
    };

static const ANTLR_INT32 dfa40_T270[] =
    {
	477
    };

static const ANTLR_INT32 dfa40_T271[] =
    {
	178
    };

static const ANTLR_INT32 dfa40_T272[] =
    {
	260
    };

static const ANTLR_INT32 dfa40_T273[] =
    {
	253, -1, -1, -1, -1, -1, -1, 254
    };

static const ANTLR_INT32 dfa40_T274[] =
    {
	177
    };

static const ANTLR_INT32 dfa40_T275[] =
    {
	259
    };

static const ANTLR_INT32 dfa40_T276[] =
    {
	214
    };

static const ANTLR_INT32 dfa40_T277[] =
    {
	262
    };

static const ANTLR_INT32 dfa40_T278[] =
    {
	121, -1, -1, 122, 123, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 124
    };

static const ANTLR_INT32 dfa40_T279[] =
    {
	335
    };

static const ANTLR_INT32 dfa40_T280[] =
    {
	261
    };

static const ANTLR_INT32 dfa40_T281[] =
    {
	334
    };

static const ANTLR_INT32 dfa40_T282[] =
    {
	224, -1, -1, -1, -1, -1, -1, -1, -1, -1, 223
    };

static const ANTLR_INT32 dfa40_T283[] =
    {
	397
    };

static const ANTLR_INT32 dfa40_T284[] =
    {
	174
    };

static const ANTLR_INT32 dfa40_T285[] =
    {
	256
    };

static const ANTLR_INT32 dfa40_T286[] =
    {
	255
    };

static const ANTLR_INT32 dfa40_T287[] =
    {
	329
    };

static const ANTLR_INT32 dfa40_T288[] =
    {
	331
    };

static const ANTLR_INT32 dfa40_T289[] =
    {
	176
    };

static const ANTLR_INT32 dfa40_T290[] =
    {
	330
    };

static const ANTLR_INT32 dfa40_T291[] =
    {
	257
    };

static const ANTLR_INT32 dfa40_T292[] =
    {
	175
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa40_transitions[] =
{
    dfa40_T97, dfa40_T45, dfa40_T152, dfa40_T227, dfa40_T148, dfa40_T174, 
    NULL, dfa40_T99, NULL, NULL, NULL, NULL, NULL, dfa40_T136, NULL, NULL, 
    dfa40_T46, dfa40_T190, dfa40_T249, NULL, NULL, dfa40_T266, dfa40_T96, 
    dfa40_T100, dfa40_T100, dfa40_T100, dfa40_T86, NULL, NULL, NULL, NULL, 
    NULL, dfa40_T245, dfa40_T89, dfa40_T229, dfa40_T92, dfa40_T254, dfa40_T19, 
    dfa40_T196, dfa40_T120, dfa40_T119, dfa40_T141, dfa40_T132, dfa40_T66, 
    dfa40_T94, dfa40_T2, dfa40_T21, dfa40_T278, dfa40_T78, dfa40_T157, dfa40_T194, 
    dfa40_T221, NULL, NULL, dfa40_T14, NULL, dfa40_T5, dfa40_T122, dfa40_T8, 
    dfa40_T0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, dfa40_T101, 
    dfa40_T181, dfa40_T36, dfa40_T90, dfa40_T4, dfa40_T112, dfa40_T31, dfa40_T38, 
    dfa40_T67, dfa40_T15, dfa40_T16, dfa40_T198, dfa40_T222, dfa40_T244, 
    dfa40_T213, dfa40_T220, dfa40_T91, dfa40_T195, dfa40_T161, dfa40_T284, 
    dfa40_T292, dfa40_T289, dfa40_T274, dfa40_T271, dfa40_T135, dfa40_T264, 
    dfa40_T259, dfa40_T0, dfa40_T234, dfa40_T0, dfa40_T137, dfa40_T139, 
    dfa40_T131, dfa40_T7, dfa40_T0, dfa40_T0, dfa40_T116, dfa40_T3, dfa40_T106, 
    dfa40_T1, dfa40_T169, dfa40_T165, dfa40_T162, dfa40_T158, dfa40_T18, 
    dfa40_T20, dfa40_T0, dfa40_T151, dfa40_T95, dfa40_T53, dfa40_T27, dfa40_T54, 
    dfa40_T276, dfa40_T261, dfa40_T80, NULL, dfa40_T124, dfa40_T0, dfa40_T118, 
    dfa40_T121, dfa40_T47, dfa40_T24, NULL, dfa40_T282, dfa40_T191, dfa40_T180, 
    dfa40_T37, dfa40_T0, dfa40_T98, dfa40_T0, dfa40_T0, dfa40_T0, NULL, 
    dfa40_T32, dfa40_T33, dfa40_T69, dfa40_T73, dfa40_T79, dfa40_T11, dfa40_T237, 
    dfa40_T240, dfa40_T200, dfa40_T223, dfa40_T224, dfa40_T230, dfa40_T235, 
    dfa40_T214, dfa40_T212, dfa40_T219, dfa40_T93, dfa40_T0, dfa40_T273, 
    dfa40_T286, dfa40_T285, dfa40_T291, dfa40_T0, dfa40_T275, dfa40_T272, 
    dfa40_T280, dfa40_T277, dfa40_T265, dfa40_T257, NULL, dfa40_T185, dfa40_T251, 
    dfa40_T28, NULL, NULL, dfa40_T138, dfa40_T140, dfa40_T134, dfa40_T6, 
    NULL, NULL, dfa40_T113, dfa40_T115, NULL, dfa40_T104, dfa40_T179, dfa40_T173, 
    dfa40_T168, dfa40_T164, dfa40_T163, dfa40_T159, dfa40_T17, dfa40_T88, 
    NULL, dfa40_T150, dfa40_T22, dfa40_T41, dfa40_T52, dfa40_T26, dfa40_T56, 
    dfa40_T267, dfa40_T260, dfa40_T81, dfa40_T127, NULL, dfa40_T117, dfa40_T0, 
    dfa40_T48, dfa40_T23, dfa40_T102, dfa40_T184, dfa40_T192, dfa40_T183, 
    dfa40_T39, NULL, dfa40_T40, NULL, NULL, NULL, dfa40_T0, dfa40_T35, dfa40_T68, 
    dfa40_T74, dfa40_T82, dfa40_T12, dfa40_T236, dfa40_T239, dfa40_T241, 
    dfa40_T246, dfa40_T0, dfa40_T226, dfa40_T231, dfa40_T211, dfa40_T0, 
    dfa40_T217, dfa40_T0, dfa40_T0, dfa40_T34, NULL, dfa40_T199, dfa40_T209, 
    dfa40_T287, dfa40_T290, dfa40_T288, NULL, dfa40_T0, dfa40_T0, dfa40_T281, 
    dfa40_T279, dfa40_T262, dfa40_T258, dfa40_T193, dfa40_T253, dfa40_T250, 
    dfa40_T0, dfa40_T0, dfa40_T0, dfa40_T133, dfa40_T10, dfa40_T111, dfa40_T114, 
    dfa40_T105, dfa40_T178, dfa40_T171, dfa40_T167, dfa40_T166, dfa40_T0, 
    dfa40_T160, dfa40_T156, dfa40_T153, dfa40_T0, NULL, dfa40_T0, dfa40_T149, 
    dfa40_T50, dfa40_T43, dfa40_T51, dfa40_T25, dfa40_T64, dfa40_T146, dfa40_T0, 
    dfa40_T77, dfa40_T0, dfa40_T128, dfa40_T123, NULL, dfa40_T0, dfa40_T30, 
    dfa40_T103, dfa40_T186, dfa40_T0, dfa40_T182, dfa40_T0, dfa40_T0, NULL, 
    dfa40_T0, dfa40_T71, dfa40_T75, dfa40_T83, dfa40_T13, dfa40_T0, dfa40_T238, 
    dfa40_T242, dfa40_T247, NULL, dfa40_T225, dfa40_T232, dfa40_T210, NULL, 
    dfa40_T218, NULL, NULL, dfa40_T0, dfa40_T201, dfa40_T205, dfa40_T283, 
    dfa40_T0, dfa40_T0, NULL, NULL, dfa40_T0, dfa40_T0, dfa40_T263, dfa40_T255, 
    dfa40_T147, dfa40_T252, dfa40_T143, NULL, NULL, NULL, dfa40_T0, dfa40_T0, 
    NULL, dfa40_T110, dfa40_T0, dfa40_T108, dfa40_T176, dfa40_T172, dfa40_T170, 
    dfa40_T0, NULL, dfa40_T0, dfa40_T155, dfa40_T0, NULL, NULL, dfa40_T0, 
    dfa40_T49, dfa40_T42, dfa40_T60, dfa40_T0, dfa40_T65, dfa40_T0, NULL, 
    NULL, dfa40_T0, NULL, dfa40_T125, dfa40_T0, NULL, dfa40_T29, dfa40_T87, 
    dfa40_T187, NULL, dfa40_T0, NULL, NULL, NULL, dfa40_T70, dfa40_T76, 
    dfa40_T84, dfa40_T9, NULL, dfa40_T0, dfa40_T243, dfa40_T0, dfa40_T228, 
    dfa40_T233, dfa40_T0, dfa40_T215, NULL, dfa40_T202, dfa40_T206, dfa40_T0, 
    NULL, NULL, NULL, NULL, dfa40_T0, dfa40_T256, dfa40_T248, NULL, dfa40_T0, 
    dfa40_T142, NULL, NULL, dfa40_T0, NULL, dfa40_T109, dfa40_T177, dfa40_T0, 
    dfa40_T0, NULL, NULL, dfa40_T154, NULL, NULL, dfa40_T0, dfa40_T44, dfa40_T0, 
    NULL, dfa40_T0, NULL, NULL, dfa40_T126, NULL, dfa40_T0, NULL, dfa40_T188, 
    NULL, dfa40_T72, dfa40_T0, dfa40_T85, dfa40_T197, NULL, dfa40_T0, NULL, 
    dfa40_T0, dfa40_T0, NULL, dfa40_T216, dfa40_T203, dfa40_T207, NULL, 
    NULL, dfa40_T270, dfa40_T0, NULL, dfa40_T145, NULL, dfa40_T107, dfa40_T175, 
    NULL, NULL, dfa40_T0, NULL, dfa40_T0, NULL, NULL, dfa40_T129, NULL, 
    dfa40_T189, dfa40_T0, NULL, dfa40_T0, dfa40_T55, NULL, NULL, NULL, NULL, 
    dfa40_T0, dfa40_T204, dfa40_T208, dfa40_T269, NULL, dfa40_T144, dfa40_T0, 
    dfa40_T0, NULL, NULL, dfa40_T130, dfa40_T0, NULL, NULL, dfa40_T59, NULL, 
    dfa40_T0, dfa40_T0, dfa40_T268, dfa40_T0, NULL, NULL, dfa40_T0, NULL, 
    dfa40_T61, NULL, NULL, dfa40_T0, NULL, NULL, dfa40_T57, NULL, dfa40_T58, 
    dfa40_T62, dfa40_T63, dfa40_T0, NULL
};


/* Declare tracking structure for Cyclic DFA 40
 */
class PLSQLLexerCyclicDFA40 : public CyclicDFA< PLSQLLexerImplTraits, PLSQLLexer >, public PLSQLLexerTokens
{
public:
	typedef CyclicDFA< PLSQLLexerImplTraits, PLSQLLexer >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	

public:
	PLSQLLexerCyclicDFA40( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		
	}

};

static PLSQLLexerCyclicDFA40  cdfa40(
	    40,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"1:1: Tokens : ( FOR_NOTATION | NATIONAL_CHAR_STRING_LIT | BIT_STRING_LIT | HEX_STRING_LIT | PERIOD | EXACT_NUM_LIT | CHAR_STRING | CHAR_STRING_PERL | DELIMITED_ID | PERCENT | AMPERSAND | LEFT_PAREN | RIGHT_PAREN | DOUBLE_ASTERISK | ASTERISK | PLUS_SIGN | COMMA | SOLIDUS | AT_SIGN | ASSIGN_OP | BINDVAR | COLON | SEMICOLON | LESS_THAN_OR_EQUALS_OP | LESS_THAN_OP | GREATER_THAN_OR_EQUALS_OP | NOT_EQUAL_OP | CARRET_OPERATOR_PART | TILDE_OPERATOR_PART | EXCLAMATION_OPERATOR_PART | GREATER_THAN_OP | CONCATENATION_OP | VERTICAL_BAR | EQUALS_OP | LEFT_BRACKET | RIGHT_BRACKET | INTRODUCER | SEPARATOR | PROMPT | SQL92_RESERVED_ALL | SQL92_RESERVED_ALTER | SQL92_RESERVED_AND | SQL92_RESERVED_ANY | SQL92_RESERVED_AS | SQL92_RESERVED_ASC | SQL92_RESERVED_BEGIN | SQL92_RESERVED_BETWEEN | SQL92_RESERVED_BY | SQL92_RESERVED_CASE | SQL92_RESERVED_CHECK | PLSQL_RESERVED_CLUSTERS | PLSQL_RESERVED_COLAUTH | PLSQL_RESERVED_COMPRESS | SQL92_RESERVED_CONNECT | PLSQL_NON_RESERVED_CONNECT_BY_ROOT | PLSQL_RESERVED_CRASH | SQL92_RESERVED_CREATE | SQL92_RESERVED_CURRENT | SQL92_RESERVED_CURSOR | SQL92_RESERVED_DATE | SQL92_RESERVED_DECLARE | SQL92_RESERVED_DEFAULT | SQL92_RESERVED_DELETE | SQL92_RESERVED_DESC | SQL92_RESERVED_DISTINCT | SQL92_RESERVED_DROP | SQL92_RESERVED_ELSE | SQL92_RESERVED_END | SQL92_RESERVED_EXCEPTION | PLSQL_RESERVED_EXCLUSIVE | SQL92_RESERVED_EXISTS | SQL92_RESERVED_FALSE | SQL92_RESERVED_FETCH | SQL92_RESERVED_FOR | SQL92_RESERVED_FROM | SQL92_RESERVED_GOTO | SQL92_RESERVED_GRANT | SQL92_RESERVED_GROUP | SQL92_RESERVED_HAVING | PLSQL_RESERVED_IDENTIFIED | PLSQL_RESERVED_IF | SQL92_RESERVED_IN | PLSQL_RESERVED_INDEX | PLSQL_RESERVED_INDEXES | SQL92_RESERVED_INSERT | SQL92_RESERVED_INTERSECT | SQL92_RESERVED_INTO | SQL92_RESERVED_IS | SQL92_RESERVED_LIKE | PLSQL_RESERVED_LOCK | PLSQL_RESERVED_MINUS | PLSQL_RESERVED_MODE | PLSQL_RESERVED_NOCOMPRESS | SQL92_RESERVED_NOT | PLSQL_RESERVED_NOWAIT | SQL92_RESERVED_NULL | SQL92_RESERVED_OF | SQL92_RESERVED_ON | SQL92_RESERVED_OPTION | SQL92_RESERVED_OR | SQL92_RESERVED_ORDER | SQL92_RESERVED_OVERLAPS | SQL92_RESERVED_PRIOR | SQL92_RESERVED_PROCEDURE | SQL92_RESERVED_PUBLIC | PLSQL_RESERVED_RESOURCE | SQL92_RESERVED_REVOKE | SQL92_RESERVED_SELECT | PLSQL_RESERVED_SHARE | SQL92_RESERVED_SIZE | PLSQL_RESERVED_START | PLSQL_RESERVED_TABAUTH | SQL92_RESERVED_TABLE | SQL92_RESERVED_THE | SQL92_RESERVED_THEN | SQL92_RESERVED_TO | SQL92_RESERVED_TRUE | SQL92_RESERVED_UNION | SQL92_RESERVED_UNIQUE | SQL92_RESERVED_UPDATE | SQL92_RESERVED_VALUES | SQL92_RESERVED_VIEW | PLSQL_RESERVED_VIEWS | SQL92_RESERVED_WHEN | SQL92_RESERVED_WHERE | SQL92_RESERVED_WITH | PLSQL_NON_RESERVED_USING | PLSQL_NON_RESERVED_MODEL | PLSQL_NON_RESERVED_ELSIF | PLSQL_NON_RESERVED_PIVOT | PLSQL_NON_RESERVED_UNPIVOT | REGULAR_ID | ZV );",
	    dfa40_eot,	    /* EOT table			    */
	    dfa40_eof,	    /* EOF table			    */
	    dfa40_min,	    /* Minimum tokens for each state    */
	    dfa40_max,	    /* Maximum tokens for each state    */
	    dfa40_accept,	/* Accept table			    */
	    dfa40_special,	/* Special transition states	    */
	    dfa40_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 40
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the lexer
 */

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 125:5: ( UNSIGNED_INTEGER '..' UNSIGNED_INTEGER )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FOR_NOTATION
 *
 * Looks to match the characters the constitute the token FOR_NOTATION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mFOR_NOTATION()
{
    ANTLR_UINT32	_type;
      

    _type	    = FOR_NOTATION;


    // PLSQLLexer.g:125:5: ( UNSIGNED_INTEGER '..' UNSIGNED_INTEGER )
    // PLSQLLexer.g:125:10: UNSIGNED_INTEGER '..' UNSIGNED_INTEGER
    {
        /* 125:10: UNSIGNED_INTEGER '..' UNSIGNED_INTEGER */
        mUNSIGNED_INTEGER();
        if  (this->hasException())
        {
            goto ruleFOR_NOTATIONEx;
        }



        this->matchs(lit_1);
        if  (this->hasException())
        {
            goto ruleFOR_NOTATIONEx;
        }




        /* 125:10: UNSIGNED_INTEGER '..' UNSIGNED_INTEGER */
        mUNSIGNED_INTEGER();
        if  (this->hasException())
        {
            goto ruleFOR_NOTATIONEx;
        }



    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleFOR_NOTATIONEx; /* Prevent compiler warnings */
    ruleFOR_NOTATIONEx: ;

}
// $ANTLR end FOR_NOTATION

//   Comes from: 136:5: ( ( 'N' | 'n' ) '\\'' ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )* '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NATIONAL_CHAR_STRING_LIT
 *
 * Looks to match the characters the constitute the token NATIONAL_CHAR_STRING_LIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mNATIONAL_CHAR_STRING_LIT()
{
    ANTLR_UINT32	_type;
      

    _type	    = NATIONAL_CHAR_STRING_LIT;


    // PLSQLLexer.g:136:5: ( ( 'N' | 'n' ) '\\'' ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )* '\\'' )
    // PLSQLLexer.g:136:10: ( 'N' | 'n' ) '\\'' ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )* '\\''
    {
        if ( this->LA(1) == 'N' || this->LA(1) == 'n' )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleNATIONAL_CHAR_STRING_LITEx;
        }


         this->matchc('\'');
        if  (this->hasException())
        {
            goto ruleNATIONAL_CHAR_STRING_LITEx;
        }


        // PLSQLLexer.g:136:27: ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )*

        for (;;)
        {
            int alt1=4;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA1_0 = this->LA(1);
                if ( (LA1_0 == '\''))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA1_1 = this->LA(2);
                        if ( (LA1_1 == '\''))
                        {
                            alt1=2;
                        }

                    }
                }
                else if ( (((LA1_0 >= 0x0000) && (LA1_0 <= '\t')) || ((LA1_0 >= 0x000B) && (LA1_0 <= '\f')) || ((LA1_0 >= 0x000E) && (LA1_0 <= '&')) || ((LA1_0 >= '(') && (LA1_0 <= 0xFFFF))))
                {
                    alt1=1;
                }
                else if ( (LA1_0 == '\n' || LA1_0 == '\r'))
                {
                    alt1=3;
                }

            }
            switch (alt1)
            {
        	case 1:
        	    // PLSQLLexer.g:136:51: ~ ( '\\'' | '\\r' | '\\n' )
        	    {
        	        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\t')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= '&')) || ((this->LA(1) >= '(') && (this->LA(1) <= 0xFFFF)) )
        	        {
        	            this->consume();
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            this->recover();
        	            goto ruleNATIONAL_CHAR_STRING_LITEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLLexer.g:136:76: '\\'' '\\''
        	    {
        	         this->matchc('\'');
        	        if  (this->hasException())
        	        {
        	            goto ruleNATIONAL_CHAR_STRING_LITEx;
        	        }


        	         this->matchc('\'');
        	        if  (this->hasException())
        	        {
        	            goto ruleNATIONAL_CHAR_STRING_LITEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLLexer.g:136:88: NEWLINE
        	    {
        	        /* 136:88: NEWLINE */
        	        mNEWLINE();
        	        if  (this->hasException())
        	        {
        	            goto ruleNATIONAL_CHAR_STRING_LITEx;
        	        }



        	    }
        	    break;

        	default:
        	    goto loop1;	/* break out of the loop */
        	    break;
            }
        }
        loop1: ; /* Jump out to here if this rule does not match */


         this->matchc('\'');
        if  (this->hasException())
        {
            goto ruleNATIONAL_CHAR_STRING_LITEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleNATIONAL_CHAR_STRING_LITEx; /* Prevent compiler warnings */
    ruleNATIONAL_CHAR_STRING_LITEx: ;

}
// $ANTLR end NATIONAL_CHAR_STRING_LIT

//   Comes from: 143:5: ( ( 'B' | 'b' ) ( '\\'' ( '0' | '1' )* '\\'' ( SEPARATOR )? )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BIT_STRING_LIT
 *
 * Looks to match the characters the constitute the token BIT_STRING_LIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mBIT_STRING_LIT()
{
    ANTLR_UINT32	_type;
      

    _type	    = BIT_STRING_LIT;


    // PLSQLLexer.g:143:5: ( ( 'B' | 'b' ) ( '\\'' ( '0' | '1' )* '\\'' ( SEPARATOR )? )+ )
    // PLSQLLexer.g:143:10: ( 'B' | 'b' ) ( '\\'' ( '0' | '1' )* '\\'' ( SEPARATOR )? )+
    {
        if ( this->LA(1) == 'B' || this->LA(1) == 'b' )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleBIT_STRING_LITEx;
        }


        // PLSQLLexer.g:143:22: ( '\\'' ( '0' | '1' )* '\\'' ( SEPARATOR )? )+
        {
            int cnt4=0;

            for (;;)
            {
                int alt4=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA4_0 = this->LA(1);
        	    if ( (LA4_0 == '\''))
        	    {
        	        alt4=1;
        	    }

        	}
        	switch (alt4)
        	{
        	    case 1:
        	        // PLSQLLexer.g:143:23: '\\'' ( '0' | '1' )* '\\'' ( SEPARATOR )?
        	        {
        	             this->matchc('\'');
        	            if  (this->hasException())
        	            {
        	                goto ruleBIT_STRING_LITEx;
        	            }


        	            // PLSQLLexer.g:143:28: ( '0' | '1' )*

        	            for (;;)
        	            {
        	                int alt2=2;
        	                {
        	                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                    */
        	                    int LA2_0 = this->LA(1);
        	                    if ( (((LA2_0 >= '0') && (LA2_0 <= '1'))))
        	                    {
        	                        alt2=1;
        	                    }

        	                }
        	                switch (alt2)
        	                {
        	            	case 1:
        	            	    // PLSQLLexer.g:
        	            	    {
        	            	        if ( ((this->LA(1) >= '0') && (this->LA(1) <= '1')) )
        	            	        {
        	            	            this->consume();
        	            	        }
        	            	        else
        	            	        {
        	            	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            	            this->recover();
        	            	            goto ruleBIT_STRING_LITEx;
        	            	        }


        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop2;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop2: ; /* Jump out to here if this rule does not match */


        	             this->matchc('\'');
        	            if  (this->hasException())
        	            {
        	                goto ruleBIT_STRING_LITEx;
        	            }


        	            // PLSQLLexer.g:143:46: ( SEPARATOR )?
        	            {
        	                int alt3=2;
        	                {
        	                    int LA3_0 = this->LA(1);
        	                    if ( (((LA3_0 >= '\t') && (LA3_0 <= '\n')) || LA3_0 == '\r' || LA3_0 == ' ' || LA3_0 == '-' || LA3_0 == '/'))
        	                    {
        	                        alt3=1;
        	                    }
        	                }
        	                switch (alt3)
        	                {
        	            	case 1:
        	            	    // PLSQLLexer.g:143:46: SEPARATOR
        	            	    {
        	            	        /* 143:46: SEPARATOR */
        	            	        mSEPARATOR();
        	            	        if  (this->hasException())
        	            	        {
        	            	            goto ruleBIT_STRING_LITEx;
        	            	        }



        	            	    }
        	            	    break;

        	                }
        	            }

        	        }
        	        break;

        	    default:

        		if ( cnt4 >= 1 )
        		{
        		    goto loop4;
        		}
        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< PLSQLLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto ruleBIT_STRING_LITEx;
        	}
        	cnt4++;
            }
            loop4: ;	/* Jump to here if this rule does not match */
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleBIT_STRING_LITEx; /* Prevent compiler warnings */
    ruleBIT_STRING_LITEx: ;

}
// $ANTLR end BIT_STRING_LIT

//   Comes from: 151:5: ( ( 'X' | 'x' ) ( '\\'' ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )* '\\'' ( SEPARATOR )? )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX_STRING_LIT
 *
 * Looks to match the characters the constitute the token HEX_STRING_LIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mHEX_STRING_LIT()
{
    ANTLR_UINT32	_type;
      

    _type	    = HEX_STRING_LIT;


    // PLSQLLexer.g:151:5: ( ( 'X' | 'x' ) ( '\\'' ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )* '\\'' ( SEPARATOR )? )+ )
    // PLSQLLexer.g:151:10: ( 'X' | 'x' ) ( '\\'' ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )* '\\'' ( SEPARATOR )? )+
    {
        if ( this->LA(1) == 'X' || this->LA(1) == 'x' )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleHEX_STRING_LITEx;
        }


        // PLSQLLexer.g:151:22: ( '\\'' ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )* '\\'' ( SEPARATOR )? )+
        {
            int cnt7=0;

            for (;;)
            {
                int alt7=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA7_0 = this->LA(1);
        	    if ( (LA7_0 == '\''))
        	    {
        	        alt7=1;
        	    }

        	}
        	switch (alt7)
        	{
        	    case 1:
        	        // PLSQLLexer.g:151:23: '\\'' ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )* '\\'' ( SEPARATOR )?
        	        {
        	             this->matchc('\'');
        	            if  (this->hasException())
        	            {
        	                goto ruleHEX_STRING_LITEx;
        	            }


        	            // PLSQLLexer.g:151:28: ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )*

        	            for (;;)
        	            {
        	                int alt5=2;
        	                {
        	                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                    */
        	                    int LA5_0 = this->LA(1);
        	                    if ( (((LA5_0 >= '0') && (LA5_0 <= '9')) || ((LA5_0 >= 'A') && (LA5_0 <= 'F')) || ((LA5_0 >= 'a') && (LA5_0 <= 'f'))))
        	                    {
        	                        alt5=1;
        	                    }

        	                }
        	                switch (alt5)
        	                {
        	            	case 1:
        	            	    // PLSQLLexer.g:
        	            	    {
        	            	        if ( ((this->LA(1) >= '0') && (this->LA(1) <= '9')) || ((this->LA(1) >= 'A') && (this->LA(1) <= 'F')) || ((this->LA(1) >= 'a') && (this->LA(1) <= 'f')) )
        	            	        {
        	            	            this->consume();
        	            	        }
        	            	        else
        	            	        {
        	            	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            	            this->recover();
        	            	            goto ruleHEX_STRING_LITEx;
        	            	        }


        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop5;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop5: ; /* Jump out to here if this rule does not match */


        	             this->matchc('\'');
        	            if  (this->hasException())
        	            {
        	                goto ruleHEX_STRING_LITEx;
        	            }


        	            // PLSQLLexer.g:151:67: ( SEPARATOR )?
        	            {
        	                int alt6=2;
        	                {
        	                    int LA6_0 = this->LA(1);
        	                    if ( (((LA6_0 >= '\t') && (LA6_0 <= '\n')) || LA6_0 == '\r' || LA6_0 == ' ' || LA6_0 == '-' || LA6_0 == '/'))
        	                    {
        	                        alt6=1;
        	                    }
        	                }
        	                switch (alt6)
        	                {
        	            	case 1:
        	            	    // PLSQLLexer.g:151:67: SEPARATOR
        	            	    {
        	            	        /* 151:67: SEPARATOR */
        	            	        mSEPARATOR();
        	            	        if  (this->hasException())
        	            	        {
        	            	            goto ruleHEX_STRING_LITEx;
        	            	        }



        	            	    }
        	            	    break;

        	                }
        	            }

        	        }
        	        break;

        	    default:

        		if ( cnt7 >= 1 )
        		{
        		    goto loop7;
        		}
        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< PLSQLLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto ruleHEX_STRING_LITEx;
        	}
        	cnt7++;
            }
            loop7: ;	/* Jump to here if this rule does not match */
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleHEX_STRING_LITEx; /* Prevent compiler warnings */
    ruleHEX_STRING_LITEx: ;

}
// $ANTLR end HEX_STRING_LIT

//   Comes from: 156:5: ( '.' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PERIOD
 *
 * Looks to match the characters the constitute the token PERIOD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPERIOD()
{
    ANTLR_UINT32	_type;
      

    _type	    = PERIOD;


    // PLSQLLexer.g:156:5: ( '.' )
    // PLSQLLexer.g:156:10: '.'
    {
         this->matchc('.');
        if  (this->hasException())
        {
            goto rulePERIODEx;
        }


        {
                if ((char) LA(1) == '.') {
                        consume();
                        _type = DOUBLE_PERIOD;
                    }
                
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePERIODEx; /* Prevent compiler warnings */
    rulePERIODEx: ;

}
// $ANTLR end PERIOD

//   Comes from: 170:5: ( ( UNSIGNED_INTEGER ( '.' ( UNSIGNED_INTEGER )? |) ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? | '.' UNSIGNED_INTEGER ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? ) ( 'D' | 'd' | 'f' | 'F' )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXACT_NUM_LIT
 *
 * Looks to match the characters the constitute the token EXACT_NUM_LIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mEXACT_NUM_LIT()
{
    ANTLR_UINT32	_type;
      

    _type	    = EXACT_NUM_LIT;


    // PLSQLLexer.g:170:5: ( ( UNSIGNED_INTEGER ( '.' ( UNSIGNED_INTEGER )? |) ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? | '.' UNSIGNED_INTEGER ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? ) ( 'D' | 'd' | 'f' | 'F' )? )
    // PLSQLLexer.g:170:7: ( UNSIGNED_INTEGER ( '.' ( UNSIGNED_INTEGER )? |) ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? | '.' UNSIGNED_INTEGER ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? ) ( 'D' | 'd' | 'f' | 'F' )?
    {
        // PLSQLLexer.g:170:7: ( UNSIGNED_INTEGER ( '.' ( UNSIGNED_INTEGER )? |) ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? | '.' UNSIGNED_INTEGER ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? )
        {
            int alt14=2;
            {
                int LA14_0 = this->LA(1);
                if ( (((LA14_0 >= '0') && (LA14_0 <= '9'))))
                {
                    alt14=1;
                }
                else if ( (LA14_0 == '.'))
                {
                    alt14=2;
                }
                else
                {

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 14 );
                    ex->set_state( 0 );


                    goto ruleEXACT_NUM_LITEx;

                }
            }
            switch (alt14)
            {
        	case 1:
        	    // PLSQLLexer.g:171:13: UNSIGNED_INTEGER ( '.' ( UNSIGNED_INTEGER )? |) ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )?
        	    {
        	        /* 171:13: UNSIGNED_INTEGER ( '.' ( UNSIGNED_INTEGER )? |) ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? */
        	        mUNSIGNED_INTEGER();
        	        if  (this->hasException())
        	        {
        	            goto ruleEXACT_NUM_LITEx;
        	        }



        	        // PLSQLLexer.g:172:13: ( '.' ( UNSIGNED_INTEGER )? |)
        	        {
        	            int alt9=2;
        	            {
        	                int LA9_0 = this->LA(1);
        	                if ( (LA9_0 == '.'))
        	                {
        	                    alt9=1;
        	                }
        	                else
        	                {
        	                    alt9=2;
        	                }
        	            }
        	            switch (alt9)
        	            {
        	        	case 1:
        	        	    // PLSQLLexer.g:172:15: '.' ( UNSIGNED_INTEGER )?
        	        	    {
        	        	         this->matchc('.');
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        }


        	        	        // PLSQLLexer.g:172:19: ( UNSIGNED_INTEGER )?
        	        	        {
        	        	            int alt8=2;
        	        	            {
        	        	                int LA8_0 = this->LA(1);
        	        	                if ( (((LA8_0 >= '0') && (LA8_0 <= '9'))))
        	        	                {
        	        	                    alt8=1;
        	        	                }
        	        	            }
        	        	            switch (alt8)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQLLexer.g:172:19: UNSIGNED_INTEGER
        	        	        	    {
        	        	        	        /* 172:19: UNSIGNED_INTEGER */
        	        	        	        mUNSIGNED_INTEGER();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        	        }



        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQLLexer.g:173:18: 
        	        	    {
        	        	        {
        	        	            _type = UNSIGNED_INTEGER;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLLexer.g:174:15: ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )?
        	        {
        	            int alt11=2;
        	            {
        	                int LA11_0 = this->LA(1);
        	                if ( (LA11_0 == 'E' || LA11_0 == 'e'))
        	                {
        	                    alt11=1;
        	                }
        	            }
        	            switch (alt11)
        	            {
        	        	case 1:
        	        	    // PLSQLLexer.g:174:17: ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER
        	        	    {
        	        	        if ( this->LA(1) == 'E' || this->LA(1) == 'e' )
        	        	        {
        	        	            this->consume();
        	        	        }
        	        	        else
        	        	        {
        	        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	        	            this->recover();
        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        }


        	        	        // PLSQLLexer.g:174:29: ( '+' | '-' )?
        	        	        {
        	        	            int alt10=2;
        	        	            {
        	        	                int LA10_0 = this->LA(1);
        	        	                if ( (LA10_0 == '+' || LA10_0 == '-'))
        	        	                {
        	        	                    alt10=1;
        	        	                }
        	        	            }
        	        	            switch (alt10)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQLLexer.g:
        	        	        	    {
        	        	        	        if ( this->LA(1) == '+' || this->LA(1) == '-' )
        	        	        	        {
        	        	        	            this->consume();
        	        	        	        }
        	        	        	        else
        	        	        	        {
        	        	        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	        	        	            this->recover();
        	        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        /* 174:17: ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER */
        	        	        mUNSIGNED_INTEGER();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        }



        	        	        {
        	        	            _type = APPROXIMATE_NUM_LIT;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQLLexer.g:175:10: '.' UNSIGNED_INTEGER ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )?
        	    {
        	         this->matchc('.');
        	        if  (this->hasException())
        	        {
        	            goto ruleEXACT_NUM_LITEx;
        	        }


        	        /* 175:10: '.' UNSIGNED_INTEGER ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? */
        	        mUNSIGNED_INTEGER();
        	        if  (this->hasException())
        	        {
        	            goto ruleEXACT_NUM_LITEx;
        	        }



        	        // PLSQLLexer.g:175:31: ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )?
        	        {
        	            int alt13=2;
        	            {
        	                int LA13_0 = this->LA(1);
        	                if ( (LA13_0 == 'E' || LA13_0 == 'e'))
        	                {
        	                    alt13=1;
        	                }
        	            }
        	            switch (alt13)
        	            {
        	        	case 1:
        	        	    // PLSQLLexer.g:175:33: ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER
        	        	    {
        	        	        if ( this->LA(1) == 'E' || this->LA(1) == 'e' )
        	        	        {
        	        	            this->consume();
        	        	        }
        	        	        else
        	        	        {
        	        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	        	            this->recover();
        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        }


        	        	        // PLSQLLexer.g:175:45: ( '+' | '-' )?
        	        	        {
        	        	            int alt12=2;
        	        	            {
        	        	                int LA12_0 = this->LA(1);
        	        	                if ( (LA12_0 == '+' || LA12_0 == '-'))
        	        	                {
        	        	                    alt12=1;
        	        	                }
        	        	            }
        	        	            switch (alt12)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQLLexer.g:
        	        	        	    {
        	        	        	        if ( this->LA(1) == '+' || this->LA(1) == '-' )
        	        	        	        {
        	        	        	            this->consume();
        	        	        	        }
        	        	        	        else
        	        	        	        {
        	        	        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	        	        	            this->recover();
        	        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        /* 175:33: ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER */
        	        	        mUNSIGNED_INTEGER();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        }



        	        	        {
        	        	            _type = APPROXIMATE_NUM_LIT;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }

        // PLSQLLexer.g:177:5: ( 'D' | 'd' | 'f' | 'F' )?
        {
            int alt15=2;
            {
                int LA15_0 = this->LA(1);
                if ( (LA15_0 == 'D' || LA15_0 == 'F' || LA15_0 == 'd' || LA15_0 == 'f'))
                {
                    alt15=1;
                }
            }
            switch (alt15)
            {
        	case 1:
        	    // PLSQLLexer.g:
        	    {
        	        if ( this->LA(1) == 'D' || this->LA(1) == 'F' || this->LA(1) == 'd' || this->LA(1) == 'f' )
        	        {
        	            this->consume();
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            this->recover();
        	            goto ruleEXACT_NUM_LITEx;
        	        }


        	    }
        	    break;

            }
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleEXACT_NUM_LITEx; /* Prevent compiler warnings */
    ruleEXACT_NUM_LITEx: ;

}
// $ANTLR end EXACT_NUM_LIT

//   Comes from: 184:5: ( '\\'' ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )* '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CHAR_STRING
 *
 * Looks to match the characters the constitute the token CHAR_STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mCHAR_STRING()
{
    ANTLR_UINT32	_type;
      

    _type	    = CHAR_STRING;


    // PLSQLLexer.g:184:5: ( '\\'' ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )* '\\'' )
    // PLSQLLexer.g:184:10: '\\'' ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )* '\\''
    {
         this->matchc('\'');
        if  (this->hasException())
        {
            goto ruleCHAR_STRINGEx;
        }


        // PLSQLLexer.g:184:15: ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )*

        for (;;)
        {
            int alt16=4;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA16_0 = this->LA(1);
                if ( (LA16_0 == '\''))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA16_1 = this->LA(2);
                        if ( (LA16_1 == '\''))
                        {
                            alt16=2;
                        }

                    }
                }
                else if ( (((LA16_0 >= 0x0000) && (LA16_0 <= '\t')) || ((LA16_0 >= 0x000B) && (LA16_0 <= '\f')) || ((LA16_0 >= 0x000E) && (LA16_0 <= '&')) || ((LA16_0 >= '(') && (LA16_0 <= 0xFFFF))))
                {
                    alt16=1;
                }
                else if ( (LA16_0 == '\n' || LA16_0 == '\r'))
                {
                    alt16=3;
                }

            }
            switch (alt16)
            {
        	case 1:
        	    // PLSQLLexer.g:184:39: ~ ( '\\'' | '\\r' | '\\n' )
        	    {
        	        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\t')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= '&')) || ((this->LA(1) >= '(') && (this->LA(1) <= 0xFFFF)) )
        	        {
        	            this->consume();
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            this->recover();
        	            goto ruleCHAR_STRINGEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLLexer.g:184:63: '\\'' '\\''
        	    {
        	         this->matchc('\'');
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRINGEx;
        	        }


        	         this->matchc('\'');
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRINGEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLLexer.g:184:75: NEWLINE
        	    {
        	        /* 184:75: NEWLINE */
        	        mNEWLINE();
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRINGEx;
        	        }



        	    }
        	    break;

        	default:
        	    goto loop16;	/* break out of the loop */
        	    break;
            }
        }
        loop16: ; /* Jump out to here if this rule does not match */


         this->matchc('\'');
        if  (this->hasException())
        {
            goto ruleCHAR_STRINGEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCHAR_STRINGEx; /* Prevent compiler warnings */
    ruleCHAR_STRINGEx: ;

}
// $ANTLR end CHAR_STRING

//   Comes from: 189:21: ( ( 'q' | 'Q' ) ( QS_ANGLE | QS_BRACE | QS_BRACK | QS_PAREN | QS_OTHER ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CHAR_STRING_PERL
 *
 * Looks to match the characters the constitute the token CHAR_STRING_PERL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mCHAR_STRING_PERL()
{
    ANTLR_UINT32	_type;
      

    _type	    = CHAR_STRING_PERL;


    // PLSQLLexer.g:189:21: ( ( 'q' | 'Q' ) ( QS_ANGLE | QS_BRACE | QS_BRACK | QS_PAREN | QS_OTHER ) )
    // PLSQLLexer.g:189:23: ( 'q' | 'Q' ) ( QS_ANGLE | QS_BRACE | QS_BRACK | QS_PAREN | QS_OTHER )
    {
        if ( this->LA(1) == 'Q' || this->LA(1) == 'q' )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleCHAR_STRING_PERLEx;
        }


        // PLSQLLexer.g:189:33: ( QS_ANGLE | QS_BRACE | QS_BRACK | QS_PAREN | QS_OTHER )
        {
            int alt17=5;
            {
                int LA17_0 = this->LA(1);
                if ( (LA17_0 == '\''))
                {
                    {
                        int LA17_1 = this->LA(2);
                        if ( (LA17_1 == '<'))
                        {
                            alt17=1;
                        }
                        else if ( (LA17_1 == '{'))
                        {
                            alt17=2;
                        }
                        else if ( (LA17_1 == '['))
                        {
                            alt17=3;
                        }
                        else if ( (LA17_1 == '('))
                        {
                            alt17=4;
                        }
                        else if ( (((LA17_1 >= 0x0000) && (LA17_1 <= '\b')) || ((LA17_1 >= 0x000B) && (LA17_1 <= '\f')) || ((LA17_1 >= 0x000E) && (LA17_1 <= 0x001F)) || ((LA17_1 >= '!') && (LA17_1 <= '\'')) || ((LA17_1 >= ')') && (LA17_1 <= ';')) || ((LA17_1 >= '=') && (LA17_1 <= 'Z')) || ((LA17_1 >= '\\') && (LA17_1 <= 'z')) || ((LA17_1 >= '|') && (LA17_1 <= 0xFFFF))))
                        {
                            alt17=5;
                        }
                        else
                        {

                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 17 );
                            ex->set_state( 1 );


                            goto ruleCHAR_STRING_PERLEx;

                        }
                    }
                }
                else
                {

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 17 );
                    ex->set_state( 0 );


                    goto ruleCHAR_STRING_PERLEx;

                }
            }
            switch (alt17)
            {
        	case 1:
        	    // PLSQLLexer.g:189:35: QS_ANGLE
        	    {
        	        /* 189:35: QS_ANGLE */
        	        mQS_ANGLE();
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRING_PERLEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // PLSQLLexer.g:189:46: QS_BRACE
        	    {
        	        /* 189:46: QS_BRACE */
        	        mQS_BRACE();
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRING_PERLEx;
        	        }



        	    }
        	    break;
        	case 3:
        	    // PLSQLLexer.g:189:57: QS_BRACK
        	    {
        	        /* 189:57: QS_BRACK */
        	        mQS_BRACK();
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRING_PERLEx;
        	        }



        	    }
        	    break;
        	case 4:
        	    // PLSQLLexer.g:189:68: QS_PAREN
        	    {
        	        /* 189:68: QS_PAREN */
        	        mQS_PAREN();
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRING_PERLEx;
        	        }



        	    }
        	    break;
        	case 5:
        	    // PLSQLLexer.g:189:79: QS_OTHER
        	    {
        	        /* 189:79: QS_OTHER */
        	        mQS_OTHER();
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRING_PERLEx;
        	        }



        	    }
        	    break;

            }
        }

        {
            _type = CHAR_STRING;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCHAR_STRING_PERLEx; /* Prevent compiler warnings */
    ruleCHAR_STRING_PERLEx: ;

}
// $ANTLR end CHAR_STRING_PERL

//   Comes from: 190:21: ( '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QUOTE
 *
 * Looks to match the characters the constitute the token QUOTE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mQUOTE()
{
    ANTLR_UINT32	_type;
      


    // PLSQLLexer.g:190:21: ( '\\'' )
    // PLSQLLexer.g:190:23: '\\''
    {
         this->matchc('\'');
        if  (this->hasException())
        {
            goto ruleQUOTEEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleQUOTEEx; /* Prevent compiler warnings */
    ruleQUOTEEx: ;

}
// $ANTLR end QUOTE

//   Comes from: 191:21: ( QUOTE '<' ( options {greedy=false; } : . )* '>' QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QS_ANGLE
 *
 * Looks to match the characters the constitute the token QS_ANGLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mQS_ANGLE()
{
    ANTLR_UINT32	_type;
      


    // PLSQLLexer.g:191:21: ( QUOTE '<' ( options {greedy=false; } : . )* '>' QUOTE )
    // PLSQLLexer.g:191:23: QUOTE '<' ( options {greedy=false; } : . )* '>' QUOTE
    {
        /* 191:23: QUOTE '<' ( options {greedy=false; } : . )* '>' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_ANGLEEx;
        }



         this->matchc('<');
        if  (this->hasException())
        {
            goto ruleQS_ANGLEEx;
        }


        // PLSQLLexer.g:191:33: ( options {greedy=false; } : . )*

        for (;;)
        {
            int alt18=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA18_0 = this->LA(1);
                if ( (LA18_0 == '>'))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA18_1 = this->LA(2);
                        if ( (LA18_1 == '\''))
                        {
                            alt18=2;
                        }
                        else if ( (((LA18_1 >= 0x0000) && (LA18_1 <= '&')) || ((LA18_1 >= '(') && (LA18_1 <= 0xFFFF))))
                        {
                            alt18=1;
                        }

                    }
                }
                else if ( (((LA18_0 >= 0x0000) && (LA18_0 <= '=')) || ((LA18_0 >= '?') && (LA18_0 <= 0xFFFF))))
                {
                    alt18=1;
                }

            }
            switch (alt18)
            {
        	case 1:
        	    // PLSQLLexer.g:191:61: .
        	    {
        	        this->matchAny();
        	        if  (this->hasException())
        	        {
        	            goto ruleQS_ANGLEEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop18;	/* break out of the loop */
        	    break;
            }
        }
        loop18: ; /* Jump out to here if this rule does not match */


         this->matchc('>');
        if  (this->hasException())
        {
            goto ruleQS_ANGLEEx;
        }


        /* 191:23: QUOTE '<' ( options {greedy=false; } : . )* '>' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_ANGLEEx;
        }



    }


    // This is where rules clean up and exit
    //
    goto ruleQS_ANGLEEx; /* Prevent compiler warnings */
    ruleQS_ANGLEEx: ;

}
// $ANTLR end QS_ANGLE

//   Comes from: 192:21: ( QUOTE '{' ( options {greedy=false; } : . )* '}' QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QS_BRACE
 *
 * Looks to match the characters the constitute the token QS_BRACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mQS_BRACE()
{
    ANTLR_UINT32	_type;
      


    // PLSQLLexer.g:192:21: ( QUOTE '{' ( options {greedy=false; } : . )* '}' QUOTE )
    // PLSQLLexer.g:192:23: QUOTE '{' ( options {greedy=false; } : . )* '}' QUOTE
    {
        /* 192:23: QUOTE '{' ( options {greedy=false; } : . )* '}' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_BRACEEx;
        }



         this->matchc('{');
        if  (this->hasException())
        {
            goto ruleQS_BRACEEx;
        }


        // PLSQLLexer.g:192:33: ( options {greedy=false; } : . )*

        for (;;)
        {
            int alt19=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA19_0 = this->LA(1);
                if ( (LA19_0 == '}'))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA19_1 = this->LA(2);
                        if ( (LA19_1 == '\''))
                        {
                            alt19=2;
                        }
                        else if ( (((LA19_1 >= 0x0000) && (LA19_1 <= '&')) || ((LA19_1 >= '(') && (LA19_1 <= 0xFFFF))))
                        {
                            alt19=1;
                        }

                    }
                }
                else if ( (((LA19_0 >= 0x0000) && (LA19_0 <= '|')) || ((LA19_0 >= '~') && (LA19_0 <= 0xFFFF))))
                {
                    alt19=1;
                }

            }
            switch (alt19)
            {
        	case 1:
        	    // PLSQLLexer.g:192:61: .
        	    {
        	        this->matchAny();
        	        if  (this->hasException())
        	        {
        	            goto ruleQS_BRACEEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop19;	/* break out of the loop */
        	    break;
            }
        }
        loop19: ; /* Jump out to here if this rule does not match */


         this->matchc('}');
        if  (this->hasException())
        {
            goto ruleQS_BRACEEx;
        }


        /* 192:23: QUOTE '{' ( options {greedy=false; } : . )* '}' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_BRACEEx;
        }



    }


    // This is where rules clean up and exit
    //
    goto ruleQS_BRACEEx; /* Prevent compiler warnings */
    ruleQS_BRACEEx: ;

}
// $ANTLR end QS_BRACE

//   Comes from: 193:21: ( QUOTE '[' ( options {greedy=false; } : . )* ']' QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QS_BRACK
 *
 * Looks to match the characters the constitute the token QS_BRACK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mQS_BRACK()
{
    ANTLR_UINT32	_type;
      


    // PLSQLLexer.g:193:21: ( QUOTE '[' ( options {greedy=false; } : . )* ']' QUOTE )
    // PLSQLLexer.g:193:23: QUOTE '[' ( options {greedy=false; } : . )* ']' QUOTE
    {
        /* 193:23: QUOTE '[' ( options {greedy=false; } : . )* ']' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_BRACKEx;
        }



         this->matchc('[');
        if  (this->hasException())
        {
            goto ruleQS_BRACKEx;
        }


        // PLSQLLexer.g:193:33: ( options {greedy=false; } : . )*

        for (;;)
        {
            int alt20=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA20_0 = this->LA(1);
                if ( (LA20_0 == ']'))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA20_1 = this->LA(2);
                        if ( (LA20_1 == '\''))
                        {
                            alt20=2;
                        }
                        else if ( (((LA20_1 >= 0x0000) && (LA20_1 <= '&')) || ((LA20_1 >= '(') && (LA20_1 <= 0xFFFF))))
                        {
                            alt20=1;
                        }

                    }
                }
                else if ( (((LA20_0 >= 0x0000) && (LA20_0 <= '\\')) || ((LA20_0 >= '^') && (LA20_0 <= 0xFFFF))))
                {
                    alt20=1;
                }

            }
            switch (alt20)
            {
        	case 1:
        	    // PLSQLLexer.g:193:61: .
        	    {
        	        this->matchAny();
        	        if  (this->hasException())
        	        {
        	            goto ruleQS_BRACKEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop20;	/* break out of the loop */
        	    break;
            }
        }
        loop20: ; /* Jump out to here if this rule does not match */


         this->matchc(']');
        if  (this->hasException())
        {
            goto ruleQS_BRACKEx;
        }


        /* 193:23: QUOTE '[' ( options {greedy=false; } : . )* ']' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_BRACKEx;
        }



    }


    // This is where rules clean up and exit
    //
    goto ruleQS_BRACKEx; /* Prevent compiler warnings */
    ruleQS_BRACKEx: ;

}
// $ANTLR end QS_BRACK

//   Comes from: 194:21: ( QUOTE '(' ( options {greedy=false; } : . )* ')' QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QS_PAREN
 *
 * Looks to match the characters the constitute the token QS_PAREN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mQS_PAREN()
{
    ANTLR_UINT32	_type;
      


    // PLSQLLexer.g:194:21: ( QUOTE '(' ( options {greedy=false; } : . )* ')' QUOTE )
    // PLSQLLexer.g:194:23: QUOTE '(' ( options {greedy=false; } : . )* ')' QUOTE
    {
        /* 194:23: QUOTE '(' ( options {greedy=false; } : . )* ')' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_PARENEx;
        }



         this->matchc('(');
        if  (this->hasException())
        {
            goto ruleQS_PARENEx;
        }


        // PLSQLLexer.g:194:33: ( options {greedy=false; } : . )*

        for (;;)
        {
            int alt21=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA21_0 = this->LA(1);
                if ( (LA21_0 == ')'))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA21_1 = this->LA(2);
                        if ( (LA21_1 == '\''))
                        {
                            alt21=2;
                        }
                        else if ( (((LA21_1 >= 0x0000) && (LA21_1 <= '&')) || ((LA21_1 >= '(') && (LA21_1 <= 0xFFFF))))
                        {
                            alt21=1;
                        }

                    }
                }
                else if ( (((LA21_0 >= 0x0000) && (LA21_0 <= '(')) || ((LA21_0 >= '*') && (LA21_0 <= 0xFFFF))))
                {
                    alt21=1;
                }

            }
            switch (alt21)
            {
        	case 1:
        	    // PLSQLLexer.g:194:61: .
        	    {
        	        this->matchAny();
        	        if  (this->hasException())
        	        {
        	            goto ruleQS_PARENEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop21;	/* break out of the loop */
        	    break;
            }
        }
        loop21: ; /* Jump out to here if this rule does not match */


         this->matchc(')');
        if  (this->hasException())
        {
            goto ruleQS_PARENEx;
        }


        /* 194:23: QUOTE '(' ( options {greedy=false; } : . )* ')' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_PARENEx;
        }



    }


    // This is where rules clean up and exit
    //
    goto ruleQS_PARENEx; /* Prevent compiler warnings */
    ruleQS_PARENEx: ;

}
// $ANTLR end QS_PAREN

//   Comes from: 196:21: (~ ( '<' | '{' | '[' | '(' | ' ' | '\\t' | '\\n' | '\\r' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QS_OTHER_CH
 *
 * Looks to match the characters the constitute the token QS_OTHER_CH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mQS_OTHER_CH()
{
    ANTLR_UINT32	_type;
      


    // PLSQLLexer.g:196:21: (~ ( '<' | '{' | '[' | '(' | ' ' | '\\t' | '\\n' | '\\r' ) )
    // PLSQLLexer.g:
    {
        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\b')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= 0x001F)) || ((this->LA(1) >= '!') && (this->LA(1) <= '\'')) || ((this->LA(1) >= ')') && (this->LA(1) <= ';')) || ((this->LA(1) >= '=') && (this->LA(1) <= 'Z')) || ((this->LA(1) >= '\\') && (this->LA(1) <= 'z')) || ((this->LA(1) >= '|') && (this->LA(1) <= 0xFFFF)) )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleQS_OTHER_CHEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleQS_OTHER_CHEx; /* Prevent compiler warnings */
    ruleQS_OTHER_CHEx: ;

}
// $ANTLR end QS_OTHER_CH

//   Comes from: 206:3: ( QUOTE delimiter= QS_OTHER_CH ({...}? => . )* ({...}? => . ) QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QS_OTHER
 *
 * Looks to match the characters the constitute the token QS_OTHER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mQS_OTHER()
{
    ANTLR_UINT32	_type;
      

    std::auto_ptr< ImplTraits::CommonTokenType > delimiter;


    // PLSQLLexer.g:206:3: ( QUOTE delimiter= QS_OTHER_CH ({...}? => . )* ({...}? => . ) QUOTE )
    // PLSQLLexer.g:207:3: QUOTE delimiter= QS_OTHER_CH ({...}? => . )* ({...}? => . ) QUOTE
    {
        /* 207:3: QUOTE delimiter= QS_OTHER_CH ({...}? => . )* ({...}? => . ) QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_OTHEREx;
        }



        /* 207:3: QUOTE delimiter= QS_OTHER_CH ({...}? => . )* ({...}? => . ) QUOTE */
        {
            ANTLR_MARKER delimiterStart884 = this->getCharIndex();
            ANTLR_UINT32 delimiterStartLine884 = this->getLine();
            ANTLR_UINT32 delimiterStartCharPos884 = this->getCharPositionInLine();
        mQS_OTHER_CH( );
            if  (this->hasException())
            {
                goto ruleQS_OTHEREx;
            }

            delimiter = std::auto_ptr< ImplTraits::CommonTokenType >(new CommonTokenType());
            delimiter->set_type( CommonTokenType::TOKEN_INVALID);
            delimiter->set_startIndex( delimiterStart884 );
            delimiter->set_stopIndex( this->getCharIndex()-1 );
            delimiter->set_input( this->get_input() );
            delimiter->set_line( delimiterStartLine884 );
            delimiter->set_charPositionInLine( delimiterStartCharPos884 );
        }


        // PLSQLLexer.g:216:3: ({...}? => . )*

        for (;;)
        {
            int alt22=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA22_0 = this->LA(1);
                if ( (((LA22_0 >= 0x0000) && (LA22_0 <= 0xFFFF))) && (((( LA(1) != delimiter->getText().at(0) || LA(2) != '\'' ))||(( LA(1) == delimiter->getText().at(0) && LA(2) == '\'' )))))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA22_1 = this->LA(2);
                        if ( (LA22_1 == '\'') && (((( LA(1) != delimiter->getText().at(0) || LA(2) != '\'' ))||(( LA(1) == delimiter->getText().at(0) && LA(2) == '\'' )))))
                        {
                            {
                               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                                */
                                int LA22_2 = this->LA(3);
                                if ( (((LA22_2 >= 0x0000) && (LA22_2 <= 0xFFFF))) && (( LA(1) != delimiter->getText().at(0) || LA(2) != '\'' )))
                                {
                                    alt22=1;
                                }

                            }
                        }
                        else if ( (((LA22_1 >= 0x0000) && (LA22_1 <= '&')) || ((LA22_1 >= '(') && (LA22_1 <= 0xFFFF))) && (( LA(1) != delimiter->getText().at(0) || LA(2) != '\'' )))
                        {
                            alt22=1;
                        }

                    }
                }

            }
            switch (alt22)
            {
        	case 1:
        	    // PLSQLLexer.g:216:5: {...}? => .
        	    {
        	        if ( !(( LA(1) != delimiter->getText().at(0) || LA(2) != '\'' )) )
        	        {
        	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), " LA(1) != $delimiter->getText().at(0) || LA(2) != '\\'' " );
        	                ex->set_ruleName( "QS_OTHER" );


        	        }

        	        this->matchAny();
        	        if  (this->hasException())
        	        {
        	            goto ruleQS_OTHEREx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop22;	/* break out of the loop */
        	    break;
            }
        }
        loop22: ; /* Jump out to here if this rule does not match */


        // PLSQLLexer.g:217:3: ({...}? => . )
        // PLSQLLexer.g:217:5: {...}? => .
        {
            if ( !(( LA(1) == delimiter->getText().at(0) && LA(2) == '\'' )) )
            {
                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), " LA(1) == $delimiter->getText().at(0) && LA(2) == '\\'' " );
                    ex->set_ruleName( "QS_OTHER" );


            }

            this->matchAny();
            if  (this->hasException())
            {
                goto ruleQS_OTHEREx;
            }


        }


        /* 207:3: QUOTE delimiter= QS_OTHER_CH ({...}? => . )* ({...}? => . ) QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_OTHEREx;
        }



    }


    // This is where rules clean up and exit
    //
    goto ruleQS_OTHEREx; /* Prevent compiler warnings */
    ruleQS_OTHEREx: ;

}
// $ANTLR end QS_OTHER

//   Comes from: 223:5: ( '\"' (~ ( '\"' | '\\r' | '\\n' ) | '\"' '\"' )+ '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DELIMITED_ID
 *
 * Looks to match the characters the constitute the token DELIMITED_ID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mDELIMITED_ID()
{
    ANTLR_UINT32	_type;
      

    _type	    = DELIMITED_ID;


    // PLSQLLexer.g:223:5: ( '\"' (~ ( '\"' | '\\r' | '\\n' ) | '\"' '\"' )+ '\"' )
    // PLSQLLexer.g:223:10: '\"' (~ ( '\"' | '\\r' | '\\n' ) | '\"' '\"' )+ '\"'
    {
         this->matchc('"');
        if  (this->hasException())
        {
            goto ruleDELIMITED_IDEx;
        }


        // PLSQLLexer.g:223:14: (~ ( '\"' | '\\r' | '\\n' ) | '\"' '\"' )+
        {
            int cnt23=0;

            for (;;)
            {
                int alt23=3;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA23_0 = this->LA(1);
        	    if ( (LA23_0 == '"'))
        	    {
        	        {
        	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	            */
        	            int LA23_1 = this->LA(2);
        	            if ( (LA23_1 == '"'))
        	            {
        	                alt23=2;
        	            }

        	        }
        	    }
        	    else if ( (((LA23_0 >= 0x0000) && (LA23_0 <= '\t')) || ((LA23_0 >= 0x000B) && (LA23_0 <= '\f')) || ((LA23_0 >= 0x000E) && (LA23_0 <= '!')) || ((LA23_0 >= '#') && (LA23_0 <= 0xFFFF))))
        	    {
        	        alt23=1;
        	    }

        	}
        	switch (alt23)
        	{
        	    case 1:
        	        // PLSQLLexer.g:223:15: ~ ( '\"' | '\\r' | '\\n' )
        	        {
        	            if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\t')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= '!')) || ((this->LA(1) >= '#') && (this->LA(1) <= 0xFFFF)) )
        	            {
        	                this->consume();
        	            }
        	            else
        	            {
        	                new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	                this->recover();
        	                goto ruleDELIMITED_IDEx;
        	            }


        	        }
        	        break;
        	    case 2:
        	        // PLSQLLexer.g:223:38: '\"' '\"'
        	        {
        	             this->matchc('"');
        	            if  (this->hasException())
        	            {
        	                goto ruleDELIMITED_IDEx;
        	            }


        	             this->matchc('"');
        	            if  (this->hasException())
        	            {
        	                goto ruleDELIMITED_IDEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt23 >= 1 )
        		{
        		    goto loop23;
        		}
        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< PLSQLLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto ruleDELIMITED_IDEx;
        	}
        	cnt23++;
            }
            loop23: ;	/* Jump to here if this rule does not match */
        }

         this->matchc('"');
        if  (this->hasException())
        {
            goto ruleDELIMITED_IDEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleDELIMITED_IDEx; /* Prevent compiler warnings */
    ruleDELIMITED_IDEx: ;

}
// $ANTLR end DELIMITED_ID

//   Comes from: 229:5: ( '%' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PERCENT
 *
 * Looks to match the characters the constitute the token PERCENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPERCENT()
{
    ANTLR_UINT32	_type;
      

    _type	    = PERCENT;


    // PLSQLLexer.g:229:5: ( '%' )
    // PLSQLLexer.g:229:10: '%'
    {
         this->matchc('%');
        if  (this->hasException())
        {
            goto rulePERCENTEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePERCENTEx; /* Prevent compiler warnings */
    rulePERCENTEx: ;

}
// $ANTLR end PERCENT

//   Comes from: 233:5: ( '&' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AMPERSAND
 *
 * Looks to match the characters the constitute the token AMPERSAND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mAMPERSAND()
{
    ANTLR_UINT32	_type;
      

    _type	    = AMPERSAND;


    // PLSQLLexer.g:233:5: ( '&' )
    // PLSQLLexer.g:233:10: '&'
    {
         this->matchc('&');
        if  (this->hasException())
        {
            goto ruleAMPERSANDEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleAMPERSANDEx; /* Prevent compiler warnings */
    ruleAMPERSANDEx: ;

}
// $ANTLR end AMPERSAND

//   Comes from: 237:5: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LEFT_PAREN
 *
 * Looks to match the characters the constitute the token LEFT_PAREN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mLEFT_PAREN()
{
    ANTLR_UINT32	_type;
      

    _type	    = LEFT_PAREN;


    // PLSQLLexer.g:237:5: ( '(' )
    // PLSQLLexer.g:237:10: '('
    {
         this->matchc('(');
        if  (this->hasException())
        {
            goto ruleLEFT_PARENEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLEFT_PARENEx; /* Prevent compiler warnings */
    ruleLEFT_PARENEx: ;

}
// $ANTLR end LEFT_PAREN

//   Comes from: 241:5: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RIGHT_PAREN
 *
 * Looks to match the characters the constitute the token RIGHT_PAREN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mRIGHT_PAREN()
{
    ANTLR_UINT32	_type;
      

    _type	    = RIGHT_PAREN;


    // PLSQLLexer.g:241:5: ( ')' )
    // PLSQLLexer.g:241:10: ')'
    {
         this->matchc(')');
        if  (this->hasException())
        {
            goto ruleRIGHT_PARENEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleRIGHT_PARENEx; /* Prevent compiler warnings */
    ruleRIGHT_PARENEx: ;

}
// $ANTLR end RIGHT_PAREN

//   Comes from: 245:5: ( '**' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBLE_ASTERISK
 *
 * Looks to match the characters the constitute the token DOUBLE_ASTERISK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mDOUBLE_ASTERISK()
{
    ANTLR_UINT32	_type;
      

    _type	    = DOUBLE_ASTERISK;


    // PLSQLLexer.g:245:5: ( '**' )
    // PLSQLLexer.g:245:10: '**'
    {
        this->matchs(lit_2);
        if  (this->hasException())
        {
            goto ruleDOUBLE_ASTERISKEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleDOUBLE_ASTERISKEx; /* Prevent compiler warnings */
    ruleDOUBLE_ASTERISKEx: ;

}
// $ANTLR end DOUBLE_ASTERISK

//   Comes from: 249:5: ( '*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ASTERISK
 *
 * Looks to match the characters the constitute the token ASTERISK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mASTERISK()
{
    ANTLR_UINT32	_type;
      

    _type	    = ASTERISK;


    // PLSQLLexer.g:249:5: ( '*' )
    // PLSQLLexer.g:249:10: '*'
    {
         this->matchc('*');
        if  (this->hasException())
        {
            goto ruleASTERISKEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleASTERISKEx; /* Prevent compiler warnings */
    ruleASTERISKEx: ;

}
// $ANTLR end ASTERISK

//   Comes from: 253:5: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLUS_SIGN
 *
 * Looks to match the characters the constitute the token PLUS_SIGN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLUS_SIGN()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLUS_SIGN;


    // PLSQLLexer.g:253:5: ( '+' )
    // PLSQLLexer.g:253:10: '+'
    {
         this->matchc('+');
        if  (this->hasException())
        {
            goto rulePLUS_SIGNEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLUS_SIGNEx; /* Prevent compiler warnings */
    rulePLUS_SIGNEx: ;

}
// $ANTLR end PLUS_SIGN

//   Comes from: 257:5: ( ',' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMA
 *
 * Looks to match the characters the constitute the token COMMA
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mCOMMA()
{
    ANTLR_UINT32	_type;
      

    _type	    = COMMA;


    // PLSQLLexer.g:257:5: ( ',' )
    // PLSQLLexer.g:257:10: ','
    {
         this->matchc(',');
        if  (this->hasException())
        {
            goto ruleCOMMAEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCOMMAEx; /* Prevent compiler warnings */
    ruleCOMMAEx: ;

}
// $ANTLR end COMMA

//   Comes from: 261:5: ( '/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SOLIDUS
 *
 * Looks to match the characters the constitute the token SOLIDUS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSOLIDUS()
{
    ANTLR_UINT32	_type;
      

    _type	    = SOLIDUS;


    // PLSQLLexer.g:261:5: ( '/' )
    // PLSQLLexer.g:261:10: '/'
    {
         this->matchc('/');
        if  (this->hasException())
        {
            goto ruleSOLIDUSEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSOLIDUSEx; /* Prevent compiler warnings */
    ruleSOLIDUSEx: ;

}
// $ANTLR end SOLIDUS

//   Comes from: 265:5: ( '@' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AT_SIGN
 *
 * Looks to match the characters the constitute the token AT_SIGN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mAT_SIGN()
{
    ANTLR_UINT32	_type;
      

    _type	    = AT_SIGN;


    // PLSQLLexer.g:265:5: ( '@' )
    // PLSQLLexer.g:265:10: '@'
    {
         this->matchc('@');
        if  (this->hasException())
        {
            goto ruleAT_SIGNEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleAT_SIGNEx; /* Prevent compiler warnings */
    ruleAT_SIGNEx: ;

}
// $ANTLR end AT_SIGN

//   Comes from: 269:5: ( ':=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ASSIGN_OP
 *
 * Looks to match the characters the constitute the token ASSIGN_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mASSIGN_OP()
{
    ANTLR_UINT32	_type;
      

    _type	    = ASSIGN_OP;


    // PLSQLLexer.g:269:5: ( ':=' )
    // PLSQLLexer.g:269:10: ':='
    {
        this->matchs(lit_3);
        if  (this->hasException())
        {
            goto ruleASSIGN_OPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleASSIGN_OPEx; /* Prevent compiler warnings */
    ruleASSIGN_OPEx: ;

}
// $ANTLR end ASSIGN_OP

//   Comes from: 274:5: ( COLON SIMPLE_LETTER ( SIMPLE_LETTER | '0' .. '9' | '_' )* | COLON DELIMITED_ID | COLON UNSIGNED_INTEGER | QUESTION_MARK )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BINDVAR
 *
 * Looks to match the characters the constitute the token BINDVAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mBINDVAR()
{
    ANTLR_UINT32	_type;
      

    _type	    = BINDVAR;


    {
        //  PLSQLLexer.g:274:5: ( COLON SIMPLE_LETTER ( SIMPLE_LETTER | '0' .. '9' | '_' )* | COLON DELIMITED_ID | COLON UNSIGNED_INTEGER | QUESTION_MARK )

        ANTLR_UINT32 alt25;

        alt25=4;

        {
            int LA25_0 = this->LA(1);
            if ( (LA25_0 == ':'))
            {
                switch ( this->LA(2) )
                {
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'G':
                case 'H':
                case 'I':
                case 'J':
                case 'K':
                case 'L':
                case 'M':
                case 'N':
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                case 'S':
                case 'T':
                case 'U':
                case 'V':
                case 'W':
                case 'X':
                case 'Y':
                case 'Z':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'g':
                case 'h':
                case 'i':
                case 'j':
                case 'k':
                case 'l':
                case 'm':
                case 'n':
                case 'o':
                case 'p':
                case 'q':
                case 'r':
                case 's':
                case 't':
                case 'u':
                case 'v':
                case 'w':
                case 'x':
                case 'y':
                case 'z':
                	{
                		alt25=1;
                	}
                    break;
                case '"':
                	{
                		alt25=2;
                	}
                    break;
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                	{
                		alt25=3;
                	}
                    break;

                default:
                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 25 );
                    ex->set_state( 1 );


                    goto ruleBINDVAREx;

                }

            }
            else if ( (LA25_0 == '?'))
            {
                alt25=4;
            }
            else
            {

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 25 );
                ex->set_state( 0 );


                goto ruleBINDVAREx;

            }
        }
        switch (alt25)
        {
    	case 1:
    	    // PLSQLLexer.g:274:10: COLON SIMPLE_LETTER ( SIMPLE_LETTER | '0' .. '9' | '_' )*
    	    {
    	        /* 274:10: COLON SIMPLE_LETTER ( SIMPLE_LETTER | '0' .. '9' | '_' )* */
    	        mCOLON();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	        /* 274:10: COLON SIMPLE_LETTER ( SIMPLE_LETTER | '0' .. '9' | '_' )* */
    	        mSIMPLE_LETTER();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	        // PLSQLLexer.g:274:31: ( SIMPLE_LETTER | '0' .. '9' | '_' )*

    	        for (;;)
    	        {
    	            int alt24=2;
    	            {
    	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                */
    	                int LA24_0 = this->LA(1);
    	                if ( (((LA24_0 >= '0') && (LA24_0 <= '9')) || ((LA24_0 >= 'A') && (LA24_0 <= 'Z')) || LA24_0 == '_' || ((LA24_0 >= 'a') && (LA24_0 <= 'z'))))
    	                {
    	                    alt24=1;
    	                }

    	            }
    	            switch (alt24)
    	            {
    	        	case 1:
    	        	    // PLSQLLexer.g:
    	        	    {
    	        	        if ( ((this->LA(1) >= '0') && (this->LA(1) <= '9')) || ((this->LA(1) >= 'A') && (this->LA(1) <= 'Z')) || this->LA(1) == '_' || ((this->LA(1) >= 'a') && (this->LA(1) <= 'z')) )
    	        	        {
    	        	            this->consume();
    	        	        }
    	        	        else
    	        	        {
    	        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

    	        	            this->recover();
    	        	            goto ruleBINDVAREx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop24;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop24: ; /* Jump out to here if this rule does not match */


    	    }
    	    break;
    	case 2:
    	    // PLSQLLexer.g:275:10: COLON DELIMITED_ID
    	    {
    	        /* 275:10: COLON DELIMITED_ID */
    	        mCOLON();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	        /* 275:10: COLON DELIMITED_ID */
    	        mDELIMITED_ID();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	    }
    	    break;
    	case 3:
    	    // PLSQLLexer.g:276:10: COLON UNSIGNED_INTEGER
    	    {
    	        /* 276:10: COLON UNSIGNED_INTEGER */
    	        mCOLON();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	        /* 276:10: COLON UNSIGNED_INTEGER */
    	        mUNSIGNED_INTEGER();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	    }
    	    break;
    	case 4:
    	    // PLSQLLexer.g:277:10: QUESTION_MARK
    	    {
    	        /* 277:10: QUESTION_MARK */
    	        mQUESTION_MARK();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	    }
    	    break;

        }
    }
	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleBINDVAREx; /* Prevent compiler warnings */
    ruleBINDVAREx: ;

}
// $ANTLR end BINDVAR

//   Comes from: 281:5: ( ':' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COLON
 *
 * Looks to match the characters the constitute the token COLON
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mCOLON()
{
    ANTLR_UINT32	_type;
      

    _type	    = COLON;


    // PLSQLLexer.g:281:5: ( ':' )
    // PLSQLLexer.g:281:10: ':'
    {
         this->matchc(':');
        if  (this->hasException())
        {
            goto ruleCOLONEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCOLONEx; /* Prevent compiler warnings */
    ruleCOLONEx: ;

}
// $ANTLR end COLON

//   Comes from: 285:5: ( ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SEMICOLON
 *
 * Looks to match the characters the constitute the token SEMICOLON
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSEMICOLON()
{
    ANTLR_UINT32	_type;
      

    _type	    = SEMICOLON;


    // PLSQLLexer.g:285:5: ( ';' )
    // PLSQLLexer.g:285:10: ';'
    {
         this->matchc(';');
        if  (this->hasException())
        {
            goto ruleSEMICOLONEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSEMICOLONEx; /* Prevent compiler warnings */
    ruleSEMICOLONEx: ;

}
// $ANTLR end SEMICOLON

//   Comes from: 289:5: ( '<=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LESS_THAN_OR_EQUALS_OP
 *
 * Looks to match the characters the constitute the token LESS_THAN_OR_EQUALS_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mLESS_THAN_OR_EQUALS_OP()
{
    ANTLR_UINT32	_type;
      

    _type	    = LESS_THAN_OR_EQUALS_OP;


    // PLSQLLexer.g:289:5: ( '<=' )
    // PLSQLLexer.g:289:10: '<='
    {
        this->matchs(lit_4);
        if  (this->hasException())
        {
            goto ruleLESS_THAN_OR_EQUALS_OPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLESS_THAN_OR_EQUALS_OPEx; /* Prevent compiler warnings */
    ruleLESS_THAN_OR_EQUALS_OPEx: ;

}
// $ANTLR end LESS_THAN_OR_EQUALS_OP

//   Comes from: 293:5: ( '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LESS_THAN_OP
 *
 * Looks to match the characters the constitute the token LESS_THAN_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mLESS_THAN_OP()
{
    ANTLR_UINT32	_type;
      

    _type	    = LESS_THAN_OP;


    // PLSQLLexer.g:293:5: ( '<' )
    // PLSQLLexer.g:293:10: '<'
    {
         this->matchc('<');
        if  (this->hasException())
        {
            goto ruleLESS_THAN_OPEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLESS_THAN_OPEx; /* Prevent compiler warnings */
    ruleLESS_THAN_OPEx: ;

}
// $ANTLR end LESS_THAN_OP

//   Comes from: 297:5: ( '>=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GREATER_THAN_OR_EQUALS_OP
 *
 * Looks to match the characters the constitute the token GREATER_THAN_OR_EQUALS_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mGREATER_THAN_OR_EQUALS_OP()
{
    ANTLR_UINT32	_type;
      

    _type	    = GREATER_THAN_OR_EQUALS_OP;


    // PLSQLLexer.g:297:5: ( '>=' )
    // PLSQLLexer.g:297:10: '>='
    {
        this->matchs(lit_5);
        if  (this->hasException())
        {
            goto ruleGREATER_THAN_OR_EQUALS_OPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleGREATER_THAN_OR_EQUALS_OPEx; /* Prevent compiler warnings */
    ruleGREATER_THAN_OR_EQUALS_OPEx: ;

}
// $ANTLR end GREATER_THAN_OR_EQUALS_OP

//   Comes from: 301:5: ( '!=' | '<>' | '^=' | '~=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NOT_EQUAL_OP
 *
 * Looks to match the characters the constitute the token NOT_EQUAL_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mNOT_EQUAL_OP()
{
    ANTLR_UINT32	_type;
      

    _type	    = NOT_EQUAL_OP;


    {
        //  PLSQLLexer.g:301:5: ( '!=' | '<>' | '^=' | '~=' )

        ANTLR_UINT32 alt26;

        alt26=4;

        switch ( this->LA(1) )
        {
        case '!':
        	{
        		alt26=1;
        	}
            break;
        case '<':
        	{
        		alt26=2;
        	}
            break;
        case '^':
        	{
        		alt26=3;
        	}
            break;
        case '~':
        	{
        		alt26=4;
        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 26 );
            ex->set_state( 0 );


            goto ruleNOT_EQUAL_OPEx;

        }

        switch (alt26)
        {
    	case 1:
    	    // PLSQLLexer.g:301:10: '!='
    	    {
    	        this->matchs(lit_6);
    	        if  (this->hasException())
    	        {
    	            goto ruleNOT_EQUAL_OPEx;
    	        }




    	    }
    	    break;
    	case 2:
    	    // PLSQLLexer.g:302:10: '<>'
    	    {
    	        this->matchs(lit_7);
    	        if  (this->hasException())
    	        {
    	            goto ruleNOT_EQUAL_OPEx;
    	        }




    	    }
    	    break;
    	case 3:
    	    // PLSQLLexer.g:303:10: '^='
    	    {
    	        this->matchs(lit_8);
    	        if  (this->hasException())
    	        {
    	            goto ruleNOT_EQUAL_OPEx;
    	        }




    	    }
    	    break;
    	case 4:
    	    // PLSQLLexer.g:304:10: '~='
    	    {
    	        this->matchs(lit_9);
    	        if  (this->hasException())
    	        {
    	            goto ruleNOT_EQUAL_OPEx;
    	        }




    	    }
    	    break;

        }
    }
	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleNOT_EQUAL_OPEx; /* Prevent compiler warnings */
    ruleNOT_EQUAL_OPEx: ;

}
// $ANTLR end NOT_EQUAL_OP

//   Comes from: 307:5: ( '^' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CARRET_OPERATOR_PART
 *
 * Looks to match the characters the constitute the token CARRET_OPERATOR_PART
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mCARRET_OPERATOR_PART()
{
    ANTLR_UINT32	_type;
      

    _type	    = CARRET_OPERATOR_PART;


    // PLSQLLexer.g:307:5: ( '^' )
    // PLSQLLexer.g:307:10: '^'
    {
         this->matchc('^');
        if  (this->hasException())
        {
            goto ruleCARRET_OPERATOR_PARTEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCARRET_OPERATOR_PARTEx; /* Prevent compiler warnings */
    ruleCARRET_OPERATOR_PARTEx: ;

}
// $ANTLR end CARRET_OPERATOR_PART

//   Comes from: 311:5: ( '~' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TILDE_OPERATOR_PART
 *
 * Looks to match the characters the constitute the token TILDE_OPERATOR_PART
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mTILDE_OPERATOR_PART()
{
    ANTLR_UINT32	_type;
      

    _type	    = TILDE_OPERATOR_PART;


    // PLSQLLexer.g:311:5: ( '~' )
    // PLSQLLexer.g:311:10: '~'
    {
         this->matchc('~');
        if  (this->hasException())
        {
            goto ruleTILDE_OPERATOR_PARTEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleTILDE_OPERATOR_PARTEx; /* Prevent compiler warnings */
    ruleTILDE_OPERATOR_PARTEx: ;

}
// $ANTLR end TILDE_OPERATOR_PART

//   Comes from: 315:5: ( '!' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXCLAMATION_OPERATOR_PART
 *
 * Looks to match the characters the constitute the token EXCLAMATION_OPERATOR_PART
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mEXCLAMATION_OPERATOR_PART()
{
    ANTLR_UINT32	_type;
      

    _type	    = EXCLAMATION_OPERATOR_PART;


    // PLSQLLexer.g:315:5: ( '!' )
    // PLSQLLexer.g:315:10: '!'
    {
         this->matchc('!');
        if  (this->hasException())
        {
            goto ruleEXCLAMATION_OPERATOR_PARTEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleEXCLAMATION_OPERATOR_PARTEx; /* Prevent compiler warnings */
    ruleEXCLAMATION_OPERATOR_PARTEx: ;

}
// $ANTLR end EXCLAMATION_OPERATOR_PART

//   Comes from: 319:5: ( '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GREATER_THAN_OP
 *
 * Looks to match the characters the constitute the token GREATER_THAN_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mGREATER_THAN_OP()
{
    ANTLR_UINT32	_type;
      

    _type	    = GREATER_THAN_OP;


    // PLSQLLexer.g:319:5: ( '>' )
    // PLSQLLexer.g:319:10: '>'
    {
         this->matchc('>');
        if  (this->hasException())
        {
            goto ruleGREATER_THAN_OPEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleGREATER_THAN_OPEx; /* Prevent compiler warnings */
    ruleGREATER_THAN_OPEx: ;

}
// $ANTLR end GREATER_THAN_OP

//   Comes from: 324:5: ( '?' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QUESTION_MARK
 *
 * Looks to match the characters the constitute the token QUESTION_MARK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mQUESTION_MARK()
{
    ANTLR_UINT32	_type;
      


    // PLSQLLexer.g:324:5: ( '?' )
    // PLSQLLexer.g:324:10: '?'
    {
         this->matchc('?');
        if  (this->hasException())
        {
            goto ruleQUESTION_MARKEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleQUESTION_MARKEx; /* Prevent compiler warnings */
    ruleQUESTION_MARKEx: ;

}
// $ANTLR end QUESTION_MARK

//   Comes from: 329:5: ( '||' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CONCATENATION_OP
 *
 * Looks to match the characters the constitute the token CONCATENATION_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mCONCATENATION_OP()
{
    ANTLR_UINT32	_type;
      

    _type	    = CONCATENATION_OP;


    // PLSQLLexer.g:329:5: ( '||' )
    // PLSQLLexer.g:329:10: '||'
    {
        this->matchs(lit_10);
        if  (this->hasException())
        {
            goto ruleCONCATENATION_OPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCONCATENATION_OPEx; /* Prevent compiler warnings */
    ruleCONCATENATION_OPEx: ;

}
// $ANTLR end CONCATENATION_OP

//   Comes from: 333:5: ( '|' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start VERTICAL_BAR
 *
 * Looks to match the characters the constitute the token VERTICAL_BAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mVERTICAL_BAR()
{
    ANTLR_UINT32	_type;
      

    _type	    = VERTICAL_BAR;


    // PLSQLLexer.g:333:5: ( '|' )
    // PLSQLLexer.g:333:10: '|'
    {
         this->matchc('|');
        if  (this->hasException())
        {
            goto ruleVERTICAL_BAREx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleVERTICAL_BAREx; /* Prevent compiler warnings */
    ruleVERTICAL_BAREx: ;

}
// $ANTLR end VERTICAL_BAR

//   Comes from: 337:5: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EQUALS_OP
 *
 * Looks to match the characters the constitute the token EQUALS_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mEQUALS_OP()
{
    ANTLR_UINT32	_type;
      

    _type	    = EQUALS_OP;


    // PLSQLLexer.g:337:5: ( '=' )
    // PLSQLLexer.g:337:10: '='
    {
         this->matchc('=');
        if  (this->hasException())
        {
            goto ruleEQUALS_OPEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleEQUALS_OPEx; /* Prevent compiler warnings */
    ruleEQUALS_OPEx: ;

}
// $ANTLR end EQUALS_OP

//   Comes from: 342:5: ( '[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LEFT_BRACKET
 *
 * Looks to match the characters the constitute the token LEFT_BRACKET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mLEFT_BRACKET()
{
    ANTLR_UINT32	_type;
      

    _type	    = LEFT_BRACKET;


    // PLSQLLexer.g:342:5: ( '[' )
    // PLSQLLexer.g:342:10: '['
    {
         this->matchc('[');
        if  (this->hasException())
        {
            goto ruleLEFT_BRACKETEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLEFT_BRACKETEx; /* Prevent compiler warnings */
    ruleLEFT_BRACKETEx: ;

}
// $ANTLR end LEFT_BRACKET

//   Comes from: 346:5: ( ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RIGHT_BRACKET
 *
 * Looks to match the characters the constitute the token RIGHT_BRACKET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mRIGHT_BRACKET()
{
    ANTLR_UINT32	_type;
      

    _type	    = RIGHT_BRACKET;


    // PLSQLLexer.g:346:5: ( ']' )
    // PLSQLLexer.g:346:10: ']'
    {
         this->matchc(']');
        if  (this->hasException())
        {
            goto ruleRIGHT_BRACKETEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleRIGHT_BRACKETEx; /* Prevent compiler warnings */
    ruleRIGHT_BRACKETEx: ;

}
// $ANTLR end RIGHT_BRACKET

//   Comes from: 353:5: ( '_' ( SEPARATOR )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INTRODUCER
 *
 * Looks to match the characters the constitute the token INTRODUCER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mINTRODUCER()
{
    ANTLR_UINT32	_type;
      

    _type	    = INTRODUCER;


    // PLSQLLexer.g:353:5: ( '_' ( SEPARATOR )? )
    // PLSQLLexer.g:353:10: '_' ( SEPARATOR )?
    {
         this->matchc('_');
        if  (this->hasException())
        {
            goto ruleINTRODUCEREx;
        }


        // PLSQLLexer.g:353:14: ( SEPARATOR )?
        {
            int alt27=2;
            {
                int LA27_0 = this->LA(1);
                if ( (((LA27_0 >= '\t') && (LA27_0 <= '\n')) || LA27_0 == '\r' || LA27_0 == ' ' || LA27_0 == '-' || LA27_0 == '/'))
                {
                    alt27=1;
                }
            }
            switch (alt27)
            {
        	case 1:
        	    // PLSQLLexer.g:353:15: SEPARATOR
        	    {
        	        /* 353:15: SEPARATOR */
        	        mSEPARATOR();
        	        if  (this->hasException())
        	        {
        	            goto ruleINTRODUCEREx;
        	        }



        	        {
        	            _type = UNDERSCORE;
        	        }


        	    }
        	    break;

            }
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleINTRODUCEREx; /* Prevent compiler warnings */
    ruleINTRODUCEREx: ;

}
// $ANTLR end INTRODUCER

//   Comes from: 359:5: ( '-' | COMMENT | ( SPACE | NEWLINE )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SEPARATOR
 *
 * Looks to match the characters the constitute the token SEPARATOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSEPARATOR()
{
    ANTLR_UINT32	_type;
      

    _type	    = SEPARATOR;


    {
        //  PLSQLLexer.g:359:5: ( '-' | COMMENT | ( SPACE | NEWLINE )+ )

        ANTLR_UINT32 alt29;

        alt29=3;

        switch ( this->LA(1) )
        {
        case '-':
        	{
        		{
        		    int LA29_1 = this->LA(2);
        		    if ( (LA29_1 == '-'))
        		    {
        		        alt29=2;
        		    }
        		    else
        		    {
        		        alt29=1;
        		    }
        		}
        	}
            break;
        case '/':
        	{
        		alt29=2;
        	}
            break;
        case '\t':
        case '\n':
        case '\r':
        case ' ':
        	{
        		alt29=3;
        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 29 );
            ex->set_state( 0 );


            goto ruleSEPARATOREx;

        }

        switch (alt29)
        {
    	case 1:
    	    // PLSQLLexer.g:359:10: '-'
    	    {
    	         this->matchc('-');
    	        if  (this->hasException())
    	        {
    	            goto ruleSEPARATOREx;
    	        }


    	        {
    	            _type = MINUS_SIGN;
    	        }


    	    }
    	    break;
    	case 2:
    	    // PLSQLLexer.g:360:10: COMMENT
    	    {
    	        /* 360:10: COMMENT */
    	        mCOMMENT();
    	        if  (this->hasException())
    	        {
    	            goto ruleSEPARATOREx;
    	        }



    	        {
    	             this->get_state()->get_channel()=HIDDEN; 
    	        }


    	    }
    	    break;
    	case 3:
    	    // PLSQLLexer.g:361:10: ( SPACE | NEWLINE )+
    	    {
    	        // PLSQLLexer.g:361:10: ( SPACE | NEWLINE )+
    	        {
    	            int cnt28=0;

    	            for (;;)
    	            {
    	                int alt28=3;
    	        	{
    	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	        	    */
    	        	    int LA28_0 = this->LA(1);
    	        	    if ( (LA28_0 == '\t' || LA28_0 == ' '))
    	        	    {
    	        	        alt28=1;
    	        	    }
    	        	    else if ( (LA28_0 == '\n' || LA28_0 == '\r'))
    	        	    {
    	        	        alt28=2;
    	        	    }

    	        	}
    	        	switch (alt28)
    	        	{
    	        	    case 1:
    	        	        // PLSQLLexer.g:361:11: SPACE
    	        	        {
    	        	            /* 361:11: SPACE */
    	        	            mSPACE();
    	        	            if  (this->hasException())
    	        	            {
    	        	                goto ruleSEPARATOREx;
    	        	            }



    	        	        }
    	        	        break;
    	        	    case 2:
    	        	        // PLSQLLexer.g:361:19: NEWLINE
    	        	        {
    	        	            /* 361:19: NEWLINE */
    	        	            mNEWLINE();
    	        	            if  (this->hasException())
    	        	            {
    	        	                goto ruleSEPARATOREx;
    	        	            }



    	        	        }
    	        	        break;

    	        	    default:

    	        		if ( cnt28 >= 1 )
    	        		{
    	        		    goto loop28;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		new ANTLR_Exception< PLSQLLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


    	        		goto ruleSEPARATOREx;
    	        	}
    	        	cnt28++;
    	            }
    	            loop28: ;	/* Jump to here if this rule does not match */
    	        }

    	        {
    	             this->get_state()->get_channel()=HIDDEN; 
    	        }


    	    }
    	    break;

        }
    }
	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSEPARATOREx; /* Prevent compiler warnings */
    ruleSEPARATOREx: ;

}
// $ANTLR end SEPARATOR

//   Comes from: 369:5: ( 'a' .. 'z' | 'A' .. 'Z' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SIMPLE_LETTER
 *
 * Looks to match the characters the constitute the token SIMPLE_LETTER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSIMPLE_LETTER()
{
    ANTLR_UINT32	_type;
      


    // PLSQLLexer.g:369:5: ( 'a' .. 'z' | 'A' .. 'Z' )
    // PLSQLLexer.g:
    {
        if ( ((this->LA(1) >= 'A') && (this->LA(1) <= 'Z')) || ((this->LA(1) >= 'a') && (this->LA(1) <= 'z')) )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleSIMPLE_LETTEREx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleSIMPLE_LETTEREx; /* Prevent compiler warnings */
    ruleSIMPLE_LETTEREx: ;

}
// $ANTLR end SIMPLE_LETTER

//   Comes from: 378:5: ( ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNSIGNED_INTEGER
 *
 * Looks to match the characters the constitute the token UNSIGNED_INTEGER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mUNSIGNED_INTEGER()
{
    ANTLR_UINT32	_type;
      


    // PLSQLLexer.g:378:5: ( ( '0' .. '9' )+ )
    // PLSQLLexer.g:378:10: ( '0' .. '9' )+
    {
        // PLSQLLexer.g:378:10: ( '0' .. '9' )+
        {
            int cnt30=0;

            for (;;)
            {
                int alt30=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA30_0 = this->LA(1);
        	    if ( (((LA30_0 >= '0') && (LA30_0 <= '9'))))
        	    {
        	        alt30=1;
        	    }

        	}
        	switch (alt30)
        	{
        	    case 1:
        	        // PLSQLLexer.g:
        	        {
        	            if ( ((this->LA(1) >= '0') && (this->LA(1) <= '9')) )
        	            {
        	                this->consume();
        	            }
        	            else
        	            {
        	                new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	                this->recover();
        	                goto ruleUNSIGNED_INTEGEREx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt30 >= 1 )
        		{
        		    goto loop30;
        		}
        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< PLSQLLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto ruleUNSIGNED_INTEGEREx;
        	}
        	cnt30++;
            }
            loop30: ;	/* Jump to here if this rule does not match */
        }

    }


    // This is where rules clean up and exit
    //
    goto ruleUNSIGNED_INTEGEREx; /* Prevent compiler warnings */
    ruleUNSIGNED_INTEGEREx: ;

}
// $ANTLR end UNSIGNED_INTEGER

//   Comes from: 385:5: ( '--' (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF ) | '/*' ( options {greedy=false; } : . )* '*/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT
 *
 * Looks to match the characters the constitute the token COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mCOMMENT()
{
    ANTLR_UINT32	_type;
      


    {
        //  PLSQLLexer.g:385:5: ( '--' (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF ) | '/*' ( options {greedy=false; } : . )* '*/' )

        ANTLR_UINT32 alt34;

        alt34=2;

        {
            int LA34_0 = this->LA(1);
            if ( (LA34_0 == '-'))
            {
                alt34=1;
            }
            else if ( (LA34_0 == '/'))
            {
                alt34=2;
            }
            else
            {

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 34 );
                ex->set_state( 0 );


                goto ruleCOMMENTEx;

            }
        }
        switch (alt34)
        {
    	case 1:
    	    // PLSQLLexer.g:385:10: '--' (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF )
    	    {
    	        this->matchs(lit_11);
    	        if  (this->hasException())
    	        {
    	            goto ruleCOMMENTEx;
    	        }




    	        // PLSQLLexer.g:385:15: (~ ( '\\r' | '\\n' ) )*

    	        for (;;)
    	        {
    	            int alt31=2;
    	            {
    	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                */
    	                int LA31_0 = this->LA(1);
    	                if ( (((LA31_0 >= 0x0000) && (LA31_0 <= '\t')) || ((LA31_0 >= 0x000B) && (LA31_0 <= '\f')) || ((LA31_0 >= 0x000E) && (LA31_0 <= 0xFFFF))))
    	                {
    	                    alt31=1;
    	                }

    	            }
    	            switch (alt31)
    	            {
    	        	case 1:
    	        	    // PLSQLLexer.g:
    	        	    {
    	        	        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\t')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= 0xFFFF)) )
    	        	        {
    	        	            this->consume();
    	        	        }
    	        	        else
    	        	        {
    	        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

    	        	            this->recover();
    	        	            goto ruleCOMMENTEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop31;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop31: ; /* Jump out to here if this rule does not match */


    	        // PLSQLLexer.g:385:35: ( NEWLINE | EOF )
    	        {
    	            int alt32=2;
    	            {
    	                int LA32_0 = this->LA(1);
    	                if ( (LA32_0 == '\n' || LA32_0 == '\r'))
    	                {
    	                    alt32=1;
    	                }
    	                else
    	                {
    	                    alt32=2;
    	                }
    	            }
    	            switch (alt32)
    	            {
    	        	case 1:
    	        	    // PLSQLLexer.g:385:36: NEWLINE
    	        	    {
    	        	        /* 385:36: NEWLINE */
    	        	        mNEWLINE();
    	        	        if  (this->hasException())
    	        	        {
    	        	            goto ruleCOMMENTEx;
    	        	        }



    	        	    }
    	        	    break;
    	        	case 2:
    	        	    // PLSQLLexer.g:385:44: EOF
    	        	    {
    	        	            this->matchc(ANTLR_CHARSTREAM_EOF);
    	        	            if  (this->hasException())
    	        	            {
    	        	                goto ruleCOMMENTEx;
    	        	            }



    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 2:
    	    // PLSQLLexer.g:386:10: '/*' ( options {greedy=false; } : . )* '*/'
    	    {
    	        this->matchs(lit_12);
    	        if  (this->hasException())
    	        {
    	            goto ruleCOMMENTEx;
    	        }




    	        // PLSQLLexer.g:386:15: ( options {greedy=false; } : . )*

    	        for (;;)
    	        {
    	            int alt33=2;
    	            {
    	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                */
    	                int LA33_0 = this->LA(1);
    	                if ( (LA33_0 == '*'))
    	                {
    	                    {
    	                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                        */
    	                        int LA33_1 = this->LA(2);
    	                        if ( (LA33_1 == '/'))
    	                        {
    	                            alt33=2;
    	                        }
    	                        else if ( (((LA33_1 >= 0x0000) && (LA33_1 <= '.')) || ((LA33_1 >= '0') && (LA33_1 <= 0xFFFF))))
    	                        {
    	                            alt33=1;
    	                        }

    	                    }
    	                }
    	                else if ( (((LA33_0 >= 0x0000) && (LA33_0 <= ')')) || ((LA33_0 >= '+') && (LA33_0 <= 0xFFFF))))
    	                {
    	                    alt33=1;
    	                }

    	            }
    	            switch (alt33)
    	            {
    	        	case 1:
    	        	    // PLSQLLexer.g:386:41: .
    	        	    {
    	        	        this->matchAny();
    	        	        if  (this->hasException())
    	        	        {
    	        	            goto ruleCOMMENTEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop33;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop33: ; /* Jump out to here if this rule does not match */


    	        this->matchs(lit_13);
    	        if  (this->hasException())
    	        {
    	            goto ruleCOMMENTEx;
    	        }




    	    }
    	    break;

        }
    }

    // This is where rules clean up and exit
    //
    goto ruleCOMMENTEx; /* Prevent compiler warnings */
    ruleCOMMENTEx: ;

}
// $ANTLR end COMMENT

//   Comes from: 393:2: ( 'PROMPT' SPACE (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PROMPT
 *
 * Looks to match the characters the constitute the token PROMPT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPROMPT()
{
    ANTLR_UINT32	_type;
      

    _type	    = PROMPT;


    // PLSQLLexer.g:393:2: ( 'PROMPT' SPACE (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF ) )
    // PLSQLLexer.g:393:4: 'PROMPT' SPACE (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF )
    {
        this->matchs(lit_14);
        if  (this->hasException())
        {
            goto rulePROMPTEx;
        }




        /* 393:4: 'PROMPT' SPACE (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF ) */
        mSPACE();
        if  (this->hasException())
        {
            goto rulePROMPTEx;
        }



        // PLSQLLexer.g:393:19: (~ ( '\\r' | '\\n' ) )*

        for (;;)
        {
            int alt35=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA35_0 = this->LA(1);
                if ( (((LA35_0 >= 0x0000) && (LA35_0 <= '\t')) || ((LA35_0 >= 0x000B) && (LA35_0 <= '\f')) || ((LA35_0 >= 0x000E) && (LA35_0 <= 0xFFFF))))
                {
                    alt35=1;
                }

            }
            switch (alt35)
            {
        	case 1:
        	    // PLSQLLexer.g:
        	    {
        	        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\t')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= 0xFFFF)) )
        	        {
        	            this->consume();
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            this->recover();
        	            goto rulePROMPTEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop35;	/* break out of the loop */
        	    break;
            }
        }
        loop35: ; /* Jump out to here if this rule does not match */


        // PLSQLLexer.g:393:39: ( NEWLINE | EOF )
        {
            int alt36=2;
            {
                int LA36_0 = this->LA(1);
                if ( (LA36_0 == '\n' || LA36_0 == '\r'))
                {
                    alt36=1;
                }
                else
                {
                    alt36=2;
                }
            }
            switch (alt36)
            {
        	case 1:
        	    // PLSQLLexer.g:393:40: NEWLINE
        	    {
        	        /* 393:40: NEWLINE */
        	        mNEWLINE();
        	        if  (this->hasException())
        	        {
        	            goto rulePROMPTEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // PLSQLLexer.g:393:48: EOF
        	    {
        	            this->matchc(ANTLR_CHARSTREAM_EOF);
        	            if  (this->hasException())
        	            {
        	                goto rulePROMPTEx;
        	            }



        	    }
        	    break;

            }
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePROMPTEx; /* Prevent compiler warnings */
    rulePROMPTEx: ;

}
// $ANTLR end PROMPT

//   Comes from: 402:5: ( '\\r' ( options {greedy=true; } : '\\n' )? | '\\n' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NEWLINE
 *
 * Looks to match the characters the constitute the token NEWLINE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mNEWLINE()
{
    ANTLR_UINT32	_type;
      


    {
        //  PLSQLLexer.g:402:5: ( '\\r' ( options {greedy=true; } : '\\n' )? | '\\n' )

        ANTLR_UINT32 alt38;

        alt38=2;

        {
            int LA38_0 = this->LA(1);
            if ( (LA38_0 == '\r'))
            {
                alt38=1;
            }
            else if ( (LA38_0 == '\n'))
            {
                alt38=2;
            }
            else
            {

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 38 );
                ex->set_state( 0 );


                goto ruleNEWLINEEx;

            }
        }
        switch (alt38)
        {
    	case 1:
    	    // PLSQLLexer.g:402:10: '\\r' ( options {greedy=true; } : '\\n' )?
    	    {
    	         this->matchc('\r');
    	        if  (this->hasException())
    	        {
    	            goto ruleNEWLINEEx;
    	        }


    	        // PLSQLLexer.g:402:15: ( options {greedy=true; } : '\\n' )?
    	        {
    	            int alt37=2;
    	            {
    	                int LA37_0 = this->LA(1);
    	                if ( (LA37_0 == '\n'))
    	                {
    	                    alt37=1;
    	                }
    	            }
    	            switch (alt37)
    	            {
    	        	case 1:
    	        	    // PLSQLLexer.g:402:39: '\\n'
    	        	    {
    	        	         this->matchc('\n');
    	        	        if  (this->hasException())
    	        	        {
    	        	            goto ruleNEWLINEEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 2:
    	    // PLSQLLexer.g:403:10: '\\n'
    	    {
    	         this->matchc('\n');
    	        if  (this->hasException())
    	        {
    	            goto ruleNEWLINEEx;
    	        }


    	    }
    	    break;

        }
    }

    // This is where rules clean up and exit
    //
    goto ruleNEWLINEEx; /* Prevent compiler warnings */
    ruleNEWLINEEx: ;

}
// $ANTLR end NEWLINE

//   Comes from: 409:10: ( ' ' | '\\t' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SPACE
 *
 * Looks to match the characters the constitute the token SPACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSPACE()
{
    ANTLR_UINT32	_type;
      


    // PLSQLLexer.g:409:10: ( ' ' | '\\t' )
    // PLSQLLexer.g:
    {
        if ( this->LA(1) == '\t' || this->LA(1) == ' ' )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleSPACEEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleSPACEEx; /* Prevent compiler warnings */
    ruleSPACEEx: ;

}
// $ANTLR end SPACE

//   Comes from: 414:29: ()
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start APPROXIMATE_NUM_LIT
 *
 * Looks to match the characters the constitute the token APPROXIMATE_NUM_LIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mAPPROXIMATE_NUM_LIT()
{
    ANTLR_UINT32	_type;
      


    // PLSQLLexer.g:414:29: ()
    // PLSQLLexer.g:414:31: 
    {
    }


    // This is where rules clean up and exit
    //
    goto ruleAPPROXIMATE_NUM_LITEx; /* Prevent compiler warnings */
    ruleAPPROXIMATE_NUM_LITEx: ;

}
// $ANTLR end APPROXIMATE_NUM_LIT

//   Comes from: 415:20: ()
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MINUS_SIGN
 *
 * Looks to match the characters the constitute the token MINUS_SIGN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mMINUS_SIGN()
{
    ANTLR_UINT32	_type;
      


    // PLSQLLexer.g:415:20: ()
    // PLSQLLexer.g:415:22: 
    {
    }


    // This is where rules clean up and exit
    //
    goto ruleMINUS_SIGNEx; /* Prevent compiler warnings */
    ruleMINUS_SIGNEx: ;

}
// $ANTLR end MINUS_SIGN

//   Comes from: 416:20: ()
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNDERSCORE
 *
 * Looks to match the characters the constitute the token UNDERSCORE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mUNDERSCORE()
{
    ANTLR_UINT32	_type;
      


    // PLSQLLexer.g:416:20: ()
    // PLSQLLexer.g:416:22: 
    {
    }


    // This is where rules clean up and exit
    //
    goto ruleUNDERSCOREEx; /* Prevent compiler warnings */
    ruleUNDERSCOREEx: ;

}
// $ANTLR end UNDERSCORE

//   Comes from: 417:23: ()
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBLE_PERIOD
 *
 * Looks to match the characters the constitute the token DOUBLE_PERIOD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mDOUBLE_PERIOD()
{
    ANTLR_UINT32	_type;
      


    // PLSQLLexer.g:417:23: ()
    // PLSQLLexer.g:417:25: 
    {
    }


    // This is where rules clean up and exit
    //
    goto ruleDOUBLE_PERIODEx; /* Prevent compiler warnings */
    ruleDOUBLE_PERIODEx: ;

}
// $ANTLR end DOUBLE_PERIOD

//   Comes from: 423:5: ( 'ALL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ALL
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ALL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_ALL()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_ALL;


    // PLSQLLexer.g:423:5: ( 'ALL' )
    // PLSQLLexer.g:423:10: 'ALL'
    {
        this->matchs(lit_15);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ALLEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ALLEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ALLEx: ;

}
// $ANTLR end SQL92_RESERVED_ALL

//   Comes from: 427:5: ( 'ALTER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ALTER
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ALTER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_ALTER()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_ALTER;


    // PLSQLLexer.g:427:5: ( 'ALTER' )
    // PLSQLLexer.g:427:10: 'ALTER'
    {
        this->matchs(lit_16);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ALTEREx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ALTEREx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ALTEREx: ;

}
// $ANTLR end SQL92_RESERVED_ALTER

//   Comes from: 431:5: ( 'AND' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_AND
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_AND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_AND()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_AND;


    // PLSQLLexer.g:431:5: ( 'AND' )
    // PLSQLLexer.g:431:10: 'AND'
    {
        this->matchs(lit_17);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ANDEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ANDEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ANDEx: ;

}
// $ANTLR end SQL92_RESERVED_AND

//   Comes from: 435:5: ( 'ANY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ANY
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ANY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_ANY()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_ANY;


    // PLSQLLexer.g:435:5: ( 'ANY' )
    // PLSQLLexer.g:435:10: 'ANY'
    {
        this->matchs(lit_18);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ANYEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ANYEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ANYEx: ;

}
// $ANTLR end SQL92_RESERVED_ANY

//   Comes from: 439:5: ( 'AS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_AS
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_AS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_AS()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_AS;


    // PLSQLLexer.g:439:5: ( 'AS' )
    // PLSQLLexer.g:439:10: 'AS'
    {
        this->matchs(lit_19);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ASEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ASEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ASEx: ;

}
// $ANTLR end SQL92_RESERVED_AS

//   Comes from: 443:5: ( 'ASC' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ASC
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ASC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_ASC()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_ASC;


    // PLSQLLexer.g:443:5: ( 'ASC' )
    // PLSQLLexer.g:443:10: 'ASC'
    {
        this->matchs(lit_20);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ASCEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ASCEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ASCEx: ;

}
// $ANTLR end SQL92_RESERVED_ASC

//   Comes from: 451:5: ( 'BEGIN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_BEGIN
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_BEGIN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_BEGIN()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_BEGIN;


    // PLSQLLexer.g:451:5: ( 'BEGIN' )
    // PLSQLLexer.g:451:10: 'BEGIN'
    {
        this->matchs(lit_21);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_BEGINEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_BEGINEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_BEGINEx: ;

}
// $ANTLR end SQL92_RESERVED_BEGIN

//   Comes from: 455:5: ( 'BETWEEN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_BETWEEN
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_BETWEEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_BETWEEN()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_BETWEEN;


    // PLSQLLexer.g:455:5: ( 'BETWEEN' )
    // PLSQLLexer.g:455:10: 'BETWEEN'
    {
        this->matchs(lit_22);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_BETWEENEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_BETWEENEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_BETWEENEx: ;

}
// $ANTLR end SQL92_RESERVED_BETWEEN

//   Comes from: 459:5: ( 'BY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_BY
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_BY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_BY()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_BY;


    // PLSQLLexer.g:459:5: ( 'BY' )
    // PLSQLLexer.g:459:10: 'BY'
    {
        this->matchs(lit_23);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_BYEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_BYEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_BYEx: ;

}
// $ANTLR end SQL92_RESERVED_BY

//   Comes from: 463:5: ( 'CASE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_CASE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_CASE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_CASE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_CASE;


    // PLSQLLexer.g:463:5: ( 'CASE' )
    // PLSQLLexer.g:463:10: 'CASE'
    {
        this->matchs(lit_24);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_CASEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_CASEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_CASEEx: ;

}
// $ANTLR end SQL92_RESERVED_CASE

//   Comes from: 467:5: ( 'CHECK' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_CHECK
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_CHECK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_CHECK()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_CHECK;


    // PLSQLLexer.g:467:5: ( 'CHECK' )
    // PLSQLLexer.g:467:10: 'CHECK'
    {
        this->matchs(lit_25);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_CHECKEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_CHECKEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_CHECKEx: ;

}
// $ANTLR end SQL92_RESERVED_CHECK

//   Comes from: 471:5: ( 'CLUSTERS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_CLUSTERS
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_CLUSTERS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_CLUSTERS()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_CLUSTERS;


    // PLSQLLexer.g:471:5: ( 'CLUSTERS' )
    // PLSQLLexer.g:471:10: 'CLUSTERS'
    {
        this->matchs(lit_26);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_CLUSTERSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_CLUSTERSEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_CLUSTERSEx: ;

}
// $ANTLR end PLSQL_RESERVED_CLUSTERS

//   Comes from: 475:5: ( 'COLAUTH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_COLAUTH
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_COLAUTH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_COLAUTH()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_COLAUTH;


    // PLSQLLexer.g:475:5: ( 'COLAUTH' )
    // PLSQLLexer.g:475:10: 'COLAUTH'
    {
        this->matchs(lit_27);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_COLAUTHEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_COLAUTHEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_COLAUTHEx: ;

}
// $ANTLR end PLSQL_RESERVED_COLAUTH

//   Comes from: 479:5: ( 'COMPRESS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_COMPRESS
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_COMPRESS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_COMPRESS()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_COMPRESS;


    // PLSQLLexer.g:479:5: ( 'COMPRESS' )
    // PLSQLLexer.g:479:10: 'COMPRESS'
    {
        this->matchs(lit_28);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_COMPRESSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_COMPRESSEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_COMPRESSEx: ;

}
// $ANTLR end PLSQL_RESERVED_COMPRESS

//   Comes from: 483:5: ( 'CONNECT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_CONNECT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_CONNECT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_CONNECT()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_CONNECT;


    // PLSQLLexer.g:483:5: ( 'CONNECT' )
    // PLSQLLexer.g:483:10: 'CONNECT'
    {
        this->matchs(lit_29);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_CONNECTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_CONNECTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_CONNECTEx: ;

}
// $ANTLR end SQL92_RESERVED_CONNECT

//   Comes from: 491:5: ( 'CONNECT_BY_ROOT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_CONNECT_BY_ROOT
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_CONNECT_BY_ROOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_NON_RESERVED_CONNECT_BY_ROOT()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_NON_RESERVED_CONNECT_BY_ROOT;


    // PLSQLLexer.g:491:5: ( 'CONNECT_BY_ROOT' )
    // PLSQLLexer.g:491:10: 'CONNECT_BY_ROOT'
    {
        this->matchs(lit_30);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_CONNECT_BY_ROOTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_CONNECT_BY_ROOTEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_CONNECT_BY_ROOTEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_CONNECT_BY_ROOT

//   Comes from: 495:5: ( 'CRASH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_CRASH
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_CRASH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_CRASH()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_CRASH;


    // PLSQLLexer.g:495:5: ( 'CRASH' )
    // PLSQLLexer.g:495:10: 'CRASH'
    {
        this->matchs(lit_31);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_CRASHEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_CRASHEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_CRASHEx: ;

}
// $ANTLR end PLSQL_RESERVED_CRASH

//   Comes from: 499:5: ( 'CREATE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_CREATE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_CREATE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_CREATE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_CREATE;


    // PLSQLLexer.g:499:5: ( 'CREATE' )
    // PLSQLLexer.g:499:10: 'CREATE'
    {
        this->matchs(lit_32);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_CREATEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_CREATEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_CREATEEx: ;

}
// $ANTLR end SQL92_RESERVED_CREATE

//   Comes from: 503:5: ( 'CURRENT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_CURRENT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_CURRENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_CURRENT()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_CURRENT;


    // PLSQLLexer.g:503:5: ( 'CURRENT' )
    // PLSQLLexer.g:503:10: 'CURRENT'
    {
        this->matchs(lit_33);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_CURRENTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_CURRENTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_CURRENTEx: ;

}
// $ANTLR end SQL92_RESERVED_CURRENT

//   Comes from: 507:5: ( 'CURSOR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_CURSOR
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_CURSOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_CURSOR()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_CURSOR;


    // PLSQLLexer.g:507:5: ( 'CURSOR' )
    // PLSQLLexer.g:507:10: 'CURSOR'
    {
        this->matchs(lit_34);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_CURSOREx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_CURSOREx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_CURSOREx: ;

}
// $ANTLR end SQL92_RESERVED_CURSOR

//   Comes from: 511:5: ( 'DATE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DATE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DATE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_DATE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_DATE;


    // PLSQLLexer.g:511:5: ( 'DATE' )
    // PLSQLLexer.g:511:10: 'DATE'
    {
        this->matchs(lit_35);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DATEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DATEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DATEEx: ;

}
// $ANTLR end SQL92_RESERVED_DATE

//   Comes from: 515:5: ( 'DECLARE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DECLARE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DECLARE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_DECLARE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_DECLARE;


    // PLSQLLexer.g:515:5: ( 'DECLARE' )
    // PLSQLLexer.g:515:10: 'DECLARE'
    {
        this->matchs(lit_36);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DECLAREEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DECLAREEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DECLAREEx: ;

}
// $ANTLR end SQL92_RESERVED_DECLARE

//   Comes from: 519:5: ( 'DEFAULT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DEFAULT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DEFAULT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_DEFAULT()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_DEFAULT;


    // PLSQLLexer.g:519:5: ( 'DEFAULT' )
    // PLSQLLexer.g:519:10: 'DEFAULT'
    {
        this->matchs(lit_37);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DEFAULTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DEFAULTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DEFAULTEx: ;

}
// $ANTLR end SQL92_RESERVED_DEFAULT

//   Comes from: 523:5: ( 'DELETE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DELETE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DELETE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_DELETE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_DELETE;


    // PLSQLLexer.g:523:5: ( 'DELETE' )
    // PLSQLLexer.g:523:10: 'DELETE'
    {
        this->matchs(lit_38);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DELETEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DELETEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DELETEEx: ;

}
// $ANTLR end SQL92_RESERVED_DELETE

//   Comes from: 527:5: ( 'DESC' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DESC
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DESC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_DESC()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_DESC;


    // PLSQLLexer.g:527:5: ( 'DESC' )
    // PLSQLLexer.g:527:10: 'DESC'
    {
        this->matchs(lit_39);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DESCEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DESCEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DESCEx: ;

}
// $ANTLR end SQL92_RESERVED_DESC

//   Comes from: 531:5: ( 'DISTINCT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DISTINCT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DISTINCT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_DISTINCT()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_DISTINCT;


    // PLSQLLexer.g:531:5: ( 'DISTINCT' )
    // PLSQLLexer.g:531:10: 'DISTINCT'
    {
        this->matchs(lit_40);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DISTINCTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DISTINCTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DISTINCTEx: ;

}
// $ANTLR end SQL92_RESERVED_DISTINCT

//   Comes from: 535:5: ( 'DROP' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DROP
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DROP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_DROP()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_DROP;


    // PLSQLLexer.g:535:5: ( 'DROP' )
    // PLSQLLexer.g:535:10: 'DROP'
    {
        this->matchs(lit_41);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DROPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DROPEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DROPEx: ;

}
// $ANTLR end SQL92_RESERVED_DROP

//   Comes from: 539:5: ( 'ELSE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ELSE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ELSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_ELSE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_ELSE;


    // PLSQLLexer.g:539:5: ( 'ELSE' )
    // PLSQLLexer.g:539:10: 'ELSE'
    {
        this->matchs(lit_42);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ELSEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ELSEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ELSEEx: ;

}
// $ANTLR end SQL92_RESERVED_ELSE

//   Comes from: 543:5: ( 'END' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_END
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_END
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_END()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_END;


    // PLSQLLexer.g:543:5: ( 'END' )
    // PLSQLLexer.g:543:10: 'END'
    {
        this->matchs(lit_43);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ENDEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ENDEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ENDEx: ;

}
// $ANTLR end SQL92_RESERVED_END

//   Comes from: 550:5: ( 'EXCEPTION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_EXCEPTION
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_EXCEPTION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_EXCEPTION()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_EXCEPTION;


    // PLSQLLexer.g:550:5: ( 'EXCEPTION' )
    // PLSQLLexer.g:550:10: 'EXCEPTION'
    {
        this->matchs(lit_44);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_EXCEPTIONEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_EXCEPTIONEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_EXCEPTIONEx: ;

}
// $ANTLR end SQL92_RESERVED_EXCEPTION

//   Comes from: 606:5: ( 'EXCLUSIVE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_EXCLUSIVE
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_EXCLUSIVE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_EXCLUSIVE()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_EXCLUSIVE;


    // PLSQLLexer.g:606:5: ( 'EXCLUSIVE' )
    // PLSQLLexer.g:606:10: 'EXCLUSIVE'
    {
        this->matchs(lit_45);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_EXCLUSIVEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_EXCLUSIVEEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_EXCLUSIVEEx: ;

}
// $ANTLR end PLSQL_RESERVED_EXCLUSIVE

//   Comes from: 610:5: ( 'EXISTS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_EXISTS
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_EXISTS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_EXISTS()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_EXISTS;


    // PLSQLLexer.g:610:5: ( 'EXISTS' )
    // PLSQLLexer.g:610:10: 'EXISTS'
    {
        this->matchs(lit_46);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_EXISTSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_EXISTSEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_EXISTSEx: ;

}
// $ANTLR end SQL92_RESERVED_EXISTS

//   Comes from: 614:5: ( 'FALSE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_FALSE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_FALSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_FALSE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_FALSE;


    // PLSQLLexer.g:614:5: ( 'FALSE' )
    // PLSQLLexer.g:614:10: 'FALSE'
    {
        this->matchs(lit_47);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_FALSEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_FALSEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_FALSEEx: ;

}
// $ANTLR end SQL92_RESERVED_FALSE

//   Comes from: 618:5: ( 'FETCH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_FETCH
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_FETCH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_FETCH()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_FETCH;


    // PLSQLLexer.g:618:5: ( 'FETCH' )
    // PLSQLLexer.g:618:10: 'FETCH'
    {
        this->matchs(lit_48);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_FETCHEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_FETCHEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_FETCHEx: ;

}
// $ANTLR end SQL92_RESERVED_FETCH

//   Comes from: 622:5: ( 'FOR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_FOR
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_FOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_FOR()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_FOR;


    // PLSQLLexer.g:622:5: ( 'FOR' )
    // PLSQLLexer.g:622:10: 'FOR'
    {
        this->matchs(lit_49);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_FOREx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_FOREx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_FOREx: ;

}
// $ANTLR end SQL92_RESERVED_FOR

//   Comes from: 626:5: ( 'FROM' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_FROM
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_FROM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_FROM()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_FROM;


    // PLSQLLexer.g:626:5: ( 'FROM' )
    // PLSQLLexer.g:626:10: 'FROM'
    {
        this->matchs(lit_50);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_FROMEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_FROMEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_FROMEx: ;

}
// $ANTLR end SQL92_RESERVED_FROM

//   Comes from: 630:5: ( 'GOTO' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_GOTO
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_GOTO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_GOTO()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_GOTO;


    // PLSQLLexer.g:630:5: ( 'GOTO' )
    // PLSQLLexer.g:630:10: 'GOTO'
    {
        this->matchs(lit_51);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_GOTOEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_GOTOEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_GOTOEx: ;

}
// $ANTLR end SQL92_RESERVED_GOTO

//   Comes from: 634:5: ( 'GRANT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_GRANT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_GRANT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_GRANT()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_GRANT;


    // PLSQLLexer.g:634:5: ( 'GRANT' )
    // PLSQLLexer.g:634:10: 'GRANT'
    {
        this->matchs(lit_52);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_GRANTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_GRANTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_GRANTEx: ;

}
// $ANTLR end SQL92_RESERVED_GRANT

//   Comes from: 638:5: ( 'GROUP' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_GROUP
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_GROUP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_GROUP()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_GROUP;


    // PLSQLLexer.g:638:5: ( 'GROUP' )
    // PLSQLLexer.g:638:10: 'GROUP'
    {
        this->matchs(lit_53);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_GROUPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_GROUPEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_GROUPEx: ;

}
// $ANTLR end SQL92_RESERVED_GROUP

//   Comes from: 642:5: ( 'HAVING' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_HAVING
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_HAVING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_HAVING()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_HAVING;


    // PLSQLLexer.g:642:5: ( 'HAVING' )
    // PLSQLLexer.g:642:10: 'HAVING'
    {
        this->matchs(lit_54);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_HAVINGEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_HAVINGEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_HAVINGEx: ;

}
// $ANTLR end SQL92_RESERVED_HAVING

//   Comes from: 646:5: ( 'IDENTIFIED' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_IDENTIFIED
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_IDENTIFIED
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_IDENTIFIED()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_IDENTIFIED;


    // PLSQLLexer.g:646:5: ( 'IDENTIFIED' )
    // PLSQLLexer.g:646:10: 'IDENTIFIED'
    {
        this->matchs(lit_55);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_IDENTIFIEDEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_IDENTIFIEDEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_IDENTIFIEDEx: ;

}
// $ANTLR end PLSQL_RESERVED_IDENTIFIED

//   Comes from: 650:5: ( 'IF' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_IF
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_IF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_IF()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_IF;


    // PLSQLLexer.g:650:5: ( 'IF' )
    // PLSQLLexer.g:650:10: 'IF'
    {
        this->matchs(lit_56);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_IFEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_IFEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_IFEx: ;

}
// $ANTLR end PLSQL_RESERVED_IF

//   Comes from: 654:5: ( 'IN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_IN
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_IN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_IN()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_IN;


    // PLSQLLexer.g:654:5: ( 'IN' )
    // PLSQLLexer.g:654:10: 'IN'
    {
        this->matchs(lit_57);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_INEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_INEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_INEx: ;

}
// $ANTLR end SQL92_RESERVED_IN

//   Comes from: 658:5: ( 'INDEX' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_INDEX
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_INDEX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_INDEX()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_INDEX;


    // PLSQLLexer.g:658:5: ( 'INDEX' )
    // PLSQLLexer.g:658:10: 'INDEX'
    {
        this->matchs(lit_58);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_INDEXEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_INDEXEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_INDEXEx: ;

}
// $ANTLR end PLSQL_RESERVED_INDEX

//   Comes from: 662:5: ( 'INDEXES' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_INDEXES
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_INDEXES
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_INDEXES()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_INDEXES;


    // PLSQLLexer.g:662:5: ( 'INDEXES' )
    // PLSQLLexer.g:662:10: 'INDEXES'
    {
        this->matchs(lit_59);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_INDEXESEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_INDEXESEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_INDEXESEx: ;

}
// $ANTLR end PLSQL_RESERVED_INDEXES

//   Comes from: 666:5: ( 'INSERT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_INSERT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_INSERT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_INSERT()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_INSERT;


    // PLSQLLexer.g:666:5: ( 'INSERT' )
    // PLSQLLexer.g:666:10: 'INSERT'
    {
        this->matchs(lit_60);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_INSERTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_INSERTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_INSERTEx: ;

}
// $ANTLR end SQL92_RESERVED_INSERT

//   Comes from: 670:5: ( 'INTERSECT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_INTERSECT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_INTERSECT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_INTERSECT()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_INTERSECT;


    // PLSQLLexer.g:670:5: ( 'INTERSECT' )
    // PLSQLLexer.g:670:10: 'INTERSECT'
    {
        this->matchs(lit_61);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_INTERSECTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_INTERSECTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_INTERSECTEx: ;

}
// $ANTLR end SQL92_RESERVED_INTERSECT

//   Comes from: 674:5: ( 'INTO' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_INTO
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_INTO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_INTO()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_INTO;


    // PLSQLLexer.g:674:5: ( 'INTO' )
    // PLSQLLexer.g:674:10: 'INTO'
    {
        this->matchs(lit_62);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_INTOEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_INTOEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_INTOEx: ;

}
// $ANTLR end SQL92_RESERVED_INTO

//   Comes from: 678:5: ( 'IS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_IS
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_IS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_IS()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_IS;


    // PLSQLLexer.g:678:5: ( 'IS' )
    // PLSQLLexer.g:678:10: 'IS'
    {
        this->matchs(lit_63);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ISEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ISEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ISEx: ;

}
// $ANTLR end SQL92_RESERVED_IS

//   Comes from: 682:5: ( 'LIKE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_LIKE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_LIKE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_LIKE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_LIKE;


    // PLSQLLexer.g:682:5: ( 'LIKE' )
    // PLSQLLexer.g:682:10: 'LIKE'
    {
        this->matchs(lit_64);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_LIKEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_LIKEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_LIKEEx: ;

}
// $ANTLR end SQL92_RESERVED_LIKE

//   Comes from: 686:5: ( 'LOCK' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_LOCK
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_LOCK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_LOCK()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_LOCK;


    // PLSQLLexer.g:686:5: ( 'LOCK' )
    // PLSQLLexer.g:686:10: 'LOCK'
    {
        this->matchs(lit_65);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_LOCKEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_LOCKEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_LOCKEx: ;

}
// $ANTLR end PLSQL_RESERVED_LOCK

//   Comes from: 690:5: ( 'MINUS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_MINUS
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_MINUS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_MINUS()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_MINUS;


    // PLSQLLexer.g:690:5: ( 'MINUS' )
    // PLSQLLexer.g:690:10: 'MINUS'
    {
        this->matchs(lit_66);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_MINUSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_MINUSEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_MINUSEx: ;

}
// $ANTLR end PLSQL_RESERVED_MINUS

//   Comes from: 694:5: ( 'MODE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_MODE
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_MODE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_MODE()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_MODE;


    // PLSQLLexer.g:694:5: ( 'MODE' )
    // PLSQLLexer.g:694:10: 'MODE'
    {
        this->matchs(lit_67);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_MODEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_MODEEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_MODEEx: ;

}
// $ANTLR end PLSQL_RESERVED_MODE

//   Comes from: 698:5: ( 'NOCOMPRESS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_NOCOMPRESS
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_NOCOMPRESS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_NOCOMPRESS()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_NOCOMPRESS;


    // PLSQLLexer.g:698:5: ( 'NOCOMPRESS' )
    // PLSQLLexer.g:698:10: 'NOCOMPRESS'
    {
        this->matchs(lit_68);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_NOCOMPRESSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_NOCOMPRESSEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_NOCOMPRESSEx: ;

}
// $ANTLR end PLSQL_RESERVED_NOCOMPRESS

//   Comes from: 702:5: ( 'NOT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_NOT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_NOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_NOT()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_NOT;


    // PLSQLLexer.g:702:5: ( 'NOT' )
    // PLSQLLexer.g:702:10: 'NOT'
    {
        this->matchs(lit_69);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_NOTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_NOTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_NOTEx: ;

}
// $ANTLR end SQL92_RESERVED_NOT

//   Comes from: 706:5: ( 'NOWAIT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_NOWAIT
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_NOWAIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_NOWAIT()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_NOWAIT;


    // PLSQLLexer.g:706:5: ( 'NOWAIT' )
    // PLSQLLexer.g:706:10: 'NOWAIT'
    {
        this->matchs(lit_70);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_NOWAITEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_NOWAITEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_NOWAITEx: ;

}
// $ANTLR end PLSQL_RESERVED_NOWAIT

//   Comes from: 710:5: ( 'NULL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_NULL
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_NULL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_NULL()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_NULL;


    // PLSQLLexer.g:710:5: ( 'NULL' )
    // PLSQLLexer.g:710:10: 'NULL'
    {
        this->matchs(lit_71);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_NULLEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_NULLEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_NULLEx: ;

}
// $ANTLR end SQL92_RESERVED_NULL

//   Comes from: 714:5: ( 'OF' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_OF
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_OF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_OF()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_OF;


    // PLSQLLexer.g:714:5: ( 'OF' )
    // PLSQLLexer.g:714:10: 'OF'
    {
        this->matchs(lit_72);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_OFEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_OFEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_OFEx: ;

}
// $ANTLR end SQL92_RESERVED_OF

//   Comes from: 718:5: ( 'ON' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ON
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ON
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_ON()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_ON;


    // PLSQLLexer.g:718:5: ( 'ON' )
    // PLSQLLexer.g:718:10: 'ON'
    {
        this->matchs(lit_73);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ONEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ONEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ONEx: ;

}
// $ANTLR end SQL92_RESERVED_ON

//   Comes from: 722:5: ( 'OPTION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_OPTION
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_OPTION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_OPTION()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_OPTION;


    // PLSQLLexer.g:722:5: ( 'OPTION' )
    // PLSQLLexer.g:722:10: 'OPTION'
    {
        this->matchs(lit_74);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_OPTIONEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_OPTIONEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_OPTIONEx: ;

}
// $ANTLR end SQL92_RESERVED_OPTION

//   Comes from: 726:5: ( 'OR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_OR
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_OR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_OR()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_OR;


    // PLSQLLexer.g:726:5: ( 'OR' )
    // PLSQLLexer.g:726:10: 'OR'
    {
        this->matchs(lit_75);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_OREx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_OREx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_OREx: ;

}
// $ANTLR end SQL92_RESERVED_OR

//   Comes from: 730:5: ( 'ORDER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ORDER
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ORDER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_ORDER()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_ORDER;


    // PLSQLLexer.g:730:5: ( 'ORDER' )
    // PLSQLLexer.g:730:10: 'ORDER'
    {
        this->matchs(lit_76);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ORDEREx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ORDEREx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ORDEREx: ;

}
// $ANTLR end SQL92_RESERVED_ORDER

//   Comes from: 734:5: ( 'OVERLAPS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_OVERLAPS
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_OVERLAPS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_OVERLAPS()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_OVERLAPS;


    // PLSQLLexer.g:734:5: ( 'OVERLAPS' )
    // PLSQLLexer.g:734:10: 'OVERLAPS'
    {
        this->matchs(lit_77);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_OVERLAPSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_OVERLAPSEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_OVERLAPSEx: ;

}
// $ANTLR end SQL92_RESERVED_OVERLAPS

//   Comes from: 738:5: ( 'PRIOR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_PRIOR
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_PRIOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_PRIOR()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_PRIOR;


    // PLSQLLexer.g:738:5: ( 'PRIOR' )
    // PLSQLLexer.g:738:10: 'PRIOR'
    {
        this->matchs(lit_78);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_PRIOREx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_PRIOREx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_PRIOREx: ;

}
// $ANTLR end SQL92_RESERVED_PRIOR

//   Comes from: 742:5: ( 'PROCEDURE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_PROCEDURE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_PROCEDURE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_PROCEDURE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_PROCEDURE;


    // PLSQLLexer.g:742:5: ( 'PROCEDURE' )
    // PLSQLLexer.g:742:10: 'PROCEDURE'
    {
        this->matchs(lit_79);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_PROCEDUREEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_PROCEDUREEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_PROCEDUREEx: ;

}
// $ANTLR end SQL92_RESERVED_PROCEDURE

//   Comes from: 746:5: ( 'PUBLIC' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_PUBLIC
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_PUBLIC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_PUBLIC()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_PUBLIC;


    // PLSQLLexer.g:746:5: ( 'PUBLIC' )
    // PLSQLLexer.g:746:10: 'PUBLIC'
    {
        this->matchs(lit_80);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_PUBLICEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_PUBLICEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_PUBLICEx: ;

}
// $ANTLR end SQL92_RESERVED_PUBLIC

//   Comes from: 750:5: ( 'RESOURCE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_RESOURCE
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_RESOURCE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_RESOURCE()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_RESOURCE;


    // PLSQLLexer.g:750:5: ( 'RESOURCE' )
    // PLSQLLexer.g:750:10: 'RESOURCE'
    {
        this->matchs(lit_81);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_RESOURCEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_RESOURCEEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_RESOURCEEx: ;

}
// $ANTLR end PLSQL_RESERVED_RESOURCE

//   Comes from: 754:5: ( 'REVOKE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_REVOKE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_REVOKE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_REVOKE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_REVOKE;


    // PLSQLLexer.g:754:5: ( 'REVOKE' )
    // PLSQLLexer.g:754:10: 'REVOKE'
    {
        this->matchs(lit_82);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_REVOKEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_REVOKEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_REVOKEEx: ;

}
// $ANTLR end SQL92_RESERVED_REVOKE

//   Comes from: 758:5: ( 'SELECT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_SELECT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_SELECT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_SELECT()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_SELECT;


    // PLSQLLexer.g:758:5: ( 'SELECT' )
    // PLSQLLexer.g:758:10: 'SELECT'
    {
        this->matchs(lit_83);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_SELECTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_SELECTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_SELECTEx: ;

}
// $ANTLR end SQL92_RESERVED_SELECT

//   Comes from: 762:5: ( 'SHARE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_SHARE
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_SHARE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_SHARE()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_SHARE;


    // PLSQLLexer.g:762:5: ( 'SHARE' )
    // PLSQLLexer.g:762:10: 'SHARE'
    {
        this->matchs(lit_84);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_SHAREEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_SHAREEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_SHAREEx: ;

}
// $ANTLR end PLSQL_RESERVED_SHARE

//   Comes from: 766:5: ( 'SIZE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_SIZE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_SIZE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_SIZE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_SIZE;


    // PLSQLLexer.g:766:5: ( 'SIZE' )
    // PLSQLLexer.g:766:10: 'SIZE'
    {
        this->matchs(lit_85);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_SIZEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_SIZEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_SIZEEx: ;

}
// $ANTLR end SQL92_RESERVED_SIZE

//   Comes from: 774:5: ( 'START' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_START
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_START
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_START()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_START;


    // PLSQLLexer.g:774:5: ( 'START' )
    // PLSQLLexer.g:774:10: 'START'
    {
        this->matchs(lit_86);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_STARTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_STARTEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_STARTEx: ;

}
// $ANTLR end PLSQL_RESERVED_START

//   Comes from: 778:5: ( 'TABAUTH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_TABAUTH
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_TABAUTH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_TABAUTH()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_TABAUTH;


    // PLSQLLexer.g:778:5: ( 'TABAUTH' )
    // PLSQLLexer.g:778:10: 'TABAUTH'
    {
        this->matchs(lit_87);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_TABAUTHEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_TABAUTHEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_TABAUTHEx: ;

}
// $ANTLR end PLSQL_RESERVED_TABAUTH

//   Comes from: 782:5: ( 'TABLE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_TABLE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_TABLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_TABLE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_TABLE;


    // PLSQLLexer.g:782:5: ( 'TABLE' )
    // PLSQLLexer.g:782:10: 'TABLE'
    {
        this->matchs(lit_88);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_TABLEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_TABLEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_TABLEEx: ;

}
// $ANTLR end SQL92_RESERVED_TABLE

//   Comes from: 786:5: ( 'THE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_THE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_THE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_THE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_THE;


    // PLSQLLexer.g:786:5: ( 'THE' )
    // PLSQLLexer.g:786:10: 'THE'
    {
        this->matchs(lit_89);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_THEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_THEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_THEEx: ;

}
// $ANTLR end SQL92_RESERVED_THE

//   Comes from: 790:5: ( 'THEN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_THEN
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_THEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_THEN()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_THEN;


    // PLSQLLexer.g:790:5: ( 'THEN' )
    // PLSQLLexer.g:790:10: 'THEN'
    {
        this->matchs(lit_90);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_THENEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_THENEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_THENEx: ;

}
// $ANTLR end SQL92_RESERVED_THEN

//   Comes from: 794:5: ( 'TO' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_TO
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_TO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_TO()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_TO;


    // PLSQLLexer.g:794:5: ( 'TO' )
    // PLSQLLexer.g:794:10: 'TO'
    {
        this->matchs(lit_91);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_TOEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_TOEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_TOEx: ;

}
// $ANTLR end SQL92_RESERVED_TO

//   Comes from: 798:5: ( 'TRUE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_TRUE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_TRUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_TRUE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_TRUE;


    // PLSQLLexer.g:798:5: ( 'TRUE' )
    // PLSQLLexer.g:798:10: 'TRUE'
    {
        this->matchs(lit_92);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_TRUEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_TRUEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_TRUEEx: ;

}
// $ANTLR end SQL92_RESERVED_TRUE

//   Comes from: 802:5: ( 'UNION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_UNION
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_UNION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_UNION()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_UNION;


    // PLSQLLexer.g:802:5: ( 'UNION' )
    // PLSQLLexer.g:802:10: 'UNION'
    {
        this->matchs(lit_93);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_UNIONEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_UNIONEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_UNIONEx: ;

}
// $ANTLR end SQL92_RESERVED_UNION

//   Comes from: 806:5: ( 'UNIQUE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_UNIQUE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_UNIQUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_UNIQUE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_UNIQUE;


    // PLSQLLexer.g:806:5: ( 'UNIQUE' )
    // PLSQLLexer.g:806:10: 'UNIQUE'
    {
        this->matchs(lit_94);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_UNIQUEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_UNIQUEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_UNIQUEEx: ;

}
// $ANTLR end SQL92_RESERVED_UNIQUE

//   Comes from: 810:5: ( 'UPDATE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_UPDATE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_UPDATE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_UPDATE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_UPDATE;


    // PLSQLLexer.g:810:5: ( 'UPDATE' )
    // PLSQLLexer.g:810:10: 'UPDATE'
    {
        this->matchs(lit_95);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_UPDATEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_UPDATEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_UPDATEEx: ;

}
// $ANTLR end SQL92_RESERVED_UPDATE

//   Comes from: 814:5: ( 'VALUES' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_VALUES
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_VALUES
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_VALUES()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_VALUES;


    // PLSQLLexer.g:814:5: ( 'VALUES' )
    // PLSQLLexer.g:814:10: 'VALUES'
    {
        this->matchs(lit_96);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_VALUESEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_VALUESEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_VALUESEx: ;

}
// $ANTLR end SQL92_RESERVED_VALUES

//   Comes from: 818:5: ( 'VIEW' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_VIEW
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_VIEW
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_VIEW()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_VIEW;


    // PLSQLLexer.g:818:5: ( 'VIEW' )
    // PLSQLLexer.g:818:10: 'VIEW'
    {
        this->matchs(lit_97);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_VIEWEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_VIEWEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_VIEWEx: ;

}
// $ANTLR end SQL92_RESERVED_VIEW

//   Comes from: 822:5: ( 'VIEWS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_VIEWS
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_VIEWS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_VIEWS()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_RESERVED_VIEWS;


    // PLSQLLexer.g:822:5: ( 'VIEWS' )
    // PLSQLLexer.g:822:10: 'VIEWS'
    {
        this->matchs(lit_98);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_VIEWSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_VIEWSEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_VIEWSEx: ;

}
// $ANTLR end PLSQL_RESERVED_VIEWS

//   Comes from: 826:5: ( 'WHEN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_WHEN
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_WHEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_WHEN()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_WHEN;


    // PLSQLLexer.g:826:5: ( 'WHEN' )
    // PLSQLLexer.g:826:10: 'WHEN'
    {
        this->matchs(lit_99);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_WHENEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_WHENEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_WHENEx: ;

}
// $ANTLR end SQL92_RESERVED_WHEN

//   Comes from: 830:5: ( 'WHERE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_WHERE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_WHERE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_WHERE()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_WHERE;


    // PLSQLLexer.g:830:5: ( 'WHERE' )
    // PLSQLLexer.g:830:10: 'WHERE'
    {
        this->matchs(lit_100);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_WHEREEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_WHEREEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_WHEREEx: ;

}
// $ANTLR end SQL92_RESERVED_WHERE

//   Comes from: 834:5: ( 'WITH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_WITH
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_WITH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_WITH()
{
    ANTLR_UINT32	_type;
      

    _type	    = SQL92_RESERVED_WITH;


    // PLSQLLexer.g:834:5: ( 'WITH' )
    // PLSQLLexer.g:834:10: 'WITH'
    {
        this->matchs(lit_101);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_WITHEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_WITHEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_WITHEx: ;

}
// $ANTLR end SQL92_RESERVED_WITH

//   Comes from: 838:5: ( 'USING' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_USING
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_USING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_NON_RESERVED_USING()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_NON_RESERVED_USING;


    // PLSQLLexer.g:838:5: ( 'USING' )
    // PLSQLLexer.g:838:10: 'USING'
    {
        this->matchs(lit_102);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_USINGEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_USINGEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_USINGEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_USING

//   Comes from: 842:5: ( 'MODEL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_MODEL
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_MODEL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_NON_RESERVED_MODEL()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_NON_RESERVED_MODEL;


    // PLSQLLexer.g:842:5: ( 'MODEL' )
    // PLSQLLexer.g:842:10: 'MODEL'
    {
        this->matchs(lit_103);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_MODELEx;
        }




        {

                     // "MODEL" is a keyword if and only if it is followed by ("main"|"partition"|"dimension")
                     // otherwise it is a identifier(REGULAR_ID).
                     // This wodoo implements something like context sensitive lexer.
                     // Here we've matched the word "model". Then the Token is created and en-queued in tokenBuffer
                     // We still remember the reference(m) onto this Token
                     _type = PLSQL_NON_RESERVED_MODEL;
                     // emit(m);
                     // advanceInput();

                     // _type = Token.INVALID_TOKEN_TYPE;
                     // int markModel = input.mark();

                     // // Now loop over next Tokens in the input and eventually set Token's type to REGULAR_ID

                     // // Subclassed version will return NULL unless EOF is reached.
                     // // nextToken either returns NULL => then the next token is put into the queue tokenBuffer
                     // // or it returns Token.EOF, then nothing is put into the queue
                     // Token t1 = super.nextToken();
                     // {    // This "if" handles the situation when the "model" is the last text in the input.
                     //      if( t1 != null && t1.getType() == Token.EOF)
                     //      {
                     //          $m.set_type(REGULAR_ID);
                     //      } else {
                     //          t1 = tokenBuffer.pollLast(); // "withdraw" the next token from the queue
                     //          while(true)
                     //          {
                     //             if(t1.getType() == EOF)   // is it EOF?
                     //             {
                     //                 $m.set_type(REGULAR_ID);
                     //                 break;
                     //             }

                     //             if(t1.getChannel() == HIDDEN) // is it a white space? then advance to the next token
                     //             {
                     //                 t1 = super.nextToken(); if( t1 == null) { t1 = tokenBuffer.pollLast(); };
                     //                 continue;
                     //             }

                     //             if( t1.getType() != REGULAR_ID || // is something other than ("main"|"partition"|"dimension")
                     //                ( !t1.getText().equalsIgnoreCase("main") &&
                     //                  !t1.getText().equalsIgnoreCase("partition") &&
                     //                  !t1.getText().equalsIgnoreCase("dimension")
                     //               ))
                     //             {
                     //                 $m.set_type(REGULAR_ID);
                     //                 break;
                     //             }

                     //             break; // we are in the model_clase do not rewrite anything
                     //          } // while true
                     //      } // else if( t1 != null && t1.getType() == Token.EOF)
                     // }
                     // input.rewind(markModel);
                
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_MODELEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_MODELEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_MODEL

//   Comes from: 901:5: ( 'ELSIF' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_ELSIF
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_ELSIF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_NON_RESERVED_ELSIF()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_NON_RESERVED_ELSIF;


    // PLSQLLexer.g:901:5: ( 'ELSIF' )
    // PLSQLLexer.g:901:10: 'ELSIF'
    {
        this->matchs(lit_104);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_ELSIFEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_ELSIFEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_ELSIFEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_ELSIF

//   Comes from: 905:5: ( 'PIVOT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_PIVOT
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_PIVOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_NON_RESERVED_PIVOT()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_NON_RESERVED_PIVOT;


    // PLSQLLexer.g:905:5: ( 'PIVOT' )
    // PLSQLLexer.g:905:10: 'PIVOT'
    {
        this->matchs(lit_105);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_PIVOTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_PIVOTEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_PIVOTEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_PIVOT

//   Comes from: 909:5: ( 'UNPIVOT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_UNPIVOT
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_UNPIVOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_NON_RESERVED_UNPIVOT()
{
    ANTLR_UINT32	_type;
      

    _type	    = PLSQL_NON_RESERVED_UNPIVOT;


    // PLSQLLexer.g:909:5: ( 'UNPIVOT' )
    // PLSQLLexer.g:909:10: 'UNPIVOT'
    {
        this->matchs(lit_106);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_UNPIVOTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_UNPIVOTEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_UNPIVOTEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_UNPIVOT

//   Comes from: 913:5: ( ( SIMPLE_LETTER ) ( SIMPLE_LETTER | '$' | '_' | '#' | '0' .. '9' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REGULAR_ID
 *
 * Looks to match the characters the constitute the token REGULAR_ID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mREGULAR_ID()
{
    ANTLR_UINT32	_type;
      

    _type	    = REGULAR_ID;


    // PLSQLLexer.g:913:5: ( ( SIMPLE_LETTER ) ( SIMPLE_LETTER | '$' | '_' | '#' | '0' .. '9' )* )
    // PLSQLLexer.g:913:10: ( SIMPLE_LETTER ) ( SIMPLE_LETTER | '$' | '_' | '#' | '0' .. '9' )*
    {
        if ( ((this->LA(1) >= 'A') && (this->LA(1) <= 'Z')) || ((this->LA(1) >= 'a') && (this->LA(1) <= 'z')) )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleREGULAR_IDEx;
        }


        // PLSQLLexer.g:913:26: ( SIMPLE_LETTER | '$' | '_' | '#' | '0' .. '9' )*

        for (;;)
        {
            int alt39=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA39_0 = this->LA(1);
                if ( (((LA39_0 >= '#') && (LA39_0 <= '$')) || ((LA39_0 >= '0') && (LA39_0 <= '9')) || ((LA39_0 >= 'A') && (LA39_0 <= 'Z')) || LA39_0 == '_' || ((LA39_0 >= 'a') && (LA39_0 <= 'z'))))
                {
                    alt39=1;
                }

            }
            switch (alt39)
            {
        	case 1:
        	    // PLSQLLexer.g:
        	    {
        	        if ( ((this->LA(1) >= '#') && (this->LA(1) <= '$')) || ((this->LA(1) >= '0') && (this->LA(1) <= '9')) || ((this->LA(1) >= 'A') && (this->LA(1) <= 'Z')) || this->LA(1) == '_' || ((this->LA(1) >= 'a') && (this->LA(1) <= 'z')) )
        	        {
        	            this->consume();
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            this->recover();
        	            goto ruleREGULAR_IDEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop39;	/* break out of the loop */
        	    break;
            }
        }
        loop39: ; /* Jump out to here if this rule does not match */


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleREGULAR_IDEx; /* Prevent compiler warnings */
    ruleREGULAR_IDEx: ;

}
// $ANTLR end REGULAR_ID

//   Comes from: 917:5: ( '@!' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ZV
 *
 * Looks to match the characters the constitute the token ZV
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mZV()
{
    ANTLR_UINT32	_type;
      

    _type	    = ZV;


    // PLSQLLexer.g:917:5: ( '@!' )
    // PLSQLLexer.g:917:10: '@!'
    {
        this->matchs(lit_107);
        if  (this->hasException())
        {
            goto ruleZVEx;
        }




        {
            this->get_state()->get_channel()=HIDDEN;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleZVEx; /* Prevent compiler warnings */
    ruleZVEx: ;

}
// $ANTLR end ZV

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
void
PLSQLLexer::mTokens()
{
    {
        //  PLSQLLexer.g:1:8: ( FOR_NOTATION | NATIONAL_CHAR_STRING_LIT | BIT_STRING_LIT | HEX_STRING_LIT | PERIOD | EXACT_NUM_LIT | CHAR_STRING | CHAR_STRING_PERL | DELIMITED_ID | PERCENT | AMPERSAND | LEFT_PAREN | RIGHT_PAREN | DOUBLE_ASTERISK | ASTERISK | PLUS_SIGN | COMMA | SOLIDUS | AT_SIGN | ASSIGN_OP | BINDVAR | COLON | SEMICOLON | LESS_THAN_OR_EQUALS_OP | LESS_THAN_OP | GREATER_THAN_OR_EQUALS_OP | NOT_EQUAL_OP | CARRET_OPERATOR_PART | TILDE_OPERATOR_PART | EXCLAMATION_OPERATOR_PART | GREATER_THAN_OP | CONCATENATION_OP | VERTICAL_BAR | EQUALS_OP | LEFT_BRACKET | RIGHT_BRACKET | INTRODUCER | SEPARATOR | PROMPT | SQL92_RESERVED_ALL | SQL92_RESERVED_ALTER | SQL92_RESERVED_AND | SQL92_RESERVED_ANY | SQL92_RESERVED_AS | SQL92_RESERVED_ASC | SQL92_RESERVED_BEGIN | SQL92_RESERVED_BETWEEN | SQL92_RESERVED_BY | SQL92_RESERVED_CASE | SQL92_RESERVED_CHECK | PLSQL_RESERVED_CLUSTERS | PLSQL_RESERVED_COLAUTH | PLSQL_RESERVED_COMPRESS | SQL92_RESERVED_CONNECT | PLSQL_NON_RESERVED_CONNECT_BY_ROOT | PLSQL_RESERVED_CRASH | SQL92_RESERVED_CREATE | SQL92_RESERVED_CURRENT | SQL92_RESERVED_CURSOR | SQL92_RESERVED_DATE | SQL92_RESERVED_DECLARE | SQL92_RESERVED_DEFAULT | SQL92_RESERVED_DELETE | SQL92_RESERVED_DESC | SQL92_RESERVED_DISTINCT | SQL92_RESERVED_DROP | SQL92_RESERVED_ELSE | SQL92_RESERVED_END | SQL92_RESERVED_EXCEPTION | PLSQL_RESERVED_EXCLUSIVE | SQL92_RESERVED_EXISTS | SQL92_RESERVED_FALSE | SQL92_RESERVED_FETCH | SQL92_RESERVED_FOR | SQL92_RESERVED_FROM | SQL92_RESERVED_GOTO | SQL92_RESERVED_GRANT | SQL92_RESERVED_GROUP | SQL92_RESERVED_HAVING | PLSQL_RESERVED_IDENTIFIED | PLSQL_RESERVED_IF | SQL92_RESERVED_IN | PLSQL_RESERVED_INDEX | PLSQL_RESERVED_INDEXES | SQL92_RESERVED_INSERT | SQL92_RESERVED_INTERSECT | SQL92_RESERVED_INTO | SQL92_RESERVED_IS | SQL92_RESERVED_LIKE | PLSQL_RESERVED_LOCK | PLSQL_RESERVED_MINUS | PLSQL_RESERVED_MODE | PLSQL_RESERVED_NOCOMPRESS | SQL92_RESERVED_NOT | PLSQL_RESERVED_NOWAIT | SQL92_RESERVED_NULL | SQL92_RESERVED_OF | SQL92_RESERVED_ON | SQL92_RESERVED_OPTION | SQL92_RESERVED_OR | SQL92_RESERVED_ORDER | SQL92_RESERVED_OVERLAPS | SQL92_RESERVED_PRIOR | SQL92_RESERVED_PROCEDURE | SQL92_RESERVED_PUBLIC | PLSQL_RESERVED_RESOURCE | SQL92_RESERVED_REVOKE | SQL92_RESERVED_SELECT | PLSQL_RESERVED_SHARE | SQL92_RESERVED_SIZE | PLSQL_RESERVED_START | PLSQL_RESERVED_TABAUTH | SQL92_RESERVED_TABLE | SQL92_RESERVED_THE | SQL92_RESERVED_THEN | SQL92_RESERVED_TO | SQL92_RESERVED_TRUE | SQL92_RESERVED_UNION | SQL92_RESERVED_UNIQUE | SQL92_RESERVED_UPDATE | SQL92_RESERVED_VALUES | SQL92_RESERVED_VIEW | PLSQL_RESERVED_VIEWS | SQL92_RESERVED_WHEN | SQL92_RESERVED_WHERE | SQL92_RESERVED_WITH | PLSQL_NON_RESERVED_USING | PLSQL_NON_RESERVED_MODEL | PLSQL_NON_RESERVED_ELSIF | PLSQL_NON_RESERVED_PIVOT | PLSQL_NON_RESERVED_UNPIVOT | REGULAR_ID | ZV )

        ANTLR_UINT32 alt40;

        alt40=133;

        alt40 = cdfa40.predict(this, this->get_rec(), this->get_istream(), cdfa40 );
        if  (this->hasException())
        {
            goto ruleTokensEx;
        }

        switch (alt40)
        {
    	case 1:
    	    // PLSQLLexer.g:1:10: FOR_NOTATION
    	    {
    	        /* 1:10: FOR_NOTATION */
    	        mFOR_NOTATION();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 2:
    	    // PLSQLLexer.g:1:23: NATIONAL_CHAR_STRING_LIT
    	    {
    	        /* 1:23: NATIONAL_CHAR_STRING_LIT */
    	        mNATIONAL_CHAR_STRING_LIT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 3:
    	    // PLSQLLexer.g:1:48: BIT_STRING_LIT
    	    {
    	        /* 1:48: BIT_STRING_LIT */
    	        mBIT_STRING_LIT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 4:
    	    // PLSQLLexer.g:1:63: HEX_STRING_LIT
    	    {
    	        /* 1:63: HEX_STRING_LIT */
    	        mHEX_STRING_LIT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 5:
    	    // PLSQLLexer.g:1:78: PERIOD
    	    {
    	        /* 1:78: PERIOD */
    	        mPERIOD();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 6:
    	    // PLSQLLexer.g:1:85: EXACT_NUM_LIT
    	    {
    	        /* 1:85: EXACT_NUM_LIT */
    	        mEXACT_NUM_LIT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 7:
    	    // PLSQLLexer.g:1:99: CHAR_STRING
    	    {
    	        /* 1:99: CHAR_STRING */
    	        mCHAR_STRING();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 8:
    	    // PLSQLLexer.g:1:111: CHAR_STRING_PERL
    	    {
    	        /* 1:111: CHAR_STRING_PERL */
    	        mCHAR_STRING_PERL();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 9:
    	    // PLSQLLexer.g:1:128: DELIMITED_ID
    	    {
    	        /* 1:128: DELIMITED_ID */
    	        mDELIMITED_ID();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 10:
    	    // PLSQLLexer.g:1:141: PERCENT
    	    {
    	        /* 1:141: PERCENT */
    	        mPERCENT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 11:
    	    // PLSQLLexer.g:1:149: AMPERSAND
    	    {
    	        /* 1:149: AMPERSAND */
    	        mAMPERSAND();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 12:
    	    // PLSQLLexer.g:1:159: LEFT_PAREN
    	    {
    	        /* 1:159: LEFT_PAREN */
    	        mLEFT_PAREN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 13:
    	    // PLSQLLexer.g:1:170: RIGHT_PAREN
    	    {
    	        /* 1:170: RIGHT_PAREN */
    	        mRIGHT_PAREN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 14:
    	    // PLSQLLexer.g:1:182: DOUBLE_ASTERISK
    	    {
    	        /* 1:182: DOUBLE_ASTERISK */
    	        mDOUBLE_ASTERISK();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 15:
    	    // PLSQLLexer.g:1:198: ASTERISK
    	    {
    	        /* 1:198: ASTERISK */
    	        mASTERISK();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 16:
    	    // PLSQLLexer.g:1:207: PLUS_SIGN
    	    {
    	        /* 1:207: PLUS_SIGN */
    	        mPLUS_SIGN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 17:
    	    // PLSQLLexer.g:1:217: COMMA
    	    {
    	        /* 1:217: COMMA */
    	        mCOMMA();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 18:
    	    // PLSQLLexer.g:1:223: SOLIDUS
    	    {
    	        /* 1:223: SOLIDUS */
    	        mSOLIDUS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 19:
    	    // PLSQLLexer.g:1:231: AT_SIGN
    	    {
    	        /* 1:231: AT_SIGN */
    	        mAT_SIGN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 20:
    	    // PLSQLLexer.g:1:239: ASSIGN_OP
    	    {
    	        /* 1:239: ASSIGN_OP */
    	        mASSIGN_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 21:
    	    // PLSQLLexer.g:1:249: BINDVAR
    	    {
    	        /* 1:249: BINDVAR */
    	        mBINDVAR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 22:
    	    // PLSQLLexer.g:1:257: COLON
    	    {
    	        /* 1:257: COLON */
    	        mCOLON();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 23:
    	    // PLSQLLexer.g:1:263: SEMICOLON
    	    {
    	        /* 1:263: SEMICOLON */
    	        mSEMICOLON();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 24:
    	    // PLSQLLexer.g:1:273: LESS_THAN_OR_EQUALS_OP
    	    {
    	        /* 1:273: LESS_THAN_OR_EQUALS_OP */
    	        mLESS_THAN_OR_EQUALS_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 25:
    	    // PLSQLLexer.g:1:296: LESS_THAN_OP
    	    {
    	        /* 1:296: LESS_THAN_OP */
    	        mLESS_THAN_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 26:
    	    // PLSQLLexer.g:1:309: GREATER_THAN_OR_EQUALS_OP
    	    {
    	        /* 1:309: GREATER_THAN_OR_EQUALS_OP */
    	        mGREATER_THAN_OR_EQUALS_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 27:
    	    // PLSQLLexer.g:1:335: NOT_EQUAL_OP
    	    {
    	        /* 1:335: NOT_EQUAL_OP */
    	        mNOT_EQUAL_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 28:
    	    // PLSQLLexer.g:1:348: CARRET_OPERATOR_PART
    	    {
    	        /* 1:348: CARRET_OPERATOR_PART */
    	        mCARRET_OPERATOR_PART();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 29:
    	    // PLSQLLexer.g:1:369: TILDE_OPERATOR_PART
    	    {
    	        /* 1:369: TILDE_OPERATOR_PART */
    	        mTILDE_OPERATOR_PART();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 30:
    	    // PLSQLLexer.g:1:389: EXCLAMATION_OPERATOR_PART
    	    {
    	        /* 1:389: EXCLAMATION_OPERATOR_PART */
    	        mEXCLAMATION_OPERATOR_PART();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 31:
    	    // PLSQLLexer.g:1:415: GREATER_THAN_OP
    	    {
    	        /* 1:415: GREATER_THAN_OP */
    	        mGREATER_THAN_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 32:
    	    // PLSQLLexer.g:1:431: CONCATENATION_OP
    	    {
    	        /* 1:431: CONCATENATION_OP */
    	        mCONCATENATION_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 33:
    	    // PLSQLLexer.g:1:448: VERTICAL_BAR
    	    {
    	        /* 1:448: VERTICAL_BAR */
    	        mVERTICAL_BAR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 34:
    	    // PLSQLLexer.g:1:461: EQUALS_OP
    	    {
    	        /* 1:461: EQUALS_OP */
    	        mEQUALS_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 35:
    	    // PLSQLLexer.g:1:471: LEFT_BRACKET
    	    {
    	        /* 1:471: LEFT_BRACKET */
    	        mLEFT_BRACKET();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 36:
    	    // PLSQLLexer.g:1:484: RIGHT_BRACKET
    	    {
    	        /* 1:484: RIGHT_BRACKET */
    	        mRIGHT_BRACKET();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 37:
    	    // PLSQLLexer.g:1:498: INTRODUCER
    	    {
    	        /* 1:498: INTRODUCER */
    	        mINTRODUCER();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 38:
    	    // PLSQLLexer.g:1:509: SEPARATOR
    	    {
    	        /* 1:509: SEPARATOR */
    	        mSEPARATOR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 39:
    	    // PLSQLLexer.g:1:519: PROMPT
    	    {
    	        /* 1:519: PROMPT */
    	        mPROMPT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 40:
    	    // PLSQLLexer.g:1:526: SQL92_RESERVED_ALL
    	    {
    	        /* 1:526: SQL92_RESERVED_ALL */
    	        mSQL92_RESERVED_ALL();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 41:
    	    // PLSQLLexer.g:1:545: SQL92_RESERVED_ALTER
    	    {
    	        /* 1:545: SQL92_RESERVED_ALTER */
    	        mSQL92_RESERVED_ALTER();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 42:
    	    // PLSQLLexer.g:1:566: SQL92_RESERVED_AND
    	    {
    	        /* 1:566: SQL92_RESERVED_AND */
    	        mSQL92_RESERVED_AND();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 43:
    	    // PLSQLLexer.g:1:585: SQL92_RESERVED_ANY
    	    {
    	        /* 1:585: SQL92_RESERVED_ANY */
    	        mSQL92_RESERVED_ANY();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 44:
    	    // PLSQLLexer.g:1:604: SQL92_RESERVED_AS
    	    {
    	        /* 1:604: SQL92_RESERVED_AS */
    	        mSQL92_RESERVED_AS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 45:
    	    // PLSQLLexer.g:1:622: SQL92_RESERVED_ASC
    	    {
    	        /* 1:622: SQL92_RESERVED_ASC */
    	        mSQL92_RESERVED_ASC();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 46:
    	    // PLSQLLexer.g:1:641: SQL92_RESERVED_BEGIN
    	    {
    	        /* 1:641: SQL92_RESERVED_BEGIN */
    	        mSQL92_RESERVED_BEGIN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 47:
    	    // PLSQLLexer.g:1:662: SQL92_RESERVED_BETWEEN
    	    {
    	        /* 1:662: SQL92_RESERVED_BETWEEN */
    	        mSQL92_RESERVED_BETWEEN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 48:
    	    // PLSQLLexer.g:1:685: SQL92_RESERVED_BY
    	    {
    	        /* 1:685: SQL92_RESERVED_BY */
    	        mSQL92_RESERVED_BY();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 49:
    	    // PLSQLLexer.g:1:703: SQL92_RESERVED_CASE
    	    {
    	        /* 1:703: SQL92_RESERVED_CASE */
    	        mSQL92_RESERVED_CASE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 50:
    	    // PLSQLLexer.g:1:723: SQL92_RESERVED_CHECK
    	    {
    	        /* 1:723: SQL92_RESERVED_CHECK */
    	        mSQL92_RESERVED_CHECK();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 51:
    	    // PLSQLLexer.g:1:744: PLSQL_RESERVED_CLUSTERS
    	    {
    	        /* 1:744: PLSQL_RESERVED_CLUSTERS */
    	        mPLSQL_RESERVED_CLUSTERS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 52:
    	    // PLSQLLexer.g:1:768: PLSQL_RESERVED_COLAUTH
    	    {
    	        /* 1:768: PLSQL_RESERVED_COLAUTH */
    	        mPLSQL_RESERVED_COLAUTH();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 53:
    	    // PLSQLLexer.g:1:791: PLSQL_RESERVED_COMPRESS
    	    {
    	        /* 1:791: PLSQL_RESERVED_COMPRESS */
    	        mPLSQL_RESERVED_COMPRESS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 54:
    	    // PLSQLLexer.g:1:815: SQL92_RESERVED_CONNECT
    	    {
    	        /* 1:815: SQL92_RESERVED_CONNECT */
    	        mSQL92_RESERVED_CONNECT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 55:
    	    // PLSQLLexer.g:1:838: PLSQL_NON_RESERVED_CONNECT_BY_ROOT
    	    {
    	        /* 1:838: PLSQL_NON_RESERVED_CONNECT_BY_ROOT */
    	        mPLSQL_NON_RESERVED_CONNECT_BY_ROOT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 56:
    	    // PLSQLLexer.g:1:873: PLSQL_RESERVED_CRASH
    	    {
    	        /* 1:873: PLSQL_RESERVED_CRASH */
    	        mPLSQL_RESERVED_CRASH();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 57:
    	    // PLSQLLexer.g:1:894: SQL92_RESERVED_CREATE
    	    {
    	        /* 1:894: SQL92_RESERVED_CREATE */
    	        mSQL92_RESERVED_CREATE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 58:
    	    // PLSQLLexer.g:1:916: SQL92_RESERVED_CURRENT
    	    {
    	        /* 1:916: SQL92_RESERVED_CURRENT */
    	        mSQL92_RESERVED_CURRENT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 59:
    	    // PLSQLLexer.g:1:939: SQL92_RESERVED_CURSOR
    	    {
    	        /* 1:939: SQL92_RESERVED_CURSOR */
    	        mSQL92_RESERVED_CURSOR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 60:
    	    // PLSQLLexer.g:1:961: SQL92_RESERVED_DATE
    	    {
    	        /* 1:961: SQL92_RESERVED_DATE */
    	        mSQL92_RESERVED_DATE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 61:
    	    // PLSQLLexer.g:1:981: SQL92_RESERVED_DECLARE
    	    {
    	        /* 1:981: SQL92_RESERVED_DECLARE */
    	        mSQL92_RESERVED_DECLARE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 62:
    	    // PLSQLLexer.g:1:1004: SQL92_RESERVED_DEFAULT
    	    {
    	        /* 1:1004: SQL92_RESERVED_DEFAULT */
    	        mSQL92_RESERVED_DEFAULT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 63:
    	    // PLSQLLexer.g:1:1027: SQL92_RESERVED_DELETE
    	    {
    	        /* 1:1027: SQL92_RESERVED_DELETE */
    	        mSQL92_RESERVED_DELETE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 64:
    	    // PLSQLLexer.g:1:1049: SQL92_RESERVED_DESC
    	    {
    	        /* 1:1049: SQL92_RESERVED_DESC */
    	        mSQL92_RESERVED_DESC();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 65:
    	    // PLSQLLexer.g:1:1069: SQL92_RESERVED_DISTINCT
    	    {
    	        /* 1:1069: SQL92_RESERVED_DISTINCT */
    	        mSQL92_RESERVED_DISTINCT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 66:
    	    // PLSQLLexer.g:1:1093: SQL92_RESERVED_DROP
    	    {
    	        /* 1:1093: SQL92_RESERVED_DROP */
    	        mSQL92_RESERVED_DROP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 67:
    	    // PLSQLLexer.g:1:1113: SQL92_RESERVED_ELSE
    	    {
    	        /* 1:1113: SQL92_RESERVED_ELSE */
    	        mSQL92_RESERVED_ELSE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 68:
    	    // PLSQLLexer.g:1:1133: SQL92_RESERVED_END
    	    {
    	        /* 1:1133: SQL92_RESERVED_END */
    	        mSQL92_RESERVED_END();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 69:
    	    // PLSQLLexer.g:1:1152: SQL92_RESERVED_EXCEPTION
    	    {
    	        /* 1:1152: SQL92_RESERVED_EXCEPTION */
    	        mSQL92_RESERVED_EXCEPTION();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 70:
    	    // PLSQLLexer.g:1:1177: PLSQL_RESERVED_EXCLUSIVE
    	    {
    	        /* 1:1177: PLSQL_RESERVED_EXCLUSIVE */
    	        mPLSQL_RESERVED_EXCLUSIVE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 71:
    	    // PLSQLLexer.g:1:1202: SQL92_RESERVED_EXISTS
    	    {
    	        /* 1:1202: SQL92_RESERVED_EXISTS */
    	        mSQL92_RESERVED_EXISTS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 72:
    	    // PLSQLLexer.g:1:1224: SQL92_RESERVED_FALSE
    	    {
    	        /* 1:1224: SQL92_RESERVED_FALSE */
    	        mSQL92_RESERVED_FALSE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 73:
    	    // PLSQLLexer.g:1:1245: SQL92_RESERVED_FETCH
    	    {
    	        /* 1:1245: SQL92_RESERVED_FETCH */
    	        mSQL92_RESERVED_FETCH();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 74:
    	    // PLSQLLexer.g:1:1266: SQL92_RESERVED_FOR
    	    {
    	        /* 1:1266: SQL92_RESERVED_FOR */
    	        mSQL92_RESERVED_FOR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 75:
    	    // PLSQLLexer.g:1:1285: SQL92_RESERVED_FROM
    	    {
    	        /* 1:1285: SQL92_RESERVED_FROM */
    	        mSQL92_RESERVED_FROM();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 76:
    	    // PLSQLLexer.g:1:1305: SQL92_RESERVED_GOTO
    	    {
    	        /* 1:1305: SQL92_RESERVED_GOTO */
    	        mSQL92_RESERVED_GOTO();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 77:
    	    // PLSQLLexer.g:1:1325: SQL92_RESERVED_GRANT
    	    {
    	        /* 1:1325: SQL92_RESERVED_GRANT */
    	        mSQL92_RESERVED_GRANT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 78:
    	    // PLSQLLexer.g:1:1346: SQL92_RESERVED_GROUP
    	    {
    	        /* 1:1346: SQL92_RESERVED_GROUP */
    	        mSQL92_RESERVED_GROUP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 79:
    	    // PLSQLLexer.g:1:1367: SQL92_RESERVED_HAVING
    	    {
    	        /* 1:1367: SQL92_RESERVED_HAVING */
    	        mSQL92_RESERVED_HAVING();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 80:
    	    // PLSQLLexer.g:1:1389: PLSQL_RESERVED_IDENTIFIED
    	    {
    	        /* 1:1389: PLSQL_RESERVED_IDENTIFIED */
    	        mPLSQL_RESERVED_IDENTIFIED();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 81:
    	    // PLSQLLexer.g:1:1415: PLSQL_RESERVED_IF
    	    {
    	        /* 1:1415: PLSQL_RESERVED_IF */
    	        mPLSQL_RESERVED_IF();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 82:
    	    // PLSQLLexer.g:1:1433: SQL92_RESERVED_IN
    	    {
    	        /* 1:1433: SQL92_RESERVED_IN */
    	        mSQL92_RESERVED_IN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 83:
    	    // PLSQLLexer.g:1:1451: PLSQL_RESERVED_INDEX
    	    {
    	        /* 1:1451: PLSQL_RESERVED_INDEX */
    	        mPLSQL_RESERVED_INDEX();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 84:
    	    // PLSQLLexer.g:1:1472: PLSQL_RESERVED_INDEXES
    	    {
    	        /* 1:1472: PLSQL_RESERVED_INDEXES */
    	        mPLSQL_RESERVED_INDEXES();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 85:
    	    // PLSQLLexer.g:1:1495: SQL92_RESERVED_INSERT
    	    {
    	        /* 1:1495: SQL92_RESERVED_INSERT */
    	        mSQL92_RESERVED_INSERT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 86:
    	    // PLSQLLexer.g:1:1517: SQL92_RESERVED_INTERSECT
    	    {
    	        /* 1:1517: SQL92_RESERVED_INTERSECT */
    	        mSQL92_RESERVED_INTERSECT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 87:
    	    // PLSQLLexer.g:1:1542: SQL92_RESERVED_INTO
    	    {
    	        /* 1:1542: SQL92_RESERVED_INTO */
    	        mSQL92_RESERVED_INTO();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 88:
    	    // PLSQLLexer.g:1:1562: SQL92_RESERVED_IS
    	    {
    	        /* 1:1562: SQL92_RESERVED_IS */
    	        mSQL92_RESERVED_IS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 89:
    	    // PLSQLLexer.g:1:1580: SQL92_RESERVED_LIKE
    	    {
    	        /* 1:1580: SQL92_RESERVED_LIKE */
    	        mSQL92_RESERVED_LIKE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 90:
    	    // PLSQLLexer.g:1:1600: PLSQL_RESERVED_LOCK
    	    {
    	        /* 1:1600: PLSQL_RESERVED_LOCK */
    	        mPLSQL_RESERVED_LOCK();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 91:
    	    // PLSQLLexer.g:1:1620: PLSQL_RESERVED_MINUS
    	    {
    	        /* 1:1620: PLSQL_RESERVED_MINUS */
    	        mPLSQL_RESERVED_MINUS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 92:
    	    // PLSQLLexer.g:1:1641: PLSQL_RESERVED_MODE
    	    {
    	        /* 1:1641: PLSQL_RESERVED_MODE */
    	        mPLSQL_RESERVED_MODE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 93:
    	    // PLSQLLexer.g:1:1661: PLSQL_RESERVED_NOCOMPRESS
    	    {
    	        /* 1:1661: PLSQL_RESERVED_NOCOMPRESS */
    	        mPLSQL_RESERVED_NOCOMPRESS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 94:
    	    // PLSQLLexer.g:1:1687: SQL92_RESERVED_NOT
    	    {
    	        /* 1:1687: SQL92_RESERVED_NOT */
    	        mSQL92_RESERVED_NOT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 95:
    	    // PLSQLLexer.g:1:1706: PLSQL_RESERVED_NOWAIT
    	    {
    	        /* 1:1706: PLSQL_RESERVED_NOWAIT */
    	        mPLSQL_RESERVED_NOWAIT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 96:
    	    // PLSQLLexer.g:1:1728: SQL92_RESERVED_NULL
    	    {
    	        /* 1:1728: SQL92_RESERVED_NULL */
    	        mSQL92_RESERVED_NULL();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 97:
    	    // PLSQLLexer.g:1:1748: SQL92_RESERVED_OF
    	    {
    	        /* 1:1748: SQL92_RESERVED_OF */
    	        mSQL92_RESERVED_OF();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 98:
    	    // PLSQLLexer.g:1:1766: SQL92_RESERVED_ON
    	    {
    	        /* 1:1766: SQL92_RESERVED_ON */
    	        mSQL92_RESERVED_ON();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 99:
    	    // PLSQLLexer.g:1:1784: SQL92_RESERVED_OPTION
    	    {
    	        /* 1:1784: SQL92_RESERVED_OPTION */
    	        mSQL92_RESERVED_OPTION();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 100:
    	    // PLSQLLexer.g:1:1806: SQL92_RESERVED_OR
    	    {
    	        /* 1:1806: SQL92_RESERVED_OR */
    	        mSQL92_RESERVED_OR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 101:
    	    // PLSQLLexer.g:1:1824: SQL92_RESERVED_ORDER
    	    {
    	        /* 1:1824: SQL92_RESERVED_ORDER */
    	        mSQL92_RESERVED_ORDER();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 102:
    	    // PLSQLLexer.g:1:1845: SQL92_RESERVED_OVERLAPS
    	    {
    	        /* 1:1845: SQL92_RESERVED_OVERLAPS */
    	        mSQL92_RESERVED_OVERLAPS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 103:
    	    // PLSQLLexer.g:1:1869: SQL92_RESERVED_PRIOR
    	    {
    	        /* 1:1869: SQL92_RESERVED_PRIOR */
    	        mSQL92_RESERVED_PRIOR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 104:
    	    // PLSQLLexer.g:1:1890: SQL92_RESERVED_PROCEDURE
    	    {
    	        /* 1:1890: SQL92_RESERVED_PROCEDURE */
    	        mSQL92_RESERVED_PROCEDURE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 105:
    	    // PLSQLLexer.g:1:1915: SQL92_RESERVED_PUBLIC
    	    {
    	        /* 1:1915: SQL92_RESERVED_PUBLIC */
    	        mSQL92_RESERVED_PUBLIC();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 106:
    	    // PLSQLLexer.g:1:1937: PLSQL_RESERVED_RESOURCE
    	    {
    	        /* 1:1937: PLSQL_RESERVED_RESOURCE */
    	        mPLSQL_RESERVED_RESOURCE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 107:
    	    // PLSQLLexer.g:1:1961: SQL92_RESERVED_REVOKE
    	    {
    	        /* 1:1961: SQL92_RESERVED_REVOKE */
    	        mSQL92_RESERVED_REVOKE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 108:
    	    // PLSQLLexer.g:1:1983: SQL92_RESERVED_SELECT
    	    {
    	        /* 1:1983: SQL92_RESERVED_SELECT */
    	        mSQL92_RESERVED_SELECT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 109:
    	    // PLSQLLexer.g:1:2005: PLSQL_RESERVED_SHARE
    	    {
    	        /* 1:2005: PLSQL_RESERVED_SHARE */
    	        mPLSQL_RESERVED_SHARE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 110:
    	    // PLSQLLexer.g:1:2026: SQL92_RESERVED_SIZE
    	    {
    	        /* 1:2026: SQL92_RESERVED_SIZE */
    	        mSQL92_RESERVED_SIZE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 111:
    	    // PLSQLLexer.g:1:2046: PLSQL_RESERVED_START
    	    {
    	        /* 1:2046: PLSQL_RESERVED_START */
    	        mPLSQL_RESERVED_START();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 112:
    	    // PLSQLLexer.g:1:2067: PLSQL_RESERVED_TABAUTH
    	    {
    	        /* 1:2067: PLSQL_RESERVED_TABAUTH */
    	        mPLSQL_RESERVED_TABAUTH();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 113:
    	    // PLSQLLexer.g:1:2090: SQL92_RESERVED_TABLE
    	    {
    	        /* 1:2090: SQL92_RESERVED_TABLE */
    	        mSQL92_RESERVED_TABLE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 114:
    	    // PLSQLLexer.g:1:2111: SQL92_RESERVED_THE
    	    {
    	        /* 1:2111: SQL92_RESERVED_THE */
    	        mSQL92_RESERVED_THE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 115:
    	    // PLSQLLexer.g:1:2130: SQL92_RESERVED_THEN
    	    {
    	        /* 1:2130: SQL92_RESERVED_THEN */
    	        mSQL92_RESERVED_THEN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 116:
    	    // PLSQLLexer.g:1:2150: SQL92_RESERVED_TO
    	    {
    	        /* 1:2150: SQL92_RESERVED_TO */
    	        mSQL92_RESERVED_TO();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 117:
    	    // PLSQLLexer.g:1:2168: SQL92_RESERVED_TRUE
    	    {
    	        /* 1:2168: SQL92_RESERVED_TRUE */
    	        mSQL92_RESERVED_TRUE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 118:
    	    // PLSQLLexer.g:1:2188: SQL92_RESERVED_UNION
    	    {
    	        /* 1:2188: SQL92_RESERVED_UNION */
    	        mSQL92_RESERVED_UNION();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 119:
    	    // PLSQLLexer.g:1:2209: SQL92_RESERVED_UNIQUE
    	    {
    	        /* 1:2209: SQL92_RESERVED_UNIQUE */
    	        mSQL92_RESERVED_UNIQUE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 120:
    	    // PLSQLLexer.g:1:2231: SQL92_RESERVED_UPDATE
    	    {
    	        /* 1:2231: SQL92_RESERVED_UPDATE */
    	        mSQL92_RESERVED_UPDATE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 121:
    	    // PLSQLLexer.g:1:2253: SQL92_RESERVED_VALUES
    	    {
    	        /* 1:2253: SQL92_RESERVED_VALUES */
    	        mSQL92_RESERVED_VALUES();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 122:
    	    // PLSQLLexer.g:1:2275: SQL92_RESERVED_VIEW
    	    {
    	        /* 1:2275: SQL92_RESERVED_VIEW */
    	        mSQL92_RESERVED_VIEW();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 123:
    	    // PLSQLLexer.g:1:2295: PLSQL_RESERVED_VIEWS
    	    {
    	        /* 1:2295: PLSQL_RESERVED_VIEWS */
    	        mPLSQL_RESERVED_VIEWS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 124:
    	    // PLSQLLexer.g:1:2316: SQL92_RESERVED_WHEN
    	    {
    	        /* 1:2316: SQL92_RESERVED_WHEN */
    	        mSQL92_RESERVED_WHEN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 125:
    	    // PLSQLLexer.g:1:2336: SQL92_RESERVED_WHERE
    	    {
    	        /* 1:2336: SQL92_RESERVED_WHERE */
    	        mSQL92_RESERVED_WHERE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 126:
    	    // PLSQLLexer.g:1:2357: SQL92_RESERVED_WITH
    	    {
    	        /* 1:2357: SQL92_RESERVED_WITH */
    	        mSQL92_RESERVED_WITH();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 127:
    	    // PLSQLLexer.g:1:2377: PLSQL_NON_RESERVED_USING
    	    {
    	        /* 1:2377: PLSQL_NON_RESERVED_USING */
    	        mPLSQL_NON_RESERVED_USING();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 128:
    	    // PLSQLLexer.g:1:2402: PLSQL_NON_RESERVED_MODEL
    	    {
    	        /* 1:2402: PLSQL_NON_RESERVED_MODEL */
    	        mPLSQL_NON_RESERVED_MODEL();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 129:
    	    // PLSQLLexer.g:1:2427: PLSQL_NON_RESERVED_ELSIF
    	    {
    	        /* 1:2427: PLSQL_NON_RESERVED_ELSIF */
    	        mPLSQL_NON_RESERVED_ELSIF();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 130:
    	    // PLSQLLexer.g:1:2452: PLSQL_NON_RESERVED_PIVOT
    	    {
    	        /* 1:2452: PLSQL_NON_RESERVED_PIVOT */
    	        mPLSQL_NON_RESERVED_PIVOT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 131:
    	    // PLSQLLexer.g:1:2477: PLSQL_NON_RESERVED_UNPIVOT
    	    {
    	        /* 1:2477: PLSQL_NON_RESERVED_UNPIVOT */
    	        mPLSQL_NON_RESERVED_UNPIVOT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 132:
    	    // PLSQLLexer.g:1:2504: REGULAR_ID
    	    {
    	        /* 1:2504: REGULAR_ID */
    	        mREGULAR_ID();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 133:
    	    // PLSQLLexer.g:1:2515: ZV
    	    {
    	        /* 1:2515: ZV */
    	        mZV();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;

        }
    }


    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */

}


/* End of code
 * =============================================================================
 */
