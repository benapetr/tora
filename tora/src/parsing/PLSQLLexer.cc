/** \file
 *  This C++ source file was generated by $ANTLR version 3.5.1-SNAPSHOT
 *
 *     -  From the grammar source file : PLSQLLexer.g
 *     -                            On : 2013-06-21 13:57:11
 *     -                 for the lexer : PLSQLLexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/*
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "PLSQLLexer.hpp"
/* ----------------------------------------- */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


namespace 
User
 {
const ANTLR_UINT8* PLSQLLexerTokens::getTokenName(ANTLR_INT32 index) const
{
	if( EOF_TOKEN == index)
		return (ANTLR_UINT8*) "<EOF>";
	return TokenNames[index];
}

/** \brief Table of all token names in symbolic order, mainly used for debugging.
 */
ANTLR_UINT8* PLSQLLexerTokens::TokenNames[151+4]
	= {
	(ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
	(ANTLR_UINT8*) "<EOR>",
	(ANTLR_UINT8*) "<DOWN>",
	(ANTLR_UINT8*) "<UP>",
	(ANTLR_UINT8*) "AMPERSAND",//4
	(ANTLR_UINT8*) "APPROXIMATE_NUM_LIT",//5
	(ANTLR_UINT8*) "ASSIGN_OP",//6
	(ANTLR_UINT8*) "ASTERISK",//7
	(ANTLR_UINT8*) "AT_SIGN",//8
	(ANTLR_UINT8*) "BINDVAR",//9
	(ANTLR_UINT8*) "BIT_STRING_LIT",//10
	(ANTLR_UINT8*) "CARRET_OPERATOR_PART",//11
	(ANTLR_UINT8*) "CHAR_STRING",//12
	(ANTLR_UINT8*) "CHAR_STRING_PERL",//13
	(ANTLR_UINT8*) "COLON",//14
	(ANTLR_UINT8*) "COMMA",//15
	(ANTLR_UINT8*) "COMMENT",//16
	(ANTLR_UINT8*) "CONCATENATION_OP",//17
	(ANTLR_UINT8*) "DELIMITED_ID",//18
	(ANTLR_UINT8*) "DOUBLE_ASTERISK",//19
	(ANTLR_UINT8*) "DOUBLE_PERIOD",//20
	(ANTLR_UINT8*) "EQUALS_OP",//21
	(ANTLR_UINT8*) "EXACT_NUM_LIT",//22
	(ANTLR_UINT8*) "EXCLAMATION_OPERATOR_PART",//23
	(ANTLR_UINT8*) "FOR_NOTATION",//24
	(ANTLR_UINT8*) "GREATER_THAN_OP",//25
	(ANTLR_UINT8*) "GREATER_THAN_OR_EQUALS_OP",//26
	(ANTLR_UINT8*) "HEX_STRING_LIT",//27
	(ANTLR_UINT8*) "INTRODUCER",//28
	(ANTLR_UINT8*) "LEFT_BRACKET",//29
	(ANTLR_UINT8*) "LEFT_PAREN",//30
	(ANTLR_UINT8*) "LESS_THAN_OP",//31
	(ANTLR_UINT8*) "LESS_THAN_OR_EQUALS_OP",//32
	(ANTLR_UINT8*) "MINUS_SIGN",//33
	(ANTLR_UINT8*) "NATIONAL_CHAR_STRING_LIT",//34
	(ANTLR_UINT8*) "NEWLINE",//35
	(ANTLR_UINT8*) "NOT_EQUAL_OP",//36
	(ANTLR_UINT8*) "PERCENT",//37
	(ANTLR_UINT8*) "PERIOD",//38
	(ANTLR_UINT8*) "PLSQL_NON_RESERVED_CONNECT_BY_ROOT",//39
	(ANTLR_UINT8*) "PLSQL_NON_RESERVED_ELSIF",//40
	(ANTLR_UINT8*) "PLSQL_NON_RESERVED_MODEL",//41
	(ANTLR_UINT8*) "PLSQL_NON_RESERVED_PIVOT",//42
	(ANTLR_UINT8*) "PLSQL_NON_RESERVED_UNPIVOT",//43
	(ANTLR_UINT8*) "PLSQL_NON_RESERVED_USING",//44
	(ANTLR_UINT8*) "PLSQL_RESERVED_CLUSTERS",//45
	(ANTLR_UINT8*) "PLSQL_RESERVED_COLAUTH",//46
	(ANTLR_UINT8*) "PLSQL_RESERVED_COMPRESS",//47
	(ANTLR_UINT8*) "PLSQL_RESERVED_CRASH",//48
	(ANTLR_UINT8*) "PLSQL_RESERVED_EXCLUSIVE",//49
	(ANTLR_UINT8*) "PLSQL_RESERVED_IDENTIFIED",//50
	(ANTLR_UINT8*) "PLSQL_RESERVED_IF",//51
	(ANTLR_UINT8*) "PLSQL_RESERVED_INDEX",//52
	(ANTLR_UINT8*) "PLSQL_RESERVED_INDEXES",//53
	(ANTLR_UINT8*) "PLSQL_RESERVED_LOCK",//54
	(ANTLR_UINT8*) "PLSQL_RESERVED_MINUS",//55
	(ANTLR_UINT8*) "PLSQL_RESERVED_MODE",//56
	(ANTLR_UINT8*) "PLSQL_RESERVED_NOCOMPRESS",//57
	(ANTLR_UINT8*) "PLSQL_RESERVED_NOWAIT",//58
	(ANTLR_UINT8*) "PLSQL_RESERVED_RESOURCE",//59
	(ANTLR_UINT8*) "PLSQL_RESERVED_SHARE",//60
	(ANTLR_UINT8*) "PLSQL_RESERVED_START",//61
	(ANTLR_UINT8*) "PLSQL_RESERVED_TABAUTH",//62
	(ANTLR_UINT8*) "PLSQL_RESERVED_VIEWS",//63
	(ANTLR_UINT8*) "PLUS_SIGN",//64
	(ANTLR_UINT8*) "PROMPT",//65
	(ANTLR_UINT8*) "QS_ANGLE",//66
	(ANTLR_UINT8*) "QS_BRACE",//67
	(ANTLR_UINT8*) "QS_BRACK",//68
	(ANTLR_UINT8*) "QS_OTHER",//69
	(ANTLR_UINT8*) "QS_OTHER_CH",//70
	(ANTLR_UINT8*) "QS_PAREN",//71
	(ANTLR_UINT8*) "QUESTION_MARK",//72
	(ANTLR_UINT8*) "QUOTE",//73
	(ANTLR_UINT8*) "REGULAR_ID",//74
	(ANTLR_UINT8*) "RIGHT_BRACKET",//75
	(ANTLR_UINT8*) "RIGHT_PAREN",//76
	(ANTLR_UINT8*) "SEMICOLON",//77
	(ANTLR_UINT8*) "SEPARATOR",//78
	(ANTLR_UINT8*) "SIMPLE_LETTER",//79
	(ANTLR_UINT8*) "SOLIDUS",//80
	(ANTLR_UINT8*) "SPACE",//81
	(ANTLR_UINT8*) "SQL92_RESERVED_ALL",//82
	(ANTLR_UINT8*) "SQL92_RESERVED_ALTER",//83
	(ANTLR_UINT8*) "SQL92_RESERVED_AND",//84
	(ANTLR_UINT8*) "SQL92_RESERVED_ANY",//85
	(ANTLR_UINT8*) "SQL92_RESERVED_AS",//86
	(ANTLR_UINT8*) "SQL92_RESERVED_ASC",//87
	(ANTLR_UINT8*) "SQL92_RESERVED_BEGIN",//88
	(ANTLR_UINT8*) "SQL92_RESERVED_BETWEEN",//89
	(ANTLR_UINT8*) "SQL92_RESERVED_BY",//90
	(ANTLR_UINT8*) "SQL92_RESERVED_CASE",//91
	(ANTLR_UINT8*) "SQL92_RESERVED_CHECK",//92
	(ANTLR_UINT8*) "SQL92_RESERVED_CONNECT",//93
	(ANTLR_UINT8*) "SQL92_RESERVED_CREATE",//94
	(ANTLR_UINT8*) "SQL92_RESERVED_CURRENT",//95
	(ANTLR_UINT8*) "SQL92_RESERVED_CURSOR",//96
	(ANTLR_UINT8*) "SQL92_RESERVED_DATE",//97
	(ANTLR_UINT8*) "SQL92_RESERVED_DECLARE",//98
	(ANTLR_UINT8*) "SQL92_RESERVED_DEFAULT",//99
	(ANTLR_UINT8*) "SQL92_RESERVED_DELETE",//100
	(ANTLR_UINT8*) "SQL92_RESERVED_DESC",//101
	(ANTLR_UINT8*) "SQL92_RESERVED_DISTINCT",//102
	(ANTLR_UINT8*) "SQL92_RESERVED_DROP",//103
	(ANTLR_UINT8*) "SQL92_RESERVED_ELSE",//104
	(ANTLR_UINT8*) "SQL92_RESERVED_END",//105
	(ANTLR_UINT8*) "SQL92_RESERVED_EXCEPTION",//106
	(ANTLR_UINT8*) "SQL92_RESERVED_EXISTS",//107
	(ANTLR_UINT8*) "SQL92_RESERVED_FALSE",//108
	(ANTLR_UINT8*) "SQL92_RESERVED_FETCH",//109
	(ANTLR_UINT8*) "SQL92_RESERVED_FOR",//110
	(ANTLR_UINT8*) "SQL92_RESERVED_FROM",//111
	(ANTLR_UINT8*) "SQL92_RESERVED_GOTO",//112
	(ANTLR_UINT8*) "SQL92_RESERVED_GRANT",//113
	(ANTLR_UINT8*) "SQL92_RESERVED_GROUP",//114
	(ANTLR_UINT8*) "SQL92_RESERVED_HAVING",//115
	(ANTLR_UINT8*) "SQL92_RESERVED_IN",//116
	(ANTLR_UINT8*) "SQL92_RESERVED_INSERT",//117
	(ANTLR_UINT8*) "SQL92_RESERVED_INTERSECT",//118
	(ANTLR_UINT8*) "SQL92_RESERVED_INTO",//119
	(ANTLR_UINT8*) "SQL92_RESERVED_IS",//120
	(ANTLR_UINT8*) "SQL92_RESERVED_LIKE",//121
	(ANTLR_UINT8*) "SQL92_RESERVED_NOT",//122
	(ANTLR_UINT8*) "SQL92_RESERVED_NULL",//123
	(ANTLR_UINT8*) "SQL92_RESERVED_OF",//124
	(ANTLR_UINT8*) "SQL92_RESERVED_ON",//125
	(ANTLR_UINT8*) "SQL92_RESERVED_OPTION",//126
	(ANTLR_UINT8*) "SQL92_RESERVED_OR",//127
	(ANTLR_UINT8*) "SQL92_RESERVED_ORDER",//128
	(ANTLR_UINT8*) "SQL92_RESERVED_OVERLAPS",//129
	(ANTLR_UINT8*) "SQL92_RESERVED_PRIOR",//130
	(ANTLR_UINT8*) "SQL92_RESERVED_PROCEDURE",//131
	(ANTLR_UINT8*) "SQL92_RESERVED_PUBLIC",//132
	(ANTLR_UINT8*) "SQL92_RESERVED_REVOKE",//133
	(ANTLR_UINT8*) "SQL92_RESERVED_SELECT",//134
	(ANTLR_UINT8*) "SQL92_RESERVED_SIZE",//135
	(ANTLR_UINT8*) "SQL92_RESERVED_TABLE",//136
	(ANTLR_UINT8*) "SQL92_RESERVED_THE",//137
	(ANTLR_UINT8*) "SQL92_RESERVED_THEN",//138
	(ANTLR_UINT8*) "SQL92_RESERVED_TO",//139
	(ANTLR_UINT8*) "SQL92_RESERVED_TRUE",//140
	(ANTLR_UINT8*) "SQL92_RESERVED_UNION",//141
	(ANTLR_UINT8*) "SQL92_RESERVED_UNIQUE",//142
	(ANTLR_UINT8*) "SQL92_RESERVED_UPDATE",//143
	(ANTLR_UINT8*) "SQL92_RESERVED_VALUES",//144
	(ANTLR_UINT8*) "SQL92_RESERVED_VIEW",//145
	(ANTLR_UINT8*) "SQL92_RESERVED_WHEN",//146
	(ANTLR_UINT8*) "SQL92_RESERVED_WHERE",//147
	(ANTLR_UINT8*) "SQL92_RESERVED_WITH",//148
	(ANTLR_UINT8*) "TILDE_OPERATOR_PART",//149
	(ANTLR_UINT8*) "UNDERSCORE",//150
	(ANTLR_UINT8*) "UNSIGNED_INTEGER",//151
	(ANTLR_UINT8*) "VERTICAL_BAR",//152
	(ANTLR_UINT8*) "ZV",//153
	};
/** String literals used by PLSQLLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR_UCHAR	lit_1[]  = { 0x2E, 0x2E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_2[]  = { 0x2A, 0x2A,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_3[]  = { 0x3A, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_4[]  = { 0x3C, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_5[]  = { 0x3E, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_6[]  = { 0x21, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_7[]  = { 0x3C, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_8[]  = { 0x5E, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_9[]  = { 0x7E, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_10[]  = { 0x7C, 0x7C,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_11[]  = { 0x2D, 0x2D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_12[]  = { 0x2F, 0x2A,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_13[]  = { 0x2A, 0x2F,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_14[]  = { 0x50, 0x52, 0x4F, 0x4D, 0x50, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_15[]  = { 0x41, 0x4C, 0x4C,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_16[]  = { 0x41, 0x4C, 0x54, 0x45, 0x52,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_17[]  = { 0x41, 0x4E, 0x44,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_18[]  = { 0x41, 0x4E, 0x59,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_19[]  = { 0x41, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_20[]  = { 0x41, 0x53, 0x43,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_21[]  = { 0x42, 0x45, 0x47, 0x49, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_22[]  = { 0x42, 0x45, 0x54, 0x57, 0x45, 0x45, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_23[]  = { 0x42, 0x59,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_24[]  = { 0x43, 0x41, 0x53, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_25[]  = { 0x43, 0x48, 0x45, 0x43, 0x4B,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_26[]  = { 0x43, 0x4C, 0x55, 0x53, 0x54, 0x45, 0x52, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_27[]  = { 0x43, 0x4F, 0x4C, 0x41, 0x55, 0x54, 0x48,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_28[]  = { 0x43, 0x4F, 0x4D, 0x50, 0x52, 0x45, 0x53, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_29[]  = { 0x43, 0x4F, 0x4E, 0x4E, 0x45, 0x43, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_30[]  = { 0x43, 0x4F, 0x4E, 0x4E, 0x45, 0x43, 0x54, 0x5F, 0x42, 0x59, 0x5F, 0x52, 0x4F, 0x4F, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_31[]  = { 0x43, 0x52, 0x41, 0x53, 0x48,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_32[]  = { 0x43, 0x52, 0x45, 0x41, 0x54, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_33[]  = { 0x43, 0x55, 0x52, 0x52, 0x45, 0x4E, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_34[]  = { 0x43, 0x55, 0x52, 0x53, 0x4F, 0x52,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_35[]  = { 0x44, 0x41, 0x54, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_36[]  = { 0x44, 0x45, 0x43, 0x4C, 0x41, 0x52, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_37[]  = { 0x44, 0x45, 0x46, 0x41, 0x55, 0x4C, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_38[]  = { 0x44, 0x45, 0x4C, 0x45, 0x54, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_39[]  = { 0x44, 0x45, 0x53, 0x43,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_40[]  = { 0x44, 0x49, 0x53, 0x54, 0x49, 0x4E, 0x43, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_41[]  = { 0x44, 0x52, 0x4F, 0x50,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_42[]  = { 0x45, 0x4C, 0x53, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_43[]  = { 0x45, 0x4E, 0x44,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_44[]  = { 0x45, 0x58, 0x43, 0x45, 0x50, 0x54, 0x49, 0x4F, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_45[]  = { 0x45, 0x58, 0x43, 0x4C, 0x55, 0x53, 0x49, 0x56, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_46[]  = { 0x45, 0x58, 0x49, 0x53, 0x54, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_47[]  = { 0x46, 0x41, 0x4C, 0x53, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_48[]  = { 0x46, 0x45, 0x54, 0x43, 0x48,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_49[]  = { 0x46, 0x4F, 0x52,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_50[]  = { 0x46, 0x52, 0x4F, 0x4D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_51[]  = { 0x47, 0x4F, 0x54, 0x4F,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_52[]  = { 0x47, 0x52, 0x41, 0x4E, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_53[]  = { 0x47, 0x52, 0x4F, 0x55, 0x50,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_54[]  = { 0x48, 0x41, 0x56, 0x49, 0x4E, 0x47,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_55[]  = { 0x49, 0x44, 0x45, 0x4E, 0x54, 0x49, 0x46, 0x49, 0x45, 0x44,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_56[]  = { 0x49, 0x46,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_57[]  = { 0x49, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_58[]  = { 0x49, 0x4E, 0x44, 0x45, 0x58,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_59[]  = { 0x49, 0x4E, 0x44, 0x45, 0x58, 0x45, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_60[]  = { 0x49, 0x4E, 0x53, 0x45, 0x52, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_61[]  = { 0x49, 0x4E, 0x54, 0x45, 0x52, 0x53, 0x45, 0x43, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_62[]  = { 0x49, 0x4E, 0x54, 0x4F,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_63[]  = { 0x49, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_64[]  = { 0x4C, 0x49, 0x4B, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_65[]  = { 0x4C, 0x4F, 0x43, 0x4B,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_66[]  = { 0x4D, 0x49, 0x4E, 0x55, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_67[]  = { 0x4D, 0x4F, 0x44, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_68[]  = { 0x4E, 0x4F, 0x43, 0x4F, 0x4D, 0x50, 0x52, 0x45, 0x53, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_69[]  = { 0x4E, 0x4F, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_70[]  = { 0x4E, 0x4F, 0x57, 0x41, 0x49, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_71[]  = { 0x4E, 0x55, 0x4C, 0x4C,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_72[]  = { 0x4F, 0x46,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_73[]  = { 0x4F, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_74[]  = { 0x4F, 0x50, 0x54, 0x49, 0x4F, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_75[]  = { 0x4F, 0x52,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_76[]  = { 0x4F, 0x52, 0x44, 0x45, 0x52,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_77[]  = { 0x4F, 0x56, 0x45, 0x52, 0x4C, 0x41, 0x50, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_78[]  = { 0x50, 0x52, 0x49, 0x4F, 0x52,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_79[]  = { 0x50, 0x52, 0x4F, 0x43, 0x45, 0x44, 0x55, 0x52, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_80[]  = { 0x50, 0x55, 0x42, 0x4C, 0x49, 0x43,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_81[]  = { 0x52, 0x45, 0x53, 0x4F, 0x55, 0x52, 0x43, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_82[]  = { 0x52, 0x45, 0x56, 0x4F, 0x4B, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_83[]  = { 0x53, 0x45, 0x4C, 0x45, 0x43, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_84[]  = { 0x53, 0x48, 0x41, 0x52, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_85[]  = { 0x53, 0x49, 0x5A, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_86[]  = { 0x53, 0x54, 0x41, 0x52, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_87[]  = { 0x54, 0x41, 0x42, 0x41, 0x55, 0x54, 0x48,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_88[]  = { 0x54, 0x41, 0x42, 0x4C, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_89[]  = { 0x54, 0x48, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_90[]  = { 0x54, 0x48, 0x45, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_91[]  = { 0x54, 0x4F,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_92[]  = { 0x54, 0x52, 0x55, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_93[]  = { 0x55, 0x4E, 0x49, 0x4F, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_94[]  = { 0x55, 0x4E, 0x49, 0x51, 0x55, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_95[]  = { 0x55, 0x50, 0x44, 0x41, 0x54, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_96[]  = { 0x56, 0x41, 0x4C, 0x55, 0x45, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_97[]  = { 0x56, 0x49, 0x45, 0x57,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_98[]  = { 0x56, 0x49, 0x45, 0x57, 0x53,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_99[]  = { 0x57, 0x48, 0x45, 0x4E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_100[]  = { 0x57, 0x48, 0x45, 0x52, 0x45,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_101[]  = { 0x57, 0x49, 0x54, 0x48,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_102[]  = { 0x55, 0x53, 0x49, 0x4E, 0x47,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_103[]  = { 0x4D, 0x4F, 0x44, 0x45, 0x4C,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_104[]  = { 0x45, 0x4C, 0x53, 0x49, 0x46,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_105[]  = { 0x50, 0x49, 0x56, 0x4F, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_106[]  = { 0x55, 0x4E, 0x50, 0x49, 0x56, 0x4F, 0x54,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_107[]  = { 0x40, 0x21,  antlr3::ANTLR_STRING_TERMINATOR};

}


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

using namespace antlr3;

namespace 
User
 {

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */


PLSQLLexer::~PLSQLLexer()
{
}

void
PLSQLLexer::reset()
{
    this->get_rec()->reset();
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "PLSQLLexer.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* PLSQLLexer::getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called PLSQLLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return
 *     - Success pPLSQLLexer initialized for the lex start
 *     - Fail NULL
 */
PLSQLLexer::PLSQLLexer(StreamType* instream)
:PLSQLLexerImplTraits::BaseLexerType(ANTLR_SIZE_HINT, instream, NULL)
{
	// See if we can create a new lexer with the standard constructor
	//
	this->init(instream );
}

/** \brief Create a new lexer called PLSQLLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return
 *     - Success pPLSQLLexer initialized for the lex start
 *     - Fail NULL
 */
PLSQLLexer::PLSQLLexer(StreamType* instream, RecognizerSharedStateType* state)
:PLSQLLexerImplTraits::BaseLexerType(ANTLR_SIZE_HINT, instream, state)
{
	this->init(instream );
}

void PLSQLLexer::init(StreamType* instream)
{
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in PLSQLLexer.h here so you can get a sense
     * of what goes where.
     */

}


/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( FOR_NOTATION | NATIONAL_CHAR_STRING_LIT | BIT_STRING_LIT | HEX_STRING_LIT | PERIOD | EXACT_NUM_LIT | CHAR_STRING | CHAR_STRING_PERL | DELIMITED_ID | PERCENT | AMPERSAND | LEFT_PAREN | RIGHT_PAREN | DOUBLE_ASTERISK | ASTERISK | PLUS_SIGN | COMMA | SOLIDUS | AT_SIGN | ASSIGN_OP | BINDVAR | COLON | SEMICOLON | LESS_THAN_OR_EQUALS_OP | LESS_THAN_OP | GREATER_THAN_OR_EQUALS_OP | NOT_EQUAL_OP | CARRET_OPERATOR_PART | TILDE_OPERATOR_PART | EXCLAMATION_OPERATOR_PART | GREATER_THAN_OP | CONCATENATION_OP | VERTICAL_BAR | EQUALS_OP | LEFT_BRACKET | RIGHT_BRACKET | INTRODUCER | SEPARATOR | PROMPT | SQL92_RESERVED_ALL | SQL92_RESERVED_ALTER | SQL92_RESERVED_AND | SQL92_RESERVED_ANY | SQL92_RESERVED_AS | SQL92_RESERVED_ASC | SQL92_RESERVED_BEGIN | SQL92_RESERVED_BETWEEN | SQL92_RESERVED_BY | SQL92_RESERVED_CASE | SQL92_RESERVED_CHECK | PLSQL_RESERVED_CLUSTERS | PLSQL_RESERVED_COLAUTH | PLSQL_RESERVED_COMPRESS | SQL92_RESERVED_CONNECT | PLSQL_NON_RESERVED_CONNECT_BY_ROOT | PLSQL_RESERVED_CRASH | SQL92_RESERVED_CREATE | SQL92_RESERVED_CURRENT | SQL92_RESERVED_CURSOR | SQL92_RESERVED_DATE | SQL92_RESERVED_DECLARE | SQL92_RESERVED_DEFAULT | SQL92_RESERVED_DELETE | SQL92_RESERVED_DESC | SQL92_RESERVED_DISTINCT | SQL92_RESERVED_DROP | SQL92_RESERVED_ELSE | SQL92_RESERVED_END | SQL92_RESERVED_EXCEPTION | PLSQL_RESERVED_EXCLUSIVE | SQL92_RESERVED_EXISTS | SQL92_RESERVED_FALSE | SQL92_RESERVED_FETCH | SQL92_RESERVED_FOR | SQL92_RESERVED_FROM | SQL92_RESERVED_GOTO | SQL92_RESERVED_GRANT | SQL92_RESERVED_GROUP | SQL92_RESERVED_HAVING | PLSQL_RESERVED_IDENTIFIED | PLSQL_RESERVED_IF | SQL92_RESERVED_IN | PLSQL_RESERVED_INDEX | PLSQL_RESERVED_INDEXES | SQL92_RESERVED_INSERT | SQL92_RESERVED_INTERSECT | SQL92_RESERVED_INTO | SQL92_RESERVED_IS | SQL92_RESERVED_LIKE | PLSQL_RESERVED_LOCK | PLSQL_RESERVED_MINUS | PLSQL_RESERVED_MODE | PLSQL_RESERVED_NOCOMPRESS | SQL92_RESERVED_NOT | PLSQL_RESERVED_NOWAIT | SQL92_RESERVED_NULL | SQL92_RESERVED_OF | SQL92_RESERVED_ON | SQL92_RESERVED_OPTION | SQL92_RESERVED_OR | SQL92_RESERVED_ORDER | SQL92_RESERVED_OVERLAPS | SQL92_RESERVED_PRIOR | SQL92_RESERVED_PROCEDURE | SQL92_RESERVED_PUBLIC | PLSQL_RESERVED_RESOURCE | SQL92_RESERVED_REVOKE | SQL92_RESERVED_SELECT | PLSQL_RESERVED_SHARE | SQL92_RESERVED_SIZE | PLSQL_RESERVED_START | PLSQL_RESERVED_TABAUTH | SQL92_RESERVED_TABLE | SQL92_RESERVED_THE | SQL92_RESERVED_THEN | SQL92_RESERVED_TO | SQL92_RESERVED_TRUE | SQL92_RESERVED_UNION | SQL92_RESERVED_UNIQUE | SQL92_RESERVED_UPDATE | SQL92_RESERVED_VALUES | SQL92_RESERVED_VIEW | PLSQL_RESERVED_VIEWS | SQL92_RESERVED_WHEN | SQL92_RESERVED_WHERE | SQL92_RESERVED_WITH | PLSQL_NON_RESERVED_USING | PLSQL_NON_RESERVED_MODEL | PLSQL_NON_RESERVED_ELSIF | PLSQL_NON_RESERVED_PIVOT | PLSQL_NON_RESERVED_UNPIVOT | REGULAR_ID | ZV );
 */
static const ANTLR_INT32 dfa39_eot[511] =
    {
	-1, 53, 52, 52, 52, 62, -1, 52, -1, -1, -1, -1, -1, 65, -1, -1, 66, 68, 
	70, -1, -1, 73, 75, 76, 77, 78, 80, -1, -1, -1, -1, -1, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, -1, -1, 
	-1, -1, 52, 52, 52, 143, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 153, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	183, 187, 188, 52, 52, 52, 52, 193, 194, 52, 197, 52, 52, 52, 52, 52, 52, 
	52, 52, 207, 52, 52, 52, 52, 52, 52, 52, 52, -1, 52, 218, 52, 52, 52, 52, 
	-1, 52, 52, 52, 52, 228, 52, 230, 231, 232, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 252, 52, 52, 52, 52, 258, 52, 
	52, 52, 52, 52, 52, -1, 52, 52, 52, -1, -1, 52, 52, 52, 52, -1, -1, 52, 
	52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 285, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, -1, 52, 299, 52, 52, 52, 52, 52, 52, 52, -1, 52, -1, -1, 
	-1, 308, 52, 52, 52, 52, 52, 52, 52, 52, 52, 318, 52, 52, 52, 322, 52, 
	324, 325, 52, -1, 52, 52, 52, 52, 52, -1, 332, 333, 52, 52, 52, 52, 52, 
	52, 52, 341, 342, 343, 52, 346, 52, 52, 52, 52, 52, 52, 52, 354, 52, 52, 
	52, 358, -1, 359, 52, 52, 52, 52, 52, 52, 367, 368, 52, 370, 52, 52, -1, 
	373, 52, 52, 52, 377, 52, 379, 380, -1, 381, 52, 52, 52, 52, 386, 52, 52, 
	52, -1, 52, 52, 52, -1, 52, -1, -1, 394, 52, 52, 52, 398, 399, -1, -1, 
	400, 401, 52, 52, 405, 52, 52, -1, -1, -1, 408, 409, -1, 52, 411, 52, 52, 
	52, 52, 416, -1, 417, 52, 419, -1, -1, 420, 52, 52, 52, 424, 52, 426, -1, 
	-1, 427, -1, 52, 429, -1, 52, 52, 52, -1, 433, -1, -1, -1, 52, 52, 52, 
	52, -1, 438, 52, 440, 52, 52, 443, 52, -1, 52, 52, 447, -1, -1, -1, -1, 
	448, 52, 52, -1, 451, 52, -1, -1, 453, -1, 52, 52, 456, 457, -1, -1, 52, 
	-1, -1, 459, 52, 461, -1, 462, -1, -1, 52, -1, 464, -1, 52, -1, 52, 467, 
	52, 470, -1, 471, -1, 472, 473, -1, 52, 52, 52, -1, -1, 52, 478, -1, 52, 
	-1, 52, 52, -1, -1, 482, -1, 483, -1, -1, 52, -1, 52, 486, -1, 487, 52, 
	-1, -1, -1, -1, 489, 52, 52, 52, -1, 52, 494, 495, -1, -1, 52, 497, -1, 
	-1, 52, -1, 499, 500, 52, 502, -1, -1, 503, -1, 52, -1, -1, 505, -1, -1, 
	52, -1, 52, 52, 52, 510, -1
    };
static const ANTLR_INT32 dfa39_eof[511] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa39_min[511] =
    {
	9, 46, 39, 39, 39, 48, -1, 39, -1, -1, -1, -1, -1, 42, -1, -1, 42, 33, 
	34, -1, -1, 61, 61, 61, 61, 61, 124, -1, -1, -1, -1, -1, 73, 76, 39, 65, 
	65, 76, 65, 79, 65, 68, 73, 73, 39, 70, 69, 69, 65, 78, 65, 72, -1, -1, 
	46, -1, 67, 76, 71, 35, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 73, 66, 86, 76, 68, 35, 83, 69, 85, 
	76, 65, 82, 84, 67, 83, 79, 83, 68, 67, 76, 84, 82, 79, 84, 65, 86, 69, 
	35, 35, 35, 75, 67, 78, 68, 35, 35, 84, 35, 69, 83, 76, 65, 90, 65, 66, 
	69, 35, 85, 73, 68, 73, 76, 69, 69, 84, -1, 79, 35, 65, 76, 73, 87, -1, 
	67, 79, 76, 79, 35, 69, 35, 35, 35, -1, 69, 67, 83, 65, 80, 78, 83, 65, 
	82, 69, 76, 65, 69, 67, 84, 80, 69, 35, 69, 83, 83, 67, 35, 77, 79, 78, 
	85, 73, 78, -1, 69, 69, 69, -1, -1, 69, 75, 85, 69, -1, -1, 73, 69, -1, 
	82, 79, 79, 69, 82, 69, 82, 65, 35, -1, 69, 79, 73, 65, 78, 85, 87, 78, 
	72, 77, -1, 73, 35, 78, 69, 80, 69, 82, 73, 84, -1, 82, -1, -1, -1, 35, 
	75, 84, 85, 82, 69, 72, 84, 69, 79, 35, 65, 85, 84, 35, 73, 35, 35, 70, 
	-1, 80, 85, 84, 69, 72, -1, 35, 35, 84, 80, 78, 84, 88, 82, 82, 35, 35, 
	35, 83, 35, 79, 82, 76, 85, 75, 67, 69, 35, 84, 85, 69, 35, -1, 35, 78, 
	85, 86, 84, 71, 69, 35, 35, 69, 35, 80, 84, -1, 35, 69, 84, 68, 35, 67, 
	35, 35, -1, 35, 69, 84, 69, 67, 35, 69, 78, 82, -1, 82, 76, 69, -1, 78, 
	-1, -1, 35, 84, 83, 83, 35, 35, -1, -1, 35, 35, 71, 73, 35, 84, 83, -1, 
	-1, -1, 35, 35, -1, 78, 35, 65, 82, 69, 84, 35, -1, 35, 84, 35, -1, -1, 
	35, 69, 79, 69, 35, 83, 35, -1, -1, 35, -1, 82, 35, -1, 78, 9, 85, -1, 
	35, -1, -1, -1, 82, 72, 83, 84, -1, 35, 84, 35, 69, 84, 35, 67, -1, 73, 
	73, 35, -1, -1, -1, -1, 35, 70, 83, -1, 35, 69, -1, -1, 35, -1, 80, 67, 
	35, 35, -1, -1, 72, -1, -1, 35, 84, 35, -1, 35, -1, -1, 69, -1, 35, -1, 
	82, -1, 83, 35, 83, 35, -1, 35, -1, 35, 35, -1, 84, 79, 86, -1, -1, 73, 
	35, -1, 67, -1, 83, 69, -1, -1, 35, -1, 35, -1, -1, 83, -1, 69, 35, -1, 
	35, 66, -1, -1, -1, -1, 35, 78, 69, 69, -1, 84, 35, 35, -1, -1, 83, 35, 
	-1, -1, 89, -1, 35, 35, 68, 35, -1, -1, 35, -1, 95, -1, -1, 35, -1, -1, 
	82, -1, 79, 79, 84, 35, -1
    };
static const ANTLR_INT32 dfa39_max[511] =
    {
	126, 57, 85, 89, 39, 57, -1, 39, -1, -1, -1, -1, -1, 42, -1, -1, 42, 33, 
	122, -1, -1, 62, 61, 61, 61, 61, 124, -1, -1, -1, -1, -1, 85, 83, 39, 85, 
	82, 88, 82, 82, 65, 83, 79, 79, 39, 86, 69, 84, 82, 83, 73, 73, -1, -1, 
	57, -1, 87, 76, 84, 122, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 79, 66, 86, 84, 89, 122, 83, 69, 85, 
	78, 69, 82, 84, 83, 83, 79, 83, 68, 73, 76, 84, 82, 79, 84, 79, 86, 69, 
	122, 122, 122, 75, 67, 78, 68, 122, 122, 84, 122, 69, 86, 76, 65, 90, 65, 
	66, 69, 122, 85, 80, 68, 73, 76, 69, 69, 84, -1, 79, 122, 65, 76, 73, 87, 
	-1, 77, 79, 76, 79, 122, 69, 122, 122, 122, -1, 69, 67, 83, 65, 80, 78, 
	83, 65, 83, 69, 76, 65, 69, 67, 84, 80, 73, 122, 76, 83, 83, 67, 122, 77, 
	79, 78, 85, 73, 78, -1, 69, 69, 79, -1, -1, 69, 75, 85, 69, -1, -1, 73, 
	69, -1, 82, 79, 79, 69, 82, 69, 82, 76, 122, -1, 69, 81, 73, 65, 78, 85, 
	87, 82, 72, 77, -1, 73, 122, 78, 69, 80, 69, 82, 73, 84, -1, 82, -1, -1, 
	-1, 122, 75, 84, 85, 82, 69, 72, 84, 69, 79, 122, 65, 85, 84, 122, 73, 
	122, 122, 70, -1, 80, 85, 84, 69, 72, -1, 122, 122, 84, 80, 78, 84, 88, 
	82, 82, 122, 122, 122, 83, 122, 79, 82, 76, 85, 75, 67, 69, 122, 84, 85, 
	69, 122, -1, 122, 78, 85, 86, 84, 71, 69, 122, 122, 69, 122, 80, 84, -1, 
	122, 69, 84, 68, 122, 67, 122, 122, -1, 122, 69, 84, 69, 67, 122, 69, 78, 
	82, -1, 82, 76, 69, -1, 78, -1, -1, 122, 84, 83, 83, 122, 122, -1, -1, 
	122, 122, 71, 73, 122, 84, 83, -1, -1, -1, 122, 122, -1, 78, 122, 65, 82, 
	69, 84, 122, -1, 122, 84, 122, -1, -1, 122, 69, 79, 69, 122, 83, 122, -1, 
	-1, 122, -1, 82, 122, -1, 78, 32, 85, -1, 122, -1, -1, -1, 82, 72, 83, 
	84, -1, 122, 84, 122, 69, 84, 122, 67, -1, 73, 73, 122, -1, -1, -1, -1, 
	122, 70, 83, -1, 122, 69, -1, -1, 122, -1, 80, 67, 122, 122, -1, -1, 72, 
	-1, -1, 122, 84, 122, -1, 122, -1, -1, 69, -1, 122, -1, 82, -1, 83, 122, 
	83, 122, -1, 122, -1, 122, 122, -1, 84, 79, 86, -1, -1, 73, 122, -1, 67, 
	-1, 83, 69, -1, -1, 122, -1, 122, -1, -1, 83, -1, 69, 122, -1, 122, 66, 
	-1, -1, -1, -1, 122, 78, 69, 69, -1, 84, 122, 122, -1, -1, 83, 122, -1, 
	-1, 89, -1, 122, 122, 68, 122, -1, -1, 122, -1, 95, -1, -1, 122, -1, -1, 
	82, -1, 79, 79, 84, 122, -1
    };
static const ANTLR_INT32 dfa39_accept[511] =
    {
	-1, -1, -1, -1, -1, -1, 7, -1, 9, 10, 11, 12, 13, -1, 16, 17, -1, -1, -1, 
	21, 23, -1, -1, -1, -1, -1, -1, 34, 35, 36, 37, 38, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 132, 6, -1, 
	2, -1, -1, -1, -1, 3, 4, 5, 8, 14, 15, 18, 133, 19, 20, 22, 24, 27, 25, 
	26, 31, 30, 28, 29, 32, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, 48, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 44, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 81, -1, -1, -1, 82, 88, -1, -1, -1, -1, 97, 98, -1, -1, 100, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 116, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	94, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, -1, 42, 43, 45, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 68, -1, 
	-1, -1, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 114, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 96, -1, -1, -1, -1, -1, -1, -1, -1, 
	49, -1, -1, -1, -1, -1, -1, -1, -1, -1, 60, -1, -1, -1, 64, -1, 66, 67, 
	-1, -1, -1, -1, -1, -1, 75, 76, -1, -1, -1, -1, -1, -1, -1, 87, 89, 90, 
	-1, -1, 92, -1, -1, -1, -1, -1, -1, -1, 110, -1, -1, -1, 115, 117, -1, 
	-1, -1, -1, -1, -1, -1, 122, 124, -1, 126, -1, -1, 46, -1, -1, -1, 103, 
	-1, 130, 41, 50, -1, -1, -1, -1, 56, -1, -1, -1, -1, -1, -1, -1, 129, -1, 
	-1, -1, 72, 73, 77, 78, -1, -1, -1, 83, -1, -1, 91, 128, -1, 101, -1, -1, 
	-1, -1, 109, 111, -1, 113, 118, -1, -1, -1, 127, -1, 123, 125, -1, 95, 
	-1, 39, -1, 105, -1, -1, -1, -1, 57, -1, 59, -1, -1, 63, -1, -1, -1, 71, 
	79, -1, -1, 85, -1, 99, -1, -1, 107, 108, -1, 119, -1, 120, 121, -1, 47, 
	-1, -1, 52, -1, -1, 54, 58, 61, 62, -1, -1, -1, -1, 84, -1, -1, -1, 112, 
	131, -1, -1, 51, 53, -1, 65, -1, -1, -1, -1, 102, 106, -1, 104, -1, 69, 
	70, -1, 86, 93, -1, 80, -1, -1, -1, -1, 55
    };
static const ANTLR_INT32 dfa39_special[511] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa39_T_empty	 =   NULL;

static const ANTLR_INT32 dfa39_T0[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa39_T1[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 196, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa39_T2[] =
    {
	19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 
	19, 19, 19, 19, 19, 19, -1, -1, -1, 69, -1, -1, -1, 19, 19, 19, 19, 19, 
	19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19, 19, 19, 19, 19, 
	19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19
    };

static const ANTLR_INT32 dfa39_T3[] =
    {
	199, -1, -1, 200
    };

static const ANTLR_INT32 dfa39_T4[] =
    {
	192
    };

static const ANTLR_INT32 dfa39_T5[] =
    {
	137, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 138, 
	-1, -1, 139
    };

static const ANTLR_INT32 dfa39_T6[] =
    {
	272
    };

static const ANTLR_INT32 dfa39_T7[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 345, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa39_T8[] =
    {
	141, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 142
    };

static const ANTLR_INT32 dfa39_T9[] =
    {
	157, 158, 159
    };

static const ANTLR_INT32 dfa39_T10[] =
    {
	205
    };

static const ANTLR_INT32 dfa39_T11[] =
    {
	282, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 283
    };

static const ANTLR_INT32 dfa39_T12[] =
    {
	206
    };

static const ANTLR_INT32 dfa39_T13[] =
    {
	160, -1, -1, -1, 161
    };

static const ANTLR_INT32 dfa39_T14[] =
    {
	437
    };

static const ANTLR_INT32 dfa39_T15[] =
    {
	385
    };

static const ANTLR_INT32 dfa39_T16[] =
    {
	313
    };

static const ANTLR_INT32 dfa39_T17[] =
    {
	238
    };

static const ANTLR_INT32 dfa39_T18[] =
    {
	287, -1, 288
    };

static const ANTLR_INT32 dfa39_T19[] =
    {
	97, -1, 98, -1, -1, -1, -1, -1, -1, -1, -1, -1, 99
    };

static const ANTLR_INT32 dfa39_T20[] =
    {
	234
    };

static const ANTLR_INT32 dfa39_T21[] =
    {
	326
    };

static const ANTLR_INT32 dfa39_T22[] =
    {
	155
    };

static const ANTLR_INT32 dfa39_T23[] =
    {
	233
    };

static const ANTLR_INT32 dfa39_T24[] =
    {
	235
    };

static const ANTLR_INT32 dfa39_T25[] =
    {
	306
    };

static const ANTLR_INT32 dfa39_T26[] =
    {
	227
    };

static const ANTLR_INT32 dfa39_T27[] =
    {
	156
    };

static const ANTLR_INT32 dfa39_T28[] =
    {
	147
    };

static const ANTLR_INT32 dfa39_T29[] =
    {
	309
    };

static const ANTLR_INT32 dfa39_T30[] =
    {
	289
    };

static const ANTLR_INT32 dfa39_T31[] =
    {
	362
    };

static const ANTLR_INT32 dfa39_T32[] =
    {
	434
    };

static const ANTLR_INT32 dfa39_T33[] =
    {
	466
    };

static const ANTLR_INT32 dfa39_T34[] =
    {
	72
    };

static const ANTLR_INT32 dfa39_T35[] =
    {
	310
    };

static const ANTLR_INT32 dfa39_T36[] =
    {
	422
    };

static const ANTLR_INT32 dfa39_T37[] =
    {
	460
    };

static const ANTLR_INT32 dfa39_T38[] =
    {
	382
    };

static const ANTLR_INT32 dfa39_T39[] =
    {
	383
    };

static const ANTLR_INT32 dfa39_T40[] =
    {
	435
    };

static const ANTLR_INT32 dfa39_T41[] =
    {
	236
    };

static const ANTLR_INT32 dfa39_T42[] =
    {
	311
    };

static const ANTLR_INT32 dfa39_T43[] =
    {
	31
    };

static const ANTLR_INT32 dfa39_T44[] =
    {
	221
    };

static const ANTLR_INT32 dfa39_T45[] =
    {
	300
    };

static const ANTLR_INT32 dfa39_T46[] =
    {
	430
    };

static const ANTLR_INT32 dfa39_T47[] =
    {
	222
    };

static const ANTLR_INT32 dfa39_T48[] =
    {
	301
    };

static const ANTLR_INT32 dfa39_T49[] =
    {
	374
    };

static const ANTLR_INT32 dfa39_T50[] =
    {
	113, -1, -1, -1, -1, -1, 114
    };

static const ANTLR_INT32 dfa39_T51[] =
    {
	154
    };

static const ANTLR_INT32 dfa39_T52[] =
    {
	508
    };

static const ANTLR_INT32 dfa39_T53[] =
    {
	507
    };

static const ANTLR_INT32 dfa39_T54[] =
    {
	506
    };

static const ANTLR_INT32 dfa39_T55[] =
    {
	504
    };

static const ANTLR_INT32 dfa39_T56[] =
    {
	425
    };

static const ANTLR_INT32 dfa39_T57[] =
    {
	365
    };

static const ANTLR_INT32 dfa39_T58[] =
    {
	292
    };

static const ANTLR_INT32 dfa39_T59[] =
    {
	213
    };

static const ANTLR_INT32 dfa39_T60[] =
    {
	509
    };

static const ANTLR_INT32 dfa39_T61[] =
    {
	239
    };

static const ANTLR_INT32 dfa39_T62[] =
    {
	314
    };

static const ANTLR_INT32 dfa39_T63[] =
    {
	240
    };

static const ANTLR_INT32 dfa39_T64[] =
    {
	315
    };

static const ANTLR_INT32 dfa39_T65[] =
    {
	387
    };

static const ANTLR_INT32 dfa39_T66[] =
    {
	388
    };

static const ANTLR_INT32 dfa39_T67[] =
    {
	439
    };

static const ANTLR_INT32 dfa39_T68[] =
    {
	316
    };

static const ANTLR_INT32 dfa39_T69[] =
    {
	31, 31, -1, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 31, 23, 8, -1, -1, 9, 10, 6, 11, 12, 13, 14, 15, 31, 
	5, 16, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 18, 20, 21, 27, 22, 19, 17, 33, 3, 
	35, 36, 37, 38, 39, 40, 41, 52, 52, 42, 43, 2, 45, 32, 7, 46, 47, 48, 49, 
	50, 51, 4, 52, 52, 28, -1, 29, 24, 30, -1, 52, 34, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 44, 52, 52, 7, 52, 52, 52, 52, 52, 52, 4, 52, 52, 
	-1, 26, -1, 25
    };

static const ANTLR_INT32 dfa39_T70[] =
    {
	312
    };

static const ANTLR_INT32 dfa39_T71[] =
    {
	237
    };

static const ANTLR_INT32 dfa39_T72[] =
    {
	436
    };

static const ANTLR_INT32 dfa39_T73[] =
    {
	369
    };

static const ANTLR_INT32 dfa39_T74[] =
    {
	384
    };

static const ANTLR_INT32 dfa39_T75[] =
    {
	468
    };

static const ANTLR_INT32 dfa39_T76[] =
    {
	212
    };

static const ANTLR_INT32 dfa39_T77[] =
    {
	296
    };

static const ANTLR_INT32 dfa39_T78[] =
    {
	216
    };

static const ANTLR_INT32 dfa39_T79[] =
    {
	431, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 431
    };

static const ANTLR_INT32 dfa39_T80[] =
    {
	291
    };

static const ANTLR_INT32 dfa39_T81[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 284, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa39_T82[] =
    {
	364
    };

static const ANTLR_INT32 dfa39_T83[] =
    {
	488
    };

static const ANTLR_INT32 dfa39_T84[] =
    {
	498
    };

static const ANTLR_INT32 dfa39_T85[] =
    {
	170
    };

static const ANTLR_INT32 dfa39_T86[] =
    {
	148, -1, -1, -1, -1, -1, -1, -1, 149
    };

static const ANTLR_INT32 dfa39_T87[] =
    {
	250, -1, -1, -1, 251
    };

static const ANTLR_INT32 dfa39_T88[] =
    {
	375
    };

static const ANTLR_INT32 dfa39_T89[] =
    {
	302
    };

static const ANTLR_INT32 dfa39_T90[] =
    {
	209, -1, -1, -1, -1, -1, -1, 210
    };

static const ANTLR_INT32 dfa39_T91[] =
    {
	79
    };

static const ANTLR_INT32 dfa39_T92[] =
    {
	150, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 151
    };

static const ANTLR_INT32 dfa39_T93[] =
    {
	229
    };

static const ANTLR_INT32 dfa39_T94[] =
    {
	307
    };

static const ANTLR_INT32 dfa39_T95[] =
    {
	87, -1, -1, -1, -1, -1, -1, 88, -1, -1, -1, 89, -1, -1, 90, -1, -1, 91, 
	-1, -1, 92
    };

static const ANTLR_INT32 dfa39_T96[] =
    {
	115, -1, -1, -1, -1, -1, -1, -1, 116, -1, 117, -1, 118, -1, -1, -1, 119
    };

static const ANTLR_INT32 dfa39_T97[] =
    {
	84, -1, 85, -1, -1, -1, -1, 86
    };

static const ANTLR_INT32 dfa39_T98[] =
    {
	54, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    };

static const ANTLR_INT32 dfa39_T99[] =
    {
	74
    };

static const ANTLR_INT32 dfa39_T100[] =
    {
	145, -1, -1, -1, -1, -1, 144
    };

static const ANTLR_INT32 dfa39_T101[] =
    {
	376
    };

static const ANTLR_INT32 dfa39_T102[] =
    {
	432
    };

static const ANTLR_INT32 dfa39_T103[] =
    {
	303
    };

static const ANTLR_INT32 dfa39_T104[] =
    {
	146
    };

static const ANTLR_INT32 dfa39_T105[] =
    {
	465
    };

static const ANTLR_INT32 dfa39_T106[] =
    {
	485
    };

static const ANTLR_INT32 dfa39_T107[] =
    {
	55
    };

static const ANTLR_INT32 dfa39_T108[] =
    {
	480
    };

static const ANTLR_INT32 dfa39_T109[] =
    {
	454
    };

static const ANTLR_INT32 dfa39_T110[] =
    {
	412
    };

static const ANTLR_INT32 dfa39_T111[] =
    {
	349
    };

static const ANTLR_INT32 dfa39_T112[] =
    {
	275
    };

static const ANTLR_INT32 dfa39_T113[] =
    {
	198
    };

static const ANTLR_INT32 dfa39_T114[] =
    {
	136, -1, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53
    };

static const ANTLR_INT32 dfa39_T115[] =
    {
	304
    };

static const ANTLR_INT32 dfa39_T116[] =
    {
	225
    };

static const ANTLR_INT32 dfa39_T117[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 366, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa39_T118[] =
    {
	274
    };

static const ANTLR_INT32 dfa39_T119[] =
    {
	348
    };

static const ANTLR_INT32 dfa39_T120[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 152, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa39_T121[] =
    {
	410
    };

static const ANTLR_INT32 dfa39_T122[] =
    {
	347
    };

static const ANTLR_INT32 dfa39_T123[] =
    {
	107, -1, 108, -1, -1, -1, -1, -1, -1, -1, 109, -1, -1, -1, -1, 110
    };

static const ANTLR_INT32 dfa39_T124[] =
    {
	273
    };

static const ANTLR_INT32 dfa39_T125[] =
    {
	195
    };

static const ANTLR_INT32 dfa39_T126[] =
    {
	298
    };

static const ANTLR_INT32 dfa39_T127[] =
    {
	372
    };

static const ANTLR_INT32 dfa39_T128[] =
    {
	219
    };

static const ANTLR_INT32 dfa39_T129[] =
    {
	220
    };

static const ANTLR_INT32 dfa39_T130[] =
    {
	140
    };

static const ANTLR_INT32 dfa39_T131[] =
    {
	111, -1, -1, -1, -1, -1, 112
    };

static const ANTLR_INT32 dfa39_T132[] =
    {
	484
    };

static const ANTLR_INT32 dfa39_T133[] =
    {
	463
    };

static const ANTLR_INT32 dfa39_T134[] =
    {
	428
    };

static const ANTLR_INT32 dfa39_T135[] =
    {
	371
    };

static const ANTLR_INT32 dfa39_T136[] =
    {
	496
    };

static const ANTLR_INT32 dfa39_T137[] =
    {
	104, -1, -1, 105
    };

static const ANTLR_INT32 dfa39_T138[] =
    {
	344
    };

static const ANTLR_INT32 dfa39_T139[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 404, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa39_T140[] =
    {
	63
    };

static const ANTLR_INT32 dfa39_T141[] =
    {
	217
    };

static const ANTLR_INT32 dfa39_T142[] =
    {
	297
    };

static const ANTLR_INT32 dfa39_T143[] =
    {
	269
    };

static const ANTLR_INT32 dfa39_T144[] =
    {
	179, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 180
    };

static const ANTLR_INT32 dfa39_T145[] =
    {
	189
    };

static const ANTLR_INT32 dfa39_T146[] =
    {
	64
    };

static const ANTLR_INT32 dfa39_T147[] =
    {
	190
    };

static const ANTLR_INT32 dfa39_T148[] =
    {
	270
    };

static const ANTLR_INT32 dfa39_T149[] =
    {
	271
    };

static const ANTLR_INT32 dfa39_T150[] =
    {
	191
    };

static const ANTLR_INT32 dfa39_T151[] =
    {
	338
    };

static const ANTLR_INT32 dfa39_T152[] =
    {
	423
    };

static const ANTLR_INT32 dfa39_T153[] =
    {
	363
    };

static const ANTLR_INT32 dfa39_T154[] =
    {
	290
    };

static const ANTLR_INT32 dfa39_T155[] =
    {
	211
    };

static const ANTLR_INT32 dfa39_T156[] =
    {
	421
    };

static const ANTLR_INT32 dfa39_T157[] =
    {
	361
    };

static const ANTLR_INT32 dfa39_T158[] =
    {
	360
    };

static const ANTLR_INT32 dfa39_T159[] =
    {
	129, -1, 130, -1, -1, 131
    };

static const ANTLR_INT32 dfa39_T160[] =
    {
	265
    };

static const ANTLR_INT32 dfa39_T161[] =
    {
	208
    };

static const ANTLR_INT32 dfa39_T162[] =
    {
	286
    };

static const ANTLR_INT32 dfa39_T163[] =
    {
	55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 56, -1, -1, -1, -1, -1, 57
    };

static const ANTLR_INT32 dfa39_T164[] =
    {
	172, -1, -1, -1, -1, -1, 173
    };

static const ANTLR_INT32 dfa39_T165[] =
    {
	357
    };

static const ANTLR_INT32 dfa39_T166[] =
    {
	61
    };

static const ANTLR_INT32 dfa39_T167[] =
    {
	458
    };

static const ANTLR_INT32 dfa39_T168[] =
    {
	418
    };

static const ANTLR_INT32 dfa39_T169[] =
    {
	356
    };

static const ANTLR_INT32 dfa39_T170[] =
    {
	53, 53, 53, 53, 53, 53, 53, 53, 53, 53
    };

static const ANTLR_INT32 dfa39_T171[] =
    {
	355
    };

static const ANTLR_INT32 dfa39_T172[] =
    {
	281
    };

static const ANTLR_INT32 dfa39_T173[] =
    {
	204
    };

static const ANTLR_INT32 dfa39_T174[] =
    {
	106
    };

static const ANTLR_INT32 dfa39_T175[] =
    {
	280
    };

static const ANTLR_INT32 dfa39_T176[] =
    {
	203
    };

static const ANTLR_INT32 dfa39_T177[] =
    {
	279
    };

static const ANTLR_INT32 dfa39_T178[] =
    {
	353
    };

static const ANTLR_INT32 dfa39_T179[] =
    {
	267, -1, -1, -1, -1, -1, -1, -1, -1, -1, 268
    };

static const ANTLR_INT32 dfa39_T180[] =
    {
	202
    };

static const ANTLR_INT32 dfa39_T181[] =
    {
	278
    };

static const ANTLR_INT32 dfa39_T182[] =
    {
	201
    };

static const ANTLR_INT32 dfa39_T183[] =
    {
	415
    };

static const ANTLR_INT32 dfa39_T184[] =
    {
	352
    };

static const ANTLR_INT32 dfa39_T185[] =
    {
	351
    };

static const ANTLR_INT32 dfa39_T186[] =
    {
	125, -1, -1, -1, -1, -1, -1, 126, -1, -1, -1, -1, -1, -1, 127, -1, -1, 
	128
    };

static const ANTLR_INT32 dfa39_T187[] =
    {
	277
    };

static const ANTLR_INT32 dfa39_T188[] =
    {
	414
    };

static const ANTLR_INT32 dfa39_T189[] =
    {
	276
    };

static const ANTLR_INT32 dfa39_T190[] =
    {
	350
    };

static const ANTLR_INT32 dfa39_T191[] =
    {
	413
    };

static const ANTLR_INT32 dfa39_T192[] =
    {
	455
    };

static const ANTLR_INT32 dfa39_T193[] =
    {
	67
    };

static const ANTLR_INT32 dfa39_T194[] =
    {
	481
    };

static const ANTLR_INT32 dfa39_T195[] =
    {
	226
    };

static const ANTLR_INT32 dfa39_T196[] =
    {
	305
    };

static const ANTLR_INT32 dfa39_T197[] =
    {
	378
    };

static const ANTLR_INT32 dfa39_T198[] =
    {
	164, -1, -1, 165, -1, -1, -1, -1, -1, 166, -1, -1, -1, -1, -1, -1, 167
    };

static const ANTLR_INT32 dfa39_T199[] =
    {
	396
    };

static const ANTLR_INT32 dfa39_T200[] =
    {
	328
    };

static const ANTLR_INT32 dfa39_T201[] =
    {
	476
    };

static const ANTLR_INT32 dfa39_T202[] =
    {
	446
    };

static const ANTLR_INT32 dfa39_T203[] =
    {
	491
    };

static const ANTLR_INT32 dfa39_T204[] =
    {
	255
    };

static const ANTLR_INT32 dfa39_T205[] =
    {
	329
    };

static const ANTLR_INT32 dfa39_T206[] =
    {
	397
    };

static const ANTLR_INT32 dfa39_T207[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 469, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa39_T208[] =
    {
	174
    };

static const ANTLR_INT32 dfa39_T209[] =
    {
	256
    };

static const ANTLR_INT32 dfa39_T210[] =
    {
	330
    };

static const ANTLR_INT32 dfa39_T211[] =
    {
	162
    };

static const ANTLR_INT32 dfa39_T212[] =
    {
	249
    };

static const ANTLR_INT32 dfa39_T213[] =
    {
	100, -1, -1, -1, 101, -1, -1, -1, -1, -1, -1, -1, -1, -1, 102, -1, -1, 
	103
    };

static const ANTLR_INT32 dfa39_T214[] =
    {
	132, -1, -1, -1, -1, -1, -1, -1, 133
    };

static const ANTLR_INT32 dfa39_T215[] =
    {
	169
    };

static const ANTLR_INT32 dfa39_T216[] =
    {
	241, 242
    };

static const ANTLR_INT32 dfa39_T217[] =
    {
	52, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, 184, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 185, 186, 52, 52, 52, 52, 
	52, 52, -1, -1, -1, -1, 52, -1, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR_INT32 dfa39_T218[] =
    {
	171
    };

static const ANTLR_INT32 dfa39_T219[] =
    {
	490
    };

static const ANTLR_INT32 dfa39_T220[] =
    {
	445
    };

static const ANTLR_INT32 dfa39_T221[] =
    {
	475
    };

static const ANTLR_INT32 dfa39_T222[] =
    {
	327
    };

static const ANTLR_INT32 dfa39_T223[] =
    {
	395
    };

static const ANTLR_INT32 dfa39_T224[] =
    {
	83, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, -1, 82
    };

static const ANTLR_INT32 dfa39_T225[] =
    {
	320
    };

static const ANTLR_INT32 dfa39_T226[] =
    {
	245
    };

static const ANTLR_INT32 dfa39_T227[] =
    {
	442
    };

static const ANTLR_INT32 dfa39_T228[] =
    {
	391
    };

static const ANTLR_INT32 dfa39_T229[] =
    {
	120
    };

static const ANTLR_INT32 dfa39_T230[] =
    {
	321
    };

static const ANTLR_INT32 dfa39_T231[] =
    {
	246
    };

static const ANTLR_INT32 dfa39_T232[] =
    {
	392
    };

static const ANTLR_INT32 dfa39_T233[] =
    {
	247
    };

static const ANTLR_INT32 dfa39_T234[] =
    {
	168
    };

static const ANTLR_INT32 dfa39_T235[] =
    {
	248
    };

static const ANTLR_INT32 dfa39_T236[] =
    {
	323
    };

static const ANTLR_INT32 dfa39_T237[] =
    {
	393
    };

static const ANTLR_INT32 dfa39_T238[] =
    {
	444
    };

static const ANTLR_INT32 dfa39_T239[] =
    {
	474
    };

static const ANTLR_INT32 dfa39_T240[] =
    {
	134, 135
    };

static const ANTLR_INT32 dfa39_T241[] =
    {
	317
    };

static const ANTLR_INT32 dfa39_T242[] =
    {
	389
    };

static const ANTLR_INT32 dfa39_T243[] =
    {
	243
    };

static const ANTLR_INT32 dfa39_T244[] =
    {
	163
    };

static const ANTLR_INT32 dfa39_T245[] =
    {
	60, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 59
    };

static const ANTLR_INT32 dfa39_T246[] =
    {
	244
    };

static const ANTLR_INT32 dfa39_T247[] =
    {
	319
    };

static const ANTLR_INT32 dfa39_T248[] =
    {
	390
    };

static const ANTLR_INT32 dfa39_T249[] =
    {
	441
    };

static const ANTLR_INT32 dfa39_T250[] =
    {
	60
    };

static const ANTLR_INT32 dfa39_T251[] =
    {
	452
    };

static const ANTLR_INT32 dfa39_T252[] =
    {
	479
    };

static const ANTLR_INT32 dfa39_T253[] =
    {
	493
    };

static const ANTLR_INT32 dfa39_T254[] =
    {
	340
    };

static const ANTLR_INT32 dfa39_T255[] =
    {
	407
    };

static const ANTLR_INT32 dfa39_T256[] =
    {
	266
    };

static const ANTLR_INT32 dfa39_T257[] =
    {
	339
    };

static const ANTLR_INT32 dfa39_T258[] =
    {
	224, -1, -1, -1, -1, -1, -1, -1, -1, -1, 223
    };

static const ANTLR_INT32 dfa39_T259[] =
    {
	406
    };

static const ANTLR_INT32 dfa39_T260[] =
    {
	71, 72
    };

static const ANTLR_INT32 dfa39_T261[] =
    {
	294, -1, -1, -1, 295
    };

static const ANTLR_INT32 dfa39_T262[] =
    {
	215
    };

static const ANTLR_INT32 dfa39_T263[] =
    {
	450
    };

static const ANTLR_INT32 dfa39_T264[] =
    {
	181
    };

static const ANTLR_INT32 dfa39_T265[] =
    {
	263
    };

static const ANTLR_INT32 dfa39_T266[] =
    {
	336
    };

static const ANTLR_INT32 dfa39_T267[] =
    {
	262
    };

static const ANTLR_INT32 dfa39_T268[] =
    {
	335
    };

static const ANTLR_INT32 dfa39_T269[] =
    {
	403
    };

static const ANTLR_INT32 dfa39_T270[] =
    {
	337
    };

static const ANTLR_INT32 dfa39_T271[] =
    {
	477
    };

static const ANTLR_INT32 dfa39_T272[] =
    {
	449
    };

static const ANTLR_INT32 dfa39_T273[] =
    {
	501
    };

static const ANTLR_INT32 dfa39_T274[] =
    {
	492
    };

static const ANTLR_INT32 dfa39_T275[] =
    {
	214
    };

static const ANTLR_INT32 dfa39_T276[] =
    {
	293
    };

static const ANTLR_INT32 dfa39_T277[] =
    {
	402
    };

static const ANTLR_INT32 dfa39_T278[] =
    {
	264
    };

static const ANTLR_INT32 dfa39_T279[] =
    {
	182
    };

static const ANTLR_INT32 dfa39_T280[] =
    {
	176
    };

static const ANTLR_INT32 dfa39_T281[] =
    {
	177
    };

static const ANTLR_INT32 dfa39_T282[] =
    {
	257
    };

static const ANTLR_INT32 dfa39_T283[] =
    {
	331
    };

static const ANTLR_INT32 dfa39_T284[] =
    {
	175
    };

static const ANTLR_INT32 dfa39_T285[] =
    {
	93, -1, -1, -1, 94, -1, -1, -1, 95, -1, -1, -1, -1, -1, -1, -1, -1, 96
    };

static const ANTLR_INT32 dfa39_T286[] =
    {
	253, -1, -1, -1, -1, -1, -1, 254
    };

static const ANTLR_INT32 dfa39_T287[] =
    {
	121, -1, -1, 122, 123, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 124
    };

static const ANTLR_INT32 dfa39_T288[] =
    {
	334
    };

static const ANTLR_INT32 dfa39_T289[] =
    {
	261
    };

static const ANTLR_INT32 dfa39_T290[] =
    {
	259
    };

static const ANTLR_INT32 dfa39_T291[] =
    {
	260
    };

static const ANTLR_INT32 dfa39_T292[] =
    {
	178
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa39_transitions[] =
{
    dfa39_T69, dfa39_T98, dfa39_T163, dfa39_T245, dfa39_T166, dfa39_T170, 
    NULL, dfa39_T140, NULL, NULL, NULL, NULL, NULL, dfa39_T146, NULL, NULL, 
    dfa39_T43, dfa39_T193, dfa39_T2, NULL, NULL, dfa39_T260, dfa39_T99, 
    dfa39_T34, dfa39_T34, dfa39_T34, dfa39_T91, NULL, NULL, NULL, NULL, 
    NULL, dfa39_T224, dfa39_T97, dfa39_T250, dfa39_T95, dfa39_T285, dfa39_T19, 
    dfa39_T213, dfa39_T137, dfa39_T174, dfa39_T123, dfa39_T131, dfa39_T50, 
    dfa39_T107, dfa39_T96, dfa39_T229, dfa39_T287, dfa39_T186, dfa39_T159, 
    dfa39_T214, dfa39_T240, NULL, NULL, dfa39_T114, NULL, dfa39_T5, dfa39_T130, 
    dfa39_T8, dfa39_T0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, dfa39_T100, dfa39_T104, dfa39_T28, dfa39_T86, dfa39_T92, dfa39_T120, 
    dfa39_T51, dfa39_T22, dfa39_T27, dfa39_T9, dfa39_T13, dfa39_T211, dfa39_T244, 
    dfa39_T198, dfa39_T234, dfa39_T215, dfa39_T85, dfa39_T218, dfa39_T164, 
    dfa39_T208, dfa39_T284, dfa39_T280, dfa39_T281, dfa39_T292, dfa39_T144, 
    dfa39_T264, dfa39_T279, dfa39_T0, dfa39_T217, dfa39_T0, dfa39_T145, 
    dfa39_T147, dfa39_T150, dfa39_T4, dfa39_T0, dfa39_T0, dfa39_T125, dfa39_T1, 
    dfa39_T113, dfa39_T3, dfa39_T182, dfa39_T180, dfa39_T176, dfa39_T173, 
    dfa39_T10, dfa39_T12, dfa39_T0, dfa39_T161, dfa39_T90, dfa39_T155, dfa39_T76, 
    dfa39_T59, dfa39_T275, dfa39_T262, dfa39_T78, NULL, dfa39_T141, dfa39_T0, 
    dfa39_T128, dfa39_T129, dfa39_T44, dfa39_T47, NULL, dfa39_T258, dfa39_T116, 
    dfa39_T195, dfa39_T26, dfa39_T0, dfa39_T93, dfa39_T0, dfa39_T0, dfa39_T0, 
    NULL, dfa39_T23, dfa39_T20, dfa39_T24, dfa39_T41, dfa39_T71, dfa39_T17, 
    dfa39_T61, dfa39_T63, dfa39_T216, dfa39_T243, dfa39_T246, dfa39_T226, 
    dfa39_T231, dfa39_T233, dfa39_T235, dfa39_T212, dfa39_T87, dfa39_T0, 
    dfa39_T286, dfa39_T204, dfa39_T209, dfa39_T282, dfa39_T0, dfa39_T290, 
    dfa39_T291, dfa39_T289, dfa39_T267, dfa39_T265, dfa39_T278, NULL, dfa39_T160, 
    dfa39_T256, dfa39_T179, NULL, NULL, dfa39_T143, dfa39_T148, dfa39_T149, 
    dfa39_T6, NULL, NULL, dfa39_T124, dfa39_T118, NULL, dfa39_T112, dfa39_T189, 
    dfa39_T187, dfa39_T181, dfa39_T177, dfa39_T175, dfa39_T172, dfa39_T11, 
    dfa39_T81, NULL, dfa39_T162, dfa39_T18, dfa39_T30, dfa39_T154, dfa39_T80, 
    dfa39_T58, dfa39_T276, dfa39_T261, dfa39_T77, dfa39_T142, NULL, dfa39_T126, 
    dfa39_T0, dfa39_T45, dfa39_T48, dfa39_T89, dfa39_T103, dfa39_T115, dfa39_T196, 
    dfa39_T25, NULL, dfa39_T94, NULL, NULL, NULL, dfa39_T0, dfa39_T29, dfa39_T35, 
    dfa39_T42, dfa39_T70, dfa39_T16, dfa39_T62, dfa39_T64, dfa39_T68, dfa39_T241, 
    dfa39_T0, dfa39_T247, dfa39_T225, dfa39_T230, dfa39_T0, dfa39_T236, 
    dfa39_T0, dfa39_T0, dfa39_T21, NULL, dfa39_T222, dfa39_T200, dfa39_T205, 
    dfa39_T210, dfa39_T283, NULL, dfa39_T0, dfa39_T0, dfa39_T288, dfa39_T268, 
    dfa39_T266, dfa39_T270, dfa39_T151, dfa39_T257, dfa39_T254, dfa39_T0, 
    dfa39_T0, dfa39_T0, dfa39_T138, dfa39_T7, dfa39_T122, dfa39_T119, dfa39_T111, 
    dfa39_T190, dfa39_T185, dfa39_T184, dfa39_T178, dfa39_T0, dfa39_T171, 
    dfa39_T169, dfa39_T165, dfa39_T0, NULL, dfa39_T0, dfa39_T158, dfa39_T157, 
    dfa39_T31, dfa39_T153, dfa39_T82, dfa39_T57, dfa39_T117, dfa39_T0, dfa39_T73, 
    dfa39_T0, dfa39_T135, dfa39_T127, NULL, dfa39_T0, dfa39_T49, dfa39_T88, 
    dfa39_T101, dfa39_T0, dfa39_T197, dfa39_T0, dfa39_T0, NULL, dfa39_T0, 
    dfa39_T38, dfa39_T39, dfa39_T74, dfa39_T15, dfa39_T0, dfa39_T65, dfa39_T66, 
    dfa39_T242, NULL, dfa39_T248, dfa39_T228, dfa39_T232, NULL, dfa39_T237, 
    NULL, NULL, dfa39_T0, dfa39_T223, dfa39_T199, dfa39_T206, dfa39_T0, 
    dfa39_T0, NULL, NULL, dfa39_T0, dfa39_T0, dfa39_T277, dfa39_T269, dfa39_T139, 
    dfa39_T259, dfa39_T255, NULL, NULL, NULL, dfa39_T0, dfa39_T0, NULL, 
    dfa39_T121, dfa39_T0, dfa39_T110, dfa39_T191, dfa39_T188, dfa39_T183, 
    dfa39_T0, NULL, dfa39_T0, dfa39_T168, dfa39_T0, NULL, NULL, dfa39_T0, 
    dfa39_T156, dfa39_T36, dfa39_T152, dfa39_T0, dfa39_T56, dfa39_T0, NULL, 
    NULL, dfa39_T0, NULL, dfa39_T134, dfa39_T0, NULL, dfa39_T46, dfa39_T79, 
    dfa39_T102, NULL, dfa39_T0, NULL, NULL, NULL, dfa39_T32, dfa39_T40, 
    dfa39_T72, dfa39_T14, NULL, dfa39_T0, dfa39_T67, dfa39_T0, dfa39_T249, 
    dfa39_T227, dfa39_T0, dfa39_T238, NULL, dfa39_T220, dfa39_T202, dfa39_T0, 
    NULL, NULL, NULL, NULL, dfa39_T0, dfa39_T272, dfa39_T263, NULL, dfa39_T0, 
    dfa39_T251, NULL, NULL, dfa39_T0, NULL, dfa39_T109, dfa39_T192, dfa39_T0, 
    dfa39_T0, NULL, NULL, dfa39_T167, NULL, NULL, dfa39_T0, dfa39_T37, dfa39_T0, 
    NULL, dfa39_T0, NULL, NULL, dfa39_T133, NULL, dfa39_T0, NULL, dfa39_T105, 
    NULL, dfa39_T33, dfa39_T0, dfa39_T75, dfa39_T207, NULL, dfa39_T0, NULL, 
    dfa39_T0, dfa39_T0, NULL, dfa39_T239, dfa39_T221, dfa39_T201, NULL, 
    NULL, dfa39_T271, dfa39_T0, NULL, dfa39_T252, NULL, dfa39_T108, dfa39_T194, 
    NULL, NULL, dfa39_T0, NULL, dfa39_T0, NULL, NULL, dfa39_T132, NULL, 
    dfa39_T106, dfa39_T0, NULL, dfa39_T0, dfa39_T83, NULL, NULL, NULL, NULL, 
    dfa39_T0, dfa39_T219, dfa39_T203, dfa39_T274, NULL, dfa39_T253, dfa39_T0, 
    dfa39_T0, NULL, NULL, dfa39_T136, dfa39_T0, NULL, NULL, dfa39_T84, NULL, 
    dfa39_T0, dfa39_T0, dfa39_T273, dfa39_T0, NULL, NULL, dfa39_T0, NULL, 
    dfa39_T55, NULL, NULL, dfa39_T0, NULL, NULL, dfa39_T54, NULL, dfa39_T53, 
    dfa39_T52, dfa39_T60, dfa39_T0, NULL
};


/* Declare tracking structure for Cyclic DFA 39
 */
class PLSQLLexerCyclicDFA39 : public CyclicDFA< PLSQLLexerImplTraits, PLSQLLexer >, public PLSQLLexerTokens
{
public:
	typedef CyclicDFA< PLSQLLexerImplTraits, PLSQLLexer >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	

public:
	PLSQLLexerCyclicDFA39( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		
	}

};

static PLSQLLexerCyclicDFA39  cdfa39(
	    39,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"1:1: Tokens : ( FOR_NOTATION | NATIONAL_CHAR_STRING_LIT | BIT_STRING_LIT | HEX_STRING_LIT | PERIOD | EXACT_NUM_LIT | CHAR_STRING | CHAR_STRING_PERL | DELIMITED_ID | PERCENT | AMPERSAND | LEFT_PAREN | RIGHT_PAREN | DOUBLE_ASTERISK | ASTERISK | PLUS_SIGN | COMMA | SOLIDUS | AT_SIGN | ASSIGN_OP | BINDVAR | COLON | SEMICOLON | LESS_THAN_OR_EQUALS_OP | LESS_THAN_OP | GREATER_THAN_OR_EQUALS_OP | NOT_EQUAL_OP | CARRET_OPERATOR_PART | TILDE_OPERATOR_PART | EXCLAMATION_OPERATOR_PART | GREATER_THAN_OP | CONCATENATION_OP | VERTICAL_BAR | EQUALS_OP | LEFT_BRACKET | RIGHT_BRACKET | INTRODUCER | SEPARATOR | PROMPT | SQL92_RESERVED_ALL | SQL92_RESERVED_ALTER | SQL92_RESERVED_AND | SQL92_RESERVED_ANY | SQL92_RESERVED_AS | SQL92_RESERVED_ASC | SQL92_RESERVED_BEGIN | SQL92_RESERVED_BETWEEN | SQL92_RESERVED_BY | SQL92_RESERVED_CASE | SQL92_RESERVED_CHECK | PLSQL_RESERVED_CLUSTERS | PLSQL_RESERVED_COLAUTH | PLSQL_RESERVED_COMPRESS | SQL92_RESERVED_CONNECT | PLSQL_NON_RESERVED_CONNECT_BY_ROOT | PLSQL_RESERVED_CRASH | SQL92_RESERVED_CREATE | SQL92_RESERVED_CURRENT | SQL92_RESERVED_CURSOR | SQL92_RESERVED_DATE | SQL92_RESERVED_DECLARE | SQL92_RESERVED_DEFAULT | SQL92_RESERVED_DELETE | SQL92_RESERVED_DESC | SQL92_RESERVED_DISTINCT | SQL92_RESERVED_DROP | SQL92_RESERVED_ELSE | SQL92_RESERVED_END | SQL92_RESERVED_EXCEPTION | PLSQL_RESERVED_EXCLUSIVE | SQL92_RESERVED_EXISTS | SQL92_RESERVED_FALSE | SQL92_RESERVED_FETCH | SQL92_RESERVED_FOR | SQL92_RESERVED_FROM | SQL92_RESERVED_GOTO | SQL92_RESERVED_GRANT | SQL92_RESERVED_GROUP | SQL92_RESERVED_HAVING | PLSQL_RESERVED_IDENTIFIED | PLSQL_RESERVED_IF | SQL92_RESERVED_IN | PLSQL_RESERVED_INDEX | PLSQL_RESERVED_INDEXES | SQL92_RESERVED_INSERT | SQL92_RESERVED_INTERSECT | SQL92_RESERVED_INTO | SQL92_RESERVED_IS | SQL92_RESERVED_LIKE | PLSQL_RESERVED_LOCK | PLSQL_RESERVED_MINUS | PLSQL_RESERVED_MODE | PLSQL_RESERVED_NOCOMPRESS | SQL92_RESERVED_NOT | PLSQL_RESERVED_NOWAIT | SQL92_RESERVED_NULL | SQL92_RESERVED_OF | SQL92_RESERVED_ON | SQL92_RESERVED_OPTION | SQL92_RESERVED_OR | SQL92_RESERVED_ORDER | SQL92_RESERVED_OVERLAPS | SQL92_RESERVED_PRIOR | SQL92_RESERVED_PROCEDURE | SQL92_RESERVED_PUBLIC | PLSQL_RESERVED_RESOURCE | SQL92_RESERVED_REVOKE | SQL92_RESERVED_SELECT | PLSQL_RESERVED_SHARE | SQL92_RESERVED_SIZE | PLSQL_RESERVED_START | PLSQL_RESERVED_TABAUTH | SQL92_RESERVED_TABLE | SQL92_RESERVED_THE | SQL92_RESERVED_THEN | SQL92_RESERVED_TO | SQL92_RESERVED_TRUE | SQL92_RESERVED_UNION | SQL92_RESERVED_UNIQUE | SQL92_RESERVED_UPDATE | SQL92_RESERVED_VALUES | SQL92_RESERVED_VIEW | PLSQL_RESERVED_VIEWS | SQL92_RESERVED_WHEN | SQL92_RESERVED_WHERE | SQL92_RESERVED_WITH | PLSQL_NON_RESERVED_USING | PLSQL_NON_RESERVED_MODEL | PLSQL_NON_RESERVED_ELSIF | PLSQL_NON_RESERVED_PIVOT | PLSQL_NON_RESERVED_UNPIVOT | REGULAR_ID | ZV );",
	    dfa39_eot,	    /* EOT table			    */
	    dfa39_eof,	    /* EOF table			    */
	    dfa39_min,	    /* Minimum tokens for each state    */
	    dfa39_max,	    /* Maximum tokens for each state    */
	    dfa39_accept,	/* Accept table			    */
	    dfa39_special,	/* Special transition states	    */
	    dfa39_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 39
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the lexer
 */

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 127:5: ( UNSIGNED_INTEGER '..' UNSIGNED_INTEGER )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FOR_NOTATION
 *
 * Looks to match the characters the constitute the token FOR_NOTATION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mFOR_NOTATION()
{
    ANTLR_UINT32	_type;
      


    _type	    = FOR_NOTATION;


    // PLSQLLexer.g:127:5: ( UNSIGNED_INTEGER '..' UNSIGNED_INTEGER )
    // PLSQLLexer.g:127:10: UNSIGNED_INTEGER '..' UNSIGNED_INTEGER
    {
        /* 127:10: UNSIGNED_INTEGER '..' UNSIGNED_INTEGER */
        mUNSIGNED_INTEGER();
        if  (this->hasException())
        {
            goto ruleFOR_NOTATIONEx;
        }



        this->matchs(lit_1);
        if  (this->hasException())
        {
            goto ruleFOR_NOTATIONEx;
        }




        /* 127:10: UNSIGNED_INTEGER '..' UNSIGNED_INTEGER */
        mUNSIGNED_INTEGER();
        if  (this->hasException())
        {
            goto ruleFOR_NOTATIONEx;
        }



    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleFOR_NOTATIONEx; /* Prevent compiler warnings */
    ruleFOR_NOTATIONEx: ;

}
// $ANTLR end FOR_NOTATION

//   Comes from: 138:5: ( ( 'N' | 'n' ) '\\'' ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )* '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NATIONAL_CHAR_STRING_LIT
 *
 * Looks to match the characters the constitute the token NATIONAL_CHAR_STRING_LIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mNATIONAL_CHAR_STRING_LIT()
{
    ANTLR_UINT32	_type;
      


    _type	    = NATIONAL_CHAR_STRING_LIT;


    // PLSQLLexer.g:138:5: ( ( 'N' | 'n' ) '\\'' ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )* '\\'' )
    // PLSQLLexer.g:138:10: ( 'N' | 'n' ) '\\'' ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )* '\\''
    {
        if ( this->LA(1) == 'N' || this->LA(1) == 'n' )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleNATIONAL_CHAR_STRING_LITEx;
        }


         this->matchc('\'');
        if  (this->hasException())
        {
            goto ruleNATIONAL_CHAR_STRING_LITEx;
        }


        // PLSQLLexer.g:138:27: ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )*

        for (;;)
        {
            int alt1=4;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA1_0 = this->LA(1);
                if ( (LA1_0 == '\''))
                {
                    switch ( this->LA(2) )
                    {
                    case '\'':
                    	{
                    		alt1=2;
                    	}
                        break;

                    }

                }
                else if ( (((LA1_0 >= 0x0000) && (LA1_0 <= '\t')) || ((LA1_0 >= 0x000B) && (LA1_0 <= '\f')) || ((LA1_0 >= 0x000E) && (LA1_0 <= '&')) || ((LA1_0 >= '(') && (LA1_0 <= 0xFFFF))))
                {
                    alt1=1;
                }
                else if ( (LA1_0 == '\n' || LA1_0 == '\r'))
                {
                    alt1=3;
                }

            }
            switch (alt1)
            {
        	case 1:
        	    // PLSQLLexer.g:138:51: ~ ( '\\'' | '\\r' | '\\n' )
        	    {
        	        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\t')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= '&')) || ((this->LA(1) >= '(') && (this->LA(1) <= 0xFFFF)) )
        	        {
        	            this->consume();
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            this->recover();
        	            goto ruleNATIONAL_CHAR_STRING_LITEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLLexer.g:138:76: '\\'' '\\''
        	    {
        	         this->matchc('\'');
        	        if  (this->hasException())
        	        {
        	            goto ruleNATIONAL_CHAR_STRING_LITEx;
        	        }


        	         this->matchc('\'');
        	        if  (this->hasException())
        	        {
        	            goto ruleNATIONAL_CHAR_STRING_LITEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLLexer.g:138:88: NEWLINE
        	    {
        	        /* 138:88: NEWLINE */
        	        mNEWLINE();
        	        if  (this->hasException())
        	        {
        	            goto ruleNATIONAL_CHAR_STRING_LITEx;
        	        }



        	    }
        	    break;

        	default:
        	    goto loop1;	/* break out of the loop */
        	    break;
            }
        }
        loop1: ; /* Jump out to here if this rule does not match */


         this->matchc('\'');
        if  (this->hasException())
        {
            goto ruleNATIONAL_CHAR_STRING_LITEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleNATIONAL_CHAR_STRING_LITEx; /* Prevent compiler warnings */
    ruleNATIONAL_CHAR_STRING_LITEx: ;

}
// $ANTLR end NATIONAL_CHAR_STRING_LIT

//   Comes from: 145:5: ( ( 'B' | 'b' ) ( '\\'' ( '0' | '1' )* '\\'' ( SEPARATOR )? )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BIT_STRING_LIT
 *
 * Looks to match the characters the constitute the token BIT_STRING_LIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mBIT_STRING_LIT()
{
    ANTLR_UINT32	_type;
      


    _type	    = BIT_STRING_LIT;


    // PLSQLLexer.g:145:5: ( ( 'B' | 'b' ) ( '\\'' ( '0' | '1' )* '\\'' ( SEPARATOR )? )+ )
    // PLSQLLexer.g:145:10: ( 'B' | 'b' ) ( '\\'' ( '0' | '1' )* '\\'' ( SEPARATOR )? )+
    {
        if ( this->LA(1) == 'B' || this->LA(1) == 'b' )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleBIT_STRING_LITEx;
        }


        // PLSQLLexer.g:145:22: ( '\\'' ( '0' | '1' )* '\\'' ( SEPARATOR )? )+
        {
            int cnt4=0;

            for (;;)
            {
                int alt4=2;
        	switch ( this->LA(1) )
        	{
        	case '\'':
        		{
        			alt4=1;
        		}
        	    break;

        	}

        	switch (alt4)
        	{
        	    case 1:
        	        // PLSQLLexer.g:145:23: '\\'' ( '0' | '1' )* '\\'' ( SEPARATOR )?
        	        {
        	             this->matchc('\'');
        	            if  (this->hasException())
        	            {
        	                goto ruleBIT_STRING_LITEx;
        	            }


        	            // PLSQLLexer.g:145:28: ( '0' | '1' )*

        	            for (;;)
        	            {
        	                int alt2=2;
        	                switch ( this->LA(1) )
        	                {
        	                case '0':
        	                case '1':
        	                	{
        	                		alt2=1;
        	                	}
        	                    break;

        	                }

        	                switch (alt2)
        	                {
        	            	case 1:
        	            	    // PLSQLLexer.g:
        	            	    {
        	            	        if ( ((this->LA(1) >= '0') && (this->LA(1) <= '1')) )
        	            	        {
        	            	            this->consume();
        	            	        }
        	            	        else
        	            	        {
        	            	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            	            this->recover();
        	            	            goto ruleBIT_STRING_LITEx;
        	            	        }


        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop2;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop2: ; /* Jump out to here if this rule does not match */


        	             this->matchc('\'');
        	            if  (this->hasException())
        	            {
        	                goto ruleBIT_STRING_LITEx;
        	            }


        	            // PLSQLLexer.g:145:46: ( SEPARATOR )?
        	            {
        	                int alt3=2;
        	                switch ( this->LA(1) )
        	                {
        	                    case '\t':
        	                    case '\n':
        	                    case '\r':
        	                    case ' ':
        	                    case '-':
        	                    case '/':
        	                    	{
        	                    		alt3=1;
        	                    	}
        	                        break;
        	                }

        	                switch (alt3)
        	                {
        	            	case 1:
        	            	    // PLSQLLexer.g:145:46: SEPARATOR
        	            	    {
        	            	        /* 145:46: SEPARATOR */
        	            	        mSEPARATOR();
        	            	        if  (this->hasException())
        	            	        {
        	            	            goto ruleBIT_STRING_LITEx;
        	            	        }



        	            	    }
        	            	    break;

        	                }
        	            }

        	        }
        	        break;

        	    default:

        		if ( cnt4 >= 1 )
        		{
        		    goto loop4;
        		}
        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< PLSQLLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto ruleBIT_STRING_LITEx;
        	}
        	cnt4++;
            }
            loop4: ;	/* Jump to here if this rule does not match */
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleBIT_STRING_LITEx; /* Prevent compiler warnings */
    ruleBIT_STRING_LITEx: ;

}
// $ANTLR end BIT_STRING_LIT

//   Comes from: 153:5: ( ( 'X' | 'x' ) ( '\\'' ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )* '\\'' ( SEPARATOR )? )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX_STRING_LIT
 *
 * Looks to match the characters the constitute the token HEX_STRING_LIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mHEX_STRING_LIT()
{
    ANTLR_UINT32	_type;
      


    _type	    = HEX_STRING_LIT;


    // PLSQLLexer.g:153:5: ( ( 'X' | 'x' ) ( '\\'' ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )* '\\'' ( SEPARATOR )? )+ )
    // PLSQLLexer.g:153:10: ( 'X' | 'x' ) ( '\\'' ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )* '\\'' ( SEPARATOR )? )+
    {
        if ( this->LA(1) == 'X' || this->LA(1) == 'x' )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleHEX_STRING_LITEx;
        }


        // PLSQLLexer.g:153:22: ( '\\'' ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )* '\\'' ( SEPARATOR )? )+
        {
            int cnt7=0;

            for (;;)
            {
                int alt7=2;
        	switch ( this->LA(1) )
        	{
        	case '\'':
        		{
        			alt7=1;
        		}
        	    break;

        	}

        	switch (alt7)
        	{
        	    case 1:
        	        // PLSQLLexer.g:153:23: '\\'' ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )* '\\'' ( SEPARATOR )?
        	        {
        	             this->matchc('\'');
        	            if  (this->hasException())
        	            {
        	                goto ruleHEX_STRING_LITEx;
        	            }


        	            // PLSQLLexer.g:153:28: ( 'a' .. 'f' | 'A' .. 'F' | '0' .. '9' )*

        	            for (;;)
        	            {
        	                int alt5=2;
        	                switch ( this->LA(1) )
        	                {
        	                case '0':
        	                case '1':
        	                case '2':
        	                case '3':
        	                case '4':
        	                case '5':
        	                case '6':
        	                case '7':
        	                case '8':
        	                case '9':
        	                case 'A':
        	                case 'B':
        	                case 'C':
        	                case 'D':
        	                case 'E':
        	                case 'F':
        	                case 'a':
        	                case 'b':
        	                case 'c':
        	                case 'd':
        	                case 'e':
        	                case 'f':
        	                	{
        	                		alt5=1;
        	                	}
        	                    break;

        	                }

        	                switch (alt5)
        	                {
        	            	case 1:
        	            	    // PLSQLLexer.g:
        	            	    {
        	            	        if ( ((this->LA(1) >= '0') && (this->LA(1) <= '9')) || ((this->LA(1) >= 'A') && (this->LA(1) <= 'F')) || ((this->LA(1) >= 'a') && (this->LA(1) <= 'f')) )
        	            	        {
        	            	            this->consume();
        	            	        }
        	            	        else
        	            	        {
        	            	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            	            this->recover();
        	            	            goto ruleHEX_STRING_LITEx;
        	            	        }


        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop5;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop5: ; /* Jump out to here if this rule does not match */


        	             this->matchc('\'');
        	            if  (this->hasException())
        	            {
        	                goto ruleHEX_STRING_LITEx;
        	            }


        	            // PLSQLLexer.g:153:67: ( SEPARATOR )?
        	            {
        	                int alt6=2;
        	                switch ( this->LA(1) )
        	                {
        	                    case '\t':
        	                    case '\n':
        	                    case '\r':
        	                    case ' ':
        	                    case '-':
        	                    case '/':
        	                    	{
        	                    		alt6=1;
        	                    	}
        	                        break;
        	                }

        	                switch (alt6)
        	                {
        	            	case 1:
        	            	    // PLSQLLexer.g:153:67: SEPARATOR
        	            	    {
        	            	        /* 153:67: SEPARATOR */
        	            	        mSEPARATOR();
        	            	        if  (this->hasException())
        	            	        {
        	            	            goto ruleHEX_STRING_LITEx;
        	            	        }



        	            	    }
        	            	    break;

        	                }
        	            }

        	        }
        	        break;

        	    default:

        		if ( cnt7 >= 1 )
        		{
        		    goto loop7;
        		}
        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< PLSQLLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto ruleHEX_STRING_LITEx;
        	}
        	cnt7++;
            }
            loop7: ;	/* Jump to here if this rule does not match */
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleHEX_STRING_LITEx; /* Prevent compiler warnings */
    ruleHEX_STRING_LITEx: ;

}
// $ANTLR end HEX_STRING_LIT

//   Comes from: 158:5: ( '.' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PERIOD
 *
 * Looks to match the characters the constitute the token PERIOD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPERIOD()
{
    ANTLR_UINT32	_type;
      


    _type	    = PERIOD;


    // PLSQLLexer.g:158:5: ( '.' )
    // PLSQLLexer.g:158:10: '.'
    {
         this->matchc('.');
        if  (this->hasException())
        {
            goto rulePERIODEx;
        }


        {
                if ((char) LA(1) == '.') {
                        consume();
                        _type = DOUBLE_PERIOD;
                    }
                
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePERIODEx; /* Prevent compiler warnings */
    rulePERIODEx: ;

}
// $ANTLR end PERIOD

//   Comes from: 172:5: ( ( UNSIGNED_INTEGER ( '.' UNSIGNED_INTEGER |) ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? | '.' UNSIGNED_INTEGER ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? ) ( 'D' | 'd' | 'f' | 'F' )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXACT_NUM_LIT
 *
 * Looks to match the characters the constitute the token EXACT_NUM_LIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mEXACT_NUM_LIT()
{
    ANTLR_UINT32	_type;
      


    _type	    = EXACT_NUM_LIT;


    // PLSQLLexer.g:172:5: ( ( UNSIGNED_INTEGER ( '.' UNSIGNED_INTEGER |) ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? | '.' UNSIGNED_INTEGER ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? ) ( 'D' | 'd' | 'f' | 'F' )? )
    // PLSQLLexer.g:172:7: ( UNSIGNED_INTEGER ( '.' UNSIGNED_INTEGER |) ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? | '.' UNSIGNED_INTEGER ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? ) ( 'D' | 'd' | 'f' | 'F' )?
    {
        // PLSQLLexer.g:172:7: ( UNSIGNED_INTEGER ( '.' UNSIGNED_INTEGER |) ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? | '.' UNSIGNED_INTEGER ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? )
        {
            int alt13=2;
            switch ( this->LA(1) )
            {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            	{
            		alt13=1;
            	}
                break;
            case '.':
            	{
            		alt13=2;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 13 );
                ex->set_state( 0 );


                goto ruleEXACT_NUM_LITEx;

            }

            switch (alt13)
            {
        	case 1:
        	    // PLSQLLexer.g:173:13: UNSIGNED_INTEGER ( '.' UNSIGNED_INTEGER |) ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )?
        	    {
        	        /* 173:13: UNSIGNED_INTEGER ( '.' UNSIGNED_INTEGER |) ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? */
        	        mUNSIGNED_INTEGER();
        	        if  (this->hasException())
        	        {
        	            goto ruleEXACT_NUM_LITEx;
        	        }



        	        // PLSQLLexer.g:174:13: ( '.' UNSIGNED_INTEGER |)
        	        {
        	            int alt8=2;
        	            switch ( this->LA(1) )
        	            {
        	            case '.':
        	            	{
        	            		alt8=1;
        	            	}
        	                break;

        	            default:
        	                alt8=2;
        	            }

        	            switch (alt8)
        	            {
        	        	case 1:
        	        	    // PLSQLLexer.g:174:15: '.' UNSIGNED_INTEGER
        	        	    {
        	        	         this->matchc('.');
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        }


        	        	        /* 174:15: '.' UNSIGNED_INTEGER */
        	        	        mUNSIGNED_INTEGER();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        }



        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQLLexer.g:175:18: 
        	        	    {
        	        	        {
        	        	            _type = UNSIGNED_INTEGER;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLLexer.g:176:15: ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )?
        	        {
        	            int alt10=2;
        	            switch ( this->LA(1) )
        	            {
        	                case 'E':
        	                case 'e':
        	                	{
        	                		alt10=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt10)
        	            {
        	        	case 1:
        	        	    // PLSQLLexer.g:176:17: ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER
        	        	    {
        	        	        if ( this->LA(1) == 'E' || this->LA(1) == 'e' )
        	        	        {
        	        	            this->consume();
        	        	        }
        	        	        else
        	        	        {
        	        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	        	            this->recover();
        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        }


        	        	        // PLSQLLexer.g:176:29: ( '+' | '-' )?
        	        	        {
        	        	            int alt9=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case '+':
        	        	                case '-':
        	        	                	{
        	        	                		alt9=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt9)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQLLexer.g:
        	        	        	    {
        	        	        	        if ( this->LA(1) == '+' || this->LA(1) == '-' )
        	        	        	        {
        	        	        	            this->consume();
        	        	        	        }
        	        	        	        else
        	        	        	        {
        	        	        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	        	        	            this->recover();
        	        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        /* 176:17: ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER */
        	        	        mUNSIGNED_INTEGER();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        }



        	        	        {
        	        	            _type = APPROXIMATE_NUM_LIT;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQLLexer.g:177:10: '.' UNSIGNED_INTEGER ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )?
        	    {
        	         this->matchc('.');
        	        if  (this->hasException())
        	        {
        	            goto ruleEXACT_NUM_LITEx;
        	        }


        	        /* 177:10: '.' UNSIGNED_INTEGER ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )? */
        	        mUNSIGNED_INTEGER();
        	        if  (this->hasException())
        	        {
        	            goto ruleEXACT_NUM_LITEx;
        	        }



        	        // PLSQLLexer.g:177:31: ( ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER )?
        	        {
        	            int alt12=2;
        	            switch ( this->LA(1) )
        	            {
        	                case 'E':
        	                case 'e':
        	                	{
        	                		alt12=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt12)
        	            {
        	        	case 1:
        	        	    // PLSQLLexer.g:177:33: ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER
        	        	    {
        	        	        if ( this->LA(1) == 'E' || this->LA(1) == 'e' )
        	        	        {
        	        	            this->consume();
        	        	        }
        	        	        else
        	        	        {
        	        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	        	            this->recover();
        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        }


        	        	        // PLSQLLexer.g:177:45: ( '+' | '-' )?
        	        	        {
        	        	            int alt11=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case '+':
        	        	                case '-':
        	        	                	{
        	        	                		alt11=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt11)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQLLexer.g:
        	        	        	    {
        	        	        	        if ( this->LA(1) == '+' || this->LA(1) == '-' )
        	        	        	        {
        	        	        	            this->consume();
        	        	        	        }
        	        	        	        else
        	        	        	        {
        	        	        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	        	        	            this->recover();
        	        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        /* 177:33: ( 'E' | 'e' ) ( '+' | '-' )? UNSIGNED_INTEGER */
        	        	        mUNSIGNED_INTEGER();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleEXACT_NUM_LITEx;
        	        	        }



        	        	        {
        	        	            _type = APPROXIMATE_NUM_LIT;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }

        // PLSQLLexer.g:179:5: ( 'D' | 'd' | 'f' | 'F' )?
        {
            int alt14=2;
            switch ( this->LA(1) )
            {
                case 'D':
                case 'F':
                case 'd':
                case 'f':
                	{
                		alt14=1;
                	}
                    break;
            }

            switch (alt14)
            {
        	case 1:
        	    // PLSQLLexer.g:
        	    {
        	        if ( this->LA(1) == 'D' || this->LA(1) == 'F' || this->LA(1) == 'd' || this->LA(1) == 'f' )
        	        {
        	            this->consume();
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            this->recover();
        	            goto ruleEXACT_NUM_LITEx;
        	        }


        	    }
        	    break;

            }
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleEXACT_NUM_LITEx; /* Prevent compiler warnings */
    ruleEXACT_NUM_LITEx: ;

}
// $ANTLR end EXACT_NUM_LIT

//   Comes from: 186:5: ( '\\'' ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )* '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CHAR_STRING
 *
 * Looks to match the characters the constitute the token CHAR_STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mCHAR_STRING()
{
    ANTLR_UINT32	_type;
      


    _type	    = CHAR_STRING;


    // PLSQLLexer.g:186:5: ( '\\'' ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )* '\\'' )
    // PLSQLLexer.g:186:10: '\\'' ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )* '\\''
    {
         this->matchc('\'');
        if  (this->hasException())
        {
            goto ruleCHAR_STRINGEx;
        }


        // PLSQLLexer.g:186:15: ( options {greedy=true; } :~ ( '\\'' | '\\r' | '\\n' ) | '\\'' '\\'' | NEWLINE )*

        for (;;)
        {
            int alt15=4;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA15_0 = this->LA(1);
                if ( (LA15_0 == '\''))
                {
                    switch ( this->LA(2) )
                    {
                    case '\'':
                    	{
                    		alt15=2;
                    	}
                        break;

                    }

                }
                else if ( (((LA15_0 >= 0x0000) && (LA15_0 <= '\t')) || ((LA15_0 >= 0x000B) && (LA15_0 <= '\f')) || ((LA15_0 >= 0x000E) && (LA15_0 <= '&')) || ((LA15_0 >= '(') && (LA15_0 <= 0xFFFF))))
                {
                    alt15=1;
                }
                else if ( (LA15_0 == '\n' || LA15_0 == '\r'))
                {
                    alt15=3;
                }

            }
            switch (alt15)
            {
        	case 1:
        	    // PLSQLLexer.g:186:39: ~ ( '\\'' | '\\r' | '\\n' )
        	    {
        	        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\t')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= '&')) || ((this->LA(1) >= '(') && (this->LA(1) <= 0xFFFF)) )
        	        {
        	            this->consume();
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            this->recover();
        	            goto ruleCHAR_STRINGEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLLexer.g:186:63: '\\'' '\\''
        	    {
        	         this->matchc('\'');
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRINGEx;
        	        }


        	         this->matchc('\'');
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRINGEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLLexer.g:186:75: NEWLINE
        	    {
        	        /* 186:75: NEWLINE */
        	        mNEWLINE();
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRINGEx;
        	        }



        	    }
        	    break;

        	default:
        	    goto loop15;	/* break out of the loop */
        	    break;
            }
        }
        loop15: ; /* Jump out to here if this rule does not match */


         this->matchc('\'');
        if  (this->hasException())
        {
            goto ruleCHAR_STRINGEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCHAR_STRINGEx; /* Prevent compiler warnings */
    ruleCHAR_STRINGEx: ;

}
// $ANTLR end CHAR_STRING

//   Comes from: 191:21: ( ( 'q' | 'Q' ) ( QS_ANGLE | QS_BRACE | QS_BRACK | QS_PAREN | QS_OTHER ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CHAR_STRING_PERL
 *
 * Looks to match the characters the constitute the token CHAR_STRING_PERL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mCHAR_STRING_PERL()
{
    ANTLR_UINT32	_type;
      


    _type	    = CHAR_STRING_PERL;


    // PLSQLLexer.g:191:21: ( ( 'q' | 'Q' ) ( QS_ANGLE | QS_BRACE | QS_BRACK | QS_PAREN | QS_OTHER ) )
    // PLSQLLexer.g:191:23: ( 'q' | 'Q' ) ( QS_ANGLE | QS_BRACE | QS_BRACK | QS_PAREN | QS_OTHER )
    {
        if ( this->LA(1) == 'Q' || this->LA(1) == 'q' )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleCHAR_STRING_PERLEx;
        }


        // PLSQLLexer.g:191:33: ( QS_ANGLE | QS_BRACE | QS_BRACK | QS_PAREN | QS_OTHER )
        {
            int alt16=5;
            switch ( this->LA(1) )
            {
            case '\'':
            	{
            		{
            		    int LA16_1 = this->LA(2);
            		    if ( (LA16_1 == '<'))
            		    {
            		        alt16=1;
            		    }
            		    else if ( (LA16_1 == '{'))
            		    {
            		        alt16=2;
            		    }
            		    else if ( (LA16_1 == '['))
            		    {
            		        alt16=3;
            		    }
            		    else if ( (LA16_1 == '('))
            		    {
            		        alt16=4;
            		    }
            		    else if ( (((LA16_1 >= 0x0000) && (LA16_1 <= '\b')) || ((LA16_1 >= 0x000B) && (LA16_1 <= '\f')) || ((LA16_1 >= 0x000E) && (LA16_1 <= 0x001F)) || ((LA16_1 >= '!') && (LA16_1 <= '\'')) || ((LA16_1 >= ')') && (LA16_1 <= ';')) || ((LA16_1 >= '=') && (LA16_1 <= 'Z')) || ((LA16_1 >= '\\') && (LA16_1 <= 'z')) || ((LA16_1 >= '|') && (LA16_1 <= 0xFFFF))))
            		    {
            		        alt16=5;
            		    }
            		    else
            		    {

            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 16 );
            		        ex->set_state( 1 );


            		        goto ruleCHAR_STRING_PERLEx;

            		    }
            		}
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 16 );
                ex->set_state( 0 );


                goto ruleCHAR_STRING_PERLEx;

            }

            switch (alt16)
            {
        	case 1:
        	    // PLSQLLexer.g:191:35: QS_ANGLE
        	    {
        	        /* 191:35: QS_ANGLE */
        	        mQS_ANGLE();
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRING_PERLEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // PLSQLLexer.g:191:46: QS_BRACE
        	    {
        	        /* 191:46: QS_BRACE */
        	        mQS_BRACE();
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRING_PERLEx;
        	        }



        	    }
        	    break;
        	case 3:
        	    // PLSQLLexer.g:191:57: QS_BRACK
        	    {
        	        /* 191:57: QS_BRACK */
        	        mQS_BRACK();
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRING_PERLEx;
        	        }



        	    }
        	    break;
        	case 4:
        	    // PLSQLLexer.g:191:68: QS_PAREN
        	    {
        	        /* 191:68: QS_PAREN */
        	        mQS_PAREN();
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRING_PERLEx;
        	        }



        	    }
        	    break;
        	case 5:
        	    // PLSQLLexer.g:191:79: QS_OTHER
        	    {
        	        /* 191:79: QS_OTHER */
        	        mQS_OTHER();
        	        if  (this->hasException())
        	        {
        	            goto ruleCHAR_STRING_PERLEx;
        	        }



        	    }
        	    break;

            }
        }

        {
            _type = CHAR_STRING;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCHAR_STRING_PERLEx; /* Prevent compiler warnings */
    ruleCHAR_STRING_PERLEx: ;

}
// $ANTLR end CHAR_STRING_PERL

//   Comes from: 192:21: ( '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QUOTE
 *
 * Looks to match the characters the constitute the token QUOTE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mQUOTE()
{
    ANTLR_UINT32	_type;
      



    // PLSQLLexer.g:192:21: ( '\\'' )
    // PLSQLLexer.g:192:23: '\\''
    {
         this->matchc('\'');
        if  (this->hasException())
        {
            goto ruleQUOTEEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleQUOTEEx; /* Prevent compiler warnings */
    ruleQUOTEEx: ;

}
// $ANTLR end QUOTE

//   Comes from: 193:21: ( QUOTE '<' ( options {greedy=false; } : . )* '>' QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QS_ANGLE
 *
 * Looks to match the characters the constitute the token QS_ANGLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mQS_ANGLE()
{
    ANTLR_UINT32	_type;
      



    // PLSQLLexer.g:193:21: ( QUOTE '<' ( options {greedy=false; } : . )* '>' QUOTE )
    // PLSQLLexer.g:193:23: QUOTE '<' ( options {greedy=false; } : . )* '>' QUOTE
    {
        /* 193:23: QUOTE '<' ( options {greedy=false; } : . )* '>' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_ANGLEEx;
        }



         this->matchc('<');
        if  (this->hasException())
        {
            goto ruleQS_ANGLEEx;
        }


        // PLSQLLexer.g:193:33: ( options {greedy=false; } : . )*

        for (;;)
        {
            int alt17=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA17_0 = this->LA(1);
                if ( (LA17_0 == '>'))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA17_1 = this->LA(2);
                        if ( (LA17_1 == '\''))
                        {
                            alt17=2;
                        }
                        else if ( (((LA17_1 >= 0x0000) && (LA17_1 <= '&')) || ((LA17_1 >= '(') && (LA17_1 <= 0xFFFF))))
                        {
                            alt17=1;
                        }

                    }
                }
                else if ( (((LA17_0 >= 0x0000) && (LA17_0 <= '=')) || ((LA17_0 >= '?') && (LA17_0 <= 0xFFFF))))
                {
                    alt17=1;
                }

            }
            switch (alt17)
            {
        	case 1:
        	    // PLSQLLexer.g:193:61: .
        	    {
        	        this->matchAny();
        	        if  (this->hasException())
        	        {
        	            goto ruleQS_ANGLEEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop17;	/* break out of the loop */
        	    break;
            }
        }
        loop17: ; /* Jump out to here if this rule does not match */


         this->matchc('>');
        if  (this->hasException())
        {
            goto ruleQS_ANGLEEx;
        }


        /* 193:23: QUOTE '<' ( options {greedy=false; } : . )* '>' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_ANGLEEx;
        }



    }


    // This is where rules clean up and exit
    //
    goto ruleQS_ANGLEEx; /* Prevent compiler warnings */
    ruleQS_ANGLEEx: ;

}
// $ANTLR end QS_ANGLE

//   Comes from: 194:21: ( QUOTE '{' ( options {greedy=false; } : . )* '}' QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QS_BRACE
 *
 * Looks to match the characters the constitute the token QS_BRACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mQS_BRACE()
{
    ANTLR_UINT32	_type;
      



    // PLSQLLexer.g:194:21: ( QUOTE '{' ( options {greedy=false; } : . )* '}' QUOTE )
    // PLSQLLexer.g:194:23: QUOTE '{' ( options {greedy=false; } : . )* '}' QUOTE
    {
        /* 194:23: QUOTE '{' ( options {greedy=false; } : . )* '}' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_BRACEEx;
        }



         this->matchc('{');
        if  (this->hasException())
        {
            goto ruleQS_BRACEEx;
        }


        // PLSQLLexer.g:194:33: ( options {greedy=false; } : . )*

        for (;;)
        {
            int alt18=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA18_0 = this->LA(1);
                if ( (LA18_0 == '}'))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA18_1 = this->LA(2);
                        if ( (LA18_1 == '\''))
                        {
                            alt18=2;
                        }
                        else if ( (((LA18_1 >= 0x0000) && (LA18_1 <= '&')) || ((LA18_1 >= '(') && (LA18_1 <= 0xFFFF))))
                        {
                            alt18=1;
                        }

                    }
                }
                else if ( (((LA18_0 >= 0x0000) && (LA18_0 <= '|')) || ((LA18_0 >= '~') && (LA18_0 <= 0xFFFF))))
                {
                    alt18=1;
                }

            }
            switch (alt18)
            {
        	case 1:
        	    // PLSQLLexer.g:194:61: .
        	    {
        	        this->matchAny();
        	        if  (this->hasException())
        	        {
        	            goto ruleQS_BRACEEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop18;	/* break out of the loop */
        	    break;
            }
        }
        loop18: ; /* Jump out to here if this rule does not match */


         this->matchc('}');
        if  (this->hasException())
        {
            goto ruleQS_BRACEEx;
        }


        /* 194:23: QUOTE '{' ( options {greedy=false; } : . )* '}' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_BRACEEx;
        }



    }


    // This is where rules clean up and exit
    //
    goto ruleQS_BRACEEx; /* Prevent compiler warnings */
    ruleQS_BRACEEx: ;

}
// $ANTLR end QS_BRACE

//   Comes from: 195:21: ( QUOTE '[' ( options {greedy=false; } : . )* ']' QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QS_BRACK
 *
 * Looks to match the characters the constitute the token QS_BRACK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mQS_BRACK()
{
    ANTLR_UINT32	_type;
      



    // PLSQLLexer.g:195:21: ( QUOTE '[' ( options {greedy=false; } : . )* ']' QUOTE )
    // PLSQLLexer.g:195:23: QUOTE '[' ( options {greedy=false; } : . )* ']' QUOTE
    {
        /* 195:23: QUOTE '[' ( options {greedy=false; } : . )* ']' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_BRACKEx;
        }



         this->matchc('[');
        if  (this->hasException())
        {
            goto ruleQS_BRACKEx;
        }


        // PLSQLLexer.g:195:33: ( options {greedy=false; } : . )*

        for (;;)
        {
            int alt19=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA19_0 = this->LA(1);
                if ( (LA19_0 == ']'))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA19_1 = this->LA(2);
                        if ( (LA19_1 == '\''))
                        {
                            alt19=2;
                        }
                        else if ( (((LA19_1 >= 0x0000) && (LA19_1 <= '&')) || ((LA19_1 >= '(') && (LA19_1 <= 0xFFFF))))
                        {
                            alt19=1;
                        }

                    }
                }
                else if ( (((LA19_0 >= 0x0000) && (LA19_0 <= '\\')) || ((LA19_0 >= '^') && (LA19_0 <= 0xFFFF))))
                {
                    alt19=1;
                }

            }
            switch (alt19)
            {
        	case 1:
        	    // PLSQLLexer.g:195:61: .
        	    {
        	        this->matchAny();
        	        if  (this->hasException())
        	        {
        	            goto ruleQS_BRACKEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop19;	/* break out of the loop */
        	    break;
            }
        }
        loop19: ; /* Jump out to here if this rule does not match */


         this->matchc(']');
        if  (this->hasException())
        {
            goto ruleQS_BRACKEx;
        }


        /* 195:23: QUOTE '[' ( options {greedy=false; } : . )* ']' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_BRACKEx;
        }



    }


    // This is where rules clean up and exit
    //
    goto ruleQS_BRACKEx; /* Prevent compiler warnings */
    ruleQS_BRACKEx: ;

}
// $ANTLR end QS_BRACK

//   Comes from: 196:21: ( QUOTE '(' ( options {greedy=false; } : . )* ')' QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QS_PAREN
 *
 * Looks to match the characters the constitute the token QS_PAREN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mQS_PAREN()
{
    ANTLR_UINT32	_type;
      



    // PLSQLLexer.g:196:21: ( QUOTE '(' ( options {greedy=false; } : . )* ')' QUOTE )
    // PLSQLLexer.g:196:23: QUOTE '(' ( options {greedy=false; } : . )* ')' QUOTE
    {
        /* 196:23: QUOTE '(' ( options {greedy=false; } : . )* ')' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_PARENEx;
        }



         this->matchc('(');
        if  (this->hasException())
        {
            goto ruleQS_PARENEx;
        }


        // PLSQLLexer.g:196:33: ( options {greedy=false; } : . )*

        for (;;)
        {
            int alt20=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA20_0 = this->LA(1);
                if ( (LA20_0 == ')'))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA20_1 = this->LA(2);
                        if ( (LA20_1 == '\''))
                        {
                            alt20=2;
                        }
                        else if ( (((LA20_1 >= 0x0000) && (LA20_1 <= '&')) || ((LA20_1 >= '(') && (LA20_1 <= 0xFFFF))))
                        {
                            alt20=1;
                        }

                    }
                }
                else if ( (((LA20_0 >= 0x0000) && (LA20_0 <= '(')) || ((LA20_0 >= '*') && (LA20_0 <= 0xFFFF))))
                {
                    alt20=1;
                }

            }
            switch (alt20)
            {
        	case 1:
        	    // PLSQLLexer.g:196:61: .
        	    {
        	        this->matchAny();
        	        if  (this->hasException())
        	        {
        	            goto ruleQS_PARENEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop20;	/* break out of the loop */
        	    break;
            }
        }
        loop20: ; /* Jump out to here if this rule does not match */


         this->matchc(')');
        if  (this->hasException())
        {
            goto ruleQS_PARENEx;
        }


        /* 196:23: QUOTE '(' ( options {greedy=false; } : . )* ')' QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_PARENEx;
        }



    }


    // This is where rules clean up and exit
    //
    goto ruleQS_PARENEx; /* Prevent compiler warnings */
    ruleQS_PARENEx: ;

}
// $ANTLR end QS_PAREN

//   Comes from: 198:21: (~ ( '<' | '{' | '[' | '(' | ' ' | '\\t' | '\\n' | '\\r' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QS_OTHER_CH
 *
 * Looks to match the characters the constitute the token QS_OTHER_CH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mQS_OTHER_CH()
{
    ANTLR_UINT32	_type;
      



    // PLSQLLexer.g:198:21: (~ ( '<' | '{' | '[' | '(' | ' ' | '\\t' | '\\n' | '\\r' ) )
    // PLSQLLexer.g:
    {
        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\b')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= 0x001F)) || ((this->LA(1) >= '!') && (this->LA(1) <= '\'')) || ((this->LA(1) >= ')') && (this->LA(1) <= ';')) || ((this->LA(1) >= '=') && (this->LA(1) <= 'Z')) || ((this->LA(1) >= '\\') && (this->LA(1) <= 'z')) || ((this->LA(1) >= '|') && (this->LA(1) <= 0xFFFF)) )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleQS_OTHER_CHEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleQS_OTHER_CHEx; /* Prevent compiler warnings */
    ruleQS_OTHER_CHEx: ;

}
// $ANTLR end QS_OTHER_CH

//   Comes from: 208:3: ( QUOTE delimiter= QS_OTHER_CH ({...}? => . )* ({...}? => . ) QUOTE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QS_OTHER
 *
 * Looks to match the characters the constitute the token QS_OTHER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mQS_OTHER()
{
    ANTLR_UINT32	_type;
      

    ImplTraits::CommonTokenType* delimiter = NULL;



    // PLSQLLexer.g:208:3: ( QUOTE delimiter= QS_OTHER_CH ({...}? => . )* ({...}? => . ) QUOTE )
    // PLSQLLexer.g:209:3: QUOTE delimiter= QS_OTHER_CH ({...}? => . )* ({...}? => . ) QUOTE
    {
        /* 209:3: QUOTE delimiter= QS_OTHER_CH ({...}? => . )* ({...}? => . ) QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_OTHEREx;
        }



        /* 209:3: QUOTE delimiter= QS_OTHER_CH ({...}? => . )* ({...}? => . ) QUOTE */
        {
            ANTLR_MARKER delimiterStart884 = this->getCharIndex();
        mQS_OTHER_CH( );
            if  (this->hasException())
            {
                goto ruleQS_OTHEREx;
            }

            delimiter = new CommonTokenType();
            delimiter->set_type( CommonTokenType::TOKEN_INVALID);
            delimiter->set_startIndex( delimiterStart884 );
            delimiter->set_stopIndex( this->getCharIndex()-1);
            delimiter->set_input( this->get_input() );
        }


        // PLSQLLexer.g:218:3: ({...}? => . )*

        for (;;)
        {
            int alt21=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA21_0 = this->LA(1);
                if ( (((( LA(1) != delimiter->getText().at(0) || LA(2) != '\'' ))||(( LA(1) == delimiter->getText().at(0) && LA(2) == '\'' )))) && (((LA21_0 >= 0x0000) && (LA21_0 <= 0xFFFF))))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA21_1 = this->LA(2);
                        if ( (((( LA(1) != delimiter->getText().at(0) || LA(2) != '\'' ))||(( LA(1) == delimiter->getText().at(0) && LA(2) == '\'' )))) && (LA21_1 == '\''))
                        {
                            {
                               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                                */
                                int LA21_2 = this->LA(3);
                                if ( (( LA(1) != delimiter->getText().at(0) || LA(2) != '\'' )) && (((LA21_2 >= 0x0000) && (LA21_2 <= 0xFFFF))))
                                {
                                    alt21=1;
                                }

                            }
                        }
                        else if ( (( LA(1) != delimiter->getText().at(0) || LA(2) != '\'' )) && (((LA21_1 >= 0x0000) && (LA21_1 <= '&')) || ((LA21_1 >= '(') && (LA21_1 <= 0xFFFF))))
                        {
                            alt21=1;
                        }

                    }
                }

            }
            switch (alt21)
            {
        	case 1:
        	    // PLSQLLexer.g:218:5: {...}? => .
        	    {
        	        if ( !(( LA(1) != delimiter->getText().at(0) || LA(2) != '\'' )) )
        	        {
        	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), " LA(1) != $delimiter->getText().at(0) || LA(2) != '\\'' " );
        	                ex->set_ruleName( "QS_OTHER" );


        	        }

        	        this->matchAny();
        	        if  (this->hasException())
        	        {
        	            goto ruleQS_OTHEREx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop21;	/* break out of the loop */
        	    break;
            }
        }
        loop21: ; /* Jump out to here if this rule does not match */


        // PLSQLLexer.g:219:3: ({...}? => . )
        // PLSQLLexer.g:219:5: {...}? => .
        {
            if ( !(( LA(1) == delimiter->getText().at(0) && LA(2) == '\'' )) )
            {
                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), " LA(1) == $delimiter->getText().at(0) && LA(2) == '\\'' " );
                    ex->set_ruleName( "QS_OTHER" );


            }

            this->matchAny();
            if  (this->hasException())
            {
                goto ruleQS_OTHEREx;
            }


        }


        /* 209:3: QUOTE delimiter= QS_OTHER_CH ({...}? => . )* ({...}? => . ) QUOTE */
        mQUOTE();
        if  (this->hasException())
        {
            goto ruleQS_OTHEREx;
        }



    }


    // This is where rules clean up and exit
    //
    goto ruleQS_OTHEREx; /* Prevent compiler warnings */
    ruleQS_OTHEREx: ;

    delimiter = NULL;

}
// $ANTLR end QS_OTHER

//   Comes from: 225:5: ( '\"' (~ ( '\"' | '\\r' | '\\n' ) | '\"' '\"' )+ '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DELIMITED_ID
 *
 * Looks to match the characters the constitute the token DELIMITED_ID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mDELIMITED_ID()
{
    ANTLR_UINT32	_type;
      


    _type	    = DELIMITED_ID;


    // PLSQLLexer.g:225:5: ( '\"' (~ ( '\"' | '\\r' | '\\n' ) | '\"' '\"' )+ '\"' )
    // PLSQLLexer.g:225:10: '\"' (~ ( '\"' | '\\r' | '\\n' ) | '\"' '\"' )+ '\"'
    {
         this->matchc('"');
        if  (this->hasException())
        {
            goto ruleDELIMITED_IDEx;
        }


        // PLSQLLexer.g:225:14: (~ ( '\"' | '\\r' | '\\n' ) | '\"' '\"' )+
        {
            int cnt22=0;

            for (;;)
            {
                int alt22=3;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA22_0 = this->LA(1);
        	    if ( (LA22_0 == '"'))
        	    {
        	        switch ( this->LA(2) )
        	        {
        	        case '"':
        	        	{
        	        		alt22=2;
        	        	}
        	            break;

        	        }

        	    }
        	    else if ( (((LA22_0 >= 0x0000) && (LA22_0 <= '\t')) || ((LA22_0 >= 0x000B) && (LA22_0 <= '\f')) || ((LA22_0 >= 0x000E) && (LA22_0 <= '!')) || ((LA22_0 >= '#') && (LA22_0 <= 0xFFFF))))
        	    {
        	        alt22=1;
        	    }

        	}
        	switch (alt22)
        	{
        	    case 1:
        	        // PLSQLLexer.g:225:15: ~ ( '\"' | '\\r' | '\\n' )
        	        {
        	            if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\t')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= '!')) || ((this->LA(1) >= '#') && (this->LA(1) <= 0xFFFF)) )
        	            {
        	                this->consume();
        	            }
        	            else
        	            {
        	                new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	                this->recover();
        	                goto ruleDELIMITED_IDEx;
        	            }


        	        }
        	        break;
        	    case 2:
        	        // PLSQLLexer.g:225:38: '\"' '\"'
        	        {
        	             this->matchc('"');
        	            if  (this->hasException())
        	            {
        	                goto ruleDELIMITED_IDEx;
        	            }


        	             this->matchc('"');
        	            if  (this->hasException())
        	            {
        	                goto ruleDELIMITED_IDEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt22 >= 1 )
        		{
        		    goto loop22;
        		}
        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< PLSQLLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto ruleDELIMITED_IDEx;
        	}
        	cnt22++;
            }
            loop22: ;	/* Jump to here if this rule does not match */
        }

         this->matchc('"');
        if  (this->hasException())
        {
            goto ruleDELIMITED_IDEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleDELIMITED_IDEx; /* Prevent compiler warnings */
    ruleDELIMITED_IDEx: ;

}
// $ANTLR end DELIMITED_ID

//   Comes from: 231:5: ( '%' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PERCENT
 *
 * Looks to match the characters the constitute the token PERCENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPERCENT()
{
    ANTLR_UINT32	_type;
      


    _type	    = PERCENT;


    // PLSQLLexer.g:231:5: ( '%' )
    // PLSQLLexer.g:231:10: '%'
    {
         this->matchc('%');
        if  (this->hasException())
        {
            goto rulePERCENTEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePERCENTEx; /* Prevent compiler warnings */
    rulePERCENTEx: ;

}
// $ANTLR end PERCENT

//   Comes from: 235:5: ( '&' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AMPERSAND
 *
 * Looks to match the characters the constitute the token AMPERSAND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mAMPERSAND()
{
    ANTLR_UINT32	_type;
      


    _type	    = AMPERSAND;


    // PLSQLLexer.g:235:5: ( '&' )
    // PLSQLLexer.g:235:10: '&'
    {
         this->matchc('&');
        if  (this->hasException())
        {
            goto ruleAMPERSANDEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleAMPERSANDEx; /* Prevent compiler warnings */
    ruleAMPERSANDEx: ;

}
// $ANTLR end AMPERSAND

//   Comes from: 239:5: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LEFT_PAREN
 *
 * Looks to match the characters the constitute the token LEFT_PAREN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mLEFT_PAREN()
{
    ANTLR_UINT32	_type;
      


    _type	    = LEFT_PAREN;


    // PLSQLLexer.g:239:5: ( '(' )
    // PLSQLLexer.g:239:10: '('
    {
         this->matchc('(');
        if  (this->hasException())
        {
            goto ruleLEFT_PARENEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLEFT_PARENEx; /* Prevent compiler warnings */
    ruleLEFT_PARENEx: ;

}
// $ANTLR end LEFT_PAREN

//   Comes from: 243:5: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RIGHT_PAREN
 *
 * Looks to match the characters the constitute the token RIGHT_PAREN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mRIGHT_PAREN()
{
    ANTLR_UINT32	_type;
      


    _type	    = RIGHT_PAREN;


    // PLSQLLexer.g:243:5: ( ')' )
    // PLSQLLexer.g:243:10: ')'
    {
         this->matchc(')');
        if  (this->hasException())
        {
            goto ruleRIGHT_PARENEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleRIGHT_PARENEx; /* Prevent compiler warnings */
    ruleRIGHT_PARENEx: ;

}
// $ANTLR end RIGHT_PAREN

//   Comes from: 247:5: ( '**' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBLE_ASTERISK
 *
 * Looks to match the characters the constitute the token DOUBLE_ASTERISK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mDOUBLE_ASTERISK()
{
    ANTLR_UINT32	_type;
      


    _type	    = DOUBLE_ASTERISK;


    // PLSQLLexer.g:247:5: ( '**' )
    // PLSQLLexer.g:247:10: '**'
    {
        this->matchs(lit_2);
        if  (this->hasException())
        {
            goto ruleDOUBLE_ASTERISKEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleDOUBLE_ASTERISKEx; /* Prevent compiler warnings */
    ruleDOUBLE_ASTERISKEx: ;

}
// $ANTLR end DOUBLE_ASTERISK

//   Comes from: 251:5: ( '*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ASTERISK
 *
 * Looks to match the characters the constitute the token ASTERISK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mASTERISK()
{
    ANTLR_UINT32	_type;
      


    _type	    = ASTERISK;


    // PLSQLLexer.g:251:5: ( '*' )
    // PLSQLLexer.g:251:10: '*'
    {
         this->matchc('*');
        if  (this->hasException())
        {
            goto ruleASTERISKEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleASTERISKEx; /* Prevent compiler warnings */
    ruleASTERISKEx: ;

}
// $ANTLR end ASTERISK

//   Comes from: 255:5: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLUS_SIGN
 *
 * Looks to match the characters the constitute the token PLUS_SIGN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLUS_SIGN()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLUS_SIGN;


    // PLSQLLexer.g:255:5: ( '+' )
    // PLSQLLexer.g:255:10: '+'
    {
         this->matchc('+');
        if  (this->hasException())
        {
            goto rulePLUS_SIGNEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLUS_SIGNEx; /* Prevent compiler warnings */
    rulePLUS_SIGNEx: ;

}
// $ANTLR end PLUS_SIGN

//   Comes from: 259:5: ( ',' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMA
 *
 * Looks to match the characters the constitute the token COMMA
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mCOMMA()
{
    ANTLR_UINT32	_type;
      


    _type	    = COMMA;


    // PLSQLLexer.g:259:5: ( ',' )
    // PLSQLLexer.g:259:10: ','
    {
         this->matchc(',');
        if  (this->hasException())
        {
            goto ruleCOMMAEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCOMMAEx; /* Prevent compiler warnings */
    ruleCOMMAEx: ;

}
// $ANTLR end COMMA

//   Comes from: 263:5: ( '/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SOLIDUS
 *
 * Looks to match the characters the constitute the token SOLIDUS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSOLIDUS()
{
    ANTLR_UINT32	_type;
      


    _type	    = SOLIDUS;


    // PLSQLLexer.g:263:5: ( '/' )
    // PLSQLLexer.g:263:10: '/'
    {
         this->matchc('/');
        if  (this->hasException())
        {
            goto ruleSOLIDUSEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSOLIDUSEx; /* Prevent compiler warnings */
    ruleSOLIDUSEx: ;

}
// $ANTLR end SOLIDUS

//   Comes from: 267:5: ( '@' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AT_SIGN
 *
 * Looks to match the characters the constitute the token AT_SIGN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mAT_SIGN()
{
    ANTLR_UINT32	_type;
      


    _type	    = AT_SIGN;


    // PLSQLLexer.g:267:5: ( '@' )
    // PLSQLLexer.g:267:10: '@'
    {
         this->matchc('@');
        if  (this->hasException())
        {
            goto ruleAT_SIGNEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleAT_SIGNEx; /* Prevent compiler warnings */
    ruleAT_SIGNEx: ;

}
// $ANTLR end AT_SIGN

//   Comes from: 271:5: ( ':=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ASSIGN_OP
 *
 * Looks to match the characters the constitute the token ASSIGN_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mASSIGN_OP()
{
    ANTLR_UINT32	_type;
      


    _type	    = ASSIGN_OP;


    // PLSQLLexer.g:271:5: ( ':=' )
    // PLSQLLexer.g:271:10: ':='
    {
        this->matchs(lit_3);
        if  (this->hasException())
        {
            goto ruleASSIGN_OPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleASSIGN_OPEx; /* Prevent compiler warnings */
    ruleASSIGN_OPEx: ;

}
// $ANTLR end ASSIGN_OP

//   Comes from: 276:5: ( COLON SIMPLE_LETTER ( SIMPLE_LETTER | '0' .. '9' | '_' )* | COLON DELIMITED_ID | COLON UNSIGNED_INTEGER | QUESTION_MARK )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BINDVAR
 *
 * Looks to match the characters the constitute the token BINDVAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mBINDVAR()
{
    ANTLR_UINT32	_type;
      


    _type	    = BINDVAR;


    {
        //  PLSQLLexer.g:276:5: ( COLON SIMPLE_LETTER ( SIMPLE_LETTER | '0' .. '9' | '_' )* | COLON DELIMITED_ID | COLON UNSIGNED_INTEGER | QUESTION_MARK )

        ANTLR_UINT32 alt24;

        alt24=4;

        switch ( this->LA(1) )
        {
        case ':':
        	{
        		switch ( this->LA(2) )
        		{
        		case 'A':
        		case 'B':
        		case 'C':
        		case 'D':
        		case 'E':
        		case 'F':
        		case 'G':
        		case 'H':
        		case 'I':
        		case 'J':
        		case 'K':
        		case 'L':
        		case 'M':
        		case 'N':
        		case 'O':
        		case 'P':
        		case 'Q':
        		case 'R':
        		case 'S':
        		case 'T':
        		case 'U':
        		case 'V':
        		case 'W':
        		case 'X':
        		case 'Y':
        		case 'Z':
        		case 'a':
        		case 'b':
        		case 'c':
        		case 'd':
        		case 'e':
        		case 'f':
        		case 'g':
        		case 'h':
        		case 'i':
        		case 'j':
        		case 'k':
        		case 'l':
        		case 'm':
        		case 'n':
        		case 'o':
        		case 'p':
        		case 'q':
        		case 'r':
        		case 's':
        		case 't':
        		case 'u':
        		case 'v':
        		case 'w':
        		case 'x':
        		case 'y':
        		case 'z':
        			{
        				alt24=1;
        			}
        		    break;
        		case '"':
        			{
        				alt24=2;
        			}
        		    break;
        		case '0':
        		case '1':
        		case '2':
        		case '3':
        		case '4':
        		case '5':
        		case '6':
        		case '7':
        		case '8':
        		case '9':
        			{
        				alt24=3;
        			}
        		    break;

        		default:
        		    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        		    ex->set_decisionNum( 24 );
        		    ex->set_state( 1 );


        		    goto ruleBINDVAREx;

        		}

        	}
            break;
        case '?':
        	{
        		alt24=4;
        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 24 );
            ex->set_state( 0 );


            goto ruleBINDVAREx;

        }

        switch (alt24)
        {
    	case 1:
    	    // PLSQLLexer.g:276:10: COLON SIMPLE_LETTER ( SIMPLE_LETTER | '0' .. '9' | '_' )*
    	    {
    	        /* 276:10: COLON SIMPLE_LETTER ( SIMPLE_LETTER | '0' .. '9' | '_' )* */
    	        mCOLON();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	        /* 276:10: COLON SIMPLE_LETTER ( SIMPLE_LETTER | '0' .. '9' | '_' )* */
    	        mSIMPLE_LETTER();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	        // PLSQLLexer.g:276:31: ( SIMPLE_LETTER | '0' .. '9' | '_' )*

    	        for (;;)
    	        {
    	            int alt23=2;
    	            switch ( this->LA(1) )
    	            {
    	            case '0':
    	            case '1':
    	            case '2':
    	            case '3':
    	            case '4':
    	            case '5':
    	            case '6':
    	            case '7':
    	            case '8':
    	            case '9':
    	            case 'A':
    	            case 'B':
    	            case 'C':
    	            case 'D':
    	            case 'E':
    	            case 'F':
    	            case 'G':
    	            case 'H':
    	            case 'I':
    	            case 'J':
    	            case 'K':
    	            case 'L':
    	            case 'M':
    	            case 'N':
    	            case 'O':
    	            case 'P':
    	            case 'Q':
    	            case 'R':
    	            case 'S':
    	            case 'T':
    	            case 'U':
    	            case 'V':
    	            case 'W':
    	            case 'X':
    	            case 'Y':
    	            case 'Z':
    	            case '_':
    	            case 'a':
    	            case 'b':
    	            case 'c':
    	            case 'd':
    	            case 'e':
    	            case 'f':
    	            case 'g':
    	            case 'h':
    	            case 'i':
    	            case 'j':
    	            case 'k':
    	            case 'l':
    	            case 'm':
    	            case 'n':
    	            case 'o':
    	            case 'p':
    	            case 'q':
    	            case 'r':
    	            case 's':
    	            case 't':
    	            case 'u':
    	            case 'v':
    	            case 'w':
    	            case 'x':
    	            case 'y':
    	            case 'z':
    	            	{
    	            		alt23=1;
    	            	}
    	                break;

    	            }

    	            switch (alt23)
    	            {
    	        	case 1:
    	        	    // PLSQLLexer.g:
    	        	    {
    	        	        if ( ((this->LA(1) >= '0') && (this->LA(1) <= '9')) || ((this->LA(1) >= 'A') && (this->LA(1) <= 'Z')) || this->LA(1) == '_' || ((this->LA(1) >= 'a') && (this->LA(1) <= 'z')) )
    	        	        {
    	        	            this->consume();
    	        	        }
    	        	        else
    	        	        {
    	        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

    	        	            this->recover();
    	        	            goto ruleBINDVAREx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop23;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop23: ; /* Jump out to here if this rule does not match */


    	    }
    	    break;
    	case 2:
    	    // PLSQLLexer.g:277:10: COLON DELIMITED_ID
    	    {
    	        /* 277:10: COLON DELIMITED_ID */
    	        mCOLON();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	        /* 277:10: COLON DELIMITED_ID */
    	        mDELIMITED_ID();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	    }
    	    break;
    	case 3:
    	    // PLSQLLexer.g:278:10: COLON UNSIGNED_INTEGER
    	    {
    	        /* 278:10: COLON UNSIGNED_INTEGER */
    	        mCOLON();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	        /* 278:10: COLON UNSIGNED_INTEGER */
    	        mUNSIGNED_INTEGER();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	    }
    	    break;
    	case 4:
    	    // PLSQLLexer.g:279:10: QUESTION_MARK
    	    {
    	        /* 279:10: QUESTION_MARK */
    	        mQUESTION_MARK();
    	        if  (this->hasException())
    	        {
    	            goto ruleBINDVAREx;
    	        }



    	    }
    	    break;

        }
    }
	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleBINDVAREx; /* Prevent compiler warnings */
    ruleBINDVAREx: ;

}
// $ANTLR end BINDVAR

//   Comes from: 283:5: ( ':' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COLON
 *
 * Looks to match the characters the constitute the token COLON
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mCOLON()
{
    ANTLR_UINT32	_type;
      


    _type	    = COLON;


    // PLSQLLexer.g:283:5: ( ':' )
    // PLSQLLexer.g:283:10: ':'
    {
         this->matchc(':');
        if  (this->hasException())
        {
            goto ruleCOLONEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCOLONEx; /* Prevent compiler warnings */
    ruleCOLONEx: ;

}
// $ANTLR end COLON

//   Comes from: 287:5: ( ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SEMICOLON
 *
 * Looks to match the characters the constitute the token SEMICOLON
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSEMICOLON()
{
    ANTLR_UINT32	_type;
      


    _type	    = SEMICOLON;


    // PLSQLLexer.g:287:5: ( ';' )
    // PLSQLLexer.g:287:10: ';'
    {
         this->matchc(';');
        if  (this->hasException())
        {
            goto ruleSEMICOLONEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSEMICOLONEx; /* Prevent compiler warnings */
    ruleSEMICOLONEx: ;

}
// $ANTLR end SEMICOLON

//   Comes from: 291:5: ( '<=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LESS_THAN_OR_EQUALS_OP
 *
 * Looks to match the characters the constitute the token LESS_THAN_OR_EQUALS_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mLESS_THAN_OR_EQUALS_OP()
{
    ANTLR_UINT32	_type;
      


    _type	    = LESS_THAN_OR_EQUALS_OP;


    // PLSQLLexer.g:291:5: ( '<=' )
    // PLSQLLexer.g:291:10: '<='
    {
        this->matchs(lit_4);
        if  (this->hasException())
        {
            goto ruleLESS_THAN_OR_EQUALS_OPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLESS_THAN_OR_EQUALS_OPEx; /* Prevent compiler warnings */
    ruleLESS_THAN_OR_EQUALS_OPEx: ;

}
// $ANTLR end LESS_THAN_OR_EQUALS_OP

//   Comes from: 295:5: ( '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LESS_THAN_OP
 *
 * Looks to match the characters the constitute the token LESS_THAN_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mLESS_THAN_OP()
{
    ANTLR_UINT32	_type;
      


    _type	    = LESS_THAN_OP;


    // PLSQLLexer.g:295:5: ( '<' )
    // PLSQLLexer.g:295:10: '<'
    {
         this->matchc('<');
        if  (this->hasException())
        {
            goto ruleLESS_THAN_OPEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLESS_THAN_OPEx; /* Prevent compiler warnings */
    ruleLESS_THAN_OPEx: ;

}
// $ANTLR end LESS_THAN_OP

//   Comes from: 299:5: ( '>=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GREATER_THAN_OR_EQUALS_OP
 *
 * Looks to match the characters the constitute the token GREATER_THAN_OR_EQUALS_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mGREATER_THAN_OR_EQUALS_OP()
{
    ANTLR_UINT32	_type;
      


    _type	    = GREATER_THAN_OR_EQUALS_OP;


    // PLSQLLexer.g:299:5: ( '>=' )
    // PLSQLLexer.g:299:10: '>='
    {
        this->matchs(lit_5);
        if  (this->hasException())
        {
            goto ruleGREATER_THAN_OR_EQUALS_OPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleGREATER_THAN_OR_EQUALS_OPEx; /* Prevent compiler warnings */
    ruleGREATER_THAN_OR_EQUALS_OPEx: ;

}
// $ANTLR end GREATER_THAN_OR_EQUALS_OP

//   Comes from: 303:5: ( '!=' | '<>' | '^=' | '~=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NOT_EQUAL_OP
 *
 * Looks to match the characters the constitute the token NOT_EQUAL_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mNOT_EQUAL_OP()
{
    ANTLR_UINT32	_type;
      


    _type	    = NOT_EQUAL_OP;


    {
        //  PLSQLLexer.g:303:5: ( '!=' | '<>' | '^=' | '~=' )

        ANTLR_UINT32 alt25;

        alt25=4;

        switch ( this->LA(1) )
        {
        case '!':
        	{
        		alt25=1;
        	}
            break;
        case '<':
        	{
        		alt25=2;
        	}
            break;
        case '^':
        	{
        		alt25=3;
        	}
            break;
        case '~':
        	{
        		alt25=4;
        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 25 );
            ex->set_state( 0 );


            goto ruleNOT_EQUAL_OPEx;

        }

        switch (alt25)
        {
    	case 1:
    	    // PLSQLLexer.g:303:10: '!='
    	    {
    	        this->matchs(lit_6);
    	        if  (this->hasException())
    	        {
    	            goto ruleNOT_EQUAL_OPEx;
    	        }




    	    }
    	    break;
    	case 2:
    	    // PLSQLLexer.g:304:10: '<>'
    	    {
    	        this->matchs(lit_7);
    	        if  (this->hasException())
    	        {
    	            goto ruleNOT_EQUAL_OPEx;
    	        }




    	    }
    	    break;
    	case 3:
    	    // PLSQLLexer.g:305:10: '^='
    	    {
    	        this->matchs(lit_8);
    	        if  (this->hasException())
    	        {
    	            goto ruleNOT_EQUAL_OPEx;
    	        }




    	    }
    	    break;
    	case 4:
    	    // PLSQLLexer.g:306:10: '~='
    	    {
    	        this->matchs(lit_9);
    	        if  (this->hasException())
    	        {
    	            goto ruleNOT_EQUAL_OPEx;
    	        }




    	    }
    	    break;

        }
    }
	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleNOT_EQUAL_OPEx; /* Prevent compiler warnings */
    ruleNOT_EQUAL_OPEx: ;

}
// $ANTLR end NOT_EQUAL_OP

//   Comes from: 309:5: ( '^' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CARRET_OPERATOR_PART
 *
 * Looks to match the characters the constitute the token CARRET_OPERATOR_PART
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mCARRET_OPERATOR_PART()
{
    ANTLR_UINT32	_type;
      


    _type	    = CARRET_OPERATOR_PART;


    // PLSQLLexer.g:309:5: ( '^' )
    // PLSQLLexer.g:309:10: '^'
    {
         this->matchc('^');
        if  (this->hasException())
        {
            goto ruleCARRET_OPERATOR_PARTEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCARRET_OPERATOR_PARTEx; /* Prevent compiler warnings */
    ruleCARRET_OPERATOR_PARTEx: ;

}
// $ANTLR end CARRET_OPERATOR_PART

//   Comes from: 313:5: ( '~' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TILDE_OPERATOR_PART
 *
 * Looks to match the characters the constitute the token TILDE_OPERATOR_PART
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mTILDE_OPERATOR_PART()
{
    ANTLR_UINT32	_type;
      


    _type	    = TILDE_OPERATOR_PART;


    // PLSQLLexer.g:313:5: ( '~' )
    // PLSQLLexer.g:313:10: '~'
    {
         this->matchc('~');
        if  (this->hasException())
        {
            goto ruleTILDE_OPERATOR_PARTEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleTILDE_OPERATOR_PARTEx; /* Prevent compiler warnings */
    ruleTILDE_OPERATOR_PARTEx: ;

}
// $ANTLR end TILDE_OPERATOR_PART

//   Comes from: 317:5: ( '!' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXCLAMATION_OPERATOR_PART
 *
 * Looks to match the characters the constitute the token EXCLAMATION_OPERATOR_PART
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mEXCLAMATION_OPERATOR_PART()
{
    ANTLR_UINT32	_type;
      


    _type	    = EXCLAMATION_OPERATOR_PART;


    // PLSQLLexer.g:317:5: ( '!' )
    // PLSQLLexer.g:317:10: '!'
    {
         this->matchc('!');
        if  (this->hasException())
        {
            goto ruleEXCLAMATION_OPERATOR_PARTEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleEXCLAMATION_OPERATOR_PARTEx; /* Prevent compiler warnings */
    ruleEXCLAMATION_OPERATOR_PARTEx: ;

}
// $ANTLR end EXCLAMATION_OPERATOR_PART

//   Comes from: 321:5: ( '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GREATER_THAN_OP
 *
 * Looks to match the characters the constitute the token GREATER_THAN_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mGREATER_THAN_OP()
{
    ANTLR_UINT32	_type;
      


    _type	    = GREATER_THAN_OP;


    // PLSQLLexer.g:321:5: ( '>' )
    // PLSQLLexer.g:321:10: '>'
    {
         this->matchc('>');
        if  (this->hasException())
        {
            goto ruleGREATER_THAN_OPEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleGREATER_THAN_OPEx; /* Prevent compiler warnings */
    ruleGREATER_THAN_OPEx: ;

}
// $ANTLR end GREATER_THAN_OP

//   Comes from: 326:5: ( '?' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QUESTION_MARK
 *
 * Looks to match the characters the constitute the token QUESTION_MARK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mQUESTION_MARK()
{
    ANTLR_UINT32	_type;
      



    // PLSQLLexer.g:326:5: ( '?' )
    // PLSQLLexer.g:326:10: '?'
    {
         this->matchc('?');
        if  (this->hasException())
        {
            goto ruleQUESTION_MARKEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleQUESTION_MARKEx; /* Prevent compiler warnings */
    ruleQUESTION_MARKEx: ;

}
// $ANTLR end QUESTION_MARK

//   Comes from: 331:5: ( '||' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CONCATENATION_OP
 *
 * Looks to match the characters the constitute the token CONCATENATION_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mCONCATENATION_OP()
{
    ANTLR_UINT32	_type;
      


    _type	    = CONCATENATION_OP;


    // PLSQLLexer.g:331:5: ( '||' )
    // PLSQLLexer.g:331:10: '||'
    {
        this->matchs(lit_10);
        if  (this->hasException())
        {
            goto ruleCONCATENATION_OPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCONCATENATION_OPEx; /* Prevent compiler warnings */
    ruleCONCATENATION_OPEx: ;

}
// $ANTLR end CONCATENATION_OP

//   Comes from: 335:5: ( '|' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start VERTICAL_BAR
 *
 * Looks to match the characters the constitute the token VERTICAL_BAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mVERTICAL_BAR()
{
    ANTLR_UINT32	_type;
      


    _type	    = VERTICAL_BAR;


    // PLSQLLexer.g:335:5: ( '|' )
    // PLSQLLexer.g:335:10: '|'
    {
         this->matchc('|');
        if  (this->hasException())
        {
            goto ruleVERTICAL_BAREx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleVERTICAL_BAREx; /* Prevent compiler warnings */
    ruleVERTICAL_BAREx: ;

}
// $ANTLR end VERTICAL_BAR

//   Comes from: 339:5: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EQUALS_OP
 *
 * Looks to match the characters the constitute the token EQUALS_OP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mEQUALS_OP()
{
    ANTLR_UINT32	_type;
      


    _type	    = EQUALS_OP;


    // PLSQLLexer.g:339:5: ( '=' )
    // PLSQLLexer.g:339:10: '='
    {
         this->matchc('=');
        if  (this->hasException())
        {
            goto ruleEQUALS_OPEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleEQUALS_OPEx; /* Prevent compiler warnings */
    ruleEQUALS_OPEx: ;

}
// $ANTLR end EQUALS_OP

//   Comes from: 344:5: ( '[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LEFT_BRACKET
 *
 * Looks to match the characters the constitute the token LEFT_BRACKET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mLEFT_BRACKET()
{
    ANTLR_UINT32	_type;
      


    _type	    = LEFT_BRACKET;


    // PLSQLLexer.g:344:5: ( '[' )
    // PLSQLLexer.g:344:10: '['
    {
         this->matchc('[');
        if  (this->hasException())
        {
            goto ruleLEFT_BRACKETEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLEFT_BRACKETEx; /* Prevent compiler warnings */
    ruleLEFT_BRACKETEx: ;

}
// $ANTLR end LEFT_BRACKET

//   Comes from: 348:5: ( ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RIGHT_BRACKET
 *
 * Looks to match the characters the constitute the token RIGHT_BRACKET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mRIGHT_BRACKET()
{
    ANTLR_UINT32	_type;
      


    _type	    = RIGHT_BRACKET;


    // PLSQLLexer.g:348:5: ( ']' )
    // PLSQLLexer.g:348:10: ']'
    {
         this->matchc(']');
        if  (this->hasException())
        {
            goto ruleRIGHT_BRACKETEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleRIGHT_BRACKETEx; /* Prevent compiler warnings */
    ruleRIGHT_BRACKETEx: ;

}
// $ANTLR end RIGHT_BRACKET

//   Comes from: 355:5: ( '_' ( SEPARATOR )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INTRODUCER
 *
 * Looks to match the characters the constitute the token INTRODUCER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mINTRODUCER()
{
    ANTLR_UINT32	_type;
      


    _type	    = INTRODUCER;


    // PLSQLLexer.g:355:5: ( '_' ( SEPARATOR )? )
    // PLSQLLexer.g:355:10: '_' ( SEPARATOR )?
    {
         this->matchc('_');
        if  (this->hasException())
        {
            goto ruleINTRODUCEREx;
        }


        // PLSQLLexer.g:355:14: ( SEPARATOR )?
        {
            int alt26=2;
            switch ( this->LA(1) )
            {
                case '\t':
                case '\n':
                case '\r':
                case ' ':
                case '-':
                case '/':
                	{
                		alt26=1;
                	}
                    break;
            }

            switch (alt26)
            {
        	case 1:
        	    // PLSQLLexer.g:355:15: SEPARATOR
        	    {
        	        /* 355:15: SEPARATOR */
        	        mSEPARATOR();
        	        if  (this->hasException())
        	        {
        	            goto ruleINTRODUCEREx;
        	        }



        	        {
        	            _type = UNDERSCORE;
        	        }


        	    }
        	    break;

            }
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleINTRODUCEREx; /* Prevent compiler warnings */
    ruleINTRODUCEREx: ;

}
// $ANTLR end INTRODUCER

//   Comes from: 361:5: ( '-' | COMMENT | ( SPACE | NEWLINE )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SEPARATOR
 *
 * Looks to match the characters the constitute the token SEPARATOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSEPARATOR()
{
    ANTLR_UINT32	_type;
      


    _type	    = SEPARATOR;


    {
        //  PLSQLLexer.g:361:5: ( '-' | COMMENT | ( SPACE | NEWLINE )+ )

        ANTLR_UINT32 alt28;

        alt28=3;

        switch ( this->LA(1) )
        {
        case '-':
        	{
        		switch ( this->LA(2) )
        		{
        		case '-':
        			{
        				alt28=2;
        			}
        		    break;

        		default:
        		    alt28=1;
        		}

        	}
            break;
        case '/':
        	{
        		alt28=2;
        	}
            break;
        case '\t':
        case '\n':
        case '\r':
        case ' ':
        	{
        		alt28=3;
        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 28 );
            ex->set_state( 0 );


            goto ruleSEPARATOREx;

        }

        switch (alt28)
        {
    	case 1:
    	    // PLSQLLexer.g:361:10: '-'
    	    {
    	         this->matchc('-');
    	        if  (this->hasException())
    	        {
    	            goto ruleSEPARATOREx;
    	        }


    	        {
    	            _type = MINUS_SIGN;
    	        }


    	    }
    	    break;
    	case 2:
    	    // PLSQLLexer.g:362:10: COMMENT
    	    {
    	        /* 362:10: COMMENT */
    	        mCOMMENT();
    	        if  (this->hasException())
    	        {
    	            goto ruleSEPARATOREx;
    	        }



    	        {
    	             this->get_state()->get_channel()=HIDDEN; 
    	        }


    	    }
    	    break;
    	case 3:
    	    // PLSQLLexer.g:363:10: ( SPACE | NEWLINE )+
    	    {
    	        // PLSQLLexer.g:363:10: ( SPACE | NEWLINE )+
    	        {
    	            int cnt27=0;

    	            for (;;)
    	            {
    	                int alt27=3;
    	        	switch ( this->LA(1) )
    	        	{
    	        	case '\t':
    	        	case ' ':
    	        		{
    	        			alt27=1;
    	        		}
    	        	    break;
    	        	case '\n':
    	        	case '\r':
    	        		{
    	        			alt27=2;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt27)
    	        	{
    	        	    case 1:
    	        	        // PLSQLLexer.g:363:11: SPACE
    	        	        {
    	        	            /* 363:11: SPACE */
    	        	            mSPACE();
    	        	            if  (this->hasException())
    	        	            {
    	        	                goto ruleSEPARATOREx;
    	        	            }



    	        	        }
    	        	        break;
    	        	    case 2:
    	        	        // PLSQLLexer.g:363:19: NEWLINE
    	        	        {
    	        	            /* 363:19: NEWLINE */
    	        	            mNEWLINE();
    	        	            if  (this->hasException())
    	        	            {
    	        	                goto ruleSEPARATOREx;
    	        	            }



    	        	        }
    	        	        break;

    	        	    default:

    	        		if ( cnt27 >= 1 )
    	        		{
    	        		    goto loop27;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		new ANTLR_Exception< PLSQLLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


    	        		goto ruleSEPARATOREx;
    	        	}
    	        	cnt27++;
    	            }
    	            loop27: ;	/* Jump to here if this rule does not match */
    	        }

    	        {
    	             this->get_state()->get_channel()=HIDDEN; 
    	        }


    	    }
    	    break;

        }
    }
	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSEPARATOREx; /* Prevent compiler warnings */
    ruleSEPARATOREx: ;

}
// $ANTLR end SEPARATOR

//   Comes from: 371:5: ( 'a' .. 'z' | 'A' .. 'Z' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SIMPLE_LETTER
 *
 * Looks to match the characters the constitute the token SIMPLE_LETTER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSIMPLE_LETTER()
{
    ANTLR_UINT32	_type;
      



    // PLSQLLexer.g:371:5: ( 'a' .. 'z' | 'A' .. 'Z' )
    // PLSQLLexer.g:
    {
        if ( ((this->LA(1) >= 'A') && (this->LA(1) <= 'Z')) || ((this->LA(1) >= 'a') && (this->LA(1) <= 'z')) )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleSIMPLE_LETTEREx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleSIMPLE_LETTEREx; /* Prevent compiler warnings */
    ruleSIMPLE_LETTEREx: ;

}
// $ANTLR end SIMPLE_LETTER

//   Comes from: 380:5: ( ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNSIGNED_INTEGER
 *
 * Looks to match the characters the constitute the token UNSIGNED_INTEGER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mUNSIGNED_INTEGER()
{
    ANTLR_UINT32	_type;
      



    // PLSQLLexer.g:380:5: ( ( '0' .. '9' )+ )
    // PLSQLLexer.g:380:10: ( '0' .. '9' )+
    {
        // PLSQLLexer.g:380:10: ( '0' .. '9' )+
        {
            int cnt29=0;

            for (;;)
            {
                int alt29=2;
        	switch ( this->LA(1) )
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt29=1;
        		}
        	    break;

        	}

        	switch (alt29)
        	{
        	    case 1:
        	        // PLSQLLexer.g:
        	        {
        	            if ( ((this->LA(1) >= '0') && (this->LA(1) <= '9')) )
        	            {
        	                this->consume();
        	            }
        	            else
        	            {
        	                new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	                this->recover();
        	                goto ruleUNSIGNED_INTEGEREx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt29 >= 1 )
        		{
        		    goto loop29;
        		}
        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< PLSQLLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto ruleUNSIGNED_INTEGEREx;
        	}
        	cnt29++;
            }
            loop29: ;	/* Jump to here if this rule does not match */
        }

    }


    // This is where rules clean up and exit
    //
    goto ruleUNSIGNED_INTEGEREx; /* Prevent compiler warnings */
    ruleUNSIGNED_INTEGEREx: ;

}
// $ANTLR end UNSIGNED_INTEGER

//   Comes from: 387:5: ( '--' (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF ) | '/*' ( options {greedy=false; } : . )* '*/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT
 *
 * Looks to match the characters the constitute the token COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mCOMMENT()
{
    ANTLR_UINT32	_type;
      



    {
        //  PLSQLLexer.g:387:5: ( '--' (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF ) | '/*' ( options {greedy=false; } : . )* '*/' )

        ANTLR_UINT32 alt33;

        alt33=2;

        switch ( this->LA(1) )
        {
        case '-':
        	{
        		alt33=1;
        	}
            break;
        case '/':
        	{
        		alt33=2;
        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 33 );
            ex->set_state( 0 );


            goto ruleCOMMENTEx;

        }

        switch (alt33)
        {
    	case 1:
    	    // PLSQLLexer.g:387:10: '--' (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF )
    	    {
    	        this->matchs(lit_11);
    	        if  (this->hasException())
    	        {
    	            goto ruleCOMMENTEx;
    	        }




    	        // PLSQLLexer.g:387:15: (~ ( '\\r' | '\\n' ) )*

    	        for (;;)
    	        {
    	            int alt30=2;
    	            {
    	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                */
    	                int LA30_0 = this->LA(1);
    	                if ( (((LA30_0 >= 0x0000) && (LA30_0 <= '\t')) || ((LA30_0 >= 0x000B) && (LA30_0 <= '\f')) || ((LA30_0 >= 0x000E) && (LA30_0 <= 0xFFFF))))
    	                {
    	                    alt30=1;
    	                }

    	            }
    	            switch (alt30)
    	            {
    	        	case 1:
    	        	    // PLSQLLexer.g:
    	        	    {
    	        	        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\t')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= 0xFFFF)) )
    	        	        {
    	        	            this->consume();
    	        	        }
    	        	        else
    	        	        {
    	        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

    	        	            this->recover();
    	        	            goto ruleCOMMENTEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop30;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop30: ; /* Jump out to here if this rule does not match */


    	        // PLSQLLexer.g:387:35: ( NEWLINE | EOF )
    	        {
    	            int alt31=2;
    	            switch ( this->LA(1) )
    	            {
    	            case '\n':
    	            case '\r':
    	            	{
    	            		alt31=1;
    	            	}
    	                break;

    	            default:
    	                alt31=2;
    	            }

    	            switch (alt31)
    	            {
    	        	case 1:
    	        	    // PLSQLLexer.g:387:36: NEWLINE
    	        	    {
    	        	        /* 387:36: NEWLINE */
    	        	        mNEWLINE();
    	        	        if  (this->hasException())
    	        	        {
    	        	            goto ruleCOMMENTEx;
    	        	        }



    	        	    }
    	        	    break;
    	        	case 2:
    	        	    // PLSQLLexer.g:387:44: EOF
    	        	    {
    	        	            this->matchc(ANTLR_CHARSTREAM_EOF);
    	        	            if  (this->hasException())
    	        	            {
    	        	                goto ruleCOMMENTEx;
    	        	            }



    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 2:
    	    // PLSQLLexer.g:388:10: '/*' ( options {greedy=false; } : . )* '*/'
    	    {
    	        this->matchs(lit_12);
    	        if  (this->hasException())
    	        {
    	            goto ruleCOMMENTEx;
    	        }




    	        // PLSQLLexer.g:388:15: ( options {greedy=false; } : . )*

    	        for (;;)
    	        {
    	            int alt32=2;
    	            {
    	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                */
    	                int LA32_0 = this->LA(1);
    	                if ( (LA32_0 == '*'))
    	                {
    	                    {
    	                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                        */
    	                        int LA32_1 = this->LA(2);
    	                        if ( (LA32_1 == '/'))
    	                        {
    	                            alt32=2;
    	                        }
    	                        else if ( (((LA32_1 >= 0x0000) && (LA32_1 <= '.')) || ((LA32_1 >= '0') && (LA32_1 <= 0xFFFF))))
    	                        {
    	                            alt32=1;
    	                        }

    	                    }
    	                }
    	                else if ( (((LA32_0 >= 0x0000) && (LA32_0 <= ')')) || ((LA32_0 >= '+') && (LA32_0 <= 0xFFFF))))
    	                {
    	                    alt32=1;
    	                }

    	            }
    	            switch (alt32)
    	            {
    	        	case 1:
    	        	    // PLSQLLexer.g:388:41: .
    	        	    {
    	        	        this->matchAny();
    	        	        if  (this->hasException())
    	        	        {
    	        	            goto ruleCOMMENTEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop32;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop32: ; /* Jump out to here if this rule does not match */


    	        this->matchs(lit_13);
    	        if  (this->hasException())
    	        {
    	            goto ruleCOMMENTEx;
    	        }




    	    }
    	    break;

        }
    }

    // This is where rules clean up and exit
    //
    goto ruleCOMMENTEx; /* Prevent compiler warnings */
    ruleCOMMENTEx: ;

}
// $ANTLR end COMMENT

//   Comes from: 395:2: ( 'PROMPT' SPACE (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PROMPT
 *
 * Looks to match the characters the constitute the token PROMPT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPROMPT()
{
    ANTLR_UINT32	_type;
      


    _type	    = PROMPT;


    // PLSQLLexer.g:395:2: ( 'PROMPT' SPACE (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF ) )
    // PLSQLLexer.g:395:4: 'PROMPT' SPACE (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF )
    {
        this->matchs(lit_14);
        if  (this->hasException())
        {
            goto rulePROMPTEx;
        }




        /* 395:4: 'PROMPT' SPACE (~ ( '\\r' | '\\n' ) )* ( NEWLINE | EOF ) */
        mSPACE();
        if  (this->hasException())
        {
            goto rulePROMPTEx;
        }



        // PLSQLLexer.g:395:19: (~ ( '\\r' | '\\n' ) )*

        for (;;)
        {
            int alt34=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA34_0 = this->LA(1);
                if ( (((LA34_0 >= 0x0000) && (LA34_0 <= '\t')) || ((LA34_0 >= 0x000B) && (LA34_0 <= '\f')) || ((LA34_0 >= 0x000E) && (LA34_0 <= 0xFFFF))))
                {
                    alt34=1;
                }

            }
            switch (alt34)
            {
        	case 1:
        	    // PLSQLLexer.g:
        	    {
        	        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\t')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= 0xFFFF)) )
        	        {
        	            this->consume();
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            this->recover();
        	            goto rulePROMPTEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop34;	/* break out of the loop */
        	    break;
            }
        }
        loop34: ; /* Jump out to here if this rule does not match */


        // PLSQLLexer.g:395:39: ( NEWLINE | EOF )
        {
            int alt35=2;
            switch ( this->LA(1) )
            {
            case '\n':
            case '\r':
            	{
            		alt35=1;
            	}
                break;

            default:
                alt35=2;
            }

            switch (alt35)
            {
        	case 1:
        	    // PLSQLLexer.g:395:40: NEWLINE
        	    {
        	        /* 395:40: NEWLINE */
        	        mNEWLINE();
        	        if  (this->hasException())
        	        {
        	            goto rulePROMPTEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // PLSQLLexer.g:395:48: EOF
        	    {
        	            this->matchc(ANTLR_CHARSTREAM_EOF);
        	            if  (this->hasException())
        	            {
        	                goto rulePROMPTEx;
        	            }



        	    }
        	    break;

            }
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePROMPTEx; /* Prevent compiler warnings */
    rulePROMPTEx: ;

}
// $ANTLR end PROMPT

//   Comes from: 404:5: ( '\\r' ( options {greedy=true; } : '\\n' )? | '\\n' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NEWLINE
 *
 * Looks to match the characters the constitute the token NEWLINE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mNEWLINE()
{
    ANTLR_UINT32	_type;
      



    {
        //  PLSQLLexer.g:404:5: ( '\\r' ( options {greedy=true; } : '\\n' )? | '\\n' )

        ANTLR_UINT32 alt37;

        alt37=2;

        switch ( this->LA(1) )
        {
        case '\r':
        	{
        		alt37=1;
        	}
            break;
        case '\n':
        	{
        		alt37=2;
        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 37 );
            ex->set_state( 0 );


            goto ruleNEWLINEEx;

        }

        switch (alt37)
        {
    	case 1:
    	    // PLSQLLexer.g:404:10: '\\r' ( options {greedy=true; } : '\\n' )?
    	    {
    	         this->matchc('\r');
    	        if  (this->hasException())
    	        {
    	            goto ruleNEWLINEEx;
    	        }


    	        // PLSQLLexer.g:404:15: ( options {greedy=true; } : '\\n' )?
    	        {
    	            int alt36=2;
    	            switch ( this->LA(1) )
    	            {
    	                case '\n':
    	                	{
    	                		alt36=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt36)
    	            {
    	        	case 1:
    	        	    // PLSQLLexer.g:404:39: '\\n'
    	        	    {
    	        	         this->matchc('\n');
    	        	        if  (this->hasException())
    	        	        {
    	        	            goto ruleNEWLINEEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 2:
    	    // PLSQLLexer.g:405:10: '\\n'
    	    {
    	         this->matchc('\n');
    	        if  (this->hasException())
    	        {
    	            goto ruleNEWLINEEx;
    	        }


    	    }
    	    break;

        }
    }

    // This is where rules clean up and exit
    //
    goto ruleNEWLINEEx; /* Prevent compiler warnings */
    ruleNEWLINEEx: ;

}
// $ANTLR end NEWLINE

//   Comes from: 411:10: ( ' ' | '\\t' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SPACE
 *
 * Looks to match the characters the constitute the token SPACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSPACE()
{
    ANTLR_UINT32	_type;
      



    // PLSQLLexer.g:411:10: ( ' ' | '\\t' )
    // PLSQLLexer.g:
    {
        if ( this->LA(1) == '\t' || this->LA(1) == ' ' )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleSPACEEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleSPACEEx; /* Prevent compiler warnings */
    ruleSPACEEx: ;

}
// $ANTLR end SPACE

//   Comes from: 416:29: ()
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start APPROXIMATE_NUM_LIT
 *
 * Looks to match the characters the constitute the token APPROXIMATE_NUM_LIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mAPPROXIMATE_NUM_LIT()
{
    ANTLR_UINT32	_type;
      



    // PLSQLLexer.g:416:29: ()
    // PLSQLLexer.g:416:31: 
    {
    }


    // This is where rules clean up and exit
    //
    goto ruleAPPROXIMATE_NUM_LITEx; /* Prevent compiler warnings */
    ruleAPPROXIMATE_NUM_LITEx: ;

}
// $ANTLR end APPROXIMATE_NUM_LIT

//   Comes from: 417:20: ()
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MINUS_SIGN
 *
 * Looks to match the characters the constitute the token MINUS_SIGN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mMINUS_SIGN()
{
    ANTLR_UINT32	_type;
      



    // PLSQLLexer.g:417:20: ()
    // PLSQLLexer.g:417:22: 
    {
    }


    // This is where rules clean up and exit
    //
    goto ruleMINUS_SIGNEx; /* Prevent compiler warnings */
    ruleMINUS_SIGNEx: ;

}
// $ANTLR end MINUS_SIGN

//   Comes from: 418:20: ()
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNDERSCORE
 *
 * Looks to match the characters the constitute the token UNDERSCORE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mUNDERSCORE()
{
    ANTLR_UINT32	_type;
      



    // PLSQLLexer.g:418:20: ()
    // PLSQLLexer.g:418:22: 
    {
    }


    // This is where rules clean up and exit
    //
    goto ruleUNDERSCOREEx; /* Prevent compiler warnings */
    ruleUNDERSCOREEx: ;

}
// $ANTLR end UNDERSCORE

//   Comes from: 419:23: ()
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBLE_PERIOD
 *
 * Looks to match the characters the constitute the token DOUBLE_PERIOD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mDOUBLE_PERIOD()
{
    ANTLR_UINT32	_type;
      



    // PLSQLLexer.g:419:23: ()
    // PLSQLLexer.g:419:25: 
    {
    }


    // This is where rules clean up and exit
    //
    goto ruleDOUBLE_PERIODEx; /* Prevent compiler warnings */
    ruleDOUBLE_PERIODEx: ;

}
// $ANTLR end DOUBLE_PERIOD

//   Comes from: 425:5: ( 'ALL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ALL
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ALL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_ALL()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_ALL;


    // PLSQLLexer.g:425:5: ( 'ALL' )
    // PLSQLLexer.g:425:10: 'ALL'
    {
        this->matchs(lit_15);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ALLEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ALLEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ALLEx: ;

}
// $ANTLR end SQL92_RESERVED_ALL

//   Comes from: 429:5: ( 'ALTER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ALTER
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ALTER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_ALTER()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_ALTER;


    // PLSQLLexer.g:429:5: ( 'ALTER' )
    // PLSQLLexer.g:429:10: 'ALTER'
    {
        this->matchs(lit_16);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ALTEREx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ALTEREx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ALTEREx: ;

}
// $ANTLR end SQL92_RESERVED_ALTER

//   Comes from: 433:5: ( 'AND' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_AND
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_AND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_AND()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_AND;


    // PLSQLLexer.g:433:5: ( 'AND' )
    // PLSQLLexer.g:433:10: 'AND'
    {
        this->matchs(lit_17);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ANDEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ANDEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ANDEx: ;

}
// $ANTLR end SQL92_RESERVED_AND

//   Comes from: 437:5: ( 'ANY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ANY
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ANY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_ANY()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_ANY;


    // PLSQLLexer.g:437:5: ( 'ANY' )
    // PLSQLLexer.g:437:10: 'ANY'
    {
        this->matchs(lit_18);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ANYEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ANYEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ANYEx: ;

}
// $ANTLR end SQL92_RESERVED_ANY

//   Comes from: 441:5: ( 'AS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_AS
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_AS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_AS()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_AS;


    // PLSQLLexer.g:441:5: ( 'AS' )
    // PLSQLLexer.g:441:10: 'AS'
    {
        this->matchs(lit_19);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ASEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ASEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ASEx: ;

}
// $ANTLR end SQL92_RESERVED_AS

//   Comes from: 445:5: ( 'ASC' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ASC
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ASC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_ASC()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_ASC;


    // PLSQLLexer.g:445:5: ( 'ASC' )
    // PLSQLLexer.g:445:10: 'ASC'
    {
        this->matchs(lit_20);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ASCEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ASCEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ASCEx: ;

}
// $ANTLR end SQL92_RESERVED_ASC

//   Comes from: 453:5: ( 'BEGIN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_BEGIN
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_BEGIN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_BEGIN()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_BEGIN;


    // PLSQLLexer.g:453:5: ( 'BEGIN' )
    // PLSQLLexer.g:453:10: 'BEGIN'
    {
        this->matchs(lit_21);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_BEGINEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_BEGINEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_BEGINEx: ;

}
// $ANTLR end SQL92_RESERVED_BEGIN

//   Comes from: 457:5: ( 'BETWEEN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_BETWEEN
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_BETWEEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_BETWEEN()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_BETWEEN;


    // PLSQLLexer.g:457:5: ( 'BETWEEN' )
    // PLSQLLexer.g:457:10: 'BETWEEN'
    {
        this->matchs(lit_22);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_BETWEENEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_BETWEENEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_BETWEENEx: ;

}
// $ANTLR end SQL92_RESERVED_BETWEEN

//   Comes from: 461:5: ( 'BY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_BY
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_BY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_BY()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_BY;


    // PLSQLLexer.g:461:5: ( 'BY' )
    // PLSQLLexer.g:461:10: 'BY'
    {
        this->matchs(lit_23);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_BYEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_BYEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_BYEx: ;

}
// $ANTLR end SQL92_RESERVED_BY

//   Comes from: 465:5: ( 'CASE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_CASE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_CASE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_CASE()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_CASE;


    // PLSQLLexer.g:465:5: ( 'CASE' )
    // PLSQLLexer.g:465:10: 'CASE'
    {
        this->matchs(lit_24);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_CASEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_CASEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_CASEEx: ;

}
// $ANTLR end SQL92_RESERVED_CASE

//   Comes from: 469:5: ( 'CHECK' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_CHECK
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_CHECK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_CHECK()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_CHECK;


    // PLSQLLexer.g:469:5: ( 'CHECK' )
    // PLSQLLexer.g:469:10: 'CHECK'
    {
        this->matchs(lit_25);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_CHECKEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_CHECKEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_CHECKEx: ;

}
// $ANTLR end SQL92_RESERVED_CHECK

//   Comes from: 473:5: ( 'CLUSTERS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_CLUSTERS
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_CLUSTERS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_CLUSTERS()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_CLUSTERS;


    // PLSQLLexer.g:473:5: ( 'CLUSTERS' )
    // PLSQLLexer.g:473:10: 'CLUSTERS'
    {
        this->matchs(lit_26);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_CLUSTERSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_CLUSTERSEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_CLUSTERSEx: ;

}
// $ANTLR end PLSQL_RESERVED_CLUSTERS

//   Comes from: 477:5: ( 'COLAUTH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_COLAUTH
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_COLAUTH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_COLAUTH()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_COLAUTH;


    // PLSQLLexer.g:477:5: ( 'COLAUTH' )
    // PLSQLLexer.g:477:10: 'COLAUTH'
    {
        this->matchs(lit_27);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_COLAUTHEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_COLAUTHEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_COLAUTHEx: ;

}
// $ANTLR end PLSQL_RESERVED_COLAUTH

//   Comes from: 481:5: ( 'COMPRESS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_COMPRESS
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_COMPRESS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_COMPRESS()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_COMPRESS;


    // PLSQLLexer.g:481:5: ( 'COMPRESS' )
    // PLSQLLexer.g:481:10: 'COMPRESS'
    {
        this->matchs(lit_28);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_COMPRESSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_COMPRESSEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_COMPRESSEx: ;

}
// $ANTLR end PLSQL_RESERVED_COMPRESS

//   Comes from: 485:5: ( 'CONNECT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_CONNECT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_CONNECT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_CONNECT()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_CONNECT;


    // PLSQLLexer.g:485:5: ( 'CONNECT' )
    // PLSQLLexer.g:485:10: 'CONNECT'
    {
        this->matchs(lit_29);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_CONNECTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_CONNECTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_CONNECTEx: ;

}
// $ANTLR end SQL92_RESERVED_CONNECT

//   Comes from: 493:5: ( 'CONNECT_BY_ROOT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_CONNECT_BY_ROOT
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_CONNECT_BY_ROOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_NON_RESERVED_CONNECT_BY_ROOT()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_NON_RESERVED_CONNECT_BY_ROOT;


    // PLSQLLexer.g:493:5: ( 'CONNECT_BY_ROOT' )
    // PLSQLLexer.g:493:10: 'CONNECT_BY_ROOT'
    {
        this->matchs(lit_30);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_CONNECT_BY_ROOTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_CONNECT_BY_ROOTEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_CONNECT_BY_ROOTEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_CONNECT_BY_ROOT

//   Comes from: 497:5: ( 'CRASH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_CRASH
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_CRASH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_CRASH()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_CRASH;


    // PLSQLLexer.g:497:5: ( 'CRASH' )
    // PLSQLLexer.g:497:10: 'CRASH'
    {
        this->matchs(lit_31);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_CRASHEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_CRASHEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_CRASHEx: ;

}
// $ANTLR end PLSQL_RESERVED_CRASH

//   Comes from: 501:5: ( 'CREATE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_CREATE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_CREATE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_CREATE()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_CREATE;


    // PLSQLLexer.g:501:5: ( 'CREATE' )
    // PLSQLLexer.g:501:10: 'CREATE'
    {
        this->matchs(lit_32);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_CREATEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_CREATEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_CREATEEx: ;

}
// $ANTLR end SQL92_RESERVED_CREATE

//   Comes from: 505:5: ( 'CURRENT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_CURRENT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_CURRENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_CURRENT()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_CURRENT;


    // PLSQLLexer.g:505:5: ( 'CURRENT' )
    // PLSQLLexer.g:505:10: 'CURRENT'
    {
        this->matchs(lit_33);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_CURRENTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_CURRENTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_CURRENTEx: ;

}
// $ANTLR end SQL92_RESERVED_CURRENT

//   Comes from: 509:5: ( 'CURSOR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_CURSOR
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_CURSOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_CURSOR()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_CURSOR;


    // PLSQLLexer.g:509:5: ( 'CURSOR' )
    // PLSQLLexer.g:509:10: 'CURSOR'
    {
        this->matchs(lit_34);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_CURSOREx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_CURSOREx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_CURSOREx: ;

}
// $ANTLR end SQL92_RESERVED_CURSOR

//   Comes from: 513:5: ( 'DATE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DATE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DATE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_DATE()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_DATE;


    // PLSQLLexer.g:513:5: ( 'DATE' )
    // PLSQLLexer.g:513:10: 'DATE'
    {
        this->matchs(lit_35);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DATEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DATEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DATEEx: ;

}
// $ANTLR end SQL92_RESERVED_DATE

//   Comes from: 517:5: ( 'DECLARE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DECLARE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DECLARE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_DECLARE()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_DECLARE;


    // PLSQLLexer.g:517:5: ( 'DECLARE' )
    // PLSQLLexer.g:517:10: 'DECLARE'
    {
        this->matchs(lit_36);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DECLAREEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DECLAREEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DECLAREEx: ;

}
// $ANTLR end SQL92_RESERVED_DECLARE

//   Comes from: 521:5: ( 'DEFAULT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DEFAULT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DEFAULT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_DEFAULT()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_DEFAULT;


    // PLSQLLexer.g:521:5: ( 'DEFAULT' )
    // PLSQLLexer.g:521:10: 'DEFAULT'
    {
        this->matchs(lit_37);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DEFAULTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DEFAULTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DEFAULTEx: ;

}
// $ANTLR end SQL92_RESERVED_DEFAULT

//   Comes from: 525:5: ( 'DELETE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DELETE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DELETE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_DELETE()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_DELETE;


    // PLSQLLexer.g:525:5: ( 'DELETE' )
    // PLSQLLexer.g:525:10: 'DELETE'
    {
        this->matchs(lit_38);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DELETEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DELETEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DELETEEx: ;

}
// $ANTLR end SQL92_RESERVED_DELETE

//   Comes from: 529:5: ( 'DESC' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DESC
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DESC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_DESC()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_DESC;


    // PLSQLLexer.g:529:5: ( 'DESC' )
    // PLSQLLexer.g:529:10: 'DESC'
    {
        this->matchs(lit_39);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DESCEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DESCEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DESCEx: ;

}
// $ANTLR end SQL92_RESERVED_DESC

//   Comes from: 533:5: ( 'DISTINCT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DISTINCT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DISTINCT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_DISTINCT()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_DISTINCT;


    // PLSQLLexer.g:533:5: ( 'DISTINCT' )
    // PLSQLLexer.g:533:10: 'DISTINCT'
    {
        this->matchs(lit_40);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DISTINCTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DISTINCTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DISTINCTEx: ;

}
// $ANTLR end SQL92_RESERVED_DISTINCT

//   Comes from: 537:5: ( 'DROP' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_DROP
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_DROP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_DROP()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_DROP;


    // PLSQLLexer.g:537:5: ( 'DROP' )
    // PLSQLLexer.g:537:10: 'DROP'
    {
        this->matchs(lit_41);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_DROPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_DROPEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_DROPEx: ;

}
// $ANTLR end SQL92_RESERVED_DROP

//   Comes from: 541:5: ( 'ELSE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ELSE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ELSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_ELSE()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_ELSE;


    // PLSQLLexer.g:541:5: ( 'ELSE' )
    // PLSQLLexer.g:541:10: 'ELSE'
    {
        this->matchs(lit_42);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ELSEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ELSEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ELSEEx: ;

}
// $ANTLR end SQL92_RESERVED_ELSE

//   Comes from: 545:5: ( 'END' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_END
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_END
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_END()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_END;


    // PLSQLLexer.g:545:5: ( 'END' )
    // PLSQLLexer.g:545:10: 'END'
    {
        this->matchs(lit_43);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ENDEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ENDEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ENDEx: ;

}
// $ANTLR end SQL92_RESERVED_END

//   Comes from: 552:5: ( 'EXCEPTION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_EXCEPTION
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_EXCEPTION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_EXCEPTION()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_EXCEPTION;


    // PLSQLLexer.g:552:5: ( 'EXCEPTION' )
    // PLSQLLexer.g:552:10: 'EXCEPTION'
    {
        this->matchs(lit_44);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_EXCEPTIONEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_EXCEPTIONEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_EXCEPTIONEx: ;

}
// $ANTLR end SQL92_RESERVED_EXCEPTION

//   Comes from: 608:5: ( 'EXCLUSIVE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_EXCLUSIVE
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_EXCLUSIVE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_EXCLUSIVE()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_EXCLUSIVE;


    // PLSQLLexer.g:608:5: ( 'EXCLUSIVE' )
    // PLSQLLexer.g:608:10: 'EXCLUSIVE'
    {
        this->matchs(lit_45);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_EXCLUSIVEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_EXCLUSIVEEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_EXCLUSIVEEx: ;

}
// $ANTLR end PLSQL_RESERVED_EXCLUSIVE

//   Comes from: 612:5: ( 'EXISTS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_EXISTS
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_EXISTS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_EXISTS()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_EXISTS;


    // PLSQLLexer.g:612:5: ( 'EXISTS' )
    // PLSQLLexer.g:612:10: 'EXISTS'
    {
        this->matchs(lit_46);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_EXISTSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_EXISTSEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_EXISTSEx: ;

}
// $ANTLR end SQL92_RESERVED_EXISTS

//   Comes from: 616:5: ( 'FALSE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_FALSE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_FALSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_FALSE()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_FALSE;


    // PLSQLLexer.g:616:5: ( 'FALSE' )
    // PLSQLLexer.g:616:10: 'FALSE'
    {
        this->matchs(lit_47);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_FALSEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_FALSEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_FALSEEx: ;

}
// $ANTLR end SQL92_RESERVED_FALSE

//   Comes from: 620:5: ( 'FETCH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_FETCH
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_FETCH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_FETCH()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_FETCH;


    // PLSQLLexer.g:620:5: ( 'FETCH' )
    // PLSQLLexer.g:620:10: 'FETCH'
    {
        this->matchs(lit_48);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_FETCHEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_FETCHEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_FETCHEx: ;

}
// $ANTLR end SQL92_RESERVED_FETCH

//   Comes from: 624:5: ( 'FOR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_FOR
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_FOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_FOR()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_FOR;


    // PLSQLLexer.g:624:5: ( 'FOR' )
    // PLSQLLexer.g:624:10: 'FOR'
    {
        this->matchs(lit_49);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_FOREx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_FOREx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_FOREx: ;

}
// $ANTLR end SQL92_RESERVED_FOR

//   Comes from: 628:5: ( 'FROM' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_FROM
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_FROM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_FROM()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_FROM;


    // PLSQLLexer.g:628:5: ( 'FROM' )
    // PLSQLLexer.g:628:10: 'FROM'
    {
        this->matchs(lit_50);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_FROMEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_FROMEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_FROMEx: ;

}
// $ANTLR end SQL92_RESERVED_FROM

//   Comes from: 632:5: ( 'GOTO' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_GOTO
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_GOTO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_GOTO()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_GOTO;


    // PLSQLLexer.g:632:5: ( 'GOTO' )
    // PLSQLLexer.g:632:10: 'GOTO'
    {
        this->matchs(lit_51);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_GOTOEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_GOTOEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_GOTOEx: ;

}
// $ANTLR end SQL92_RESERVED_GOTO

//   Comes from: 636:5: ( 'GRANT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_GRANT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_GRANT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_GRANT()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_GRANT;


    // PLSQLLexer.g:636:5: ( 'GRANT' )
    // PLSQLLexer.g:636:10: 'GRANT'
    {
        this->matchs(lit_52);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_GRANTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_GRANTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_GRANTEx: ;

}
// $ANTLR end SQL92_RESERVED_GRANT

//   Comes from: 640:5: ( 'GROUP' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_GROUP
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_GROUP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_GROUP()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_GROUP;


    // PLSQLLexer.g:640:5: ( 'GROUP' )
    // PLSQLLexer.g:640:10: 'GROUP'
    {
        this->matchs(lit_53);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_GROUPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_GROUPEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_GROUPEx: ;

}
// $ANTLR end SQL92_RESERVED_GROUP

//   Comes from: 644:5: ( 'HAVING' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_HAVING
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_HAVING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_HAVING()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_HAVING;


    // PLSQLLexer.g:644:5: ( 'HAVING' )
    // PLSQLLexer.g:644:10: 'HAVING'
    {
        this->matchs(lit_54);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_HAVINGEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_HAVINGEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_HAVINGEx: ;

}
// $ANTLR end SQL92_RESERVED_HAVING

//   Comes from: 648:5: ( 'IDENTIFIED' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_IDENTIFIED
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_IDENTIFIED
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_IDENTIFIED()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_IDENTIFIED;


    // PLSQLLexer.g:648:5: ( 'IDENTIFIED' )
    // PLSQLLexer.g:648:10: 'IDENTIFIED'
    {
        this->matchs(lit_55);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_IDENTIFIEDEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_IDENTIFIEDEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_IDENTIFIEDEx: ;

}
// $ANTLR end PLSQL_RESERVED_IDENTIFIED

//   Comes from: 652:5: ( 'IF' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_IF
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_IF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_IF()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_IF;


    // PLSQLLexer.g:652:5: ( 'IF' )
    // PLSQLLexer.g:652:10: 'IF'
    {
        this->matchs(lit_56);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_IFEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_IFEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_IFEx: ;

}
// $ANTLR end PLSQL_RESERVED_IF

//   Comes from: 656:5: ( 'IN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_IN
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_IN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_IN()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_IN;


    // PLSQLLexer.g:656:5: ( 'IN' )
    // PLSQLLexer.g:656:10: 'IN'
    {
        this->matchs(lit_57);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_INEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_INEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_INEx: ;

}
// $ANTLR end SQL92_RESERVED_IN

//   Comes from: 660:5: ( 'INDEX' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_INDEX
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_INDEX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_INDEX()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_INDEX;


    // PLSQLLexer.g:660:5: ( 'INDEX' )
    // PLSQLLexer.g:660:10: 'INDEX'
    {
        this->matchs(lit_58);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_INDEXEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_INDEXEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_INDEXEx: ;

}
// $ANTLR end PLSQL_RESERVED_INDEX

//   Comes from: 664:5: ( 'INDEXES' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_INDEXES
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_INDEXES
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_INDEXES()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_INDEXES;


    // PLSQLLexer.g:664:5: ( 'INDEXES' )
    // PLSQLLexer.g:664:10: 'INDEXES'
    {
        this->matchs(lit_59);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_INDEXESEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_INDEXESEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_INDEXESEx: ;

}
// $ANTLR end PLSQL_RESERVED_INDEXES

//   Comes from: 668:5: ( 'INSERT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_INSERT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_INSERT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_INSERT()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_INSERT;


    // PLSQLLexer.g:668:5: ( 'INSERT' )
    // PLSQLLexer.g:668:10: 'INSERT'
    {
        this->matchs(lit_60);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_INSERTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_INSERTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_INSERTEx: ;

}
// $ANTLR end SQL92_RESERVED_INSERT

//   Comes from: 672:5: ( 'INTERSECT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_INTERSECT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_INTERSECT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_INTERSECT()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_INTERSECT;


    // PLSQLLexer.g:672:5: ( 'INTERSECT' )
    // PLSQLLexer.g:672:10: 'INTERSECT'
    {
        this->matchs(lit_61);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_INTERSECTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_INTERSECTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_INTERSECTEx: ;

}
// $ANTLR end SQL92_RESERVED_INTERSECT

//   Comes from: 676:5: ( 'INTO' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_INTO
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_INTO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_INTO()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_INTO;


    // PLSQLLexer.g:676:5: ( 'INTO' )
    // PLSQLLexer.g:676:10: 'INTO'
    {
        this->matchs(lit_62);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_INTOEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_INTOEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_INTOEx: ;

}
// $ANTLR end SQL92_RESERVED_INTO

//   Comes from: 680:5: ( 'IS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_IS
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_IS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_IS()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_IS;


    // PLSQLLexer.g:680:5: ( 'IS' )
    // PLSQLLexer.g:680:10: 'IS'
    {
        this->matchs(lit_63);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ISEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ISEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ISEx: ;

}
// $ANTLR end SQL92_RESERVED_IS

//   Comes from: 684:5: ( 'LIKE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_LIKE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_LIKE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_LIKE()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_LIKE;


    // PLSQLLexer.g:684:5: ( 'LIKE' )
    // PLSQLLexer.g:684:10: 'LIKE'
    {
        this->matchs(lit_64);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_LIKEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_LIKEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_LIKEEx: ;

}
// $ANTLR end SQL92_RESERVED_LIKE

//   Comes from: 688:5: ( 'LOCK' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_LOCK
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_LOCK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_LOCK()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_LOCK;


    // PLSQLLexer.g:688:5: ( 'LOCK' )
    // PLSQLLexer.g:688:10: 'LOCK'
    {
        this->matchs(lit_65);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_LOCKEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_LOCKEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_LOCKEx: ;

}
// $ANTLR end PLSQL_RESERVED_LOCK

//   Comes from: 692:5: ( 'MINUS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_MINUS
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_MINUS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_MINUS()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_MINUS;


    // PLSQLLexer.g:692:5: ( 'MINUS' )
    // PLSQLLexer.g:692:10: 'MINUS'
    {
        this->matchs(lit_66);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_MINUSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_MINUSEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_MINUSEx: ;

}
// $ANTLR end PLSQL_RESERVED_MINUS

//   Comes from: 696:5: ( 'MODE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_MODE
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_MODE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_MODE()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_MODE;


    // PLSQLLexer.g:696:5: ( 'MODE' )
    // PLSQLLexer.g:696:10: 'MODE'
    {
        this->matchs(lit_67);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_MODEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_MODEEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_MODEEx: ;

}
// $ANTLR end PLSQL_RESERVED_MODE

//   Comes from: 700:5: ( 'NOCOMPRESS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_NOCOMPRESS
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_NOCOMPRESS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_NOCOMPRESS()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_NOCOMPRESS;


    // PLSQLLexer.g:700:5: ( 'NOCOMPRESS' )
    // PLSQLLexer.g:700:10: 'NOCOMPRESS'
    {
        this->matchs(lit_68);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_NOCOMPRESSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_NOCOMPRESSEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_NOCOMPRESSEx: ;

}
// $ANTLR end PLSQL_RESERVED_NOCOMPRESS

//   Comes from: 704:5: ( 'NOT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_NOT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_NOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_NOT()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_NOT;


    // PLSQLLexer.g:704:5: ( 'NOT' )
    // PLSQLLexer.g:704:10: 'NOT'
    {
        this->matchs(lit_69);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_NOTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_NOTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_NOTEx: ;

}
// $ANTLR end SQL92_RESERVED_NOT

//   Comes from: 708:5: ( 'NOWAIT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_NOWAIT
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_NOWAIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_NOWAIT()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_NOWAIT;


    // PLSQLLexer.g:708:5: ( 'NOWAIT' )
    // PLSQLLexer.g:708:10: 'NOWAIT'
    {
        this->matchs(lit_70);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_NOWAITEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_NOWAITEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_NOWAITEx: ;

}
// $ANTLR end PLSQL_RESERVED_NOWAIT

//   Comes from: 712:5: ( 'NULL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_NULL
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_NULL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_NULL()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_NULL;


    // PLSQLLexer.g:712:5: ( 'NULL' )
    // PLSQLLexer.g:712:10: 'NULL'
    {
        this->matchs(lit_71);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_NULLEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_NULLEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_NULLEx: ;

}
// $ANTLR end SQL92_RESERVED_NULL

//   Comes from: 716:5: ( 'OF' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_OF
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_OF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_OF()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_OF;


    // PLSQLLexer.g:716:5: ( 'OF' )
    // PLSQLLexer.g:716:10: 'OF'
    {
        this->matchs(lit_72);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_OFEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_OFEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_OFEx: ;

}
// $ANTLR end SQL92_RESERVED_OF

//   Comes from: 720:5: ( 'ON' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ON
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ON
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_ON()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_ON;


    // PLSQLLexer.g:720:5: ( 'ON' )
    // PLSQLLexer.g:720:10: 'ON'
    {
        this->matchs(lit_73);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ONEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ONEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ONEx: ;

}
// $ANTLR end SQL92_RESERVED_ON

//   Comes from: 724:5: ( 'OPTION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_OPTION
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_OPTION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_OPTION()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_OPTION;


    // PLSQLLexer.g:724:5: ( 'OPTION' )
    // PLSQLLexer.g:724:10: 'OPTION'
    {
        this->matchs(lit_74);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_OPTIONEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_OPTIONEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_OPTIONEx: ;

}
// $ANTLR end SQL92_RESERVED_OPTION

//   Comes from: 728:5: ( 'OR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_OR
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_OR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_OR()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_OR;


    // PLSQLLexer.g:728:5: ( 'OR' )
    // PLSQLLexer.g:728:10: 'OR'
    {
        this->matchs(lit_75);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_OREx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_OREx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_OREx: ;

}
// $ANTLR end SQL92_RESERVED_OR

//   Comes from: 732:5: ( 'ORDER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_ORDER
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_ORDER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_ORDER()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_ORDER;


    // PLSQLLexer.g:732:5: ( 'ORDER' )
    // PLSQLLexer.g:732:10: 'ORDER'
    {
        this->matchs(lit_76);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_ORDEREx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_ORDEREx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_ORDEREx: ;

}
// $ANTLR end SQL92_RESERVED_ORDER

//   Comes from: 736:5: ( 'OVERLAPS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_OVERLAPS
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_OVERLAPS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_OVERLAPS()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_OVERLAPS;


    // PLSQLLexer.g:736:5: ( 'OVERLAPS' )
    // PLSQLLexer.g:736:10: 'OVERLAPS'
    {
        this->matchs(lit_77);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_OVERLAPSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_OVERLAPSEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_OVERLAPSEx: ;

}
// $ANTLR end SQL92_RESERVED_OVERLAPS

//   Comes from: 740:5: ( 'PRIOR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_PRIOR
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_PRIOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_PRIOR()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_PRIOR;


    // PLSQLLexer.g:740:5: ( 'PRIOR' )
    // PLSQLLexer.g:740:10: 'PRIOR'
    {
        this->matchs(lit_78);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_PRIOREx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_PRIOREx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_PRIOREx: ;

}
// $ANTLR end SQL92_RESERVED_PRIOR

//   Comes from: 744:5: ( 'PROCEDURE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_PROCEDURE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_PROCEDURE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_PROCEDURE()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_PROCEDURE;


    // PLSQLLexer.g:744:5: ( 'PROCEDURE' )
    // PLSQLLexer.g:744:10: 'PROCEDURE'
    {
        this->matchs(lit_79);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_PROCEDUREEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_PROCEDUREEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_PROCEDUREEx: ;

}
// $ANTLR end SQL92_RESERVED_PROCEDURE

//   Comes from: 748:5: ( 'PUBLIC' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_PUBLIC
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_PUBLIC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_PUBLIC()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_PUBLIC;


    // PLSQLLexer.g:748:5: ( 'PUBLIC' )
    // PLSQLLexer.g:748:10: 'PUBLIC'
    {
        this->matchs(lit_80);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_PUBLICEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_PUBLICEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_PUBLICEx: ;

}
// $ANTLR end SQL92_RESERVED_PUBLIC

//   Comes from: 752:5: ( 'RESOURCE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_RESOURCE
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_RESOURCE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_RESOURCE()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_RESOURCE;


    // PLSQLLexer.g:752:5: ( 'RESOURCE' )
    // PLSQLLexer.g:752:10: 'RESOURCE'
    {
        this->matchs(lit_81);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_RESOURCEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_RESOURCEEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_RESOURCEEx: ;

}
// $ANTLR end PLSQL_RESERVED_RESOURCE

//   Comes from: 756:5: ( 'REVOKE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_REVOKE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_REVOKE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_REVOKE()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_REVOKE;


    // PLSQLLexer.g:756:5: ( 'REVOKE' )
    // PLSQLLexer.g:756:10: 'REVOKE'
    {
        this->matchs(lit_82);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_REVOKEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_REVOKEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_REVOKEEx: ;

}
// $ANTLR end SQL92_RESERVED_REVOKE

//   Comes from: 760:5: ( 'SELECT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_SELECT
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_SELECT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_SELECT()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_SELECT;


    // PLSQLLexer.g:760:5: ( 'SELECT' )
    // PLSQLLexer.g:760:10: 'SELECT'
    {
        this->matchs(lit_83);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_SELECTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_SELECTEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_SELECTEx: ;

}
// $ANTLR end SQL92_RESERVED_SELECT

//   Comes from: 764:5: ( 'SHARE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_SHARE
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_SHARE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_SHARE()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_SHARE;


    // PLSQLLexer.g:764:5: ( 'SHARE' )
    // PLSQLLexer.g:764:10: 'SHARE'
    {
        this->matchs(lit_84);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_SHAREEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_SHAREEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_SHAREEx: ;

}
// $ANTLR end PLSQL_RESERVED_SHARE

//   Comes from: 768:5: ( 'SIZE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_SIZE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_SIZE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_SIZE()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_SIZE;


    // PLSQLLexer.g:768:5: ( 'SIZE' )
    // PLSQLLexer.g:768:10: 'SIZE'
    {
        this->matchs(lit_85);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_SIZEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_SIZEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_SIZEEx: ;

}
// $ANTLR end SQL92_RESERVED_SIZE

//   Comes from: 776:5: ( 'START' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_START
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_START
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_START()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_START;


    // PLSQLLexer.g:776:5: ( 'START' )
    // PLSQLLexer.g:776:10: 'START'
    {
        this->matchs(lit_86);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_STARTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_STARTEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_STARTEx: ;

}
// $ANTLR end PLSQL_RESERVED_START

//   Comes from: 780:5: ( 'TABAUTH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_TABAUTH
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_TABAUTH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_TABAUTH()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_TABAUTH;


    // PLSQLLexer.g:780:5: ( 'TABAUTH' )
    // PLSQLLexer.g:780:10: 'TABAUTH'
    {
        this->matchs(lit_87);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_TABAUTHEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_TABAUTHEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_TABAUTHEx: ;

}
// $ANTLR end PLSQL_RESERVED_TABAUTH

//   Comes from: 784:5: ( 'TABLE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_TABLE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_TABLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_TABLE()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_TABLE;


    // PLSQLLexer.g:784:5: ( 'TABLE' )
    // PLSQLLexer.g:784:10: 'TABLE'
    {
        this->matchs(lit_88);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_TABLEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_TABLEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_TABLEEx: ;

}
// $ANTLR end SQL92_RESERVED_TABLE

//   Comes from: 788:5: ( 'THE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_THE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_THE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_THE()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_THE;


    // PLSQLLexer.g:788:5: ( 'THE' )
    // PLSQLLexer.g:788:10: 'THE'
    {
        this->matchs(lit_89);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_THEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_THEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_THEEx: ;

}
// $ANTLR end SQL92_RESERVED_THE

//   Comes from: 792:5: ( 'THEN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_THEN
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_THEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_THEN()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_THEN;


    // PLSQLLexer.g:792:5: ( 'THEN' )
    // PLSQLLexer.g:792:10: 'THEN'
    {
        this->matchs(lit_90);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_THENEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_THENEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_THENEx: ;

}
// $ANTLR end SQL92_RESERVED_THEN

//   Comes from: 796:5: ( 'TO' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_TO
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_TO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_TO()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_TO;


    // PLSQLLexer.g:796:5: ( 'TO' )
    // PLSQLLexer.g:796:10: 'TO'
    {
        this->matchs(lit_91);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_TOEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_TOEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_TOEx: ;

}
// $ANTLR end SQL92_RESERVED_TO

//   Comes from: 800:5: ( 'TRUE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_TRUE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_TRUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_TRUE()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_TRUE;


    // PLSQLLexer.g:800:5: ( 'TRUE' )
    // PLSQLLexer.g:800:10: 'TRUE'
    {
        this->matchs(lit_92);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_TRUEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_TRUEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_TRUEEx: ;

}
// $ANTLR end SQL92_RESERVED_TRUE

//   Comes from: 804:5: ( 'UNION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_UNION
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_UNION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_UNION()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_UNION;


    // PLSQLLexer.g:804:5: ( 'UNION' )
    // PLSQLLexer.g:804:10: 'UNION'
    {
        this->matchs(lit_93);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_UNIONEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_UNIONEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_UNIONEx: ;

}
// $ANTLR end SQL92_RESERVED_UNION

//   Comes from: 808:5: ( 'UNIQUE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_UNIQUE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_UNIQUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_UNIQUE()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_UNIQUE;


    // PLSQLLexer.g:808:5: ( 'UNIQUE' )
    // PLSQLLexer.g:808:10: 'UNIQUE'
    {
        this->matchs(lit_94);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_UNIQUEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_UNIQUEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_UNIQUEEx: ;

}
// $ANTLR end SQL92_RESERVED_UNIQUE

//   Comes from: 812:5: ( 'UPDATE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_UPDATE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_UPDATE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_UPDATE()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_UPDATE;


    // PLSQLLexer.g:812:5: ( 'UPDATE' )
    // PLSQLLexer.g:812:10: 'UPDATE'
    {
        this->matchs(lit_95);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_UPDATEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_UPDATEEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_UPDATEEx: ;

}
// $ANTLR end SQL92_RESERVED_UPDATE

//   Comes from: 816:5: ( 'VALUES' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_VALUES
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_VALUES
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_VALUES()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_VALUES;


    // PLSQLLexer.g:816:5: ( 'VALUES' )
    // PLSQLLexer.g:816:10: 'VALUES'
    {
        this->matchs(lit_96);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_VALUESEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_VALUESEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_VALUESEx: ;

}
// $ANTLR end SQL92_RESERVED_VALUES

//   Comes from: 820:5: ( 'VIEW' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_VIEW
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_VIEW
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_VIEW()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_VIEW;


    // PLSQLLexer.g:820:5: ( 'VIEW' )
    // PLSQLLexer.g:820:10: 'VIEW'
    {
        this->matchs(lit_97);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_VIEWEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_VIEWEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_VIEWEx: ;

}
// $ANTLR end SQL92_RESERVED_VIEW

//   Comes from: 824:5: ( 'VIEWS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_RESERVED_VIEWS
 *
 * Looks to match the characters the constitute the token PLSQL_RESERVED_VIEWS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_RESERVED_VIEWS()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_RESERVED_VIEWS;


    // PLSQLLexer.g:824:5: ( 'VIEWS' )
    // PLSQLLexer.g:824:10: 'VIEWS'
    {
        this->matchs(lit_98);
        if  (this->hasException())
        {
            goto rulePLSQL_RESERVED_VIEWSEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_RESERVED_VIEWSEx; /* Prevent compiler warnings */
    rulePLSQL_RESERVED_VIEWSEx: ;

}
// $ANTLR end PLSQL_RESERVED_VIEWS

//   Comes from: 828:5: ( 'WHEN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_WHEN
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_WHEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_WHEN()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_WHEN;


    // PLSQLLexer.g:828:5: ( 'WHEN' )
    // PLSQLLexer.g:828:10: 'WHEN'
    {
        this->matchs(lit_99);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_WHENEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_WHENEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_WHENEx: ;

}
// $ANTLR end SQL92_RESERVED_WHEN

//   Comes from: 832:5: ( 'WHERE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_WHERE
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_WHERE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_WHERE()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_WHERE;


    // PLSQLLexer.g:832:5: ( 'WHERE' )
    // PLSQLLexer.g:832:10: 'WHERE'
    {
        this->matchs(lit_100);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_WHEREEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_WHEREEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_WHEREEx: ;

}
// $ANTLR end SQL92_RESERVED_WHERE

//   Comes from: 836:5: ( 'WITH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SQL92_RESERVED_WITH
 *
 * Looks to match the characters the constitute the token SQL92_RESERVED_WITH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mSQL92_RESERVED_WITH()
{
    ANTLR_UINT32	_type;
      


    _type	    = SQL92_RESERVED_WITH;


    // PLSQLLexer.g:836:5: ( 'WITH' )
    // PLSQLLexer.g:836:10: 'WITH'
    {
        this->matchs(lit_101);
        if  (this->hasException())
        {
            goto ruleSQL92_RESERVED_WITHEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSQL92_RESERVED_WITHEx; /* Prevent compiler warnings */
    ruleSQL92_RESERVED_WITHEx: ;

}
// $ANTLR end SQL92_RESERVED_WITH

//   Comes from: 840:5: ( 'USING' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_USING
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_USING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_NON_RESERVED_USING()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_NON_RESERVED_USING;


    // PLSQLLexer.g:840:5: ( 'USING' )
    // PLSQLLexer.g:840:10: 'USING'
    {
        this->matchs(lit_102);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_USINGEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_USINGEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_USINGEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_USING

//   Comes from: 844:5: ( 'MODEL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_MODEL
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_MODEL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_NON_RESERVED_MODEL()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_NON_RESERVED_MODEL;


    // PLSQLLexer.g:844:5: ( 'MODEL' )
    // PLSQLLexer.g:844:10: 'MODEL'
    {
        this->matchs(lit_103);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_MODELEx;
        }




        {

                     // "MODEL" is a keyword if and only if it is followed by ("main"|"partition"|"dimension")
                     // otherwise it is a identifier(REGULAR_ID).
                     // This wodoo implements something like context sensitive lexer.
                     // Here we've matched the word "model". Then the Token is created and en-queued in tokenBuffer
                     // We still remember the reference(m) onto this Token
                     _type = PLSQL_NON_RESERVED_MODEL;
                     // emit(m);
                     // advanceInput();

                     // _type = Token.INVALID_TOKEN_TYPE;
                     // int markModel = input.mark();

                     // // Now loop over next Tokens in the input and eventually set Token's type to REGULAR_ID

                     // // Subclassed version will return NULL unless EOF is reached.
                     // // nextToken either returns NULL => then the next token is put into the queue tokenBuffer
                     // // or it returns Token.EOF, then nothing is put into the queue
                     // Token t1 = super.nextToken();
                     // {    // This "if" handles the situation when the "model" is the last text in the input.
                     //      if( t1 != null && t1.getType() == Token.EOF)
                     //      {
                     //          $m.set_type(REGULAR_ID);
                     //      } else {
                     //          t1 = tokenBuffer.pollLast(); // "withdraw" the next token from the queue
                     //          while(true)
                     //          {
                     //             if(t1.getType() == EOF)   // is it EOF?
                     //             {
                     //                 $m.set_type(REGULAR_ID);
                     //                 break;
                     //             }

                     //             if(t1.getChannel() == HIDDEN) // is it a white space? then advance to the next token
                     //             {
                     //                 t1 = super.nextToken(); if( t1 == null) { t1 = tokenBuffer.pollLast(); };
                     //                 continue;
                     //             }

                     //             if( t1.getType() != REGULAR_ID || // is something other than ("main"|"partition"|"dimension")
                     //                ( !t1.getText().equalsIgnoreCase("main") &&
                     //                  !t1.getText().equalsIgnoreCase("partition") &&
                     //                  !t1.getText().equalsIgnoreCase("dimension")
                     //               ))
                     //             {
                     //                 $m.set_type(REGULAR_ID);
                     //                 break;
                     //             }

                     //             break; // we are in the model_clase do not rewrite anything
                     //          } // while true
                     //      } // else if( t1 != null && t1.getType() == Token.EOF)
                     // }
                     // input.rewind(markModel);
                
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_MODELEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_MODELEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_MODEL

//   Comes from: 903:5: ( 'ELSIF' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_ELSIF
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_ELSIF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_NON_RESERVED_ELSIF()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_NON_RESERVED_ELSIF;


    // PLSQLLexer.g:903:5: ( 'ELSIF' )
    // PLSQLLexer.g:903:10: 'ELSIF'
    {
        this->matchs(lit_104);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_ELSIFEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_ELSIFEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_ELSIFEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_ELSIF

//   Comes from: 907:5: ( 'PIVOT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_PIVOT
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_PIVOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_NON_RESERVED_PIVOT()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_NON_RESERVED_PIVOT;


    // PLSQLLexer.g:907:5: ( 'PIVOT' )
    // PLSQLLexer.g:907:10: 'PIVOT'
    {
        this->matchs(lit_105);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_PIVOTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_PIVOTEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_PIVOTEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_PIVOT

//   Comes from: 911:5: ( 'UNPIVOT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLSQL_NON_RESERVED_UNPIVOT
 *
 * Looks to match the characters the constitute the token PLSQL_NON_RESERVED_UNPIVOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mPLSQL_NON_RESERVED_UNPIVOT()
{
    ANTLR_UINT32	_type;
      


    _type	    = PLSQL_NON_RESERVED_UNPIVOT;


    // PLSQLLexer.g:911:5: ( 'UNPIVOT' )
    // PLSQLLexer.g:911:10: 'UNPIVOT'
    {
        this->matchs(lit_106);
        if  (this->hasException())
        {
            goto rulePLSQL_NON_RESERVED_UNPIVOTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto rulePLSQL_NON_RESERVED_UNPIVOTEx; /* Prevent compiler warnings */
    rulePLSQL_NON_RESERVED_UNPIVOTEx: ;

}
// $ANTLR end PLSQL_NON_RESERVED_UNPIVOT

//   Comes from: 915:5: ( ( SIMPLE_LETTER ) ( SIMPLE_LETTER | '$' | '_' | '#' | '0' .. '9' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REGULAR_ID
 *
 * Looks to match the characters the constitute the token REGULAR_ID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mREGULAR_ID()
{
    ANTLR_UINT32	_type;
      


    _type	    = REGULAR_ID;


    // PLSQLLexer.g:915:5: ( ( SIMPLE_LETTER ) ( SIMPLE_LETTER | '$' | '_' | '#' | '0' .. '9' )* )
    // PLSQLLexer.g:915:10: ( SIMPLE_LETTER ) ( SIMPLE_LETTER | '$' | '_' | '#' | '0' .. '9' )*
    {
        if ( ((this->LA(1) >= 'A') && (this->LA(1) <= 'Z')) || ((this->LA(1) >= 'a') && (this->LA(1) <= 'z')) )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleREGULAR_IDEx;
        }


        // PLSQLLexer.g:915:26: ( SIMPLE_LETTER | '$' | '_' | '#' | '0' .. '9' )*

        for (;;)
        {
            int alt38=2;
            switch ( this->LA(1) )
            {
            case '#':
            case '$':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '_':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            	{
            		alt38=1;
            	}
                break;

            }

            switch (alt38)
            {
        	case 1:
        	    // PLSQLLexer.g:
        	    {
        	        if ( ((this->LA(1) >= '#') && (this->LA(1) <= '$')) || ((this->LA(1) >= '0') && (this->LA(1) <= '9')) || ((this->LA(1) >= 'A') && (this->LA(1) <= 'Z')) || this->LA(1) == '_' || ((this->LA(1) >= 'a') && (this->LA(1) <= 'z')) )
        	        {
        	            this->consume();
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< PLSQLLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            this->recover();
        	            goto ruleREGULAR_IDEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop38;	/* break out of the loop */
        	    break;
            }
        }
        loop38: ; /* Jump out to here if this rule does not match */


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleREGULAR_IDEx; /* Prevent compiler warnings */
    ruleREGULAR_IDEx: ;

}
// $ANTLR end REGULAR_ID

//   Comes from: 919:5: ( '@!' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ZV
 *
 * Looks to match the characters the constitute the token ZV
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void PLSQLLexer::mZV()
{
    ANTLR_UINT32	_type;
      


    _type	    = ZV;


    // PLSQLLexer.g:919:5: ( '@!' )
    // PLSQLLexer.g:919:10: '@!'
    {
        this->matchs(lit_107);
        if  (this->hasException())
        {
            goto ruleZVEx;
        }




        {
            this->get_state()->get_channel()=HIDDEN;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleZVEx; /* Prevent compiler warnings */
    ruleZVEx: ;

}
// $ANTLR end ZV

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
void
PLSQLLexer::mTokens()
{
    {
        //  PLSQLLexer.g:1:8: ( FOR_NOTATION | NATIONAL_CHAR_STRING_LIT | BIT_STRING_LIT | HEX_STRING_LIT | PERIOD | EXACT_NUM_LIT | CHAR_STRING | CHAR_STRING_PERL | DELIMITED_ID | PERCENT | AMPERSAND | LEFT_PAREN | RIGHT_PAREN | DOUBLE_ASTERISK | ASTERISK | PLUS_SIGN | COMMA | SOLIDUS | AT_SIGN | ASSIGN_OP | BINDVAR | COLON | SEMICOLON | LESS_THAN_OR_EQUALS_OP | LESS_THAN_OP | GREATER_THAN_OR_EQUALS_OP | NOT_EQUAL_OP | CARRET_OPERATOR_PART | TILDE_OPERATOR_PART | EXCLAMATION_OPERATOR_PART | GREATER_THAN_OP | CONCATENATION_OP | VERTICAL_BAR | EQUALS_OP | LEFT_BRACKET | RIGHT_BRACKET | INTRODUCER | SEPARATOR | PROMPT | SQL92_RESERVED_ALL | SQL92_RESERVED_ALTER | SQL92_RESERVED_AND | SQL92_RESERVED_ANY | SQL92_RESERVED_AS | SQL92_RESERVED_ASC | SQL92_RESERVED_BEGIN | SQL92_RESERVED_BETWEEN | SQL92_RESERVED_BY | SQL92_RESERVED_CASE | SQL92_RESERVED_CHECK | PLSQL_RESERVED_CLUSTERS | PLSQL_RESERVED_COLAUTH | PLSQL_RESERVED_COMPRESS | SQL92_RESERVED_CONNECT | PLSQL_NON_RESERVED_CONNECT_BY_ROOT | PLSQL_RESERVED_CRASH | SQL92_RESERVED_CREATE | SQL92_RESERVED_CURRENT | SQL92_RESERVED_CURSOR | SQL92_RESERVED_DATE | SQL92_RESERVED_DECLARE | SQL92_RESERVED_DEFAULT | SQL92_RESERVED_DELETE | SQL92_RESERVED_DESC | SQL92_RESERVED_DISTINCT | SQL92_RESERVED_DROP | SQL92_RESERVED_ELSE | SQL92_RESERVED_END | SQL92_RESERVED_EXCEPTION | PLSQL_RESERVED_EXCLUSIVE | SQL92_RESERVED_EXISTS | SQL92_RESERVED_FALSE | SQL92_RESERVED_FETCH | SQL92_RESERVED_FOR | SQL92_RESERVED_FROM | SQL92_RESERVED_GOTO | SQL92_RESERVED_GRANT | SQL92_RESERVED_GROUP | SQL92_RESERVED_HAVING | PLSQL_RESERVED_IDENTIFIED | PLSQL_RESERVED_IF | SQL92_RESERVED_IN | PLSQL_RESERVED_INDEX | PLSQL_RESERVED_INDEXES | SQL92_RESERVED_INSERT | SQL92_RESERVED_INTERSECT | SQL92_RESERVED_INTO | SQL92_RESERVED_IS | SQL92_RESERVED_LIKE | PLSQL_RESERVED_LOCK | PLSQL_RESERVED_MINUS | PLSQL_RESERVED_MODE | PLSQL_RESERVED_NOCOMPRESS | SQL92_RESERVED_NOT | PLSQL_RESERVED_NOWAIT | SQL92_RESERVED_NULL | SQL92_RESERVED_OF | SQL92_RESERVED_ON | SQL92_RESERVED_OPTION | SQL92_RESERVED_OR | SQL92_RESERVED_ORDER | SQL92_RESERVED_OVERLAPS | SQL92_RESERVED_PRIOR | SQL92_RESERVED_PROCEDURE | SQL92_RESERVED_PUBLIC | PLSQL_RESERVED_RESOURCE | SQL92_RESERVED_REVOKE | SQL92_RESERVED_SELECT | PLSQL_RESERVED_SHARE | SQL92_RESERVED_SIZE | PLSQL_RESERVED_START | PLSQL_RESERVED_TABAUTH | SQL92_RESERVED_TABLE | SQL92_RESERVED_THE | SQL92_RESERVED_THEN | SQL92_RESERVED_TO | SQL92_RESERVED_TRUE | SQL92_RESERVED_UNION | SQL92_RESERVED_UNIQUE | SQL92_RESERVED_UPDATE | SQL92_RESERVED_VALUES | SQL92_RESERVED_VIEW | PLSQL_RESERVED_VIEWS | SQL92_RESERVED_WHEN | SQL92_RESERVED_WHERE | SQL92_RESERVED_WITH | PLSQL_NON_RESERVED_USING | PLSQL_NON_RESERVED_MODEL | PLSQL_NON_RESERVED_ELSIF | PLSQL_NON_RESERVED_PIVOT | PLSQL_NON_RESERVED_UNPIVOT | REGULAR_ID | ZV )

        ANTLR_UINT32 alt39;

        alt39=133;

        alt39 = cdfa39.predict(this, this->get_rec(), this->get_istream(), cdfa39 );
        if  (this->hasException())
        {
            goto ruleTokensEx;
        }

        switch (alt39)
        {
    	case 1:
    	    // PLSQLLexer.g:1:10: FOR_NOTATION
    	    {
    	        /* 1:10: FOR_NOTATION */
    	        mFOR_NOTATION();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 2:
    	    // PLSQLLexer.g:1:23: NATIONAL_CHAR_STRING_LIT
    	    {
    	        /* 1:23: NATIONAL_CHAR_STRING_LIT */
    	        mNATIONAL_CHAR_STRING_LIT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 3:
    	    // PLSQLLexer.g:1:48: BIT_STRING_LIT
    	    {
    	        /* 1:48: BIT_STRING_LIT */
    	        mBIT_STRING_LIT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 4:
    	    // PLSQLLexer.g:1:63: HEX_STRING_LIT
    	    {
    	        /* 1:63: HEX_STRING_LIT */
    	        mHEX_STRING_LIT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 5:
    	    // PLSQLLexer.g:1:78: PERIOD
    	    {
    	        /* 1:78: PERIOD */
    	        mPERIOD();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 6:
    	    // PLSQLLexer.g:1:85: EXACT_NUM_LIT
    	    {
    	        /* 1:85: EXACT_NUM_LIT */
    	        mEXACT_NUM_LIT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 7:
    	    // PLSQLLexer.g:1:99: CHAR_STRING
    	    {
    	        /* 1:99: CHAR_STRING */
    	        mCHAR_STRING();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 8:
    	    // PLSQLLexer.g:1:111: CHAR_STRING_PERL
    	    {
    	        /* 1:111: CHAR_STRING_PERL */
    	        mCHAR_STRING_PERL();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 9:
    	    // PLSQLLexer.g:1:128: DELIMITED_ID
    	    {
    	        /* 1:128: DELIMITED_ID */
    	        mDELIMITED_ID();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 10:
    	    // PLSQLLexer.g:1:141: PERCENT
    	    {
    	        /* 1:141: PERCENT */
    	        mPERCENT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 11:
    	    // PLSQLLexer.g:1:149: AMPERSAND
    	    {
    	        /* 1:149: AMPERSAND */
    	        mAMPERSAND();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 12:
    	    // PLSQLLexer.g:1:159: LEFT_PAREN
    	    {
    	        /* 1:159: LEFT_PAREN */
    	        mLEFT_PAREN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 13:
    	    // PLSQLLexer.g:1:170: RIGHT_PAREN
    	    {
    	        /* 1:170: RIGHT_PAREN */
    	        mRIGHT_PAREN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 14:
    	    // PLSQLLexer.g:1:182: DOUBLE_ASTERISK
    	    {
    	        /* 1:182: DOUBLE_ASTERISK */
    	        mDOUBLE_ASTERISK();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 15:
    	    // PLSQLLexer.g:1:198: ASTERISK
    	    {
    	        /* 1:198: ASTERISK */
    	        mASTERISK();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 16:
    	    // PLSQLLexer.g:1:207: PLUS_SIGN
    	    {
    	        /* 1:207: PLUS_SIGN */
    	        mPLUS_SIGN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 17:
    	    // PLSQLLexer.g:1:217: COMMA
    	    {
    	        /* 1:217: COMMA */
    	        mCOMMA();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 18:
    	    // PLSQLLexer.g:1:223: SOLIDUS
    	    {
    	        /* 1:223: SOLIDUS */
    	        mSOLIDUS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 19:
    	    // PLSQLLexer.g:1:231: AT_SIGN
    	    {
    	        /* 1:231: AT_SIGN */
    	        mAT_SIGN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 20:
    	    // PLSQLLexer.g:1:239: ASSIGN_OP
    	    {
    	        /* 1:239: ASSIGN_OP */
    	        mASSIGN_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 21:
    	    // PLSQLLexer.g:1:249: BINDVAR
    	    {
    	        /* 1:249: BINDVAR */
    	        mBINDVAR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 22:
    	    // PLSQLLexer.g:1:257: COLON
    	    {
    	        /* 1:257: COLON */
    	        mCOLON();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 23:
    	    // PLSQLLexer.g:1:263: SEMICOLON
    	    {
    	        /* 1:263: SEMICOLON */
    	        mSEMICOLON();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 24:
    	    // PLSQLLexer.g:1:273: LESS_THAN_OR_EQUALS_OP
    	    {
    	        /* 1:273: LESS_THAN_OR_EQUALS_OP */
    	        mLESS_THAN_OR_EQUALS_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 25:
    	    // PLSQLLexer.g:1:296: LESS_THAN_OP
    	    {
    	        /* 1:296: LESS_THAN_OP */
    	        mLESS_THAN_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 26:
    	    // PLSQLLexer.g:1:309: GREATER_THAN_OR_EQUALS_OP
    	    {
    	        /* 1:309: GREATER_THAN_OR_EQUALS_OP */
    	        mGREATER_THAN_OR_EQUALS_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 27:
    	    // PLSQLLexer.g:1:335: NOT_EQUAL_OP
    	    {
    	        /* 1:335: NOT_EQUAL_OP */
    	        mNOT_EQUAL_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 28:
    	    // PLSQLLexer.g:1:348: CARRET_OPERATOR_PART
    	    {
    	        /* 1:348: CARRET_OPERATOR_PART */
    	        mCARRET_OPERATOR_PART();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 29:
    	    // PLSQLLexer.g:1:369: TILDE_OPERATOR_PART
    	    {
    	        /* 1:369: TILDE_OPERATOR_PART */
    	        mTILDE_OPERATOR_PART();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 30:
    	    // PLSQLLexer.g:1:389: EXCLAMATION_OPERATOR_PART
    	    {
    	        /* 1:389: EXCLAMATION_OPERATOR_PART */
    	        mEXCLAMATION_OPERATOR_PART();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 31:
    	    // PLSQLLexer.g:1:415: GREATER_THAN_OP
    	    {
    	        /* 1:415: GREATER_THAN_OP */
    	        mGREATER_THAN_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 32:
    	    // PLSQLLexer.g:1:431: CONCATENATION_OP
    	    {
    	        /* 1:431: CONCATENATION_OP */
    	        mCONCATENATION_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 33:
    	    // PLSQLLexer.g:1:448: VERTICAL_BAR
    	    {
    	        /* 1:448: VERTICAL_BAR */
    	        mVERTICAL_BAR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 34:
    	    // PLSQLLexer.g:1:461: EQUALS_OP
    	    {
    	        /* 1:461: EQUALS_OP */
    	        mEQUALS_OP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 35:
    	    // PLSQLLexer.g:1:471: LEFT_BRACKET
    	    {
    	        /* 1:471: LEFT_BRACKET */
    	        mLEFT_BRACKET();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 36:
    	    // PLSQLLexer.g:1:484: RIGHT_BRACKET
    	    {
    	        /* 1:484: RIGHT_BRACKET */
    	        mRIGHT_BRACKET();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 37:
    	    // PLSQLLexer.g:1:498: INTRODUCER
    	    {
    	        /* 1:498: INTRODUCER */
    	        mINTRODUCER();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 38:
    	    // PLSQLLexer.g:1:509: SEPARATOR
    	    {
    	        /* 1:509: SEPARATOR */
    	        mSEPARATOR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 39:
    	    // PLSQLLexer.g:1:519: PROMPT
    	    {
    	        /* 1:519: PROMPT */
    	        mPROMPT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 40:
    	    // PLSQLLexer.g:1:526: SQL92_RESERVED_ALL
    	    {
    	        /* 1:526: SQL92_RESERVED_ALL */
    	        mSQL92_RESERVED_ALL();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 41:
    	    // PLSQLLexer.g:1:545: SQL92_RESERVED_ALTER
    	    {
    	        /* 1:545: SQL92_RESERVED_ALTER */
    	        mSQL92_RESERVED_ALTER();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 42:
    	    // PLSQLLexer.g:1:566: SQL92_RESERVED_AND
    	    {
    	        /* 1:566: SQL92_RESERVED_AND */
    	        mSQL92_RESERVED_AND();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 43:
    	    // PLSQLLexer.g:1:585: SQL92_RESERVED_ANY
    	    {
    	        /* 1:585: SQL92_RESERVED_ANY */
    	        mSQL92_RESERVED_ANY();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 44:
    	    // PLSQLLexer.g:1:604: SQL92_RESERVED_AS
    	    {
    	        /* 1:604: SQL92_RESERVED_AS */
    	        mSQL92_RESERVED_AS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 45:
    	    // PLSQLLexer.g:1:622: SQL92_RESERVED_ASC
    	    {
    	        /* 1:622: SQL92_RESERVED_ASC */
    	        mSQL92_RESERVED_ASC();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 46:
    	    // PLSQLLexer.g:1:641: SQL92_RESERVED_BEGIN
    	    {
    	        /* 1:641: SQL92_RESERVED_BEGIN */
    	        mSQL92_RESERVED_BEGIN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 47:
    	    // PLSQLLexer.g:1:662: SQL92_RESERVED_BETWEEN
    	    {
    	        /* 1:662: SQL92_RESERVED_BETWEEN */
    	        mSQL92_RESERVED_BETWEEN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 48:
    	    // PLSQLLexer.g:1:685: SQL92_RESERVED_BY
    	    {
    	        /* 1:685: SQL92_RESERVED_BY */
    	        mSQL92_RESERVED_BY();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 49:
    	    // PLSQLLexer.g:1:703: SQL92_RESERVED_CASE
    	    {
    	        /* 1:703: SQL92_RESERVED_CASE */
    	        mSQL92_RESERVED_CASE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 50:
    	    // PLSQLLexer.g:1:723: SQL92_RESERVED_CHECK
    	    {
    	        /* 1:723: SQL92_RESERVED_CHECK */
    	        mSQL92_RESERVED_CHECK();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 51:
    	    // PLSQLLexer.g:1:744: PLSQL_RESERVED_CLUSTERS
    	    {
    	        /* 1:744: PLSQL_RESERVED_CLUSTERS */
    	        mPLSQL_RESERVED_CLUSTERS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 52:
    	    // PLSQLLexer.g:1:768: PLSQL_RESERVED_COLAUTH
    	    {
    	        /* 1:768: PLSQL_RESERVED_COLAUTH */
    	        mPLSQL_RESERVED_COLAUTH();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 53:
    	    // PLSQLLexer.g:1:791: PLSQL_RESERVED_COMPRESS
    	    {
    	        /* 1:791: PLSQL_RESERVED_COMPRESS */
    	        mPLSQL_RESERVED_COMPRESS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 54:
    	    // PLSQLLexer.g:1:815: SQL92_RESERVED_CONNECT
    	    {
    	        /* 1:815: SQL92_RESERVED_CONNECT */
    	        mSQL92_RESERVED_CONNECT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 55:
    	    // PLSQLLexer.g:1:838: PLSQL_NON_RESERVED_CONNECT_BY_ROOT
    	    {
    	        /* 1:838: PLSQL_NON_RESERVED_CONNECT_BY_ROOT */
    	        mPLSQL_NON_RESERVED_CONNECT_BY_ROOT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 56:
    	    // PLSQLLexer.g:1:873: PLSQL_RESERVED_CRASH
    	    {
    	        /* 1:873: PLSQL_RESERVED_CRASH */
    	        mPLSQL_RESERVED_CRASH();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 57:
    	    // PLSQLLexer.g:1:894: SQL92_RESERVED_CREATE
    	    {
    	        /* 1:894: SQL92_RESERVED_CREATE */
    	        mSQL92_RESERVED_CREATE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 58:
    	    // PLSQLLexer.g:1:916: SQL92_RESERVED_CURRENT
    	    {
    	        /* 1:916: SQL92_RESERVED_CURRENT */
    	        mSQL92_RESERVED_CURRENT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 59:
    	    // PLSQLLexer.g:1:939: SQL92_RESERVED_CURSOR
    	    {
    	        /* 1:939: SQL92_RESERVED_CURSOR */
    	        mSQL92_RESERVED_CURSOR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 60:
    	    // PLSQLLexer.g:1:961: SQL92_RESERVED_DATE
    	    {
    	        /* 1:961: SQL92_RESERVED_DATE */
    	        mSQL92_RESERVED_DATE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 61:
    	    // PLSQLLexer.g:1:981: SQL92_RESERVED_DECLARE
    	    {
    	        /* 1:981: SQL92_RESERVED_DECLARE */
    	        mSQL92_RESERVED_DECLARE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 62:
    	    // PLSQLLexer.g:1:1004: SQL92_RESERVED_DEFAULT
    	    {
    	        /* 1:1004: SQL92_RESERVED_DEFAULT */
    	        mSQL92_RESERVED_DEFAULT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 63:
    	    // PLSQLLexer.g:1:1027: SQL92_RESERVED_DELETE
    	    {
    	        /* 1:1027: SQL92_RESERVED_DELETE */
    	        mSQL92_RESERVED_DELETE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 64:
    	    // PLSQLLexer.g:1:1049: SQL92_RESERVED_DESC
    	    {
    	        /* 1:1049: SQL92_RESERVED_DESC */
    	        mSQL92_RESERVED_DESC();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 65:
    	    // PLSQLLexer.g:1:1069: SQL92_RESERVED_DISTINCT
    	    {
    	        /* 1:1069: SQL92_RESERVED_DISTINCT */
    	        mSQL92_RESERVED_DISTINCT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 66:
    	    // PLSQLLexer.g:1:1093: SQL92_RESERVED_DROP
    	    {
    	        /* 1:1093: SQL92_RESERVED_DROP */
    	        mSQL92_RESERVED_DROP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 67:
    	    // PLSQLLexer.g:1:1113: SQL92_RESERVED_ELSE
    	    {
    	        /* 1:1113: SQL92_RESERVED_ELSE */
    	        mSQL92_RESERVED_ELSE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 68:
    	    // PLSQLLexer.g:1:1133: SQL92_RESERVED_END
    	    {
    	        /* 1:1133: SQL92_RESERVED_END */
    	        mSQL92_RESERVED_END();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 69:
    	    // PLSQLLexer.g:1:1152: SQL92_RESERVED_EXCEPTION
    	    {
    	        /* 1:1152: SQL92_RESERVED_EXCEPTION */
    	        mSQL92_RESERVED_EXCEPTION();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 70:
    	    // PLSQLLexer.g:1:1177: PLSQL_RESERVED_EXCLUSIVE
    	    {
    	        /* 1:1177: PLSQL_RESERVED_EXCLUSIVE */
    	        mPLSQL_RESERVED_EXCLUSIVE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 71:
    	    // PLSQLLexer.g:1:1202: SQL92_RESERVED_EXISTS
    	    {
    	        /* 1:1202: SQL92_RESERVED_EXISTS */
    	        mSQL92_RESERVED_EXISTS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 72:
    	    // PLSQLLexer.g:1:1224: SQL92_RESERVED_FALSE
    	    {
    	        /* 1:1224: SQL92_RESERVED_FALSE */
    	        mSQL92_RESERVED_FALSE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 73:
    	    // PLSQLLexer.g:1:1245: SQL92_RESERVED_FETCH
    	    {
    	        /* 1:1245: SQL92_RESERVED_FETCH */
    	        mSQL92_RESERVED_FETCH();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 74:
    	    // PLSQLLexer.g:1:1266: SQL92_RESERVED_FOR
    	    {
    	        /* 1:1266: SQL92_RESERVED_FOR */
    	        mSQL92_RESERVED_FOR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 75:
    	    // PLSQLLexer.g:1:1285: SQL92_RESERVED_FROM
    	    {
    	        /* 1:1285: SQL92_RESERVED_FROM */
    	        mSQL92_RESERVED_FROM();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 76:
    	    // PLSQLLexer.g:1:1305: SQL92_RESERVED_GOTO
    	    {
    	        /* 1:1305: SQL92_RESERVED_GOTO */
    	        mSQL92_RESERVED_GOTO();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 77:
    	    // PLSQLLexer.g:1:1325: SQL92_RESERVED_GRANT
    	    {
    	        /* 1:1325: SQL92_RESERVED_GRANT */
    	        mSQL92_RESERVED_GRANT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 78:
    	    // PLSQLLexer.g:1:1346: SQL92_RESERVED_GROUP
    	    {
    	        /* 1:1346: SQL92_RESERVED_GROUP */
    	        mSQL92_RESERVED_GROUP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 79:
    	    // PLSQLLexer.g:1:1367: SQL92_RESERVED_HAVING
    	    {
    	        /* 1:1367: SQL92_RESERVED_HAVING */
    	        mSQL92_RESERVED_HAVING();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 80:
    	    // PLSQLLexer.g:1:1389: PLSQL_RESERVED_IDENTIFIED
    	    {
    	        /* 1:1389: PLSQL_RESERVED_IDENTIFIED */
    	        mPLSQL_RESERVED_IDENTIFIED();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 81:
    	    // PLSQLLexer.g:1:1415: PLSQL_RESERVED_IF
    	    {
    	        /* 1:1415: PLSQL_RESERVED_IF */
    	        mPLSQL_RESERVED_IF();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 82:
    	    // PLSQLLexer.g:1:1433: SQL92_RESERVED_IN
    	    {
    	        /* 1:1433: SQL92_RESERVED_IN */
    	        mSQL92_RESERVED_IN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 83:
    	    // PLSQLLexer.g:1:1451: PLSQL_RESERVED_INDEX
    	    {
    	        /* 1:1451: PLSQL_RESERVED_INDEX */
    	        mPLSQL_RESERVED_INDEX();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 84:
    	    // PLSQLLexer.g:1:1472: PLSQL_RESERVED_INDEXES
    	    {
    	        /* 1:1472: PLSQL_RESERVED_INDEXES */
    	        mPLSQL_RESERVED_INDEXES();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 85:
    	    // PLSQLLexer.g:1:1495: SQL92_RESERVED_INSERT
    	    {
    	        /* 1:1495: SQL92_RESERVED_INSERT */
    	        mSQL92_RESERVED_INSERT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 86:
    	    // PLSQLLexer.g:1:1517: SQL92_RESERVED_INTERSECT
    	    {
    	        /* 1:1517: SQL92_RESERVED_INTERSECT */
    	        mSQL92_RESERVED_INTERSECT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 87:
    	    // PLSQLLexer.g:1:1542: SQL92_RESERVED_INTO
    	    {
    	        /* 1:1542: SQL92_RESERVED_INTO */
    	        mSQL92_RESERVED_INTO();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 88:
    	    // PLSQLLexer.g:1:1562: SQL92_RESERVED_IS
    	    {
    	        /* 1:1562: SQL92_RESERVED_IS */
    	        mSQL92_RESERVED_IS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 89:
    	    // PLSQLLexer.g:1:1580: SQL92_RESERVED_LIKE
    	    {
    	        /* 1:1580: SQL92_RESERVED_LIKE */
    	        mSQL92_RESERVED_LIKE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 90:
    	    // PLSQLLexer.g:1:1600: PLSQL_RESERVED_LOCK
    	    {
    	        /* 1:1600: PLSQL_RESERVED_LOCK */
    	        mPLSQL_RESERVED_LOCK();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 91:
    	    // PLSQLLexer.g:1:1620: PLSQL_RESERVED_MINUS
    	    {
    	        /* 1:1620: PLSQL_RESERVED_MINUS */
    	        mPLSQL_RESERVED_MINUS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 92:
    	    // PLSQLLexer.g:1:1641: PLSQL_RESERVED_MODE
    	    {
    	        /* 1:1641: PLSQL_RESERVED_MODE */
    	        mPLSQL_RESERVED_MODE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 93:
    	    // PLSQLLexer.g:1:1661: PLSQL_RESERVED_NOCOMPRESS
    	    {
    	        /* 1:1661: PLSQL_RESERVED_NOCOMPRESS */
    	        mPLSQL_RESERVED_NOCOMPRESS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 94:
    	    // PLSQLLexer.g:1:1687: SQL92_RESERVED_NOT
    	    {
    	        /* 1:1687: SQL92_RESERVED_NOT */
    	        mSQL92_RESERVED_NOT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 95:
    	    // PLSQLLexer.g:1:1706: PLSQL_RESERVED_NOWAIT
    	    {
    	        /* 1:1706: PLSQL_RESERVED_NOWAIT */
    	        mPLSQL_RESERVED_NOWAIT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 96:
    	    // PLSQLLexer.g:1:1728: SQL92_RESERVED_NULL
    	    {
    	        /* 1:1728: SQL92_RESERVED_NULL */
    	        mSQL92_RESERVED_NULL();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 97:
    	    // PLSQLLexer.g:1:1748: SQL92_RESERVED_OF
    	    {
    	        /* 1:1748: SQL92_RESERVED_OF */
    	        mSQL92_RESERVED_OF();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 98:
    	    // PLSQLLexer.g:1:1766: SQL92_RESERVED_ON
    	    {
    	        /* 1:1766: SQL92_RESERVED_ON */
    	        mSQL92_RESERVED_ON();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 99:
    	    // PLSQLLexer.g:1:1784: SQL92_RESERVED_OPTION
    	    {
    	        /* 1:1784: SQL92_RESERVED_OPTION */
    	        mSQL92_RESERVED_OPTION();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 100:
    	    // PLSQLLexer.g:1:1806: SQL92_RESERVED_OR
    	    {
    	        /* 1:1806: SQL92_RESERVED_OR */
    	        mSQL92_RESERVED_OR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 101:
    	    // PLSQLLexer.g:1:1824: SQL92_RESERVED_ORDER
    	    {
    	        /* 1:1824: SQL92_RESERVED_ORDER */
    	        mSQL92_RESERVED_ORDER();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 102:
    	    // PLSQLLexer.g:1:1845: SQL92_RESERVED_OVERLAPS
    	    {
    	        /* 1:1845: SQL92_RESERVED_OVERLAPS */
    	        mSQL92_RESERVED_OVERLAPS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 103:
    	    // PLSQLLexer.g:1:1869: SQL92_RESERVED_PRIOR
    	    {
    	        /* 1:1869: SQL92_RESERVED_PRIOR */
    	        mSQL92_RESERVED_PRIOR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 104:
    	    // PLSQLLexer.g:1:1890: SQL92_RESERVED_PROCEDURE
    	    {
    	        /* 1:1890: SQL92_RESERVED_PROCEDURE */
    	        mSQL92_RESERVED_PROCEDURE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 105:
    	    // PLSQLLexer.g:1:1915: SQL92_RESERVED_PUBLIC
    	    {
    	        /* 1:1915: SQL92_RESERVED_PUBLIC */
    	        mSQL92_RESERVED_PUBLIC();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 106:
    	    // PLSQLLexer.g:1:1937: PLSQL_RESERVED_RESOURCE
    	    {
    	        /* 1:1937: PLSQL_RESERVED_RESOURCE */
    	        mPLSQL_RESERVED_RESOURCE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 107:
    	    // PLSQLLexer.g:1:1961: SQL92_RESERVED_REVOKE
    	    {
    	        /* 1:1961: SQL92_RESERVED_REVOKE */
    	        mSQL92_RESERVED_REVOKE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 108:
    	    // PLSQLLexer.g:1:1983: SQL92_RESERVED_SELECT
    	    {
    	        /* 1:1983: SQL92_RESERVED_SELECT */
    	        mSQL92_RESERVED_SELECT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 109:
    	    // PLSQLLexer.g:1:2005: PLSQL_RESERVED_SHARE
    	    {
    	        /* 1:2005: PLSQL_RESERVED_SHARE */
    	        mPLSQL_RESERVED_SHARE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 110:
    	    // PLSQLLexer.g:1:2026: SQL92_RESERVED_SIZE
    	    {
    	        /* 1:2026: SQL92_RESERVED_SIZE */
    	        mSQL92_RESERVED_SIZE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 111:
    	    // PLSQLLexer.g:1:2046: PLSQL_RESERVED_START
    	    {
    	        /* 1:2046: PLSQL_RESERVED_START */
    	        mPLSQL_RESERVED_START();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 112:
    	    // PLSQLLexer.g:1:2067: PLSQL_RESERVED_TABAUTH
    	    {
    	        /* 1:2067: PLSQL_RESERVED_TABAUTH */
    	        mPLSQL_RESERVED_TABAUTH();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 113:
    	    // PLSQLLexer.g:1:2090: SQL92_RESERVED_TABLE
    	    {
    	        /* 1:2090: SQL92_RESERVED_TABLE */
    	        mSQL92_RESERVED_TABLE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 114:
    	    // PLSQLLexer.g:1:2111: SQL92_RESERVED_THE
    	    {
    	        /* 1:2111: SQL92_RESERVED_THE */
    	        mSQL92_RESERVED_THE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 115:
    	    // PLSQLLexer.g:1:2130: SQL92_RESERVED_THEN
    	    {
    	        /* 1:2130: SQL92_RESERVED_THEN */
    	        mSQL92_RESERVED_THEN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 116:
    	    // PLSQLLexer.g:1:2150: SQL92_RESERVED_TO
    	    {
    	        /* 1:2150: SQL92_RESERVED_TO */
    	        mSQL92_RESERVED_TO();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 117:
    	    // PLSQLLexer.g:1:2168: SQL92_RESERVED_TRUE
    	    {
    	        /* 1:2168: SQL92_RESERVED_TRUE */
    	        mSQL92_RESERVED_TRUE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 118:
    	    // PLSQLLexer.g:1:2188: SQL92_RESERVED_UNION
    	    {
    	        /* 1:2188: SQL92_RESERVED_UNION */
    	        mSQL92_RESERVED_UNION();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 119:
    	    // PLSQLLexer.g:1:2209: SQL92_RESERVED_UNIQUE
    	    {
    	        /* 1:2209: SQL92_RESERVED_UNIQUE */
    	        mSQL92_RESERVED_UNIQUE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 120:
    	    // PLSQLLexer.g:1:2231: SQL92_RESERVED_UPDATE
    	    {
    	        /* 1:2231: SQL92_RESERVED_UPDATE */
    	        mSQL92_RESERVED_UPDATE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 121:
    	    // PLSQLLexer.g:1:2253: SQL92_RESERVED_VALUES
    	    {
    	        /* 1:2253: SQL92_RESERVED_VALUES */
    	        mSQL92_RESERVED_VALUES();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 122:
    	    // PLSQLLexer.g:1:2275: SQL92_RESERVED_VIEW
    	    {
    	        /* 1:2275: SQL92_RESERVED_VIEW */
    	        mSQL92_RESERVED_VIEW();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 123:
    	    // PLSQLLexer.g:1:2295: PLSQL_RESERVED_VIEWS
    	    {
    	        /* 1:2295: PLSQL_RESERVED_VIEWS */
    	        mPLSQL_RESERVED_VIEWS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 124:
    	    // PLSQLLexer.g:1:2316: SQL92_RESERVED_WHEN
    	    {
    	        /* 1:2316: SQL92_RESERVED_WHEN */
    	        mSQL92_RESERVED_WHEN();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 125:
    	    // PLSQLLexer.g:1:2336: SQL92_RESERVED_WHERE
    	    {
    	        /* 1:2336: SQL92_RESERVED_WHERE */
    	        mSQL92_RESERVED_WHERE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 126:
    	    // PLSQLLexer.g:1:2357: SQL92_RESERVED_WITH
    	    {
    	        /* 1:2357: SQL92_RESERVED_WITH */
    	        mSQL92_RESERVED_WITH();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 127:
    	    // PLSQLLexer.g:1:2377: PLSQL_NON_RESERVED_USING
    	    {
    	        /* 1:2377: PLSQL_NON_RESERVED_USING */
    	        mPLSQL_NON_RESERVED_USING();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 128:
    	    // PLSQLLexer.g:1:2402: PLSQL_NON_RESERVED_MODEL
    	    {
    	        /* 1:2402: PLSQL_NON_RESERVED_MODEL */
    	        mPLSQL_NON_RESERVED_MODEL();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 129:
    	    // PLSQLLexer.g:1:2427: PLSQL_NON_RESERVED_ELSIF
    	    {
    	        /* 1:2427: PLSQL_NON_RESERVED_ELSIF */
    	        mPLSQL_NON_RESERVED_ELSIF();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 130:
    	    // PLSQLLexer.g:1:2452: PLSQL_NON_RESERVED_PIVOT
    	    {
    	        /* 1:2452: PLSQL_NON_RESERVED_PIVOT */
    	        mPLSQL_NON_RESERVED_PIVOT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 131:
    	    // PLSQLLexer.g:1:2477: PLSQL_NON_RESERVED_UNPIVOT
    	    {
    	        /* 1:2477: PLSQL_NON_RESERVED_UNPIVOT */
    	        mPLSQL_NON_RESERVED_UNPIVOT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 132:
    	    // PLSQLLexer.g:1:2504: REGULAR_ID
    	    {
    	        /* 1:2504: REGULAR_ID */
    	        mREGULAR_ID();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 133:
    	    // PLSQLLexer.g:1:2515: ZV
    	    {
    	        /* 1:2515: ZV */
    	        mZV();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;

        }
    }


    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */

}


/* End of code
 * =============================================================================
 */
