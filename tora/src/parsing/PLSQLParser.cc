/** \file
 *  This C++ source file was generated by $ANTLR version 3.5.2-SNAPSHOT
 *
 *     -  From the grammar source file : PLSQLParser.g
 *     -                            On : 2013-10-27 10:35:38
 *     -                for the parser : PLSQLParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "PLSQLParser.hpp"
/* ----------------------------------------- */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

namespace  Antlr3BackendImpl  {
using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8* PLSQLParserTokenNames[265+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "AMPERSAND",
        (ANTLR_UINT8*) "APPROXIMATE_NUM_LIT",
        (ANTLR_UINT8*) "ASSIGN_OP",
        (ANTLR_UINT8*) "ASTERISK",
        (ANTLR_UINT8*) "AT_SIGN",
        (ANTLR_UINT8*) "BINDVAR",
        (ANTLR_UINT8*) "BIT_STRING_LIT",
        (ANTLR_UINT8*) "CARRET_OPERATOR_PART",
        (ANTLR_UINT8*) "CHAR_STRING",
        (ANTLR_UINT8*) "CHAR_STRING_PERL",
        (ANTLR_UINT8*) "COLON",
        (ANTLR_UINT8*) "COMMA",
        (ANTLR_UINT8*) "COMMENT",
        (ANTLR_UINT8*) "CONCATENATION_OP",
        (ANTLR_UINT8*) "DELIMITED_ID",
        (ANTLR_UINT8*) "DOUBLE_ASTERISK",
        (ANTLR_UINT8*) "DOUBLE_PERIOD",
        (ANTLR_UINT8*) "EQUALS_OP",
        (ANTLR_UINT8*) "EXACT_NUM_LIT",
        (ANTLR_UINT8*) "EXCLAMATION_OPERATOR_PART",
        (ANTLR_UINT8*) "FOR_NOTATION",
        (ANTLR_UINT8*) "GREATER_THAN_OP",
        (ANTLR_UINT8*) "GREATER_THAN_OR_EQUALS_OP",
        (ANTLR_UINT8*) "HEX_STRING_LIT",
        (ANTLR_UINT8*) "INTRODUCER",
        (ANTLR_UINT8*) "LEFT_BRACKET",
        (ANTLR_UINT8*) "LEFT_PAREN",
        (ANTLR_UINT8*) "LESS_THAN_OP",
        (ANTLR_UINT8*) "LESS_THAN_OR_EQUALS_OP",
        (ANTLR_UINT8*) "MINUS_SIGN",
        (ANTLR_UINT8*) "NATIONAL_CHAR_STRING_LIT",
        (ANTLR_UINT8*) "NEWLINE",
        (ANTLR_UINT8*) "NOT_EQUAL_OP",
        (ANTLR_UINT8*) "PERCENT",
        (ANTLR_UINT8*) "PERIOD",
        (ANTLR_UINT8*) "PLSQL_NON_RESERVED_CONNECT_BY_ROOT",
        (ANTLR_UINT8*) "PLSQL_NON_RESERVED_ELSIF",
        (ANTLR_UINT8*) "PLSQL_NON_RESERVED_MODEL",
        (ANTLR_UINT8*) "PLSQL_NON_RESERVED_PIVOT",
        (ANTLR_UINT8*) "PLSQL_NON_RESERVED_UNPIVOT",
        (ANTLR_UINT8*) "PLSQL_NON_RESERVED_USING",
        (ANTLR_UINT8*) "PLSQL_RESERVED_CLUSTERS",
        (ANTLR_UINT8*) "PLSQL_RESERVED_COLAUTH",
        (ANTLR_UINT8*) "PLSQL_RESERVED_COMPRESS",
        (ANTLR_UINT8*) "PLSQL_RESERVED_CRASH",
        (ANTLR_UINT8*) "PLSQL_RESERVED_EXCLUSIVE",
        (ANTLR_UINT8*) "PLSQL_RESERVED_IDENTIFIED",
        (ANTLR_UINT8*) "PLSQL_RESERVED_IF",
        (ANTLR_UINT8*) "PLSQL_RESERVED_INDEX",
        (ANTLR_UINT8*) "PLSQL_RESERVED_INDEXES",
        (ANTLR_UINT8*) "PLSQL_RESERVED_LOCK",
        (ANTLR_UINT8*) "PLSQL_RESERVED_MINUS",
        (ANTLR_UINT8*) "PLSQL_RESERVED_MODE",
        (ANTLR_UINT8*) "PLSQL_RESERVED_NOCOMPRESS",
        (ANTLR_UINT8*) "PLSQL_RESERVED_NOWAIT",
        (ANTLR_UINT8*) "PLSQL_RESERVED_RESOURCE",
        (ANTLR_UINT8*) "PLSQL_RESERVED_SHARE",
        (ANTLR_UINT8*) "PLSQL_RESERVED_START",
        (ANTLR_UINT8*) "PLSQL_RESERVED_TABAUTH",
        (ANTLR_UINT8*) "PLSQL_RESERVED_VIEWS",
        (ANTLR_UINT8*) "PLUS_SIGN",
        (ANTLR_UINT8*) "PROMPT",
        (ANTLR_UINT8*) "QS_ANGLE",
        (ANTLR_UINT8*) "QS_BRACE",
        (ANTLR_UINT8*) "QS_BRACK",
        (ANTLR_UINT8*) "QS_OTHER",
        (ANTLR_UINT8*) "QS_OTHER_CH",
        (ANTLR_UINT8*) "QS_PAREN",
        (ANTLR_UINT8*) "QUESTION_MARK",
        (ANTLR_UINT8*) "QUOTE",
        (ANTLR_UINT8*) "REGULAR_ID",
        (ANTLR_UINT8*) "RIGHT_BRACKET",
        (ANTLR_UINT8*) "RIGHT_PAREN",
        (ANTLR_UINT8*) "SEMICOLON",
        (ANTLR_UINT8*) "SEPARATOR",
        (ANTLR_UINT8*) "SIMPLE_LETTER",
        (ANTLR_UINT8*) "SOLIDUS",
        (ANTLR_UINT8*) "SPACE",
        (ANTLR_UINT8*) "SQL92_RESERVED_ALL",
        (ANTLR_UINT8*) "SQL92_RESERVED_ALTER",
        (ANTLR_UINT8*) "SQL92_RESERVED_AND",
        (ANTLR_UINT8*) "SQL92_RESERVED_ANY",
        (ANTLR_UINT8*) "SQL92_RESERVED_AS",
        (ANTLR_UINT8*) "SQL92_RESERVED_ASC",
        (ANTLR_UINT8*) "SQL92_RESERVED_BEGIN",
        (ANTLR_UINT8*) "SQL92_RESERVED_BETWEEN",
        (ANTLR_UINT8*) "SQL92_RESERVED_BY",
        (ANTLR_UINT8*) "SQL92_RESERVED_CASE",
        (ANTLR_UINT8*) "SQL92_RESERVED_CHECK",
        (ANTLR_UINT8*) "SQL92_RESERVED_CONNECT",
        (ANTLR_UINT8*) "SQL92_RESERVED_CREATE",
        (ANTLR_UINT8*) "SQL92_RESERVED_CURRENT",
        (ANTLR_UINT8*) "SQL92_RESERVED_CURSOR",
        (ANTLR_UINT8*) "SQL92_RESERVED_DATE",
        (ANTLR_UINT8*) "SQL92_RESERVED_DECLARE",
        (ANTLR_UINT8*) "SQL92_RESERVED_DEFAULT",
        (ANTLR_UINT8*) "SQL92_RESERVED_DELETE",
        (ANTLR_UINT8*) "SQL92_RESERVED_DESC",
        (ANTLR_UINT8*) "SQL92_RESERVED_DISTINCT",
        (ANTLR_UINT8*) "SQL92_RESERVED_DROP",
        (ANTLR_UINT8*) "SQL92_RESERVED_ELSE",
        (ANTLR_UINT8*) "SQL92_RESERVED_END",
        (ANTLR_UINT8*) "SQL92_RESERVED_EXCEPTION",
        (ANTLR_UINT8*) "SQL92_RESERVED_EXISTS",
        (ANTLR_UINT8*) "SQL92_RESERVED_FALSE",
        (ANTLR_UINT8*) "SQL92_RESERVED_FETCH",
        (ANTLR_UINT8*) "SQL92_RESERVED_FOR",
        (ANTLR_UINT8*) "SQL92_RESERVED_FROM",
        (ANTLR_UINT8*) "SQL92_RESERVED_GOTO",
        (ANTLR_UINT8*) "SQL92_RESERVED_GRANT",
        (ANTLR_UINT8*) "SQL92_RESERVED_GROUP",
        (ANTLR_UINT8*) "SQL92_RESERVED_HAVING",
        (ANTLR_UINT8*) "SQL92_RESERVED_IN",
        (ANTLR_UINT8*) "SQL92_RESERVED_INSERT",
        (ANTLR_UINT8*) "SQL92_RESERVED_INTERSECT",
        (ANTLR_UINT8*) "SQL92_RESERVED_INTO",
        (ANTLR_UINT8*) "SQL92_RESERVED_IS",
        (ANTLR_UINT8*) "SQL92_RESERVED_LIKE",
        (ANTLR_UINT8*) "SQL92_RESERVED_NOT",
        (ANTLR_UINT8*) "SQL92_RESERVED_NULL",
        (ANTLR_UINT8*) "SQL92_RESERVED_OF",
        (ANTLR_UINT8*) "SQL92_RESERVED_ON",
        (ANTLR_UINT8*) "SQL92_RESERVED_OPTION",
        (ANTLR_UINT8*) "SQL92_RESERVED_OR",
        (ANTLR_UINT8*) "SQL92_RESERVED_ORDER",
        (ANTLR_UINT8*) "SQL92_RESERVED_OVERLAPS",
        (ANTLR_UINT8*) "SQL92_RESERVED_PRIOR",
        (ANTLR_UINT8*) "SQL92_RESERVED_PROCEDURE",
        (ANTLR_UINT8*) "SQL92_RESERVED_PUBLIC",
        (ANTLR_UINT8*) "SQL92_RESERVED_REVOKE",
        (ANTLR_UINT8*) "SQL92_RESERVED_SELECT",
        (ANTLR_UINT8*) "SQL92_RESERVED_SIZE",
        (ANTLR_UINT8*) "SQL92_RESERVED_TABLE",
        (ANTLR_UINT8*) "SQL92_RESERVED_THE",
        (ANTLR_UINT8*) "SQL92_RESERVED_THEN",
        (ANTLR_UINT8*) "SQL92_RESERVED_TO",
        (ANTLR_UINT8*) "SQL92_RESERVED_TRUE",
        (ANTLR_UINT8*) "SQL92_RESERVED_UNION",
        (ANTLR_UINT8*) "SQL92_RESERVED_UNIQUE",
        (ANTLR_UINT8*) "SQL92_RESERVED_UPDATE",
        (ANTLR_UINT8*) "SQL92_RESERVED_VALUES",
        (ANTLR_UINT8*) "SQL92_RESERVED_VIEW",
        (ANTLR_UINT8*) "SQL92_RESERVED_WHEN",
        (ANTLR_UINT8*) "SQL92_RESERVED_WHERE",
        (ANTLR_UINT8*) "SQL92_RESERVED_WITH",
        (ANTLR_UINT8*) "TILDE_OPERATOR_PART",
        (ANTLR_UINT8*) "UNDERSCORE",
        (ANTLR_UINT8*) "UNSIGNED_INTEGER",
        (ANTLR_UINT8*) "VERTICAL_BAR",
        (ANTLR_UINT8*) "ZV",
        (ANTLR_UINT8*) "154",
        (ANTLR_UINT8*) "155",
        (ANTLR_UINT8*) "156",
        (ANTLR_UINT8*) "157",
        (ANTLR_UINT8*) "158",
        (ANTLR_UINT8*) "159",
        (ANTLR_UINT8*) "160",
        (ANTLR_UINT8*) "161",
        (ANTLR_UINT8*) "162",
        (ANTLR_UINT8*) "163",
        (ANTLR_UINT8*) "164",
        (ANTLR_UINT8*) "165",
        (ANTLR_UINT8*) "166",
        (ANTLR_UINT8*) "167",
        (ANTLR_UINT8*) "168",
        (ANTLR_UINT8*) "169",
        (ANTLR_UINT8*) "170",
        (ANTLR_UINT8*) "171",
        (ANTLR_UINT8*) "172",
        (ANTLR_UINT8*) "173",
        (ANTLR_UINT8*) "174",
        (ANTLR_UINT8*) "175",
        (ANTLR_UINT8*) "176",
        (ANTLR_UINT8*) "177",
        (ANTLR_UINT8*) "178",
        (ANTLR_UINT8*) "179",
        (ANTLR_UINT8*) "180",
        (ANTLR_UINT8*) "181",
        (ANTLR_UINT8*) "182",
        (ANTLR_UINT8*) "183",
        (ANTLR_UINT8*) "184",
        (ANTLR_UINT8*) "185",
        (ANTLR_UINT8*) "186",
        (ANTLR_UINT8*) "187",
        (ANTLR_UINT8*) "188",
        (ANTLR_UINT8*) "189",
        (ANTLR_UINT8*) "190",
        (ANTLR_UINT8*) "191",
        (ANTLR_UINT8*) "192",
        (ANTLR_UINT8*) "193",
        (ANTLR_UINT8*) "194",
        (ANTLR_UINT8*) "195",
        (ANTLR_UINT8*) "196",
        (ANTLR_UINT8*) "197",
        (ANTLR_UINT8*) "198",
        (ANTLR_UINT8*) "199",
        (ANTLR_UINT8*) "200",
        (ANTLR_UINT8*) "201",
        (ANTLR_UINT8*) "202",
        (ANTLR_UINT8*) "203",
        (ANTLR_UINT8*) "204",
        (ANTLR_UINT8*) "205",
        (ANTLR_UINT8*) "206",
        (ANTLR_UINT8*) "207",
        (ANTLR_UINT8*) "208",
        (ANTLR_UINT8*) "209",
        (ANTLR_UINT8*) "210",
        (ANTLR_UINT8*) "211",
        (ANTLR_UINT8*) "212",
        (ANTLR_UINT8*) "213",
        (ANTLR_UINT8*) "214",
        (ANTLR_UINT8*) "215",
        (ANTLR_UINT8*) "216",
        (ANTLR_UINT8*) "217",
        (ANTLR_UINT8*) "218",
        (ANTLR_UINT8*) "219",
        (ANTLR_UINT8*) "220",
        (ANTLR_UINT8*) "221",
        (ANTLR_UINT8*) "222",
        (ANTLR_UINT8*) "223",
        (ANTLR_UINT8*) "224",
        (ANTLR_UINT8*) "225",
        (ANTLR_UINT8*) "226",
        (ANTLR_UINT8*) "227",
        (ANTLR_UINT8*) "228",
        (ANTLR_UINT8*) "229",
        (ANTLR_UINT8*) "230",
        (ANTLR_UINT8*) "231",
        (ANTLR_UINT8*) "232",
        (ANTLR_UINT8*) "233",
        (ANTLR_UINT8*) "234",
        (ANTLR_UINT8*) "235",
        (ANTLR_UINT8*) "236",
        (ANTLR_UINT8*) "237",
        (ANTLR_UINT8*) "238",
        (ANTLR_UINT8*) "239",
        (ANTLR_UINT8*) "240",
        (ANTLR_UINT8*) "241",
        (ANTLR_UINT8*) "242",
        (ANTLR_UINT8*) "243",
        (ANTLR_UINT8*) "244",
        (ANTLR_UINT8*) "245",
        (ANTLR_UINT8*) "246",
        (ANTLR_UINT8*) "247",
        (ANTLR_UINT8*) "248",
        (ANTLR_UINT8*) "249",
        (ANTLR_UINT8*) "250",
        (ANTLR_UINT8*) "251",
        (ANTLR_UINT8*) "252",
        (ANTLR_UINT8*) "253",
        (ANTLR_UINT8*) "254",
        (ANTLR_UINT8*) "255",
        (ANTLR_UINT8*) "256",
        (ANTLR_UINT8*) "257",
        (ANTLR_UINT8*) "258",
        (ANTLR_UINT8*) "259",
        (ANTLR_UINT8*) "260",
        (ANTLR_UINT8*) "261",
        (ANTLR_UINT8*) "262",
        (ANTLR_UINT8*) "263",
        (ANTLR_UINT8*) "264",
        (ANTLR_UINT8*) "265",
        (ANTLR_UINT8*) "266",
        (ANTLR_UINT8*) "267",
        (ANTLR_UINT8*) "268"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "PLSQLParser.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* PLSQLParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new PLSQLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PLSQLParser::PLSQLParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new PLSQLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PLSQLParser::PLSQLParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void PLSQLParser::init(StreamType* instream)
{
	// Initialize the lexers that we are going to delegate some
	// functions to.
	//
	m_gPLSQLKeys = new PLSQLParser_PLSQLKeys(instream, this->get_psrstate(), this);
	m_gPLSQLCommons = new PLSQLParser_PLSQLCommons(instream, this->get_psrstate(), this);
	m_gPLSQL_DMLParser = new PLSQLParser_PLSQL_DMLParser(instream, this->get_psrstate(), this);
	m_gSQLPLUSParser = new PLSQLParser_SQLPLUSParser(instream, this->get_psrstate(), this);
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( PLSQLParserTokenNames );


}

void
PLSQLParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
PLSQLParser::~PLSQLParser()
 {
	// Free the parsers that we delegated to
	// functions to.NULL the state so we only free it once.
	//
	m_gPLSQLKeys->set_psrstate( NULL );
	         delete m_gPLSQLKeys;
	m_gPLSQLCommons->set_psrstate( NULL );
	         delete m_gPLSQLCommons;
	m_gPLSQL_DMLParser->set_psrstate( NULL );
	         delete m_gPLSQL_DMLParser;
	m_gSQLPLUSParser->set_psrstate( NULL );
	         delete m_gSQLPLUSParser;
}

/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return PLSQLParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_unit_statement_in_compilation_unit118_bits[]	= { ANTLR_UINT64_LIT(0x0040000040000000), ANTLR_UINT64_LIT(0x0020009040080400), ANTLR_UINT64_LIT(0x0000000000108048) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_unit_statement_in_compilation_unit118( FOLLOW_unit_statement_in_compilation_unit118_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_EOF_in_compilation_unit121_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_EOF_in_compilation_unit121( FOLLOW_EOF_in_compilation_unit121_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_unit_statement_in_sql_script141_bits[]	= { ANTLR_UINT64_LIT(0x0040000040000000), ANTLR_UINT64_LIT(0x0020009040090402), ANTLR_UINT64_LIT(0x0000000000108048) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_unit_statement_in_sql_script141( FOLLOW_unit_statement_in_sql_script141_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_sql_plus_command_in_sql_script143_bits[]	= { ANTLR_UINT64_LIT(0x0040000040000000), ANTLR_UINT64_LIT(0x0020009040090402), ANTLR_UINT64_LIT(0x0000000000108048) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_sql_plus_command_in_sql_script143( FOLLOW_sql_plus_command_in_sql_script143_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_EOF_in_sql_script147_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_EOF_in_sql_script147( FOLLOW_EOF_in_sql_script147_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_function_in_unit_statement175_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_function_in_unit_statement175( FOLLOW_alter_function_in_unit_statement175_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_package_in_unit_statement186_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_package_in_unit_statement186( FOLLOW_alter_package_in_unit_statement186_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_procedure_in_unit_statement197_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_procedure_in_unit_statement197( FOLLOW_alter_procedure_in_unit_statement197_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_sequence_in_unit_statement208_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_sequence_in_unit_statement208( FOLLOW_alter_sequence_in_unit_statement208_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_trigger_in_unit_statement219_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_trigger_in_unit_statement219( FOLLOW_alter_trigger_in_unit_statement219_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_type_in_unit_statement230_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_type_in_unit_statement230( FOLLOW_alter_type_in_unit_statement230_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_function_body_in_unit_statement242_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_function_body_in_unit_statement242( FOLLOW_create_function_body_in_unit_statement242_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_procedure_body_in_unit_statement253_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_procedure_body_in_unit_statement253( FOLLOW_create_procedure_body_in_unit_statement253_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_package_in_unit_statement264_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_package_in_unit_statement264( FOLLOW_create_package_in_unit_statement264_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_sequence_in_unit_statement282_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_sequence_in_unit_statement282( FOLLOW_create_sequence_in_unit_statement282_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_trigger_in_unit_statement293_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_trigger_in_unit_statement293( FOLLOW_create_trigger_in_unit_statement293_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_type_in_unit_statement304_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_type_in_unit_statement304( FOLLOW_create_type_in_unit_statement304_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_function_in_unit_statement316_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_function_in_unit_statement316( FOLLOW_drop_function_in_unit_statement316_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_package_in_unit_statement327_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_package_in_unit_statement327( FOLLOW_drop_package_in_unit_statement327_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_procedure_in_unit_statement338_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_procedure_in_unit_statement338( FOLLOW_drop_procedure_in_unit_statement338_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_sequence_in_unit_statement349_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_sequence_in_unit_statement349( FOLLOW_drop_sequence_in_unit_statement349_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_trigger_in_unit_statement360_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_trigger_in_unit_statement360( FOLLOW_drop_trigger_in_unit_statement360_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_type_in_unit_statement371_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_type_in_unit_statement371( FOLLOW_drop_type_in_unit_statement371_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_data_manipulation_language_statements_in_unit_statement382_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_data_manipulation_language_statements_in_unit_statement382( FOLLOW_data_manipulation_language_statements_in_unit_statement382_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_key_in_drop_function406_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_key_in_drop_function406( FOLLOW_drop_key_in_drop_function406_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_key_in_drop_function408_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_function_key_in_drop_function408( FOLLOW_function_key_in_drop_function408_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_name_in_drop_function410_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_function_name_in_drop_function410( FOLLOW_function_name_in_drop_function410_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_drop_function420_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_drop_function420( FOLLOW_SEMICOLON_in_drop_function420_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_key_in_alter_function440_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_key_in_alter_function440( FOLLOW_alter_key_in_alter_function440_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_key_in_alter_function442_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_function_key_in_alter_function442( FOLLOW_function_key_in_alter_function442_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_name_in_alter_function444_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_function_name_in_alter_function444( FOLLOW_function_name_in_alter_function444_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_compile_key_in_alter_function454_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_compile_key_in_alter_function454( FOLLOW_compile_key_in_alter_function454_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_debug_key_in_alter_function456_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_debug_key_in_alter_function456( FOLLOW_debug_key_in_alter_function456_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_compiler_parameters_clause_in_alter_function459_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_compiler_parameters_clause_in_alter_function459( FOLLOW_compiler_parameters_clause_in_alter_function459_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_reuse_key_in_alter_function471_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_reuse_key_in_alter_function471( FOLLOW_reuse_key_in_alter_function471_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_settings_key_in_alter_function473_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_settings_key_in_alter_function473( FOLLOW_settings_key_in_alter_function473_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_alter_function485_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_alter_function485( FOLLOW_SEMICOLON_in_alter_function485_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_key_in_create_function_body506_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x8000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_key_in_create_function_body506( FOLLOW_create_key_in_create_function_body506_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_or_key_in_create_function_body510_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_or_key_in_create_function_body510( FOLLOW_or_key_in_create_function_body510_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_replace_key_in_create_function_body512_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_replace_key_in_create_function_body512( FOLLOW_replace_key_in_create_function_body512_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_key_in_create_function_body519_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_function_key_in_create_function_body519( FOLLOW_function_key_in_create_function_body519_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_name_in_create_function_body521_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_function_name_in_create_function_body521( FOLLOW_function_name_in_create_function_body521_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_create_function_body540_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_create_function_body540( FOLLOW_LEFT_PAREN_in_create_function_body540_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_parameter_in_create_function_body542_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_parameter_in_create_function_body542( FOLLOW_parameter_in_create_function_body542_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_create_function_body545_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_create_function_body545( FOLLOW_COMMA_in_create_function_body545_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_parameter_in_create_function_body547_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_parameter_in_create_function_body547( FOLLOW_parameter_in_create_function_body547_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_create_function_body551_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_create_function_body551( FOLLOW_RIGHT_PAREN_in_create_function_body551_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_return_key_in_create_function_body563_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_return_key_in_create_function_body563( FOLLOW_return_key_in_create_function_body563_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_create_function_body565_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000400400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_create_function_body565( FOLLOW_type_spec_in_create_function_body565_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_invoker_rights_clause_in_create_function_body584_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000400400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_invoker_rights_clause_in_create_function_body584( FOLLOW_invoker_rights_clause_in_create_function_body584_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_parallel_enable_clause_in_create_function_body586_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000400400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_parallel_enable_clause_in_create_function_body586( FOLLOW_parallel_enable_clause_in_create_function_body586_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_result_cache_clause_in_create_function_body588_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000400400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_result_cache_clause_in_create_function_body588( FOLLOW_result_cache_clause_in_create_function_body588_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_deterministic_key_in_create_function_body590_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000400400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_deterministic_key_in_create_function_body590( FOLLOW_deterministic_key_in_create_function_body590_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_pipelined_key_in_create_function_body621_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000400000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_pipelined_key_in_create_function_body621( FOLLOW_pipelined_key_in_create_function_body621_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_create_function_body626_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_create_function_body626( FOLLOW_is_key_in_create_function_body626_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_create_function_body630_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_as_key_in_create_function_body630( FOLLOW_as_key_in_create_function_body630_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_declare_key_in_create_function_body661_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000141000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_declare_key_in_create_function_body661( FOLLOW_declare_key_in_create_function_body661_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_declare_spec_in_create_function_body664_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000141000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_declare_spec_in_create_function_body664( FOLLOW_declare_spec_in_create_function_body664_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_body_in_create_function_body667_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_body_in_create_function_body667( FOLLOW_body_in_create_function_body667_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_call_spec_in_create_function_body697_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_call_spec_in_create_function_body697( FOLLOW_call_spec_in_create_function_body697_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_pipelined_key_in_create_function_body728_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_pipelined_key_in_create_function_body728( FOLLOW_pipelined_key_in_create_function_body728_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_aggregate_key_in_create_function_body730_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_aggregate_key_in_create_function_body730( FOLLOW_aggregate_key_in_create_function_body730_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_using_key_in_create_function_body733_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_using_key_in_create_function_body733( FOLLOW_using_key_in_create_function_body733_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_implementation_type_name_in_create_function_body735_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_implementation_type_name_in_create_function_body735( FOLLOW_implementation_type_name_in_create_function_body735_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_create_function_body761_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_create_function_body761( FOLLOW_SEMICOLON_in_create_function_body761_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_parallel_enable_key_in_parallel_enable_clause783_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_parallel_enable_key_in_parallel_enable_clause783( FOLLOW_parallel_enable_key_in_parallel_enable_clause783_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_partition_by_clause_in_parallel_enable_clause785_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_partition_by_clause_in_parallel_enable_clause785( FOLLOW_partition_by_clause_in_parallel_enable_clause785_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_partition_by_clause806_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_partition_by_clause806( FOLLOW_LEFT_PAREN_in_partition_by_clause806_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_partition_key_in_partition_by_clause820_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_partition_key_in_partition_by_clause820( FOLLOW_partition_key_in_partition_by_clause820_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_partition_by_clause822_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_partition_by_clause822( FOLLOW_expression_in_partition_by_clause822_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_partition_by_clause824_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000200400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_by_key_in_partition_by_clause824( FOLLOW_by_key_in_partition_by_clause824_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_any_key_in_partition_by_clause844_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_any_key_in_partition_by_clause844( FOLLOW_any_key_in_partition_by_clause844_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_hash_key_in_partition_by_clause865_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_hash_key_in_partition_by_clause865( FOLLOW_hash_key_in_partition_by_clause865_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_range_key_in_partition_by_clause867_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_range_key_in_partition_by_clause867( FOLLOW_range_key_in_partition_by_clause867_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_partition_by_clause870_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_partition_by_clause870( FOLLOW_LEFT_PAREN_in_partition_by_clause870_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_partition_by_clause872_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_column_name_in_partition_by_clause872( FOLLOW_column_name_in_partition_by_clause872_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_partition_by_clause875_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_partition_by_clause875( FOLLOW_COMMA_in_partition_by_clause875_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_partition_by_clause877_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_column_name_in_partition_by_clause877( FOLLOW_column_name_in_partition_by_clause877_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_partition_by_clause881_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_partition_by_clause881( FOLLOW_RIGHT_PAREN_in_partition_by_clause881_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_streaming_clause_in_partition_by_clause909_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_streaming_clause_in_partition_by_clause909( FOLLOW_streaming_clause_in_partition_by_clause909_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_partition_by_clause920_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_partition_by_clause920( FOLLOW_RIGHT_PAREN_in_partition_by_clause920_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_result_cache_key_in_result_cache_clause940_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_result_cache_key_in_result_cache_clause940( FOLLOW_result_cache_key_in_result_cache_clause940_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_relies_on_part_in_result_cache_clause942_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_relies_on_part_in_result_cache_clause942( FOLLOW_relies_on_part_in_result_cache_clause942_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_relies_on_key_in_relies_on_part963_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_relies_on_key_in_relies_on_part963( FOLLOW_relies_on_key_in_relies_on_part963_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_relies_on_part965_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_relies_on_part965( FOLLOW_LEFT_PAREN_in_relies_on_part965_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_relies_on_part967_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_relies_on_part967( FOLLOW_tableview_name_in_relies_on_part967_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_relies_on_part970_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_relies_on_part970( FOLLOW_COMMA_in_relies_on_part970_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_relies_on_part972_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_relies_on_part972( FOLLOW_tableview_name_in_relies_on_part972_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_relies_on_part976_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_relies_on_part976( FOLLOW_RIGHT_PAREN_in_relies_on_part976_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_order_key_in_streaming_clause997_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_order_key_in_streaming_clause997( FOLLOW_order_key_in_streaming_clause997_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_cluster_key_in_streaming_clause999_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_cluster_key_in_streaming_clause999( FOLLOW_cluster_key_in_streaming_clause999_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_streaming_clause1002_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_streaming_clause1002( FOLLOW_expression_in_streaming_clause1002_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_streaming_clause1004_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_by_key_in_streaming_clause1004( FOLLOW_by_key_in_streaming_clause1004_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_streaming_clause1015_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_streaming_clause1015( FOLLOW_LEFT_PAREN_in_streaming_clause1015_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_streaming_clause1017_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_column_name_in_streaming_clause1017( FOLLOW_column_name_in_streaming_clause1017_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_streaming_clause1020_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_streaming_clause1020( FOLLOW_COMMA_in_streaming_clause1020_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_streaming_clause1022_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_column_name_in_streaming_clause1022( FOLLOW_column_name_in_streaming_clause1022_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_streaming_clause1026_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_streaming_clause1026( FOLLOW_RIGHT_PAREN_in_streaming_clause1026_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_key_in_drop_package1050_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_key_in_drop_package1050( FOLLOW_drop_key_in_drop_package1050_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_package_key_in_drop_package1052_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_package_key_in_drop_package1052( FOLLOW_package_key_in_drop_package1052_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_body_key_in_drop_package1054_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_body_key_in_drop_package1054( FOLLOW_body_key_in_drop_package1054_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_package_name_in_drop_package1057_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_package_name_in_drop_package1057( FOLLOW_package_name_in_drop_package1057_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_drop_package1067_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_drop_package1067( FOLLOW_SEMICOLON_in_drop_package1067_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_key_in_alter_package1087_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_key_in_alter_package1087( FOLLOW_alter_key_in_alter_package1087_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_package_key_in_alter_package1089_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_package_key_in_alter_package1089( FOLLOW_package_key_in_alter_package1089_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_package_name_in_alter_package1091_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_package_name_in_alter_package1091( FOLLOW_package_name_in_alter_package1091_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_compile_key_in_alter_package1101_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_compile_key_in_alter_package1101( FOLLOW_compile_key_in_alter_package1101_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_debug_key_in_alter_package1103_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_debug_key_in_alter_package1103( FOLLOW_debug_key_in_alter_package1103_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_package_key_in_alter_package1107_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_package_key_in_alter_package1107( FOLLOW_package_key_in_alter_package1107_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_body_key_in_alter_package1109_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_body_key_in_alter_package1109( FOLLOW_body_key_in_alter_package1109_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_specification_key_in_alter_package1111_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_specification_key_in_alter_package1111( FOLLOW_specification_key_in_alter_package1111_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_compiler_parameters_clause_in_alter_package1123_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_compiler_parameters_clause_in_alter_package1123( FOLLOW_compiler_parameters_clause_in_alter_package1123_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_reuse_key_in_alter_package1135_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_reuse_key_in_alter_package1135( FOLLOW_reuse_key_in_alter_package1135_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_settings_key_in_alter_package1137_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_settings_key_in_alter_package1137( FOLLOW_settings_key_in_alter_package1137_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_alter_package1149_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_alter_package1149( FOLLOW_SEMICOLON_in_alter_package1149_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_key_in_create_package1169_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x8000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_key_in_create_package1169( FOLLOW_create_key_in_create_package1169_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_or_key_in_create_package1173_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_or_key_in_create_package1173( FOLLOW_or_key_in_create_package1173_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_replace_key_in_create_package1175_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_replace_key_in_create_package1175( FOLLOW_replace_key_in_create_package1175_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_package_key_in_create_package1180_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_package_key_in_create_package1180( FOLLOW_package_key_in_create_package1180_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_package_spec_in_create_package1192_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_package_spec_in_create_package1192( FOLLOW_package_spec_in_create_package1192_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_package_body_in_create_package1196_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_package_body_in_create_package1196( FOLLOW_package_body_in_create_package1196_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_create_package1209_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_create_package1209( FOLLOW_SEMICOLON_in_create_package1209_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_body_key_in_package_body1231_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_body_key_in_package_body1231( FOLLOW_body_key_in_package_body1231_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_package_name_in_package_body1233_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000400000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_package_name_in_package_body1233( FOLLOW_package_name_in_package_body1233_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_package_body1236_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000020141000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_package_body1236( FOLLOW_is_key_in_package_body1236_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_package_body1240_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000020141000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_as_key_in_package_body1240( FOLLOW_as_key_in_package_body1240_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_package_obj_body_in_package_body1251_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000020141000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_package_obj_body_in_package_body1251( FOLLOW_package_obj_body_in_package_body1251_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_begin_key_in_package_body1263_bits[]	= { ANTLR_UINT64_LIT(0x00480000D0044200), ANTLR_UINT64_LIT(0x0823601549080400), ANTLR_UINT64_LIT(0x0000000000108048) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_begin_key_in_package_body1263( FOLLOW_begin_key_in_package_body1263_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_seq_of_statements_in_package_body1265_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_seq_of_statements_in_package_body1265( FOLLOW_seq_of_statements_in_package_body1265_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_end_key_in_package_body1267_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_end_key_in_package_body1267( FOLLOW_end_key_in_package_body1267_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_package_name_in_package_body1269_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_package_name_in_package_body1269( FOLLOW_package_name_in_package_body1269_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_package_name_in_package_spec1291_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000400400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_package_name_in_package_spec1291( FOLLOW_package_name_in_package_spec1291_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_invoker_rights_clause_in_package_spec1293_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000400000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_invoker_rights_clause_in_package_spec1293( FOLLOW_invoker_rights_clause_in_package_spec1293_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_package_spec1297_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000020100000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_package_spec1297( FOLLOW_is_key_in_package_spec1297_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_package_spec1301_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000020100000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_as_key_in_package_spec1301( FOLLOW_as_key_in_package_spec1301_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_package_obj_spec_in_package_spec1312_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000020100000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_package_obj_spec_in_package_spec1312( FOLLOW_package_obj_spec_in_package_spec1312_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_end_key_in_package_spec1323_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_end_key_in_package_spec1323( FOLLOW_end_key_in_package_spec1323_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_package_name_in_package_spec1325_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_package_name_in_package_spec1325( FOLLOW_package_name_in_package_spec1325_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_variable_declaration_in_package_obj_spec1354_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_variable_declaration_in_package_obj_spec1354( FOLLOW_variable_declaration_in_package_obj_spec1354_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_subtype_declaration_in_package_obj_spec1366_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_subtype_declaration_in_package_obj_spec1366( FOLLOW_subtype_declaration_in_package_obj_spec1366_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_declaration_in_package_obj_spec1378_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_cursor_declaration_in_package_obj_spec1378( FOLLOW_cursor_declaration_in_package_obj_spec1378_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exception_declaration_in_package_obj_spec1390_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exception_declaration_in_package_obj_spec1390( FOLLOW_exception_declaration_in_package_obj_spec1390_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_record_declaration_in_package_obj_spec1402_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_record_declaration_in_package_obj_spec1402( FOLLOW_record_declaration_in_package_obj_spec1402_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_table_declaration_in_package_obj_spec1414_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_table_declaration_in_package_obj_spec1414( FOLLOW_table_declaration_in_package_obj_spec1414_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_procedure_spec_in_package_obj_spec1426_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_procedure_spec_in_package_obj_spec1426( FOLLOW_procedure_spec_in_package_obj_spec1426_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_spec_in_package_obj_spec1438_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_function_spec_in_package_obj_spec1438( FOLLOW_function_spec_in_package_obj_spec1438_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_procedure_key_in_procedure_spec1459_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_procedure_key_in_procedure_spec1459( FOLLOW_procedure_key_in_procedure_spec1459_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_procedure_name_in_procedure_spec1461_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_procedure_name_in_procedure_spec1461( FOLLOW_procedure_name_in_procedure_spec1461_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_procedure_spec1474_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_procedure_spec1474( FOLLOW_LEFT_PAREN_in_procedure_spec1474_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_parameter_in_procedure_spec1476_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_parameter_in_procedure_spec1476( FOLLOW_parameter_in_procedure_spec1476_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_procedure_spec1480_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_procedure_spec1480( FOLLOW_COMMA_in_procedure_spec1480_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_parameter_in_procedure_spec1482_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_parameter_in_procedure_spec1482( FOLLOW_parameter_in_procedure_spec1482_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_procedure_spec1487_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_procedure_spec1487( FOLLOW_RIGHT_PAREN_in_procedure_spec1487_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_procedure_spec1492_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_procedure_spec1492( FOLLOW_SEMICOLON_in_procedure_spec1492_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_key_in_function_spec1513_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_function_key_in_function_spec1513( FOLLOW_function_key_in_function_spec1513_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_name_in_function_spec1515_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_function_name_in_function_spec1515( FOLLOW_function_name_in_function_spec1515_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_function_spec1527_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_function_spec1527( FOLLOW_LEFT_PAREN_in_function_spec1527_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_parameter_in_function_spec1529_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_parameter_in_function_spec1529( FOLLOW_parameter_in_function_spec1529_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_function_spec1533_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_function_spec1533( FOLLOW_COMMA_in_function_spec1533_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_parameter_in_function_spec1535_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_parameter_in_function_spec1535( FOLLOW_parameter_in_function_spec1535_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_function_spec1539_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_function_spec1539( FOLLOW_RIGHT_PAREN_in_function_spec1539_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_return_key_in_function_spec1552_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_return_key_in_function_spec1552( FOLLOW_return_key_in_function_spec1552_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_function_spec1554_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_function_spec1554( FOLLOW_type_spec_in_function_spec1554_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_function_spec1556_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_function_spec1556( FOLLOW_SEMICOLON_in_function_spec1556_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_variable_declaration_in_package_obj_body1586_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_variable_declaration_in_package_obj_body1586( FOLLOW_variable_declaration_in_package_obj_body1586_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_subtype_declaration_in_package_obj_body1599_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_subtype_declaration_in_package_obj_body1599( FOLLOW_subtype_declaration_in_package_obj_body1599_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_declaration_in_package_obj_body1612_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_cursor_declaration_in_package_obj_body1612( FOLLOW_cursor_declaration_in_package_obj_body1612_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exception_declaration_in_package_obj_body1625_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exception_declaration_in_package_obj_body1625( FOLLOW_exception_declaration_in_package_obj_body1625_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_record_declaration_in_package_obj_body1638_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_record_declaration_in_package_obj_body1638( FOLLOW_record_declaration_in_package_obj_body1638_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_table_declaration_in_package_obj_body1650_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_table_declaration_in_package_obj_body1650( FOLLOW_table_declaration_in_package_obj_body1650_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_procedure_body_in_package_obj_body1662_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_procedure_body_in_package_obj_body1662( FOLLOW_create_procedure_body_in_package_obj_body1662_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_function_body_in_package_obj_body1674_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_function_body_in_package_obj_body1674( FOLLOW_create_function_body_in_package_obj_body1674_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_key_in_drop_procedure1701_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_key_in_drop_procedure1701( FOLLOW_drop_key_in_drop_procedure1701_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_procedure_key_in_drop_procedure1703_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_procedure_key_in_drop_procedure1703( FOLLOW_procedure_key_in_drop_procedure1703_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_procedure_name_in_drop_procedure1705_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_procedure_name_in_drop_procedure1705( FOLLOW_procedure_name_in_drop_procedure1705_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_drop_procedure1715_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_drop_procedure1715( FOLLOW_SEMICOLON_in_drop_procedure1715_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_key_in_alter_procedure1735_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_key_in_alter_procedure1735( FOLLOW_alter_key_in_alter_procedure1735_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_procedure_key_in_alter_procedure1737_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_procedure_key_in_alter_procedure1737( FOLLOW_procedure_key_in_alter_procedure1737_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_procedure_name_in_alter_procedure1739_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_procedure_name_in_alter_procedure1739( FOLLOW_procedure_name_in_alter_procedure1739_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_compile_key_in_alter_procedure1749_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_compile_key_in_alter_procedure1749( FOLLOW_compile_key_in_alter_procedure1749_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_debug_key_in_alter_procedure1751_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_debug_key_in_alter_procedure1751( FOLLOW_debug_key_in_alter_procedure1751_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_compiler_parameters_clause_in_alter_procedure1754_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_compiler_parameters_clause_in_alter_procedure1754( FOLLOW_compiler_parameters_clause_in_alter_procedure1754_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_reuse_key_in_alter_procedure1766_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_reuse_key_in_alter_procedure1766( FOLLOW_reuse_key_in_alter_procedure1766_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_settings_key_in_alter_procedure1768_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_settings_key_in_alter_procedure1768( FOLLOW_settings_key_in_alter_procedure1768_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_alter_procedure1780_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_alter_procedure1780( FOLLOW_SEMICOLON_in_alter_procedure1780_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_key_in_create_procedure_body1801_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x8000000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_key_in_create_procedure_body1801( FOLLOW_create_key_in_create_procedure_body1801_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_or_key_in_create_procedure_body1805_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_or_key_in_create_procedure_body1805( FOLLOW_or_key_in_create_procedure_body1805_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_replace_key_in_create_procedure_body1807_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_replace_key_in_create_procedure_body1807( FOLLOW_replace_key_in_create_procedure_body1807_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_procedure_key_in_create_procedure_body1814_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_procedure_key_in_create_procedure_body1814( FOLLOW_procedure_key_in_create_procedure_body1814_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_procedure_name_in_create_procedure_body1816_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0100000000400400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_procedure_name_in_create_procedure_body1816( FOLLOW_procedure_name_in_create_procedure_body1816_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_create_procedure_body1834_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_create_procedure_body1834( FOLLOW_LEFT_PAREN_in_create_procedure_body1834_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_parameter_in_create_procedure_body1836_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_parameter_in_create_procedure_body1836( FOLLOW_parameter_in_create_procedure_body1836_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_create_procedure_body1840_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_create_procedure_body1840( FOLLOW_COMMA_in_create_procedure_body1840_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_parameter_in_create_procedure_body1842_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_parameter_in_create_procedure_body1842( FOLLOW_parameter_in_create_procedure_body1842_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_create_procedure_body1847_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000400400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_create_procedure_body1847( FOLLOW_RIGHT_PAREN_in_create_procedure_body1847_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_invoker_rights_clause_in_create_procedure_body1867_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000400000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_invoker_rights_clause_in_create_procedure_body1867( FOLLOW_invoker_rights_clause_in_create_procedure_body1867_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_create_procedure_body1880_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_create_procedure_body1880( FOLLOW_is_key_in_create_procedure_body1880_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_create_procedure_body1884_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_as_key_in_create_procedure_body1884( FOLLOW_as_key_in_create_procedure_body1884_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_declare_key_in_create_procedure_body1907_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000141000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_declare_key_in_create_procedure_body1907( FOLLOW_declare_key_in_create_procedure_body1907_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_declare_spec_in_create_procedure_body1910_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000141000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_declare_spec_in_create_procedure_body1910( FOLLOW_declare_spec_in_create_procedure_body1910_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_body_in_create_procedure_body1913_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_body_in_create_procedure_body1913( FOLLOW_body_in_create_procedure_body1913_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_call_spec_in_create_procedure_body1935_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_call_spec_in_create_procedure_body1935( FOLLOW_call_spec_in_create_procedure_body1935_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_external_key_in_create_procedure_body1957_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_external_key_in_create_procedure_body1957( FOLLOW_external_key_in_create_procedure_body1957_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_create_procedure_body1989_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_create_procedure_body1989( FOLLOW_SEMICOLON_in_create_procedure_body1989_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_key_in_drop_trigger2015_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_key_in_drop_trigger2015( FOLLOW_drop_key_in_drop_trigger2015_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_key_in_drop_trigger2017_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_key_in_drop_trigger2017( FOLLOW_trigger_key_in_drop_trigger2017_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_name_in_drop_trigger2019_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_name_in_drop_trigger2019( FOLLOW_trigger_name_in_drop_trigger2019_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_drop_trigger2029_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_drop_trigger2029( FOLLOW_SEMICOLON_in_drop_trigger2029_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_key_in_alter_trigger2049_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_key_in_alter_trigger2049( FOLLOW_alter_key_in_alter_trigger2049_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_key_in_alter_trigger2051_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_key_in_alter_trigger2051( FOLLOW_trigger_key_in_alter_trigger2051_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_name_in_alter_trigger2055_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_name_in_alter_trigger2055( FOLLOW_trigger_name_in_alter_trigger2055_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_enable_key_in_alter_trigger2067_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_enable_key_in_alter_trigger2067( FOLLOW_enable_key_in_alter_trigger2067_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_disable_key_in_alter_trigger2069_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_disable_key_in_alter_trigger2069( FOLLOW_disable_key_in_alter_trigger2069_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_rename_key_in_alter_trigger2081_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_rename_key_in_alter_trigger2081( FOLLOW_rename_key_in_alter_trigger2081_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_to_key_in_alter_trigger2083_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_to_key_in_alter_trigger2083( FOLLOW_to_key_in_alter_trigger2083_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_name_in_alter_trigger2087_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_name_in_alter_trigger2087( FOLLOW_trigger_name_in_alter_trigger2087_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_compile_key_in_alter_trigger2098_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_compile_key_in_alter_trigger2098( FOLLOW_compile_key_in_alter_trigger2098_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_debug_key_in_alter_trigger2100_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_debug_key_in_alter_trigger2100( FOLLOW_debug_key_in_alter_trigger2100_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_compiler_parameters_clause_in_alter_trigger2103_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_compiler_parameters_clause_in_alter_trigger2103( FOLLOW_compiler_parameters_clause_in_alter_trigger2103_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_reuse_key_in_alter_trigger2107_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_reuse_key_in_alter_trigger2107( FOLLOW_reuse_key_in_alter_trigger2107_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_settings_key_in_alter_trigger2109_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_settings_key_in_alter_trigger2109( FOLLOW_settings_key_in_alter_trigger2109_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_alter_trigger2122_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_alter_trigger2122( FOLLOW_SEMICOLON_in_alter_trigger2122_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_key_in_create_trigger2142_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x8000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_key_in_create_trigger2142( FOLLOW_create_key_in_create_trigger2142_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_or_key_in_create_trigger2146_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_or_key_in_create_trigger2146( FOLLOW_or_key_in_create_trigger2146_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_replace_key_in_create_trigger2148_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_replace_key_in_create_trigger2148( FOLLOW_replace_key_in_create_trigger2148_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_key_in_create_trigger2153_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_key_in_create_trigger2153( FOLLOW_trigger_key_in_create_trigger2153_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_name_in_create_trigger2155_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000400000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_name_in_create_trigger2155( FOLLOW_trigger_name_in_create_trigger2155_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_simple_dml_trigger_in_create_trigger2166_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000040008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_simple_dml_trigger_in_create_trigger2166( FOLLOW_simple_dml_trigger_in_create_trigger2166_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_compound_dml_trigger_in_create_trigger2177_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000040008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_compound_dml_trigger_in_create_trigger2177( FOLLOW_compound_dml_trigger_in_create_trigger2177_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_non_dml_trigger_in_create_trigger2188_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000040008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_non_dml_trigger_in_create_trigger2188( FOLLOW_non_dml_trigger_in_create_trigger2188_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_follows_clause_in_create_trigger2200_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000040008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_follows_clause_in_create_trigger2200( FOLLOW_trigger_follows_clause_in_create_trigger2200_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_enable_key_in_create_trigger2208_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000040008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_enable_key_in_create_trigger2208( FOLLOW_enable_key_in_create_trigger2208_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_disable_key_in_create_trigger2210_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000040008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_disable_key_in_create_trigger2210( FOLLOW_disable_key_in_create_trigger2210_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_when_clause_in_create_trigger2218_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_when_clause_in_create_trigger2218( FOLLOW_trigger_when_clause_in_create_trigger2218_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_body_in_create_trigger2226_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_body_in_create_trigger2226( FOLLOW_trigger_body_in_create_trigger2226_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_create_trigger2228_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_create_trigger2228( FOLLOW_SEMICOLON_in_create_trigger2228_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_follows_key_in_trigger_follows_clause2248_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_follows_key_in_trigger_follows_clause2248( FOLLOW_follows_key_in_trigger_follows_clause2248_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_name_in_trigger_follows_clause2250_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_name_in_trigger_follows_clause2250( FOLLOW_trigger_name_in_trigger_follows_clause2250_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_trigger_follows_clause2253_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_trigger_follows_clause2253( FOLLOW_COMMA_in_trigger_follows_clause2253_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_name_in_trigger_follows_clause2255_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_name_in_trigger_follows_clause2255( FOLLOW_trigger_name_in_trigger_follows_clause2255_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_trigger_when_clause2277_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_when_key_in_trigger_when_clause2277( FOLLOW_when_key_in_trigger_when_clause2277_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_trigger_when_clause2279_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_trigger_when_clause2279( FOLLOW_LEFT_PAREN_in_trigger_when_clause2279_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_trigger_when_clause2281_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_condition_in_trigger_when_clause2281( FOLLOW_condition_in_trigger_when_clause2281_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_trigger_when_clause2283_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_trigger_when_clause2283( FOLLOW_RIGHT_PAREN_in_trigger_when_clause2283_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_before_key_in_simple_dml_trigger2305_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020001000000000), ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_before_key_in_simple_dml_trigger2305( FOLLOW_before_key_in_simple_dml_trigger2305_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_after_key_in_simple_dml_trigger2307_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020001000000000), ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_after_key_in_simple_dml_trigger2307( FOLLOW_after_key_in_simple_dml_trigger2307_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_instead_key_in_simple_dml_trigger2309_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1000000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_instead_key_in_simple_dml_trigger2309( FOLLOW_instead_key_in_simple_dml_trigger2309_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_of_key_in_simple_dml_trigger2311_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020001000000000), ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_of_key_in_simple_dml_trigger2311( FOLLOW_of_key_in_simple_dml_trigger2311_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_dml_event_clause_in_simple_dml_trigger2314_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000400000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_dml_event_clause_in_simple_dml_trigger2314( FOLLOW_dml_event_clause_in_simple_dml_trigger2314_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_referencing_clause_in_simple_dml_trigger2316_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000400000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_referencing_clause_in_simple_dml_trigger2316( FOLLOW_referencing_clause_in_simple_dml_trigger2316_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_for_each_row_in_simple_dml_trigger2319_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_for_each_row_in_simple_dml_trigger2319( FOLLOW_for_each_row_in_simple_dml_trigger2319_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_for_key_in_for_each_row2340_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_for_key_in_for_each_row2340( FOLLOW_for_key_in_for_each_row2340_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_each_key_in_for_each_row2342_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_each_key_in_for_each_row2342( FOLLOW_each_key_in_for_each_row2342_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_row_key_in_for_each_row2344_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_row_key_in_for_each_row2344( FOLLOW_row_key_in_for_each_row2344_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_for_key_in_compound_dml_trigger2364_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020001000000000), ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_for_key_in_compound_dml_trigger2364( FOLLOW_for_key_in_compound_dml_trigger2364_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_dml_event_clause_in_compound_dml_trigger2366_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_dml_event_clause_in_compound_dml_trigger2366( FOLLOW_dml_event_clause_in_compound_dml_trigger2366_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_referencing_clause_in_compound_dml_trigger2368_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_referencing_clause_in_compound_dml_trigger2368( FOLLOW_referencing_clause_in_compound_dml_trigger2368_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_before_key_in_non_dml_trigger2390_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002008040080400), ANTLR_UINT64_LIT(0x0000000000000020) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_before_key_in_non_dml_trigger2390( FOLLOW_before_key_in_non_dml_trigger2390_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_after_key_in_non_dml_trigger2392_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002008040080400), ANTLR_UINT64_LIT(0x0000000000000020) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_after_key_in_non_dml_trigger2392( FOLLOW_after_key_in_non_dml_trigger2392_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_non_dml_event_in_non_dml_trigger2395_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0xA000000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_non_dml_event_in_non_dml_trigger2395( FOLLOW_non_dml_event_in_non_dml_trigger2395_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_or_key_in_non_dml_trigger2398_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0002008040080400), ANTLR_UINT64_LIT(0x0000000000000020) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_or_key_in_non_dml_trigger2398( FOLLOW_or_key_in_non_dml_trigger2398_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_non_dml_event_in_non_dml_trigger2400_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0xA000000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_non_dml_event_in_non_dml_trigger2400( FOLLOW_non_dml_event_in_non_dml_trigger2400_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_on_key_in_non_dml_trigger2412_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_on_key_in_non_dml_trigger2412( FOLLOW_on_key_in_non_dml_trigger2412_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_database_key_in_non_dml_trigger2415_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_database_key_in_non_dml_trigger2415( FOLLOW_database_key_in_non_dml_trigger2415_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_schema_name_in_non_dml_trigger2420_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_schema_name_in_non_dml_trigger2420( FOLLOW_schema_name_in_non_dml_trigger2420_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_non_dml_trigger2422_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_non_dml_trigger2422( FOLLOW_PERIOD_in_non_dml_trigger2422_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_schema_key_in_non_dml_trigger2426_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_schema_key_in_non_dml_trigger2426( FOLLOW_schema_key_in_non_dml_trigger2426_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_compound_trigger_block_in_trigger_body2455_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_compound_trigger_block_in_trigger_body2455( FOLLOW_compound_trigger_block_in_trigger_body2455_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_call_key_in_trigger_body2473_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_call_key_in_trigger_body2473( FOLLOW_call_key_in_trigger_body2473_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_routine_clause_in_trigger_body2475_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_routine_clause_in_trigger_body2475( FOLLOW_routine_clause_in_trigger_body2475_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_block_in_trigger_body2487_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_block_in_trigger_body2487( FOLLOW_trigger_block_in_trigger_body2487_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_routine_name_in_routine_clause2507_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_routine_name_in_routine_clause2507( FOLLOW_routine_name_in_routine_clause2507_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_argument_in_routine_clause2509_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_function_argument_in_routine_clause2509( FOLLOW_function_argument_in_routine_clause2509_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_compound_key_in_compound_trigger_block2530_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_compound_key_in_compound_trigger_block2530( FOLLOW_compound_key_in_compound_trigger_block2530_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_key_in_compound_trigger_block2532_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000140000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_key_in_compound_trigger_block2532( FOLLOW_trigger_key_in_compound_trigger_block2532_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_declare_spec_in_compound_trigger_block2534_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000140000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_declare_spec_in_compound_trigger_block2534( FOLLOW_declare_spec_in_compound_trigger_block2534_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_timing_point_section_in_compound_trigger_block2537_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_timing_point_section_in_compound_trigger_block2537( FOLLOW_timing_point_section_in_compound_trigger_block2537_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_end_key_in_compound_trigger_block2540_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_end_key_in_compound_trigger_block2540( FOLLOW_end_key_in_compound_trigger_block2540_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_name_in_compound_trigger_block2542_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_name_in_compound_trigger_block2542( FOLLOW_trigger_name_in_compound_trigger_block2542_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_before_key_in_timing_point_section2572_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_before_key_in_timing_point_section2572( FOLLOW_before_key_in_timing_point_section2572_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_statement_key_in_timing_point_section2574_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_statement_key_in_timing_point_section2574( FOLLOW_statement_key_in_timing_point_section2574_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_timing_point_section2576_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_timing_point_section2576( FOLLOW_is_key_in_timing_point_section2576_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_block_in_timing_point_section2578_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_block_in_timing_point_section2578( FOLLOW_trigger_block_in_timing_point_section2578_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_before_key_in_timing_point_section2580_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_before_key_in_timing_point_section2580( FOLLOW_before_key_in_timing_point_section2580_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_statement_key_in_timing_point_section2582_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_statement_key_in_timing_point_section2582( FOLLOW_statement_key_in_timing_point_section2582_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_timing_point_section2584_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_timing_point_section2584( FOLLOW_SEMICOLON_in_timing_point_section2584_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_before_key_in_timing_point_section2597_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_before_key_in_timing_point_section2597( FOLLOW_before_key_in_timing_point_section2597_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_each_key_in_timing_point_section2599_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_each_key_in_timing_point_section2599( FOLLOW_each_key_in_timing_point_section2599_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_row_key_in_timing_point_section2601_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_row_key_in_timing_point_section2601( FOLLOW_row_key_in_timing_point_section2601_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_timing_point_section2603_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_timing_point_section2603( FOLLOW_is_key_in_timing_point_section2603_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_block_in_timing_point_section2605_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_block_in_timing_point_section2605( FOLLOW_trigger_block_in_timing_point_section2605_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_before_key_in_timing_point_section2607_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_before_key_in_timing_point_section2607( FOLLOW_before_key_in_timing_point_section2607_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_each_key_in_timing_point_section2609_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_each_key_in_timing_point_section2609( FOLLOW_each_key_in_timing_point_section2609_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_row_key_in_timing_point_section2611_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_row_key_in_timing_point_section2611( FOLLOW_row_key_in_timing_point_section2611_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_timing_point_section2613_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_timing_point_section2613( FOLLOW_SEMICOLON_in_timing_point_section2613_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_after_key_in_timing_point_section2626_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_after_key_in_timing_point_section2626( FOLLOW_after_key_in_timing_point_section2626_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_statement_key_in_timing_point_section2628_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_statement_key_in_timing_point_section2628( FOLLOW_statement_key_in_timing_point_section2628_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_timing_point_section2630_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_timing_point_section2630( FOLLOW_is_key_in_timing_point_section2630_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_block_in_timing_point_section2632_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_block_in_timing_point_section2632( FOLLOW_trigger_block_in_timing_point_section2632_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_after_key_in_timing_point_section2634_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_after_key_in_timing_point_section2634( FOLLOW_after_key_in_timing_point_section2634_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_statement_key_in_timing_point_section2636_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_statement_key_in_timing_point_section2636( FOLLOW_statement_key_in_timing_point_section2636_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_timing_point_section2638_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_timing_point_section2638( FOLLOW_SEMICOLON_in_timing_point_section2638_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_after_key_in_timing_point_section2651_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_after_key_in_timing_point_section2651( FOLLOW_after_key_in_timing_point_section2651_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_each_key_in_timing_point_section2653_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_each_key_in_timing_point_section2653( FOLLOW_each_key_in_timing_point_section2653_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_row_key_in_timing_point_section2655_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_row_key_in_timing_point_section2655( FOLLOW_row_key_in_timing_point_section2655_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_timing_point_section2657_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_timing_point_section2657( FOLLOW_is_key_in_timing_point_section2657_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_block_in_timing_point_section2659_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_block_in_timing_point_section2659( FOLLOW_trigger_block_in_timing_point_section2659_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_after_key_in_timing_point_section2661_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_after_key_in_timing_point_section2661( FOLLOW_after_key_in_timing_point_section2661_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_each_key_in_timing_point_section2663_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_each_key_in_timing_point_section2663( FOLLOW_each_key_in_timing_point_section2663_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_row_key_in_timing_point_section2665_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_row_key_in_timing_point_section2665( FOLLOW_row_key_in_timing_point_section2665_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_timing_point_section2667_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_timing_point_section2667( FOLLOW_SEMICOLON_in_timing_point_section2667_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_key_in_non_dml_event2687_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_key_in_non_dml_event2687( FOLLOW_alter_key_in_non_dml_event2687_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_analyze_key_in_non_dml_event2698_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_analyze_key_in_non_dml_event2698( FOLLOW_analyze_key_in_non_dml_event2698_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_associate_key_in_non_dml_event2709_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_associate_key_in_non_dml_event2709( FOLLOW_associate_key_in_non_dml_event2709_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_statistics_key_in_non_dml_event2711_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_statistics_key_in_non_dml_event2711( FOLLOW_statistics_key_in_non_dml_event2711_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_audit_key_in_non_dml_event2722_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_audit_key_in_non_dml_event2722( FOLLOW_audit_key_in_non_dml_event2722_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_comment_key_in_non_dml_event2733_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_comment_key_in_non_dml_event2733( FOLLOW_comment_key_in_non_dml_event2733_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_key_in_non_dml_event2744_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_key_in_non_dml_event2744( FOLLOW_create_key_in_non_dml_event2744_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_disassociate_key_in_non_dml_event2755_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_disassociate_key_in_non_dml_event2755( FOLLOW_disassociate_key_in_non_dml_event2755_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_statistics_key_in_non_dml_event2757_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_statistics_key_in_non_dml_event2757( FOLLOW_statistics_key_in_non_dml_event2757_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_key_in_non_dml_event2768_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_key_in_non_dml_event2768( FOLLOW_drop_key_in_non_dml_event2768_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_grant_key_in_non_dml_event2779_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_grant_key_in_non_dml_event2779( FOLLOW_grant_key_in_non_dml_event2779_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_noaudit_key_in_non_dml_event2790_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_noaudit_key_in_non_dml_event2790( FOLLOW_noaudit_key_in_non_dml_event2790_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_rename_key_in_non_dml_event2801_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_rename_key_in_non_dml_event2801( FOLLOW_rename_key_in_non_dml_event2801_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_revoke_key_in_non_dml_event2812_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_revoke_key_in_non_dml_event2812( FOLLOW_revoke_key_in_non_dml_event2812_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_truncate_key_in_non_dml_event2823_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_truncate_key_in_non_dml_event2823( FOLLOW_truncate_key_in_non_dml_event2823_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_ddl_key_in_non_dml_event2834_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_ddl_key_in_non_dml_event2834( FOLLOW_ddl_key_in_non_dml_event2834_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_startup_key_in_non_dml_event2845_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_startup_key_in_non_dml_event2845( FOLLOW_startup_key_in_non_dml_event2845_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_shutdown_key_in_non_dml_event2856_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_shutdown_key_in_non_dml_event2856( FOLLOW_shutdown_key_in_non_dml_event2856_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_db_role_change_key_in_non_dml_event2867_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_db_role_change_key_in_non_dml_event2867( FOLLOW_db_role_change_key_in_non_dml_event2867_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_logon_key_in_non_dml_event2878_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_logon_key_in_non_dml_event2878( FOLLOW_logon_key_in_non_dml_event2878_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_logoff_key_in_non_dml_event2889_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_logoff_key_in_non_dml_event2889( FOLLOW_logoff_key_in_non_dml_event2889_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_servererror_key_in_non_dml_event2900_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_servererror_key_in_non_dml_event2900( FOLLOW_servererror_key_in_non_dml_event2900_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_suspend_key_in_non_dml_event2911_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_suspend_key_in_non_dml_event2911( FOLLOW_suspend_key_in_non_dml_event2911_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_database_key_in_non_dml_event2922_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_database_key_in_non_dml_event2922( FOLLOW_database_key_in_non_dml_event2922_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_schema_key_in_non_dml_event2933_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_schema_key_in_non_dml_event2933( FOLLOW_schema_key_in_non_dml_event2933_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_follows_key_in_non_dml_event2944_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_follows_key_in_non_dml_event2944( FOLLOW_follows_key_in_non_dml_event2944_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_dml_event_element_in_dml_event_clause2964_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0xA000000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_dml_event_element_in_dml_event_clause2964( FOLLOW_dml_event_element_in_dml_event_clause2964_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_or_key_in_dml_event_clause2967_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020001000000000), ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_or_key_in_dml_event_clause2967( FOLLOW_or_key_in_dml_event_clause2967_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_dml_event_element_in_dml_event_clause2969_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0xA000000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_dml_event_element_in_dml_event_clause2969( FOLLOW_dml_event_element_in_dml_event_clause2969_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_on_key_in_dml_event_clause2981_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_on_key_in_dml_event_clause2981( FOLLOW_on_key_in_dml_event_clause2981_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_dml_event_nested_clause_in_dml_event_clause2992_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_dml_event_nested_clause_in_dml_event_clause2992( FOLLOW_dml_event_nested_clause_in_dml_event_clause2992_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_dml_event_clause2995_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_dml_event_clause2995( FOLLOW_tableview_name_in_dml_event_clause2995_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_delete_key_in_dml_event_element3016_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x1000000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_delete_key_in_dml_event_element3016( FOLLOW_delete_key_in_dml_event_element3016_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_insert_key_in_dml_event_element3018_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x1000000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_insert_key_in_dml_event_element3018( FOLLOW_insert_key_in_dml_event_element3018_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_update_key_in_dml_event_element3020_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x1000000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_update_key_in_dml_event_element3020( FOLLOW_update_key_in_dml_event_element3020_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_of_key_in_dml_event_element3024_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_of_key_in_dml_event_element3024( FOLLOW_of_key_in_dml_event_element3024_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_dml_event_element3026_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_column_name_in_dml_event_element3026( FOLLOW_column_name_in_dml_event_element3026_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_dml_event_element3029_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_dml_event_element3029( FOLLOW_COMMA_in_dml_event_element3029_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_dml_event_element3031_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_column_name_in_dml_event_element3031( FOLLOW_column_name_in_dml_event_element3031_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_nested_key_in_dml_event_nested_clause3055_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000100) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_nested_key_in_dml_event_nested_clause3055( FOLLOW_nested_key_in_dml_event_nested_clause3055_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_table_key_in_dml_event_nested_clause3057_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_table_key_in_dml_event_nested_clause3057( FOLLOW_table_key_in_dml_event_nested_clause3057_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_dml_event_nested_clause3059_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1000000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_dml_event_nested_clause3059( FOLLOW_tableview_name_in_dml_event_nested_clause3059_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_of_key_in_dml_event_nested_clause3061_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_of_key_in_dml_event_nested_clause3061( FOLLOW_of_key_in_dml_event_nested_clause3061_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_referencing_key_in_referencing_clause3081_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_referencing_key_in_referencing_clause3081( FOLLOW_referencing_key_in_referencing_clause3081_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_referencing_element_in_referencing_clause3083_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_referencing_element_in_referencing_clause3083( FOLLOW_referencing_element_in_referencing_clause3083_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_new_key_in_referencing_element3106_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043000), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_new_key_in_referencing_element3106( FOLLOW_new_key_in_referencing_element3106_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_old_key_in_referencing_element3110_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043000), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_old_key_in_referencing_element3110( FOLLOW_old_key_in_referencing_element3110_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_parent_key_in_referencing_element3114_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043000), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_parent_key_in_referencing_element3114( FOLLOW_parent_key_in_referencing_element3114_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_referencing_element3118_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_column_alias_in_referencing_element3118( FOLLOW_column_alias_in_referencing_element3118_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_key_in_drop_type3143_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_key_in_drop_type3143( FOLLOW_drop_key_in_drop_type3143_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_key_in_drop_type3145_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_key_in_drop_type3145( FOLLOW_type_key_in_drop_type3145_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_body_key_in_drop_type3147_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_body_key_in_drop_type3147( FOLLOW_body_key_in_drop_type3147_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_name_in_drop_type3150_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_name_in_drop_type3150( FOLLOW_type_name_in_drop_type3150_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_force_key_in_drop_type3153_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_force_key_in_drop_type3153( FOLLOW_force_key_in_drop_type3153_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_validate_key_in_drop_type3155_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_validate_key_in_drop_type3155( FOLLOW_validate_key_in_drop_type3155_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_drop_type3167_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_drop_type3167( FOLLOW_SEMICOLON_in_drop_type3167_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_key_in_alter_type3187_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_key_in_alter_type3187( FOLLOW_alter_key_in_alter_type3187_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_key_in_alter_type3189_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_key_in_alter_type3189( FOLLOW_type_key_in_alter_type3189_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_name_in_alter_type3191_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0400008000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_name_in_alter_type3191( FOLLOW_type_name_in_alter_type3191_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_compile_type_clause_in_alter_type3202_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_compile_type_clause_in_alter_type3202( FOLLOW_compile_type_clause_in_alter_type3202_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_replace_type_clause_in_alter_type3213_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_replace_type_clause_in_alter_type3213( FOLLOW_replace_type_clause_in_alter_type3213_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_attribute_definition_in_alter_type3226_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_attribute_definition_in_alter_type3226( FOLLOW_alter_attribute_definition_in_alter_type3226_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_method_spec_in_alter_type3237_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_method_spec_in_alter_type3237( FOLLOW_alter_method_spec_in_alter_type3237_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_collection_clauses_in_alter_type3248_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_collection_clauses_in_alter_type3248( FOLLOW_alter_collection_clauses_in_alter_type3248_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_modifier_clause_in_alter_type3259_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_modifier_clause_in_alter_type3259( FOLLOW_modifier_clause_in_alter_type3259_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_dependent_handling_clause_in_alter_type3275_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_dependent_handling_clause_in_alter_type3275( FOLLOW_dependent_handling_clause_in_alter_type3275_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_alter_type3286_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_alter_type3286( FOLLOW_SEMICOLON_in_alter_type3286_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_compile_key_in_compile_type_clause3307_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_compile_key_in_compile_type_clause3307( FOLLOW_compile_key_in_compile_type_clause3307_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_debug_key_in_compile_type_clause3309_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_debug_key_in_compile_type_clause3309( FOLLOW_debug_key_in_compile_type_clause3309_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_specification_key_in_compile_type_clause3313_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_specification_key_in_compile_type_clause3313( FOLLOW_specification_key_in_compile_type_clause3313_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_body_key_in_compile_type_clause3315_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_body_key_in_compile_type_clause3315( FOLLOW_body_key_in_compile_type_clause3315_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_compiler_parameters_clause_in_compile_type_clause3319_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_compiler_parameters_clause_in_compile_type_clause3319( FOLLOW_compiler_parameters_clause_in_compile_type_clause3319_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_reuse_key_in_compile_type_clause3323_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_reuse_key_in_compile_type_clause3323( FOLLOW_reuse_key_in_compile_type_clause3323_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_settings_key_in_compile_type_clause3325_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_settings_key_in_compile_type_clause3325( FOLLOW_settings_key_in_compile_type_clause3325_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_replace_key_in_replace_type_clause3347_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_replace_key_in_replace_type_clause3347( FOLLOW_replace_key_in_replace_type_clause3347_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_invoker_rights_clause_in_replace_type_clause3349_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000400000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_invoker_rights_clause_in_replace_type_clause3349( FOLLOW_invoker_rights_clause_in_replace_type_clause3349_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_replace_type_clause3352_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_as_key_in_replace_type_clause3352( FOLLOW_as_key_in_replace_type_clause3352_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_object_key_in_replace_type_clause3354_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_object_key_in_replace_type_clause3354( FOLLOW_object_key_in_replace_type_clause3354_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_replace_type_clause3364_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0400000000000400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_replace_type_clause3364( FOLLOW_LEFT_PAREN_in_replace_type_clause3364_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_object_member_spec_in_replace_type_clause3366_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_object_member_spec_in_replace_type_clause3366( FOLLOW_object_member_spec_in_replace_type_clause3366_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_replace_type_clause3369_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0400000000000400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_replace_type_clause3369( FOLLOW_COMMA_in_replace_type_clause3369_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_object_member_spec_in_replace_type_clause3371_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_object_member_spec_in_replace_type_clause3371( FOLLOW_object_member_spec_in_replace_type_clause3371_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_replace_type_clause3375_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_replace_type_clause3375( FOLLOW_RIGHT_PAREN_in_replace_type_clause3375_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_method_element_in_alter_method_spec3396_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_method_element_in_alter_method_spec3396( FOLLOW_alter_method_element_in_alter_method_spec3396_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_alter_method_spec3399_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000008000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_alter_method_spec3399( FOLLOW_COMMA_in_alter_method_spec3399_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_method_element_in_alter_method_spec3401_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_method_element_in_alter_method_spec3401( FOLLOW_alter_method_element_in_alter_method_spec3401_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_add_key_in_alter_method_element3424_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_add_key_in_alter_method_element3424( FOLLOW_add_key_in_alter_method_element3424_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_key_in_alter_method_element3426_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_key_in_alter_method_element3426( FOLLOW_drop_key_in_alter_method_element3426_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_map_order_function_spec_in_alter_method_element3430_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_map_order_function_spec_in_alter_method_element3430( FOLLOW_map_order_function_spec_in_alter_method_element3430_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_subprogram_spec_in_alter_method_element3432_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_subprogram_spec_in_alter_method_element3432( FOLLOW_subprogram_spec_in_alter_method_element3432_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_add_key_in_alter_attribute_definition3454_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_add_key_in_alter_attribute_definition3454( FOLLOW_add_key_in_alter_attribute_definition3454_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_modify_key_in_alter_attribute_definition3456_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_modify_key_in_alter_attribute_definition3456( FOLLOW_modify_key_in_alter_attribute_definition3456_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_key_in_alter_attribute_definition3458_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_key_in_alter_attribute_definition3458( FOLLOW_drop_key_in_alter_attribute_definition3458_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_attribute_key_in_alter_attribute_definition3461_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_attribute_key_in_alter_attribute_definition3461( FOLLOW_attribute_key_in_alter_attribute_definition3461_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_attribute_definition_in_alter_attribute_definition3476_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_attribute_definition_in_alter_attribute_definition3476( FOLLOW_attribute_definition_in_alter_attribute_definition3476_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_alter_attribute_definition3491_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_alter_attribute_definition3491( FOLLOW_LEFT_PAREN_in_alter_attribute_definition3491_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_attribute_definition_in_alter_attribute_definition3493_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_attribute_definition_in_alter_attribute_definition3493( FOLLOW_attribute_definition_in_alter_attribute_definition3493_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_alter_attribute_definition3496_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_alter_attribute_definition3496( FOLLOW_COMMA_in_alter_attribute_definition3496_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_attribute_definition_in_alter_attribute_definition3498_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_attribute_definition_in_alter_attribute_definition3498( FOLLOW_attribute_definition_in_alter_attribute_definition3498_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_alter_attribute_definition3502_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_alter_attribute_definition3502( FOLLOW_RIGHT_PAREN_in_alter_attribute_definition3502_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_attribute_name_in_attribute_definition3532_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040002), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_attribute_name_in_attribute_definition3532( FOLLOW_attribute_name_in_attribute_definition3532_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_attribute_definition3534_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_attribute_definition3534( FOLLOW_type_spec_in_attribute_definition3534_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_modify_key_in_alter_collection_clauses3555_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_modify_key_in_alter_collection_clauses3555( FOLLOW_modify_key_in_alter_collection_clauses3555_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_limit_key_in_alter_collection_clauses3566_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_limit_key_in_alter_collection_clauses3566( FOLLOW_limit_key_in_alter_collection_clauses3566_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_alter_collection_clauses3568_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_alter_collection_clauses3568( FOLLOW_expression_in_alter_collection_clauses3568_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_element_key_in_alter_collection_clauses3579_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_element_key_in_alter_collection_clauses3579( FOLLOW_element_key_in_alter_collection_clauses3579_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_key_in_alter_collection_clauses3581_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_key_in_alter_collection_clauses3581( FOLLOW_type_key_in_alter_collection_clauses3581_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_alter_collection_clauses3583_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_alter_collection_clauses3583( FOLLOW_type_spec_in_alter_collection_clauses3583_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_invalidate_key_in_dependent_handling_clause3609_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_invalidate_key_in_dependent_handling_clause3609( FOLLOW_invalidate_key_in_dependent_handling_clause3609_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_cascade_key_in_dependent_handling_clause3620_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0400000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_cascade_key_in_dependent_handling_clause3620( FOLLOW_cascade_key_in_dependent_handling_clause3620_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_convert_key_in_dependent_handling_clause3635_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_convert_key_in_dependent_handling_clause3635( FOLLOW_convert_key_in_dependent_handling_clause3635_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_to_key_in_dependent_handling_clause3637_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_to_key_in_dependent_handling_clause3637( FOLLOW_to_key_in_dependent_handling_clause3637_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_substitutable_key_in_dependent_handling_clause3639_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_substitutable_key_in_dependent_handling_clause3639( FOLLOW_substitutable_key_in_dependent_handling_clause3639_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_not_key_in_dependent_handling_clause3654_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_not_key_in_dependent_handling_clause3654( FOLLOW_not_key_in_dependent_handling_clause3654_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_including_key_in_dependent_handling_clause3657_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000100) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_including_key_in_dependent_handling_clause3657( FOLLOW_including_key_in_dependent_handling_clause3657_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_table_key_in_dependent_handling_clause3659_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_table_key_in_dependent_handling_clause3659( FOLLOW_table_key_in_dependent_handling_clause3659_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_data_key_in_dependent_handling_clause3661_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_data_key_in_dependent_handling_clause3661( FOLLOW_data_key_in_dependent_handling_clause3661_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_dependent_exceptions_part_in_dependent_handling_clause3682_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_dependent_exceptions_part_in_dependent_handling_clause3682( FOLLOW_dependent_exceptions_part_in_dependent_handling_clause3682_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_force_key_in_dependent_exceptions_part3703_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_force_key_in_dependent_exceptions_part3703( FOLLOW_force_key_in_dependent_exceptions_part3703_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exceptions_key_in_dependent_exceptions_part3706_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exceptions_key_in_dependent_exceptions_part3706( FOLLOW_exceptions_key_in_dependent_exceptions_part3706_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_into_key_in_dependent_exceptions_part3708_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_into_key_in_dependent_exceptions_part3708( FOLLOW_into_key_in_dependent_exceptions_part3708_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_dependent_exceptions_part3710_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_dependent_exceptions_part3710( FOLLOW_tableview_name_in_dependent_exceptions_part3710_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_key_in_create_type3732_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x8000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_key_in_create_type3732( FOLLOW_create_key_in_create_type3732_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_or_key_in_create_type3735_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_or_key_in_create_type3735( FOLLOW_or_key_in_create_type3735_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_replace_key_in_create_type3737_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_replace_key_in_create_type3737( FOLLOW_replace_key_in_create_type3737_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_key_in_create_type3741_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_key_in_create_type3741( FOLLOW_type_key_in_create_type3741_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_definition_in_create_type3753_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_definition_in_create_type3753( FOLLOW_type_definition_in_create_type3753_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_body_in_create_type3757_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_body_in_create_type3757( FOLLOW_type_body_in_create_type3757_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_create_type3768_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_create_type3768( FOLLOW_SEMICOLON_in_create_type3768_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_name_in_type_definition3789_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0100000000400400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_name_in_type_definition3789( FOLLOW_type_name_in_type_definition3789_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_oid_key_in_type_definition3801_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_oid_key_in_type_definition3801( FOLLOW_oid_key_in_type_definition3801_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_CHAR_STRING_in_type_definition3803_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0100000000400400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_CHAR_STRING_in_type_definition3803( FOLLOW_CHAR_STRING_in_type_definition3803_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_object_type_def_in_type_definition3815_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_object_type_def_in_type_definition3815( FOLLOW_object_type_def_in_type_definition3815_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_invoker_rights_clause_in_object_type_def3836_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000400400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_invoker_rights_clause_in_object_type_def3836( FOLLOW_invoker_rights_clause_in_object_type_def3836_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_object_as_part_in_object_type_def3848_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002), ANTLR_UINT64_LIT(0x0400000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_object_as_part_in_object_type_def3848( FOLLOW_object_as_part_in_object_type_def3848_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_object_under_part_in_object_type_def3859_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002), ANTLR_UINT64_LIT(0x0400000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_object_under_part_in_object_type_def3859( FOLLOW_object_under_part_in_object_type_def3859_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_sqlj_object_type_in_object_type_def3875_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002), ANTLR_UINT64_LIT(0x0400000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_sqlj_object_type_in_object_type_def3875( FOLLOW_sqlj_object_type_in_object_type_def3875_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_object_type_def3887_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0400000000000400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_object_type_def3887( FOLLOW_LEFT_PAREN_in_object_type_def3887_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_object_member_spec_in_object_type_def3889_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_object_member_spec_in_object_type_def3889( FOLLOW_object_member_spec_in_object_type_def3889_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_object_type_def3892_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0400000000000400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_object_type_def3892( FOLLOW_COMMA_in_object_type_def3892_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_object_member_spec_in_object_type_def3894_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_object_member_spec_in_object_type_def3894( FOLLOW_object_member_spec_in_object_type_def3894_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_object_type_def3898_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0400000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_object_type_def3898( FOLLOW_RIGHT_PAREN_in_object_type_def3898_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_modifier_clause_in_object_type_def3910_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0400000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_modifier_clause_in_object_type_def3910( FOLLOW_modifier_clause_in_object_type_def3910_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_object_as_part3932_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000100) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_object_as_part3932( FOLLOW_is_key_in_object_as_part3932_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_object_as_part3934_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000100) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_as_key_in_object_as_part3934( FOLLOW_as_key_in_object_as_part3934_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_object_key_in_object_as_part3938_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_object_key_in_object_as_part3938( FOLLOW_object_key_in_object_as_part3938_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_varray_type_def_in_object_as_part3940_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_varray_type_def_in_object_as_part3940( FOLLOW_varray_type_def_in_object_as_part3940_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_nested_table_type_def_in_object_as_part3942_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_nested_table_type_def_in_object_as_part3942( FOLLOW_nested_table_type_def_in_object_as_part3942_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_under_key_in_object_under_part3963_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_under_key_in_object_under_part3963( FOLLOW_under_key_in_object_under_part3963_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_object_under_part3965_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_object_under_part3965( FOLLOW_type_spec_in_object_under_part3965_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_table_key_in_nested_table_type_def3985_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1000000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_table_key_in_nested_table_type_def3985( FOLLOW_table_key_in_nested_table_type_def3985_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_of_key_in_nested_table_type_def3987_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_of_key_in_nested_table_type_def3987( FOLLOW_of_key_in_nested_table_type_def3987_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_nested_table_type_def3989_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0400000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_nested_table_type_def3989( FOLLOW_type_spec_in_nested_table_type_def3989_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_not_key_in_nested_table_type_def4000_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0800000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_not_key_in_nested_table_type_def4000( FOLLOW_not_key_in_nested_table_type_def4000_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_null_key_in_nested_table_type_def4002_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_null_key_in_nested_table_type_def4002( FOLLOW_null_key_in_nested_table_type_def4002_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_external_key_in_sqlj_object_type4024_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_external_key_in_sqlj_object_type4024( FOLLOW_external_key_in_sqlj_object_type4024_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_name_key_in_sqlj_object_type4026_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_name_key_in_sqlj_object_type4026( FOLLOW_name_key_in_sqlj_object_type4026_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_sqlj_object_type4028_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_sqlj_object_type4028( FOLLOW_expression_in_sqlj_object_type4028_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_language_key_in_sqlj_object_type4030_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_language_key_in_sqlj_object_type4030( FOLLOW_language_key_in_sqlj_object_type4030_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_java_key_in_sqlj_object_type4032_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_java_key_in_sqlj_object_type4032( FOLLOW_java_key_in_sqlj_object_type4032_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_using_key_in_sqlj_object_type4034_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_using_key_in_sqlj_object_type4034( FOLLOW_using_key_in_sqlj_object_type4034_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_sqldata_key_in_sqlj_object_type4037_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_sqldata_key_in_sqlj_object_type4037( FOLLOW_sqldata_key_in_sqlj_object_type4037_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_customdatum_key_in_sqlj_object_type4039_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_customdatum_key_in_sqlj_object_type4039( FOLLOW_customdatum_key_in_sqlj_object_type4039_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_oradata_key_in_sqlj_object_type4041_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_oradata_key_in_sqlj_object_type4041( FOLLOW_oradata_key_in_sqlj_object_type4041_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_body_key_in_type_body4062_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_body_key_in_type_body4062( FOLLOW_body_key_in_type_body4062_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_name_in_type_body4064_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000400000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_name_in_type_body4064( FOLLOW_type_name_in_type_body4064_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_type_body4075_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_type_body4075( FOLLOW_is_key_in_type_body4075_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_type_body4077_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_as_key_in_type_body4077( FOLLOW_as_key_in_type_body4077_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_body_elements_in_type_body4080_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_body_elements_in_type_body4080( FOLLOW_type_body_elements_in_type_body4080_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_type_body4083_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_type_body4083( FOLLOW_COMMA_in_type_body4083_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_body_elements_in_type_body4085_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_body_elements_in_type_body4085( FOLLOW_type_body_elements_in_type_body4085_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_end_key_in_type_body4097_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_end_key_in_type_body4097( FOLLOW_end_key_in_type_body4097_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_map_order_func_declaration_in_type_body_elements4117_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_map_order_func_declaration_in_type_body_elements4117( FOLLOW_map_order_func_declaration_in_type_body_elements4117_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_subprog_decl_in_type_in_type_body_elements4128_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_subprog_decl_in_type_in_type_body_elements4128( FOLLOW_subprog_decl_in_type_in_type_body_elements4128_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_map_key_in_map_order_func_declaration4149_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_map_key_in_map_order_func_declaration4149( FOLLOW_map_key_in_map_order_func_declaration4149_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_order_key_in_map_order_func_declaration4151_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_order_key_in_map_order_func_declaration4151( FOLLOW_order_key_in_map_order_func_declaration4151_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_member_key_in_map_order_func_declaration4154_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_member_key_in_map_order_func_declaration4154( FOLLOW_member_key_in_map_order_func_declaration4154_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_func_decl_in_type_in_map_order_func_declaration4156_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_func_decl_in_type_in_map_order_func_declaration4156( FOLLOW_func_decl_in_type_in_map_order_func_declaration4156_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_member_key_in_subprog_decl_in_type4177_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_member_key_in_subprog_decl_in_type4177( FOLLOW_member_key_in_subprog_decl_in_type4177_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_static_key_in_subprog_decl_in_type4179_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_static_key_in_subprog_decl_in_type4179( FOLLOW_static_key_in_subprog_decl_in_type4179_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_proc_decl_in_type_in_subprog_decl_in_type4191_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_proc_decl_in_type_in_subprog_decl_in_type4191( FOLLOW_proc_decl_in_type_in_subprog_decl_in_type4191_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_func_decl_in_type_in_subprog_decl_in_type4202_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_func_decl_in_type_in_subprog_decl_in_type4202( FOLLOW_func_decl_in_type_in_subprog_decl_in_type4202_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_constructor_declaration_in_subprog_decl_in_type4213_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_constructor_declaration_in_subprog_decl_in_type4213( FOLLOW_constructor_declaration_in_subprog_decl_in_type4213_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_procedure_key_in_proc_decl_in_type4234_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_procedure_key_in_proc_decl_in_type4234( FOLLOW_procedure_key_in_proc_decl_in_type4234_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_procedure_name_in_proc_decl_in_type4236_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_procedure_name_in_proc_decl_in_type4236( FOLLOW_procedure_name_in_proc_decl_in_type4236_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_proc_decl_in_type4246_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_proc_decl_in_type4246( FOLLOW_LEFT_PAREN_in_proc_decl_in_type4246_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_elements_parameter_in_proc_decl_in_type4248_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_elements_parameter_in_proc_decl_in_type4248( FOLLOW_type_elements_parameter_in_proc_decl_in_type4248_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_proc_decl_in_type4251_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_proc_decl_in_type4251( FOLLOW_COMMA_in_proc_decl_in_type4251_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_elements_parameter_in_proc_decl_in_type4253_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_elements_parameter_in_proc_decl_in_type4253( FOLLOW_type_elements_parameter_in_proc_decl_in_type4253_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_proc_decl_in_type4257_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000400000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_proc_decl_in_type4257( FOLLOW_RIGHT_PAREN_in_proc_decl_in_type4257_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_proc_decl_in_type4268_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_proc_decl_in_type4268( FOLLOW_is_key_in_proc_decl_in_type4268_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_proc_decl_in_type4270_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_as_key_in_proc_decl_in_type4270( FOLLOW_as_key_in_proc_decl_in_type4270_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_call_spec_in_proc_decl_in_type4287_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_call_spec_in_proc_decl_in_type4287( FOLLOW_call_spec_in_proc_decl_in_type4287_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_declare_key_in_proc_decl_in_type4289_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000141000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_declare_key_in_proc_decl_in_type4289( FOLLOW_declare_key_in_proc_decl_in_type4289_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_declare_spec_in_proc_decl_in_type4292_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000141000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_declare_spec_in_proc_decl_in_type4292( FOLLOW_declare_spec_in_proc_decl_in_type4292_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_body_in_proc_decl_in_type4295_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_body_in_proc_decl_in_type4295( FOLLOW_body_in_proc_decl_in_type4295_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_proc_decl_in_type4297_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_proc_decl_in_type4297( FOLLOW_SEMICOLON_in_proc_decl_in_type4297_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_key_in_func_decl_in_type4318_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_function_key_in_func_decl_in_type4318( FOLLOW_function_key_in_func_decl_in_type4318_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_name_in_func_decl_in_type4320_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_function_name_in_func_decl_in_type4320( FOLLOW_function_name_in_func_decl_in_type4320_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_func_decl_in_type4332_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_func_decl_in_type4332( FOLLOW_LEFT_PAREN_in_func_decl_in_type4332_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_elements_parameter_in_func_decl_in_type4334_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_elements_parameter_in_func_decl_in_type4334( FOLLOW_type_elements_parameter_in_func_decl_in_type4334_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_func_decl_in_type4337_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_func_decl_in_type4337( FOLLOW_COMMA_in_func_decl_in_type4337_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_elements_parameter_in_func_decl_in_type4339_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_elements_parameter_in_func_decl_in_type4339( FOLLOW_type_elements_parameter_in_func_decl_in_type4339_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_func_decl_in_type4343_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_func_decl_in_type4343( FOLLOW_RIGHT_PAREN_in_func_decl_in_type4343_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_return_key_in_func_decl_in_type4356_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_return_key_in_func_decl_in_type4356( FOLLOW_return_key_in_func_decl_in_type4356_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_func_decl_in_type4358_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000400000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_func_decl_in_type4358( FOLLOW_type_spec_in_func_decl_in_type4358_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_func_decl_in_type4369_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_func_decl_in_type4369( FOLLOW_is_key_in_func_decl_in_type4369_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_func_decl_in_type4371_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_as_key_in_func_decl_in_type4371( FOLLOW_as_key_in_func_decl_in_type4371_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_call_spec_in_func_decl_in_type4387_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_call_spec_in_func_decl_in_type4387( FOLLOW_call_spec_in_func_decl_in_type4387_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_declare_key_in_func_decl_in_type4390_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000141000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_declare_key_in_func_decl_in_type4390( FOLLOW_declare_key_in_func_decl_in_type4390_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_declare_spec_in_func_decl_in_type4393_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000141000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_declare_spec_in_func_decl_in_type4393( FOLLOW_declare_spec_in_func_decl_in_type4393_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_body_in_func_decl_in_type4396_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_body_in_func_decl_in_type4396( FOLLOW_body_in_func_decl_in_type4396_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_func_decl_in_type4398_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_func_decl_in_type4398( FOLLOW_SEMICOLON_in_func_decl_in_type4398_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_final_key_in_constructor_declaration4419_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_final_key_in_constructor_declaration4419( FOLLOW_final_key_in_constructor_declaration4419_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_instantiable_key_in_constructor_declaration4422_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_instantiable_key_in_constructor_declaration4422( FOLLOW_instantiable_key_in_constructor_declaration4422_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_constructor_key_in_constructor_declaration4425_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_constructor_key_in_constructor_declaration4425( FOLLOW_constructor_key_in_constructor_declaration4425_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_key_in_constructor_declaration4427_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_function_key_in_constructor_declaration4427( FOLLOW_function_key_in_constructor_declaration4427_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_constructor_declaration4429_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_constructor_declaration4429( FOLLOW_type_spec_in_constructor_declaration4429_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_constructor_declaration4440_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_constructor_declaration4440( FOLLOW_LEFT_PAREN_in_constructor_declaration4440_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_self_key_in_constructor_declaration4443_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0010000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_self_key_in_constructor_declaration4443( FOLLOW_self_key_in_constructor_declaration4443_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_constructor_declaration4445_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_in_key_in_constructor_declaration4445( FOLLOW_in_key_in_constructor_declaration4445_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_out_key_in_constructor_declaration4447_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_out_key_in_constructor_declaration4447( FOLLOW_out_key_in_constructor_declaration4447_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_constructor_declaration4449_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_constructor_declaration4449( FOLLOW_type_spec_in_constructor_declaration4449_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_constructor_declaration4451_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_constructor_declaration4451( FOLLOW_COMMA_in_constructor_declaration4451_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_elements_parameter_in_constructor_declaration4454_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_elements_parameter_in_constructor_declaration4454( FOLLOW_type_elements_parameter_in_constructor_declaration4454_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_constructor_declaration4457_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_constructor_declaration4457( FOLLOW_COMMA_in_constructor_declaration4457_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_elements_parameter_in_constructor_declaration4459_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_elements_parameter_in_constructor_declaration4459( FOLLOW_type_elements_parameter_in_constructor_declaration4459_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_constructor_declaration4464_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_constructor_declaration4464( FOLLOW_RIGHT_PAREN_in_constructor_declaration4464_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_return_key_in_constructor_declaration4476_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_return_key_in_constructor_declaration4476( FOLLOW_return_key_in_constructor_declaration4476_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_self_key_in_constructor_declaration4478_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000400000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_self_key_in_constructor_declaration4478( FOLLOW_self_key_in_constructor_declaration4478_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_constructor_declaration4480_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_as_key_in_constructor_declaration4480( FOLLOW_as_key_in_constructor_declaration4480_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_result_key_in_constructor_declaration4482_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000400000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_result_key_in_constructor_declaration4482( FOLLOW_result_key_in_constructor_declaration4482_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_constructor_declaration4494_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_constructor_declaration4494( FOLLOW_is_key_in_constructor_declaration4494_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_constructor_declaration4496_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000541000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_as_key_in_constructor_declaration4496( FOLLOW_as_key_in_constructor_declaration4496_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_call_spec_in_constructor_declaration4513_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_call_spec_in_constructor_declaration4513( FOLLOW_call_spec_in_constructor_declaration4513_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_declare_key_in_constructor_declaration4516_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000141000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_declare_key_in_constructor_declaration4516( FOLLOW_declare_key_in_constructor_declaration4516_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_declare_spec_in_constructor_declaration4519_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000141000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_declare_spec_in_constructor_declaration4519( FOLLOW_declare_spec_in_constructor_declaration4519_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_body_in_constructor_declaration4522_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_body_in_constructor_declaration4522( FOLLOW_body_in_constructor_declaration4522_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_constructor_declaration4524_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_constructor_declaration4524( FOLLOW_SEMICOLON_in_constructor_declaration4524_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_not_key_in_modifier_clause4549_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_not_key_in_modifier_clause4549( FOLLOW_not_key_in_modifier_clause4549_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_instantiable_key_in_modifier_clause4553_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_instantiable_key_in_modifier_clause4553( FOLLOW_instantiable_key_in_modifier_clause4553_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_final_key_in_modifier_clause4555_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_final_key_in_modifier_clause4555( FOLLOW_final_key_in_modifier_clause4555_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_overriding_key_in_modifier_clause4557_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_overriding_key_in_modifier_clause4557( FOLLOW_overriding_key_in_modifier_clause4557_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_id_in_object_member_spec4586_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_id_in_object_member_spec4586( FOLLOW_id_in_object_member_spec4586_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_object_member_spec4588_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_object_member_spec4588( FOLLOW_type_spec_in_object_member_spec4588_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_sqlj_object_type_attr_in_object_member_spec4590_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_sqlj_object_type_attr_in_object_member_spec4590( FOLLOW_sqlj_object_type_attr_in_object_member_spec4590_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_element_spec_in_object_member_spec4602_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_element_spec_in_object_member_spec4602( FOLLOW_element_spec_in_object_member_spec4602_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_external_key_in_sqlj_object_type_attr4622_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_external_key_in_sqlj_object_type_attr4622( FOLLOW_external_key_in_sqlj_object_type_attr4622_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_name_key_in_sqlj_object_type_attr4624_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_name_key_in_sqlj_object_type_attr4624( FOLLOW_name_key_in_sqlj_object_type_attr4624_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_sqlj_object_type_attr4626_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_sqlj_object_type_attr4626( FOLLOW_expression_in_sqlj_object_type_attr4626_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_modifier_clause_in_element_spec4646_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_modifier_clause_in_element_spec4646( FOLLOW_modifier_clause_in_element_spec4646_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_element_spec_options_in_element_spec4657_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_element_spec_options_in_element_spec4657( FOLLOW_element_spec_options_in_element_spec4657_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_element_spec4669_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_element_spec4669( FOLLOW_COMMA_in_element_spec4669_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_pragma_clause_in_element_spec4671_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_pragma_clause_in_element_spec4671( FOLLOW_pragma_clause_in_element_spec4671_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_subprogram_spec_in_element_spec_options4693_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_subprogram_spec_in_element_spec_options4693( FOLLOW_subprogram_spec_in_element_spec_options4693_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_constructor_spec_in_element_spec_options4704_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_constructor_spec_in_element_spec_options4704( FOLLOW_constructor_spec_in_element_spec_options4704_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_map_order_function_spec_in_element_spec_options4715_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_map_order_function_spec_in_element_spec_options4715( FOLLOW_map_order_function_spec_in_element_spec_options4715_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_member_key_in_subprogram_spec4736_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_member_key_in_subprogram_spec4736( FOLLOW_member_key_in_subprogram_spec4736_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_static_key_in_subprogram_spec4738_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_static_key_in_subprogram_spec4738( FOLLOW_static_key_in_subprogram_spec4738_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_procedure_spec_in_subprogram_spec4750_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_procedure_spec_in_subprogram_spec4750( FOLLOW_type_procedure_spec_in_subprogram_spec4750_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_function_spec_in_subprogram_spec4752_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_function_spec_in_subprogram_spec4752( FOLLOW_type_function_spec_in_subprogram_spec4752_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_procedure_key_in_type_procedure_spec4773_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_procedure_key_in_type_procedure_spec4773( FOLLOW_procedure_key_in_type_procedure_spec4773_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_procedure_name_in_type_procedure_spec4775_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_procedure_name_in_type_procedure_spec4775( FOLLOW_procedure_name_in_type_procedure_spec4775_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_type_procedure_spec4785_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_type_procedure_spec4785( FOLLOW_LEFT_PAREN_in_type_procedure_spec4785_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_elements_parameter_in_type_procedure_spec4787_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_elements_parameter_in_type_procedure_spec4787( FOLLOW_type_elements_parameter_in_type_procedure_spec4787_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_type_procedure_spec4790_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_type_procedure_spec4790( FOLLOW_COMMA_in_type_procedure_spec4790_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_elements_parameter_in_type_procedure_spec4792_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_elements_parameter_in_type_procedure_spec4792( FOLLOW_type_elements_parameter_in_type_procedure_spec4792_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_type_procedure_spec4796_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0100000000400000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_type_procedure_spec4796( FOLLOW_RIGHT_PAREN_in_type_procedure_spec4796_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_type_procedure_spec4808_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_type_procedure_spec4808( FOLLOW_is_key_in_type_procedure_spec4808_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_type_procedure_spec4810_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_as_key_in_type_procedure_spec4810( FOLLOW_as_key_in_type_procedure_spec4810_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_call_spec_in_type_procedure_spec4813_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_call_spec_in_type_procedure_spec4813( FOLLOW_call_spec_in_type_procedure_spec4813_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_key_in_type_function_spec4836_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_function_key_in_type_function_spec4836( FOLLOW_function_key_in_type_function_spec4836_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_name_in_type_function_spec4838_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_function_name_in_type_function_spec4838( FOLLOW_function_name_in_type_function_spec4838_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_type_function_spec4850_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_type_function_spec4850( FOLLOW_LEFT_PAREN_in_type_function_spec4850_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_elements_parameter_in_type_function_spec4852_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_elements_parameter_in_type_function_spec4852( FOLLOW_type_elements_parameter_in_type_function_spec4852_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_type_function_spec4855_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_type_function_spec4855( FOLLOW_COMMA_in_type_function_spec4855_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_elements_parameter_in_type_function_spec4857_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_elements_parameter_in_type_function_spec4857( FOLLOW_type_elements_parameter_in_type_function_spec4857_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_type_function_spec4861_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_type_function_spec4861( FOLLOW_RIGHT_PAREN_in_type_function_spec4861_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_return_key_in_type_function_spec4874_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_return_key_in_type_function_spec4874( FOLLOW_return_key_in_type_function_spec4874_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_type_function_spec4878_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0100000000400400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_type_function_spec4878( FOLLOW_type_spec_in_type_function_spec4878_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_self_key_in_type_function_spec4882_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000400000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_self_key_in_type_function_spec4882( FOLLOW_self_key_in_type_function_spec4882_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_type_function_spec4884_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_as_key_in_type_function_spec4884( FOLLOW_as_key_in_type_function_spec4884_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_result_key_in_type_function_spec4886_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0100000000400400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_result_key_in_type_function_spec4886( FOLLOW_result_key_in_type_function_spec4886_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_type_function_spec4899_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_type_function_spec4899( FOLLOW_is_key_in_type_function_spec4899_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_type_function_spec4901_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_as_key_in_type_function_spec4901( FOLLOW_as_key_in_type_function_spec4901_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_call_spec_in_type_function_spec4904_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_call_spec_in_type_function_spec4904( FOLLOW_call_spec_in_type_function_spec4904_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_external_key_in_type_function_spec4908_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_external_key_in_type_function_spec4908( FOLLOW_external_key_in_type_function_spec4908_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_variable_key_in_type_function_spec4910_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_variable_key_in_type_function_spec4910( FOLLOW_variable_key_in_type_function_spec4910_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_name_key_in_type_function_spec4913_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_name_key_in_type_function_spec4913( FOLLOW_name_key_in_type_function_spec4913_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_type_function_spec4915_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_type_function_spec4915( FOLLOW_expression_in_type_function_spec4915_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_final_key_in_constructor_spec4937_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_final_key_in_constructor_spec4937( FOLLOW_final_key_in_constructor_spec4937_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_instantiable_key_in_constructor_spec4940_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_instantiable_key_in_constructor_spec4940( FOLLOW_instantiable_key_in_constructor_spec4940_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_constructor_key_in_constructor_spec4943_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_constructor_key_in_constructor_spec4943( FOLLOW_constructor_key_in_constructor_spec4943_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_key_in_constructor_spec4945_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_function_key_in_constructor_spec4945( FOLLOW_function_key_in_constructor_spec4945_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_constructor_spec4947_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_constructor_spec4947( FOLLOW_type_spec_in_constructor_spec4947_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_constructor_spec4958_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_constructor_spec4958( FOLLOW_LEFT_PAREN_in_constructor_spec4958_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_self_key_in_constructor_spec4961_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0010000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_self_key_in_constructor_spec4961( FOLLOW_self_key_in_constructor_spec4961_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_constructor_spec4963_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_in_key_in_constructor_spec4963( FOLLOW_in_key_in_constructor_spec4963_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_out_key_in_constructor_spec4965_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_out_key_in_constructor_spec4965( FOLLOW_out_key_in_constructor_spec4965_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_constructor_spec4967_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_constructor_spec4967( FOLLOW_type_spec_in_constructor_spec4967_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_constructor_spec4969_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_constructor_spec4969( FOLLOW_COMMA_in_constructor_spec4969_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_elements_parameter_in_constructor_spec4972_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_elements_parameter_in_constructor_spec4972( FOLLOW_type_elements_parameter_in_constructor_spec4972_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_constructor_spec4975_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_constructor_spec4975( FOLLOW_COMMA_in_constructor_spec4975_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_elements_parameter_in_constructor_spec4977_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_elements_parameter_in_constructor_spec4977( FOLLOW_type_elements_parameter_in_constructor_spec4977_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_constructor_spec4982_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_constructor_spec4982( FOLLOW_RIGHT_PAREN_in_constructor_spec4982_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_return_key_in_constructor_spec4994_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_return_key_in_constructor_spec4994( FOLLOW_return_key_in_constructor_spec4994_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_self_key_in_constructor_spec4996_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000400000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_self_key_in_constructor_spec4996( FOLLOW_self_key_in_constructor_spec4996_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_constructor_spec4998_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_as_key_in_constructor_spec4998( FOLLOW_as_key_in_constructor_spec4998_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_result_key_in_constructor_spec5000_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0100000000400000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_result_key_in_constructor_spec5000( FOLLOW_result_key_in_constructor_spec5000_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_constructor_spec5004_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_constructor_spec5004( FOLLOW_is_key_in_constructor_spec5004_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_constructor_spec5006_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_as_key_in_constructor_spec5006( FOLLOW_as_key_in_constructor_spec5006_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_call_spec_in_constructor_spec5009_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_call_spec_in_constructor_spec5009( FOLLOW_call_spec_in_constructor_spec5009_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_map_key_in_map_order_function_spec5032_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_map_key_in_map_order_function_spec5032( FOLLOW_map_key_in_map_order_function_spec5032_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_order_key_in_map_order_function_spec5034_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_order_key_in_map_order_function_spec5034( FOLLOW_order_key_in_map_order_function_spec5034_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_member_key_in_map_order_function_spec5037_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_member_key_in_map_order_function_spec5037( FOLLOW_member_key_in_map_order_function_spec5037_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_function_spec_in_map_order_function_spec5039_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_function_spec_in_map_order_function_spec5039( FOLLOW_type_function_spec_in_map_order_function_spec5039_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_pragma_key_in_pragma_clause5059_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_pragma_key_in_pragma_clause5059( FOLLOW_pragma_key_in_pragma_clause5059_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_restrict_references_key_in_pragma_clause5061_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_restrict_references_key_in_pragma_clause5061( FOLLOW_restrict_references_key_in_pragma_clause5061_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_pragma_clause5063_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000800000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_pragma_clause5063( FOLLOW_LEFT_PAREN_in_pragma_clause5063_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_pragma_elements_in_pragma_clause5065_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_pragma_elements_in_pragma_clause5065( FOLLOW_pragma_elements_in_pragma_clause5065_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_pragma_clause5068_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000800000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_pragma_clause5068( FOLLOW_COMMA_in_pragma_clause5068_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_pragma_elements_in_pragma_clause5070_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_pragma_elements_in_pragma_clause5070( FOLLOW_pragma_elements_in_pragma_clause5070_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_pragma_clause5074_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_pragma_clause5074( FOLLOW_RIGHT_PAREN_in_pragma_clause5074_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_id_in_pragma_elements5094_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_id_in_pragma_elements5094( FOLLOW_id_in_pragma_elements5094_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_default_key_in_pragma_elements5105_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_default_key_in_pragma_elements5105( FOLLOW_default_key_in_pragma_elements5105_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_parameter_name_in_type_elements_parameter5125_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_parameter_name_in_type_elements_parameter5125( FOLLOW_parameter_name_in_type_elements_parameter5125_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_type_elements_parameter5127_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_type_elements_parameter5127( FOLLOW_type_spec_in_type_elements_parameter5127_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_key_in_drop_sequence5151_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_key_in_drop_sequence5151( FOLLOW_drop_key_in_drop_sequence5151_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_sequence_key_in_drop_sequence5153_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_sequence_key_in_drop_sequence5153( FOLLOW_sequence_key_in_drop_sequence5153_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_sequence_name_in_drop_sequence5155_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_sequence_name_in_drop_sequence5155( FOLLOW_sequence_name_in_drop_sequence5155_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_drop_sequence5165_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_drop_sequence5165( FOLLOW_SEMICOLON_in_drop_sequence5165_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_key_in_alter_sequence5185_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_key_in_alter_sequence5185( FOLLOW_alter_key_in_alter_sequence5185_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_sequence_key_in_alter_sequence5187_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_sequence_key_in_alter_sequence5187( FOLLOW_sequence_key_in_alter_sequence5187_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_sequence_name_in_alter_sequence5189_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_sequence_name_in_alter_sequence5189( FOLLOW_sequence_name_in_alter_sequence5189_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_sequence_spec_in_alter_sequence5191_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_sequence_spec_in_alter_sequence5191( FOLLOW_sequence_spec_in_alter_sequence5191_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_alter_sequence5203_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_alter_sequence5203( FOLLOW_SEMICOLON_in_alter_sequence5203_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_key_in_create_sequence5223_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_key_in_create_sequence5223( FOLLOW_create_key_in_create_sequence5223_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_sequence_key_in_create_sequence5225_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_sequence_key_in_create_sequence5225( FOLLOW_sequence_key_in_create_sequence5225_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_sequence_name_in_create_sequence5227_bits[]	= { ANTLR_UINT64_LIT(0x2000000000000000), ANTLR_UINT64_LIT(0x0000000000002400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_sequence_name_in_create_sequence5227( FOLLOW_sequence_name_in_create_sequence5227_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_sequence_start_clause_in_create_sequence5238_bits[]	= { ANTLR_UINT64_LIT(0x2000000000000000), ANTLR_UINT64_LIT(0x0000000000002400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_sequence_start_clause_in_create_sequence5238( FOLLOW_sequence_start_clause_in_create_sequence5238_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_sequence_spec_in_create_sequence5249_bits[]	= { ANTLR_UINT64_LIT(0x2000000000000000), ANTLR_UINT64_LIT(0x0000000000002400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_sequence_spec_in_create_sequence5249( FOLLOW_sequence_spec_in_create_sequence5249_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_create_sequence5260_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_create_sequence5260( FOLLOW_SEMICOLON_in_create_sequence5260_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_increment_key_in_sequence_spec5282_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_increment_key_in_sequence_spec5282( FOLLOW_increment_key_in_sequence_spec5282_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_sequence_spec5284_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_by_key_in_sequence_spec5284( FOLLOW_by_key_in_sequence_spec5284_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_sequence_spec5286_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_sequence_spec5286( FOLLOW_UNSIGNED_INTEGER_in_sequence_spec5286_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_maxvalue_key_in_sequence_spec5297_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_maxvalue_key_in_sequence_spec5297( FOLLOW_maxvalue_key_in_sequence_spec5297_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_sequence_spec5299_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_sequence_spec5299( FOLLOW_UNSIGNED_INTEGER_in_sequence_spec5299_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_nomaxvalue_key_in_sequence_spec5310_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_nomaxvalue_key_in_sequence_spec5310( FOLLOW_nomaxvalue_key_in_sequence_spec5310_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_minvalue_key_in_sequence_spec5321_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_minvalue_key_in_sequence_spec5321( FOLLOW_minvalue_key_in_sequence_spec5321_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_sequence_spec5323_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_sequence_spec5323( FOLLOW_UNSIGNED_INTEGER_in_sequence_spec5323_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_nominvalue_key_in_sequence_spec5334_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_nominvalue_key_in_sequence_spec5334( FOLLOW_nominvalue_key_in_sequence_spec5334_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_cycle_key_in_sequence_spec5345_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_cycle_key_in_sequence_spec5345( FOLLOW_cycle_key_in_sequence_spec5345_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_nocycle_key_in_sequence_spec5356_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_nocycle_key_in_sequence_spec5356( FOLLOW_nocycle_key_in_sequence_spec5356_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_cache_key_in_sequence_spec5367_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_cache_key_in_sequence_spec5367( FOLLOW_cache_key_in_sequence_spec5367_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_sequence_spec5369_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_sequence_spec5369( FOLLOW_UNSIGNED_INTEGER_in_sequence_spec5369_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_nocache_key_in_sequence_spec5380_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_nocache_key_in_sequence_spec5380( FOLLOW_nocache_key_in_sequence_spec5380_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_order_key_in_sequence_spec5391_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_order_key_in_sequence_spec5391( FOLLOW_order_key_in_sequence_spec5391_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_noorder_key_in_sequence_spec5402_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_noorder_key_in_sequence_spec5402( FOLLOW_noorder_key_in_sequence_spec5402_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_start_key_in_sequence_start_clause5422_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_start_key_in_sequence_start_clause5422( FOLLOW_start_key_in_sequence_start_clause5422_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_sequence_start_clause5424_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_with_key_in_sequence_start_clause5424( FOLLOW_with_key_in_sequence_start_clause5424_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_UNSIGNED_INTEGER_in_sequence_start_clause5426_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_UNSIGNED_INTEGER_in_sequence_start_clause5426( FOLLOW_UNSIGNED_INTEGER_in_sequence_start_clause5426_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_authid_key_in_invoker_rights_clause5451_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_authid_key_in_invoker_rights_clause5451( FOLLOW_authid_key_in_invoker_rights_clause5451_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_current_user_key_in_invoker_rights_clause5454_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_current_user_key_in_invoker_rights_clause5454( FOLLOW_current_user_key_in_invoker_rights_clause5454_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_definer_key_in_invoker_rights_clause5456_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_definer_key_in_invoker_rights_clause5456( FOLLOW_definer_key_in_invoker_rights_clause5456_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_id_in_compiler_parameters_clause5477_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_id_in_compiler_parameters_clause5477( FOLLOW_id_in_compiler_parameters_clause5477_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_compiler_parameters_clause5479_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_compiler_parameters_clause5479( FOLLOW_EQUALS_OP_in_compiler_parameters_clause5479_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_compiler_parameters_clause5481_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_compiler_parameters_clause5481( FOLLOW_expression_in_compiler_parameters_clause5481_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_language_key_in_call_spec5501_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_language_key_in_call_spec5501( FOLLOW_language_key_in_call_spec5501_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_java_spec_in_call_spec5505_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_java_spec_in_call_spec5505( FOLLOW_java_spec_in_call_spec5505_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_c_spec_in_call_spec5509_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_c_spec_in_call_spec5509( FOLLOW_c_spec_in_call_spec5509_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_java_key_in_java_spec5533_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_java_key_in_java_spec5533( FOLLOW_java_key_in_java_spec5533_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_name_key_in_java_spec5535_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_name_key_in_java_spec5535( FOLLOW_name_key_in_java_spec5535_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_CHAR_STRING_in_java_spec5537_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_CHAR_STRING_in_java_spec5537( FOLLOW_CHAR_STRING_in_java_spec5537_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_c_key_in_c_spec5557_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_c_key_in_c_spec5557( FOLLOW_c_key_in_c_spec5557_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_name_key_in_c_spec5560_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_name_key_in_c_spec5560( FOLLOW_name_key_in_c_spec5560_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_CHAR_STRING_in_c_spec5562_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_CHAR_STRING_in_c_spec5562( FOLLOW_CHAR_STRING_in_c_spec5562_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_library_key_in_c_spec5575_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_library_key_in_c_spec5575( FOLLOW_library_key_in_c_spec5575_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_id_in_c_spec5577_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_id_in_c_spec5577( FOLLOW_id_in_c_spec5577_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_c_agent_in_clause_in_c_spec5587_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_c_agent_in_clause_in_c_spec5587( FOLLOW_c_agent_in_clause_in_c_spec5587_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_c_spec5591_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_with_key_in_c_spec5591( FOLLOW_with_key_in_c_spec5591_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_context_key_in_c_spec5593_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_context_key_in_c_spec5593( FOLLOW_context_key_in_c_spec5593_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_c_parameters_clause_in_c_spec5597_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_c_parameters_clause_in_c_spec5597( FOLLOW_c_parameters_clause_in_c_spec5597_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_agent_key_in_c_agent_in_clause5618_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0010000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_agent_key_in_c_agent_in_clause5618( FOLLOW_agent_key_in_c_agent_in_clause5618_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_c_agent_in_clause5620_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_in_key_in_c_agent_in_clause5620( FOLLOW_in_key_in_c_agent_in_clause5620_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_c_agent_in_clause5622_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_c_agent_in_clause5622( FOLLOW_LEFT_PAREN_in_c_agent_in_clause5622_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_c_agent_in_clause5624_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_c_agent_in_clause5624( FOLLOW_expression_in_c_agent_in_clause5624_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_c_agent_in_clause5627_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_c_agent_in_clause5627( FOLLOW_COMMA_in_c_agent_in_clause5627_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_c_agent_in_clause5629_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_c_agent_in_clause5629( FOLLOW_expression_in_c_agent_in_clause5629_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_c_agent_in_clause5633_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_c_agent_in_clause5633( FOLLOW_RIGHT_PAREN_in_c_agent_in_clause5633_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_parameters_key_in_c_parameters_clause5653_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_parameters_key_in_c_parameters_clause5653( FOLLOW_parameters_key_in_c_parameters_clause5653_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_c_parameters_clause5655_bits[]	= { ANTLR_UINT64_LIT(0x0000008650547220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_c_parameters_clause5655( FOLLOW_LEFT_PAREN_in_c_parameters_clause5655_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_c_parameters_clause5658_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_c_parameters_clause5658( FOLLOW_expression_in_c_parameters_clause5658_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_c_parameters_clause5661_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_c_parameters_clause5661( FOLLOW_COMMA_in_c_parameters_clause5661_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_c_parameters_clause5663_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_c_parameters_clause5663( FOLLOW_expression_in_c_parameters_clause5663_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_DOUBLE_PERIOD_in_c_parameters_clause5669_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_DOUBLE_PERIOD_in_c_parameters_clause5669( FOLLOW_DOUBLE_PERIOD_in_c_parameters_clause5669_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_c_parameters_clause5671_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_c_parameters_clause5671( FOLLOW_PERIOD_in_c_parameters_clause5671_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_c_parameters_clause5674_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_c_parameters_clause5674( FOLLOW_RIGHT_PAREN_in_c_parameters_clause5674_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_parameter_name_in_parameter5696_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040042), ANTLR_UINT64_LIT(0x0010000A00000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_parameter_name_in_parameter5696( FOLLOW_parameter_name_in_parameter5696_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_parameter5700_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040042), ANTLR_UINT64_LIT(0x0010000A00000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_in_key_in_parameter5700( FOLLOW_in_key_in_parameter5700_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_out_key_in_parameter5704_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040042), ANTLR_UINT64_LIT(0x0010000A00000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_out_key_in_parameter5704( FOLLOW_out_key_in_parameter5704_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_inout_key_in_parameter5708_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040042), ANTLR_UINT64_LIT(0x0010000A00000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_inout_key_in_parameter5708( FOLLOW_inout_key_in_parameter5708_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_nocopy_key_in_parameter5712_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040042), ANTLR_UINT64_LIT(0x0010000A00000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_nocopy_key_in_parameter5712( FOLLOW_nocopy_key_in_parameter5712_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_parameter5716_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000042), ANTLR_UINT64_LIT(0x0000000800000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_parameter5716( FOLLOW_type_spec_in_parameter5716_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_default_value_part_in_parameter5719_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_default_value_part_in_parameter5719( FOLLOW_default_value_part_in_parameter5719_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_ASSIGN_OP_in_default_value_part5741_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_ASSIGN_OP_in_default_value_part5741( FOLLOW_ASSIGN_OP_in_default_value_part5741_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_default_key_in_default_value_part5743_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_default_key_in_default_value_part5743( FOLLOW_default_key_in_default_value_part5743_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_default_value_part5746_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_default_value_part5746( FOLLOW_expression_in_default_value_part5746_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_variable_declaration_in_declare_spec5780_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_variable_declaration_in_declare_spec5780( FOLLOW_variable_declaration_in_declare_spec5780_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_subtype_declaration_in_declare_spec5792_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_subtype_declaration_in_declare_spec5792( FOLLOW_subtype_declaration_in_declare_spec5792_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_declaration_in_declare_spec5804_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_cursor_declaration_in_declare_spec5804( FOLLOW_cursor_declaration_in_declare_spec5804_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exception_declaration_in_declare_spec5816_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exception_declaration_in_declare_spec5816( FOLLOW_exception_declaration_in_declare_spec5816_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_pragma_declaration_in_declare_spec5828_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_pragma_declaration_in_declare_spec5828( FOLLOW_pragma_declaration_in_declare_spec5828_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_record_declaration_in_declare_spec5840_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_record_declaration_in_declare_spec5840( FOLLOW_record_declaration_in_declare_spec5840_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_table_declaration_in_declare_spec5852_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_table_declaration_in_declare_spec5852( FOLLOW_table_declaration_in_declare_spec5852_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_procedure_body_in_declare_spec5864_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_procedure_body_in_declare_spec5864( FOLLOW_create_procedure_body_in_declare_spec5864_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_function_body_in_declare_spec5876_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_function_body_in_declare_spec5876( FOLLOW_create_function_body_in_declare_spec5876_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_variable_name_in_variable_declaration5897_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_variable_name_in_variable_declaration5897( FOLLOW_variable_name_in_variable_declaration5897_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_constant_key_in_variable_declaration5899_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_constant_key_in_variable_declaration5899( FOLLOW_constant_key_in_variable_declaration5899_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_variable_declaration5910_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0400000800002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_variable_declaration5910( FOLLOW_type_spec_in_variable_declaration5910_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_not_key_in_variable_declaration5913_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0800000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_not_key_in_variable_declaration5913( FOLLOW_not_key_in_variable_declaration5913_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_null_key_in_variable_declaration5915_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000040), ANTLR_UINT64_LIT(0x0000000800002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_null_key_in_variable_declaration5915( FOLLOW_null_key_in_variable_declaration5915_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_default_value_part_in_variable_declaration5928_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_default_value_part_in_variable_declaration5928( FOLLOW_default_value_part_in_variable_declaration5928_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_variable_declaration5931_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_variable_declaration5931( FOLLOW_SEMICOLON_in_variable_declaration5931_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_subtype_key_in_subtype_declaration5957_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_subtype_key_in_subtype_declaration5957( FOLLOW_subtype_key_in_subtype_declaration5957_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_name_in_subtype_declaration5959_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_name_in_subtype_declaration5959( FOLLOW_type_name_in_subtype_declaration5959_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_subtype_declaration5961_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_subtype_declaration5961( FOLLOW_is_key_in_subtype_declaration5961_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_subtype_declaration5963_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0400000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_subtype_declaration5963( FOLLOW_type_spec_in_subtype_declaration5963_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_range_key_in_subtype_declaration5976_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_range_key_in_subtype_declaration5976( FOLLOW_range_key_in_subtype_declaration5976_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_subtype_declaration5978_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_subtype_declaration5978( FOLLOW_expression_in_subtype_declaration5978_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_DOUBLE_PERIOD_in_subtype_declaration5980_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_DOUBLE_PERIOD_in_subtype_declaration5980( FOLLOW_DOUBLE_PERIOD_in_subtype_declaration5980_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_subtype_declaration5982_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0400000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_subtype_declaration5982( FOLLOW_expression_in_subtype_declaration5982_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_not_key_in_subtype_declaration5997_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0800000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_not_key_in_subtype_declaration5997( FOLLOW_not_key_in_subtype_declaration5997_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_null_key_in_subtype_declaration5999_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_null_key_in_subtype_declaration5999( FOLLOW_null_key_in_subtype_declaration5999_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_subtype_declaration6003_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_subtype_declaration6003( FOLLOW_SEMICOLON_in_subtype_declaration6003_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_key_in_cursor_declaration6026_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_cursor_key_in_cursor_declaration6026( FOLLOW_cursor_key_in_cursor_declaration6026_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_name_in_cursor_declaration6028_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0100000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_cursor_name_in_cursor_declaration6028( FOLLOW_cursor_name_in_cursor_declaration6028_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_cursor_declaration6045_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_cursor_declaration6045( FOLLOW_LEFT_PAREN_in_cursor_declaration6045_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_parameter_spec_in_cursor_declaration6047_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_parameter_spec_in_cursor_declaration6047( FOLLOW_parameter_spec_in_cursor_declaration6047_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_cursor_declaration6050_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_cursor_declaration6050( FOLLOW_COMMA_in_cursor_declaration6050_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_parameter_spec_in_cursor_declaration6052_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_parameter_spec_in_cursor_declaration6052( FOLLOW_parameter_spec_in_cursor_declaration6052_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_cursor_declaration6056_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_cursor_declaration6056( FOLLOW_RIGHT_PAREN_in_cursor_declaration6056_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_return_key_in_cursor_declaration6076_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_return_key_in_cursor_declaration6076( FOLLOW_return_key_in_cursor_declaration6076_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_cursor_declaration6078_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_cursor_declaration6078( FOLLOW_type_spec_in_cursor_declaration6078_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_cursor_declaration6083_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_cursor_declaration6083( FOLLOW_is_key_in_cursor_declaration6083_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_cursor_declaration6085_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_select_statement_in_cursor_declaration6085( FOLLOW_select_statement_in_cursor_declaration6085_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_cursor_declaration6089_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_cursor_declaration6089( FOLLOW_SEMICOLON_in_cursor_declaration6089_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_parameter_name_in_parameter_spec6109_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040042), ANTLR_UINT64_LIT(0x0010000A00000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_parameter_name_in_parameter_spec6109( FOLLOW_parameter_name_in_parameter_spec6109_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_parameter_spec6112_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_in_key_in_parameter_spec6112( FOLLOW_in_key_in_parameter_spec6112_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_parameter_spec6115_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000042), ANTLR_UINT64_LIT(0x0000000800000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_parameter_spec6115( FOLLOW_type_spec_in_parameter_spec6115_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_default_value_part_in_parameter_spec6128_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_default_value_part_in_parameter_spec6128( FOLLOW_default_value_part_in_parameter_spec6128_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exception_name_in_exception_declaration6150_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000040000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exception_name_in_exception_declaration6150( FOLLOW_exception_name_in_exception_declaration6150_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exception_key_in_exception_declaration6152_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exception_key_in_exception_declaration6152( FOLLOW_exception_key_in_exception_declaration6152_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_exception_declaration6154_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_exception_declaration6154( FOLLOW_SEMICOLON_in_exception_declaration6154_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_pragma_key_in_pragma_declaration6187_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_pragma_key_in_pragma_declaration6187( FOLLOW_pragma_key_in_pragma_declaration6187_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_serially_reusable_key_in_pragma_declaration6202_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_serially_reusable_key_in_pragma_declaration6202( FOLLOW_serially_reusable_key_in_pragma_declaration6202_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_autonomous_transaction_key_in_pragma_declaration6218_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_autonomous_transaction_key_in_pragma_declaration6218( FOLLOW_autonomous_transaction_key_in_pragma_declaration6218_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exception_init_key_in_pragma_declaration6233_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exception_init_key_in_pragma_declaration6233( FOLLOW_exception_init_key_in_pragma_declaration6233_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_pragma_declaration6235_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_pragma_declaration6235( FOLLOW_LEFT_PAREN_in_pragma_declaration6235_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exception_name_in_pragma_declaration6237_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exception_name_in_pragma_declaration6237( FOLLOW_exception_name_in_pragma_declaration6237_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_pragma_declaration6239_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400020), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000800000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_pragma_declaration6239( FOLLOW_COMMA_in_pragma_declaration6239_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_numeric_in_pragma_declaration6241_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_numeric_in_pragma_declaration6241( FOLLOW_numeric_in_pragma_declaration6241_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_pragma_declaration6243_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_pragma_declaration6243( FOLLOW_RIGHT_PAREN_in_pragma_declaration6243_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_inline_key_in_pragma_declaration6259_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_inline_key_in_pragma_declaration6259( FOLLOW_inline_key_in_pragma_declaration6259_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_pragma_declaration6261_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_pragma_declaration6261( FOLLOW_LEFT_PAREN_in_pragma_declaration6261_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_id_in_pragma_declaration6265_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_id_in_pragma_declaration6265( FOLLOW_id_in_pragma_declaration6265_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_pragma_declaration6267_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_pragma_declaration6267( FOLLOW_COMMA_in_pragma_declaration6267_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_pragma_declaration6269_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_pragma_declaration6269( FOLLOW_expression_in_pragma_declaration6269_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_pragma_declaration6271_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_pragma_declaration6271( FOLLOW_RIGHT_PAREN_in_pragma_declaration6271_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_restrict_references_key_in_pragma_declaration6286_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_restrict_references_key_in_pragma_declaration6286( FOLLOW_restrict_references_key_in_pragma_declaration6286_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_pragma_declaration6288_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000800000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_pragma_declaration6288( FOLLOW_LEFT_PAREN_in_pragma_declaration6288_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_id_in_pragma_declaration6291_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_id_in_pragma_declaration6291( FOLLOW_id_in_pragma_declaration6291_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_default_key_in_pragma_declaration6293_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_default_key_in_pragma_declaration6293( FOLLOW_default_key_in_pragma_declaration6293_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_pragma_declaration6297_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_pragma_declaration6297( FOLLOW_COMMA_in_pragma_declaration6297_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_id_in_pragma_declaration6299_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_id_in_pragma_declaration6299( FOLLOW_id_in_pragma_declaration6299_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_pragma_declaration6303_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_pragma_declaration6303( FOLLOW_RIGHT_PAREN_in_pragma_declaration6303_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_pragma_declaration6323_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_pragma_declaration6323( FOLLOW_SEMICOLON_in_pragma_declaration6323_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_record_type_dec_in_record_declaration6343_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_record_type_dec_in_record_declaration6343( FOLLOW_record_type_dec_in_record_declaration6343_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_record_var_dec_in_record_declaration6354_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_record_var_dec_in_record_declaration6354( FOLLOW_record_var_dec_in_record_declaration6354_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_key_in_record_type_dec6377_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_key_in_record_type_dec6377( FOLLOW_type_key_in_record_type_dec6377_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_name_in_record_type_dec6379_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_name_in_record_type_dec6379( FOLLOW_type_name_in_record_type_dec6379_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_record_type_dec6381_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_record_type_dec6381( FOLLOW_is_key_in_record_type_dec6381_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_record_key_in_record_type_dec6393_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_record_key_in_record_type_dec6393( FOLLOW_record_key_in_record_type_dec6393_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_record_type_dec6395_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_record_type_dec6395( FOLLOW_LEFT_PAREN_in_record_type_dec6395_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_field_spec_in_record_type_dec6397_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_field_spec_in_record_type_dec6397( FOLLOW_field_spec_in_record_type_dec6397_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_record_type_dec6401_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_record_type_dec6401( FOLLOW_COMMA_in_record_type_dec6401_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_field_spec_in_record_type_dec6403_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_field_spec_in_record_type_dec6403( FOLLOW_field_spec_in_record_type_dec6403_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_record_type_dec6408_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_record_type_dec6408( FOLLOW_RIGHT_PAREN_in_record_type_dec6408_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_ref_key_in_record_type_dec6419_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000100000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_ref_key_in_record_type_dec6419( FOLLOW_ref_key_in_record_type_dec6419_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_key_in_record_type_dec6421_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_cursor_key_in_record_type_dec6421( FOLLOW_cursor_key_in_record_type_dec6421_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_return_key_in_record_type_dec6424_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_return_key_in_record_type_dec6424( FOLLOW_return_key_in_record_type_dec6424_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_record_type_dec6426_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_record_type_dec6426( FOLLOW_type_spec_in_record_type_dec6426_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_record_type_dec6439_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_record_type_dec6439( FOLLOW_SEMICOLON_in_record_type_dec6439_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_field_spec6459_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040042), ANTLR_UINT64_LIT(0x0400000A00000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_column_name_in_field_spec6459( FOLLOW_column_name_in_field_spec6459_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_field_spec6461_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000042), ANTLR_UINT64_LIT(0x0400000800000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_field_spec6461( FOLLOW_type_spec_in_field_spec6461_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_not_key_in_field_spec6473_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0800000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_not_key_in_field_spec6473( FOLLOW_not_key_in_field_spec6473_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_null_key_in_field_spec6475_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000042), ANTLR_UINT64_LIT(0x0000000800000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_null_key_in_field_spec6475( FOLLOW_null_key_in_field_spec6475_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_default_value_part_in_field_spec6487_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_default_value_part_in_field_spec6487( FOLLOW_default_value_part_in_field_spec6487_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_record_name_in_record_var_dec6508_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_record_name_in_record_var_dec6508( FOLLOW_record_name_in_record_var_dec6508_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_name_in_record_var_dec6510_bits[]	= { ANTLR_UINT64_LIT(0x0000002000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_name_in_record_var_dec6510( FOLLOW_type_name_in_record_var_dec6510_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_percent_rowtype_key_in_record_var_dec6513_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_percent_rowtype_key_in_record_var_dec6513( FOLLOW_percent_rowtype_key_in_record_var_dec6513_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_percent_type_key_in_record_var_dec6515_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_percent_type_key_in_record_var_dec6515( FOLLOW_percent_type_key_in_record_var_dec6515_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_record_var_dec6518_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_record_var_dec6518( FOLLOW_SEMICOLON_in_record_var_dec6518_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_table_type_dec_in_table_declaration6541_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_table_type_dec_in_table_declaration6541( FOLLOW_table_type_dec_in_table_declaration6541_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_table_var_dec_in_table_declaration6545_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_table_var_dec_in_table_declaration6545( FOLLOW_table_var_dec_in_table_declaration6545_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_table_declaration6548_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_table_declaration6548( FOLLOW_SEMICOLON_in_table_declaration6548_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_key_in_table_type_dec6568_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_key_in_table_type_dec6568( FOLLOW_type_key_in_table_type_dec6568_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_name_in_table_type_dec6570_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0100000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_name_in_table_type_dec6570( FOLLOW_type_name_in_table_type_dec6570_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_table_type_dec6572_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000100) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_is_key_in_table_type_dec6572( FOLLOW_is_key_in_table_type_dec6572_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_table_key_in_table_type_dec6584_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1000000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_table_key_in_table_type_dec6584( FOLLOW_table_key_in_table_type_dec6584_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_of_key_in_table_type_dec6598_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_of_key_in_table_type_dec6598( FOLLOW_of_key_in_table_type_dec6598_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_table_type_dec6600_bits[]	= { ANTLR_UINT64_LIT(0x0010000000000002), ANTLR_UINT64_LIT(0x0400000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_table_type_dec6600( FOLLOW_type_spec_in_table_type_dec6600_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_table_indexed_by_part_in_table_type_dec6615_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0400000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_table_indexed_by_part_in_table_type_dec6615( FOLLOW_table_indexed_by_part_in_table_type_dec6615_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_not_key_in_table_type_dec6627_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0800000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_not_key_in_table_type_dec6627( FOLLOW_not_key_in_table_type_dec6627_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_null_key_in_table_type_dec6629_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_null_key_in_table_type_dec6629( FOLLOW_null_key_in_table_type_dec6629_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_varray_type_def_in_table_type_dec6642_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_varray_type_def_in_table_type_dec6642( FOLLOW_varray_type_def_in_table_type_dec6642_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_indexed_key_in_table_indexed_by_part6671_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_indexed_key_in_table_indexed_by_part6671( FOLLOW_indexed_key_in_table_indexed_by_part6671_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_index_key_in_table_indexed_by_part6675_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_index_key_in_table_indexed_by_part6675( FOLLOW_index_key_in_table_indexed_by_part6675_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_table_indexed_by_part6678_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_by_key_in_table_indexed_by_part6678( FOLLOW_by_key_in_table_indexed_by_part6678_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_table_indexed_by_part6680_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_table_indexed_by_part6680( FOLLOW_type_spec_in_table_indexed_by_part6680_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_varray_key_in_varray_type_def6701_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_varray_key_in_varray_type_def6701( FOLLOW_varray_key_in_varray_type_def6701_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_varying_key_in_varray_type_def6704_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_varying_key_in_varray_type_def6704( FOLLOW_varying_key_in_varray_type_def6704_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_array_key_in_varray_type_def6706_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_array_key_in_varray_type_def6706( FOLLOW_array_key_in_varray_type_def6706_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_varray_type_def6717_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_varray_type_def6717( FOLLOW_LEFT_PAREN_in_varray_type_def6717_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_varray_type_def6719_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_varray_type_def6719( FOLLOW_expression_in_varray_type_def6719_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_varray_type_def6721_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1000000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_varray_type_def6721( FOLLOW_RIGHT_PAREN_in_varray_type_def6721_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_of_key_in_varray_type_def6732_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_of_key_in_varray_type_def6732( FOLLOW_of_key_in_varray_type_def6732_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_varray_type_def6734_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0400000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_varray_type_def6734( FOLLOW_type_spec_in_varray_type_def6734_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_not_key_in_varray_type_def6745_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0800000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_not_key_in_varray_type_def6745( FOLLOW_not_key_in_varray_type_def6745_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_null_key_in_varray_type_def6747_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_null_key_in_varray_type_def6747( FOLLOW_null_key_in_varray_type_def6747_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_table_var_name_in_table_var_dec6769_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_table_var_name_in_table_var_dec6769( FOLLOW_table_var_name_in_table_var_dec6769_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_table_var_dec6771_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_table_var_dec6771( FOLLOW_type_spec_in_table_var_dec6771_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_statement_in_seq_of_statements6800_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_statement_in_seq_of_statements6800( FOLLOW_statement_in_seq_of_statements6800_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_seq_of_statements6802_bits[]	= { ANTLR_UINT64_LIT(0x00480000D0044202), ANTLR_UINT64_LIT(0x0823601549080400), ANTLR_UINT64_LIT(0x0000000000108048) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_set_in_seq_of_statements6802( FOLLOW_set_in_seq_of_statements6802_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_label_declaration_in_seq_of_statements6808_bits[]	= { ANTLR_UINT64_LIT(0x00480000D0044202), ANTLR_UINT64_LIT(0x0823601549080400), ANTLR_UINT64_LIT(0x0000000000108048) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_label_declaration_in_seq_of_statements6808( FOLLOW_label_declaration_in_seq_of_statements6808_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LESS_THAN_OP_in_label_declaration6834_bits[]	= { ANTLR_UINT64_LIT(0x0000000080000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LESS_THAN_OP_in_label_declaration6834( FOLLOW_LESS_THAN_OP_in_label_declaration6834_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LESS_THAN_OP_in_label_declaration6836_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LESS_THAN_OP_in_label_declaration6836( FOLLOW_LESS_THAN_OP_in_label_declaration6836_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_label_name_in_label_declaration6838_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_label_name_in_label_declaration6838( FOLLOW_label_name_in_label_declaration6838_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OP_in_label_declaration6840_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_GREATER_THAN_OP_in_label_declaration6840( FOLLOW_GREATER_THAN_OP_in_label_declaration6840_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OP_in_label_declaration6842_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_GREATER_THAN_OP_in_label_declaration6842( FOLLOW_GREATER_THAN_OP_in_label_declaration6842_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_key_in_statement6871_bits[]	= { ANTLR_UINT64_LIT(0xFFFFFFFFFFFFFFF0), ANTLR_UINT64_LIT(0xFFFFFFFFFFFFDFFF), ANTLR_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR_UINT64_LIT(0x0000000000001FFF) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_key_in_statement6871( FOLLOW_create_key_in_statement6871_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_swallow_to_semi_in_statement6873_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_swallow_to_semi_in_statement6873( FOLLOW_swallow_to_semi_in_statement6873_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_statement6875_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_set_in_statement6875( FOLLOW_set_in_statement6875_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_key_in_statement6890_bits[]	= { ANTLR_UINT64_LIT(0xFFFFFFFFFFFFFFF0), ANTLR_UINT64_LIT(0xFFFFFFFFFFFFDFFF), ANTLR_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR_UINT64_LIT(0x0000000000001FFF) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_key_in_statement6890( FOLLOW_alter_key_in_statement6890_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_swallow_to_semi_in_statement6892_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_swallow_to_semi_in_statement6892( FOLLOW_swallow_to_semi_in_statement6892_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_statement6895_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_set_in_statement6895( FOLLOW_set_in_statement6895_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_grant_key_in_statement6910_bits[]	= { ANTLR_UINT64_LIT(0xFFFFFFFFFFFFFFF0), ANTLR_UINT64_LIT(0xFFFFFFFFFFFFDFFF), ANTLR_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR_UINT64_LIT(0x0000000000001FFF) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_grant_key_in_statement6910( FOLLOW_grant_key_in_statement6910_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_swallow_to_semi_in_statement6912_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_swallow_to_semi_in_statement6912( FOLLOW_swallow_to_semi_in_statement6912_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_statement6915_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_set_in_statement6915( FOLLOW_set_in_statement6915_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_truncate_key_in_statement6930_bits[]	= { ANTLR_UINT64_LIT(0xFFFFFFFFFFFFFFF0), ANTLR_UINT64_LIT(0xFFFFFFFFFFFFDFFF), ANTLR_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR_UINT64_LIT(0x0000000000001FFF) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_truncate_key_in_statement6930( FOLLOW_truncate_key_in_statement6930_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_swallow_to_semi_in_statement6932_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_swallow_to_semi_in_statement6932( FOLLOW_swallow_to_semi_in_statement6932_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_statement6935_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_set_in_statement6935( FOLLOW_set_in_statement6935_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_body_in_statement6956_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_body_in_statement6956( FOLLOW_body_in_statement6956_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_block_in_statement6973_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_block_in_statement6973( FOLLOW_block_in_statement6973_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_assignment_statement_in_statement6984_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_assignment_statement_in_statement6984( FOLLOW_assignment_statement_in_statement6984_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_continue_statement_in_statement6995_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_continue_statement_in_statement6995( FOLLOW_continue_statement_in_statement6995_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exit_statement_in_statement7006_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exit_statement_in_statement7006( FOLLOW_exit_statement_in_statement7006_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_goto_statement_in_statement7017_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_goto_statement_in_statement7017( FOLLOW_goto_statement_in_statement7017_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_if_statement_in_statement7028_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_if_statement_in_statement7028( FOLLOW_if_statement_in_statement7028_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_loop_statement_in_statement7039_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_loop_statement_in_statement7039( FOLLOW_loop_statement_in_statement7039_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_forall_statement_in_statement7050_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_forall_statement_in_statement7050( FOLLOW_forall_statement_in_statement7050_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_null_statement_in_statement7061_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_null_statement_in_statement7061( FOLLOW_null_statement_in_statement7061_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_raise_statement_in_statement7072_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_raise_statement_in_statement7072( FOLLOW_raise_statement_in_statement7072_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_return_statement_in_statement7083_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_return_statement_in_statement7083( FOLLOW_return_statement_in_statement7083_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_case_statement_in_statement7094_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_case_statement_in_statement7094( FOLLOW_case_statement_in_statement7094_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_sql_statement_in_statement7106_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_sql_statement_in_statement7106( FOLLOW_sql_statement_in_statement7106_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_call_in_statement7117_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_function_call_in_statement7117( FOLLOW_function_call_in_statement7117_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_in_assignment_statement7139_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_general_element_in_assignment_statement7139( FOLLOW_general_element_in_assignment_statement7139_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_assignment_statement7141_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_bind_variable_in_assignment_statement7141( FOLLOW_bind_variable_in_assignment_statement7141_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_ASSIGN_OP_in_assignment_statement7144_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_ASSIGN_OP_in_assignment_statement7144( FOLLOW_ASSIGN_OP_in_assignment_statement7144_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_assignment_statement7146_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_assignment_statement7146( FOLLOW_expression_in_assignment_statement7146_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_continue_key_in_continue_statement7166_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_continue_key_in_continue_statement7166( FOLLOW_continue_key_in_continue_statement7166_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_label_name_in_continue_statement7168_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_label_name_in_continue_statement7168( FOLLOW_label_name_in_continue_statement7168_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_continue_statement7172_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_when_key_in_continue_statement7172( FOLLOW_when_key_in_continue_statement7172_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_continue_statement7174_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_condition_in_continue_statement7174( FOLLOW_condition_in_continue_statement7174_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exit_key_in_exit_statement7196_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exit_key_in_exit_statement7196( FOLLOW_exit_key_in_exit_statement7196_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_label_name_in_exit_statement7198_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_label_name_in_exit_statement7198( FOLLOW_label_name_in_exit_statement7198_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_exit_statement7202_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_when_key_in_exit_statement7202( FOLLOW_when_key_in_exit_statement7202_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_exit_statement7204_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_condition_in_exit_statement7204( FOLLOW_condition_in_exit_statement7204_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_goto_key_in_goto_statement7226_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_goto_key_in_goto_statement7226( FOLLOW_goto_key_in_goto_statement7226_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_label_name_in_goto_statement7228_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_label_name_in_goto_statement7228( FOLLOW_label_name_in_goto_statement7228_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_if_key_in_if_statement7248_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_if_key_in_if_statement7248( FOLLOW_if_key_in_if_statement7248_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_if_statement7250_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_condition_in_if_statement7250( FOLLOW_condition_in_if_statement7250_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_then_key_in_if_statement7252_bits[]	= { ANTLR_UINT64_LIT(0x00480000D0044200), ANTLR_UINT64_LIT(0x0823601549080400), ANTLR_UINT64_LIT(0x0000000000108048) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_then_key_in_if_statement7252( FOLLOW_then_key_in_if_statement7252_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_seq_of_statements_in_if_statement7254_bits[]	= { ANTLR_UINT64_LIT(0x0000010000000000), ANTLR_UINT64_LIT(0x0000030000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_seq_of_statements_in_if_statement7254( FOLLOW_seq_of_statements_in_if_statement7254_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_elsif_part_in_if_statement7264_bits[]	= { ANTLR_UINT64_LIT(0x0000010000000000), ANTLR_UINT64_LIT(0x0000030000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_elsif_part_in_if_statement7264( FOLLOW_elsif_part_in_if_statement7264_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_else_part_in_if_statement7267_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_else_part_in_if_statement7267( FOLLOW_else_part_in_if_statement7267_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_end_key_in_if_statement7278_bits[]	= { ANTLR_UINT64_LIT(0x0008000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_end_key_in_if_statement7278( FOLLOW_end_key_in_if_statement7278_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_if_key_in_if_statement7280_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_if_key_in_if_statement7280( FOLLOW_if_key_in_if_statement7280_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_elsif_key_in_elsif_part7300_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_elsif_key_in_elsif_part7300( FOLLOW_elsif_key_in_elsif_part7300_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_elsif_part7302_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_condition_in_elsif_part7302( FOLLOW_condition_in_elsif_part7302_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_then_key_in_elsif_part7304_bits[]	= { ANTLR_UINT64_LIT(0x00480000D0044200), ANTLR_UINT64_LIT(0x0823601549080400), ANTLR_UINT64_LIT(0x0000000000108048) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_then_key_in_elsif_part7304( FOLLOW_then_key_in_elsif_part7304_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_seq_of_statements_in_elsif_part7306_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_seq_of_statements_in_elsif_part7306( FOLLOW_seq_of_statements_in_elsif_part7306_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_else_key_in_else_part7326_bits[]	= { ANTLR_UINT64_LIT(0x00480000D0044200), ANTLR_UINT64_LIT(0x0823601549080400), ANTLR_UINT64_LIT(0x0000000000108048) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_else_key_in_else_part7326( FOLLOW_else_key_in_else_part7326_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_seq_of_statements_in_else_part7328_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_seq_of_statements_in_else_part7328( FOLLOW_seq_of_statements_in_else_part7328_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_label_name_in_loop_statement7348_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000400000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_label_name_in_loop_statement7348( FOLLOW_label_name_in_loop_statement7348_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_while_key_in_loop_statement7360_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_while_key_in_loop_statement7360( FOLLOW_while_key_in_loop_statement7360_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_loop_statement7362_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_condition_in_loop_statement7362( FOLLOW_condition_in_loop_statement7362_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_for_key_in_loop_statement7366_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_for_key_in_loop_statement7366( FOLLOW_for_key_in_loop_statement7366_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_loop_param_in_loop_statement7368_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_cursor_loop_param_in_loop_statement7368( FOLLOW_cursor_loop_param_in_loop_statement7368_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_loop_key_in_loop_statement7380_bits[]	= { ANTLR_UINT64_LIT(0x00480000D0044200), ANTLR_UINT64_LIT(0x0823601549080400), ANTLR_UINT64_LIT(0x0000000000108048) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_loop_key_in_loop_statement7380( FOLLOW_loop_key_in_loop_statement7380_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_seq_of_statements_in_loop_statement7390_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_seq_of_statements_in_loop_statement7390( FOLLOW_seq_of_statements_in_loop_statement7390_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_end_key_in_loop_statement7400_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_end_key_in_loop_statement7400( FOLLOW_end_key_in_loop_statement7400_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_loop_key_in_loop_statement7402_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_loop_key_in_loop_statement7402( FOLLOW_loop_key_in_loop_statement7402_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_label_name_in_loop_statement7404_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_label_name_in_loop_statement7404( FOLLOW_label_name_in_loop_statement7404_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_index_name_in_cursor_loop_param7454_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0010000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_index_name_in_cursor_loop_param7454( FOLLOW_index_name_in_cursor_loop_param7454_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_cursor_loop_param7456_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_in_key_in_cursor_loop_param7456( FOLLOW_in_key_in_cursor_loop_param7456_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_reverse_key_in_cursor_loop_param7458_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_reverse_key_in_cursor_loop_param7458( FOLLOW_reverse_key_in_cursor_loop_param7458_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_lower_bound_in_cursor_loop_param7461_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_lower_bound_in_cursor_loop_param7461( FOLLOW_lower_bound_in_cursor_loop_param7461_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_DOUBLE_PERIOD_in_cursor_loop_param7463_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_DOUBLE_PERIOD_in_cursor_loop_param7463( FOLLOW_DOUBLE_PERIOD_in_cursor_loop_param7463_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_upper_bound_in_cursor_loop_param7465_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_upper_bound_in_cursor_loop_param7465( FOLLOW_upper_bound_in_cursor_loop_param7465_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_record_name_in_cursor_loop_param7477_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0010000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_record_name_in_cursor_loop_param7477( FOLLOW_record_name_in_cursor_loop_param7477_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_cursor_loop_param7479_bits[]	= { ANTLR_UINT64_LIT(0x0000000050044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_in_key_in_cursor_loop_param7479( FOLLOW_in_key_in_cursor_loop_param7479_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_name_in_cursor_loop_param7483_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_cursor_name_in_cursor_loop_param7483( FOLLOW_cursor_name_in_cursor_loop_param7483_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_cursor_loop_param7485_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_list_in_cursor_loop_param7485( FOLLOW_expression_list_in_cursor_loop_param7485_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_cursor_loop_param7490_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_cursor_loop_param7490( FOLLOW_LEFT_PAREN_in_cursor_loop_param7490_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_cursor_loop_param7492_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_select_statement_in_cursor_loop_param7492( FOLLOW_select_statement_in_cursor_loop_param7492_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_cursor_loop_param7494_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_cursor_loop_param7494( FOLLOW_RIGHT_PAREN_in_cursor_loop_param7494_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_forall_key_in_forall_statement7516_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_forall_key_in_forall_statement7516( FOLLOW_forall_key_in_forall_statement7516_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_index_name_in_forall_statement7518_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0010000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_index_name_in_forall_statement7518( FOLLOW_index_name_in_forall_statement7518_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_forall_statement7520_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000811004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_in_key_in_forall_statement7520( FOLLOW_in_key_in_forall_statement7520_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_bounds_clause_in_forall_statement7522_bits[]	= { ANTLR_UINT64_LIT(0x0040000040000000), ANTLR_UINT64_LIT(0x0020201000000400), ANTLR_UINT64_LIT(0x0000000000108040) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_bounds_clause_in_forall_statement7522( FOLLOW_bounds_clause_in_forall_statement7522_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_sql_statement_in_forall_statement7524_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_sql_statement_in_forall_statement7524( FOLLOW_sql_statement_in_forall_statement7524_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_save_key_in_forall_statement7527_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_save_key_in_forall_statement7527( FOLLOW_save_key_in_forall_statement7527_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exceptions_key_in_forall_statement7529_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exceptions_key_in_forall_statement7529( FOLLOW_exceptions_key_in_forall_statement7529_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_lower_bound_in_bounds_clause7551_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_lower_bound_in_bounds_clause7551( FOLLOW_lower_bound_in_bounds_clause7551_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_DOUBLE_PERIOD_in_bounds_clause7553_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_DOUBLE_PERIOD_in_bounds_clause7553( FOLLOW_DOUBLE_PERIOD_in_bounds_clause7553_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_upper_bound_in_bounds_clause7555_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_upper_bound_in_bounds_clause7555( FOLLOW_upper_bound_in_bounds_clause7555_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_indices_key_in_bounds_clause7566_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1000000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_indices_key_in_bounds_clause7566( FOLLOW_indices_key_in_bounds_clause7566_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_of_key_in_bounds_clause7568_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_of_key_in_bounds_clause7568( FOLLOW_of_key_in_bounds_clause7568_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_collection_name_in_bounds_clause7570_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000002000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_collection_name_in_bounds_clause7570( FOLLOW_collection_name_in_bounds_clause7570_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_between_bound_in_bounds_clause7572_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_between_bound_in_bounds_clause7572( FOLLOW_between_bound_in_bounds_clause7572_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_values_key_in_bounds_clause7584_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1000000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_values_key_in_bounds_clause7584( FOLLOW_values_key_in_bounds_clause7584_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_of_key_in_bounds_clause7586_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_of_key_in_bounds_clause7586( FOLLOW_of_key_in_bounds_clause7586_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_index_name_in_bounds_clause7588_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_index_name_in_bounds_clause7588( FOLLOW_index_name_in_bounds_clause7588_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_between_key_in_between_bound7608_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_between_key_in_between_bound7608( FOLLOW_between_key_in_between_bound7608_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_lower_bound_in_between_bound7610_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_lower_bound_in_between_bound7610( FOLLOW_lower_bound_in_between_bound7610_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_and_key_in_between_bound7612_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_and_key_in_between_bound7612( FOLLOW_and_key_in_between_bound7612_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_upper_bound_in_between_bound7614_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_upper_bound_in_between_bound7614( FOLLOW_upper_bound_in_between_bound7614_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_lower_bound7634_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_concatenation_in_lower_bound7634( FOLLOW_concatenation_in_lower_bound7634_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_upper_bound7654_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_concatenation_in_upper_bound7654( FOLLOW_concatenation_in_upper_bound7654_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_null_key_in_null_statement7674_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_null_key_in_null_statement7674( FOLLOW_null_key_in_null_statement7674_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_raise_key_in_raise_statement7694_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_raise_key_in_raise_statement7694( FOLLOW_raise_key_in_raise_statement7694_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exception_name_in_raise_statement7696_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exception_name_in_raise_statement7696( FOLLOW_exception_name_in_raise_statement7696_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_return_key_in_return_statement7717_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447222), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_return_key_in_return_statement7717( FOLLOW_return_key_in_return_statement7717_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_return_statement7721_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_condition_in_return_statement7721( FOLLOW_condition_in_return_statement7721_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_call_key_in_function_call7742_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_call_key_in_function_call7742( FOLLOW_call_key_in_function_call7742_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_routine_name_in_function_call7745_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_routine_name_in_function_call7745( FOLLOW_routine_name_in_function_call7745_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_function_argument_in_function_call7747_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_function_argument_in_function_call7747( FOLLOW_function_argument_in_function_call7747_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_begin_key_in_body7768_bits[]	= { ANTLR_UINT64_LIT(0x00480000D0044200), ANTLR_UINT64_LIT(0x0823601549080400), ANTLR_UINT64_LIT(0x0000000000108048) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_begin_key_in_body7768( FOLLOW_begin_key_in_body7768_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_seq_of_statements_in_body7778_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000060000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_seq_of_statements_in_body7778( FOLLOW_seq_of_statements_in_body7778_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exception_clause_in_body7788_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exception_clause_in_body7788( FOLLOW_exception_clause_in_body7788_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_end_key_in_body7799_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_end_key_in_body7799( FOLLOW_end_key_in_body7799_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_label_name_in_body7801_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_label_name_in_body7801( FOLLOW_label_name_in_body7801_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exception_key_in_exception_clause7824_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exception_key_in_exception_clause7824( FOLLOW_exception_key_in_exception_clause7824_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exception_handler_in_exception_clause7826_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exception_handler_in_exception_clause7826( FOLLOW_exception_handler_in_exception_clause7826_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_exception_handler7847_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_when_key_in_exception_handler7847( FOLLOW_when_key_in_exception_handler7847_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exception_name_in_exception_handler7849_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x8000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exception_name_in_exception_handler7849( FOLLOW_exception_name_in_exception_handler7849_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_or_key_in_exception_handler7852_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_or_key_in_exception_handler7852( FOLLOW_or_key_in_exception_handler7852_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exception_name_in_exception_handler7854_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x8000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exception_name_in_exception_handler7854( FOLLOW_exception_name_in_exception_handler7854_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_then_key_in_exception_handler7858_bits[]	= { ANTLR_UINT64_LIT(0x00480000D0044200), ANTLR_UINT64_LIT(0x0823601549080400), ANTLR_UINT64_LIT(0x0000000000108048) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_then_key_in_exception_handler7858( FOLLOW_then_key_in_exception_handler7858_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_seq_of_statements_in_exception_handler7868_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_seq_of_statements_in_exception_handler7868( FOLLOW_seq_of_statements_in_exception_handler7868_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_declare_key_in_trigger_block7891_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000140000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_declare_key_in_trigger_block7891( FOLLOW_declare_key_in_trigger_block7891_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_declare_spec_in_trigger_block7894_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000141000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_declare_spec_in_trigger_block7894( FOLLOW_declare_spec_in_trigger_block7894_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_body_in_trigger_block7907_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_body_in_trigger_block7907( FOLLOW_body_in_trigger_block7907_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_declare_key_in_block7927_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000140000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_declare_key_in_block7927( FOLLOW_declare_key_in_block7927_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_declare_spec_in_block7930_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000141000400), ANTLR_UINT64_LIT(0x0000000000000008) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_declare_spec_in_block7930( FOLLOW_declare_spec_in_block7930_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_body_in_block7941_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_body_in_block7941( FOLLOW_body_in_block7941_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_execute_immediate_in_sql_statement7973_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_execute_immediate_in_sql_statement7973( FOLLOW_execute_immediate_in_sql_statement7973_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_data_manipulation_language_statements_in_sql_statement7984_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_data_manipulation_language_statements_in_sql_statement7984( FOLLOW_data_manipulation_language_statements_in_sql_statement7984_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_manipulation_statements_in_sql_statement7995_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_cursor_manipulation_statements_in_sql_statement7995( FOLLOW_cursor_manipulation_statements_in_sql_statement7995_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_transaction_control_statements_in_sql_statement8006_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_transaction_control_statements_in_sql_statement8006( FOLLOW_transaction_control_statements_in_sql_statement8006_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_execute_key_in_execute_immediate8026_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_execute_key_in_execute_immediate8026( FOLLOW_execute_key_in_execute_immediate8026_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_immediate_key_in_execute_immediate8028_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_immediate_key_in_execute_immediate8028( FOLLOW_immediate_key_in_execute_immediate8028_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_execute_immediate8030_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000002), ANTLR_UINT64_LIT(0x0080000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_execute_immediate8030( FOLLOW_expression_in_execute_immediate8030_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_into_clause_in_execute_immediate8041_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_into_clause_in_execute_immediate8041( FOLLOW_into_clause_in_execute_immediate8041_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_using_clause_in_execute_immediate8043_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_using_clause_in_execute_immediate8043( FOLLOW_using_clause_in_execute_immediate8043_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_using_clause_in_execute_immediate8055_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_using_clause_in_execute_immediate8055( FOLLOW_using_clause_in_execute_immediate8055_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_dynamic_returning_clause_in_execute_immediate8057_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_dynamic_returning_clause_in_execute_immediate8057( FOLLOW_dynamic_returning_clause_in_execute_immediate8057_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_dynamic_returning_clause_in_execute_immediate8069_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_dynamic_returning_clause_in_execute_immediate8069( FOLLOW_dynamic_returning_clause_in_execute_immediate8069_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_returning_key_in_dynamic_returning_clause8098_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_returning_key_in_dynamic_returning_clause8098( FOLLOW_returning_key_in_dynamic_returning_clause8098_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_return_key_in_dynamic_returning_clause8100_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_return_key_in_dynamic_returning_clause8100( FOLLOW_return_key_in_dynamic_returning_clause8100_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_into_clause_in_dynamic_returning_clause8103_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_into_clause_in_dynamic_returning_clause8103( FOLLOW_into_clause_in_dynamic_returning_clause8103_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_merge_statement_in_data_manipulation_language_statements8127_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_merge_statement_in_data_manipulation_language_statements8127( FOLLOW_merge_statement_in_data_manipulation_language_statements8127_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_lock_table_statement_in_data_manipulation_language_statements8138_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_lock_table_statement_in_data_manipulation_language_statements8138( FOLLOW_lock_table_statement_in_data_manipulation_language_statements8138_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_data_manipulation_language_statements8149_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_select_statement_in_data_manipulation_language_statements8149( FOLLOW_select_statement_in_data_manipulation_language_statements8149_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_update_statement_in_data_manipulation_language_statements8160_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_update_statement_in_data_manipulation_language_statements8160( FOLLOW_update_statement_in_data_manipulation_language_statements8160_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_delete_statement_in_data_manipulation_language_statements8171_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_delete_statement_in_data_manipulation_language_statements8171( FOLLOW_delete_statement_in_data_manipulation_language_statements8171_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_insert_statement_in_data_manipulation_language_statements8182_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_insert_statement_in_data_manipulation_language_statements8182( FOLLOW_insert_statement_in_data_manipulation_language_statements8182_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_explain_statement_in_data_manipulation_language_statements8193_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_explain_statement_in_data_manipulation_language_statements8193( FOLLOW_explain_statement_in_data_manipulation_language_statements8193_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_close_statement_in_cursor_manipulation_statements8217_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_close_statement_in_cursor_manipulation_statements8217( FOLLOW_close_statement_in_cursor_manipulation_statements8217_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_open_statement_in_cursor_manipulation_statements8228_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_open_statement_in_cursor_manipulation_statements8228( FOLLOW_open_statement_in_cursor_manipulation_statements8228_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_fetch_statement_in_cursor_manipulation_statements8239_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_fetch_statement_in_cursor_manipulation_statements8239( FOLLOW_fetch_statement_in_cursor_manipulation_statements8239_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_open_for_statement_in_cursor_manipulation_statements8250_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_open_for_statement_in_cursor_manipulation_statements8250( FOLLOW_open_for_statement_in_cursor_manipulation_statements8250_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_close_key_in_close_statement8271_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_close_key_in_close_statement8271( FOLLOW_close_key_in_close_statement8271_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_name_in_close_statement8273_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_cursor_name_in_close_statement8273( FOLLOW_cursor_name_in_close_statement8273_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_open_key_in_open_statement8293_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_open_key_in_open_statement8293( FOLLOW_open_key_in_open_statement8293_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_name_in_open_statement8295_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_cursor_name_in_open_statement8295( FOLLOW_cursor_name_in_open_statement8295_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_open_statement8297_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_list_in_open_statement8297( FOLLOW_expression_list_in_open_statement8297_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_fetch_key_in_fetch_statement8318_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_fetch_key_in_fetch_statement8318( FOLLOW_fetch_key_in_fetch_statement8318_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_name_in_fetch_statement8320_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_cursor_name_in_fetch_statement8320( FOLLOW_cursor_name_in_fetch_statement8320_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_into_key_in_fetch_statement8334_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_into_key_in_fetch_statement8334( FOLLOW_into_key_in_fetch_statement8334_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_variable_name_in_fetch_statement8336_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_variable_name_in_fetch_statement8336( FOLLOW_variable_name_in_fetch_statement8336_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_fetch_statement8339_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_fetch_statement8339( FOLLOW_COMMA_in_fetch_statement8339_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_variable_name_in_fetch_statement8341_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_variable_name_in_fetch_statement8341( FOLLOW_variable_name_in_fetch_statement8341_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_bulk_key_in_fetch_statement8355_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_bulk_key_in_fetch_statement8355( FOLLOW_bulk_key_in_fetch_statement8355_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_collect_key_in_fetch_statement8357_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_collect_key_in_fetch_statement8357( FOLLOW_collect_key_in_fetch_statement8357_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_into_key_in_fetch_statement8359_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_into_key_in_fetch_statement8359( FOLLOW_into_key_in_fetch_statement8359_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_variable_name_in_fetch_statement8361_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_variable_name_in_fetch_statement8361( FOLLOW_variable_name_in_fetch_statement8361_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_fetch_statement8364_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_fetch_statement8364( FOLLOW_COMMA_in_fetch_statement8364_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_variable_name_in_fetch_statement8366_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_variable_name_in_fetch_statement8366( FOLLOW_variable_name_in_fetch_statement8366_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_open_key_in_open_for_statement8395_bits[]	= { ANTLR_UINT64_LIT(0x0000000010044200), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_open_key_in_open_for_statement8395( FOLLOW_open_key_in_open_for_statement8395_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_variable_name_in_open_for_statement8397_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_variable_name_in_open_for_statement8397( FOLLOW_variable_name_in_open_for_statement8397_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_for_key_in_open_for_statement8399_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000901044) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_for_key_in_open_for_statement8399( FOLLOW_for_key_in_open_for_statement8399_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_open_for_statement8417_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_select_statement_in_open_for_statement8417( FOLLOW_select_statement_in_open_for_statement8417_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_open_for_statement8428_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_open_for_statement8428( FOLLOW_expression_in_open_for_statement8428_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_using_clause_in_open_for_statement8444_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_using_clause_in_open_for_statement8444( FOLLOW_using_clause_in_open_for_statement8444_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_transaction_command_in_transaction_control_statements8469_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_set_transaction_command_in_transaction_control_statements8469( FOLLOW_set_transaction_command_in_transaction_control_statements8469_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_constraint_command_in_transaction_control_statements8480_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_set_constraint_command_in_transaction_control_statements8480( FOLLOW_set_constraint_command_in_transaction_control_statements8480_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_commit_statement_in_transaction_control_statements8491_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_commit_statement_in_transaction_control_statements8491( FOLLOW_commit_statement_in_transaction_control_statements8491_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_rollback_statement_in_transaction_control_statements8502_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_rollback_statement_in_transaction_control_statements8502( FOLLOW_rollback_statement_in_transaction_control_statements8502_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_savepoint_statement_in_transaction_control_statements8513_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_savepoint_statement_in_transaction_control_statements8513( FOLLOW_savepoint_statement_in_transaction_control_statements8513_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_key_in_set_transaction_command8533_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_set_key_in_set_transaction_command8533( FOLLOW_set_key_in_set_transaction_command8533_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_transaction_key_in_set_transaction_command8535_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_transaction_key_in_set_transaction_command8535( FOLLOW_transaction_key_in_set_transaction_command8535_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_read_key_in_set_transaction_command8547_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_read_key_in_set_transaction_command8547( FOLLOW_read_key_in_set_transaction_command8547_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_only_key_in_set_transaction_command8550_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_only_key_in_set_transaction_command8550( FOLLOW_only_key_in_set_transaction_command8550_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_write_key_in_set_transaction_command8552_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_write_key_in_set_transaction_command8552( FOLLOW_write_key_in_set_transaction_command8552_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_isolation_key_in_set_transaction_command8564_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_isolation_key_in_set_transaction_command8564( FOLLOW_isolation_key_in_set_transaction_command8564_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_level_key_in_set_transaction_command8566_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_level_key_in_set_transaction_command8566( FOLLOW_level_key_in_set_transaction_command8566_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_serializable_key_in_set_transaction_command8569_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_serializable_key_in_set_transaction_command8569( FOLLOW_serializable_key_in_set_transaction_command8569_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_read_key_in_set_transaction_command8571_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_read_key_in_set_transaction_command8571( FOLLOW_read_key_in_set_transaction_command8571_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_committed_key_in_set_transaction_command8573_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_committed_key_in_set_transaction_command8573( FOLLOW_committed_key_in_set_transaction_command8573_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_use_key_in_set_transaction_command8585_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_use_key_in_set_transaction_command8585( FOLLOW_use_key_in_set_transaction_command8585_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_rollback_key_in_set_transaction_command8587_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_rollback_key_in_set_transaction_command8587( FOLLOW_rollback_key_in_set_transaction_command8587_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_segment_key_in_set_transaction_command8589_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_segment_key_in_set_transaction_command8589( FOLLOW_segment_key_in_set_transaction_command8589_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_rollback_segment_name_in_set_transaction_command8591_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_rollback_segment_name_in_set_transaction_command8591( FOLLOW_rollback_segment_name_in_set_transaction_command8591_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_name_key_in_set_transaction_command8609_bits[]	= { ANTLR_UINT64_LIT(0x0000000400003000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_name_key_in_set_transaction_command8609( FOLLOW_name_key_in_set_transaction_command8609_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_set_transaction_command8611_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_quoted_string_in_set_transaction_command8611( FOLLOW_quoted_string_in_set_transaction_command8611_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_key_in_set_constraint_command8633_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_set_key_in_set_constraint_command8633( FOLLOW_set_key_in_set_constraint_command8633_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_constraint_key_in_set_constraint_command8637_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000040400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_constraint_key_in_set_constraint_command8637( FOLLOW_constraint_key_in_set_constraint_command8637_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_constraints_key_in_set_constraint_command8641_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000040400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_constraints_key_in_set_constraint_command8641( FOLLOW_constraints_key_in_set_constraint_command8641_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_set_constraint_command8655_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_all_key_in_set_constraint_command8655( FOLLOW_all_key_in_set_constraint_command8655_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_constraint_name_in_set_constraint_command8659_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_constraint_name_in_set_constraint_command8659( FOLLOW_constraint_name_in_set_constraint_command8659_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_set_constraint_command8662_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_set_constraint_command8662( FOLLOW_COMMA_in_set_constraint_command8662_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_constraint_name_in_set_constraint_command8664_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_constraint_name_in_set_constraint_command8664( FOLLOW_constraint_name_in_set_constraint_command8664_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_immediate_key_in_set_constraint_command8679_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_immediate_key_in_set_constraint_command8679( FOLLOW_immediate_key_in_set_constraint_command8679_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_deferred_key_in_set_constraint_command8681_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_deferred_key_in_set_constraint_command8681( FOLLOW_deferred_key_in_set_constraint_command8681_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_commit_key_in_commit_statement8703_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_commit_key_in_commit_statement8703( FOLLOW_commit_key_in_commit_statement8703_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_work_key_in_commit_statement8705_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_work_key_in_commit_statement8705( FOLLOW_work_key_in_commit_statement8705_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_comment_key_in_commit_statement8717_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_comment_key_in_commit_statement8717( FOLLOW_comment_key_in_commit_statement8717_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_commit_statement8719_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_commit_statement8719( FOLLOW_expression_in_commit_statement8719_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_force_key_in_commit_statement8730_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_force_key_in_commit_statement8730( FOLLOW_force_key_in_commit_statement8730_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_corrupt_xid_key_in_commit_statement8733_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_corrupt_xid_key_in_commit_statement8733( FOLLOW_corrupt_xid_key_in_commit_statement8733_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_commit_statement8735_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_commit_statement8735( FOLLOW_expression_in_commit_statement8735_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_corrupt_xid_all_key_in_commit_statement8738_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_corrupt_xid_all_key_in_commit_statement8738( FOLLOW_corrupt_xid_all_key_in_commit_statement8738_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_commit_statement8742_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_commit_statement8742( FOLLOW_expression_in_commit_statement8742_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_commit_statement8745_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_COMMA_in_commit_statement8745( FOLLOW_COMMA_in_commit_statement8745_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_commit_statement8747_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_expression_in_commit_statement8747( FOLLOW_expression_in_commit_statement8747_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_write_clause_in_commit_statement8767_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_write_clause_in_commit_statement8767( FOLLOW_write_clause_in_commit_statement8767_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_write_key_in_write_clause8788_bits[]	= { ANTLR_UINT64_LIT(0x0400000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_write_key_in_write_clause8788( FOLLOW_write_key_in_write_clause8788_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_wait_key_in_write_clause8791_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_wait_key_in_write_clause8791( FOLLOW_wait_key_in_write_clause8791_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_nowait_key_in_write_clause8793_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_nowait_key_in_write_clause8793( FOLLOW_nowait_key_in_write_clause8793_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_immediate_key_in_write_clause8798_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_immediate_key_in_write_clause8798( FOLLOW_immediate_key_in_write_clause8798_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_batch_key_in_write_clause8800_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_batch_key_in_write_clause8800( FOLLOW_batch_key_in_write_clause8800_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_rollback_key_in_rollback_statement8823_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_rollback_key_in_rollback_statement8823( FOLLOW_rollback_key_in_rollback_statement8823_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_work_key_in_rollback_statement8825_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_work_key_in_rollback_statement8825( FOLLOW_work_key_in_rollback_statement8825_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_to_key_in_rollback_statement8838_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_to_key_in_rollback_statement8838( FOLLOW_to_key_in_rollback_statement8838_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_savepoint_key_in_rollback_statement8840_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_savepoint_key_in_rollback_statement8840( FOLLOW_savepoint_key_in_rollback_statement8840_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_savepoint_name_in_rollback_statement8843_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_savepoint_name_in_rollback_statement8843( FOLLOW_savepoint_name_in_rollback_statement8843_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_force_key_in_rollback_statement8854_bits[]	= { ANTLR_UINT64_LIT(0x0000000400003000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_force_key_in_rollback_statement8854( FOLLOW_force_key_in_rollback_statement8854_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_rollback_statement8856_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_quoted_string_in_rollback_statement8856( FOLLOW_quoted_string_in_rollback_statement8856_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_savepoint_key_in_savepoint_statement8883_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_savepoint_key_in_savepoint_statement8883( FOLLOW_savepoint_key_in_savepoint_statement8883_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_savepoint_name_in_savepoint_statement8885_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_savepoint_name_in_savepoint_statement8885( FOLLOW_savepoint_name_in_savepoint_statement8885_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_function_in_synpred1_PLSQLParser175_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_function_in_synpred1_PLSQLParser175( FOLLOW_alter_function_in_synpred1_PLSQLParser175_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_package_in_synpred2_PLSQLParser186_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_package_in_synpred2_PLSQLParser186( FOLLOW_alter_package_in_synpred2_PLSQLParser186_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_procedure_in_synpred3_PLSQLParser197_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_procedure_in_synpred3_PLSQLParser197( FOLLOW_alter_procedure_in_synpred3_PLSQLParser197_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_sequence_in_synpred4_PLSQLParser208_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_sequence_in_synpred4_PLSQLParser208( FOLLOW_alter_sequence_in_synpred4_PLSQLParser208_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_trigger_in_synpred5_PLSQLParser219_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_trigger_in_synpred5_PLSQLParser219( FOLLOW_alter_trigger_in_synpred5_PLSQLParser219_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_alter_type_in_synpred6_PLSQLParser230_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_alter_type_in_synpred6_PLSQLParser230( FOLLOW_alter_type_in_synpred6_PLSQLParser230_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_function_body_in_synpred7_PLSQLParser242_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_function_body_in_synpred7_PLSQLParser242( FOLLOW_create_function_body_in_synpred7_PLSQLParser242_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_procedure_body_in_synpred8_PLSQLParser253_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_procedure_body_in_synpred8_PLSQLParser253( FOLLOW_create_procedure_body_in_synpred8_PLSQLParser253_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_package_in_synpred9_PLSQLParser264_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_package_in_synpred9_PLSQLParser264( FOLLOW_create_package_in_synpred9_PLSQLParser264_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_sequence_in_synpred10_PLSQLParser282_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_sequence_in_synpred10_PLSQLParser282( FOLLOW_create_sequence_in_synpred10_PLSQLParser282_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_trigger_in_synpred11_PLSQLParser293_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_trigger_in_synpred11_PLSQLParser293( FOLLOW_create_trigger_in_synpred11_PLSQLParser293_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_type_in_synpred12_PLSQLParser304_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_type_in_synpred12_PLSQLParser304( FOLLOW_create_type_in_synpred12_PLSQLParser304_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_function_in_synpred13_PLSQLParser316_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_function_in_synpred13_PLSQLParser316( FOLLOW_drop_function_in_synpred13_PLSQLParser316_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_package_in_synpred14_PLSQLParser327_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_package_in_synpred14_PLSQLParser327( FOLLOW_drop_package_in_synpred14_PLSQLParser327_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_procedure_in_synpred15_PLSQLParser338_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_procedure_in_synpred15_PLSQLParser338( FOLLOW_drop_procedure_in_synpred15_PLSQLParser338_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_sequence_in_synpred16_PLSQLParser349_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_sequence_in_synpred16_PLSQLParser349( FOLLOW_drop_sequence_in_synpred16_PLSQLParser349_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_trigger_in_synpred17_PLSQLParser360_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_trigger_in_synpred17_PLSQLParser360( FOLLOW_drop_trigger_in_synpred17_PLSQLParser360_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_drop_type_in_synpred18_PLSQLParser371_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_drop_type_in_synpred18_PLSQLParser371( FOLLOW_drop_type_in_synpred18_PLSQLParser371_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_variable_declaration_in_synpred19_PLSQLParser1354_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_variable_declaration_in_synpred19_PLSQLParser1354( FOLLOW_variable_declaration_in_synpred19_PLSQLParser1354_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_subtype_declaration_in_synpred20_PLSQLParser1366_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_subtype_declaration_in_synpred20_PLSQLParser1366( FOLLOW_subtype_declaration_in_synpred20_PLSQLParser1366_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exception_declaration_in_synpred22_PLSQLParser1390_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exception_declaration_in_synpred22_PLSQLParser1390( FOLLOW_exception_declaration_in_synpred22_PLSQLParser1390_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_record_declaration_in_synpred23_PLSQLParser1402_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_record_declaration_in_synpred23_PLSQLParser1402( FOLLOW_record_declaration_in_synpred23_PLSQLParser1402_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_table_declaration_in_synpred24_PLSQLParser1414_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_table_declaration_in_synpred24_PLSQLParser1414( FOLLOW_table_declaration_in_synpred24_PLSQLParser1414_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_variable_declaration_in_synpred26_PLSQLParser1586_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_variable_declaration_in_synpred26_PLSQLParser1586( FOLLOW_variable_declaration_in_synpred26_PLSQLParser1586_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_subtype_declaration_in_synpred27_PLSQLParser1599_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_subtype_declaration_in_synpred27_PLSQLParser1599( FOLLOW_subtype_declaration_in_synpred27_PLSQLParser1599_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exception_declaration_in_synpred29_PLSQLParser1625_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exception_declaration_in_synpred29_PLSQLParser1625( FOLLOW_exception_declaration_in_synpred29_PLSQLParser1625_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_record_declaration_in_synpred30_PLSQLParser1638_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_record_declaration_in_synpred30_PLSQLParser1638( FOLLOW_record_declaration_in_synpred30_PLSQLParser1638_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_table_declaration_in_synpred31_PLSQLParser1650_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_table_declaration_in_synpred31_PLSQLParser1650( FOLLOW_table_declaration_in_synpred31_PLSQLParser1650_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_procedure_body_in_synpred32_PLSQLParser1662_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_procedure_body_in_synpred32_PLSQLParser1662( FOLLOW_create_procedure_body_in_synpred32_PLSQLParser1662_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_compound_key_in_synpred33_PLSQLParser2449_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_compound_key_in_synpred33_PLSQLParser2449( FOLLOW_compound_key_in_synpred33_PLSQLParser2449_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_trigger_key_in_synpred33_PLSQLParser2451_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_trigger_key_in_synpred33_PLSQLParser2451( FOLLOW_trigger_key_in_synpred33_PLSQLParser2451_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_call_key_in_synpred34_PLSQLParser2467_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_call_key_in_synpred34_PLSQLParser2467( FOLLOW_call_key_in_synpred34_PLSQLParser2467_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_id_in_synpred34_PLSQLParser2469_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_id_in_synpred34_PLSQLParser2469( FOLLOW_id_in_synpred34_PLSQLParser2469_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_id_in_synpred35_PLSQLParser4586_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_id_in_synpred35_PLSQLParser4586( FOLLOW_id_in_synpred35_PLSQLParser4586_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_synpred35_PLSQLParser4588_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_type_spec_in_synpred35_PLSQLParser4588( FOLLOW_type_spec_in_synpred35_PLSQLParser4588_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_sqlj_object_type_attr_in_synpred35_PLSQLParser4590_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_sqlj_object_type_attr_in_synpred35_PLSQLParser4590( FOLLOW_sqlj_object_type_attr_in_synpred35_PLSQLParser4590_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_variable_declaration_in_synpred36_PLSQLParser5780_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_variable_declaration_in_synpred36_PLSQLParser5780( FOLLOW_variable_declaration_in_synpred36_PLSQLParser5780_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_subtype_declaration_in_synpred37_PLSQLParser5792_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_subtype_declaration_in_synpred37_PLSQLParser5792( FOLLOW_subtype_declaration_in_synpred37_PLSQLParser5792_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exception_declaration_in_synpred39_PLSQLParser5816_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exception_declaration_in_synpred39_PLSQLParser5816( FOLLOW_exception_declaration_in_synpred39_PLSQLParser5816_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_pragma_declaration_in_synpred40_PLSQLParser5828_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_pragma_declaration_in_synpred40_PLSQLParser5828( FOLLOW_pragma_declaration_in_synpred40_PLSQLParser5828_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_record_declaration_in_synpred41_PLSQLParser5840_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_record_declaration_in_synpred41_PLSQLParser5840( FOLLOW_record_declaration_in_synpred41_PLSQLParser5840_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_table_declaration_in_synpred42_PLSQLParser5852_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_table_declaration_in_synpred42_PLSQLParser5852( FOLLOW_table_declaration_in_synpred42_PLSQLParser5852_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_procedure_body_in_synpred43_PLSQLParser5864_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_procedure_body_in_synpred43_PLSQLParser5864( FOLLOW_create_procedure_body_in_synpred43_PLSQLParser5864_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_create_key_in_synpred44_PLSQLParser6871_bits[]	= { ANTLR_UINT64_LIT(0xFFFFFFFFFFFFFFF0), ANTLR_UINT64_LIT(0xFFFFFFFFFFFFDFFF), ANTLR_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR_UINT64_LIT(0x0000000000001FFF) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_create_key_in_synpred44_PLSQLParser6871( FOLLOW_create_key_in_synpred44_PLSQLParser6871_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_swallow_to_semi_in_synpred44_PLSQLParser6873_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_swallow_to_semi_in_synpred44_PLSQLParser6873( FOLLOW_swallow_to_semi_in_synpred44_PLSQLParser6873_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_synpred44_PLSQLParser6875_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_set_in_synpred44_PLSQLParser6875( FOLLOW_set_in_synpred44_PLSQLParser6875_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_truncate_key_in_synpred47_PLSQLParser6930_bits[]	= { ANTLR_UINT64_LIT(0xFFFFFFFFFFFFFFF0), ANTLR_UINT64_LIT(0xFFFFFFFFFFFFDFFF), ANTLR_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR_UINT64_LIT(0xFFFFFFFFFFFFFFFF), ANTLR_UINT64_LIT(0x0000000000001FFF) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_truncate_key_in_synpred47_PLSQLParser6930( FOLLOW_truncate_key_in_synpred47_PLSQLParser6930_bits, 5 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_swallow_to_semi_in_synpred47_PLSQLParser6932_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_swallow_to_semi_in_synpred47_PLSQLParser6932( FOLLOW_swallow_to_semi_in_synpred47_PLSQLParser6932_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_synpred47_PLSQLParser6935_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_set_in_synpred47_PLSQLParser6935( FOLLOW_set_in_synpred47_PLSQLParser6935_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_begin_key_in_synpred48_PLSQLParser6951_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_begin_key_in_synpred48_PLSQLParser6951( FOLLOW_begin_key_in_synpred48_PLSQLParser6951_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_declare_key_in_synpred49_PLSQLParser6968_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_declare_key_in_synpred49_PLSQLParser6968( FOLLOW_declare_key_in_synpred49_PLSQLParser6968_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_assignment_statement_in_synpred50_PLSQLParser6984_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_assignment_statement_in_synpred50_PLSQLParser6984( FOLLOW_assignment_statement_in_synpred50_PLSQLParser6984_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_continue_statement_in_synpred51_PLSQLParser6995_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_continue_statement_in_synpred51_PLSQLParser6995( FOLLOW_continue_statement_in_synpred51_PLSQLParser6995_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_exit_statement_in_synpred52_PLSQLParser7006_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_exit_statement_in_synpred52_PLSQLParser7006( FOLLOW_exit_statement_in_synpred52_PLSQLParser7006_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_loop_statement_in_synpred55_PLSQLParser7039_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_loop_statement_in_synpred55_PLSQLParser7039( FOLLOW_loop_statement_in_synpred55_PLSQLParser7039_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_forall_statement_in_synpred56_PLSQLParser7050_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_forall_statement_in_synpred56_PLSQLParser7050( FOLLOW_forall_statement_in_synpred56_PLSQLParser7050_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_raise_statement_in_synpred58_PLSQLParser7072_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_raise_statement_in_synpred58_PLSQLParser7072( FOLLOW_raise_statement_in_synpred58_PLSQLParser7072_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_return_statement_in_synpred59_PLSQLParser7083_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_return_statement_in_synpred59_PLSQLParser7083( FOLLOW_return_statement_in_synpred59_PLSQLParser7083_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_case_statement_in_synpred60_PLSQLParser7094_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_case_statement_in_synpred60_PLSQLParser7094( FOLLOW_case_statement_in_synpred60_PLSQLParser7094_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_sql_statement_in_synpred61_PLSQLParser7106_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_sql_statement_in_synpred61_PLSQLParser7106( FOLLOW_sql_statement_in_synpred61_PLSQLParser7106_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_index_name_in_synpred62_PLSQLParser7428_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0010000000000000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_index_name_in_synpred62_PLSQLParser7428( FOLLOW_index_name_in_synpred62_PLSQLParser7428_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_synpred62_PLSQLParser7430_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_in_key_in_synpred62_PLSQLParser7430( FOLLOW_in_key_in_synpred62_PLSQLParser7430_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_reverse_key_in_synpred62_PLSQLParser7432_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_reverse_key_in_synpred62_PLSQLParser7432( FOLLOW_reverse_key_in_synpred62_PLSQLParser7432_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_lower_bound_in_synpred62_PLSQLParser7435_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_lower_bound_in_synpred62_PLSQLParser7435( FOLLOW_lower_bound_in_synpred62_PLSQLParser7435_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_DOUBLE_PERIOD_in_synpred62_PLSQLParser7437_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_DOUBLE_PERIOD_in_synpred62_PLSQLParser7437( FOLLOW_DOUBLE_PERIOD_in_synpred62_PLSQLParser7437_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_manipulation_statements_in_synpred65_PLSQLParser7995_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_cursor_manipulation_statements_in_synpred65_PLSQLParser7995( FOLLOW_cursor_manipulation_statements_in_synpred65_PLSQLParser7995_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred66_PLSQLParser8411_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred66_PLSQLParser8411( FOLLOW_select_key_in_synpred66_PLSQLParser8411_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred66_PLSQLParser8413_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParserImplTraits::BitsetListType FOLLOW_with_key_in_synpred66_PLSQLParser8413( FOLLOW_with_key_in_synpred66_PLSQLParser8413_bits, 1 );



/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    304:69: ( referencing_clause )?
 */
static const ANTLR_INT32 dfa74_eot[39] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1
    };
static const ANTLR_INT32 dfa74_eof[39] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1
    };
static const ANTLR_INT32 dfa74_min[39] =
    {
	9, 9, -1, 6, -1, -1, -1, -1, -1, 18, 0, -1, 6, -1, -1, -1, -1, -1, -1, 
	18, 0, 6, -1, -1, -1, -1, 18, 8, 18, -1, 18, 0, -1, -1, -1, 6, 18, -1, 
	6
    };
static const ANTLR_INT32 dfa74_max[39] =
    {
	146, 146, -1, 148, -1, -1, -1, -1, -1, 74, 0, -1, 146, -1, -1, -1, -1, 
	-1, -1, 74, 0, 122, -1, -1, -1, -1, 74, 146, 74, -1, 74, 0, -1, -1, -1, 
	122, 74, -1, 122
    };
static const ANTLR_INT32 dfa74_accept[39] =
    {
	-1, -1, 2, -1, 2, 2, 2, 2, 1, -1, -1, 2, -1, 2, 2, 2, 2, 2, 2, -1, -1, 
	-1, 2, 2, 2, 2, -1, -1, -1, 2, -1, -1, 2, 2, 2, -1, -1, 2, -1
    };
static const ANTLR_INT32 dfa74_special[39] =
    {
	-1, 10, -1, 11, -1, -1, -1, -1, -1, 7, 1, -1, 0, -1, -1, -1, -1, -1, -1, 
	3, 14, 5, -1, -1, -1, -1, 8, 15, 9, -1, 2, 13, -1, -1, -1, 4, 6, -1, 12
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa74_T_empty	 =   NULL;

static const ANTLR_INT32 dfa74_T0[] =
    {
	24, -1, 23, 8, -1, -1, -1, -1, 8, -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 8, -1, 23, -1, -1, -1, -1, -1, -1, 24, 18, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 20, -1, -1, 24, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, 8, -1, 8, 22, 
	8, 24, -1, -1, -1, -1, -1, -1, 22, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 25, -1, 24, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8
    };

static const ANTLR_INT32 dfa74_T1[] =
    {
	-1
    };

static const ANTLR_INT32 dfa74_T2[] =
    {
	27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 27
    };

static const ANTLR_INT32 dfa74_T3[] =
    {
	37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 29, 36, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, 37, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 8, -1, 37, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 37
    };

static const ANTLR_INT32 dfa74_T4[] =
    {
	29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 29, 28, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, 29, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 8, -1, 29, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 29
    };

static const ANTLR_INT32 dfa74_T5[] =
    {
	38, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 38
    };

static const ANTLR_INT32 dfa74_T6[] =
    {
	19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 19
    };

static const ANTLR_INT32 dfa74_T7[] =
    {
	30, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 30
    };

static const ANTLR_INT32 dfa74_T8[] =
    {
	35, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 35
    };

static const ANTLR_INT32 dfa74_T9[] =
    {
	6, -1, -1, -1, -1, 6, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1, 6, -1, 6, 7, 6, -1, -1, -1, 
	-1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 6
    };

static const ANTLR_INT32 dfa74_T10[] =
    {
	18, -1, 17, 13, -1, -1, 8, 8, 13, 11, -1, -1, 12, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 9, -1, 18, -1, -1, -1, 8, -1, -1, 18, 7, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, 18, -1, -1, 
	-1, -1, -1, -1, -1, -1, 8, -1, 14, -1, -1, -1, -1, -1, 13, -1, 13, 15, 
	11, 18, -1, -1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 18, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, 13, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, 18
    };

static const ANTLR_INT32 dfa74_T11[] =
    {
	37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 29, 36, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 37, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 37, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 37
    };

static const ANTLR_INT32 dfa74_T12[] =
    {
	2, -1, -1, -1, -1, 2, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, 2, -1, 2, -1, 2, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 2
    };

static const ANTLR_INT32 dfa74_T13[] =
    {
	23, 8, -1, -1, -1, -1, 8, -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 8, -1, 34, -1, -1, -1, -1, -1, -1, -1, 32, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 31, -1, -1, 34, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, 8, -1, 8, 22, 8, -1, 
	-1, -1, -1, -1, -1, -1, 33, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa74_transitions[] =
{
    dfa74_T12, dfa74_T9, NULL, dfa74_T10, NULL, NULL, NULL, NULL, NULL, 
    dfa74_T6, dfa74_T1, NULL, dfa74_T0, NULL, NULL, NULL, NULL, NULL, NULL, 
    dfa74_T2, dfa74_T1, dfa74_T4, NULL, NULL, NULL, NULL, dfa74_T7, dfa74_T13, 
    dfa74_T8, NULL, dfa74_T2, dfa74_T1, NULL, NULL, NULL, dfa74_T3, dfa74_T5, 
    NULL, dfa74_T11
};


/* Declare tracking structure for Cyclic DFA 74
 */
class PLSQLParserCyclicDFA74 : public CyclicDFA< PLSQLParserImplTraits, PLSQLParser >, public PLSQLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParserImplTraits, PLSQLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParserCyclicDFA74( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA74_12;

	    		    ANTLR_MARKER index74_12;


	    		    LA74_12 = ctx->LA(1);

	    		     
	    		        index74_12 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA74_12 == BINDVAR || LA74_12 == COLON || LA74_12 == INTRODUCER || LA74_12 == SQL92_RESERVED_BEGIN || LA74_12 == SQL92_RESERVED_CREATE || LA74_12 == SQL92_RESERVED_CURSOR || LA74_12 == SQL92_RESERVED_DECLARE || LA74_12 == SQL92_RESERVED_FOR || LA74_12 == SQL92_RESERVED_PROCEDURE || LA74_12 == SQL92_RESERVED_WHEN) && ((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA74_12 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 20;
	    		    }

	    		    else if ( (LA74_12 == DELIMITED_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))))) )
	    		    {
	    		        s = 21;
	    		    }

	    		    else if ( (LA74_12 == PERIOD)  )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA74_12 == SQL92_RESERVED_DATE || LA74_12 == SQL92_RESERVED_EXCEPTION) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))))) )
	    		    {
	    		        s = 22;
	    		    }

	    		    else if ( (LA74_12 == AT_SIGN || LA74_12 == LEFT_PAREN) && ((((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 23;
	    		    }

	    		    else if ( (LA74_12 == ASSIGN_OP || LA74_12 == PERCENT || LA74_12 == SEMICOLON || LA74_12 == SQL92_RESERVED_DEFAULT || LA74_12 == SQL92_RESERVED_NOT)  )
	    		    {
	    		        s = 24;
	    		    }

	    		    else if ( (LA74_12 == SQL92_RESERVED_IS) && ((((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 25;
	    		    }

	    			 
	    				ctx->seek(index74_12);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA74_10;

	    		    ANTLR_MARKER index74_10;


	    		    LA74_10 = ctx->LA(1);

	    		     
	    		        index74_10 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))  )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (true)  )
	    		    {
	    		        s = 18;
	    		    }

	    			 
	    				ctx->seek(index74_10);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA74_30;

	    		    ANTLR_MARKER index74_30;


	    		    LA74_30 = ctx->LA(1);

	    		     
	    		        index74_30 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA74_30 == DELIMITED_ID || LA74_30 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 27;
	    		    }

	    		    else if ( (LA74_30 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))))) )
	    		    {
	    		        s = 26;
	    		    }

	    			 
	    				ctx->seek(index74_30);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA74_19;

	    		    ANTLR_MARKER index74_19;


	    		    LA74_19 = ctx->LA(1);

	    		     
	    		        index74_19 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA74_19 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))))) )
	    		    {
	    		        s = 26;
	    		    }

	    		    else if ( (LA74_19 == DELIMITED_ID || LA74_19 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 27;
	    		    }

	    			 
	    				ctx->seek(index74_19);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA74_35;

	    		    ANTLR_MARKER index74_35;


	    		    LA74_35 = ctx->LA(1);

	    		     
	    		        index74_35 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA74_35 == DELIMITED_ID || LA74_35 == REGULAR_ID || LA74_35 == SQL92_RESERVED_DATE || LA74_35 == SQL92_RESERVED_EXCEPTION) && ((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA74_35 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))))) )
	    		    {
	    		        s = 36;
	    		    }

	    		    else if ( (LA74_35 == PERCENT) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))))) )
	    		    {
	    		        s = 29;
	    		    }

	    		    else if ( (LA74_35 == ASSIGN_OP || LA74_35 == SEMICOLON || LA74_35 == SQL92_RESERVED_DEFAULT || LA74_35 == SQL92_RESERVED_NOT) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))))) )
	    		    {
	    		        s = 37;
	    		    }

	    			 
	    				ctx->seek(index74_35);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA74_21;

	    		    ANTLR_MARKER index74_21;


	    		    LA74_21 = ctx->LA(1);

	    		     
	    		        index74_21 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA74_21 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))))) )
	    		    {
	    		        s = 28;
	    		    }

	    		    else if ( (LA74_21 == DELIMITED_ID || LA74_21 == REGULAR_ID || LA74_21 == SQL92_RESERVED_DATE || LA74_21 == SQL92_RESERVED_EXCEPTION) && ((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA74_21 == ASSIGN_OP || LA74_21 == PERCENT || LA74_21 == SEMICOLON || LA74_21 == SQL92_RESERVED_DEFAULT || LA74_21 == SQL92_RESERVED_NOT) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))))) )
	    		    {
	    		        s = 29;
	    		    }

	    			 
	    				ctx->seek(index74_21);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA74_36;

	    		    ANTLR_MARKER index74_36;


	    		    LA74_36 = ctx->LA(1);

	    		     
	    		        index74_36 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA74_36 == DELIMITED_ID || LA74_36 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))))) )
	    		    {
	    		        s = 38;
	    		    }

	    			 
	    				ctx->seek(index74_36);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 7:

	    		{
	    		    ANTLR_UINT32 LA74_9;

	    		    ANTLR_MARKER index74_9;


	    		    LA74_9 = ctx->LA(1);

	    		     
	    		        index74_9 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA74_9 == DELIMITED_ID || LA74_9 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 19;
	    		    }

	    			 
	    				ctx->seek(index74_9);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 8:

	    		{
	    		    ANTLR_UINT32 LA74_26;

	    		    ANTLR_MARKER index74_26;


	    		    LA74_26 = ctx->LA(1);

	    		     
	    		        index74_26 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA74_26 == DELIMITED_ID || LA74_26 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 30;
	    		    }

	    			 
	    				ctx->seek(index74_26);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 9:

	    		{
	    		    ANTLR_UINT32 LA74_28;

	    		    ANTLR_MARKER index74_28;


	    		    LA74_28 = ctx->LA(1);

	    		     
	    		        index74_28 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA74_28 == DELIMITED_ID || LA74_28 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))))) )
	    		    {
	    		        s = 35;
	    		    }

	    			 
	    				ctx->seek(index74_28);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 10:

	    		{
	    		    ANTLR_UINT32 LA74_1;

	    		    ANTLR_MARKER index74_1;


	    		    LA74_1 = ctx->LA(1);

	    		     
	    		        index74_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA74_1 == REGULAR_ID)  )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA74_1 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))||((equalsIgnoreCase(LT(1)->getText(), "FUNCTION")))||((equalsIgnoreCase(LT(1)->getText(), "CALL"))))) )
	    		    {
	    		        s = 4;
	    		    }

	    		    else if ( (LA74_1 == DELIMITED_ID)  )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( (LA74_1 == BINDVAR || LA74_1 == COLON || LA74_1 == SQL92_RESERVED_BEGIN || LA74_1 == SQL92_RESERVED_CREATE || LA74_1 == SQL92_RESERVED_CURSOR || LA74_1 == SQL92_RESERVED_DECLARE || LA74_1 == SQL92_RESERVED_PROCEDURE || LA74_1 == SQL92_RESERVED_WHEN) && ((((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA74_1 == PERIOD || LA74_1 == SQL92_RESERVED_DATE || LA74_1 == SQL92_RESERVED_EXCEPTION)  )
	    		    {
	    		        s = 7;
	    		    }

	    			 
	    				ctx->seek(index74_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 11:

	    		{
	    		    ANTLR_UINT32 LA74_3;

	    		    ANTLR_MARKER index74_3;


	    		    LA74_3 = ctx->LA(1);

	    		     
	    		        index74_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (((LA74_3 >= CHAR_STRING) && (LA74_3 <= CHAR_STRING_PERL)) || LA74_3 == NATIONAL_CHAR_STRING_LIT || LA74_3 == SQL92_RESERVED_AS) && ((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA74_3 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA74_3 == REGULAR_ID)  )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA74_3 == PERIOD)  )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( (LA74_3 == COMMA || LA74_3 == SQL92_RESERVED_DECLARE || LA74_3 == SQL92_RESERVED_WHEN) && ((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS"))) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA74_3 == DELIMITED_ID)  )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA74_3 == BINDVAR || LA74_3 == COLON || LA74_3 == SQL92_RESERVED_CREATE || LA74_3 == SQL92_RESERVED_CURSOR || LA74_3 == SQL92_RESERVED_PROCEDURE) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))))) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( (LA74_3 == SQL92_RESERVED_BEGIN) && ((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS"))) )
	    		    {
	    		        s = 14;
	    		    }

	    		    else if ( (LA74_3 == SQL92_RESERVED_DATE)  )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA74_3 == SQL92_RESERVED_EXCEPTION) && ((((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 16;
	    		    }

	    		    else if ( (LA74_3 == AT_SIGN) && ((equalsIgnoreCase(LT(1)->getText(), "CALL"))) )
	    		    {
	    		        s = 17;
	    		    }

	    		    else if ( (LA74_3 == ASSIGN_OP || LA74_3 == LEFT_PAREN || LA74_3 == PERCENT || LA74_3 == SEMICOLON || LA74_3 == SQL92_RESERVED_DEFAULT || LA74_3 == SQL92_RESERVED_IS || LA74_3 == SQL92_RESERVED_NOT || LA74_3 == SQL92_RESERVED_WITH)  )
	    		    {
	    		        s = 18;
	    		    }

	    			 
	    				ctx->seek(index74_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 12:

	    		{
	    		    ANTLR_UINT32 LA74_38;

	    		    ANTLR_MARKER index74_38;


	    		    LA74_38 = ctx->LA(1);

	    		     
	    		        index74_38 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA74_38 == SQL92_RESERVED_EXCEPTION) && ((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA74_38 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))))) )
	    		    {
	    		        s = 36;
	    		    }

	    		    else if ( (LA74_38 == PERCENT) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))))) )
	    		    {
	    		        s = 29;
	    		    }

	    		    else if ( (LA74_38 == ASSIGN_OP || LA74_38 == SEMICOLON || LA74_38 == SQL92_RESERVED_DEFAULT || LA74_38 == SQL92_RESERVED_NOT) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))))) )
	    		    {
	    		        s = 37;
	    		    }

	    			 
	    				ctx->seek(index74_38);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 13:

	    		{
	    		    ANTLR_UINT32 LA74_31;

	    		    ANTLR_MARKER index74_31;


	    		    LA74_31 = ctx->LA(1);

	    		     
	    		        index74_31 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))  )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))))  )
	    		    {
	    		        s = 34;
	    		    }

	    			 
	    				ctx->seek(index74_31);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 14:

	    		{
	    		    ANTLR_UINT32 LA74_20;

	    		    ANTLR_MARKER index74_20;


	    		    LA74_20 = ctx->LA(1);

	    		     
	    		        index74_20 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))  )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))))  )
	    		    {
	    		        s = 25;
	    		    }

	    			 
	    				ctx->seek(index74_20);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 15:

	    		{
	    		    ANTLR_UINT32 LA74_27;

	    		    ANTLR_MARKER index74_27;


	    		    LA74_27 = ctx->LA(1);

	    		     
	    		        index74_27 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA74_27 == BINDVAR || LA74_27 == COLON || LA74_27 == INTRODUCER || LA74_27 == SQL92_RESERVED_BEGIN || LA74_27 == SQL92_RESERVED_CREATE || LA74_27 == SQL92_RESERVED_CURSOR || LA74_27 == SQL92_RESERVED_DECLARE || LA74_27 == SQL92_RESERVED_FOR || LA74_27 == SQL92_RESERVED_PROCEDURE || LA74_27 == SQL92_RESERVED_WHEN) && ((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA74_27 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 31;
	    		    }

	    		    else if ( (LA74_27 == DELIMITED_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))))) )
	    		    {
	    		        s = 21;
	    		    }

	    		    else if ( (LA74_27 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 32;
	    		    }

	    		    else if ( (LA74_27 == SQL92_RESERVED_DATE) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))))) )
	    		    {
	    		        s = 22;
	    		    }

	    		    else if ( (LA74_27 == SQL92_RESERVED_EXCEPTION) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))))) )
	    		    {
	    		        s = 33;
	    		    }

	    		    else if ( (LA74_27 == AT_SIGN) && ((((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 23;
	    		    }

	    		    else if ( (LA74_27 == LEFT_PAREN || LA74_27 == SEMICOLON) && ((((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 34;
	    		    }

	    			 
	    				ctx->seek(index74_27);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "304:69: ( referencing_clause )?" );
	    ex->set_decisionNum( 74 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParserCyclicDFA74  cdfa74(
	    74,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"304:69: ( referencing_clause )?",
	    dfa74_eot,	    /* EOT table			    */
	    dfa74_eof,	    /* EOF table			    */
	    dfa74_min,	    /* Minimum tokens for each state    */
	    dfa74_max,	    /* Maximum tokens for each state    */
	    dfa74_accept,	/* Accept table			    */
	    dfa74_special,	/* Special transition states	    */
	    dfa74_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 74
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    312:35: ( referencing_clause )?
 */
static const ANTLR_INT32 dfa76_eot[39] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1
    };
static const ANTLR_INT32 dfa76_eof[39] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1
    };
static const ANTLR_INT32 dfa76_min[39] =
    {
	9, 9, -1, 6, -1, -1, -1, -1, -1, 18, 0, -1, 6, -1, -1, -1, -1, -1, -1, 
	18, 0, 6, -1, -1, -1, -1, 18, 8, 18, -1, 18, 0, -1, -1, -1, 6, 18, -1, 
	6
    };
static const ANTLR_INT32 dfa76_max[39] =
    {
	146, 146, -1, 148, -1, -1, -1, -1, -1, 74, 0, -1, 146, -1, -1, -1, -1, 
	-1, -1, 74, 0, 122, -1, -1, -1, -1, 74, 146, 74, -1, 74, 0, -1, -1, -1, 
	122, 74, -1, 122
    };
static const ANTLR_INT32 dfa76_accept[39] =
    {
	-1, -1, 2, -1, 2, 2, 2, 2, 1, -1, -1, 2, -1, 2, 2, 2, 2, 2, 2, -1, -1, 
	-1, 2, 2, 2, 2, -1, -1, -1, 2, -1, -1, 2, 2, 2, -1, -1, 2, -1
    };
static const ANTLR_INT32 dfa76_special[39] =
    {
	-1, 11, -1, 12, -1, -1, -1, -1, -1, 8, 2, -1, 7, -1, -1, -1, -1, -1, -1, 
	3, 15, 5, -1, -1, -1, -1, 9, 0, 10, -1, 1, 14, -1, -1, -1, 4, 6, -1, 13
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa76_T_empty	 =   NULL;

static const ANTLR_INT32 dfa76_T0[] =
    {
	23, 8, -1, -1, -1, -1, 8, -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 8, -1, 34, -1, -1, -1, -1, -1, -1, -1, 32, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 31, -1, -1, 34, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, 8, -1, 8, 22, 8, -1, 
	-1, -1, -1, -1, -1, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8
    };

static const ANTLR_INT32 dfa76_T1[] =
    {
	27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 27
    };

static const ANTLR_INT32 dfa76_T2[] =
    {
	-1
    };

static const ANTLR_INT32 dfa76_T3[] =
    {
	37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 29, 36, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, 37, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 8, -1, 37, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 37
    };

static const ANTLR_INT32 dfa76_T4[] =
    {
	29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 29, 28, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, 29, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 8, -1, 29, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 29
    };

static const ANTLR_INT32 dfa76_T5[] =
    {
	38, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 38
    };

static const ANTLR_INT32 dfa76_T6[] =
    {
	24, -1, 23, 8, -1, -1, -1, -1, 8, -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 8, -1, 23, -1, -1, -1, -1, -1, -1, 24, 18, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 20, -1, -1, 24, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, 8, -1, 8, 22, 
	8, 24, -1, -1, -1, -1, -1, -1, 22, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 25, -1, 24, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8
    };

static const ANTLR_INT32 dfa76_T7[] =
    {
	19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 19
    };

static const ANTLR_INT32 dfa76_T8[] =
    {
	30, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 30
    };

static const ANTLR_INT32 dfa76_T9[] =
    {
	35, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 35
    };

static const ANTLR_INT32 dfa76_T10[] =
    {
	6, -1, -1, -1, -1, 6, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1, 6, -1, 6, 7, 6, -1, -1, -1, 
	-1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 6
    };

static const ANTLR_INT32 dfa76_T11[] =
    {
	2, -1, -1, -1, -1, 2, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, 2, -1, 2, -1, 2, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 2
    };

static const ANTLR_INT32 dfa76_T12[] =
    {
	18, -1, 17, 13, -1, -1, 8, 8, 13, 11, -1, -1, 12, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 9, -1, 18, -1, -1, -1, 8, -1, -1, 18, 7, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, 18, -1, -1, 
	-1, -1, -1, -1, -1, -1, 8, -1, 14, -1, -1, -1, -1, -1, 13, -1, 13, 15, 
	11, 18, -1, -1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 18, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, 13, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, 18
    };

static const ANTLR_INT32 dfa76_T13[] =
    {
	37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 29, 36, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 37, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 37, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 37
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa76_transitions[] =
{
    dfa76_T11, dfa76_T10, NULL, dfa76_T12, NULL, NULL, NULL, NULL, NULL, 
    dfa76_T7, dfa76_T2, NULL, dfa76_T6, NULL, NULL, NULL, NULL, NULL, NULL, 
    dfa76_T1, dfa76_T2, dfa76_T4, NULL, NULL, NULL, NULL, dfa76_T8, dfa76_T0, 
    dfa76_T9, NULL, dfa76_T1, dfa76_T2, NULL, NULL, NULL, dfa76_T3, dfa76_T5, 
    NULL, dfa76_T13
};


/* Declare tracking structure for Cyclic DFA 76
 */
class PLSQLParserCyclicDFA76 : public CyclicDFA< PLSQLParserImplTraits, PLSQLParser >, public PLSQLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParserImplTraits, PLSQLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParserCyclicDFA76( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA76_27;

	    		    ANTLR_MARKER index76_27;


	    		    LA76_27 = ctx->LA(1);

	    		     
	    		        index76_27 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA76_27 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 31;
	    		    }

	    		    else if ( (LA76_27 == BINDVAR || LA76_27 == COLON || LA76_27 == INTRODUCER || LA76_27 == SQL92_RESERVED_BEGIN || LA76_27 == SQL92_RESERVED_CREATE || LA76_27 == SQL92_RESERVED_CURSOR || LA76_27 == SQL92_RESERVED_DECLARE || LA76_27 == SQL92_RESERVED_PROCEDURE || LA76_27 == SQL92_RESERVED_WHEN) && ((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA76_27 == DELIMITED_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))))) )
	    		    {
	    		        s = 21;
	    		    }

	    		    else if ( (LA76_27 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 32;
	    		    }

	    		    else if ( (LA76_27 == SQL92_RESERVED_DATE) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))))) )
	    		    {
	    		        s = 22;
	    		    }

	    		    else if ( (LA76_27 == SQL92_RESERVED_EXCEPTION) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))))) )
	    		    {
	    		        s = 33;
	    		    }

	    		    else if ( (LA76_27 == AT_SIGN) && ((((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 23;
	    		    }

	    		    else if ( (LA76_27 == LEFT_PAREN || LA76_27 == SEMICOLON) && ((((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 34;
	    		    }

	    			 
	    				ctx->seek(index76_27);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA76_30;

	    		    ANTLR_MARKER index76_30;


	    		    LA76_30 = ctx->LA(1);

	    		     
	    		        index76_30 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA76_30 == DELIMITED_ID || LA76_30 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 27;
	    		    }

	    		    else if ( (LA76_30 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))))) )
	    		    {
	    		        s = 26;
	    		    }

	    			 
	    				ctx->seek(index76_30);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA76_10;

	    		    ANTLR_MARKER index76_10;


	    		    LA76_10 = ctx->LA(1);

	    		     
	    		        index76_10 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))  )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (true)  )
	    		    {
	    		        s = 18;
	    		    }

	    			 
	    				ctx->seek(index76_10);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA76_19;

	    		    ANTLR_MARKER index76_19;


	    		    LA76_19 = ctx->LA(1);

	    		     
	    		        index76_19 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA76_19 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))))) )
	    		    {
	    		        s = 26;
	    		    }

	    		    else if ( (LA76_19 == DELIMITED_ID || LA76_19 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 27;
	    		    }

	    			 
	    				ctx->seek(index76_19);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA76_35;

	    		    ANTLR_MARKER index76_35;


	    		    LA76_35 = ctx->LA(1);

	    		     
	    		        index76_35 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA76_35 == DELIMITED_ID || LA76_35 == REGULAR_ID || LA76_35 == SQL92_RESERVED_DATE || LA76_35 == SQL92_RESERVED_EXCEPTION) && ((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA76_35 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))))) )
	    		    {
	    		        s = 36;
	    		    }

	    		    else if ( (LA76_35 == PERCENT) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))))) )
	    		    {
	    		        s = 29;
	    		    }

	    		    else if ( (LA76_35 == ASSIGN_OP || LA76_35 == SEMICOLON || LA76_35 == SQL92_RESERVED_DEFAULT || LA76_35 == SQL92_RESERVED_NOT) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))))) )
	    		    {
	    		        s = 37;
	    		    }

	    			 
	    				ctx->seek(index76_35);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA76_21;

	    		    ANTLR_MARKER index76_21;


	    		    LA76_21 = ctx->LA(1);

	    		     
	    		        index76_21 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA76_21 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))))) )
	    		    {
	    		        s = 28;
	    		    }

	    		    else if ( (LA76_21 == DELIMITED_ID || LA76_21 == REGULAR_ID || LA76_21 == SQL92_RESERVED_DATE || LA76_21 == SQL92_RESERVED_EXCEPTION) && ((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA76_21 == ASSIGN_OP || LA76_21 == PERCENT || LA76_21 == SEMICOLON || LA76_21 == SQL92_RESERVED_DEFAULT || LA76_21 == SQL92_RESERVED_NOT) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))))) )
	    		    {
	    		        s = 29;
	    		    }

	    			 
	    				ctx->seek(index76_21);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA76_36;

	    		    ANTLR_MARKER index76_36;


	    		    LA76_36 = ctx->LA(1);

	    		     
	    		        index76_36 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA76_36 == DELIMITED_ID || LA76_36 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))))) )
	    		    {
	    		        s = 38;
	    		    }

	    			 
	    				ctx->seek(index76_36);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 7:

	    		{
	    		    ANTLR_UINT32 LA76_12;

	    		    ANTLR_MARKER index76_12;


	    		    LA76_12 = ctx->LA(1);

	    		     
	    		        index76_12 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA76_12 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 20;
	    		    }

	    		    else if ( (LA76_12 == BINDVAR || LA76_12 == COLON || LA76_12 == INTRODUCER || LA76_12 == SQL92_RESERVED_BEGIN || LA76_12 == SQL92_RESERVED_CREATE || LA76_12 == SQL92_RESERVED_CURSOR || LA76_12 == SQL92_RESERVED_DECLARE || LA76_12 == SQL92_RESERVED_PROCEDURE || LA76_12 == SQL92_RESERVED_WHEN) && ((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA76_12 == DELIMITED_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))))) )
	    		    {
	    		        s = 21;
	    		    }

	    		    else if ( (LA76_12 == PERIOD)  )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA76_12 == SQL92_RESERVED_DATE || LA76_12 == SQL92_RESERVED_EXCEPTION) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))))) )
	    		    {
	    		        s = 22;
	    		    }

	    		    else if ( (LA76_12 == AT_SIGN || LA76_12 == LEFT_PAREN) && ((((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 23;
	    		    }

	    		    else if ( (LA76_12 == ASSIGN_OP || LA76_12 == PERCENT || LA76_12 == SEMICOLON || LA76_12 == SQL92_RESERVED_DEFAULT || LA76_12 == SQL92_RESERVED_NOT)  )
	    		    {
	    		        s = 24;
	    		    }

	    		    else if ( (LA76_12 == SQL92_RESERVED_IS) && ((((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 25;
	    		    }

	    			 
	    				ctx->seek(index76_12);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 8:

	    		{
	    		    ANTLR_UINT32 LA76_9;

	    		    ANTLR_MARKER index76_9;


	    		    LA76_9 = ctx->LA(1);

	    		     
	    		        index76_9 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA76_9 == DELIMITED_ID || LA76_9 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 19;
	    		    }

	    			 
	    				ctx->seek(index76_9);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 9:

	    		{
	    		    ANTLR_UINT32 LA76_26;

	    		    ANTLR_MARKER index76_26;


	    		    LA76_26 = ctx->LA(1);

	    		     
	    		        index76_26 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA76_26 == DELIMITED_ID || LA76_26 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 30;
	    		    }

	    			 
	    				ctx->seek(index76_26);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 10:

	    		{
	    		    ANTLR_UINT32 LA76_28;

	    		    ANTLR_MARKER index76_28;


	    		    LA76_28 = ctx->LA(1);

	    		     
	    		        index76_28 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA76_28 == DELIMITED_ID || LA76_28 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))))) )
	    		    {
	    		        s = 35;
	    		    }

	    			 
	    				ctx->seek(index76_28);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 11:

	    		{
	    		    ANTLR_UINT32 LA76_1;

	    		    ANTLR_MARKER index76_1;


	    		    LA76_1 = ctx->LA(1);

	    		     
	    		        index76_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA76_1 == REGULAR_ID)  )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA76_1 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))||((equalsIgnoreCase(LT(1)->getText(), "FUNCTION")))||((equalsIgnoreCase(LT(1)->getText(), "CALL"))))) )
	    		    {
	    		        s = 4;
	    		    }

	    		    else if ( (LA76_1 == DELIMITED_ID)  )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( (LA76_1 == BINDVAR || LA76_1 == COLON || LA76_1 == SQL92_RESERVED_BEGIN || LA76_1 == SQL92_RESERVED_CREATE || LA76_1 == SQL92_RESERVED_CURSOR || LA76_1 == SQL92_RESERVED_DECLARE || LA76_1 == SQL92_RESERVED_PROCEDURE || LA76_1 == SQL92_RESERVED_WHEN) && ((((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA76_1 == PERIOD || LA76_1 == SQL92_RESERVED_DATE || LA76_1 == SQL92_RESERVED_EXCEPTION)  )
	    		    {
	    		        s = 7;
	    		    }

	    			 
	    				ctx->seek(index76_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 12:

	    		{
	    		    ANTLR_UINT32 LA76_3;

	    		    ANTLR_MARKER index76_3;


	    		    LA76_3 = ctx->LA(1);

	    		     
	    		        index76_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (((LA76_3 >= CHAR_STRING) && (LA76_3 <= CHAR_STRING_PERL)) || LA76_3 == NATIONAL_CHAR_STRING_LIT || LA76_3 == SQL92_RESERVED_AS) && ((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA76_3 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA76_3 == REGULAR_ID)  )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA76_3 == PERIOD)  )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( (LA76_3 == COMMA || LA76_3 == SQL92_RESERVED_DECLARE || LA76_3 == SQL92_RESERVED_WHEN) && ((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS"))) )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA76_3 == DELIMITED_ID)  )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA76_3 == BINDVAR || LA76_3 == COLON || LA76_3 == SQL92_RESERVED_CREATE || LA76_3 == SQL92_RESERVED_CURSOR || LA76_3 == SQL92_RESERVED_PROCEDURE) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))))) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( (LA76_3 == SQL92_RESERVED_BEGIN) && ((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS"))) )
	    		    {
	    		        s = 14;
	    		    }

	    		    else if ( (LA76_3 == SQL92_RESERVED_DATE)  )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA76_3 == SQL92_RESERVED_EXCEPTION) && ((((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 16;
	    		    }

	    		    else if ( (LA76_3 == AT_SIGN) && ((equalsIgnoreCase(LT(1)->getText(), "CALL"))) )
	    		    {
	    		        s = 17;
	    		    }

	    		    else if ( (LA76_3 == ASSIGN_OP || LA76_3 == LEFT_PAREN || LA76_3 == PERCENT || LA76_3 == SEMICOLON || LA76_3 == SQL92_RESERVED_DEFAULT || LA76_3 == SQL92_RESERVED_IS || LA76_3 == SQL92_RESERVED_NOT || LA76_3 == SQL92_RESERVED_WITH)  )
	    		    {
	    		        s = 18;
	    		    }

	    			 
	    				ctx->seek(index76_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 13:

	    		{
	    		    ANTLR_UINT32 LA76_38;

	    		    ANTLR_MARKER index76_38;


	    		    LA76_38 = ctx->LA(1);

	    		     
	    		        index76_38 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA76_38 == SQL92_RESERVED_EXCEPTION) && ((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA76_38 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))))) )
	    		    {
	    		        s = 36;
	    		    }

	    		    else if ( (LA76_38 == PERCENT) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))))) )
	    		    {
	    		        s = 29;
	    		    }

	    		    else if ( (LA76_38 == ASSIGN_OP || LA76_38 == SEMICOLON || LA76_38 == SQL92_RESERVED_DEFAULT || LA76_38 == SQL92_RESERVED_NOT) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))))) )
	    		    {
	    		        s = 37;
	    		    }

	    			 
	    				ctx->seek(index76_38);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 14:

	    		{
	    		    ANTLR_UINT32 LA76_31;

	    		    ANTLR_MARKER index76_31;


	    		    LA76_31 = ctx->LA(1);

	    		     
	    		        index76_31 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))  )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))))  )
	    		    {
	    		        s = 34;
	    		    }

	    			 
	    				ctx->seek(index76_31);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 15:

	    		{
	    		    ANTLR_UINT32 LA76_20;

	    		    ANTLR_MARKER index76_20;


	    		    LA76_20 = ctx->LA(1);

	    		     
	    		        index76_20 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "REFERENCING")))  )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "COMPOUND")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))))  )
	    		    {
	    		        s = 25;
	    		    }

	    			 
	    				ctx->seek(index76_20);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "312:35: ( referencing_clause )?" );
	    ex->set_decisionNum( 76 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParserCyclicDFA76  cdfa76(
	    76,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"312:35: ( referencing_clause )?",
	    dfa76_eot,	    /* EOT table			    */
	    dfa76_eof,	    /* EOF table			    */
	    dfa76_min,	    /* Minimum tokens for each state    */
	    dfa76_max,	    /* Maximum tokens for each state    */
	    dfa76_accept,	/* Accept table			    */
	    dfa76_special,	/* Special transition states	    */
	    dfa76_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 76
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()+ loopback of 385:26: ( referencing_element )+
 */
static const ANTLR_INT32 dfa92_eot[14] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa92_eof[14] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa92_min[14] =
    {
	9, -1, 9, 18, 0, -1, 0, -1, -1, 18, 18, 0, 18, 0
    };
static const ANTLR_INT32 dfa92_max[14] =
    {
	146, -1, 146, 74, 0, -1, 0, -1, -1, 74, 74, 0, 74, 0
    };
static const ANTLR_INT32 dfa92_accept[14] =
    {
	-1, 2, -1, -1, -1, 2, -1, 2, 1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa92_special[14] =
    {
	-1, -1, 7, 1, 4, -1, 8, -1, -1, 0, 3, 6, 2, 5
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa92_T_empty	 =   NULL;

static const ANTLR_INT32 dfa92_T0[] =
    {
	11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 11
    };

static const ANTLR_INT32 dfa92_T1[] =
    {
	9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 9
    };

static const ANTLR_INT32 dfa92_T2[] =
    {
	13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 13
    };

static const ANTLR_INT32 dfa92_T3[] =
    {
	12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 12
    };

static const ANTLR_INT32 dfa92_T4[] =
    {
	-1
    };

static const ANTLR_INT32 dfa92_T5[] =
    {
	5, -1, -1, 8, 8, 5, -1, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	3, -1, -1, -1, -1, -1, 8, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 8, -1, 5, -1, -1, -1, -1, -1, 5, -1, 5, 7, 5, -1, -1, -1, -1, 
	-1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 5
    };

static const ANTLR_INT32 dfa92_T6[] =
    {
	1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa92_transitions[] =
{
    dfa92_T6, NULL, dfa92_T5, dfa92_T1, dfa92_T4, NULL, dfa92_T4, NULL, 
    NULL, dfa92_T0, dfa92_T3, dfa92_T4, dfa92_T2, dfa92_T4
};


/* Declare tracking structure for Cyclic DFA 92
 */
class PLSQLParserCyclicDFA92 : public CyclicDFA< PLSQLParserImplTraits, PLSQLParser >, public PLSQLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParserImplTraits, PLSQLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParserCyclicDFA92( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA92_9;

	    		    ANTLR_MARKER index92_9;


	    		    LA92_9 = ctx->LA(1);

	    		     
	    		        index92_9 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA92_9 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "OLD")))||((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "PARENT")))||((equalsIgnoreCase(LT(1)->getText(), "NEW")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))||((equalsIgnoreCase(LT(1)->getText(), "FUNCTION")))||((equalsIgnoreCase(LT(1)->getText(), "CALL"))))) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA92_9 == DELIMITED_ID || LA92_9 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "OLD")))||((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "PARENT")))||((equalsIgnoreCase(LT(1)->getText(), "NEW")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))||((equalsIgnoreCase(LT(1)->getText(), "FUNCTION")))||((equalsIgnoreCase(LT(1)->getText(), "CALL"))))) )
	    		    {
	    		        s = 11;
	    		    }

	    			 
	    				ctx->seek(index92_9);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA92_3;

	    		    ANTLR_MARKER index92_3;


	    		    LA92_3 = ctx->LA(1);

	    		     
	    		        index92_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA92_3 == DELIMITED_ID || LA92_3 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "OLD")))||((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "PARENT")))||((equalsIgnoreCase(LT(1)->getText(), "NEW")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))||((equalsIgnoreCase(LT(1)->getText(), "FUNCTION")))||((equalsIgnoreCase(LT(1)->getText(), "CALL"))))) )
	    		    {
	    		        s = 9;
	    		    }

	    			 
	    				ctx->seek(index92_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA92_12;

	    		    ANTLR_MARKER index92_12;


	    		    LA92_12 = ctx->LA(1);

	    		     
	    		        index92_12 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA92_12 == DELIMITED_ID || LA92_12 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "OLD")))||((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "PARENT")))||((equalsIgnoreCase(LT(1)->getText(), "NEW")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))||((equalsIgnoreCase(LT(1)->getText(), "FUNCTION")))||((equalsIgnoreCase(LT(1)->getText(), "CALL"))))) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( (LA92_12 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "OLD")))||((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "PARENT")))||((equalsIgnoreCase(LT(1)->getText(), "NEW")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))||((equalsIgnoreCase(LT(1)->getText(), "FUNCTION")))||((equalsIgnoreCase(LT(1)->getText(), "CALL"))))) )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index92_12);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA92_10;

	    		    ANTLR_MARKER index92_10;


	    		    LA92_10 = ctx->LA(1);

	    		     
	    		        index92_10 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA92_10 == DELIMITED_ID || LA92_10 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "OLD")))||((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "PARENT")))||((equalsIgnoreCase(LT(1)->getText(), "NEW")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))||((equalsIgnoreCase(LT(1)->getText(), "FUNCTION")))||((equalsIgnoreCase(LT(1)->getText(), "CALL"))))) )
	    		    {
	    		        s = 12;
	    		    }

	    			 
	    				ctx->seek(index92_10);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA92_4;

	    		    ANTLR_MARKER index92_4;


	    		    LA92_4 = ctx->LA(1);

	    		     
	    		        index92_4 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "OLD")))||((equalsIgnoreCase(LT(1)->getText(), "PARENT")))||((equalsIgnoreCase(LT(1)->getText(), "NEW")))))  )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (true)  )
	    		    {
	    		        s = 7;
	    		    }

	    			 
	    				ctx->seek(index92_4);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA92_13;

	    		    ANTLR_MARKER index92_13;


	    		    LA92_13 = ctx->LA(1);

	    		     
	    		        index92_13 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "OLD")))||((equalsIgnoreCase(LT(1)->getText(), "PARENT")))||((equalsIgnoreCase(LT(1)->getText(), "NEW")))))  )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))||((equalsIgnoreCase(LT(1)->getText(), "FUNCTION")))||((equalsIgnoreCase(LT(1)->getText(), "CALL")))))  )
	    		    {
	    		        s = 7;
	    		    }

	    			 
	    				ctx->seek(index92_13);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA92_11;

	    		    ANTLR_MARKER index92_11;


	    		    LA92_11 = ctx->LA(1);

	    		     
	    		        index92_11 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "OLD")))||((equalsIgnoreCase(LT(1)->getText(), "PARENT")))||((equalsIgnoreCase(LT(1)->getText(), "NEW")))))  )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))||((equalsIgnoreCase(LT(1)->getText(), "FUNCTION")))||((equalsIgnoreCase(LT(1)->getText(), "CALL")))))  )
	    		    {
	    		        s = 7;
	    		    }

	    			 
	    				ctx->seek(index92_11);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 7:

	    		{
	    		    ANTLR_UINT32 LA92_2;

	    		    ANTLR_MARKER index92_2;


	    		    LA92_2 = ctx->LA(1);

	    		     
	    		        index92_2 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA92_2 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "OLD")))||((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "PARENT")))||((equalsIgnoreCase(LT(1)->getText(), "NEW")))||((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE")))||((equalsIgnoreCase(LT(1)->getText(), "FUNCTION")))||((equalsIgnoreCase(LT(1)->getText(), "CALL"))))) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA92_2 == REGULAR_ID)  )
	    		    {
	    		        s = 4;
	    		    }

	    		    else if ( (LA92_2 == BINDVAR || LA92_2 == COLON || LA92_2 == SQL92_RESERVED_BEGIN || LA92_2 == SQL92_RESERVED_CREATE || LA92_2 == SQL92_RESERVED_CURSOR || LA92_2 == SQL92_RESERVED_DECLARE || LA92_2 == SQL92_RESERVED_PROCEDURE || LA92_2 == SQL92_RESERVED_WHEN) && ((((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))) )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( (LA92_2 == DELIMITED_ID)  )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA92_2 == PERIOD || LA92_2 == SQL92_RESERVED_DATE || LA92_2 == SQL92_RESERVED_EXCEPTION)  )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( (((LA92_2 >= CHAR_STRING) && (LA92_2 <= CHAR_STRING_PERL)) || LA92_2 == NATIONAL_CHAR_STRING_LIT || LA92_2 == SQL92_RESERVED_AS) && ((((equalsIgnoreCase(LT(1)->getText(), "OLD")))||((equalsIgnoreCase(LT(1)->getText(), "PARENT")))||((equalsIgnoreCase(LT(1)->getText(), "NEW"))))) )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index92_2);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 8:

	    		{
	    		    ANTLR_UINT32 LA92_6;

	    		    ANTLR_MARKER index92_6;


	    		    LA92_6 = ctx->LA(1);

	    		     
	    		        index92_6 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "OLD")))||((equalsIgnoreCase(LT(1)->getText(), "PARENT")))||((equalsIgnoreCase(LT(1)->getText(), "NEW")))))  )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (true)  )
	    		    {
	    		        s = 7;
	    		    }

	    			 
	    				ctx->seek(index92_6);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "()+ loopback of 385:26: ( referencing_element )+" );
	    ex->set_decisionNum( 92 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParserCyclicDFA92  cdfa92(
	    92,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"()+ loopback of 385:26: ( referencing_element )+",
	    dfa92_eot,	    /* EOT table			    */
	    dfa92_eof,	    /* EOF table			    */
	    dfa92_min,	    /* Minimum tokens for each state    */
	    dfa92_max,	    /* Maximum tokens for each state    */
	    dfa92_accept,	/* Accept table			    */
	    dfa92_special,	/* Special transition states	    */
	    dfa92_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 92
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    596:20: ( type_spec | self_key as_key result_key )
 */
static const ANTLR_INT32 dfa171_eot[19] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1
    };
static const ANTLR_INT32 dfa171_eof[19] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1
    };
static const ANTLR_INT32 dfa171_min[19] =
    {
	18, 15, -1, 74, -1, -1, 15, 74, -1, 5, 0, 18, 0, 0, 18, 18, 0, 18, 0
    };
static const ANTLR_INT32 dfa171_max[19] =
    {
	97, 148, -1, 74, -1, -1, 128, 131, -1, 151, 0, 74, 0, 0, 74, 74, 0, 74, 
	0
    };
static const ANTLR_INT32 dfa171_accept[19] =
    {
	-1, -1, 1, -1, 1, 1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa171_special[19] =
    {
	-1, 2, -1, -1, -1, -1, 1, 6, -1, 8, 7, -1, 0, 5, -1, -1, 4, -1, 3
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa171_T_empty	 =   NULL;

static const ANTLR_INT32 dfa171_T0[] =
    {
	-1
    };

static const ANTLR_INT32 dfa171_T1[] =
    {
	6
    };

static const ANTLR_INT32 dfa171_T2[] =
    {
	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 7, -1, 8, 8, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, 
	-1, -1, -1, -1, 8
    };

static const ANTLR_INT32 dfa171_T3[] =
    {
	2, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, 
	-1, -1, -1, 5, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 2, -1, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, 
	-1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 2
    };

static const ANTLR_INT32 dfa171_T4[] =
    {
	18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 18
    };

static const ANTLR_INT32 dfa171_T5[] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 2
    };

static const ANTLR_INT32 dfa171_T6[] =
    {
	14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 14
    };

static const ANTLR_INT32 dfa171_T7[] =
    {
	17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 17
    };

static const ANTLR_INT32 dfa171_T8[] =
    {
	16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 16
    };

static const ANTLR_INT32 dfa171_T9[] =
    {
	9, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, 
	-1, -1, 8
    };

static const ANTLR_INT32 dfa171_T10[] =
    {
	8, -1, -1, -1, 8, -1, -1, 10, 8, 8, -1, -1, -1, 13, -1, -1, -1, 8, -1, 
	-1, -1, -1, -1, 11, -1, 8, -1, -1, 8, 8, -1, -1, -1, -1, 8, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, -1, -1, -1, -1, 
	-1, -1, -1, 8, -1, -1, 8, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, 8, 8, 
	-1, 8, -1, -1, 8, -1, -1, -1, -1, 8, 8, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 8, -1, -1, 8, 8, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, 
	8, -1, -1, 8, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa171_transitions[] =
{
    dfa171_T5, dfa171_T3, NULL, dfa171_T1, NULL, NULL, dfa171_T2, dfa171_T9, 
    NULL, dfa171_T10, dfa171_T0, dfa171_T6, dfa171_T0, dfa171_T0, dfa171_T8, 
    dfa171_T7, dfa171_T0, dfa171_T4, dfa171_T0
};


/* Declare tracking structure for Cyclic DFA 171
 */
class PLSQLParserCyclicDFA171 : public CyclicDFA< PLSQLParserImplTraits, PLSQLParser >, public PLSQLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParserImplTraits, PLSQLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParserCyclicDFA171( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA171_12;

	    		    ANTLR_MARKER index171_12;


	    		    LA171_12 = ctx->LA(1);

	    		     
	    		        index171_12 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (!( ((equalsIgnoreCase(LT(1)->getText(), "SELF"))) ))  )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SELF")))  )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index171_12);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA171_6;

	    		    ANTLR_MARKER index171_6;


	    		    LA171_6 = ctx->LA(1);

	    		     
	    		        index171_6 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA171_6 == REGULAR_ID)  )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( (LA171_6 == COMMA || ((LA171_6 >= RIGHT_PAREN) && (LA171_6 <= SEMICOLON)) || LA171_6 == SQL92_RESERVED_AS || LA171_6 == SQL92_RESERVED_IS || LA171_6 == SQL92_RESERVED_ORDER) && ((equalsIgnoreCase(LT(1)->getText(), "SELF"))) )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index171_6);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA171_1;

	    		    ANTLR_MARKER index171_1;


	    		    LA171_1 = ctx->LA(1);

	    		     
	    		        index171_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA171_1 == COMMA || LA171_1 == LEFT_PAREN || LA171_1 == REGULAR_ID || ((LA171_1 >= RIGHT_PAREN) && (LA171_1 <= SEMICOLON)) || LA171_1 == SQL92_RESERVED_IS || LA171_1 == SQL92_RESERVED_ORDER || LA171_1 == SQL92_RESERVED_WITH)  )
	    		    {
	    		        s = 2;
	    		    }

	    		    else if ( (LA171_1 == SQL92_RESERVED_AS)  )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA171_1 == DELIMITED_ID) && ((equalsIgnoreCase(LT(1)->getText(), "REF"))) )
	    		    {
	    		        s = 4;
	    		    }

	    		    else if ( (((LA171_1 >= PERCENT) && (LA171_1 <= PERIOD)))  )
	    		    {
	    		        s = 5;
	    		    }

	    			 
	    				ctx->seek(index171_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA171_18;

	    		    ANTLR_MARKER index171_18;


	    		    LA171_18 = ctx->LA(1);

	    		     
	    		        index171_18 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (!( ((equalsIgnoreCase(LT(1)->getText(), "SELF"))) ))  )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SELF")))  )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index171_18);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA171_16;

	    		    ANTLR_MARKER index171_16;


	    		    LA171_16 = ctx->LA(1);

	    		     
	    		        index171_16 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (!( ((equalsIgnoreCase(LT(1)->getText(), "SELF"))) ))  )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SELF")))  )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index171_16);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA171_13;

	    		    ANTLR_MARKER index171_13;


	    		    LA171_13 = ctx->LA(1);

	    		     
	    		        index171_13 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (!( ((equalsIgnoreCase(LT(1)->getText(), "SELF"))) ))  )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SELF")))  )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index171_13);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA171_7;

	    		    ANTLR_MARKER index171_7;


	    		    LA171_7 = ctx->LA(1);

	    		     
	    		        index171_7 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA171_7 == REGULAR_ID)  )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA171_7 == SEMICOLON || LA171_7 == SQL92_RESERVED_NOT || LA171_7 == SQL92_RESERVED_PROCEDURE) && ((equalsIgnoreCase(LT(1)->getText(), "SELF"))) )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index171_7);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 7:

	    		{
	    		    ANTLR_UINT32 LA171_10;

	    		    ANTLR_MARKER index171_10;


	    		    LA171_10 = ctx->LA(1);

	    		     
	    		        index171_10 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (!( ((equalsIgnoreCase(LT(1)->getText(), "SELF"))) ))  )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SELF")))  )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index171_10);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 8:

	    		{
	    		    ANTLR_UINT32 LA171_9;

	    		    ANTLR_MARKER index171_9;


	    		    LA171_9 = ctx->LA(1);

	    		     
	    		        index171_9 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA171_9 == CHAR_STRING)  )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA171_9 == INTRODUCER)  )
	    		    {
	    		        s = 11;
	    		    }

	    		    else if ( (LA171_9 == REGULAR_ID)  )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA171_9 == DELIMITED_ID)  )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( (LA171_9 == APPROXIMATE_NUM_LIT || LA171_9 == BINDVAR || ((LA171_9 >= CHAR_STRING_PERL) && (LA171_9 <= COLON)) || LA171_9 == EXACT_NUM_LIT || LA171_9 == LEFT_PAREN || ((LA171_9 >= MINUS_SIGN) && (LA171_9 <= NATIONAL_CHAR_STRING_LIT)) || LA171_9 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA171_9 == PLUS_SIGN || LA171_9 == SQL92_RESERVED_ALL || LA171_9 == SQL92_RESERVED_ANY || LA171_9 == SQL92_RESERVED_CASE || ((LA171_9 >= SQL92_RESERVED_CURSOR) && (LA171_9 <= SQL92_RESERVED_DATE)) || LA171_9 == SQL92_RESERVED_DEFAULT || LA171_9 == SQL92_RESERVED_DISTINCT || ((LA171_9 >= SQL92_RESERVED_EXISTS) && (LA171_9 <= SQL92_RESERVED_FALSE)) || LA171_9 == SQL92_RESERVED_INTO || ((LA171_9 >= SQL92_RESERVED_NOT) && (LA171_9 <= SQL92_RESERVED_NULL)) || LA171_9 == SQL92_RESERVED_PRIOR || LA171_9 == SQL92_RESERVED_TABLE || ((LA171_9 >= SQL92_RESERVED_TO) && (LA171_9 <= SQL92_RESERVED_TRUE)) || LA171_9 == UNSIGNED_INTEGER) && ((equalsIgnoreCase(LT(1)->getText(), "SELF"))) )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index171_9);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "596:20: ( type_spec | self_key as_key result_key )" );
	    ex->set_decisionNum( 171 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParserCyclicDFA171  cdfa171(
	    171,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"596:20: ( type_spec | self_key as_key result_key )",
	    dfa171_eot,	    /* EOT table			    */
	    dfa171_eof,	    /* EOF table			    */
	    dfa171_min,	    /* Minimum tokens for each state    */
	    dfa171_max,	    /* Maximum tokens for each state    */
	    dfa171_accept,	/* Accept table			    */
	    dfa171_special,	/* Special transition states	    */
	    dfa171_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 171
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    763:9: ( serially_reusable_key | autonomous_transaction_key | exception_init_key LEFT_PAREN exception_name COMMA numeric RIGHT_PAREN | inline_key LEFT_PAREN id1= id COMMA expression RIGHT_PAREN | restrict_references_key LEFT_PAREN ( id | default_key ) ( COMMA id )+ RIGHT_PAREN )
 */
static const ANTLR_INT32 dfa215_eot[24] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa215_eof[24] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa215_min[24] =
    {
	74, 30, 18, -1, -1, 18, 15, -1, 18, -1, 5, 18, 7, -1, 5, 7, 18, 18, 0, 
	0, 18, 18, 7, 18
    };
static const ANTLR_INT32 dfa215_max[24] =
    {
	74, 30, 99, -1, -1, 74, 38, -1, 74, -1, 151, 74, 152, -1, 152, 152, 74, 
	74, 0, 0, 74, 74, 152, 74
    };
static const ANTLR_INT32 dfa215_accept[24] =
    {
	-1, -1, -1, 1, 2, -1, -1, 5, -1, 3, -1, -1, -1, 4, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa215_special[24] =
    {
	-1, 0, 9, -1, -1, -1, -1, -1, -1, -1, 3, -1, 8, -1, 5, 4, 7, -1, 10, 6, 
	1, 11, 2, 12
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa215_T_empty	 =   NULL;

static const ANTLR_INT32 dfa215_T0[] =
    {
	2
    };

static const ANTLR_INT32 dfa215_T1[] =
    {
	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 8
    };

static const ANTLR_INT32 dfa215_T2[] =
    {
	22, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 21, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 22
    };

static const ANTLR_INT32 dfa215_T3[] =
    {
	13, -1, -1, -1, 13, -1, -1, -1, 7, -1, 13, -1, -1, -1, 13, -1, 13, -1, 
	13, 13, -1, -1, 13, 13, 13, 13, 13, -1, -1, 13, -1, 13, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13, -1, 19, -1, -1, 
	-1, 13, -1, -1, -1, 13, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 13, -1, -1, -1, 13, 13, 13, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 13
    };

static const ANTLR_INT32 dfa215_T4[] =
    {
	12, -1, -1, -1, 13, -1, -1, 13, 13, 13, -1, -1, -1, 15, -1, -1, -1, 12, 
	-1, -1, -1, -1, -1, 16, -1, 13, -1, -1, 13, 13, -1, -1, -1, -1, 13, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, 14, -1, -1, 
	-1, -1, -1, -1, -1, 13, -1, -1, 13, -1, -1, -1, -1, -1, 13, -1, -1, -1, 
	-1, 13, 13, -1, 13, -1, -1, 13, -1, -1, -1, -1, 13, 13, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 13, 13, -1, -1, -1, -1, -1, -1, 13, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 12
    };

static const ANTLR_INT32 dfa215_T5[] =
    {
	13, -1, -1, -1, 13, -1, -1, -1, 7, -1, 13, -1, -1, -1, 13, -1, 13, -1, 
	13, 13, -1, -1, 13, 13, 13, 13, 13, -1, -1, 13, -1, 13, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13, -1, 19, -1, -1, 
	-1, 13, -1, -1, -1, 13, -1, -1, -1, -1, 13, -1, 13, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 13, -1, -1, -1, 13, 13, 13, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 13
    };

static const ANTLR_INT32 dfa215_T6[] =
    {
	13, -1, 13, -1, 13, -1, 13, 13, 13, 13, 7, -1, 13, 13, -1, -1, 13, 13, 
	13, -1, 13, 13, -1, 13, 13, 13, 13, 13, 13, 13, -1, 13, -1, 13, 13, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13, -1, 19, 
	-1, -1, -1, 13, -1, 13, -1, 13, 13, -1, -1, -1, 13, -1, 13, -1, -1, -1, 
	-1, -1, 13, -1, 13, -1, -1, 13, -1, -1, -1, -1, 13, 13, -1, -1, -1, -1, 
	-1, -1, -1, 13, -1, -1, -1, 13, 13, 13, 13, -1, -1, -1, 13, -1, -1, 13, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 13, 13
    };

static const ANTLR_INT32 dfa215_T7[] =
    {
	10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 9
    };

static const ANTLR_INT32 dfa215_T8[] =
    {
	-1
    };

static const ANTLR_INT32 dfa215_T9[] =
    {
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 6
    };

static const ANTLR_INT32 dfa215_T10[] =
    {
	20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 20
    };

static const ANTLR_INT32 dfa215_T11[] =
    {
	13, -1, -1, -1, 13, -1, -1, -1, -1, -1, 13, -1, -1, -1, 13, -1, 13, -1, 
	13, 13, -1, -1, 13, -1, 13, 13, 13, -1, -1, 13, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13, -1, 18, -1, -1, 
	-1, 13, -1, -1, -1, 13, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 13, -1, -1, -1, 13, 13, 13, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 13
    };

static const ANTLR_INT32 dfa215_T12[] =
    {
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 7
    };

static const ANTLR_INT32 dfa215_T13[] =
    {
	17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 17
    };

static const ANTLR_INT32 dfa215_T14[] =
    {
	23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 23
    };

static const ANTLR_INT32 dfa215_T15[] =
    {
	1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa215_transitions[] =
{
    dfa215_T15, dfa215_T0, dfa215_T12, NULL, NULL, dfa215_T1, dfa215_T7, 
    NULL, dfa215_T9, NULL, dfa215_T4, dfa215_T13, dfa215_T11, NULL, dfa215_T6, 
    dfa215_T5, dfa215_T10, dfa215_T9, dfa215_T8, dfa215_T8, dfa215_T2, dfa215_T14, 
    dfa215_T3, dfa215_T2
};


/* Declare tracking structure for Cyclic DFA 215
 */
class PLSQLParserCyclicDFA215 : public CyclicDFA< PLSQLParserImplTraits, PLSQLParser >, public PLSQLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParserImplTraits, PLSQLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParserCyclicDFA215( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA215_1;

	    		    ANTLR_MARKER index215_1;


	    		    LA215_1 = ctx->LA(1);

	    		     
	    		        index215_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA215_1 == LEFT_PAREN)  )
	    		    {
	    		        s = 2;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SERIALLY_REUSABLE")))  )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "AUTONOMOUS_TRANSACTION")))  )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index215_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA215_20;

	    		    ANTLR_MARKER index215_20;


	    		    LA215_20 = ctx->LA(1);

	    		     
	    		        index215_20 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA215_20 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "INLINE")))||((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES"))))) )
	    		    {
	    		        s = 21;
	    		    }

	    		    else if ( (LA215_20 == DELIMITED_ID || LA215_20 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "INLINE")))||((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES"))))) )
	    		    {
	    		        s = 22;
	    		    }

	    			 
	    				ctx->seek(index215_20);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA215_22;

	    		    ANTLR_MARKER index215_22;


	    		    LA215_22 = ctx->LA(1);

	    		     
	    		        index215_22 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA215_22 == ASTERISK || LA215_22 == CARRET_OPERATOR_PART || LA215_22 == CONCATENATION_OP || LA215_22 == EQUALS_OP || LA215_22 == EXCLAMATION_OPERATOR_PART || ((LA215_22 >= GREATER_THAN_OP) && (LA215_22 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA215_22 >= LEFT_BRACKET) && (LA215_22 <= MINUS_SIGN)) || LA215_22 == NOT_EQUAL_OP || LA215_22 == PERIOD || LA215_22 == PLUS_SIGN || LA215_22 == REGULAR_ID || LA215_22 == SOLIDUS || LA215_22 == SQL92_RESERVED_AND || LA215_22 == SQL92_RESERVED_BETWEEN || LA215_22 == SQL92_RESERVED_IN || ((LA215_22 >= SQL92_RESERVED_IS) && (LA215_22 <= SQL92_RESERVED_NOT)) || LA215_22 == SQL92_RESERVED_OR || LA215_22 == VERTICAL_BAR) && ((equalsIgnoreCase(LT(1)->getText(), "INLINE"))) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( (LA215_22 == RIGHT_PAREN) && ((((equalsIgnoreCase(LT(1)->getText(), "INLINE")))||((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES"))))) )
	    		    {
	    		        s = 19;
	    		    }

	    		    else if ( (LA215_22 == COMMA) && ((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES"))) )
	    		    {
	    		        s = 7;
	    		    }

	    			 
	    				ctx->seek(index215_22);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA215_10;

	    		    ANTLR_MARKER index215_10;


	    		    LA215_10 = ctx->LA(1);

	    		     
	    		        index215_10 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA215_10 == APPROXIMATE_NUM_LIT || LA215_10 == EXACT_NUM_LIT || LA215_10 == UNSIGNED_INTEGER)  )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA215_10 == BINDVAR || ((LA215_10 >= CHAR_STRING) && (LA215_10 <= COLON)) || LA215_10 == LEFT_PAREN || ((LA215_10 >= MINUS_SIGN) && (LA215_10 <= NATIONAL_CHAR_STRING_LIT)) || LA215_10 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA215_10 == PLUS_SIGN || LA215_10 == SQL92_RESERVED_ALL || LA215_10 == SQL92_RESERVED_ANY || LA215_10 == SQL92_RESERVED_CASE || ((LA215_10 >= SQL92_RESERVED_CURSOR) && (LA215_10 <= SQL92_RESERVED_DATE)) || LA215_10 == SQL92_RESERVED_DEFAULT || LA215_10 == SQL92_RESERVED_DISTINCT || ((LA215_10 >= SQL92_RESERVED_EXISTS) && (LA215_10 <= SQL92_RESERVED_FALSE)) || ((LA215_10 >= SQL92_RESERVED_NOT) && (LA215_10 <= SQL92_RESERVED_NULL)) || LA215_10 == SQL92_RESERVED_PRIOR || LA215_10 == SQL92_RESERVED_TRUE) && ((equalsIgnoreCase(LT(1)->getText(), "INLINE"))) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( (LA215_10 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "INLINE")))||((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES"))))) )
	    		    {
	    		        s = 14;
	    		    }

	    		    else if ( (LA215_10 == DELIMITED_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "INLINE")))||((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES"))))) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA215_10 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "INLINE")))||((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES"))))) )
	    		    {
	    		        s = 16;
	    		    }

	    			 
	    				ctx->seek(index215_10);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA215_15;

	    		    ANTLR_MARKER index215_15;


	    		    LA215_15 = ctx->LA(1);

	    		     
	    		        index215_15 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA215_15 == ASTERISK || LA215_15 == CARRET_OPERATOR_PART || LA215_15 == CONCATENATION_OP || LA215_15 == EQUALS_OP || LA215_15 == EXCLAMATION_OPERATOR_PART || ((LA215_15 >= GREATER_THAN_OP) && (LA215_15 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA215_15 >= LEFT_BRACKET) && (LA215_15 <= MINUS_SIGN)) || LA215_15 == NOT_EQUAL_OP || LA215_15 == PERIOD || LA215_15 == PLUS_SIGN || LA215_15 == REGULAR_ID || LA215_15 == SOLIDUS || LA215_15 == SQL92_RESERVED_AND || LA215_15 == SQL92_RESERVED_BETWEEN || LA215_15 == SQL92_RESERVED_CASE || LA215_15 == SQL92_RESERVED_IN || ((LA215_15 >= SQL92_RESERVED_IS) && (LA215_15 <= SQL92_RESERVED_NOT)) || LA215_15 == SQL92_RESERVED_OR || LA215_15 == VERTICAL_BAR) && ((equalsIgnoreCase(LT(1)->getText(), "INLINE"))) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( (LA215_15 == RIGHT_PAREN) && ((((equalsIgnoreCase(LT(1)->getText(), "INLINE")))||((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES"))))) )
	    		    {
	    		        s = 19;
	    		    }

	    		    else if ( (LA215_15 == COMMA) && ((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES"))) )
	    		    {
	    		        s = 7;
	    		    }

	    			 
	    				ctx->seek(index215_15);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA215_14;

	    		    ANTLR_MARKER index215_14;


	    		    LA215_14 = ctx->LA(1);

	    		     
	    		        index215_14 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA215_14 == APPROXIMATE_NUM_LIT || LA215_14 == ASTERISK || LA215_14 == BINDVAR || ((LA215_14 >= CARRET_OPERATOR_PART) && (LA215_14 <= COLON)) || ((LA215_14 >= CONCATENATION_OP) && (LA215_14 <= DELIMITED_ID)) || ((LA215_14 >= EQUALS_OP) && (LA215_14 <= EXCLAMATION_OPERATOR_PART)) || ((LA215_14 >= GREATER_THAN_OP) && (LA215_14 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA215_14 >= INTRODUCER) && (LA215_14 <= NATIONAL_CHAR_STRING_LIT)) || LA215_14 == NOT_EQUAL_OP || ((LA215_14 >= PERIOD) && (LA215_14 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA215_14 == PLUS_SIGN || LA215_14 == REGULAR_ID || LA215_14 == SOLIDUS || LA215_14 == SQL92_RESERVED_ALL || ((LA215_14 >= SQL92_RESERVED_AND) && (LA215_14 <= SQL92_RESERVED_ANY)) || LA215_14 == SQL92_RESERVED_BETWEEN || LA215_14 == SQL92_RESERVED_CASE || LA215_14 == SQL92_RESERVED_DATE || LA215_14 == SQL92_RESERVED_DEFAULT || LA215_14 == SQL92_RESERVED_DISTINCT || ((LA215_14 >= SQL92_RESERVED_EXISTS) && (LA215_14 <= SQL92_RESERVED_FALSE)) || LA215_14 == SQL92_RESERVED_IN || ((LA215_14 >= SQL92_RESERVED_IS) && (LA215_14 <= SQL92_RESERVED_NULL)) || LA215_14 == SQL92_RESERVED_OR || LA215_14 == SQL92_RESERVED_PRIOR || LA215_14 == SQL92_RESERVED_TRUE || ((LA215_14 >= UNSIGNED_INTEGER) && (LA215_14 <= VERTICAL_BAR))) && ((equalsIgnoreCase(LT(1)->getText(), "INLINE"))) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( (LA215_14 == RIGHT_PAREN) && ((((equalsIgnoreCase(LT(1)->getText(), "INLINE")))||((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES"))))) )
	    		    {
	    		        s = 19;
	    		    }

	    		    else if ( (LA215_14 == COMMA) && ((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES"))) )
	    		    {
	    		        s = 7;
	    		    }

	    			 
	    				ctx->seek(index215_14);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA215_19;

	    		    ANTLR_MARKER index215_19;


	    		    LA215_19 = ctx->LA(1);

	    		     
	    		        index215_19 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "INLINE")))  )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES")))  )
	    		    {
	    		        s = 7;
	    		    }

	    			 
	    				ctx->seek(index215_19);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 7:

	    		{
	    		    ANTLR_UINT32 LA215_16;

	    		    ANTLR_MARKER index215_16;


	    		    LA215_16 = ctx->LA(1);

	    		     
	    		        index215_16 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA215_16 == DELIMITED_ID || LA215_16 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "INLINE")))||((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES"))))) )
	    		    {
	    		        s = 20;
	    		    }

	    			 
	    				ctx->seek(index215_16);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 8:

	    		{
	    		    ANTLR_UINT32 LA215_12;

	    		    ANTLR_MARKER index215_12;


	    		    LA215_12 = ctx->LA(1);

	    		     
	    		        index215_12 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA215_12 == RIGHT_PAREN)  )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA215_12 == ASTERISK || LA215_12 == CARRET_OPERATOR_PART || LA215_12 == CONCATENATION_OP || LA215_12 == EQUALS_OP || LA215_12 == EXCLAMATION_OPERATOR_PART || ((LA215_12 >= GREATER_THAN_OP) && (LA215_12 <= GREATER_THAN_OR_EQUALS_OP)) || LA215_12 == LEFT_BRACKET || ((LA215_12 >= LESS_THAN_OP) && (LA215_12 <= MINUS_SIGN)) || LA215_12 == NOT_EQUAL_OP || LA215_12 == PLUS_SIGN || LA215_12 == REGULAR_ID || LA215_12 == SOLIDUS || LA215_12 == SQL92_RESERVED_AND || LA215_12 == SQL92_RESERVED_BETWEEN || LA215_12 == SQL92_RESERVED_IN || ((LA215_12 >= SQL92_RESERVED_IS) && (LA215_12 <= SQL92_RESERVED_NOT)) || LA215_12 == SQL92_RESERVED_OR || LA215_12 == VERTICAL_BAR) && ((equalsIgnoreCase(LT(1)->getText(), "INLINE"))) )
	    		    {
	    		        s = 13;
	    		    }

	    			 
	    				ctx->seek(index215_12);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 9:

	    		{
	    		    ANTLR_UINT32 LA215_2;

	    		    ANTLR_MARKER index215_2;


	    		    LA215_2 = ctx->LA(1);

	    		     
	    		        index215_2 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA215_2 == INTRODUCER)  )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( (LA215_2 == DELIMITED_ID || LA215_2 == REGULAR_ID)  )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA215_2 == SQL92_RESERVED_DEFAULT) && ((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES"))) )
	    		    {
	    		        s = 7;
	    		    }

	    			 
	    				ctx->seek(index215_2);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 10:

	    		{
	    		    ANTLR_UINT32 LA215_18;

	    		    ANTLR_MARKER index215_18;


	    		    LA215_18 = ctx->LA(1);

	    		     
	    		        index215_18 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "EXCEPTION_INIT")))  )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "INLINE")))  )
	    		    {
	    		        s = 13;
	    		    }

	    			 
	    				ctx->seek(index215_18);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 11:

	    		{
	    		    ANTLR_UINT32 LA215_21;

	    		    ANTLR_MARKER index215_21;


	    		    LA215_21 = ctx->LA(1);

	    		     
	    		        index215_21 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA215_21 == DELIMITED_ID || LA215_21 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "INLINE")))||((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES"))))) )
	    		    {
	    		        s = 23;
	    		    }

	    			 
	    				ctx->seek(index215_21);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 12:

	    		{
	    		    ANTLR_UINT32 LA215_23;

	    		    ANTLR_MARKER index215_23;


	    		    LA215_23 = ctx->LA(1);

	    		     
	    		        index215_23 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA215_23 == DELIMITED_ID || LA215_23 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "INLINE")))||((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES"))))) )
	    		    {
	    		        s = 22;
	    		    }

	    		    else if ( (LA215_23 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "INLINE")))||((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES"))))) )
	    		    {
	    		        s = 21;
	    		    }

	    			 
	    				ctx->seek(index215_23);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "763:9: ( serially_reusable_key | autonomous_transaction_key | exception_init_key LEFT_PAREN exception_name COMMA numeric RIGHT_PAREN | inline_key LEFT_PAREN id1= id COMMA expression RIGHT_PAREN | restrict_references_key LEFT_PAREN ( id | default_key ) ( COMMA id )+ RIGHT_PAREN )" );
	    ex->set_decisionNum( 215 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParserCyclicDFA215  cdfa215(
	    215,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"763:9: ( serially_reusable_key | autonomous_transaction_key | exception_init_key LEFT_PAREN exception_name COMMA numeric RIGHT_PAREN | inline_key LEFT_PAREN id1= id COMMA expression RIGHT_PAREN | restrict_references_key LEFT_PAREN ( id | default_key ) ( COMMA id )+ RIGHT_PAREN )",
	    dfa215_eot,	    /* EOT table			    */
	    dfa215_eof,	    /* EOF table			    */
	    dfa215_min,	    /* Minimum tokens for each state    */
	    dfa215_max,	    /* Maximum tokens for each state    */
	    dfa215_accept,	/* Accept table			    */
	    dfa215_special,	/* Special transition states	    */
	    dfa215_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 215
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    772:1: record_declaration : ( record_type_dec | record_var_dec );
 */
static const ANTLR_INT32 dfa216_eot[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa216_eof[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa216_min[7] =
    {
	9, 18, -1, 37, 18, -1, 37
    };
static const ANTLR_INT32 dfa216_max[7] =
    {
	74, 74, -1, 120, 74, -1, 120
    };
static const ANTLR_INT32 dfa216_accept[7] =
    {
	-1, -1, 2, -1, -1, 1, -1
    };
static const ANTLR_INT32 dfa216_special[7] =
    {
	-1, -1, -1, 0, -1, -1, 1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa216_T_empty	 =   NULL;

static const ANTLR_INT32 dfa216_T0[] =
    {
	2, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5
    };

static const ANTLR_INT32 dfa216_T1[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 3
    };

static const ANTLR_INT32 dfa216_T2[] =
    {
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 6
    };

static const ANTLR_INT32 dfa216_T3[] =
    {
	2, -1, -1, -1, -1, 2, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa216_transitions[] =
{
    dfa216_T3, dfa216_T1, NULL, dfa216_T0, dfa216_T2, NULL, dfa216_T0
};


/* Declare tracking structure for Cyclic DFA 216
 */
class PLSQLParserCyclicDFA216 : public CyclicDFA< PLSQLParserImplTraits, PLSQLParser >, public PLSQLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParserImplTraits, PLSQLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParserCyclicDFA216( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA216_3;

	    		    ANTLR_MARKER index216_3;


	    		    LA216_3 = ctx->LA(1);

	    		     
	    		        index216_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA216_3 == PERIOD)  )
	    		    {
	    		        s = 4;
	    		    }

	    		    else if ( (LA216_3 == SQL92_RESERVED_IS) && ((equalsIgnoreCase(LT(1)->getText(), "TYPE"))) )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( (LA216_3 == PERCENT)  )
	    		    {
	    		        s = 2;
	    		    }

	    			 
	    				ctx->seek(index216_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA216_6;

	    		    ANTLR_MARKER index216_6;


	    		    LA216_6 = ctx->LA(1);

	    		     
	    		        index216_6 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA216_6 == SQL92_RESERVED_IS) && ((equalsIgnoreCase(LT(1)->getText(), "TYPE"))) )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( (LA216_6 == PERIOD)  )
	    		    {
	    		        s = 4;
	    		    }

	    		    else if ( (LA216_6 == PERCENT)  )
	    		    {
	    		        s = 2;
	    		    }

	    			 
	    				ctx->seek(index216_6);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "772:1: record_declaration : ( record_type_dec | record_var_dec );" );
	    ex->set_decisionNum( 216 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParserCyclicDFA216  cdfa216(
	    216,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"772:1: record_declaration : ( record_type_dec | record_var_dec );",
	    dfa216_eot,	    /* EOT table			    */
	    dfa216_eof,	    /* EOF table			    */
	    dfa216_min,	    /* Minimum tokens for each state    */
	    dfa216_max,	    /* Maximum tokens for each state    */
	    dfa216_accept,	/* Accept table			    */
	    dfa216_special,	/* Special transition states	    */
	    dfa216_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 216
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    800:10: ( table_type_dec | table_var_dec )
 */
static const ANTLR_INT32 dfa224_eot[8] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa224_eof[8] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa224_min[8] =
    {
	18, 18, -1, 18, 37, 18, -1, 37
    };
static const ANTLR_INT32 dfa224_max[8] =
    {
	74, 97, -1, 148, 120, 74, -1, 120
    };
static const ANTLR_INT32 dfa224_accept[8] =
    {
	-1, -1, 2, -1, -1, -1, 1, -1
    };
static const ANTLR_INT32 dfa224_special[8] =
    {
	-1, -1, -1, 1, 0, -1, -1, 2
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa224_T_empty	 =   NULL;

static const ANTLR_INT32 dfa224_T0[] =
    {
	2, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6
    };

static const ANTLR_INT32 dfa224_T1[] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, 
	2, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	2, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 2
    };

static const ANTLR_INT32 dfa224_T2[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 2
    };

static const ANTLR_INT32 dfa224_T3[] =
    {
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 7
    };

static const ANTLR_INT32 dfa224_T4[] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa224_transitions[] =
{
    dfa224_T4, dfa224_T2, NULL, dfa224_T1, dfa224_T0, dfa224_T3, NULL, dfa224_T0
};


/* Declare tracking structure for Cyclic DFA 224
 */
class PLSQLParserCyclicDFA224 : public CyclicDFA< PLSQLParserImplTraits, PLSQLParser >, public PLSQLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParserImplTraits, PLSQLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParserCyclicDFA224( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA224_4;

	    		    ANTLR_MARKER index224_4;


	    		    LA224_4 = ctx->LA(1);

	    		     
	    		        index224_4 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA224_4 == PERIOD)  )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( (LA224_4 == SQL92_RESERVED_IS) && ((equalsIgnoreCase(LT(1)->getText(), "TYPE"))) )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA224_4 == PERCENT || LA224_4 == SEMICOLON)  )
	    		    {
	    		        s = 2;
	    		    }

	    			 
	    				ctx->seek(index224_4);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA224_3;

	    		    ANTLR_MARKER index224_3;


	    		    LA224_3 = ctx->LA(1);

	    		     
	    		        index224_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA224_3 == PERIOD)  )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( (LA224_3 == SQL92_RESERVED_IS) && ((equalsIgnoreCase(LT(1)->getText(), "TYPE"))) )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA224_3 == DELIMITED_ID || LA224_3 == LEFT_PAREN || LA224_3 == PERCENT || LA224_3 == REGULAR_ID || LA224_3 == SEMICOLON || LA224_3 == SQL92_RESERVED_WITH)  )
	    		    {
	    		        s = 2;
	    		    }

	    			 
	    				ctx->seek(index224_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA224_7;

	    		    ANTLR_MARKER index224_7;


	    		    LA224_7 = ctx->LA(1);

	    		     
	    		        index224_7 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA224_7 == SQL92_RESERVED_IS) && ((equalsIgnoreCase(LT(1)->getText(), "TYPE"))) )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA224_7 == PERIOD)  )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( (LA224_7 == PERCENT || LA224_7 == SEMICOLON)  )
	    		    {
	    		        s = 2;
	    		    }

	    			 
	    				ctx->seek(index224_7);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "800:10: ( table_type_dec | table_var_dec )" );
	    ex->set_decisionNum( 224 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParserCyclicDFA224  cdfa224(
	    224,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"800:10: ( table_type_dec | table_var_dec )",
	    dfa224_eot,	    /* EOT table			    */
	    dfa224_eof,	    /* EOF table			    */
	    dfa224_min,	    /* Minimum tokens for each state    */
	    dfa224_max,	    /* Maximum tokens for each state    */
	    dfa224_accept,	/* Accept table			    */
	    dfa224_special,	/* Special transition states	    */
	    dfa224_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 224
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    984:1: sql_statement options {backtrack=true; } : ( execute_immediate | data_manipulation_language_statements | cursor_manipulation_statements | transaction_control_statements );
 */
static const ANTLR_INT32 dfa263_eot[28] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa263_eof[28] =
    {
	-1, 4, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, 9, -1, -1, -1, -1, 9, -1, 
	-1, -1, 9, -1, -1, -1, -1, 9, -1
    };
static const ANTLR_INT32 dfa263_min[28] =
    {
	30, 9, -1, -1, -1, 5, 18, 0, -1, -1, 5, 18, 5, 18, 0, 5, 18, 7, 0, 9, 18, 
	8, 18, 18, 30, 18, 8, 18
    };
static const ANTLR_INT32 dfa263_max[28] =
    {
	148, 139, -1, -1, -1, 151, 74, 0, -1, -1, 152, 74, 152, 74, 0, 151, 74, 
	152, 0, 74, 74, 110, 74, 74, 110, 74, 110, 74
    };
static const ANTLR_INT32 dfa263_accept[28] =
    {
	-1, -1, 2, 3, 4, -1, -1, -1, 4, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa263_special[28] =
    {
	-1, 0, -1, -1, -1, 6, 1, 3, -1, -1, -1, 2, -1, 8, 4, -1, 7, -1, 5, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa263_T_empty	 =   NULL;

static const ANTLR_INT32 dfa263_T0[] =
    {
	21, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 21
    };

static const ANTLR_INT32 dfa263_T1[] =
    {
	2, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 24, -1, -1, 9, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2
    };

static const ANTLR_INT32 dfa263_T2[] =
    {
	9, -1, 9, -1, 9, -1, 9, 9, 9, 9, -1, -1, 9, 9, -1, -1, 15, 9, 9, -1, 9, 
	9, -1, 9, 9, 9, 9, 9, 9, 9, -1, 9, -1, 9, 9, -1, -1, -1, -1, 9, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, 9, -1, -1, 9, -1, 9, -1, 
	9, 9, -1, -1, -1, 9, -1, 9, -1, -1, -1, -1, -1, 9, -1, 9, -1, -1, 9, -1, 
	-1, -1, -1, 9, 9, -1, -1, -1, -1, -1, -1, -1, 9, -1, 9, 9, 9, 9, 9, 9, 
	9, -1, -1, 9, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, 9, 9, 9, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 9, 9
    };

static const ANTLR_INT32 dfa263_T3[] =
    {
	3, -1, -1, -1, -1, 3, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, 4, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 8
    };

static const ANTLR_INT32 dfa263_T4[] =
    {
	11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 11
    };

static const ANTLR_INT32 dfa263_T5[] =
    {
	2, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 23, -1, -1, -1, -1, -1, 9, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 24, -1, -1, 9, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2
    };

static const ANTLR_INT32 dfa263_T6[] =
    {
	14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 14
    };

static const ANTLR_INT32 dfa263_T7[] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, 
	-1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, 
	-1, -1, -1, -1, 2, -1, -1, -1, -1, 2
    };

static const ANTLR_INT32 dfa263_T8[] =
    {
	22, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 22
    };

static const ANTLR_INT32 dfa263_T9[] =
    {
	-1
    };

static const ANTLR_INT32 dfa263_T10[] =
    {
	27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 27
    };

static const ANTLR_INT32 dfa263_T11[] =
    {
	9, -1, 9, -1, 9, -1, 9, 9, 9, 9, -1, -1, 9, 9, -1, -1, 9, 9, 9, -1, 9, 
	9, -1, 9, 9, 9, 9, 9, 9, 9, -1, 9, -1, 9, 9, -1, -1, -1, -1, 9, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 12, -1, -1, 9, -1, -1, 9, -1, 9, -1, 
	9, 9, -1, -1, -1, 9, -1, 9, -1, -1, -1, -1, -1, 9, -1, 9, -1, -1, 9, -1, 
	-1, -1, -1, 9, 9, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, 9, 9, 9, 9, 9, 
	-1, -1, -1, 9, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 9, 9
    };

static const ANTLR_INT32 dfa263_T12[] =
    {
	9, -1, -1, -1, 9, -1, -1, 9, 9, 9, -1, -1, -1, 9, -1, -1, -1, 9, -1, -1, 
	-1, -1, -1, 9, -1, 9, -1, -1, 9, 9, -1, -1, -1, -1, 9, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, 
	-1, -1, 9, -1, -1, 9, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, 9, 9, -1, 
	9, -1, -1, 9, -1, -1, -1, -1, 9, 9, -1, 2, -1, -1, -1, -1, -1, -1, -1, 
	-1, 2, -1, -1, 9, 9, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9
    };

static const ANTLR_INT32 dfa263_T13[] =
    {
	26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 26
    };

static const ANTLR_INT32 dfa263_T14[] =
    {
	9, -1, -1, -1, -1, 9, -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 21
    };

static const ANTLR_INT32 dfa263_T15[] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 2
    };

static const ANTLR_INT32 dfa263_T16[] =
    {
	18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 18
    };

static const ANTLR_INT32 dfa263_T17[] =
    {
	9, -1, -1, -1, 9, -1, -1, -1, -1, -1, 9, -1, -1, -1, 9, -1, 9, -1, 9, 9, 
	-1, -1, 9, -1, 9, 9, 9, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, 9, -1, -1, 9, -1, -1, -1, 
	9, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, 9, -1, -1, 19, 9, 9, 
	9, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9
    };

static const ANTLR_INT32 dfa263_T18[] =
    {
	16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 16
    };

static const ANTLR_INT32 dfa263_T19[] =
    {
	9, -1, -1, -1, 9, -1, -1, 17, 17, 9, -1, -1, -1, 9, -1, -1, -1, 9, -1, 
	-1, -1, -1, -1, 9, -1, 9, -1, -1, 9, 17, -1, -1, -1, -1, 9, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, 
	-1, -1, 9, -1, -1, 9, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, 9, -1, 
	9, -1, -1, 9, -1, -1, -1, -1, 9, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa263_transitions[] =
{
    dfa263_T7, dfa263_T3, NULL, NULL, NULL, dfa263_T12, dfa263_T4, dfa263_T9, 
    NULL, NULL, dfa263_T11, dfa263_T6, dfa263_T2, dfa263_T18, dfa263_T9, 
    dfa263_T19, dfa263_T16, dfa263_T17, dfa263_T9, dfa263_T14, dfa263_T8, 
    dfa263_T5, dfa263_T0, dfa263_T13, dfa263_T15, dfa263_T10, dfa263_T1, 
    dfa263_T0
};


/* Declare tracking structure for Cyclic DFA 263
 */
class PLSQLParserCyclicDFA263 : public CyclicDFA< PLSQLParserImplTraits, PLSQLParser >, public PLSQLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParserImplTraits, PLSQLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParserCyclicDFA263( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA263_1;

	    		    ANTLR_MARKER index263_1;


	    		    LA263_1 = ctx->LA(1);

	    		     
	    		        index263_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA263_1 == EOF || LA263_1 == SEMICOLON) && ((((equalsIgnoreCase(LT(1)->getText(), "COMMIT")))||((equalsIgnoreCase(LT(1)->getText(), "ROLLBACK"))))) )
	    		    {
	    		        s = 4;
	    		    }

	    		    else if ( (LA263_1 == REGULAR_ID)  )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( (LA263_1 == SQL92_RESERVED_INTO)  )
	    		    {
	    		        s = 2;
	    		    }

	    		    else if ( (LA263_1 == INTRODUCER) && ((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT"))) )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA263_1 == DELIMITED_ID) && ((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT"))) )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( (LA263_1 == BINDVAR || LA263_1 == COLON)  )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA263_1 == SQL92_RESERVED_TO) && ((equalsIgnoreCase(LT(1)->getText(), "ROLLBACK"))) )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index263_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA263_6;

	    		    ANTLR_MARKER index263_6;


	    		    LA263_6 = ctx->LA(1);

	    		     
	    		        index263_6 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA263_6 == DELIMITED_ID || LA263_6 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT"))) )
	    		    {
	    		        s = 11;
	    		    }

	    			 
	    				ctx->seek(index263_6);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA263_11;

	    		    ANTLR_MARKER index263_11;


	    		    LA263_11 = ctx->LA(1);

	    		     
	    		        index263_11 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA263_11 == PERIOD) && ((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT"))) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( (LA263_11 == DELIMITED_ID || LA263_11 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT"))) )
	    		    {
	    		        s = 14;
	    		    }

	    			 
	    				ctx->seek(index263_11);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA263_7;

	    		    ANTLR_MARKER index263_7;


	    		    LA263_7 = ctx->LA(1);

	    		     
	    		        index263_7 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (( (this->msynpred( antlr3::ClassForwarder<synpred65_PLSQLParser>() )) && ((((equalsIgnoreCase(LT(1)->getText(), "OPEN")))||((equalsIgnoreCase(LT(1)->getText(), "CLOSE"))))) ))  )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT")))  )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index263_7);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA263_14;

	    		    ANTLR_MARKER index263_14;


	    		    LA263_14 = ctx->LA(1);

	    		     
	    		        index263_14 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (( (this->msynpred( antlr3::ClassForwarder<synpred65_PLSQLParser>() )) && ((((equalsIgnoreCase(LT(1)->getText(), "OPEN")))||((equalsIgnoreCase(LT(1)->getText(), "CLOSE"))))) ))  )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT")))  )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index263_14);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA263_18;

	    		    ANTLR_MARKER index263_18;


	    		    LA263_18 = ctx->LA(1);

	    		     
	    		        index263_18 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (( (this->msynpred( antlr3::ClassForwarder<synpred65_PLSQLParser>() )) && ((((equalsIgnoreCase(LT(1)->getText(), "OPEN")))||((equalsIgnoreCase(LT(1)->getText(), "CLOSE"))))) ))  )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT")))  )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index263_18);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA263_5;

	    		    ANTLR_MARKER index263_5;


	    		    LA263_5 = ctx->LA(1);

	    		     
	    		        index263_5 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA263_5 == APPROXIMATE_NUM_LIT || LA263_5 == BINDVAR || ((LA263_5 >= CHAR_STRING) && (LA263_5 <= COLON)) || LA263_5 == DELIMITED_ID || LA263_5 == EXACT_NUM_LIT || LA263_5 == INTRODUCER || LA263_5 == LEFT_PAREN || ((LA263_5 >= MINUS_SIGN) && (LA263_5 <= NATIONAL_CHAR_STRING_LIT)) || LA263_5 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA263_5 == PLUS_SIGN || LA263_5 == SQL92_RESERVED_ALL || LA263_5 == SQL92_RESERVED_ANY || LA263_5 == SQL92_RESERVED_CASE || ((LA263_5 >= SQL92_RESERVED_CURSOR) && (LA263_5 <= SQL92_RESERVED_DATE)) || LA263_5 == SQL92_RESERVED_DEFAULT || LA263_5 == SQL92_RESERVED_DISTINCT || ((LA263_5 >= SQL92_RESERVED_EXISTS) && (LA263_5 <= SQL92_RESERVED_FALSE)) || ((LA263_5 >= SQL92_RESERVED_NOT) && (LA263_5 <= SQL92_RESERVED_NULL)) || LA263_5 == SQL92_RESERVED_PRIOR || LA263_5 == SQL92_RESERVED_TRUE || LA263_5 == UNSIGNED_INTEGER)  )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA263_5 == REGULAR_ID)  )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA263_5 == SQL92_RESERVED_FOR || LA263_5 == SQL92_RESERVED_INTO)  )
	    		    {
	    		        s = 2;
	    		    }

	    		    else if ( (( (this->msynpred( antlr3::ClassForwarder<synpred65_PLSQLParser>() )) && ((((equalsIgnoreCase(LT(1)->getText(), "OPEN")))||((equalsIgnoreCase(LT(1)->getText(), "CLOSE"))))) ))  )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "COMMIT")))||((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT")))||((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "ROLLBACK")))))  )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index263_5);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 7:

	    		{
	    		    ANTLR_UINT32 LA263_16;

	    		    ANTLR_MARKER index263_16;


	    		    LA263_16 = ctx->LA(1);

	    		     
	    		        index263_16 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA263_16 == DELIMITED_ID || LA263_16 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT"))) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA263_16 == PERIOD) && ((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT"))) )
	    		    {
	    		        s = 13;
	    		    }

	    			 
	    				ctx->seek(index263_16);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 8:

	    		{
	    		    ANTLR_UINT32 LA263_13;

	    		    ANTLR_MARKER index263_13;


	    		    LA263_13 = ctx->LA(1);

	    		     
	    		        index263_13 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA263_13 == DELIMITED_ID || LA263_13 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT"))) )
	    		    {
	    		        s = 16;
	    		    }

	    			 
	    				ctx->seek(index263_13);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "984:1: sql_statement options {backtrack=true; } : ( execute_immediate | data_manipulation_language_statements | cursor_manipulation_statements | transaction_control_statements );" );
	    ex->set_decisionNum( 263 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParserCyclicDFA263  cdfa263(
	    263,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"984:1: sql_statement options {backtrack=true; } : ( execute_immediate | data_manipulation_language_statements | cursor_manipulation_statements | transaction_control_statements );",
	    dfa263_eot,	    /* EOT table			    */
	    dfa263_eof,	    /* EOF table			    */
	    dfa263_min,	    /* Minimum tokens for each state    */
	    dfa263_max,	    /* Maximum tokens for each state    */
	    dfa263_accept,	/* Accept table			    */
	    dfa263_special,	/* Special transition states	    */
	    dfa263_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 263
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1024:1: cursor_manipulation_statements : ( close_statement | open_statement | fetch_statement | open_for_statement );
 */
static const ANTLR_INT32 dfa269_eot[14] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa269_eof[14] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa269_min[14] =
    {
	74, 9, -1, 18, 38, 9, 151, 18, -1, -1, -1, 9, 18, 18
    };
static const ANTLR_INT32 dfa269_max[14] =
    {
	109, 74, -1, 74, 110, 110, 151, 74, -1, -1, -1, 110, 74, 74
    };
static const ANTLR_INT32 dfa269_accept[14] =
    {
	-1, -1, 3, -1, -1, -1, -1, -1, 4, 1, 2, -1, -1, -1
    };
static const ANTLR_INT32 dfa269_special[14] =
    {
	6, 2, -1, 5, 0, 8, 7, 1, -1, -1, -1, 4, 9, 3
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa269_T_empty	 =   NULL;

static const ANTLR_INT32 dfa269_T0[] =
    {
	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	8
    };

static const ANTLR_INT32 dfa269_T1[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4
    };

static const ANTLR_INT32 dfa269_T2[] =
    {
	5, -1, -1, -1, -1, 6, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa269_T3[] =
    {
	8, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8
    };

static const ANTLR_INT32 dfa269_T4[] =
    {
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 7
    };

static const ANTLR_INT32 dfa269_T5[] =
    {
	1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2
    };

static const ANTLR_INT32 dfa269_T6[] =
    {
	11
    };

static const ANTLR_INT32 dfa269_T7[] =
    {
	13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 13
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa269_transitions[] =
{
    dfa269_T5, dfa269_T2, NULL, dfa269_T4, dfa269_T0, dfa269_T3, dfa269_T6, 
    dfa269_T1, NULL, NULL, NULL, dfa269_T3, dfa269_T7, dfa269_T1
};


/* Declare tracking structure for Cyclic DFA 269
 */
class PLSQLParserCyclicDFA269 : public CyclicDFA< PLSQLParserImplTraits, PLSQLParser >, public PLSQLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParserImplTraits, PLSQLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParserCyclicDFA269( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA269_4;

	    		    ANTLR_MARKER index269_4;


	    		    LA269_4 = ctx->LA(1);

	    		     
	    		        index269_4 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA269_4 == PERIOD || LA269_4 == SQL92_RESERVED_FOR) && ((equalsIgnoreCase(LT(1)->getText(), "OPEN"))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "CLOSE")))  )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "OPEN")))  )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index269_4);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA269_7;

	    		    ANTLR_MARKER index269_7;


	    		    LA269_7 = ctx->LA(1);

	    		     
	    		        index269_7 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA269_7 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "OPEN")))||((equalsIgnoreCase(LT(1)->getText(), "CLOSE"))))) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA269_7 == DELIMITED_ID || LA269_7 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "OPEN")))||((equalsIgnoreCase(LT(1)->getText(), "CLOSE"))))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index269_7);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA269_1;

	    		    ANTLR_MARKER index269_1;


	    		    LA269_1 = ctx->LA(1);

	    		     
	    		        index269_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA269_1 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "OPEN")))||((equalsIgnoreCase(LT(1)->getText(), "CLOSE"))))) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA269_1 == DELIMITED_ID || LA269_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "OPEN")))||((equalsIgnoreCase(LT(1)->getText(), "CLOSE"))))) )
	    		    {
	    		        s = 4;
	    		    }

	    		    else if ( (LA269_1 == BINDVAR) && ((((equalsIgnoreCase(LT(1)->getText(), "OPEN")))||((equalsIgnoreCase(LT(1)->getText(), "CLOSE"))))) )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( (LA269_1 == COLON) && ((((equalsIgnoreCase(LT(1)->getText(), "OPEN")))||((equalsIgnoreCase(LT(1)->getText(), "CLOSE"))))) )
	    		    {
	    		        s = 6;
	    		    }

	    			 
	    				ctx->seek(index269_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA269_13;

	    		    ANTLR_MARKER index269_13;


	    		    LA269_13 = ctx->LA(1);

	    		     
	    		        index269_13 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA269_13 == DELIMITED_ID || LA269_13 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "OPEN")))||((equalsIgnoreCase(LT(1)->getText(), "CLOSE"))))) )
	    		    {
	    		        s = 4;
	    		    }

	    		    else if ( (LA269_13 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "OPEN")))||((equalsIgnoreCase(LT(1)->getText(), "CLOSE"))))) )
	    		    {
	    		        s = 12;
	    		    }

	    			 
	    				ctx->seek(index269_13);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA269_11;

	    		    ANTLR_MARKER index269_11;


	    		    LA269_11 = ctx->LA(1);

	    		     
	    		        index269_11 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA269_11 == BINDVAR || LA269_11 == COLON || LA269_11 == PERIOD || LA269_11 == REGULAR_ID || LA269_11 == SQL92_RESERVED_FOR) && ((equalsIgnoreCase(LT(1)->getText(), "OPEN"))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "CLOSE")))  )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "OPEN")))  )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index269_11);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA269_3;

	    		    ANTLR_MARKER index269_3;


	    		    LA269_3 = ctx->LA(1);

	    		     
	    		        index269_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA269_3 == DELIMITED_ID || LA269_3 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "OPEN")))||((equalsIgnoreCase(LT(1)->getText(), "CLOSE"))))) )
	    		    {
	    		        s = 7;
	    		    }

	    			 
	    				ctx->seek(index269_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA269_0;

	    		    ANTLR_MARKER index269_0;


	    		    LA269_0 = ctx->LA(1);

	    		     
	    		        index269_0 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA269_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "OPEN")))||((equalsIgnoreCase(LT(1)->getText(), "CLOSE"))))) )
	    		    {
	    		        s = 1;
	    		    }

	    		    else if ( (LA269_0 == SQL92_RESERVED_FETCH)  )
	    		    {
	    		        s = 2;
	    		    }

	    			 
	    				ctx->seek(index269_0);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 7:

	    		{
	    		    ANTLR_UINT32 LA269_6;

	    		    ANTLR_MARKER index269_6;


	    		    LA269_6 = ctx->LA(1);

	    		     
	    		        index269_6 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA269_6 == UNSIGNED_INTEGER) && ((((equalsIgnoreCase(LT(1)->getText(), "OPEN")))||((equalsIgnoreCase(LT(1)->getText(), "CLOSE"))))) )
	    		    {
	    		        s = 11;
	    		    }

	    			 
	    				ctx->seek(index269_6);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 8:

	    		{
	    		    ANTLR_UINT32 LA269_5;

	    		    ANTLR_MARKER index269_5;


	    		    LA269_5 = ctx->LA(1);

	    		     
	    		        index269_5 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA269_5 == BINDVAR || LA269_5 == COLON || LA269_5 == PERIOD || LA269_5 == REGULAR_ID || LA269_5 == SQL92_RESERVED_FOR) && ((equalsIgnoreCase(LT(1)->getText(), "OPEN"))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "CLOSE")))  )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "OPEN")))  )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index269_5);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 9:

	    		{
	    		    ANTLR_UINT32 LA269_12;

	    		    ANTLR_MARKER index269_12;


	    		    LA269_12 = ctx->LA(1);

	    		     
	    		        index269_12 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA269_12 == DELIMITED_ID || LA269_12 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "OPEN")))||((equalsIgnoreCase(LT(1)->getText(), "CLOSE"))))) )
	    		    {
	    		        s = 13;
	    		    }

	    			 
	    				ctx->seek(index269_12);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "1024:1: cursor_manipulation_statements : ( close_statement | open_statement | fetch_statement | open_for_statement );" );
	    ex->set_decisionNum( 269 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParserCyclicDFA269  cdfa269(
	    269,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"1024:1: cursor_manipulation_statements : ( close_statement | open_statement | fetch_statement | open_for_statement );",
	    dfa269_eot,	    /* EOT table			    */
	    dfa269_eof,	    /* EOF table			    */
	    dfa269_min,	    /* Minimum tokens for each state    */
	    dfa269_max,	    /* Maximum tokens for each state    */
	    dfa269_accept,	/* Accept table			    */
	    dfa269_special,	/* Special transition states	    */
	    dfa269_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 269
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */

/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start swallow_to_semi
 * PLSQLParser.g:56:1: swallow_to_semi : (~ ( SEMICOLON ) )+ ;
 */
void
PLSQLParser::swallow_to_semi()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:57:5: ( (~ ( SEMICOLON ) )+ )
        // PLSQLParser.g:57:10: (~ ( SEMICOLON ) )+
        {
            // PLSQLParser.g:57:10: (~ ( SEMICOLON ) )+
            {
                int cnt1=0;

                for (;;)
                {
                    int alt1=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA1_0 = this->LA(1);
            	    if ( (((LA1_0 >= AMPERSAND) && (LA1_0 <= RIGHT_PAREN)) || ((LA1_0 >= SEPARATOR) && (LA1_0 <= 268))))
            	    {
            	        alt1=1;
            	    }

            	}
            	switch (alt1)
            	{
            	    case 1:
            	        // PLSQLParser.g:
            	        {
            	            if ( ((this->LA(1) >= AMPERSAND) && (this->LA(1) <= RIGHT_PAREN)) || ((this->LA(1) >= SEPARATOR) && (this->LA(1) <= 268)) )
            	            {
            	                this->consume();
            	                this->set_perror_recovery(false);
            	                 this->set_failedflag(false); 

            	            }
            	            else
            	            {
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return ;
            	                }

            	                new ANTLR_Exception< PLSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                this->get_exception()->set_expectingSet(NULL);

            	                goto ruleswallow_to_semiEx;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt1 >= 1 )
            		{
            		    goto loop1;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PLSQLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleswallow_to_semiEx;
            	}
            	cnt1++;
                }
                loop1: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleswallow_to_semiEx; /* Prevent compiler warnings */
    ruleswallow_to_semiEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end swallow_to_semi */

/**
 * $ANTLR start compilation_unit
 * PLSQLParser.g:60:1: compilation_unit : ( unit_statement )* EOF ;
 */
void
PLSQLParser::compilation_unit()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:61:5: ( ( unit_statement )* EOF )
        // PLSQLParser.g:61:10: ( unit_statement )* EOF
        {
            // PLSQLParser.g:61:10: ( unit_statement )*

            for (;;)
            {
                int alt2=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA2_0 = this->LA(1);
                    if ( (LA2_0 == SQL92_RESERVED_ALTER || LA2_0 == SQL92_RESERVED_CREATE))
                    {
                        alt2=1;
                    }
                    else if ( (LA2_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "EXPLAIN")))||((equalsIgnoreCase(LT(1)->getText(), "MERGE")))||((equalsIgnoreCase(LT(1)->getText(), "FUNCTION"))))))
                    {
                        alt2=1;
                    }
                    else if ( (LA2_0 == LEFT_PAREN || LA2_0 == PLSQL_RESERVED_LOCK || LA2_0 == SQL92_RESERVED_DELETE || LA2_0 == SQL92_RESERVED_DROP || LA2_0 == SQL92_RESERVED_INSERT || LA2_0 == SQL92_RESERVED_PROCEDURE || LA2_0 == SQL92_RESERVED_SELECT || LA2_0 == SQL92_RESERVED_UPDATE || LA2_0 == SQL92_RESERVED_WITH))
                    {
                        alt2=1;
                    }

                }
                switch (alt2)
                {
            	case 1:
            	    // PLSQLParser.g:61:10: unit_statement
            	    {
            	        this->followPush(FOLLOW_unit_statement_in_compilation_unit118);
            	        unit_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecompilation_unitEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop2;	/* break out of the loop */
            	    break;
                }
            }
            loop2: ; /* Jump out to here if this rule does not match */


             this->matchToken(EOF, &FOLLOW_EOF_in_compilation_unit121);
            if  (this->hasException())
            {
                goto rulecompilation_unitEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecompilation_unitEx; /* Prevent compiler warnings */
    rulecompilation_unitEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end compilation_unit */

/**
 * $ANTLR start sql_script
 * PLSQLParser.g:64:1: sql_script : ( unit_statement | sql_plus_command )* EOF ;
 */
void
PLSQLParser::sql_script()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:65:5: ( ( unit_statement | sql_plus_command )* EOF )
        // PLSQLParser.g:65:9: ( unit_statement | sql_plus_command )* EOF
        {
            // PLSQLParser.g:65:9: ( unit_statement | sql_plus_command )*

            for (;;)
            {
                int alt3=3;
                switch ( this->LA(1) )
                {
                case LEFT_PAREN:
                case PLSQL_RESERVED_LOCK:
                case SQL92_RESERVED_ALTER:
                case SQL92_RESERVED_CREATE:
                case SQL92_RESERVED_DELETE:
                case SQL92_RESERVED_DROP:
                case SQL92_RESERVED_INSERT:
                case SQL92_RESERVED_PROCEDURE:
                case SQL92_RESERVED_SELECT:
                case SQL92_RESERVED_UPDATE:
                case SQL92_RESERVED_WITH:
                	{
                		alt3=1;
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    int LA3_4 = this->LA(2);
                		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "EXPLAIN")))||((equalsIgnoreCase(LT(1)->getText(), "MERGE")))||((equalsIgnoreCase(LT(1)->getText(), "FUNCTION"))))))
                		    {
                		        alt3=1;
                		    }
                		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "EXIT")))||((equalsIgnoreCase(LT(1)->getText(), "WHENEVER"))))))
                		    {
                		        alt3=2;
                		    }

                		}
                	}
                    break;
                case PROMPT:
                case SOLIDUS:
                	{
                		alt3=2;
                	}
                    break;

                }

                switch (alt3)
                {
            	case 1:
            	    // PLSQLParser.g:65:10: unit_statement
            	    {
            	        this->followPush(FOLLOW_unit_statement_in_sql_script141);
            	        unit_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesql_scriptEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:65:25: sql_plus_command
            	    {
            	        this->followPush(FOLLOW_sql_plus_command_in_sql_script143);
            	        sql_plus_command();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesql_scriptEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop3;	/* break out of the loop */
            	    break;
                }
            }
            loop3: ; /* Jump out to here if this rule does not match */


             this->matchToken(EOF, &FOLLOW_EOF_in_sql_script147);
            if  (this->hasException())
            {
                goto rulesql_scriptEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesql_scriptEx; /* Prevent compiler warnings */
    rulesql_scriptEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sql_script */

/**
 * $ANTLR start unit_statement
 * PLSQLParser.g:68:1: unit_statement options {backtrack=true; } : ( alter_function | alter_package | alter_procedure | alter_sequence | alter_trigger | alter_type | create_function_body | create_procedure_body | create_package | create_sequence | create_trigger | create_type | drop_function | drop_package | drop_procedure | drop_sequence | drop_trigger | drop_type | data_manipulation_language_statements );
 */
void
PLSQLParser::unit_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:71:6: ( alter_function | alter_package | alter_procedure | alter_sequence | alter_trigger | alter_type | create_function_body | create_procedure_body | create_package | create_sequence | create_trigger | create_type | drop_function | drop_package | drop_procedure | drop_sequence | drop_trigger | drop_type | data_manipulation_language_statements )

            ANTLR_UINT32 alt4;

            alt4=19;

            {
                int LA4_0 = this->LA(1);
                if ( (LA4_0 == SQL92_RESERVED_ALTER))
                {
                    {
                        int LA4_1 = this->LA(2);
                        if ( (this->msynpred( antlr3::ClassForwarder<synpred1_PLSQLParser>() )))
                        {
                            alt4=1;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred2_PLSQLParser>() )))
                        {
                            alt4=2;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred3_PLSQLParser>() )))
                        {
                            alt4=3;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred4_PLSQLParser>() )))
                        {
                            alt4=4;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred5_PLSQLParser>() )))
                        {
                            alt4=5;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred6_PLSQLParser>() )))
                        {
                            alt4=6;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 4 );
                            ex->set_state( 1 );


                            goto ruleunit_statementEx;

                        }
                    }
                }
                else if ( (LA4_0 == SQL92_RESERVED_CREATE))
                {
                    {
                        int LA4_2 = this->LA(2);
                        if ( (this->msynpred( antlr3::ClassForwarder<synpred7_PLSQLParser>() )))
                        {
                            alt4=7;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred8_PLSQLParser>() )))
                        {
                            alt4=8;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred9_PLSQLParser>() )))
                        {
                            alt4=9;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred10_PLSQLParser>() )))
                        {
                            alt4=10;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred11_PLSQLParser>() )))
                        {
                            alt4=11;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred12_PLSQLParser>() )))
                        {
                            alt4=12;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 4 );
                            ex->set_state( 2 );


                            goto ruleunit_statementEx;

                        }
                    }
                }
                else if ( (LA4_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "EXPLAIN")))||((equalsIgnoreCase(LT(1)->getText(), "MERGE"))))))
                {
                    {
                        int LA4_3 = this->LA(2);
                        if ( (( (this->msynpred( antlr3::ClassForwarder<synpred7_PLSQLParser>() )) && ((equalsIgnoreCase(LT(1)->getText(), "FUNCTION"))) )))
                        {
                            alt4=7;
                        }
                        else if ( ((((equalsIgnoreCase(LT(1)->getText(), "EXPLAIN")))||((equalsIgnoreCase(LT(1)->getText(), "MERGE"))))))
                        {
                            alt4=19;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 4 );
                            ex->set_state( 3 );


                            goto ruleunit_statementEx;

                        }
                    }
                }
                else if ( (LA4_0 == SQL92_RESERVED_PROCEDURE))
                {
                    alt4=8;
                }
                else if ( (LA4_0 == SQL92_RESERVED_DROP))
                {
                    {
                        int LA4_5 = this->LA(2);
                        if ( (this->msynpred( antlr3::ClassForwarder<synpred13_PLSQLParser>() )))
                        {
                            alt4=13;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred14_PLSQLParser>() )))
                        {
                            alt4=14;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred15_PLSQLParser>() )))
                        {
                            alt4=15;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred16_PLSQLParser>() )))
                        {
                            alt4=16;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred17_PLSQLParser>() )))
                        {
                            alt4=17;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred18_PLSQLParser>() )))
                        {
                            alt4=18;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 4 );
                            ex->set_state( 5 );


                            goto ruleunit_statementEx;

                        }
                    }
                }
                else if ( (LA4_0 == LEFT_PAREN || LA4_0 == PLSQL_RESERVED_LOCK || LA4_0 == SQL92_RESERVED_DELETE || LA4_0 == SQL92_RESERVED_INSERT || LA4_0 == SQL92_RESERVED_SELECT || LA4_0 == SQL92_RESERVED_UPDATE || LA4_0 == SQL92_RESERVED_WITH))
                {
                    alt4=19;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 4 );
                    ex->set_state( 0 );


                    goto ruleunit_statementEx;

                }
            }
            switch (alt4)
            {
        	case 1:
        	    // PLSQLParser.g:71:11: alter_function
        	    {
        	        this->followPush(FOLLOW_alter_function_in_unit_statement175);
        	        alter_function();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:72:10: alter_package
        	    {
        	        this->followPush(FOLLOW_alter_package_in_unit_statement186);
        	        alter_package();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLParser.g:73:10: alter_procedure
        	    {
        	        this->followPush(FOLLOW_alter_procedure_in_unit_statement197);
        	        alter_procedure();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQLParser.g:74:10: alter_sequence
        	    {
        	        this->followPush(FOLLOW_alter_sequence_in_unit_statement208);
        	        alter_sequence();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQLParser.g:75:10: alter_trigger
        	    {
        	        this->followPush(FOLLOW_alter_trigger_in_unit_statement219);
        	        alter_trigger();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // PLSQLParser.g:76:10: alter_type
        	    {
        	        this->followPush(FOLLOW_alter_type_in_unit_statement230);
        	        alter_type();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 7:
        	    // PLSQLParser.g:78:10: create_function_body
        	    {
        	        this->followPush(FOLLOW_create_function_body_in_unit_statement242);
        	        create_function_body();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 8:
        	    // PLSQLParser.g:79:10: create_procedure_body
        	    {
        	        this->followPush(FOLLOW_create_procedure_body_in_unit_statement253);
        	        create_procedure_body();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 9:
        	    // PLSQLParser.g:80:10: create_package
        	    {
        	        this->followPush(FOLLOW_create_package_in_unit_statement264);
        	        create_package();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 10:
        	    // PLSQLParser.g:88:10: create_sequence
        	    {
        	        this->followPush(FOLLOW_create_sequence_in_unit_statement282);
        	        create_sequence();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 11:
        	    // PLSQLParser.g:89:10: create_trigger
        	    {
        	        this->followPush(FOLLOW_create_trigger_in_unit_statement293);
        	        create_trigger();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 12:
        	    // PLSQLParser.g:90:10: create_type
        	    {
        	        this->followPush(FOLLOW_create_type_in_unit_statement304);
        	        create_type();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 13:
        	    // PLSQLParser.g:92:10: drop_function
        	    {
        	        this->followPush(FOLLOW_drop_function_in_unit_statement316);
        	        drop_function();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 14:
        	    // PLSQLParser.g:93:10: drop_package
        	    {
        	        this->followPush(FOLLOW_drop_package_in_unit_statement327);
        	        drop_package();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 15:
        	    // PLSQLParser.g:94:10: drop_procedure
        	    {
        	        this->followPush(FOLLOW_drop_procedure_in_unit_statement338);
        	        drop_procedure();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 16:
        	    // PLSQLParser.g:95:10: drop_sequence
        	    {
        	        this->followPush(FOLLOW_drop_sequence_in_unit_statement349);
        	        drop_sequence();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 17:
        	    // PLSQLParser.g:96:10: drop_trigger
        	    {
        	        this->followPush(FOLLOW_drop_trigger_in_unit_statement360);
        	        drop_trigger();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 18:
        	    // PLSQLParser.g:97:10: drop_type
        	    {
        	        this->followPush(FOLLOW_drop_type_in_unit_statement371);
        	        drop_type();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 19:
        	    // PLSQLParser.g:98:10: data_manipulation_language_statements
        	    {
        	        this->followPush(FOLLOW_data_manipulation_language_statements_in_unit_statement382);
        	        data_manipulation_language_statements();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunit_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleunit_statementEx; /* Prevent compiler warnings */
    ruleunit_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unit_statement */

/**
 * $ANTLR start drop_function
 * PLSQLParser.g:105:1: drop_function : drop_key function_key function_name SEMICOLON ;
 */
void
PLSQLParser::drop_function()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:106:5: ( drop_key function_key function_name SEMICOLON )
        // PLSQLParser.g:106:10: drop_key function_key function_name SEMICOLON
        {
            this->followPush(FOLLOW_drop_key_in_drop_function406);
            drop_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledrop_functionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_function_key_in_drop_function408);
            function_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledrop_functionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_function_name_in_drop_function410);
            function_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledrop_functionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_drop_function420);
            if  (this->hasException())
            {
                goto ruledrop_functionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledrop_functionEx; /* Prevent compiler warnings */
    ruledrop_functionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end drop_function */

/**
 * $ANTLR start alter_function
 * PLSQLParser.g:110:1: alter_function : alter_key function_key function_name compile_key ( debug_key )? ( compiler_parameters_clause )* ( reuse_key settings_key )? SEMICOLON ;
 */
void
PLSQLParser::alter_function()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:111:5: ( alter_key function_key function_name compile_key ( debug_key )? ( compiler_parameters_clause )* ( reuse_key settings_key )? SEMICOLON )
        // PLSQLParser.g:111:10: alter_key function_key function_name compile_key ( debug_key )? ( compiler_parameters_clause )* ( reuse_key settings_key )? SEMICOLON
        {
            this->followPush(FOLLOW_alter_key_in_alter_function440);
            alter_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_functionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_function_key_in_alter_function442);
            function_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_functionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_function_name_in_alter_function444);
            function_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_functionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_compile_key_in_alter_function454);
            compile_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_functionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:112:21: ( debug_key )?
            {
                int alt5=2;
                {
                    int LA5_0 = this->LA(1);
                    if ( (LA5_0 == REGULAR_ID))
                    {
                        {
                            int LA5_1 = this->LA(2);
                            if ( (LA5_1 == DELIMITED_ID || LA5_1 == INTRODUCER || LA5_1 == SEMICOLON))
                            {
                                alt5=1;
                            }
                            else if ( (LA5_1 == REGULAR_ID))
                            {
                                {
                                    int LA5_4 = this->LA(3);
                                    if ( (LA5_4 == EQUALS_OP || LA5_4 == REGULAR_ID))
                                    {
                                        alt5=1;
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt5)
                {
            	case 1:
            	    // PLSQLParser.g:112:21: debug_key
            	    {
            	        this->followPush(FOLLOW_debug_key_in_alter_function456);
            	        debug_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_functionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:112:32: ( compiler_parameters_clause )*

            for (;;)
            {
                int alt6=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA6_0 = this->LA(1);
                    if ( (LA6_0 == REGULAR_ID))
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA6_1 = this->LA(2);
                            if ( (LA6_1 == EQUALS_OP))
                            {
                                alt6=1;
                            }

                        }
                    }
                    else if ( (LA6_0 == DELIMITED_ID || LA6_0 == INTRODUCER))
                    {
                        alt6=1;
                    }

                }
                switch (alt6)
                {
            	case 1:
            	    // PLSQLParser.g:112:32: compiler_parameters_clause
            	    {
            	        this->followPush(FOLLOW_compiler_parameters_clause_in_alter_function459);
            	        compiler_parameters_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_functionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop6;	/* break out of the loop */
            	    break;
                }
            }
            loop6: ; /* Jump out to here if this rule does not match */


            // PLSQLParser.g:113:9: ( reuse_key settings_key )?
            {
                int alt7=2;
                {
                    int LA7_0 = this->LA(1);
                    if ( (LA7_0 == REGULAR_ID))
                    {
                        alt7=1;
                    }
                }
                switch (alt7)
                {
            	case 1:
            	    // PLSQLParser.g:113:10: reuse_key settings_key
            	    {
            	        this->followPush(FOLLOW_reuse_key_in_alter_function471);
            	        reuse_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_functionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_settings_key_in_alter_function473);
            	        settings_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_functionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_alter_function485);
            if  (this->hasException())
            {
                goto rulealter_functionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealter_functionEx; /* Prevent compiler warnings */
    rulealter_functionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end alter_function */

/**
 * $ANTLR start create_function_body
 * PLSQLParser.g:117:1: create_function_body : ( create_key ( or_key replace_key )? )? function_key function_name ( LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN )? return_key type_spec ( invoker_rights_clause | parallel_enable_clause | result_cache_clause | deterministic_key )* ( ( ( pipelined_key )? ( is_key | as_key ) ( ( declare_key )? ( declare_spec )* body | call_spec ) ) | ( pipelined_key | aggregate_key ) using_key implementation_type_name ) SEMICOLON ;
 */
void
PLSQLParser::create_function_body()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:118:5: ( ( create_key ( or_key replace_key )? )? function_key function_name ( LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN )? return_key type_spec ( invoker_rights_clause | parallel_enable_clause | result_cache_clause | deterministic_key )* ( ( ( pipelined_key )? ( is_key | as_key ) ( ( declare_key )? ( declare_spec )* body | call_spec ) ) | ( pipelined_key | aggregate_key ) using_key implementation_type_name ) SEMICOLON )
        // PLSQLParser.g:118:10: ( create_key ( or_key replace_key )? )? function_key function_name ( LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN )? return_key type_spec ( invoker_rights_clause | parallel_enable_clause | result_cache_clause | deterministic_key )* ( ( ( pipelined_key )? ( is_key | as_key ) ( ( declare_key )? ( declare_spec )* body | call_spec ) ) | ( pipelined_key | aggregate_key ) using_key implementation_type_name ) SEMICOLON
        {
            // PLSQLParser.g:118:10: ( create_key ( or_key replace_key )? )?
            {
                int alt9=2;
                {
                    int LA9_0 = this->LA(1);
                    if ( (LA9_0 == SQL92_RESERVED_CREATE))
                    {
                        alt9=1;
                    }
                }
                switch (alt9)
                {
            	case 1:
            	    // PLSQLParser.g:118:11: create_key ( or_key replace_key )?
            	    {
            	        this->followPush(FOLLOW_create_key_in_create_function_body506);
            	        create_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_function_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:118:22: ( or_key replace_key )?
            	        {
            	            int alt8=2;
            	            {
            	                int LA8_0 = this->LA(1);
            	                if ( (LA8_0 == SQL92_RESERVED_OR))
            	                {
            	                    alt8=1;
            	                }
            	            }
            	            switch (alt8)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:118:24: or_key replace_key
            	        	    {
            	        	        this->followPush(FOLLOW_or_key_in_create_function_body510);
            	        	        or_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecreate_function_bodyEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_replace_key_in_create_function_body512);
            	        	        replace_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecreate_function_bodyEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_function_key_in_create_function_body519);
            function_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecreate_function_bodyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_function_name_in_create_function_body521);
            function_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecreate_function_bodyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:119:15: ( LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN )?
            {
                int alt11=2;
                {
                    int LA11_0 = this->LA(1);
                    if ( (LA11_0 == LEFT_PAREN))
                    {
                        alt11=1;
                    }
                }
                switch (alt11)
                {
            	case 1:
            	    // PLSQLParser.g:119:17: LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_create_function_body540);
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_function_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_parameter_in_create_function_body542);
            	        parameter();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_function_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:119:38: ( COMMA parameter )*

            	        for (;;)
            	        {
            	            int alt10=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA10_0 = this->LA(1);
            	                if ( (LA10_0 == COMMA))
            	                {
            	                    alt10=1;
            	                }

            	            }
            	            switch (alt10)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:119:39: COMMA parameter
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_create_function_body545);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecreate_function_bodyEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_parameter_in_create_function_body547);
            	        	        parameter();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecreate_function_bodyEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop10;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop10: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_create_function_body551);
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_function_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_return_key_in_create_function_body563);
            return_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecreate_function_bodyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_spec_in_create_function_body565);
            type_spec();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecreate_function_bodyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:121:17: ( invoker_rights_clause | parallel_enable_clause | result_cache_clause | deterministic_key )*

            for (;;)
            {
                int alt12=5;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA12_0 = this->LA(1);
                    if ( (LA12_0 == REGULAR_ID))
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA12_1 = this->LA(2);
                            if ( (LA12_1 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "AUTHID"))))
                            {
                                alt12=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "PARALLEL_ENABLE"))))
                            {
                                alt12=2;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "RESULT_CACHE"))))
                            {
                                alt12=3;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "DETERMINISTIC"))))
                            {
                                alt12=4;
                            }

                        }
                    }

                }
                switch (alt12)
                {
            	case 1:
            	    // PLSQLParser.g:121:18: invoker_rights_clause
            	    {
            	        this->followPush(FOLLOW_invoker_rights_clause_in_create_function_body584);
            	        invoker_rights_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_function_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:121:40: parallel_enable_clause
            	    {
            	        this->followPush(FOLLOW_parallel_enable_clause_in_create_function_body586);
            	        parallel_enable_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_function_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLParser.g:121:63: result_cache_clause
            	    {
            	        this->followPush(FOLLOW_result_cache_clause_in_create_function_body588);
            	        result_cache_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_function_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 4:
            	    // PLSQLParser.g:121:83: deterministic_key
            	    {
            	        this->followPush(FOLLOW_deterministic_key_in_create_function_body590);
            	        deterministic_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_function_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop12;	/* break out of the loop */
            	    break;
                }
            }
            loop12: ; /* Jump out to here if this rule does not match */


            // PLSQLParser.g:122:9: ( ( ( pipelined_key )? ( is_key | as_key ) ( ( declare_key )? ( declare_spec )* body | call_spec ) ) | ( pipelined_key | aggregate_key ) using_key implementation_type_name )
            {
                int alt19=2;
                {
                    int LA19_0 = this->LA(1);
                    if ( (LA19_0 == REGULAR_ID))
                    {
                        {
                            int LA19_1 = this->LA(2);
                            if ( (LA19_1 == SQL92_RESERVED_AS || LA19_1 == SQL92_RESERVED_IS) && ((equalsIgnoreCase(LT(1)->getText(), "PIPELINED"))))
                            {
                                alt19=1;
                            }
                            else if ( (LA19_1 == PLSQL_NON_RESERVED_USING))
                            {
                                alt19=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 19 );
                                ex->set_state( 1 );


                                goto rulecreate_function_bodyEx;

                            }
                        }
                    }
                    else if ( (LA19_0 == SQL92_RESERVED_AS || LA19_0 == SQL92_RESERVED_IS))
                    {
                        alt19=1;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 19 );
                        ex->set_state( 0 );


                        goto rulecreate_function_bodyEx;

                    }
                }
                switch (alt19)
                {
            	case 1:
            	    // PLSQLParser.g:123:13: ( ( pipelined_key )? ( is_key | as_key ) ( ( declare_key )? ( declare_spec )* body | call_spec ) )
            	    {
            	        // PLSQLParser.g:123:13: ( ( pipelined_key )? ( is_key | as_key ) ( ( declare_key )? ( declare_spec )* body | call_spec ) )
            	        // PLSQLParser.g:123:18: ( pipelined_key )? ( is_key | as_key ) ( ( declare_key )? ( declare_spec )* body | call_spec )
            	        {
            	            // PLSQLParser.g:123:18: ( pipelined_key )?
            	            {
            	                int alt13=2;
            	                {
            	                    int LA13_0 = this->LA(1);
            	                    if ( (LA13_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "PIPELINED"))))
            	                    {
            	                        alt13=1;
            	                    }
            	                }
            	                switch (alt13)
            	                {
            	            	case 1:
            	            	    // PLSQLParser.g:123:18: pipelined_key
            	            	    {
            	            	        this->followPush(FOLLOW_pipelined_key_in_create_function_body621);
            	            	        pipelined_key();

            	            	        this->followPop();
            	            	        if  (this->hasException())
            	            	        {
            	            	            goto rulecreate_function_bodyEx;
            	            	        }
            	            	        if (this->hasFailed())
            	            	        {
            	            	            return ;
            	            	        }


            	            	    }
            	            	    break;

            	                }
            	            }

            	            // PLSQLParser.g:123:33: ( is_key | as_key )
            	            {
            	                int alt14=2;
            	                {
            	                    int LA14_0 = this->LA(1);
            	                    if ( (LA14_0 == SQL92_RESERVED_IS))
            	                    {
            	                        alt14=1;
            	                    }
            	                    else if ( (LA14_0 == SQL92_RESERVED_AS))
            	                    {
            	                        alt14=2;
            	                    }
            	                    else
            	                    {
            	                        if (this->get_backtracking()>0)
            	                        {
            	                            this->set_failedflag( true );
            	                            return ;
            	                        }


            	                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                        ex->set_decisionNum( 14 );
            	                        ex->set_state( 0 );


            	                        goto rulecreate_function_bodyEx;

            	                    }
            	                }
            	                switch (alt14)
            	                {
            	            	case 1:
            	            	    // PLSQLParser.g:123:35: is_key
            	            	    {
            	            	        this->followPush(FOLLOW_is_key_in_create_function_body626);
            	            	        is_key();

            	            	        this->followPop();
            	            	        if  (this->hasException())
            	            	        {
            	            	            goto rulecreate_function_bodyEx;
            	            	        }
            	            	        if (this->hasFailed())
            	            	        {
            	            	            return ;
            	            	        }


            	            	    }
            	            	    break;
            	            	case 2:
            	            	    // PLSQLParser.g:123:44: as_key
            	            	    {
            	            	        this->followPush(FOLLOW_as_key_in_create_function_body630);
            	            	        as_key();

            	            	        this->followPop();
            	            	        if  (this->hasException())
            	            	        {
            	            	            goto rulecreate_function_bodyEx;
            	            	        }
            	            	        if (this->hasFailed())
            	            	        {
            	            	            return ;
            	            	        }


            	            	    }
            	            	    break;

            	                }
            	            }

            	            // PLSQLParser.g:124:23: ( ( declare_key )? ( declare_spec )* body | call_spec )
            	            {
            	                int alt17=2;
            	                {
            	                    int LA17_0 = this->LA(1);
            	                    if ( (LA17_0 == BINDVAR || LA17_0 == COLON || LA17_0 == DELIMITED_ID || LA17_0 == INTRODUCER || LA17_0 == SQL92_RESERVED_BEGIN || LA17_0 == SQL92_RESERVED_CREATE || LA17_0 == SQL92_RESERVED_CURSOR || LA17_0 == SQL92_RESERVED_DECLARE || LA17_0 == SQL92_RESERVED_PROCEDURE))
            	                    {
            	                        alt17=1;
            	                    }
            	                    else if ( (LA17_0 == REGULAR_ID))
            	                    {
            	                        {
            	                            int LA17_3 = this->LA(2);
            	                            if ( (!( ((equalsIgnoreCase(LT(1)->getText(), "LANGUAGE"))) )))
            	                            {
            	                                alt17=1;
            	                            }
            	                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "LANGUAGE"))))
            	                            {
            	                                alt17=2;
            	                            }
            	                            else
            	                            {
            	                                if (this->get_backtracking()>0)
            	                                {
            	                                    this->set_failedflag( true );
            	                                    return ;
            	                                }


            	                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                                ex->set_decisionNum( 17 );
            	                                ex->set_state( 3 );


            	                                goto rulecreate_function_bodyEx;

            	                            }
            	                        }
            	                    }
            	                    else
            	                    {
            	                        if (this->get_backtracking()>0)
            	                        {
            	                            this->set_failedflag( true );
            	                            return ;
            	                        }


            	                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                        ex->set_decisionNum( 17 );
            	                        ex->set_state( 0 );


            	                        goto rulecreate_function_bodyEx;

            	                    }
            	                }
            	                switch (alt17)
            	                {
            	            	case 1:
            	            	    // PLSQLParser.g:124:28: ( declare_key )? ( declare_spec )* body
            	            	    {
            	            	        // PLSQLParser.g:124:28: ( declare_key )?
            	            	        {
            	            	            int alt15=2;
            	            	            {
            	            	                int LA15_0 = this->LA(1);
            	            	                if ( (LA15_0 == SQL92_RESERVED_DECLARE))
            	            	                {
            	            	                    alt15=1;
            	            	                }
            	            	            }
            	            	            switch (alt15)
            	            	            {
            	            	        	case 1:
            	            	        	    // PLSQLParser.g:124:28: declare_key
            	            	        	    {
            	            	        	        this->followPush(FOLLOW_declare_key_in_create_function_body661);
            	            	        	        declare_key();

            	            	        	        this->followPop();
            	            	        	        if  (this->hasException())
            	            	        	        {
            	            	        	            goto rulecreate_function_bodyEx;
            	            	        	        }
            	            	        	        if (this->hasFailed())
            	            	        	        {
            	            	        	            return ;
            	            	        	        }


            	            	        	    }
            	            	        	    break;

            	            	            }
            	            	        }

            	            	        // PLSQLParser.g:124:41: ( declare_spec )*

            	            	        for (;;)
            	            	        {
            	            	            int alt16=2;
            	            	            {
            	            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            	                */
            	            	                int LA16_0 = this->LA(1);
            	            	                if ( (LA16_0 == BINDVAR || LA16_0 == COLON || LA16_0 == DELIMITED_ID || LA16_0 == INTRODUCER || LA16_0 == REGULAR_ID || LA16_0 == SQL92_RESERVED_CREATE || LA16_0 == SQL92_RESERVED_CURSOR || LA16_0 == SQL92_RESERVED_PROCEDURE))
            	            	                {
            	            	                    alt16=1;
            	            	                }

            	            	            }
            	            	            switch (alt16)
            	            	            {
            	            	        	case 1:
            	            	        	    // PLSQLParser.g:124:41: declare_spec
            	            	        	    {
            	            	        	        this->followPush(FOLLOW_declare_spec_in_create_function_body664);
            	            	        	        declare_spec();

            	            	        	        this->followPop();
            	            	        	        if  (this->hasException())
            	            	        	        {
            	            	        	            goto rulecreate_function_bodyEx;
            	            	        	        }
            	            	        	        if (this->hasFailed())
            	            	        	        {
            	            	        	            return ;
            	            	        	        }


            	            	        	    }
            	            	        	    break;

            	            	        	default:
            	            	        	    goto loop16;	/* break out of the loop */
            	            	        	    break;
            	            	            }
            	            	        }
            	            	        loop16: ; /* Jump out to here if this rule does not match */


            	            	        this->followPush(FOLLOW_body_in_create_function_body667);
            	            	        body();

            	            	        this->followPop();
            	            	        if  (this->hasException())
            	            	        {
            	            	            goto rulecreate_function_bodyEx;
            	            	        }
            	            	        if (this->hasFailed())
            	            	        {
            	            	            return ;
            	            	        }


            	            	    }
            	            	    break;
            	            	case 2:
            	            	    // PLSQLParser.g:125:28: call_spec
            	            	    {
            	            	        this->followPush(FOLLOW_call_spec_in_create_function_body697);
            	            	        call_spec();

            	            	        this->followPop();
            	            	        if  (this->hasException())
            	            	        {
            	            	            goto rulecreate_function_bodyEx;
            	            	        }
            	            	        if (this->hasFailed())
            	            	        {
            	            	            return ;
            	            	        }


            	            	    }
            	            	    break;

            	                }
            	            }

            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:127:14: ( pipelined_key | aggregate_key ) using_key implementation_type_name
            	    {
            	        // PLSQLParser.g:127:14: ( pipelined_key | aggregate_key )
            	        {
            	            int alt18=2;
            	            {
            	                int LA18_0 = this->LA(1);
            	                if ( (LA18_0 == REGULAR_ID))
            	                {
            	                    {
            	                        int LA18_1 = this->LA(2);
            	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "PIPELINED"))))
            	                        {
            	                            alt18=1;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "AGGREGATE"))))
            	                        {
            	                            alt18=2;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 18 );
            	                            ex->set_state( 1 );


            	                            goto rulecreate_function_bodyEx;

            	                        }
            	                    }
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 18 );
            	                    ex->set_state( 0 );


            	                    goto rulecreate_function_bodyEx;

            	                }
            	            }
            	            switch (alt18)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:127:15: pipelined_key
            	        	    {
            	        	        this->followPush(FOLLOW_pipelined_key_in_create_function_body728);
            	        	        pipelined_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecreate_function_bodyEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQLParser.g:127:29: aggregate_key
            	        	    {
            	        	        this->followPush(FOLLOW_aggregate_key_in_create_function_body730);
            	        	        aggregate_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecreate_function_bodyEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_using_key_in_create_function_body733);
            	        using_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_function_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_implementation_type_name_in_create_function_body735);
            	        implementation_type_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_function_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_create_function_body761);
            if  (this->hasException())
            {
                goto rulecreate_function_bodyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecreate_function_bodyEx; /* Prevent compiler warnings */
    rulecreate_function_bodyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end create_function_body */

/**
 * $ANTLR start parallel_enable_clause
 * PLSQLParser.g:134:1: parallel_enable_clause : parallel_enable_key ( partition_by_clause )? ;
 */
void
PLSQLParser::parallel_enable_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:135:5: ( parallel_enable_key ( partition_by_clause )? )
        // PLSQLParser.g:135:10: parallel_enable_key ( partition_by_clause )?
        {
            this->followPush(FOLLOW_parallel_enable_key_in_parallel_enable_clause783);
            parallel_enable_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleparallel_enable_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:135:30: ( partition_by_clause )?
            {
                int alt20=2;
                {
                    int LA20_0 = this->LA(1);
                    if ( (LA20_0 == LEFT_PAREN))
                    {
                        alt20=1;
                    }
                }
                switch (alt20)
                {
            	case 1:
            	    // PLSQLParser.g:135:30: partition_by_clause
            	    {
            	        this->followPush(FOLLOW_partition_by_clause_in_parallel_enable_clause785);
            	        partition_by_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleparallel_enable_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleparallel_enable_clauseEx; /* Prevent compiler warnings */
    ruleparallel_enable_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end parallel_enable_clause */

/**
 * $ANTLR start partition_by_clause
 * PLSQLParser.g:138:1: partition_by_clause : LEFT_PAREN partition_key expression by_key ( any_key | ( hash_key | range_key ) LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) ( streaming_clause )? RIGHT_PAREN ;
 */
void
PLSQLParser::partition_by_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:139:5: ( LEFT_PAREN partition_key expression by_key ( any_key | ( hash_key | range_key ) LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) ( streaming_clause )? RIGHT_PAREN )
        // PLSQLParser.g:139:10: LEFT_PAREN partition_key expression by_key ( any_key | ( hash_key | range_key ) LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) ( streaming_clause )? RIGHT_PAREN
        {
             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_partition_by_clause806);
            if  (this->hasException())
            {
                goto rulepartition_by_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_partition_key_in_partition_by_clause820);
            partition_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepartition_by_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_partition_by_clause822);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepartition_by_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_by_key_in_partition_by_clause824);
            by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepartition_by_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:141:13: ( any_key | ( hash_key | range_key ) LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
            {
                int alt23=2;
                {
                    int LA23_0 = this->LA(1);
                    if ( (LA23_0 == SQL92_RESERVED_ANY))
                    {
                        alt23=1;
                    }
                    else if ( (LA23_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "RANGE")))||((equalsIgnoreCase(LT(1)->getText(), "HASH"))))))
                    {
                        alt23=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 23 );
                        ex->set_state( 0 );


                        goto rulepartition_by_clauseEx;

                    }
                }
                switch (alt23)
                {
            	case 1:
            	    // PLSQLParser.g:141:18: any_key
            	    {
            	        this->followPush(FOLLOW_any_key_in_partition_by_clause844);
            	        any_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepartition_by_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:142:18: ( hash_key | range_key ) LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	        // PLSQLParser.g:142:18: ( hash_key | range_key )
            	        {
            	            int alt21=2;
            	            {
            	                int LA21_0 = this->LA(1);
            	                if ( (LA21_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "RANGE")))||((equalsIgnoreCase(LT(1)->getText(), "HASH"))))))
            	                {
            	                    {
            	                        int LA21_1 = this->LA(2);
            	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "HASH"))))
            	                        {
            	                            alt21=1;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "RANGE"))))
            	                        {
            	                            alt21=2;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 21 );
            	                            ex->set_state( 1 );


            	                            goto rulepartition_by_clauseEx;

            	                        }
            	                    }
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 21 );
            	                    ex->set_state( 0 );


            	                    goto rulepartition_by_clauseEx;

            	                }
            	            }
            	            switch (alt21)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:142:19: hash_key
            	        	    {
            	        	        this->followPush(FOLLOW_hash_key_in_partition_by_clause865);
            	        	        hash_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepartition_by_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQLParser.g:142:28: range_key
            	        	    {
            	        	        this->followPush(FOLLOW_range_key_in_partition_by_clause867);
            	        	        range_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepartition_by_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_partition_by_clause870);
            	        if  (this->hasException())
            	        {
            	            goto rulepartition_by_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_partition_by_clause872);
            	        column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepartition_by_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:142:62: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            int alt22=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA22_0 = this->LA(1);
            	                if ( (LA22_0 == COMMA))
            	                {
            	                    alt22=1;
            	                }

            	            }
            	            switch (alt22)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:142:63: COMMA column_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_partition_by_clause875);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepartition_by_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_column_name_in_partition_by_clause877);
            	        	        column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepartition_by_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop22;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop22: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_partition_by_clause881);
            	        if  (this->hasException())
            	        {
            	            goto rulepartition_by_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:144:13: ( streaming_clause )?
            {
                int alt24=2;
                {
                    int LA24_0 = this->LA(1);
                    if ( (LA24_0 == SQL92_RESERVED_ORDER))
                    {
                        alt24=1;
                    }
                    else if ( (LA24_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "CLUSTER"))))
                    {
                        alt24=1;
                    }
                }
                switch (alt24)
                {
            	case 1:
            	    // PLSQLParser.g:144:13: streaming_clause
            	    {
            	        this->followPush(FOLLOW_streaming_clause_in_partition_by_clause909);
            	        streaming_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepartition_by_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_partition_by_clause920);
            if  (this->hasException())
            {
                goto rulepartition_by_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepartition_by_clauseEx; /* Prevent compiler warnings */
    rulepartition_by_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end partition_by_clause */

/**
 * $ANTLR start result_cache_clause
 * PLSQLParser.g:148:1: result_cache_clause : result_cache_key ( relies_on_part )? ;
 */
void
PLSQLParser::result_cache_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:149:5: ( result_cache_key ( relies_on_part )? )
        // PLSQLParser.g:149:10: result_cache_key ( relies_on_part )?
        {
            this->followPush(FOLLOW_result_cache_key_in_result_cache_clause940);
            result_cache_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleresult_cache_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:149:27: ( relies_on_part )?
            {
                int alt25=2;
                {
                    int LA25_0 = this->LA(1);
                    if ( (LA25_0 == REGULAR_ID))
                    {
                        {
                            int LA25_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "RELIES_ON"))))
                            {
                                alt25=1;
                            }
                        }
                    }
                }
                switch (alt25)
                {
            	case 1:
            	    // PLSQLParser.g:149:27: relies_on_part
            	    {
            	        this->followPush(FOLLOW_relies_on_part_in_result_cache_clause942);
            	        relies_on_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleresult_cache_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleresult_cache_clauseEx; /* Prevent compiler warnings */
    ruleresult_cache_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end result_cache_clause */

/**
 * $ANTLR start relies_on_part
 * PLSQLParser.g:152:1: relies_on_part : relies_on_key LEFT_PAREN tableview_name ( COMMA tableview_name )* RIGHT_PAREN ;
 */
void
PLSQLParser::relies_on_part()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:153:5: ( relies_on_key LEFT_PAREN tableview_name ( COMMA tableview_name )* RIGHT_PAREN )
        // PLSQLParser.g:153:10: relies_on_key LEFT_PAREN tableview_name ( COMMA tableview_name )* RIGHT_PAREN
        {
            this->followPush(FOLLOW_relies_on_key_in_relies_on_part963);
            relies_on_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerelies_on_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_relies_on_part965);
            if  (this->hasException())
            {
                goto rulerelies_on_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_tableview_name_in_relies_on_part967);
            tableview_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerelies_on_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:153:50: ( COMMA tableview_name )*

            for (;;)
            {
                int alt26=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA26_0 = this->LA(1);
                    if ( (LA26_0 == COMMA))
                    {
                        alt26=1;
                    }

                }
                switch (alt26)
                {
            	case 1:
            	    // PLSQLParser.g:153:51: COMMA tableview_name
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_relies_on_part970);
            	        if  (this->hasException())
            	        {
            	            goto rulerelies_on_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_tableview_name_in_relies_on_part972);
            	        tableview_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerelies_on_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop26;	/* break out of the loop */
            	    break;
                }
            }
            loop26: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_relies_on_part976);
            if  (this->hasException())
            {
                goto rulerelies_on_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerelies_on_partEx; /* Prevent compiler warnings */
    rulerelies_on_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end relies_on_part */

/**
 * $ANTLR start streaming_clause
 * PLSQLParser.g:156:1: streaming_clause : ( order_key | cluster_key ) expression by_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ;
 */
void
PLSQLParser::streaming_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:157:5: ( ( order_key | cluster_key ) expression by_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
        // PLSQLParser.g:157:10: ( order_key | cluster_key ) expression by_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
        {
            // PLSQLParser.g:157:10: ( order_key | cluster_key )
            {
                int alt27=2;
                {
                    int LA27_0 = this->LA(1);
                    if ( (LA27_0 == SQL92_RESERVED_ORDER))
                    {
                        alt27=1;
                    }
                    else if ( (LA27_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "CLUSTER"))))
                    {
                        alt27=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 27 );
                        ex->set_state( 0 );


                        goto rulestreaming_clauseEx;

                    }
                }
                switch (alt27)
                {
            	case 1:
            	    // PLSQLParser.g:157:11: order_key
            	    {
            	        this->followPush(FOLLOW_order_key_in_streaming_clause997);
            	        order_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulestreaming_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:157:21: cluster_key
            	    {
            	        this->followPush(FOLLOW_cluster_key_in_streaming_clause999);
            	        cluster_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulestreaming_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_expression_in_streaming_clause1002);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestreaming_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_by_key_in_streaming_clause1004);
            by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestreaming_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_streaming_clause1015);
            if  (this->hasException())
            {
                goto rulestreaming_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_streaming_clause1017);
            column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestreaming_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:158:32: ( COMMA column_name )*

            for (;;)
            {
                int alt28=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA28_0 = this->LA(1);
                    if ( (LA28_0 == COMMA))
                    {
                        alt28=1;
                    }

                }
                switch (alt28)
                {
            	case 1:
            	    // PLSQLParser.g:158:33: COMMA column_name
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_streaming_clause1020);
            	        if  (this->hasException())
            	        {
            	            goto rulestreaming_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_streaming_clause1022);
            	        column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulestreaming_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop28;	/* break out of the loop */
            	    break;
                }
            }
            loop28: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_streaming_clause1026);
            if  (this->hasException())
            {
                goto rulestreaming_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestreaming_clauseEx; /* Prevent compiler warnings */
    rulestreaming_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end streaming_clause */

/**
 * $ANTLR start drop_package
 * PLSQLParser.g:165:1: drop_package : drop_key package_key ( body_key )? package_name SEMICOLON ;
 */
void
PLSQLParser::drop_package()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:166:5: ( drop_key package_key ( body_key )? package_name SEMICOLON )
        // PLSQLParser.g:166:10: drop_key package_key ( body_key )? package_name SEMICOLON
        {
            this->followPush(FOLLOW_drop_key_in_drop_package1050);
            drop_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledrop_packageEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_package_key_in_drop_package1052);
            package_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledrop_packageEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:166:31: ( body_key )?
            {
                int alt29=2;
                {
                    int LA29_0 = this->LA(1);
                    if ( (LA29_0 == REGULAR_ID))
                    {
                        {
                            int LA29_1 = this->LA(2);
                            if ( (LA29_1 == DELIMITED_ID || LA29_1 == INTRODUCER || LA29_1 == REGULAR_ID))
                            {
                                alt29=1;
                            }
                        }
                    }
                }
                switch (alt29)
                {
            	case 1:
            	    // PLSQLParser.g:166:31: body_key
            	    {
            	        this->followPush(FOLLOW_body_key_in_drop_package1054);
            	        body_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledrop_packageEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_package_name_in_drop_package1057);
            package_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledrop_packageEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_drop_package1067);
            if  (this->hasException())
            {
                goto ruledrop_packageEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledrop_packageEx; /* Prevent compiler warnings */
    ruledrop_packageEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end drop_package */

/**
 * $ANTLR start alter_package
 * PLSQLParser.g:170:1: alter_package : alter_key package_key package_name compile_key ( debug_key )? ( package_key | body_key | specification_key )? ( compiler_parameters_clause )* ( reuse_key settings_key )? SEMICOLON ;
 */
void
PLSQLParser::alter_package()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:171:5: ( alter_key package_key package_name compile_key ( debug_key )? ( package_key | body_key | specification_key )? ( compiler_parameters_clause )* ( reuse_key settings_key )? SEMICOLON )
        // PLSQLParser.g:171:10: alter_key package_key package_name compile_key ( debug_key )? ( package_key | body_key | specification_key )? ( compiler_parameters_clause )* ( reuse_key settings_key )? SEMICOLON
        {
            this->followPush(FOLLOW_alter_key_in_alter_package1087);
            alter_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_packageEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_package_key_in_alter_package1089);
            package_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_packageEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_package_name_in_alter_package1091);
            package_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_packageEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_compile_key_in_alter_package1101);
            compile_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_packageEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:172:21: ( debug_key )?
            {
                int alt30=2;
                {
                    int LA30_0 = this->LA(1);
                    if ( (LA30_0 == REGULAR_ID))
                    {
                        {
                            int LA30_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "DEBUG"))))
                            {
                                alt30=1;
                            }
                        }
                    }
                }
                switch (alt30)
                {
            	case 1:
            	    // PLSQLParser.g:172:21: debug_key
            	    {
            	        this->followPush(FOLLOW_debug_key_in_alter_package1103);
            	        debug_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_packageEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:172:32: ( package_key | body_key | specification_key )?
            {
                int alt31=4;
                {
                    int LA31_0 = this->LA(1);
                    if ( (LA31_0 == REGULAR_ID))
                    {
                        {
                            int LA31_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "PACKAGE"))))
                            {
                                alt31=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "BODY"))))
                            {
                                alt31=2;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "SPECIFICATION"))))
                            {
                                alt31=3;
                            }
                        }
                    }
                }
                switch (alt31)
                {
            	case 1:
            	    // PLSQLParser.g:172:33: package_key
            	    {
            	        this->followPush(FOLLOW_package_key_in_alter_package1107);
            	        package_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_packageEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:172:45: body_key
            	    {
            	        this->followPush(FOLLOW_body_key_in_alter_package1109);
            	        body_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_packageEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLParser.g:172:54: specification_key
            	    {
            	        this->followPush(FOLLOW_specification_key_in_alter_package1111);
            	        specification_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_packageEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:173:9: ( compiler_parameters_clause )*

            for (;;)
            {
                int alt32=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA32_0 = this->LA(1);
                    if ( (LA32_0 == REGULAR_ID))
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA32_1 = this->LA(2);
                            if ( (LA32_1 == EQUALS_OP))
                            {
                                alt32=1;
                            }

                        }
                    }
                    else if ( (LA32_0 == DELIMITED_ID || LA32_0 == INTRODUCER))
                    {
                        alt32=1;
                    }

                }
                switch (alt32)
                {
            	case 1:
            	    // PLSQLParser.g:173:9: compiler_parameters_clause
            	    {
            	        this->followPush(FOLLOW_compiler_parameters_clause_in_alter_package1123);
            	        compiler_parameters_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_packageEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop32;	/* break out of the loop */
            	    break;
                }
            }
            loop32: ; /* Jump out to here if this rule does not match */


            // PLSQLParser.g:174:9: ( reuse_key settings_key )?
            {
                int alt33=2;
                {
                    int LA33_0 = this->LA(1);
                    if ( (LA33_0 == REGULAR_ID))
                    {
                        alt33=1;
                    }
                }
                switch (alt33)
                {
            	case 1:
            	    // PLSQLParser.g:174:10: reuse_key settings_key
            	    {
            	        this->followPush(FOLLOW_reuse_key_in_alter_package1135);
            	        reuse_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_packageEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_settings_key_in_alter_package1137);
            	        settings_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_packageEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_alter_package1149);
            if  (this->hasException())
            {
                goto rulealter_packageEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealter_packageEx; /* Prevent compiler warnings */
    rulealter_packageEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end alter_package */

/**
 * $ANTLR start create_package
 * PLSQLParser.g:178:1: create_package : create_key ( or_key replace_key )? package_key ( package_spec | package_body )? SEMICOLON ;
 */
void
PLSQLParser::create_package()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:179:5: ( create_key ( or_key replace_key )? package_key ( package_spec | package_body )? SEMICOLON )
        // PLSQLParser.g:179:10: create_key ( or_key replace_key )? package_key ( package_spec | package_body )? SEMICOLON
        {
            this->followPush(FOLLOW_create_key_in_create_package1169);
            create_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecreate_packageEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:179:21: ( or_key replace_key )?
            {
                int alt34=2;
                {
                    int LA34_0 = this->LA(1);
                    if ( (LA34_0 == SQL92_RESERVED_OR))
                    {
                        alt34=1;
                    }
                }
                switch (alt34)
                {
            	case 1:
            	    // PLSQLParser.g:179:23: or_key replace_key
            	    {
            	        this->followPush(FOLLOW_or_key_in_create_package1173);
            	        or_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_packageEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_replace_key_in_create_package1175);
            	        replace_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_packageEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_package_key_in_create_package1180);
            package_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecreate_packageEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:180:9: ( package_spec | package_body )?
            {
                int alt35=3;
                {
                    int LA35_0 = this->LA(1);
                    if ( (LA35_0 == DELIMITED_ID || LA35_0 == INTRODUCER))
                    {
                        alt35=1;
                    }
                    else if ( (LA35_0 == REGULAR_ID))
                    {
                        switch ( this->LA(2) )
                        {
                            case REGULAR_ID:
                            	{
                            		{
                            		    int LA35_4 = this->LA(3);
                            		    if ( (LA35_4 == REGULAR_ID))
                            		    {
                            		        alt35=1;
                            		    }
                            		    else if ( (LA35_4 == SQL92_RESERVED_AS || LA35_4 == SQL92_RESERVED_IS))
                            		    {
                            		        alt35=2;
                            		    }
                            		}
                            	}
                                break;
                            case SQL92_RESERVED_AS:
                            case SQL92_RESERVED_IS:
                            	{
                            		alt35=1;
                            	}
                                break;
                            case DELIMITED_ID:
                            case INTRODUCER:
                            	{
                            		alt35=2;
                            	}
                                break;
                        }

                    }
                }
                switch (alt35)
                {
            	case 1:
            	    // PLSQLParser.g:180:11: package_spec
            	    {
            	        this->followPush(FOLLOW_package_spec_in_create_package1192);
            	        package_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_packageEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:180:26: package_body
            	    {
            	        this->followPush(FOLLOW_package_body_in_create_package1196);
            	        package_body();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_packageEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_create_package1209);
            if  (this->hasException())
            {
                goto rulecreate_packageEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecreate_packageEx; /* Prevent compiler warnings */
    rulecreate_packageEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end create_package */

/**
 * $ANTLR start package_body
 * PLSQLParser.g:186:1: package_body : body_key package_name ( is_key | as_key ) ( package_obj_body )* ( begin_key seq_of_statements | end_key ( package_name )? ) ;
 */
void
PLSQLParser::package_body()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:187:5: ( body_key package_name ( is_key | as_key ) ( package_obj_body )* ( begin_key seq_of_statements | end_key ( package_name )? ) )
        // PLSQLParser.g:187:10: body_key package_name ( is_key | as_key ) ( package_obj_body )* ( begin_key seq_of_statements | end_key ( package_name )? )
        {
            this->followPush(FOLLOW_body_key_in_package_body1231);
            body_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepackage_bodyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_package_name_in_package_body1233);
            package_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepackage_bodyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:187:32: ( is_key | as_key )
            {
                int alt36=2;
                {
                    int LA36_0 = this->LA(1);
                    if ( (LA36_0 == SQL92_RESERVED_IS))
                    {
                        alt36=1;
                    }
                    else if ( (LA36_0 == SQL92_RESERVED_AS))
                    {
                        alt36=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 36 );
                        ex->set_state( 0 );


                        goto rulepackage_bodyEx;

                    }
                }
                switch (alt36)
                {
            	case 1:
            	    // PLSQLParser.g:187:33: is_key
            	    {
            	        this->followPush(FOLLOW_is_key_in_package_body1236);
            	        is_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepackage_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:187:42: as_key
            	    {
            	        this->followPush(FOLLOW_as_key_in_package_body1240);
            	        as_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepackage_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:188:9: ( package_obj_body )*

            for (;;)
            {
                int alt37=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA37_0 = this->LA(1);
                    if ( (LA37_0 == BINDVAR || LA37_0 == COLON || LA37_0 == DELIMITED_ID || LA37_0 == INTRODUCER || LA37_0 == REGULAR_ID || LA37_0 == SQL92_RESERVED_CREATE || LA37_0 == SQL92_RESERVED_CURSOR || LA37_0 == SQL92_RESERVED_PROCEDURE))
                    {
                        alt37=1;
                    }

                }
                switch (alt37)
                {
            	case 1:
            	    // PLSQLParser.g:188:9: package_obj_body
            	    {
            	        this->followPush(FOLLOW_package_obj_body_in_package_body1251);
            	        package_obj_body();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepackage_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop37;	/* break out of the loop */
            	    break;
                }
            }
            loop37: ; /* Jump out to here if this rule does not match */


            // PLSQLParser.g:189:9: ( begin_key seq_of_statements | end_key ( package_name )? )
            {
                int alt39=2;
                {
                    int LA39_0 = this->LA(1);
                    if ( (LA39_0 == SQL92_RESERVED_BEGIN))
                    {
                        alt39=1;
                    }
                    else if ( (LA39_0 == SQL92_RESERVED_END))
                    {
                        alt39=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 39 );
                        ex->set_state( 0 );


                        goto rulepackage_bodyEx;

                    }
                }
                switch (alt39)
                {
            	case 1:
            	    // PLSQLParser.g:189:10: begin_key seq_of_statements
            	    {
            	        this->followPush(FOLLOW_begin_key_in_package_body1263);
            	        begin_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepackage_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_seq_of_statements_in_package_body1265);
            	        seq_of_statements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepackage_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:189:38: end_key ( package_name )?
            	    {
            	        this->followPush(FOLLOW_end_key_in_package_body1267);
            	        end_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepackage_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:189:46: ( package_name )?
            	        {
            	            int alt38=2;
            	            {
            	                int LA38_0 = this->LA(1);
            	                if ( (LA38_0 == DELIMITED_ID || LA38_0 == INTRODUCER || LA38_0 == REGULAR_ID))
            	                {
            	                    alt38=1;
            	                }
            	            }
            	            switch (alt38)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:189:46: package_name
            	        	    {
            	        	        this->followPush(FOLLOW_package_name_in_package_body1269);
            	        	        package_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepackage_bodyEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulepackage_bodyEx; /* Prevent compiler warnings */
    rulepackage_bodyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end package_body */

/**
 * $ANTLR start package_spec
 * PLSQLParser.g:192:1: package_spec : package_name ( invoker_rights_clause )? ( is_key | as_key ) ( package_obj_spec )* end_key ( package_name )? ;
 */
void
PLSQLParser::package_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:193:5: ( package_name ( invoker_rights_clause )? ( is_key | as_key ) ( package_obj_spec )* end_key ( package_name )? )
        // PLSQLParser.g:193:10: package_name ( invoker_rights_clause )? ( is_key | as_key ) ( package_obj_spec )* end_key ( package_name )?
        {
            this->followPush(FOLLOW_package_name_in_package_spec1291);
            package_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepackage_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:193:23: ( invoker_rights_clause )?
            {
                int alt40=2;
                {
                    int LA40_0 = this->LA(1);
                    if ( (LA40_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "AUTHID"))))
                    {
                        alt40=1;
                    }
                }
                switch (alt40)
                {
            	case 1:
            	    // PLSQLParser.g:193:23: invoker_rights_clause
            	    {
            	        this->followPush(FOLLOW_invoker_rights_clause_in_package_spec1293);
            	        invoker_rights_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepackage_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:193:46: ( is_key | as_key )
            {
                int alt41=2;
                {
                    int LA41_0 = this->LA(1);
                    if ( (LA41_0 == SQL92_RESERVED_IS))
                    {
                        alt41=1;
                    }
                    else if ( (LA41_0 == SQL92_RESERVED_AS))
                    {
                        alt41=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 41 );
                        ex->set_state( 0 );


                        goto rulepackage_specEx;

                    }
                }
                switch (alt41)
                {
            	case 1:
            	    // PLSQLParser.g:193:47: is_key
            	    {
            	        this->followPush(FOLLOW_is_key_in_package_spec1297);
            	        is_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepackage_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:193:56: as_key
            	    {
            	        this->followPush(FOLLOW_as_key_in_package_spec1301);
            	        as_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepackage_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:194:9: ( package_obj_spec )*

            for (;;)
            {
                int alt42=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA42_0 = this->LA(1);
                    if ( (LA42_0 == BINDVAR || LA42_0 == COLON || LA42_0 == DELIMITED_ID || LA42_0 == INTRODUCER || LA42_0 == REGULAR_ID || LA42_0 == SQL92_RESERVED_CURSOR || LA42_0 == SQL92_RESERVED_PROCEDURE))
                    {
                        alt42=1;
                    }

                }
                switch (alt42)
                {
            	case 1:
            	    // PLSQLParser.g:194:9: package_obj_spec
            	    {
            	        this->followPush(FOLLOW_package_obj_spec_in_package_spec1312);
            	        package_obj_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepackage_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop42;	/* break out of the loop */
            	    break;
                }
            }
            loop42: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_end_key_in_package_spec1323);
            end_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepackage_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:195:17: ( package_name )?
            {
                int alt43=2;
                {
                    int LA43_0 = this->LA(1);
                    if ( (LA43_0 == DELIMITED_ID || LA43_0 == INTRODUCER || LA43_0 == REGULAR_ID))
                    {
                        alt43=1;
                    }
                }
                switch (alt43)
                {
            	case 1:
            	    // PLSQLParser.g:195:17: package_name
            	    {
            	        this->followPush(FOLLOW_package_name_in_package_spec1325);
            	        package_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepackage_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulepackage_specEx; /* Prevent compiler warnings */
    rulepackage_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end package_spec */

/**
 * $ANTLR start package_obj_spec
 * PLSQLParser.g:198:1: package_obj_spec options {backtrack=true; } : ( variable_declaration | subtype_declaration | cursor_declaration | exception_declaration | record_declaration | table_declaration | procedure_spec | function_spec );
 */
void
PLSQLParser::package_obj_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:201:6: ( variable_declaration | subtype_declaration | cursor_declaration | exception_declaration | record_declaration | table_declaration | procedure_spec | function_spec )

            ANTLR_UINT32 alt44;

            alt44=8;

            switch ( this->LA(1) )
            {
            case INTRODUCER:
            	{
            		{
            		    int LA44_1 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred19_PLSQLParser>() )))
            		    {
            		        alt44=1;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQLParser>() )))
            		    {
            		        alt44=4;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred23_PLSQLParser>() )))
            		    {
            		        alt44=5;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred24_PLSQLParser>() )))
            		    {
            		        alt44=6;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 44 );
            		        ex->set_state( 1 );


            		        goto rulepackage_obj_specEx;

            		    }
            		}
            	}
                break;
            case REGULAR_ID:
            	{
            		{
            		    int LA44_2 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred19_PLSQLParser>() )))
            		    {
            		        alt44=1;
            		    }
            		    else if ( (( (this->msynpred( antlr3::ClassForwarder<synpred20_PLSQLParser>() )) && ((equalsIgnoreCase(LT(1)->getText(), "SUBTYPE"))) )))
            		    {
            		        alt44=2;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQLParser>() )))
            		    {
            		        alt44=4;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred23_PLSQLParser>() )))
            		    {
            		        alt44=5;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred24_PLSQLParser>() )))
            		    {
            		        alt44=6;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "FUNCTION"))))
            		    {
            		        alt44=8;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 44 );
            		        ex->set_state( 2 );


            		        goto rulepackage_obj_specEx;

            		    }
            		}
            	}
                break;
            case BINDVAR:
            	{
            		{
            		    int LA44_3 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred19_PLSQLParser>() )))
            		    {
            		        alt44=1;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred23_PLSQLParser>() )))
            		    {
            		        alt44=5;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 44 );
            		        ex->set_state( 3 );


            		        goto rulepackage_obj_specEx;

            		    }
            		}
            	}
                break;
            case COLON:
            	{
            		{
            		    int LA44_4 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred19_PLSQLParser>() )))
            		    {
            		        alt44=1;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred23_PLSQLParser>() )))
            		    {
            		        alt44=5;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 44 );
            		        ex->set_state( 4 );


            		        goto rulepackage_obj_specEx;

            		    }
            		}
            	}
                break;
            case DELIMITED_ID:
            	{
            		{
            		    int LA44_5 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred19_PLSQLParser>() )))
            		    {
            		        alt44=1;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQLParser>() )))
            		    {
            		        alt44=4;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred23_PLSQLParser>() )))
            		    {
            		        alt44=5;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred24_PLSQLParser>() )))
            		    {
            		        alt44=6;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 44 );
            		        ex->set_state( 5 );


            		        goto rulepackage_obj_specEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_CURSOR:
            	{
            		alt44=3;
            	}
                break;
            case SQL92_RESERVED_PROCEDURE:
            	{
            		alt44=7;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 44 );
                ex->set_state( 0 );


                goto rulepackage_obj_specEx;

            }

            switch (alt44)
            {
        	case 1:
        	    // PLSQLParser.g:201:11: variable_declaration
        	    {
        	        this->followPush(FOLLOW_variable_declaration_in_package_obj_spec1354);
        	        variable_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepackage_obj_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:202:11: subtype_declaration
        	    {
        	        this->followPush(FOLLOW_subtype_declaration_in_package_obj_spec1366);
        	        subtype_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepackage_obj_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLParser.g:203:11: cursor_declaration
        	    {
        	        this->followPush(FOLLOW_cursor_declaration_in_package_obj_spec1378);
        	        cursor_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepackage_obj_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQLParser.g:204:11: exception_declaration
        	    {
        	        this->followPush(FOLLOW_exception_declaration_in_package_obj_spec1390);
        	        exception_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepackage_obj_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQLParser.g:205:11: record_declaration
        	    {
        	        this->followPush(FOLLOW_record_declaration_in_package_obj_spec1402);
        	        record_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepackage_obj_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // PLSQLParser.g:206:11: table_declaration
        	    {
        	        this->followPush(FOLLOW_table_declaration_in_package_obj_spec1414);
        	        table_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepackage_obj_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 7:
        	    // PLSQLParser.g:207:11: procedure_spec
        	    {
        	        this->followPush(FOLLOW_procedure_spec_in_package_obj_spec1426);
        	        procedure_spec();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepackage_obj_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 8:
        	    // PLSQLParser.g:208:11: function_spec
        	    {
        	        this->followPush(FOLLOW_function_spec_in_package_obj_spec1438);
        	        function_spec();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepackage_obj_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulepackage_obj_specEx; /* Prevent compiler warnings */
    rulepackage_obj_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end package_obj_spec */

/**
 * $ANTLR start procedure_spec
 * PLSQLParser.g:211:1: procedure_spec : procedure_key procedure_name ( LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN )? SEMICOLON ;
 */
void
PLSQLParser::procedure_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:212:5: ( procedure_key procedure_name ( LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN )? SEMICOLON )
        // PLSQLParser.g:212:11: procedure_key procedure_name ( LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN )? SEMICOLON
        {
            this->followPush(FOLLOW_procedure_key_in_procedure_spec1459);
            procedure_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprocedure_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_procedure_name_in_procedure_spec1461);
            procedure_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprocedure_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:213:9: ( LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN )?
            {
                int alt46=2;
                {
                    int LA46_0 = this->LA(1);
                    if ( (LA46_0 == LEFT_PAREN))
                    {
                        alt46=1;
                    }
                }
                switch (alt46)
                {
            	case 1:
            	    // PLSQLParser.g:213:11: LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_procedure_spec1474);
            	        if  (this->hasException())
            	        {
            	            goto ruleprocedure_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_parameter_in_procedure_spec1476);
            	        parameter();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprocedure_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:213:32: ( COMMA parameter )*

            	        for (;;)
            	        {
            	            int alt45=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA45_0 = this->LA(1);
            	                if ( (LA45_0 == COMMA))
            	                {
            	                    alt45=1;
            	                }

            	            }
            	            switch (alt45)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:213:34: COMMA parameter
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_procedure_spec1480);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleprocedure_specEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_parameter_in_procedure_spec1482);
            	        	        parameter();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleprocedure_specEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop45;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop45: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_procedure_spec1487);
            	        if  (this->hasException())
            	        {
            	            goto ruleprocedure_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_procedure_spec1492);
            if  (this->hasException())
            {
                goto ruleprocedure_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprocedure_specEx; /* Prevent compiler warnings */
    ruleprocedure_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end procedure_spec */

/**
 * $ANTLR start function_spec
 * PLSQLParser.g:216:1: function_spec : function_key function_name ( LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN )? return_key type_spec SEMICOLON ;
 */
void
PLSQLParser::function_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:217:5: ( function_key function_name ( LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN )? return_key type_spec SEMICOLON )
        // PLSQLParser.g:217:10: function_key function_name ( LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN )? return_key type_spec SEMICOLON
        {
            this->followPush(FOLLOW_function_key_in_function_spec1513);
            function_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunction_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_function_name_in_function_spec1515);
            function_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunction_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:218:9: ( LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN )?
            {
                int alt48=2;
                {
                    int LA48_0 = this->LA(1);
                    if ( (LA48_0 == LEFT_PAREN))
                    {
                        alt48=1;
                    }
                }
                switch (alt48)
                {
            	case 1:
            	    // PLSQLParser.g:218:10: LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_function_spec1527);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_parameter_in_function_spec1529);
            	        parameter();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:218:31: ( COMMA parameter )*

            	        for (;;)
            	        {
            	            int alt47=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA47_0 = this->LA(1);
            	                if ( (LA47_0 == COMMA))
            	                {
            	                    alt47=1;
            	                }

            	            }
            	            switch (alt47)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:218:33: COMMA parameter
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_function_spec1533);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_specEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_parameter_in_function_spec1535);
            	        	        parameter();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunction_specEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop47;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop47: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_function_spec1539);
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_return_key_in_function_spec1552);
            return_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunction_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_spec_in_function_spec1554);
            type_spec();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunction_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_function_spec1556);
            if  (this->hasException())
            {
                goto rulefunction_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunction_specEx; /* Prevent compiler warnings */
    rulefunction_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end function_spec */

/**
 * $ANTLR start package_obj_body
 * PLSQLParser.g:222:1: package_obj_body options {backtrack=true; } : ( variable_declaration | subtype_declaration | cursor_declaration | exception_declaration | record_declaration | table_declaration | create_procedure_body | create_function_body );
 */
void
PLSQLParser::package_obj_body()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:225:6: ( variable_declaration | subtype_declaration | cursor_declaration | exception_declaration | record_declaration | table_declaration | create_procedure_body | create_function_body )

            ANTLR_UINT32 alt49;

            alt49=8;

            switch ( this->LA(1) )
            {
            case INTRODUCER:
            	{
            		{
            		    int LA49_1 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred26_PLSQLParser>() )))
            		    {
            		        alt49=1;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred29_PLSQLParser>() )))
            		    {
            		        alt49=4;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred30_PLSQLParser>() )))
            		    {
            		        alt49=5;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred31_PLSQLParser>() )))
            		    {
            		        alt49=6;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 49 );
            		        ex->set_state( 1 );


            		        goto rulepackage_obj_bodyEx;

            		    }
            		}
            	}
                break;
            case REGULAR_ID:
            	{
            		{
            		    int LA49_2 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred26_PLSQLParser>() )))
            		    {
            		        alt49=1;
            		    }
            		    else if ( (( (this->msynpred( antlr3::ClassForwarder<synpred27_PLSQLParser>() )) && ((equalsIgnoreCase(LT(1)->getText(), "SUBTYPE"))) )))
            		    {
            		        alt49=2;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred29_PLSQLParser>() )))
            		    {
            		        alt49=4;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred30_PLSQLParser>() )))
            		    {
            		        alt49=5;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred31_PLSQLParser>() )))
            		    {
            		        alt49=6;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "FUNCTION"))))
            		    {
            		        alt49=8;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 49 );
            		        ex->set_state( 2 );


            		        goto rulepackage_obj_bodyEx;

            		    }
            		}
            	}
                break;
            case BINDVAR:
            	{
            		{
            		    int LA49_3 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred26_PLSQLParser>() )))
            		    {
            		        alt49=1;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred30_PLSQLParser>() )))
            		    {
            		        alt49=5;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 49 );
            		        ex->set_state( 3 );


            		        goto rulepackage_obj_bodyEx;

            		    }
            		}
            	}
                break;
            case COLON:
            	{
            		{
            		    int LA49_4 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred26_PLSQLParser>() )))
            		    {
            		        alt49=1;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred30_PLSQLParser>() )))
            		    {
            		        alt49=5;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 49 );
            		        ex->set_state( 4 );


            		        goto rulepackage_obj_bodyEx;

            		    }
            		}
            	}
                break;
            case DELIMITED_ID:
            	{
            		{
            		    int LA49_5 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred26_PLSQLParser>() )))
            		    {
            		        alt49=1;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred29_PLSQLParser>() )))
            		    {
            		        alt49=4;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred30_PLSQLParser>() )))
            		    {
            		        alt49=5;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred31_PLSQLParser>() )))
            		    {
            		        alt49=6;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 49 );
            		        ex->set_state( 5 );


            		        goto rulepackage_obj_bodyEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_CURSOR:
            	{
            		alt49=3;
            	}
                break;
            case SQL92_RESERVED_CREATE:
            	{
            		{
            		    int LA49_7 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred32_PLSQLParser>() )))
            		    {
            		        alt49=7;
            		    }
            		    else if ( (true))
            		    {
            		        alt49=8;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 49 );
            		        ex->set_state( 7 );


            		        goto rulepackage_obj_bodyEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_PROCEDURE:
            	{
            		alt49=7;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 49 );
                ex->set_state( 0 );


                goto rulepackage_obj_bodyEx;

            }

            switch (alt49)
            {
        	case 1:
        	    // PLSQLParser.g:225:12: variable_declaration
        	    {
        	        this->followPush(FOLLOW_variable_declaration_in_package_obj_body1586);
        	        variable_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepackage_obj_bodyEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:226:11: subtype_declaration
        	    {
        	        this->followPush(FOLLOW_subtype_declaration_in_package_obj_body1599);
        	        subtype_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepackage_obj_bodyEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLParser.g:227:11: cursor_declaration
        	    {
        	        this->followPush(FOLLOW_cursor_declaration_in_package_obj_body1612);
        	        cursor_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepackage_obj_bodyEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQLParser.g:228:11: exception_declaration
        	    {
        	        this->followPush(FOLLOW_exception_declaration_in_package_obj_body1625);
        	        exception_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepackage_obj_bodyEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQLParser.g:229:11: record_declaration
        	    {
        	        this->followPush(FOLLOW_record_declaration_in_package_obj_body1638);
        	        record_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepackage_obj_bodyEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // PLSQLParser.g:230:11: table_declaration
        	    {
        	        this->followPush(FOLLOW_table_declaration_in_package_obj_body1650);
        	        table_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepackage_obj_bodyEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 7:
        	    // PLSQLParser.g:231:11: create_procedure_body
        	    {
        	        this->followPush(FOLLOW_create_procedure_body_in_package_obj_body1662);
        	        create_procedure_body();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepackage_obj_bodyEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 8:
        	    // PLSQLParser.g:232:11: create_function_body
        	    {
        	        this->followPush(FOLLOW_create_function_body_in_package_obj_body1674);
        	        create_function_body();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepackage_obj_bodyEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulepackage_obj_bodyEx; /* Prevent compiler warnings */
    rulepackage_obj_bodyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end package_obj_body */

/**
 * $ANTLR start drop_procedure
 * PLSQLParser.g:241:1: drop_procedure : drop_key procedure_key procedure_name SEMICOLON ;
 */
void
PLSQLParser::drop_procedure()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:242:5: ( drop_key procedure_key procedure_name SEMICOLON )
        // PLSQLParser.g:242:10: drop_key procedure_key procedure_name SEMICOLON
        {
            this->followPush(FOLLOW_drop_key_in_drop_procedure1701);
            drop_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledrop_procedureEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_procedure_key_in_drop_procedure1703);
            procedure_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledrop_procedureEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_procedure_name_in_drop_procedure1705);
            procedure_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledrop_procedureEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_drop_procedure1715);
            if  (this->hasException())
            {
                goto ruledrop_procedureEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledrop_procedureEx; /* Prevent compiler warnings */
    ruledrop_procedureEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end drop_procedure */

/**
 * $ANTLR start alter_procedure
 * PLSQLParser.g:246:1: alter_procedure : alter_key procedure_key procedure_name compile_key ( debug_key )? ( compiler_parameters_clause )* ( reuse_key settings_key )? SEMICOLON ;
 */
void
PLSQLParser::alter_procedure()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:247:5: ( alter_key procedure_key procedure_name compile_key ( debug_key )? ( compiler_parameters_clause )* ( reuse_key settings_key )? SEMICOLON )
        // PLSQLParser.g:247:10: alter_key procedure_key procedure_name compile_key ( debug_key )? ( compiler_parameters_clause )* ( reuse_key settings_key )? SEMICOLON
        {
            this->followPush(FOLLOW_alter_key_in_alter_procedure1735);
            alter_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_procedureEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_procedure_key_in_alter_procedure1737);
            procedure_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_procedureEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_procedure_name_in_alter_procedure1739);
            procedure_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_procedureEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_compile_key_in_alter_procedure1749);
            compile_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_procedureEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:248:21: ( debug_key )?
            {
                int alt50=2;
                {
                    int LA50_0 = this->LA(1);
                    if ( (LA50_0 == REGULAR_ID))
                    {
                        {
                            int LA50_1 = this->LA(2);
                            if ( (LA50_1 == DELIMITED_ID || LA50_1 == INTRODUCER || LA50_1 == SEMICOLON))
                            {
                                alt50=1;
                            }
                            else if ( (LA50_1 == REGULAR_ID))
                            {
                                {
                                    int LA50_4 = this->LA(3);
                                    if ( (LA50_4 == EQUALS_OP || LA50_4 == REGULAR_ID))
                                    {
                                        alt50=1;
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt50)
                {
            	case 1:
            	    // PLSQLParser.g:248:21: debug_key
            	    {
            	        this->followPush(FOLLOW_debug_key_in_alter_procedure1751);
            	        debug_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_procedureEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:248:32: ( compiler_parameters_clause )*

            for (;;)
            {
                int alt51=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA51_0 = this->LA(1);
                    if ( (LA51_0 == REGULAR_ID))
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA51_1 = this->LA(2);
                            if ( (LA51_1 == EQUALS_OP))
                            {
                                alt51=1;
                            }

                        }
                    }
                    else if ( (LA51_0 == DELIMITED_ID || LA51_0 == INTRODUCER))
                    {
                        alt51=1;
                    }

                }
                switch (alt51)
                {
            	case 1:
            	    // PLSQLParser.g:248:32: compiler_parameters_clause
            	    {
            	        this->followPush(FOLLOW_compiler_parameters_clause_in_alter_procedure1754);
            	        compiler_parameters_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_procedureEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop51;	/* break out of the loop */
            	    break;
                }
            }
            loop51: ; /* Jump out to here if this rule does not match */


            // PLSQLParser.g:249:9: ( reuse_key settings_key )?
            {
                int alt52=2;
                {
                    int LA52_0 = this->LA(1);
                    if ( (LA52_0 == REGULAR_ID))
                    {
                        alt52=1;
                    }
                }
                switch (alt52)
                {
            	case 1:
            	    // PLSQLParser.g:249:10: reuse_key settings_key
            	    {
            	        this->followPush(FOLLOW_reuse_key_in_alter_procedure1766);
            	        reuse_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_procedureEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_settings_key_in_alter_procedure1768);
            	        settings_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_procedureEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_alter_procedure1780);
            if  (this->hasException())
            {
                goto rulealter_procedureEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealter_procedureEx; /* Prevent compiler warnings */
    rulealter_procedureEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end alter_procedure */

/**
 * $ANTLR start create_procedure_body
 * PLSQLParser.g:253:1: create_procedure_body : ( create_key ( or_key replace_key )? )? procedure_key procedure_name ( LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN )? ( invoker_rights_clause )? ( is_key | as_key ) ( ( declare_key )? ( declare_spec )* body | call_spec | external_key ) SEMICOLON ;
 */
void
PLSQLParser::create_procedure_body()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:254:5: ( ( create_key ( or_key replace_key )? )? procedure_key procedure_name ( LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN )? ( invoker_rights_clause )? ( is_key | as_key ) ( ( declare_key )? ( declare_spec )* body | call_spec | external_key ) SEMICOLON )
        // PLSQLParser.g:254:10: ( create_key ( or_key replace_key )? )? procedure_key procedure_name ( LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN )? ( invoker_rights_clause )? ( is_key | as_key ) ( ( declare_key )? ( declare_spec )* body | call_spec | external_key ) SEMICOLON
        {
            // PLSQLParser.g:254:10: ( create_key ( or_key replace_key )? )?
            {
                int alt54=2;
                {
                    int LA54_0 = this->LA(1);
                    if ( (LA54_0 == SQL92_RESERVED_CREATE))
                    {
                        alt54=1;
                    }
                }
                switch (alt54)
                {
            	case 1:
            	    // PLSQLParser.g:254:11: create_key ( or_key replace_key )?
            	    {
            	        this->followPush(FOLLOW_create_key_in_create_procedure_body1801);
            	        create_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_procedure_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:254:22: ( or_key replace_key )?
            	        {
            	            int alt53=2;
            	            {
            	                int LA53_0 = this->LA(1);
            	                if ( (LA53_0 == SQL92_RESERVED_OR))
            	                {
            	                    alt53=1;
            	                }
            	            }
            	            switch (alt53)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:254:24: or_key replace_key
            	        	    {
            	        	        this->followPush(FOLLOW_or_key_in_create_procedure_body1805);
            	        	        or_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecreate_procedure_bodyEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_replace_key_in_create_procedure_body1807);
            	        	        replace_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecreate_procedure_bodyEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_procedure_key_in_create_procedure_body1814);
            procedure_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecreate_procedure_bodyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_procedure_name_in_create_procedure_body1816);
            procedure_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecreate_procedure_bodyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:255:15: ( LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN )?
            {
                int alt56=2;
                {
                    int LA56_0 = this->LA(1);
                    if ( (LA56_0 == LEFT_PAREN))
                    {
                        alt56=1;
                    }
                }
                switch (alt56)
                {
            	case 1:
            	    // PLSQLParser.g:255:17: LEFT_PAREN parameter ( COMMA parameter )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_create_procedure_body1834);
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_procedure_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_parameter_in_create_procedure_body1836);
            	        parameter();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_procedure_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:255:38: ( COMMA parameter )*

            	        for (;;)
            	        {
            	            int alt55=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA55_0 = this->LA(1);
            	                if ( (LA55_0 == COMMA))
            	                {
            	                    alt55=1;
            	                }

            	            }
            	            switch (alt55)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:255:40: COMMA parameter
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_create_procedure_body1840);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecreate_procedure_bodyEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_parameter_in_create_procedure_body1842);
            	        	        parameter();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecreate_procedure_bodyEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop55;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop55: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_create_procedure_body1847);
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_procedure_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:256:15: ( invoker_rights_clause )?
            {
                int alt57=2;
                {
                    int LA57_0 = this->LA(1);
                    if ( (LA57_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "AUTHID"))))
                    {
                        alt57=1;
                    }
                }
                switch (alt57)
                {
            	case 1:
            	    // PLSQLParser.g:256:15: invoker_rights_clause
            	    {
            	        this->followPush(FOLLOW_invoker_rights_clause_in_create_procedure_body1867);
            	        invoker_rights_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_procedure_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:257:9: ( is_key | as_key )
            {
                int alt58=2;
                {
                    int LA58_0 = this->LA(1);
                    if ( (LA58_0 == SQL92_RESERVED_IS))
                    {
                        alt58=1;
                    }
                    else if ( (LA58_0 == SQL92_RESERVED_AS))
                    {
                        alt58=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 58 );
                        ex->set_state( 0 );


                        goto rulecreate_procedure_bodyEx;

                    }
                }
                switch (alt58)
                {
            	case 1:
            	    // PLSQLParser.g:257:11: is_key
            	    {
            	        this->followPush(FOLLOW_is_key_in_create_procedure_body1880);
            	        is_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_procedure_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:257:20: as_key
            	    {
            	        this->followPush(FOLLOW_as_key_in_create_procedure_body1884);
            	        as_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_procedure_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:258:15: ( ( declare_key )? ( declare_spec )* body | call_spec | external_key )
            {
                int alt61=3;
                {
                    int LA61_0 = this->LA(1);
                    if ( (LA61_0 == BINDVAR || LA61_0 == COLON || LA61_0 == DELIMITED_ID || LA61_0 == INTRODUCER || LA61_0 == SQL92_RESERVED_BEGIN || LA61_0 == SQL92_RESERVED_CREATE || LA61_0 == SQL92_RESERVED_CURSOR || LA61_0 == SQL92_RESERVED_DECLARE || LA61_0 == SQL92_RESERVED_PROCEDURE))
                    {
                        alt61=1;
                    }
                    else if ( (LA61_0 == REGULAR_ID))
                    {
                        {
                            int LA61_3 = this->LA(2);
                            if ( (!( ((((equalsIgnoreCase(LT(1)->getText(), "LANGUAGE")))||((equalsIgnoreCase(LT(1)->getText(), "EXTERNAL"))))) )))
                            {
                                alt61=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "LANGUAGE"))))
                            {
                                alt61=2;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "EXTERNAL"))))
                            {
                                alt61=3;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 61 );
                                ex->set_state( 3 );


                                goto rulecreate_procedure_bodyEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 61 );
                        ex->set_state( 0 );


                        goto rulecreate_procedure_bodyEx;

                    }
                }
                switch (alt61)
                {
            	case 1:
            	    // PLSQLParser.g:258:20: ( declare_key )? ( declare_spec )* body
            	    {
            	        // PLSQLParser.g:258:20: ( declare_key )?
            	        {
            	            int alt59=2;
            	            {
            	                int LA59_0 = this->LA(1);
            	                if ( (LA59_0 == SQL92_RESERVED_DECLARE))
            	                {
            	                    alt59=1;
            	                }
            	            }
            	            switch (alt59)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:258:20: declare_key
            	        	    {
            	        	        this->followPush(FOLLOW_declare_key_in_create_procedure_body1907);
            	        	        declare_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecreate_procedure_bodyEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQLParser.g:258:33: ( declare_spec )*

            	        for (;;)
            	        {
            	            int alt60=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA60_0 = this->LA(1);
            	                if ( (LA60_0 == BINDVAR || LA60_0 == COLON || LA60_0 == DELIMITED_ID || LA60_0 == INTRODUCER || LA60_0 == REGULAR_ID || LA60_0 == SQL92_RESERVED_CREATE || LA60_0 == SQL92_RESERVED_CURSOR || LA60_0 == SQL92_RESERVED_PROCEDURE))
            	                {
            	                    alt60=1;
            	                }

            	            }
            	            switch (alt60)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:258:33: declare_spec
            	        	    {
            	        	        this->followPush(FOLLOW_declare_spec_in_create_procedure_body1910);
            	        	        declare_spec();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecreate_procedure_bodyEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop60;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop60: ; /* Jump out to here if this rule does not match */


            	        this->followPush(FOLLOW_body_in_create_procedure_body1913);
            	        body();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_procedure_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:259:20: call_spec
            	    {
            	        this->followPush(FOLLOW_call_spec_in_create_procedure_body1935);
            	        call_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_procedure_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLParser.g:260:20: external_key
            	    {
            	        this->followPush(FOLLOW_external_key_in_create_procedure_body1957);
            	        external_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_procedure_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_create_procedure_body1989);
            if  (this->hasException())
            {
                goto rulecreate_procedure_bodyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecreate_procedure_bodyEx; /* Prevent compiler warnings */
    rulecreate_procedure_bodyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end create_procedure_body */

/**
 * $ANTLR start drop_trigger
 * PLSQLParser.g:269:1: drop_trigger : drop_key trigger_key trigger_name SEMICOLON ;
 */
void
PLSQLParser::drop_trigger()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:270:5: ( drop_key trigger_key trigger_name SEMICOLON )
        // PLSQLParser.g:270:10: drop_key trigger_key trigger_name SEMICOLON
        {
            this->followPush(FOLLOW_drop_key_in_drop_trigger2015);
            drop_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledrop_triggerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_trigger_key_in_drop_trigger2017);
            trigger_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledrop_triggerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_trigger_name_in_drop_trigger2019);
            trigger_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledrop_triggerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_drop_trigger2029);
            if  (this->hasException())
            {
                goto ruledrop_triggerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledrop_triggerEx; /* Prevent compiler warnings */
    ruledrop_triggerEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end drop_trigger */

/**
 * $ANTLR start alter_trigger
 * PLSQLParser.g:274:1: alter_trigger : alter_key trigger_key tn1= trigger_name ( ( enable_key | disable_key ) | rename_key to_key tn2= trigger_name | compile_key ( debug_key )? ( compiler_parameters_clause )* ( reuse_key settings_key )? ) SEMICOLON ;
 */
void
PLSQLParser::alter_trigger()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:275:5: ( alter_key trigger_key tn1= trigger_name ( ( enable_key | disable_key ) | rename_key to_key tn2= trigger_name | compile_key ( debug_key )? ( compiler_parameters_clause )* ( reuse_key settings_key )? ) SEMICOLON )
        // PLSQLParser.g:275:10: alter_key trigger_key tn1= trigger_name ( ( enable_key | disable_key ) | rename_key to_key tn2= trigger_name | compile_key ( debug_key )? ( compiler_parameters_clause )* ( reuse_key settings_key )? ) SEMICOLON
        {
            this->followPush(FOLLOW_alter_key_in_alter_trigger2049);
            alter_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_triggerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_trigger_key_in_alter_trigger2051);
            trigger_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_triggerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_trigger_name_in_alter_trigger2055);
            trigger_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_triggerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:276:5: ( ( enable_key | disable_key ) | rename_key to_key tn2= trigger_name | compile_key ( debug_key )? ( compiler_parameters_clause )* ( reuse_key settings_key )? )
            {
                int alt66=3;
                {
                    int LA66_0 = this->LA(1);
                    if ( (LA66_0 == REGULAR_ID))
                    {
                        {
                            int LA66_1 = this->LA(2);
                            if ( (LA66_1 == SQL92_RESERVED_TO) && ((equalsIgnoreCase(LT(1)->getText(), "RENAME"))))
                            {
                                alt66=2;
                            }
                            else if ( ((((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))))
                            {
                                alt66=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "COMPILE"))))
                            {
                                alt66=3;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 66 );
                                ex->set_state( 1 );


                                goto rulealter_triggerEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 66 );
                        ex->set_state( 0 );


                        goto rulealter_triggerEx;

                    }
                }
                switch (alt66)
                {
            	case 1:
            	    // PLSQLParser.g:276:10: ( enable_key | disable_key )
            	    {
            	        // PLSQLParser.g:276:10: ( enable_key | disable_key )
            	        {
            	            int alt62=2;
            	            {
            	                int LA62_0 = this->LA(1);
            	                if ( (LA62_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "ENABLE")))||((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))))
            	                {
            	                    {
            	                        int LA62_1 = this->LA(2);
            	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "ENABLE"))))
            	                        {
            	                            alt62=1;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))
            	                        {
            	                            alt62=2;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 62 );
            	                            ex->set_state( 1 );


            	                            goto rulealter_triggerEx;

            	                        }
            	                    }
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 62 );
            	                    ex->set_state( 0 );


            	                    goto rulealter_triggerEx;

            	                }
            	            }
            	            switch (alt62)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:276:11: enable_key
            	        	    {
            	        	        this->followPush(FOLLOW_enable_key_in_alter_trigger2067);
            	        	        enable_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulealter_triggerEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQLParser.g:276:22: disable_key
            	        	    {
            	        	        this->followPush(FOLLOW_disable_key_in_alter_trigger2069);
            	        	        disable_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulealter_triggerEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:277:10: rename_key to_key tn2= trigger_name
            	    {
            	        this->followPush(FOLLOW_rename_key_in_alter_trigger2081);
            	        rename_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_to_key_in_alter_trigger2083);
            	        to_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_trigger_name_in_alter_trigger2087);
            	        trigger_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLParser.g:278:10: compile_key ( debug_key )? ( compiler_parameters_clause )* ( reuse_key settings_key )?
            	    {
            	        this->followPush(FOLLOW_compile_key_in_alter_trigger2098);
            	        compile_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:278:22: ( debug_key )?
            	        {
            	            int alt63=2;
            	            {
            	                int LA63_0 = this->LA(1);
            	                if ( (LA63_0 == REGULAR_ID))
            	                {
            	                    {
            	                        int LA63_1 = this->LA(2);
            	                        if ( (LA63_1 == DELIMITED_ID || LA63_1 == INTRODUCER || LA63_1 == SEMICOLON))
            	                        {
            	                            alt63=1;
            	                        }
            	                        else if ( (LA63_1 == REGULAR_ID))
            	                        {
            	                            {
            	                                int LA63_4 = this->LA(3);
            	                                if ( (LA63_4 == EQUALS_OP || LA63_4 == REGULAR_ID))
            	                                {
            	                                    alt63=1;
            	                                }
            	                            }
            	                        }
            	                    }
            	                }
            	            }
            	            switch (alt63)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:278:22: debug_key
            	        	    {
            	        	        this->followPush(FOLLOW_debug_key_in_alter_trigger2100);
            	        	        debug_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulealter_triggerEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQLParser.g:278:33: ( compiler_parameters_clause )*

            	        for (;;)
            	        {
            	            int alt64=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA64_0 = this->LA(1);
            	                if ( (LA64_0 == REGULAR_ID))
            	                {
            	                    {
            	                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                        */
            	                        int LA64_1 = this->LA(2);
            	                        if ( (LA64_1 == EQUALS_OP))
            	                        {
            	                            alt64=1;
            	                        }

            	                    }
            	                }
            	                else if ( (LA64_0 == DELIMITED_ID || LA64_0 == INTRODUCER))
            	                {
            	                    alt64=1;
            	                }

            	            }
            	            switch (alt64)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:278:33: compiler_parameters_clause
            	        	    {
            	        	        this->followPush(FOLLOW_compiler_parameters_clause_in_alter_trigger2103);
            	        	        compiler_parameters_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulealter_triggerEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop64;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop64: ; /* Jump out to here if this rule does not match */


            	        // PLSQLParser.g:278:61: ( reuse_key settings_key )?
            	        {
            	            int alt65=2;
            	            {
            	                int LA65_0 = this->LA(1);
            	                if ( (LA65_0 == REGULAR_ID))
            	                {
            	                    alt65=1;
            	                }
            	            }
            	            switch (alt65)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:278:62: reuse_key settings_key
            	        	    {
            	        	        this->followPush(FOLLOW_reuse_key_in_alter_trigger2107);
            	        	        reuse_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulealter_triggerEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_settings_key_in_alter_trigger2109);
            	        	        settings_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulealter_triggerEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_alter_trigger2122);
            if  (this->hasException())
            {
                goto rulealter_triggerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealter_triggerEx; /* Prevent compiler warnings */
    rulealter_triggerEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end alter_trigger */

/**
 * $ANTLR start create_trigger
 * PLSQLParser.g:282:1: create_trigger : create_key ( or_key replace_key )? trigger_key trigger_name ( simple_dml_trigger | compound_dml_trigger | non_dml_trigger ) ( trigger_follows_clause )? ( enable_key | disable_key )? ( trigger_when_clause )? trigger_body SEMICOLON ;
 */
void
PLSQLParser::create_trigger()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:283:5: ( create_key ( or_key replace_key )? trigger_key trigger_name ( simple_dml_trigger | compound_dml_trigger | non_dml_trigger ) ( trigger_follows_clause )? ( enable_key | disable_key )? ( trigger_when_clause )? trigger_body SEMICOLON )
        // PLSQLParser.g:283:10: create_key ( or_key replace_key )? trigger_key trigger_name ( simple_dml_trigger | compound_dml_trigger | non_dml_trigger ) ( trigger_follows_clause )? ( enable_key | disable_key )? ( trigger_when_clause )? trigger_body SEMICOLON
        {
            this->followPush(FOLLOW_create_key_in_create_trigger2142);
            create_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecreate_triggerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:283:21: ( or_key replace_key )?
            {
                int alt67=2;
                {
                    int LA67_0 = this->LA(1);
                    if ( (LA67_0 == SQL92_RESERVED_OR))
                    {
                        alt67=1;
                    }
                }
                switch (alt67)
                {
            	case 1:
            	    // PLSQLParser.g:283:23: or_key replace_key
            	    {
            	        this->followPush(FOLLOW_or_key_in_create_trigger2146);
            	        or_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_replace_key_in_create_trigger2148);
            	        replace_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_trigger_key_in_create_trigger2153);
            trigger_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecreate_triggerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_trigger_name_in_create_trigger2155);
            trigger_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecreate_triggerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:284:5: ( simple_dml_trigger | compound_dml_trigger | non_dml_trigger )
            {
                int alt68=3;
                {
                    int LA68_0 = this->LA(1);
                    if ( (LA68_0 == REGULAR_ID))
                    {
                        {
                            int LA68_1 = this->LA(2);
                            if ( (LA68_1 == SQL92_RESERVED_DELETE || LA68_1 == SQL92_RESERVED_INSERT || LA68_1 == SQL92_RESERVED_UPDATE))
                            {
                                alt68=1;
                            }
                            else if ( (LA68_1 == SQL92_RESERVED_OF) && ((equalsIgnoreCase(LT(1)->getText(), "INSTEAD"))))
                            {
                                alt68=1;
                            }
                            else if ( (LA68_1 == REGULAR_ID || LA68_1 == SQL92_RESERVED_ALTER || LA68_1 == SQL92_RESERVED_CREATE || LA68_1 == SQL92_RESERVED_DROP || LA68_1 == SQL92_RESERVED_GRANT || LA68_1 == SQL92_RESERVED_REVOKE))
                            {
                                alt68=3;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 68 );
                                ex->set_state( 1 );


                                goto rulecreate_triggerEx;

                            }
                        }
                    }
                    else if ( (LA68_0 == SQL92_RESERVED_FOR))
                    {
                        alt68=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 68 );
                        ex->set_state( 0 );


                        goto rulecreate_triggerEx;

                    }
                }
                switch (alt68)
                {
            	case 1:
            	    // PLSQLParser.g:284:10: simple_dml_trigger
            	    {
            	        this->followPush(FOLLOW_simple_dml_trigger_in_create_trigger2166);
            	        simple_dml_trigger();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:285:10: compound_dml_trigger
            	    {
            	        this->followPush(FOLLOW_compound_dml_trigger_in_create_trigger2177);
            	        compound_dml_trigger();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLParser.g:286:10: non_dml_trigger
            	    {
            	        this->followPush(FOLLOW_non_dml_trigger_in_create_trigger2188);
            	        non_dml_trigger();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:288:5: ( trigger_follows_clause )?
            {
                int alt69=2;
                {
                    int LA69_0 = this->LA(1);
                    if ( (LA69_0 == REGULAR_ID))
                    {
                        {
                            int LA69_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS"))))
                            {
                                alt69=1;
                            }
                        }
                    }
                }
                switch (alt69)
                {
            	case 1:
            	    // PLSQLParser.g:288:5: trigger_follows_clause
            	    {
            	        this->followPush(FOLLOW_trigger_follows_clause_in_create_trigger2200);
            	        trigger_follows_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:289:5: ( enable_key | disable_key )?
            {
                int alt70=3;
                {
                    int LA70_0 = this->LA(1);
                    if ( (LA70_0 == REGULAR_ID))
                    {
                        {
                            int LA70_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "ENABLE"))))
                            {
                                alt70=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))))
                            {
                                alt70=2;
                            }
                        }
                    }
                }
                switch (alt70)
                {
            	case 1:
            	    // PLSQLParser.g:289:6: enable_key
            	    {
            	        this->followPush(FOLLOW_enable_key_in_create_trigger2208);
            	        enable_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:289:17: disable_key
            	    {
            	        this->followPush(FOLLOW_disable_key_in_create_trigger2210);
            	        disable_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:290:5: ( trigger_when_clause )?
            {
                int alt71=2;
                {
                    int LA71_0 = this->LA(1);
                    if ( (LA71_0 == SQL92_RESERVED_WHEN))
                    {
                        alt71=1;
                    }
                }
                switch (alt71)
                {
            	case 1:
            	    // PLSQLParser.g:290:5: trigger_when_clause
            	    {
            	        this->followPush(FOLLOW_trigger_when_clause_in_create_trigger2218);
            	        trigger_when_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_trigger_body_in_create_trigger2226);
            trigger_body();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecreate_triggerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_create_trigger2228);
            if  (this->hasException())
            {
                goto rulecreate_triggerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecreate_triggerEx; /* Prevent compiler warnings */
    rulecreate_triggerEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end create_trigger */

/**
 * $ANTLR start trigger_follows_clause
 * PLSQLParser.g:294:1: trigger_follows_clause : follows_key trigger_name ( COMMA trigger_name )* ;
 */
void
PLSQLParser::trigger_follows_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:295:5: ( follows_key trigger_name ( COMMA trigger_name )* )
        // PLSQLParser.g:295:10: follows_key trigger_name ( COMMA trigger_name )*
        {
            this->followPush(FOLLOW_follows_key_in_trigger_follows_clause2248);
            follows_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletrigger_follows_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_trigger_name_in_trigger_follows_clause2250);
            trigger_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletrigger_follows_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:295:35: ( COMMA trigger_name )*

            for (;;)
            {
                int alt72=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA72_0 = this->LA(1);
                    if ( (LA72_0 == COMMA))
                    {
                        alt72=1;
                    }

                }
                switch (alt72)
                {
            	case 1:
            	    // PLSQLParser.g:295:36: COMMA trigger_name
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_trigger_follows_clause2253);
            	        if  (this->hasException())
            	        {
            	            goto ruletrigger_follows_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_trigger_name_in_trigger_follows_clause2255);
            	        trigger_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletrigger_follows_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop72;	/* break out of the loop */
            	    break;
                }
            }
            loop72: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletrigger_follows_clauseEx; /* Prevent compiler warnings */
    ruletrigger_follows_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end trigger_follows_clause */

/**
 * $ANTLR start trigger_when_clause
 * PLSQLParser.g:298:1: trigger_when_clause : when_key LEFT_PAREN condition RIGHT_PAREN ;
 */
void
PLSQLParser::trigger_when_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:299:5: ( when_key LEFT_PAREN condition RIGHT_PAREN )
        // PLSQLParser.g:299:10: when_key LEFT_PAREN condition RIGHT_PAREN
        {
            this->followPush(FOLLOW_when_key_in_trigger_when_clause2277);
            when_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletrigger_when_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_trigger_when_clause2279);
            if  (this->hasException())
            {
                goto ruletrigger_when_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_condition_in_trigger_when_clause2281);
            condition();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletrigger_when_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_trigger_when_clause2283);
            if  (this->hasException())
            {
                goto ruletrigger_when_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletrigger_when_clauseEx; /* Prevent compiler warnings */
    ruletrigger_when_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end trigger_when_clause */

/**
 * $ANTLR start simple_dml_trigger
 * PLSQLParser.g:303:1: simple_dml_trigger : ( before_key | after_key | instead_key of_key ) dml_event_clause ( referencing_clause )? ( for_each_row )? ;
 */
void
PLSQLParser::simple_dml_trigger()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:304:5: ( ( before_key | after_key | instead_key of_key ) dml_event_clause ( referencing_clause )? ( for_each_row )? )
        // PLSQLParser.g:304:10: ( before_key | after_key | instead_key of_key ) dml_event_clause ( referencing_clause )? ( for_each_row )?
        {
            // PLSQLParser.g:304:10: ( before_key | after_key | instead_key of_key )
            {
                int alt73=3;
                {
                    int LA73_0 = this->LA(1);
                    if ( (LA73_0 == REGULAR_ID))
                    {
                        {
                            int LA73_1 = this->LA(2);
                            if ( (LA73_1 == SQL92_RESERVED_OF) && ((equalsIgnoreCase(LT(1)->getText(), "INSTEAD"))))
                            {
                                alt73=3;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "BEFORE"))))
                            {
                                alt73=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "AFTER"))))
                            {
                                alt73=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 73 );
                                ex->set_state( 1 );


                                goto rulesimple_dml_triggerEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 73 );
                        ex->set_state( 0 );


                        goto rulesimple_dml_triggerEx;

                    }
                }
                switch (alt73)
                {
            	case 1:
            	    // PLSQLParser.g:304:11: before_key
            	    {
            	        this->followPush(FOLLOW_before_key_in_simple_dml_trigger2305);
            	        before_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_dml_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:304:22: after_key
            	    {
            	        this->followPush(FOLLOW_after_key_in_simple_dml_trigger2307);
            	        after_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_dml_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLParser.g:304:32: instead_key of_key
            	    {
            	        this->followPush(FOLLOW_instead_key_in_simple_dml_trigger2309);
            	        instead_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_dml_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_of_key_in_simple_dml_trigger2311);
            	        of_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_dml_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_dml_event_clause_in_simple_dml_trigger2314);
            dml_event_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_dml_triggerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:304:69: ( referencing_clause )?
            {
                int alt74=2;
                alt74 = cdfa74.predict(this, this->get_rec(), this->get_istream(), cdfa74 );
                if  (this->hasException())
                {
                    goto rulesimple_dml_triggerEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }

                switch (alt74)
                {
            	case 1:
            	    // PLSQLParser.g:304:69: referencing_clause
            	    {
            	        this->followPush(FOLLOW_referencing_clause_in_simple_dml_trigger2316);
            	        referencing_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_dml_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:304:89: ( for_each_row )?
            {
                int alt75=2;
                {
                    int LA75_0 = this->LA(1);
                    if ( (LA75_0 == SQL92_RESERVED_FOR))
                    {
                        alt75=1;
                    }
                }
                switch (alt75)
                {
            	case 1:
            	    // PLSQLParser.g:304:89: for_each_row
            	    {
            	        this->followPush(FOLLOW_for_each_row_in_simple_dml_trigger2319);
            	        for_each_row();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_dml_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesimple_dml_triggerEx; /* Prevent compiler warnings */
    rulesimple_dml_triggerEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end simple_dml_trigger */

/**
 * $ANTLR start for_each_row
 * PLSQLParser.g:307:1: for_each_row : for_key each_key row_key ;
 */
void
PLSQLParser::for_each_row()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:308:5: ( for_key each_key row_key )
        // PLSQLParser.g:308:10: for_key each_key row_key
        {
            this->followPush(FOLLOW_for_key_in_for_each_row2340);
            for_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_each_rowEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_each_key_in_for_each_row2342);
            each_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_each_rowEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_row_key_in_for_each_row2344);
            row_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_each_rowEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefor_each_rowEx; /* Prevent compiler warnings */
    rulefor_each_rowEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end for_each_row */

/**
 * $ANTLR start compound_dml_trigger
 * PLSQLParser.g:311:1: compound_dml_trigger : for_key dml_event_clause ( referencing_clause )? ;
 */
void
PLSQLParser::compound_dml_trigger()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:312:5: ( for_key dml_event_clause ( referencing_clause )? )
        // PLSQLParser.g:312:10: for_key dml_event_clause ( referencing_clause )?
        {
            this->followPush(FOLLOW_for_key_in_compound_dml_trigger2364);
            for_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecompound_dml_triggerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_dml_event_clause_in_compound_dml_trigger2366);
            dml_event_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecompound_dml_triggerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:312:35: ( referencing_clause )?
            {
                int alt76=2;
                alt76 = cdfa76.predict(this, this->get_rec(), this->get_istream(), cdfa76 );
                if  (this->hasException())
                {
                    goto rulecompound_dml_triggerEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }

                switch (alt76)
                {
            	case 1:
            	    // PLSQLParser.g:312:35: referencing_clause
            	    {
            	        this->followPush(FOLLOW_referencing_clause_in_compound_dml_trigger2368);
            	        referencing_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecompound_dml_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulecompound_dml_triggerEx; /* Prevent compiler warnings */
    rulecompound_dml_triggerEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end compound_dml_trigger */

/**
 * $ANTLR start non_dml_trigger
 * PLSQLParser.g:315:1: non_dml_trigger : ( before_key | after_key ) non_dml_event ( or_key non_dml_event )* on_key ( database_key | ( schema_name PERIOD )? schema_key ) ;
 */
void
PLSQLParser::non_dml_trigger()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:316:5: ( ( before_key | after_key ) non_dml_event ( or_key non_dml_event )* on_key ( database_key | ( schema_name PERIOD )? schema_key ) )
        // PLSQLParser.g:316:10: ( before_key | after_key ) non_dml_event ( or_key non_dml_event )* on_key ( database_key | ( schema_name PERIOD )? schema_key )
        {
            // PLSQLParser.g:316:10: ( before_key | after_key )
            {
                int alt77=2;
                {
                    int LA77_0 = this->LA(1);
                    if ( (LA77_0 == REGULAR_ID))
                    {
                        {
                            int LA77_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "BEFORE"))))
                            {
                                alt77=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "AFTER"))))
                            {
                                alt77=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 77 );
                                ex->set_state( 1 );


                                goto rulenon_dml_triggerEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 77 );
                        ex->set_state( 0 );


                        goto rulenon_dml_triggerEx;

                    }
                }
                switch (alt77)
                {
            	case 1:
            	    // PLSQLParser.g:316:11: before_key
            	    {
            	        this->followPush(FOLLOW_before_key_in_non_dml_trigger2390);
            	        before_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulenon_dml_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:316:22: after_key
            	    {
            	        this->followPush(FOLLOW_after_key_in_non_dml_trigger2392);
            	        after_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulenon_dml_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_non_dml_event_in_non_dml_trigger2395);
            non_dml_event();

            this->followPop();
            if  (this->hasException())
            {
                goto rulenon_dml_triggerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:316:47: ( or_key non_dml_event )*

            for (;;)
            {
                int alt78=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA78_0 = this->LA(1);
                    if ( (LA78_0 == SQL92_RESERVED_OR))
                    {
                        alt78=1;
                    }

                }
                switch (alt78)
                {
            	case 1:
            	    // PLSQLParser.g:316:48: or_key non_dml_event
            	    {
            	        this->followPush(FOLLOW_or_key_in_non_dml_trigger2398);
            	        or_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulenon_dml_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_non_dml_event_in_non_dml_trigger2400);
            	        non_dml_event();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulenon_dml_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop78;	/* break out of the loop */
            	    break;
                }
            }
            loop78: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_on_key_in_non_dml_trigger2412);
            on_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulenon_dml_triggerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:317:16: ( database_key | ( schema_name PERIOD )? schema_key )
            {
                int alt80=2;
                {
                    int LA80_0 = this->LA(1);
                    if ( (LA80_0 == REGULAR_ID))
                    {
                        {
                            int LA80_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "DATABASE"))))
                            {
                                alt80=1;
                            }
                            else if ( (true))
                            {
                                alt80=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 80 );
                                ex->set_state( 1 );


                                goto rulenon_dml_triggerEx;

                            }
                        }
                    }
                    else if ( (LA80_0 == DELIMITED_ID || LA80_0 == INTRODUCER))
                    {
                        alt80=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 80 );
                        ex->set_state( 0 );


                        goto rulenon_dml_triggerEx;

                    }
                }
                switch (alt80)
                {
            	case 1:
            	    // PLSQLParser.g:317:17: database_key
            	    {
            	        this->followPush(FOLLOW_database_key_in_non_dml_trigger2415);
            	        database_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulenon_dml_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:317:32: ( schema_name PERIOD )? schema_key
            	    {
            	        // PLSQLParser.g:317:32: ( schema_name PERIOD )?
            	        {
            	            int alt79=2;
            	            {
            	                int LA79_0 = this->LA(1);
            	                if ( (LA79_0 == DELIMITED_ID || LA79_0 == INTRODUCER))
            	                {
            	                    alt79=1;
            	                }
            	                else if ( (LA79_0 == REGULAR_ID))
            	                {
            	                    {
            	                        int LA79_2 = this->LA(2);
            	                        if ( (LA79_2 == PERIOD))
            	                        {
            	                            alt79=1;
            	                        }
            	                    }
            	                }
            	            }
            	            switch (alt79)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:317:33: schema_name PERIOD
            	        	    {
            	        	        this->followPush(FOLLOW_schema_name_in_non_dml_trigger2420);
            	        	        schema_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulenon_dml_triggerEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_non_dml_trigger2422);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulenon_dml_triggerEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_schema_key_in_non_dml_trigger2426);
            	        schema_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulenon_dml_triggerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulenon_dml_triggerEx; /* Prevent compiler warnings */
    rulenon_dml_triggerEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end non_dml_trigger */

/**
 * $ANTLR start trigger_body
 * PLSQLParser.g:320:1: trigger_body : ( ( compound_key trigger_key )=> compound_trigger_block | ( call_key id )=> call_key routine_clause | trigger_block );
 */
void
PLSQLParser::trigger_body()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:321:5: ( ( compound_key trigger_key )=> compound_trigger_block | ( call_key id )=> call_key routine_clause | trigger_block )

            ANTLR_UINT32 alt81;

            alt81=3;

            {
                int LA81_0 = this->LA(1);
                if ( (LA81_0 == REGULAR_ID))
                {
                    {
                        int LA81_1 = this->LA(2);
                        if ( (( ((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))) && (this->msynpred( antlr3::ClassForwarder<synpred33_PLSQLParser>() )) )))
                        {
                            alt81=1;
                        }
                        else if ( (( (this->msynpred( antlr3::ClassForwarder<synpred34_PLSQLParser>() )) && ((equalsIgnoreCase(LT(1)->getText(), "CALL"))) )))
                        {
                            alt81=2;
                        }
                        else if ( (true))
                        {
                            alt81=3;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 81 );
                            ex->set_state( 1 );


                            goto ruletrigger_bodyEx;

                        }
                    }
                }
                else if ( (LA81_0 == BINDVAR || LA81_0 == COLON || LA81_0 == DELIMITED_ID || LA81_0 == INTRODUCER || LA81_0 == SQL92_RESERVED_BEGIN || LA81_0 == SQL92_RESERVED_CREATE || LA81_0 == SQL92_RESERVED_CURSOR || LA81_0 == SQL92_RESERVED_DECLARE || LA81_0 == SQL92_RESERVED_PROCEDURE))
                {
                    alt81=3;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 81 );
                    ex->set_state( 0 );


                    goto ruletrigger_bodyEx;

                }
            }
            switch (alt81)
            {
        	case 1:
        	    // PLSQLParser.g:321:10: ( compound_key trigger_key )=> compound_trigger_block
        	    {
        	        this->followPush(FOLLOW_compound_trigger_block_in_trigger_body2455);
        	        compound_trigger_block();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletrigger_bodyEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:322:10: ( call_key id )=> call_key routine_clause
        	    {
        	        this->followPush(FOLLOW_call_key_in_trigger_body2473);
        	        call_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletrigger_bodyEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_routine_clause_in_trigger_body2475);
        	        routine_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletrigger_bodyEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLParser.g:323:10: trigger_block
        	    {
        	        this->followPush(FOLLOW_trigger_block_in_trigger_body2487);
        	        trigger_block();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletrigger_bodyEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruletrigger_bodyEx; /* Prevent compiler warnings */
    ruletrigger_bodyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end trigger_body */

/**
 * $ANTLR start routine_clause
 * PLSQLParser.g:326:1: routine_clause : routine_name ( function_argument )? ;
 */
void
PLSQLParser::routine_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:327:5: ( routine_name ( function_argument )? )
        // PLSQLParser.g:327:10: routine_name ( function_argument )?
        {
            this->followPush(FOLLOW_routine_name_in_routine_clause2507);
            routine_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleroutine_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:327:23: ( function_argument )?
            {
                int alt82=2;
                {
                    int LA82_0 = this->LA(1);
                    if ( (LA82_0 == LEFT_PAREN))
                    {
                        alt82=1;
                    }
                }
                switch (alt82)
                {
            	case 1:
            	    // PLSQLParser.g:327:23: function_argument
            	    {
            	        this->followPush(FOLLOW_function_argument_in_routine_clause2509);
            	        function_argument();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleroutine_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleroutine_clauseEx; /* Prevent compiler warnings */
    ruleroutine_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end routine_clause */

/**
 * $ANTLR start compound_trigger_block
 * PLSQLParser.g:330:1: compound_trigger_block : compound_key trigger_key ( declare_spec )* ( timing_point_section )+ end_key trigger_name ;
 */
void
PLSQLParser::compound_trigger_block()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:331:5: ( compound_key trigger_key ( declare_spec )* ( timing_point_section )+ end_key trigger_name )
        // PLSQLParser.g:331:10: compound_key trigger_key ( declare_spec )* ( timing_point_section )+ end_key trigger_name
        {
            this->followPush(FOLLOW_compound_key_in_compound_trigger_block2530);
            compound_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecompound_trigger_blockEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_trigger_key_in_compound_trigger_block2532);
            trigger_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecompound_trigger_blockEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:331:35: ( declare_spec )*

            for (;;)
            {
                int alt83=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA83_0 = this->LA(1);
                    if ( (LA83_0 == REGULAR_ID))
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA83_1 = this->LA(2);
                            if ( (!( ((((equalsIgnoreCase(LT(1)->getText(), "AFTER")))||((equalsIgnoreCase(LT(1)->getText(), "BEFORE"))))) )))
                            {
                                alt83=1;
                            }

                        }
                    }
                    else if ( (LA83_0 == BINDVAR || LA83_0 == COLON || LA83_0 == DELIMITED_ID || LA83_0 == INTRODUCER || LA83_0 == SQL92_RESERVED_CREATE || LA83_0 == SQL92_RESERVED_CURSOR || LA83_0 == SQL92_RESERVED_PROCEDURE))
                    {
                        alt83=1;
                    }

                }
                switch (alt83)
                {
            	case 1:
            	    // PLSQLParser.g:331:35: declare_spec
            	    {
            	        this->followPush(FOLLOW_declare_spec_in_compound_trigger_block2534);
            	        declare_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecompound_trigger_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop83;	/* break out of the loop */
            	    break;
                }
            }
            loop83: ; /* Jump out to here if this rule does not match */


            // PLSQLParser.g:331:49: ( timing_point_section )+
            {
                int cnt84=0;

                for (;;)
                {
                    int alt84=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA84_0 = this->LA(1);
            	    if ( (LA84_0 == REGULAR_ID))
            	    {
            	        alt84=1;
            	    }

            	}
            	switch (alt84)
            	{
            	    case 1:
            	        // PLSQLParser.g:331:49: timing_point_section
            	        {
            	            this->followPush(FOLLOW_timing_point_section_in_compound_trigger_block2537);
            	            timing_point_section();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulecompound_trigger_blockEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt84 >= 1 )
            		{
            		    goto loop84;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PLSQLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto rulecompound_trigger_blockEx;
            	}
            	cnt84++;
                }
                loop84: ;	/* Jump to here if this rule does not match */
            }

            this->followPush(FOLLOW_end_key_in_compound_trigger_block2540);
            end_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecompound_trigger_blockEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_trigger_name_in_compound_trigger_block2542);
            trigger_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecompound_trigger_blockEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecompound_trigger_blockEx; /* Prevent compiler warnings */
    rulecompound_trigger_blockEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end compound_trigger_block */

/**
 * $ANTLR start timing_point_section
 * PLSQLParser.g:334:1: timing_point_section options {k=3; } : (bk= before_key statement_key is_key trigger_block before_key statement_key SEMICOLON |bk= before_key each_key row_key is_key trigger_block before_key each_key row_key SEMICOLON |ak= after_key statement_key is_key trigger_block after_key statement_key SEMICOLON |ak= after_key each_key row_key is_key trigger_block after_key each_key row_key SEMICOLON );
 */
void
PLSQLParser::timing_point_section()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:337:6: (bk= before_key statement_key is_key trigger_block before_key statement_key SEMICOLON |bk= before_key each_key row_key is_key trigger_block before_key each_key row_key SEMICOLON |ak= after_key statement_key is_key trigger_block after_key statement_key SEMICOLON |ak= after_key each_key row_key is_key trigger_block after_key each_key row_key SEMICOLON )

            ANTLR_UINT32 alt85;

            alt85=4;

            {
                int LA85_0 = this->LA(1);
                if ( (LA85_0 == REGULAR_ID))
                {
                    {
                        int LA85_1 = this->LA(2);
                        if ( (LA85_1 == REGULAR_ID))
                        {
                            {
                                int LA85_3 = this->LA(3);
                                if ( (LA85_3 == SQL92_RESERVED_IS))
                                {
                                    {
                                        int LA85_5 = this->LA(4);
                                        if ( ((equalsIgnoreCase(LT(1)->getText(), "BEFORE"))))
                                        {
                                            alt85=1;
                                        }
                                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "AFTER"))))
                                        {
                                            alt85=3;
                                        }
                                        else
                                        {
                                            if (this->get_backtracking()>0)
                                            {
                                                this->set_failedflag( true );
                                                return ;
                                            }


                                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                            ex->set_decisionNum( 85 );
                                            ex->set_state( 5 );


                                            goto ruletiming_point_sectionEx;

                                        }
                                    }
                                }
                                else if ( (LA85_3 == REGULAR_ID))
                                {
                                    {
                                        int LA85_6 = this->LA(4);
                                        if ( ((equalsIgnoreCase(LT(1)->getText(), "BEFORE"))))
                                        {
                                            alt85=2;
                                        }
                                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "AFTER"))))
                                        {
                                            alt85=4;
                                        }
                                        else
                                        {
                                            if (this->get_backtracking()>0)
                                            {
                                                this->set_failedflag( true );
                                                return ;
                                            }


                                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                            ex->set_decisionNum( 85 );
                                            ex->set_state( 6 );


                                            goto ruletiming_point_sectionEx;

                                        }
                                    }
                                }
                                else
                                {
                                    if (this->get_backtracking()>0)
                                    {
                                        this->set_failedflag( true );
                                        return ;
                                    }


                                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                    ex->set_decisionNum( 85 );
                                    ex->set_state( 3 );


                                    goto ruletiming_point_sectionEx;

                                }
                            }
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 85 );
                            ex->set_state( 1 );


                            goto ruletiming_point_sectionEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 85 );
                    ex->set_state( 0 );


                    goto ruletiming_point_sectionEx;

                }
            }
            switch (alt85)
            {
        	case 1:
        	    // PLSQLParser.g:337:11: bk= before_key statement_key is_key trigger_block before_key statement_key SEMICOLON
        	    {
        	        this->followPush(FOLLOW_before_key_in_timing_point_section2572);
        	        before_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_statement_key_in_timing_point_section2574);
        	        statement_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_is_key_in_timing_point_section2576);
        	        is_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_trigger_block_in_timing_point_section2578);
        	        trigger_block();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_before_key_in_timing_point_section2580);
        	        before_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_statement_key_in_timing_point_section2582);
        	        statement_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_timing_point_section2584);
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:338:10: bk= before_key each_key row_key is_key trigger_block before_key each_key row_key SEMICOLON
        	    {
        	        this->followPush(FOLLOW_before_key_in_timing_point_section2597);
        	        before_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_each_key_in_timing_point_section2599);
        	        each_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_row_key_in_timing_point_section2601);
        	        row_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_is_key_in_timing_point_section2603);
        	        is_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_trigger_block_in_timing_point_section2605);
        	        trigger_block();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_before_key_in_timing_point_section2607);
        	        before_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_each_key_in_timing_point_section2609);
        	        each_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_row_key_in_timing_point_section2611);
        	        row_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_timing_point_section2613);
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLParser.g:339:10: ak= after_key statement_key is_key trigger_block after_key statement_key SEMICOLON
        	    {
        	        this->followPush(FOLLOW_after_key_in_timing_point_section2626);
        	        after_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_statement_key_in_timing_point_section2628);
        	        statement_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_is_key_in_timing_point_section2630);
        	        is_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_trigger_block_in_timing_point_section2632);
        	        trigger_block();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_after_key_in_timing_point_section2634);
        	        after_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_statement_key_in_timing_point_section2636);
        	        statement_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_timing_point_section2638);
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQLParser.g:340:10: ak= after_key each_key row_key is_key trigger_block after_key each_key row_key SEMICOLON
        	    {
        	        this->followPush(FOLLOW_after_key_in_timing_point_section2651);
        	        after_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_each_key_in_timing_point_section2653);
        	        each_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_row_key_in_timing_point_section2655);
        	        row_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_is_key_in_timing_point_section2657);
        	        is_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_trigger_block_in_timing_point_section2659);
        	        trigger_block();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_after_key_in_timing_point_section2661);
        	        after_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_each_key_in_timing_point_section2663);
        	        each_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_row_key_in_timing_point_section2665);
        	        row_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_timing_point_section2667);
        	        if  (this->hasException())
        	        {
        	            goto ruletiming_point_sectionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruletiming_point_sectionEx; /* Prevent compiler warnings */
    ruletiming_point_sectionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timing_point_section */

/**
 * $ANTLR start non_dml_event
 * PLSQLParser.g:343:1: non_dml_event : ( alter_key | analyze_key | associate_key statistics_key | audit_key | comment_key | create_key | disassociate_key statistics_key | drop_key | grant_key | noaudit_key | rename_key | revoke_key | truncate_key | ddl_key | startup_key | shutdown_key | db_role_change_key | logon_key | logoff_key | servererror_key | suspend_key | database_key | schema_key | follows_key );
 */
void
PLSQLParser::non_dml_event()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:344:5: ( alter_key | analyze_key | associate_key statistics_key | audit_key | comment_key | create_key | disassociate_key statistics_key | drop_key | grant_key | noaudit_key | rename_key | revoke_key | truncate_key | ddl_key | startup_key | shutdown_key | db_role_change_key | logon_key | logoff_key | servererror_key | suspend_key | database_key | schema_key | follows_key )

            ANTLR_UINT32 alt86;

            alt86=24;

            {
                int LA86_0 = this->LA(1);
                if ( (LA86_0 == SQL92_RESERVED_ALTER))
                {
                    alt86=1;
                }
                else if ( (LA86_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS")))||((equalsIgnoreCase(LT(1)->getText(), "COMMENT")))||((equalsIgnoreCase(LT(1)->getText(), "AUDIT")))||((equalsIgnoreCase(LT(1)->getText(), "SHUTDOWN")))||((equalsIgnoreCase(LT(1)->getText(), "RENAME")))||((equalsIgnoreCase(LT(1)->getText(), "STARTUP")))||((equalsIgnoreCase(LT(1)->getText(), "DATABASE")))||((equalsIgnoreCase(LT(1)->getText(), "DISASSOCIATE")))||((equalsIgnoreCase(LT(1)->getText(), "ANALYZE")))||((equalsIgnoreCase(LT(1)->getText(), "LOGON")))||((equalsIgnoreCase(LT(1)->getText(), "TRUNCATE")))||((equalsIgnoreCase(LT(1)->getText(), "DB_ROLE_CHANGE")))||((equalsIgnoreCase(LT(1)->getText(), "ASSOCIATE")))||((equalsIgnoreCase(LT(1)->getText(), "SCHEMA")))||((equalsIgnoreCase(LT(1)->getText(), "SUSPEND")))||((equalsIgnoreCase(LT(1)->getText(), "NOAUDIT")))||((equalsIgnoreCase(LT(1)->getText(), "LOGOFF")))||((equalsIgnoreCase(LT(1)->getText(), "DDL")))||((equalsIgnoreCase(LT(1)->getText(), "SERVERERROR"))))))
                {
                    {
                        int LA86_2 = this->LA(2);
                        if ( (LA86_2 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "DISASSOCIATE")))||((equalsIgnoreCase(LT(1)->getText(), "ASSOCIATE"))))))
                        {
                            {
                                int LA86_7 = this->LA(3);
                                if ( ((equalsIgnoreCase(LT(1)->getText(), "ASSOCIATE"))))
                                {
                                    alt86=3;
                                }
                                else if ( ((equalsIgnoreCase(LT(1)->getText(), "DISASSOCIATE"))))
                                {
                                    alt86=7;
                                }
                                else
                                {
                                    if (this->get_backtracking()>0)
                                    {
                                        this->set_failedflag( true );
                                        return ;
                                    }


                                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                    ex->set_decisionNum( 86 );
                                    ex->set_state( 7 );


                                    goto rulenon_dml_eventEx;

                                }
                            }
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "ANALYZE"))))
                        {
                            alt86=2;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "AUDIT"))))
                        {
                            alt86=4;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "COMMENT"))))
                        {
                            alt86=5;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NOAUDIT"))))
                        {
                            alt86=10;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "RENAME"))))
                        {
                            alt86=11;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "TRUNCATE"))))
                        {
                            alt86=13;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "DDL"))))
                        {
                            alt86=14;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "STARTUP"))))
                        {
                            alt86=15;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "SHUTDOWN"))))
                        {
                            alt86=16;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "DB_ROLE_CHANGE"))))
                        {
                            alt86=17;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "LOGON"))))
                        {
                            alt86=18;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "LOGOFF"))))
                        {
                            alt86=19;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "SERVERERROR"))))
                        {
                            alt86=20;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "SUSPEND"))))
                        {
                            alt86=21;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "DATABASE"))))
                        {
                            alt86=22;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "SCHEMA"))))
                        {
                            alt86=23;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS"))))
                        {
                            alt86=24;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 86 );
                            ex->set_state( 2 );


                            goto rulenon_dml_eventEx;

                        }
                    }
                }
                else if ( (LA86_0 == SQL92_RESERVED_CREATE))
                {
                    alt86=6;
                }
                else if ( (LA86_0 == SQL92_RESERVED_DROP))
                {
                    alt86=8;
                }
                else if ( (LA86_0 == SQL92_RESERVED_GRANT))
                {
                    alt86=9;
                }
                else if ( (LA86_0 == SQL92_RESERVED_REVOKE))
                {
                    alt86=12;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 86 );
                    ex->set_state( 0 );


                    goto rulenon_dml_eventEx;

                }
            }
            switch (alt86)
            {
        	case 1:
        	    // PLSQLParser.g:344:10: alter_key
        	    {
        	        this->followPush(FOLLOW_alter_key_in_non_dml_event2687);
        	        alter_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:345:10: analyze_key
        	    {
        	        this->followPush(FOLLOW_analyze_key_in_non_dml_event2698);
        	        analyze_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLParser.g:346:10: associate_key statistics_key
        	    {
        	        this->followPush(FOLLOW_associate_key_in_non_dml_event2709);
        	        associate_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_statistics_key_in_non_dml_event2711);
        	        statistics_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQLParser.g:347:10: audit_key
        	    {
        	        this->followPush(FOLLOW_audit_key_in_non_dml_event2722);
        	        audit_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQLParser.g:348:10: comment_key
        	    {
        	        this->followPush(FOLLOW_comment_key_in_non_dml_event2733);
        	        comment_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // PLSQLParser.g:349:10: create_key
        	    {
        	        this->followPush(FOLLOW_create_key_in_non_dml_event2744);
        	        create_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 7:
        	    // PLSQLParser.g:350:10: disassociate_key statistics_key
        	    {
        	        this->followPush(FOLLOW_disassociate_key_in_non_dml_event2755);
        	        disassociate_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_statistics_key_in_non_dml_event2757);
        	        statistics_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 8:
        	    // PLSQLParser.g:351:10: drop_key
        	    {
        	        this->followPush(FOLLOW_drop_key_in_non_dml_event2768);
        	        drop_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 9:
        	    // PLSQLParser.g:352:10: grant_key
        	    {
        	        this->followPush(FOLLOW_grant_key_in_non_dml_event2779);
        	        grant_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 10:
        	    // PLSQLParser.g:353:10: noaudit_key
        	    {
        	        this->followPush(FOLLOW_noaudit_key_in_non_dml_event2790);
        	        noaudit_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 11:
        	    // PLSQLParser.g:354:10: rename_key
        	    {
        	        this->followPush(FOLLOW_rename_key_in_non_dml_event2801);
        	        rename_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 12:
        	    // PLSQLParser.g:355:10: revoke_key
        	    {
        	        this->followPush(FOLLOW_revoke_key_in_non_dml_event2812);
        	        revoke_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 13:
        	    // PLSQLParser.g:356:10: truncate_key
        	    {
        	        this->followPush(FOLLOW_truncate_key_in_non_dml_event2823);
        	        truncate_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 14:
        	    // PLSQLParser.g:357:10: ddl_key
        	    {
        	        this->followPush(FOLLOW_ddl_key_in_non_dml_event2834);
        	        ddl_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 15:
        	    // PLSQLParser.g:358:10: startup_key
        	    {
        	        this->followPush(FOLLOW_startup_key_in_non_dml_event2845);
        	        startup_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 16:
        	    // PLSQLParser.g:359:10: shutdown_key
        	    {
        	        this->followPush(FOLLOW_shutdown_key_in_non_dml_event2856);
        	        shutdown_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 17:
        	    // PLSQLParser.g:360:10: db_role_change_key
        	    {
        	        this->followPush(FOLLOW_db_role_change_key_in_non_dml_event2867);
        	        db_role_change_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 18:
        	    // PLSQLParser.g:361:10: logon_key
        	    {
        	        this->followPush(FOLLOW_logon_key_in_non_dml_event2878);
        	        logon_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 19:
        	    // PLSQLParser.g:362:10: logoff_key
        	    {
        	        this->followPush(FOLLOW_logoff_key_in_non_dml_event2889);
        	        logoff_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 20:
        	    // PLSQLParser.g:363:10: servererror_key
        	    {
        	        this->followPush(FOLLOW_servererror_key_in_non_dml_event2900);
        	        servererror_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 21:
        	    // PLSQLParser.g:364:10: suspend_key
        	    {
        	        this->followPush(FOLLOW_suspend_key_in_non_dml_event2911);
        	        suspend_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 22:
        	    // PLSQLParser.g:365:10: database_key
        	    {
        	        this->followPush(FOLLOW_database_key_in_non_dml_event2922);
        	        database_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 23:
        	    // PLSQLParser.g:366:10: schema_key
        	    {
        	        this->followPush(FOLLOW_schema_key_in_non_dml_event2933);
        	        schema_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 24:
        	    // PLSQLParser.g:367:10: follows_key
        	    {
        	        this->followPush(FOLLOW_follows_key_in_non_dml_event2944);
        	        follows_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenon_dml_eventEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulenon_dml_eventEx; /* Prevent compiler warnings */
    rulenon_dml_eventEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end non_dml_event */

/**
 * $ANTLR start dml_event_clause
 * PLSQLParser.g:370:1: dml_event_clause : dml_event_element ( or_key dml_event_element )* on_key ( dml_event_nested_clause )? tableview_name ;
 */
void
PLSQLParser::dml_event_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:371:5: ( dml_event_element ( or_key dml_event_element )* on_key ( dml_event_nested_clause )? tableview_name )
        // PLSQLParser.g:371:10: dml_event_element ( or_key dml_event_element )* on_key ( dml_event_nested_clause )? tableview_name
        {
            this->followPush(FOLLOW_dml_event_element_in_dml_event_clause2964);
            dml_event_element();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledml_event_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:371:28: ( or_key dml_event_element )*

            for (;;)
            {
                int alt87=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA87_0 = this->LA(1);
                    if ( (LA87_0 == SQL92_RESERVED_OR))
                    {
                        alt87=1;
                    }

                }
                switch (alt87)
                {
            	case 1:
            	    // PLSQLParser.g:371:29: or_key dml_event_element
            	    {
            	        this->followPush(FOLLOW_or_key_in_dml_event_clause2967);
            	        or_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledml_event_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_dml_event_element_in_dml_event_clause2969);
            	        dml_event_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledml_event_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop87;	/* break out of the loop */
            	    break;
                }
            }
            loop87: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_on_key_in_dml_event_clause2981);
            on_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledml_event_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:373:9: ( dml_event_nested_clause )?
            {
                int alt88=2;
                {
                    int LA88_0 = this->LA(1);
                    if ( (LA88_0 == REGULAR_ID))
                    {
                        {
                            int LA88_1 = this->LA(2);
                            if ( (LA88_1 == SQL92_RESERVED_TABLE) && ((equalsIgnoreCase(LT(1)->getText(), "NESTED"))))
                            {
                                alt88=1;
                            }
                        }
                    }
                }
                switch (alt88)
                {
            	case 1:
            	    // PLSQLParser.g:373:9: dml_event_nested_clause
            	    {
            	        this->followPush(FOLLOW_dml_event_nested_clause_in_dml_event_clause2992);
            	        dml_event_nested_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledml_event_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_tableview_name_in_dml_event_clause2995);
            tableview_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledml_event_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledml_event_clauseEx; /* Prevent compiler warnings */
    ruledml_event_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dml_event_clause */

/**
 * $ANTLR start dml_event_element
 * PLSQLParser.g:376:1: dml_event_element : ( delete_key | insert_key | update_key ) ( of_key column_name ( COMMA column_name )* )? ;
 */
void
PLSQLParser::dml_event_element()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:377:5: ( ( delete_key | insert_key | update_key ) ( of_key column_name ( COMMA column_name )* )? )
        // PLSQLParser.g:377:10: ( delete_key | insert_key | update_key ) ( of_key column_name ( COMMA column_name )* )?
        {
            // PLSQLParser.g:377:10: ( delete_key | insert_key | update_key )
            {
                int alt89=3;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_DELETE:
                	{
                		alt89=1;
                	}
                    break;
                case SQL92_RESERVED_INSERT:
                	{
                		alt89=2;
                	}
                    break;
                case SQL92_RESERVED_UPDATE:
                	{
                		alt89=3;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 89 );
                    ex->set_state( 0 );


                    goto ruledml_event_elementEx;

                }

                switch (alt89)
                {
            	case 1:
            	    // PLSQLParser.g:377:11: delete_key
            	    {
            	        this->followPush(FOLLOW_delete_key_in_dml_event_element3016);
            	        delete_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledml_event_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:377:22: insert_key
            	    {
            	        this->followPush(FOLLOW_insert_key_in_dml_event_element3018);
            	        insert_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledml_event_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLParser.g:377:33: update_key
            	    {
            	        this->followPush(FOLLOW_update_key_in_dml_event_element3020);
            	        update_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledml_event_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:377:45: ( of_key column_name ( COMMA column_name )* )?
            {
                int alt91=2;
                {
                    int LA91_0 = this->LA(1);
                    if ( (LA91_0 == SQL92_RESERVED_OF))
                    {
                        alt91=1;
                    }
                }
                switch (alt91)
                {
            	case 1:
            	    // PLSQLParser.g:377:46: of_key column_name ( COMMA column_name )*
            	    {
            	        this->followPush(FOLLOW_of_key_in_dml_event_element3024);
            	        of_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledml_event_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_dml_event_element3026);
            	        column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledml_event_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:377:65: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            int alt90=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA90_0 = this->LA(1);
            	                if ( (LA90_0 == COMMA))
            	                {
            	                    alt90=1;
            	                }

            	            }
            	            switch (alt90)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:377:66: COMMA column_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_dml_event_element3029);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruledml_event_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_column_name_in_dml_event_element3031);
            	        	        column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruledml_event_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop90;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop90: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruledml_event_elementEx; /* Prevent compiler warnings */
    ruledml_event_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dml_event_element */

/**
 * $ANTLR start dml_event_nested_clause
 * PLSQLParser.g:380:1: dml_event_nested_clause : nested_key table_key tableview_name of_key ;
 */
void
PLSQLParser::dml_event_nested_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:381:5: ( nested_key table_key tableview_name of_key )
        // PLSQLParser.g:381:10: nested_key table_key tableview_name of_key
        {
            this->followPush(FOLLOW_nested_key_in_dml_event_nested_clause3055);
            nested_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledml_event_nested_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_table_key_in_dml_event_nested_clause3057);
            table_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledml_event_nested_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_tableview_name_in_dml_event_nested_clause3059);
            tableview_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledml_event_nested_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_of_key_in_dml_event_nested_clause3061);
            of_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledml_event_nested_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledml_event_nested_clauseEx; /* Prevent compiler warnings */
    ruledml_event_nested_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dml_event_nested_clause */

/**
 * $ANTLR start referencing_clause
 * PLSQLParser.g:384:1: referencing_clause : referencing_key ( referencing_element )+ ;
 */
void
PLSQLParser::referencing_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:385:5: ( referencing_key ( referencing_element )+ )
        // PLSQLParser.g:385:10: referencing_key ( referencing_element )+
        {
            this->followPush(FOLLOW_referencing_key_in_referencing_clause3081);
            referencing_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereferencing_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:385:26: ( referencing_element )+
            {
                int cnt92=0;

                for (;;)
                {
                    int alt92=2;
            	alt92 = cdfa92.predict(this, this->get_rec(), this->get_istream(), cdfa92 );
            	if  (this->hasException())
            	{
            	    goto rulereferencing_clauseEx;
            	}
            	if (this->hasFailed())
            	{
            	    return ;
            	}

            	switch (alt92)
            	{
            	    case 1:
            	        // PLSQLParser.g:385:26: referencing_element
            	        {
            	            this->followPush(FOLLOW_referencing_element_in_referencing_clause3083);
            	            referencing_element();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulereferencing_clauseEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt92 >= 1 )
            		{
            		    goto loop92;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PLSQLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto rulereferencing_clauseEx;
            	}
            	cnt92++;
                }
                loop92: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulereferencing_clauseEx; /* Prevent compiler warnings */
    rulereferencing_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end referencing_clause */

/**
 * $ANTLR start referencing_element
 * PLSQLParser.g:388:1: referencing_element : ( new_key | old_key | parent_key ) column_alias ;
 */
void
PLSQLParser::referencing_element()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:389:5: ( ( new_key | old_key | parent_key ) column_alias )
        // PLSQLParser.g:389:10: ( new_key | old_key | parent_key ) column_alias
        {
            // PLSQLParser.g:389:10: ( new_key | old_key | parent_key )
            {
                int alt93=3;
                {
                    int LA93_0 = this->LA(1);
                    if ( (LA93_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "OLD")))||((equalsIgnoreCase(LT(1)->getText(), "PARENT")))||((equalsIgnoreCase(LT(1)->getText(), "NEW"))))))
                    {
                        {
                            int LA93_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))))
                            {
                                alt93=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "OLD"))))
                            {
                                alt93=2;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "PARENT"))))
                            {
                                alt93=3;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 93 );
                                ex->set_state( 1 );


                                goto rulereferencing_elementEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 93 );
                        ex->set_state( 0 );


                        goto rulereferencing_elementEx;

                    }
                }
                switch (alt93)
                {
            	case 1:
            	    // PLSQLParser.g:389:12: new_key
            	    {
            	        this->followPush(FOLLOW_new_key_in_referencing_element3106);
            	        new_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulereferencing_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:389:22: old_key
            	    {
            	        this->followPush(FOLLOW_old_key_in_referencing_element3110);
            	        old_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulereferencing_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLParser.g:389:32: parent_key
            	    {
            	        this->followPush(FOLLOW_parent_key_in_referencing_element3114);
            	        parent_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulereferencing_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_column_alias_in_referencing_element3118);
            column_alias();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereferencing_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereferencing_elementEx; /* Prevent compiler warnings */
    rulereferencing_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end referencing_element */

/**
 * $ANTLR start drop_type
 * PLSQLParser.g:397:1: drop_type : drop_key type_key ( body_key )? type_name ( force_key | validate_key )? SEMICOLON ;
 */
void
PLSQLParser::drop_type()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:398:5: ( drop_key type_key ( body_key )? type_name ( force_key | validate_key )? SEMICOLON )
        // PLSQLParser.g:398:10: drop_key type_key ( body_key )? type_name ( force_key | validate_key )? SEMICOLON
        {
            this->followPush(FOLLOW_drop_key_in_drop_type3143);
            drop_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledrop_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_key_in_drop_type3145);
            type_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledrop_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:398:28: ( body_key )?
            {
                int alt94=2;
                {
                    int LA94_0 = this->LA(1);
                    if ( (LA94_0 == REGULAR_ID))
                    {
                        {
                            int LA94_1 = this->LA(2);
                            if ( (LA94_1 == REGULAR_ID))
                            {
                                {
                                    int LA94_3 = this->LA(3);
                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "BODY"))))
                                    {
                                        alt94=1;
                                    }
                                }
                            }
                            else if ( (LA94_1 == DELIMITED_ID))
                            {
                                alt94=1;
                            }
                        }
                    }
                }
                switch (alt94)
                {
            	case 1:
            	    // PLSQLParser.g:398:28: body_key
            	    {
            	        this->followPush(FOLLOW_body_key_in_drop_type3147);
            	        body_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledrop_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_type_name_in_drop_type3150);
            type_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledrop_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:398:48: ( force_key | validate_key )?
            {
                int alt95=3;
                {
                    int LA95_0 = this->LA(1);
                    if ( (LA95_0 == REGULAR_ID))
                    {
                        {
                            int LA95_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "FORCE"))))
                            {
                                alt95=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "VALIDATE"))))
                            {
                                alt95=2;
                            }
                        }
                    }
                }
                switch (alt95)
                {
            	case 1:
            	    // PLSQLParser.g:398:49: force_key
            	    {
            	        this->followPush(FOLLOW_force_key_in_drop_type3153);
            	        force_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledrop_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:398:59: validate_key
            	    {
            	        this->followPush(FOLLOW_validate_key_in_drop_type3155);
            	        validate_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledrop_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_drop_type3167);
            if  (this->hasException())
            {
                goto ruledrop_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledrop_typeEx; /* Prevent compiler warnings */
    ruledrop_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end drop_type */

/**
 * $ANTLR start alter_type
 * PLSQLParser.g:402:1: alter_type : alter_key type_key type_name ( compile_type_clause | replace_type_clause |{...}? alter_attribute_definition | alter_method_spec | alter_collection_clauses | modifier_clause ) ( dependent_handling_clause )? SEMICOLON ;
 */
void
PLSQLParser::alter_type()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:403:5: ( alter_key type_key type_name ( compile_type_clause | replace_type_clause |{...}? alter_attribute_definition | alter_method_spec | alter_collection_clauses | modifier_clause ) ( dependent_handling_clause )? SEMICOLON )
        // PLSQLParser.g:403:10: alter_key type_key type_name ( compile_type_clause | replace_type_clause |{...}? alter_attribute_definition | alter_method_spec | alter_collection_clauses | modifier_clause ) ( dependent_handling_clause )? SEMICOLON
        {
            this->followPush(FOLLOW_alter_key_in_alter_type3187);
            alter_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_key_in_alter_type3189);
            type_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_name_in_alter_type3191);
            type_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:404:5: ( compile_type_clause | replace_type_clause |{...}? alter_attribute_definition | alter_method_spec | alter_collection_clauses | modifier_clause )
            {
                int alt96=6;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		{
                		    int LA96_1 = this->LA(2);
                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "COMPILE"))))
                		    {
                		        alt96=1;
                		    }
                		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "REPLACE" ))))
                		    {
                		        alt96=2;
                		    }
                		    else if ( (( ((((equalsIgnoreCase(LT(1)->getText(), "MODIFY")))||((equalsIgnoreCase(LT(1)->getText(), "ADD"))))) && ((equalsIgnoreCase(LT(2)->getText(), "ATTRIBUTE"))) )))
                		    {
                		        alt96=3;
                		    }
                		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "ADD"))))
                		    {
                		        alt96=4;
                		    }
                		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "MODIFY"))))
                		    {
                		        alt96=5;
                		    }
                		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "FINAL")))||((equalsIgnoreCase(LT(1)->getText(), "OVERRIDING")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))))))
                		    {
                		        alt96=6;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 96 );
                		        ex->set_state( 1 );


                		        goto rulealter_typeEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_DROP:
                	{
                		{
                		    int LA96_2 = this->LA(2);
                		    if ( ((equalsIgnoreCase(LT(2)->getText(), "ATTRIBUTE"))))
                		    {
                		        alt96=3;
                		    }
                		    else if ( (true))
                		    {
                		        alt96=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 96 );
                		        ex->set_state( 2 );


                		        goto rulealter_typeEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_NOT:
                	{
                		alt96=6;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 96 );
                    ex->set_state( 0 );


                    goto rulealter_typeEx;

                }

                switch (alt96)
                {
            	case 1:
            	    // PLSQLParser.g:404:10: compile_type_clause
            	    {
            	        this->followPush(FOLLOW_compile_type_clause_in_alter_type3202);
            	        compile_type_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:405:10: replace_type_clause
            	    {
            	        this->followPush(FOLLOW_replace_type_clause_in_alter_type3213);
            	        replace_type_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLParser.g:406:10: {...}? alter_attribute_definition
            	    {
            	        if ( !((equalsIgnoreCase(LT(2)->getText(), "ATTRIBUTE"))) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return ;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(2)->getText(), \"ATTRIBUTE\")" );
            	                ex->set_ruleName( "alter_type" );


            	        }

            	        this->followPush(FOLLOW_alter_attribute_definition_in_alter_type3226);
            	        alter_attribute_definition();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 4:
            	    // PLSQLParser.g:407:10: alter_method_spec
            	    {
            	        this->followPush(FOLLOW_alter_method_spec_in_alter_type3237);
            	        alter_method_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 5:
            	    // PLSQLParser.g:408:10: alter_collection_clauses
            	    {
            	        this->followPush(FOLLOW_alter_collection_clauses_in_alter_type3248);
            	        alter_collection_clauses();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 6:
            	    // PLSQLParser.g:409:10: modifier_clause
            	    {
            	        this->followPush(FOLLOW_modifier_clause_in_alter_type3259);
            	        modifier_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:411:9: ( dependent_handling_clause )?
            {
                int alt97=2;
                {
                    int LA97_0 = this->LA(1);
                    if ( (LA97_0 == REGULAR_ID))
                    {
                        alt97=1;
                    }
                }
                switch (alt97)
                {
            	case 1:
            	    // PLSQLParser.g:411:9: dependent_handling_clause
            	    {
            	        this->followPush(FOLLOW_dependent_handling_clause_in_alter_type3275);
            	        dependent_handling_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_alter_type3286);
            if  (this->hasException())
            {
                goto rulealter_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealter_typeEx; /* Prevent compiler warnings */
    rulealter_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end alter_type */

/**
 * $ANTLR start compile_type_clause
 * PLSQLParser.g:416:1: compile_type_clause : compile_key ( debug_key )? ( specification_key | body_key )? ( compiler_parameters_clause )* ( reuse_key settings_key )? ;
 */
void
PLSQLParser::compile_type_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:417:5: ( compile_key ( debug_key )? ( specification_key | body_key )? ( compiler_parameters_clause )* ( reuse_key settings_key )? )
        // PLSQLParser.g:417:10: compile_key ( debug_key )? ( specification_key | body_key )? ( compiler_parameters_clause )* ( reuse_key settings_key )?
        {
            this->followPush(FOLLOW_compile_key_in_compile_type_clause3307);
            compile_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecompile_type_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:417:22: ( debug_key )?
            {
                int alt98=2;
                {
                    int LA98_0 = this->LA(1);
                    if ( (LA98_0 == REGULAR_ID))
                    {
                        {
                            int LA98_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "DEBUG"))))
                            {
                                alt98=1;
                            }
                        }
                    }
                }
                switch (alt98)
                {
            	case 1:
            	    // PLSQLParser.g:417:22: debug_key
            	    {
            	        this->followPush(FOLLOW_debug_key_in_compile_type_clause3309);
            	        debug_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecompile_type_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:417:33: ( specification_key | body_key )?
            {
                int alt99=3;
                {
                    int LA99_0 = this->LA(1);
                    if ( (LA99_0 == REGULAR_ID))
                    {
                        {
                            int LA99_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "SPECIFICATION"))))
                            {
                                alt99=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "BODY"))))
                            {
                                alt99=2;
                            }
                        }
                    }
                }
                switch (alt99)
                {
            	case 1:
            	    // PLSQLParser.g:417:34: specification_key
            	    {
            	        this->followPush(FOLLOW_specification_key_in_compile_type_clause3313);
            	        specification_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecompile_type_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:417:52: body_key
            	    {
            	        this->followPush(FOLLOW_body_key_in_compile_type_clause3315);
            	        body_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecompile_type_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:417:63: ( compiler_parameters_clause )*

            for (;;)
            {
                int alt100=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA100_0 = this->LA(1);
                    if ( (LA100_0 == REGULAR_ID))
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA100_1 = this->LA(2);
                            if ( (LA100_1 == EQUALS_OP))
                            {
                                alt100=1;
                            }

                        }
                    }
                    else if ( (LA100_0 == DELIMITED_ID || LA100_0 == INTRODUCER))
                    {
                        alt100=1;
                    }

                }
                switch (alt100)
                {
            	case 1:
            	    // PLSQLParser.g:417:63: compiler_parameters_clause
            	    {
            	        this->followPush(FOLLOW_compiler_parameters_clause_in_compile_type_clause3319);
            	        compiler_parameters_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecompile_type_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop100;	/* break out of the loop */
            	    break;
                }
            }
            loop100: ; /* Jump out to here if this rule does not match */


            // PLSQLParser.g:417:91: ( reuse_key settings_key )?
            {
                int alt101=2;
                {
                    int LA101_0 = this->LA(1);
                    if ( (LA101_0 == REGULAR_ID))
                    {
                        {
                            int LA101_1 = this->LA(2);
                            if ( (LA101_1 == REGULAR_ID))
                            {
                                {
                                    int LA101_3 = this->LA(3);
                                    if ( (LA101_3 == REGULAR_ID))
                                    {
                                        {
                                            int LA101_5 = this->LA(4);
                                            if ( (LA101_5 == REGULAR_ID || LA101_5 == SEMICOLON || LA101_5 == SQL92_RESERVED_NOT))
                                            {
                                                alt101=1;
                                            }
                                        }
                                    }
                                    else if ( (LA101_3 == SEMICOLON))
                                    {
                                        alt101=1;
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt101)
                {
            	case 1:
            	    // PLSQLParser.g:417:92: reuse_key settings_key
            	    {
            	        this->followPush(FOLLOW_reuse_key_in_compile_type_clause3323);
            	        reuse_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecompile_type_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_settings_key_in_compile_type_clause3325);
            	        settings_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecompile_type_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulecompile_type_clauseEx; /* Prevent compiler warnings */
    rulecompile_type_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end compile_type_clause */

/**
 * $ANTLR start replace_type_clause
 * PLSQLParser.g:420:1: replace_type_clause : replace_key ( invoker_rights_clause )? as_key object_key LEFT_PAREN object_member_spec ( COMMA object_member_spec )* RIGHT_PAREN ;
 */
void
PLSQLParser::replace_type_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:421:5: ( replace_key ( invoker_rights_clause )? as_key object_key LEFT_PAREN object_member_spec ( COMMA object_member_spec )* RIGHT_PAREN )
        // PLSQLParser.g:421:10: replace_key ( invoker_rights_clause )? as_key object_key LEFT_PAREN object_member_spec ( COMMA object_member_spec )* RIGHT_PAREN
        {
            this->followPush(FOLLOW_replace_key_in_replace_type_clause3347);
            replace_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereplace_type_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:421:22: ( invoker_rights_clause )?
            {
                int alt102=2;
                {
                    int LA102_0 = this->LA(1);
                    if ( (LA102_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "AUTHID"))))
                    {
                        alt102=1;
                    }
                }
                switch (alt102)
                {
            	case 1:
            	    // PLSQLParser.g:421:22: invoker_rights_clause
            	    {
            	        this->followPush(FOLLOW_invoker_rights_clause_in_replace_type_clause3349);
            	        invoker_rights_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulereplace_type_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_as_key_in_replace_type_clause3352);
            as_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereplace_type_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_object_key_in_replace_type_clause3354);
            object_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereplace_type_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_replace_type_clause3364);
            if  (this->hasException())
            {
                goto rulereplace_type_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_object_member_spec_in_replace_type_clause3366);
            object_member_spec();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereplace_type_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:422:39: ( COMMA object_member_spec )*

            for (;;)
            {
                int alt103=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA103_0 = this->LA(1);
                    if ( (LA103_0 == COMMA))
                    {
                        alt103=1;
                    }

                }
                switch (alt103)
                {
            	case 1:
            	    // PLSQLParser.g:422:40: COMMA object_member_spec
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_replace_type_clause3369);
            	        if  (this->hasException())
            	        {
            	            goto rulereplace_type_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_object_member_spec_in_replace_type_clause3371);
            	        object_member_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulereplace_type_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop103;	/* break out of the loop */
            	    break;
                }
            }
            loop103: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_replace_type_clause3375);
            if  (this->hasException())
            {
                goto rulereplace_type_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereplace_type_clauseEx; /* Prevent compiler warnings */
    rulereplace_type_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end replace_type_clause */

/**
 * $ANTLR start alter_method_spec
 * PLSQLParser.g:425:1: alter_method_spec : alter_method_element ( COMMA alter_method_element )* ;
 */
void
PLSQLParser::alter_method_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:426:5: ( alter_method_element ( COMMA alter_method_element )* )
        // PLSQLParser.g:426:11: alter_method_element ( COMMA alter_method_element )*
        {
            this->followPush(FOLLOW_alter_method_element_in_alter_method_spec3396);
            alter_method_element();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_method_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:426:32: ( COMMA alter_method_element )*

            for (;;)
            {
                int alt104=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA104_0 = this->LA(1);
                    if ( (LA104_0 == COMMA))
                    {
                        alt104=1;
                    }

                }
                switch (alt104)
                {
            	case 1:
            	    // PLSQLParser.g:426:33: COMMA alter_method_element
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_alter_method_spec3399);
            	        if  (this->hasException())
            	        {
            	            goto rulealter_method_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_alter_method_element_in_alter_method_spec3401);
            	        alter_method_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_method_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop104;	/* break out of the loop */
            	    break;
                }
            }
            loop104: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealter_method_specEx; /* Prevent compiler warnings */
    rulealter_method_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end alter_method_spec */

/**
 * $ANTLR start alter_method_element
 * PLSQLParser.g:429:1: alter_method_element : ( add_key | drop_key ) ( map_order_function_spec | subprogram_spec ) ;
 */
void
PLSQLParser::alter_method_element()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:430:5: ( ( add_key | drop_key ) ( map_order_function_spec | subprogram_spec ) )
        // PLSQLParser.g:430:10: ( add_key | drop_key ) ( map_order_function_spec | subprogram_spec )
        {
            // PLSQLParser.g:430:10: ( add_key | drop_key )
            {
                int alt105=2;
                {
                    int LA105_0 = this->LA(1);
                    if ( (LA105_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "ADD"))))
                    {
                        alt105=1;
                    }
                    else if ( (LA105_0 == SQL92_RESERVED_DROP))
                    {
                        alt105=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 105 );
                        ex->set_state( 0 );


                        goto rulealter_method_elementEx;

                    }
                }
                switch (alt105)
                {
            	case 1:
            	    // PLSQLParser.g:430:11: add_key
            	    {
            	        this->followPush(FOLLOW_add_key_in_alter_method_element3424);
            	        add_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_method_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:430:19: drop_key
            	    {
            	        this->followPush(FOLLOW_drop_key_in_alter_method_element3426);
            	        drop_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_method_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:430:29: ( map_order_function_spec | subprogram_spec )
            {
                int alt106=2;
                {
                    int LA106_0 = this->LA(1);
                    if ( (LA106_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER")))||((equalsIgnoreCase(LT(1)->getText(), "MAP"))))))
                    {
                        {
                            int LA106_1 = this->LA(2);
                            if ( (LA106_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER")))||((equalsIgnoreCase(LT(1)->getText(), "MAP"))))))
                            {
                                {
                                    int LA106_3 = this->LA(3);
                                    if ( (LA106_3 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER")))||((equalsIgnoreCase(LT(1)->getText(), "MAP"))))))
                                    {
                                        {
                                            int LA106_5 = this->LA(4);
                                            if ( (LA106_5 == DELIMITED_ID || LA106_5 == INTRODUCER) && ((equalsIgnoreCase(LT(1)->getText(), "MAP"))))
                                            {
                                                alt106=1;
                                            }
                                            else if ( (LA106_5 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER")))||((equalsIgnoreCase(LT(1)->getText(), "MAP"))))))
                                            {
                                                {
                                                    int LA106_7 = this->LA(5);
                                                    if ( (LA106_7 == LEFT_PAREN || LA106_7 == PERIOD) && ((equalsIgnoreCase(LT(1)->getText(), "MAP"))))
                                                    {
                                                        alt106=1;
                                                    }
                                                    else if ( (LA106_7 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER")))||((equalsIgnoreCase(LT(1)->getText(), "MAP"))))))
                                                    {
                                                        {
                                                            int LA106_8 = this->LA(6);
                                                            if ( (LA106_8 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER")))||((equalsIgnoreCase(LT(1)->getText(), "MAP"))))))
                                                            {
                                                                {
                                                                    int LA106_9 = this->LA(7);
                                                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "MAP"))))
                                                                    {
                                                                        alt106=1;
                                                                    }
                                                                    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))))
                                                                    {
                                                                        alt106=2;
                                                                    }
                                                                    else
                                                                    {
                                                                        if (this->get_backtracking()>0)
                                                                        {
                                                                            this->set_failedflag( true );
                                                                            return ;
                                                                        }


                                                                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                                                        ex->set_decisionNum( 106 );
                                                                        ex->set_state( 9 );


                                                                        goto rulealter_method_elementEx;

                                                                    }
                                                                }
                                                            }
                                                            else if ( (LA106_8 == SQL92_RESERVED_DATE) && ((equalsIgnoreCase(LT(1)->getText(), "MAP"))))
                                                            {
                                                                alt106=1;
                                                            }
                                                            else if ( (LA106_8 == DELIMITED_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER")))||((equalsIgnoreCase(LT(1)->getText(), "MAP"))))))
                                                            {
                                                                {
                                                                    int LA106_10 = this->LA(7);
                                                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "MAP"))))
                                                                    {
                                                                        alt106=1;
                                                                    }
                                                                    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))))
                                                                    {
                                                                        alt106=2;
                                                                    }
                                                                    else
                                                                    {
                                                                        if (this->get_backtracking()>0)
                                                                        {
                                                                            this->set_failedflag( true );
                                                                            return ;
                                                                        }


                                                                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                                                        ex->set_decisionNum( 106 );
                                                                        ex->set_state( 10 );


                                                                        goto rulealter_method_elementEx;

                                                                    }
                                                                }
                                                            }
                                                            else if ( (LA106_8 == COMMA || LA106_8 == LEFT_PAREN || ((LA106_8 >= PERCENT) && (LA106_8 <= PERIOD)) || LA106_8 == SEMICOLON || LA106_8 == SQL92_RESERVED_AS || LA106_8 == SQL92_RESERVED_IS || LA106_8 == SQL92_RESERVED_WITH) && ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))))
                                                            {
                                                                alt106=2;
                                                            }
                                                            else
                                                            {
                                                                if (this->get_backtracking()>0)
                                                                {
                                                                    this->set_failedflag( true );
                                                                    return ;
                                                                }


                                                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                                                ex->set_decisionNum( 106 );
                                                                ex->set_state( 8 );


                                                                goto rulealter_method_elementEx;

                                                            }
                                                        }
                                                    }
                                                    else if ( (LA106_7 == DELIMITED_ID || LA106_7 == SQL92_RESERVED_DATE) && ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))))
                                                    {
                                                        alt106=2;
                                                    }
                                                    else
                                                    {
                                                        if (this->get_backtracking()>0)
                                                        {
                                                            this->set_failedflag( true );
                                                            return ;
                                                        }


                                                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                                        ex->set_decisionNum( 106 );
                                                        ex->set_state( 7 );


                                                        goto rulealter_method_elementEx;

                                                    }
                                                }
                                            }
                                            else if ( (LA106_5 == LEFT_PAREN || LA106_5 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))))
                                            {
                                                alt106=2;
                                            }
                                            else
                                            {
                                                if (this->get_backtracking()>0)
                                                {
                                                    this->set_failedflag( true );
                                                    return ;
                                                }


                                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                                ex->set_decisionNum( 106 );
                                                ex->set_state( 5 );


                                                goto rulealter_method_elementEx;

                                            }
                                        }
                                    }
                                    else if ( (LA106_3 == DELIMITED_ID || LA106_3 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))))
                                    {
                                        alt106=2;
                                    }
                                    else
                                    {
                                        if (this->get_backtracking()>0)
                                        {
                                            this->set_failedflag( true );
                                            return ;
                                        }


                                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                        ex->set_decisionNum( 106 );
                                        ex->set_state( 3 );


                                        goto rulealter_method_elementEx;

                                    }
                                }
                            }
                            else if ( (LA106_1 == SQL92_RESERVED_PROCEDURE) && ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))))
                            {
                                alt106=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 106 );
                                ex->set_state( 1 );


                                goto rulealter_method_elementEx;

                            }
                        }
                    }
                    else if ( (LA106_0 == SQL92_RESERVED_ORDER))
                    {
                        alt106=1;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 106 );
                        ex->set_state( 0 );


                        goto rulealter_method_elementEx;

                    }
                }
                switch (alt106)
                {
            	case 1:
            	    // PLSQLParser.g:430:30: map_order_function_spec
            	    {
            	        this->followPush(FOLLOW_map_order_function_spec_in_alter_method_element3430);
            	        map_order_function_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_method_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:430:54: subprogram_spec
            	    {
            	        this->followPush(FOLLOW_subprogram_spec_in_alter_method_element3432);
            	        subprogram_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_method_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulealter_method_elementEx; /* Prevent compiler warnings */
    rulealter_method_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end alter_method_element */

/**
 * $ANTLR start alter_attribute_definition
 * PLSQLParser.g:433:1: alter_attribute_definition : ( add_key | modify_key | drop_key ) attribute_key ( attribute_definition | LEFT_PAREN attribute_definition ( COMMA attribute_definition )* RIGHT_PAREN ) ;
 */
void
PLSQLParser::alter_attribute_definition()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:434:5: ( ( add_key | modify_key | drop_key ) attribute_key ( attribute_definition | LEFT_PAREN attribute_definition ( COMMA attribute_definition )* RIGHT_PAREN ) )
        // PLSQLParser.g:434:10: ( add_key | modify_key | drop_key ) attribute_key ( attribute_definition | LEFT_PAREN attribute_definition ( COMMA attribute_definition )* RIGHT_PAREN )
        {
            // PLSQLParser.g:434:10: ( add_key | modify_key | drop_key )
            {
                int alt107=3;
                {
                    int LA107_0 = this->LA(1);
                    if ( (LA107_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "MODIFY")))||((equalsIgnoreCase(LT(1)->getText(), "ADD"))))))
                    {
                        {
                            int LA107_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "ADD"))))
                            {
                                alt107=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "MODIFY"))))
                            {
                                alt107=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 107 );
                                ex->set_state( 1 );


                                goto rulealter_attribute_definitionEx;

                            }
                        }
                    }
                    else if ( (LA107_0 == SQL92_RESERVED_DROP))
                    {
                        alt107=3;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 107 );
                        ex->set_state( 0 );


                        goto rulealter_attribute_definitionEx;

                    }
                }
                switch (alt107)
                {
            	case 1:
            	    // PLSQLParser.g:434:11: add_key
            	    {
            	        this->followPush(FOLLOW_add_key_in_alter_attribute_definition3454);
            	        add_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_attribute_definitionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:434:19: modify_key
            	    {
            	        this->followPush(FOLLOW_modify_key_in_alter_attribute_definition3456);
            	        modify_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_attribute_definitionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLParser.g:434:30: drop_key
            	    {
            	        this->followPush(FOLLOW_drop_key_in_alter_attribute_definition3458);
            	        drop_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_attribute_definitionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_attribute_key_in_alter_attribute_definition3461);
            attribute_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_attribute_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:435:9: ( attribute_definition | LEFT_PAREN attribute_definition ( COMMA attribute_definition )* RIGHT_PAREN )
            {
                int alt109=2;
                {
                    int LA109_0 = this->LA(1);
                    if ( (LA109_0 == DELIMITED_ID || LA109_0 == INTRODUCER || LA109_0 == REGULAR_ID))
                    {
                        alt109=1;
                    }
                    else if ( (LA109_0 == LEFT_PAREN))
                    {
                        alt109=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 109 );
                        ex->set_state( 0 );


                        goto rulealter_attribute_definitionEx;

                    }
                }
                switch (alt109)
                {
            	case 1:
            	    // PLSQLParser.g:435:14: attribute_definition
            	    {
            	        this->followPush(FOLLOW_attribute_definition_in_alter_attribute_definition3476);
            	        attribute_definition();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_attribute_definitionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:436:14: LEFT_PAREN attribute_definition ( COMMA attribute_definition )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_alter_attribute_definition3491);
            	        if  (this->hasException())
            	        {
            	            goto rulealter_attribute_definitionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_attribute_definition_in_alter_attribute_definition3493);
            	        attribute_definition();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_attribute_definitionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:436:46: ( COMMA attribute_definition )*

            	        for (;;)
            	        {
            	            int alt108=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA108_0 = this->LA(1);
            	                if ( (LA108_0 == COMMA))
            	                {
            	                    alt108=1;
            	                }

            	            }
            	            switch (alt108)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:436:47: COMMA attribute_definition
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_alter_attribute_definition3496);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulealter_attribute_definitionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_attribute_definition_in_alter_attribute_definition3498);
            	        	        attribute_definition();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulealter_attribute_definitionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop108;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop108: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_alter_attribute_definition3502);
            	        if  (this->hasException())
            	        {
            	            goto rulealter_attribute_definitionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulealter_attribute_definitionEx; /* Prevent compiler warnings */
    rulealter_attribute_definitionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end alter_attribute_definition */

/**
 * $ANTLR start attribute_definition
 * PLSQLParser.g:440:1: attribute_definition : attribute_name ( type_spec )? ;
 */
void
PLSQLParser::attribute_definition()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:441:5: ( attribute_name ( type_spec )? )
        // PLSQLParser.g:441:10: attribute_name ( type_spec )?
        {
            this->followPush(FOLLOW_attribute_name_in_attribute_definition3532);
            attribute_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleattribute_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:441:25: ( type_spec )?
            {
                int alt110=2;
                {
                    int LA110_0 = this->LA(1);
                    if ( (LA110_0 == REGULAR_ID))
                    {
                        {
                            int LA110_1 = this->LA(2);
                            if ( (!( ((((equalsIgnoreCase(LT(1)->getText(), "CASCADE")))||((equalsIgnoreCase(LT(1)->getText(), "INVALIDATE"))))) )))
                            {
                                alt110=1;
                            }
                        }
                    }
                    else if ( (LA110_0 == DELIMITED_ID || LA110_0 == SQL92_RESERVED_DATE))
                    {
                        alt110=1;
                    }
                }
                switch (alt110)
                {
            	case 1:
            	    // PLSQLParser.g:441:25: type_spec
            	    {
            	        this->followPush(FOLLOW_type_spec_in_attribute_definition3534);
            	        type_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleattribute_definitionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleattribute_definitionEx; /* Prevent compiler warnings */
    ruleattribute_definitionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end attribute_definition */

/**
 * $ANTLR start alter_collection_clauses
 * PLSQLParser.g:444:1: alter_collection_clauses : modify_key ( limit_key expression | element_key type_key type_spec ) ;
 */
void
PLSQLParser::alter_collection_clauses()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:445:5: ( modify_key ( limit_key expression | element_key type_key type_spec ) )
        // PLSQLParser.g:445:10: modify_key ( limit_key expression | element_key type_key type_spec )
        {
            this->followPush(FOLLOW_modify_key_in_alter_collection_clauses3555);
            modify_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_collection_clausesEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:446:5: ( limit_key expression | element_key type_key type_spec )
            {
                int alt111=2;
                {
                    int LA111_0 = this->LA(1);
                    if ( (LA111_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "LIMIT")))||((equalsIgnoreCase(LT(1)->getText(), "ELEMENT"))))))
                    {
                        {
                            int LA111_1 = this->LA(2);
                            if ( (LA111_1 == APPROXIMATE_NUM_LIT || LA111_1 == BINDVAR || ((LA111_1 >= CHAR_STRING) && (LA111_1 <= COLON)) || LA111_1 == DELIMITED_ID || LA111_1 == EXACT_NUM_LIT || LA111_1 == INTRODUCER || LA111_1 == LEFT_PAREN || ((LA111_1 >= MINUS_SIGN) && (LA111_1 <= NATIONAL_CHAR_STRING_LIT)) || LA111_1 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA111_1 == PLUS_SIGN || LA111_1 == SQL92_RESERVED_ALL || LA111_1 == SQL92_RESERVED_ANY || LA111_1 == SQL92_RESERVED_CASE || ((LA111_1 >= SQL92_RESERVED_CURSOR) && (LA111_1 <= SQL92_RESERVED_DATE)) || LA111_1 == SQL92_RESERVED_DEFAULT || LA111_1 == SQL92_RESERVED_DISTINCT || ((LA111_1 >= SQL92_RESERVED_EXISTS) && (LA111_1 <= SQL92_RESERVED_FALSE)) || ((LA111_1 >= SQL92_RESERVED_NOT) && (LA111_1 <= SQL92_RESERVED_NULL)) || LA111_1 == SQL92_RESERVED_PRIOR || LA111_1 == SQL92_RESERVED_TRUE || LA111_1 == UNSIGNED_INTEGER) && ((equalsIgnoreCase(LT(1)->getText(), "LIMIT"))))
                            {
                                alt111=1;
                            }
                            else if ( (LA111_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "LIMIT")))||((equalsIgnoreCase(LT(1)->getText(), "ELEMENT"))))))
                            {
                                {
                                    int LA111_3 = this->LA(3);
                                    if ( (LA111_3 == APPROXIMATE_NUM_LIT || LA111_3 == ASTERISK || LA111_3 == BINDVAR || ((LA111_3 >= CARRET_OPERATOR_PART) && (LA111_3 <= COLON)) || LA111_3 == CONCATENATION_OP || ((LA111_3 >= EQUALS_OP) && (LA111_3 <= EXCLAMATION_OPERATOR_PART)) || ((LA111_3 >= GREATER_THAN_OP) && (LA111_3 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA111_3 >= INTRODUCER) && (LA111_3 <= NATIONAL_CHAR_STRING_LIT)) || LA111_3 == NOT_EQUAL_OP || ((LA111_3 >= PERIOD) && (LA111_3 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA111_3 == PLUS_SIGN || LA111_3 == SEMICOLON || LA111_3 == SOLIDUS || LA111_3 == SQL92_RESERVED_ALL || ((LA111_3 >= SQL92_RESERVED_AND) && (LA111_3 <= SQL92_RESERVED_ANY)) || LA111_3 == SQL92_RESERVED_BETWEEN || LA111_3 == SQL92_RESERVED_CASE || LA111_3 == SQL92_RESERVED_DEFAULT || LA111_3 == SQL92_RESERVED_DISTINCT || ((LA111_3 >= SQL92_RESERVED_EXISTS) && (LA111_3 <= SQL92_RESERVED_FALSE)) || LA111_3 == SQL92_RESERVED_IN || ((LA111_3 >= SQL92_RESERVED_IS) && (LA111_3 <= SQL92_RESERVED_NULL)) || LA111_3 == SQL92_RESERVED_OR || LA111_3 == SQL92_RESERVED_PRIOR || LA111_3 == SQL92_RESERVED_TRUE || ((LA111_3 >= UNSIGNED_INTEGER) && (LA111_3 <= VERTICAL_BAR))) && ((equalsIgnoreCase(LT(1)->getText(), "LIMIT"))))
                                    {
                                        alt111=1;
                                    }
                                    else if ( (LA111_3 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "LIMIT")))||((equalsIgnoreCase(LT(1)->getText(), "ELEMENT"))))))
                                    {
                                        {
                                            int LA111_4 = this->LA(4);
                                            if ( ((equalsIgnoreCase(LT(1)->getText(), "LIMIT"))))
                                            {
                                                alt111=1;
                                            }
                                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "ELEMENT"))))
                                            {
                                                alt111=2;
                                            }
                                            else
                                            {
                                                if (this->get_backtracking()>0)
                                                {
                                                    this->set_failedflag( true );
                                                    return ;
                                                }


                                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                                ex->set_decisionNum( 111 );
                                                ex->set_state( 4 );


                                                goto rulealter_collection_clausesEx;

                                            }
                                        }
                                    }
                                    else if ( (LA111_3 == DELIMITED_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "LIMIT")))||((equalsIgnoreCase(LT(1)->getText(), "ELEMENT"))))))
                                    {
                                        {
                                            int LA111_5 = this->LA(4);
                                            if ( ((equalsIgnoreCase(LT(1)->getText(), "LIMIT"))))
                                            {
                                                alt111=1;
                                            }
                                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "ELEMENT"))))
                                            {
                                                alt111=2;
                                            }
                                            else
                                            {
                                                if (this->get_backtracking()>0)
                                                {
                                                    this->set_failedflag( true );
                                                    return ;
                                                }


                                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                                ex->set_decisionNum( 111 );
                                                ex->set_state( 5 );


                                                goto rulealter_collection_clausesEx;

                                            }
                                        }
                                    }
                                    else if ( (LA111_3 == SQL92_RESERVED_DATE) && ((((equalsIgnoreCase(LT(1)->getText(), "LIMIT")))||((equalsIgnoreCase(LT(1)->getText(), "ELEMENT"))))))
                                    {
                                        {
                                            int LA111_6 = this->LA(4);
                                            if ( (((LA111_6 >= CHAR_STRING) && (LA111_6 <= CHAR_STRING_PERL)) || LA111_6 == NATIONAL_CHAR_STRING_LIT) && ((equalsIgnoreCase(LT(1)->getText(), "LIMIT"))))
                                            {
                                                alt111=1;
                                            }
                                            else if ( (LA111_6 == LEFT_PAREN || LA111_6 == REGULAR_ID || LA111_6 == SEMICOLON || LA111_6 == SQL92_RESERVED_WITH) && ((equalsIgnoreCase(LT(1)->getText(), "ELEMENT"))))
                                            {
                                                alt111=2;
                                            }
                                            else
                                            {
                                                if (this->get_backtracking()>0)
                                                {
                                                    this->set_failedflag( true );
                                                    return ;
                                                }


                                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                                ex->set_decisionNum( 111 );
                                                ex->set_state( 6 );


                                                goto rulealter_collection_clausesEx;

                                            }
                                        }
                                    }
                                    else
                                    {
                                        if (this->get_backtracking()>0)
                                        {
                                            this->set_failedflag( true );
                                            return ;
                                        }


                                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                        ex->set_decisionNum( 111 );
                                        ex->set_state( 3 );


                                        goto rulealter_collection_clausesEx;

                                    }
                                }
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 111 );
                                ex->set_state( 1 );


                                goto rulealter_collection_clausesEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 111 );
                        ex->set_state( 0 );


                        goto rulealter_collection_clausesEx;

                    }
                }
                switch (alt111)
                {
            	case 1:
            	    // PLSQLParser.g:446:10: limit_key expression
            	    {
            	        this->followPush(FOLLOW_limit_key_in_alter_collection_clauses3566);
            	        limit_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_collection_clausesEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_alter_collection_clauses3568);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_collection_clausesEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:447:10: element_key type_key type_spec
            	    {
            	        this->followPush(FOLLOW_element_key_in_alter_collection_clauses3579);
            	        element_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_collection_clausesEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_type_key_in_alter_collection_clauses3581);
            	        type_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_collection_clausesEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_type_spec_in_alter_collection_clauses3583);
            	        type_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulealter_collection_clausesEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulealter_collection_clausesEx; /* Prevent compiler warnings */
    rulealter_collection_clausesEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end alter_collection_clauses */

/**
 * $ANTLR start dependent_handling_clause
 * PLSQLParser.g:451:1: dependent_handling_clause : ( invalidate_key | cascade_key ( convert_key to_key substitutable_key | ( not_key )? including_key table_key data_key )? ( dependent_exceptions_part )? );
 */
void
PLSQLParser::dependent_handling_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:452:5: ( invalidate_key | cascade_key ( convert_key to_key substitutable_key | ( not_key )? including_key table_key data_key )? ( dependent_exceptions_part )? )

            ANTLR_UINT32 alt115;

            alt115=2;

            {
                int LA115_0 = this->LA(1);
                if ( (LA115_0 == REGULAR_ID))
                {
                    {
                        int LA115_1 = this->LA(2);
                        if ( ((equalsIgnoreCase(LT(1)->getText(), "INVALIDATE"))))
                        {
                            alt115=1;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "CASCADE"))))
                        {
                            alt115=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 115 );
                            ex->set_state( 1 );


                            goto ruledependent_handling_clauseEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 115 );
                    ex->set_state( 0 );


                    goto ruledependent_handling_clauseEx;

                }
            }
            switch (alt115)
            {
        	case 1:
        	    // PLSQLParser.g:452:10: invalidate_key
        	    {
        	        this->followPush(FOLLOW_invalidate_key_in_dependent_handling_clause3609);
        	        invalidate_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledependent_handling_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:453:10: cascade_key ( convert_key to_key substitutable_key | ( not_key )? including_key table_key data_key )? ( dependent_exceptions_part )?
        	    {
        	        this->followPush(FOLLOW_cascade_key_in_dependent_handling_clause3620);
        	        cascade_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledependent_handling_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLParser.g:454:9: ( convert_key to_key substitutable_key | ( not_key )? including_key table_key data_key )?
        	        {
        	            int alt113=3;
        	            {
        	                int LA113_0 = this->LA(1);
        	                if ( (LA113_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA113_1 = this->LA(2);
        	                        if ( (LA113_1 == SQL92_RESERVED_TO))
        	                        {
        	                            alt113=1;
        	                        }
        	                        else if ( (LA113_1 == SQL92_RESERVED_TABLE) && ((equalsIgnoreCase(LT(1)->getText(), "INCLUDING"))))
        	                        {
        	                            alt113=2;
        	                        }
        	                    }
        	                }
        	                else if ( (LA113_0 == SQL92_RESERVED_NOT))
        	                {
        	                    alt113=2;
        	                }
        	            }
        	            switch (alt113)
        	            {
        	        	case 1:
        	        	    // PLSQLParser.g:454:14: convert_key to_key substitutable_key
        	        	    {
        	        	        this->followPush(FOLLOW_convert_key_in_dependent_handling_clause3635);
        	        	        convert_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledependent_handling_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_to_key_in_dependent_handling_clause3637);
        	        	        to_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledependent_handling_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_substitutable_key_in_dependent_handling_clause3639);
        	        	        substitutable_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledependent_handling_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQLParser.g:455:14: ( not_key )? including_key table_key data_key
        	        	    {
        	        	        // PLSQLParser.g:455:14: ( not_key )?
        	        	        {
        	        	            int alt112=2;
        	        	            {
        	        	                int LA112_0 = this->LA(1);
        	        	                if ( (LA112_0 == SQL92_RESERVED_NOT))
        	        	                {
        	        	                    alt112=1;
        	        	                }
        	        	            }
        	        	            switch (alt112)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQLParser.g:455:14: not_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_not_key_in_dependent_handling_clause3654);
        	        	        	        not_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruledependent_handling_clauseEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        this->followPush(FOLLOW_including_key_in_dependent_handling_clause3657);
        	        	        including_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledependent_handling_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_table_key_in_dependent_handling_clause3659);
        	        	        table_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledependent_handling_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_data_key_in_dependent_handling_clause3661);
        	        	        data_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledependent_handling_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQLParser.g:457:9: ( dependent_exceptions_part )?
        	        {
        	            int alt114=2;
        	            {
        	                int LA114_0 = this->LA(1);
        	                if ( (LA114_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FORCE")))||((equalsIgnoreCase(LT(1)->getText(), "EXCEPTIONS"))))))
        	                {
        	                    alt114=1;
        	                }
        	            }
        	            switch (alt114)
        	            {
        	        	case 1:
        	        	    // PLSQLParser.g:457:9: dependent_exceptions_part
        	        	    {
        	        	        this->followPush(FOLLOW_dependent_exceptions_part_in_dependent_handling_clause3682);
        	        	        dependent_exceptions_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledependent_handling_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruledependent_handling_clauseEx; /* Prevent compiler warnings */
    ruledependent_handling_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dependent_handling_clause */

/**
 * $ANTLR start dependent_exceptions_part
 * PLSQLParser.g:460:1: dependent_exceptions_part : ( force_key )? exceptions_key into_key tableview_name ;
 */
void
PLSQLParser::dependent_exceptions_part()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:461:5: ( ( force_key )? exceptions_key into_key tableview_name )
        // PLSQLParser.g:461:10: ( force_key )? exceptions_key into_key tableview_name
        {
            // PLSQLParser.g:461:10: ( force_key )?
            {
                int alt116=2;
                {
                    int LA116_0 = this->LA(1);
                    if ( (LA116_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FORCE")))||((equalsIgnoreCase(LT(1)->getText(), "EXCEPTIONS"))))))
                    {
                        {
                            int LA116_1 = this->LA(2);
                            if ( (LA116_1 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "FORCE"))))
                            {
                                alt116=1;
                            }
                        }
                    }
                }
                switch (alt116)
                {
            	case 1:
            	    // PLSQLParser.g:461:10: force_key
            	    {
            	        this->followPush(FOLLOW_force_key_in_dependent_exceptions_part3703);
            	        force_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledependent_exceptions_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_exceptions_key_in_dependent_exceptions_part3706);
            exceptions_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledependent_exceptions_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_into_key_in_dependent_exceptions_part3708);
            into_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledependent_exceptions_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_tableview_name_in_dependent_exceptions_part3710);
            tableview_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledependent_exceptions_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledependent_exceptions_partEx; /* Prevent compiler warnings */
    ruledependent_exceptions_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dependent_exceptions_part */

/**
 * $ANTLR start create_type
 * PLSQLParser.g:466:1: create_type : create_key ( or_key replace_key )? type_key ( type_definition | type_body ) SEMICOLON ;
 */
void
PLSQLParser::create_type()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:467:5: ( create_key ( or_key replace_key )? type_key ( type_definition | type_body ) SEMICOLON )
        // PLSQLParser.g:467:10: create_key ( or_key replace_key )? type_key ( type_definition | type_body ) SEMICOLON
        {
            this->followPush(FOLLOW_create_key_in_create_type3732);
            create_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecreate_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:467:21: ( or_key replace_key )?
            {
                int alt117=2;
                {
                    int LA117_0 = this->LA(1);
                    if ( (LA117_0 == SQL92_RESERVED_OR))
                    {
                        alt117=1;
                    }
                }
                switch (alt117)
                {
            	case 1:
            	    // PLSQLParser.g:467:22: or_key replace_key
            	    {
            	        this->followPush(FOLLOW_or_key_in_create_type3735);
            	        or_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_replace_key_in_create_type3737);
            	        replace_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_type_key_in_create_type3741);
            type_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecreate_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:468:9: ( type_definition | type_body )
            {
                int alt118=2;
                {
                    int LA118_0 = this->LA(1);
                    if ( (LA118_0 == REGULAR_ID))
                    {
                        switch ( this->LA(2) )
                        {
                        case PERIOD:
                        case SEMICOLON:
                        case SQL92_RESERVED_AS:
                        case SQL92_RESERVED_IS:
                        	{
                        		alt118=1;
                        	}
                            break;
                        case REGULAR_ID:
                        	{
                        		{
                        		    int LA118_3 = this->LA(3);
                        		    if ( (LA118_3 == CHAR_STRING || LA118_3 == DELIMITED_ID || LA118_3 == REGULAR_ID || LA118_3 == SQL92_RESERVED_DATE))
                        		    {
                        		        alt118=1;
                        		    }
                        		    else if ( (LA118_3 == PERIOD || LA118_3 == SQL92_RESERVED_AS || LA118_3 == SQL92_RESERVED_IS))
                        		    {
                        		        alt118=2;
                        		    }
                        		    else
                        		    {
                        		        if (this->get_backtracking()>0)
                        		        {
                        		            this->set_failedflag( true );
                        		            return ;
                        		        }


                        		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        		        ex->set_decisionNum( 118 );
                        		        ex->set_state( 3 );


                        		        goto rulecreate_typeEx;

                        		    }
                        		}
                        	}
                            break;
                        case DELIMITED_ID:
                        	{
                        		alt118=2;
                        	}
                            break;

                        default:
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }

                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 118 );
                            ex->set_state( 1 );


                            goto rulecreate_typeEx;

                        }

                    }
                    else if ( (LA118_0 == DELIMITED_ID))
                    {
                        alt118=1;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 118 );
                        ex->set_state( 0 );


                        goto rulecreate_typeEx;

                    }
                }
                switch (alt118)
                {
            	case 1:
            	    // PLSQLParser.g:468:11: type_definition
            	    {
            	        this->followPush(FOLLOW_type_definition_in_create_type3753);
            	        type_definition();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:468:29: type_body
            	    {
            	        this->followPush(FOLLOW_type_body_in_create_type3757);
            	        type_body();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_create_type3768);
            if  (this->hasException())
            {
                goto rulecreate_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecreate_typeEx; /* Prevent compiler warnings */
    rulecreate_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end create_type */

/**
 * $ANTLR start type_definition
 * PLSQLParser.g:473:1: type_definition : type_name ( oid_key CHAR_STRING )? ( object_type_def )? ;
 */
void
PLSQLParser::type_definition()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:474:5: ( type_name ( oid_key CHAR_STRING )? ( object_type_def )? )
        // PLSQLParser.g:474:10: type_name ( oid_key CHAR_STRING )? ( object_type_def )?
        {
            this->followPush(FOLLOW_type_name_in_type_definition3789);
            type_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletype_definitionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:475:9: ( oid_key CHAR_STRING )?
            {
                int alt119=2;
                {
                    int LA119_0 = this->LA(1);
                    if ( (LA119_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "AUTHID")))||((equalsIgnoreCase(LT(1)->getText(), "OID")))||((equalsIgnoreCase(LT(1)->getText(), "UNDER"))))))
                    {
                        {
                            int LA119_1 = this->LA(2);
                            if ( (LA119_1 == CHAR_STRING) && ((equalsIgnoreCase(LT(1)->getText(), "OID"))))
                            {
                                alt119=1;
                            }
                        }
                    }
                }
                switch (alt119)
                {
            	case 1:
            	    // PLSQLParser.g:475:10: oid_key CHAR_STRING
            	    {
            	        this->followPush(FOLLOW_oid_key_in_type_definition3801);
            	        oid_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_definitionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(CHAR_STRING, &FOLLOW_CHAR_STRING_in_type_definition3803);
            	        if  (this->hasException())
            	        {
            	            goto ruletype_definitionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:476:9: ( object_type_def )?
            {
                int alt120=2;
                {
                    int LA120_0 = this->LA(1);
                    if ( (LA120_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "AUTHID")))||((equalsIgnoreCase(LT(1)->getText(), "UNDER"))))))
                    {
                        alt120=1;
                    }
                    else if ( (LA120_0 == SQL92_RESERVED_AS || LA120_0 == SQL92_RESERVED_IS))
                    {
                        alt120=1;
                    }
                }
                switch (alt120)
                {
            	case 1:
            	    // PLSQLParser.g:476:9: object_type_def
            	    {
            	        this->followPush(FOLLOW_object_type_def_in_type_definition3815);
            	        object_type_def();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_definitionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruletype_definitionEx; /* Prevent compiler warnings */
    ruletype_definitionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end type_definition */

/**
 * $ANTLR start object_type_def
 * PLSQLParser.g:479:1: object_type_def : ( invoker_rights_clause )? ( object_as_part | object_under_part ) ( sqlj_object_type )? ( LEFT_PAREN object_member_spec ( COMMA object_member_spec )* RIGHT_PAREN )? ( modifier_clause )* ;
 */
void
PLSQLParser::object_type_def()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:480:5: ( ( invoker_rights_clause )? ( object_as_part | object_under_part ) ( sqlj_object_type )? ( LEFT_PAREN object_member_spec ( COMMA object_member_spec )* RIGHT_PAREN )? ( modifier_clause )* )
        // PLSQLParser.g:480:10: ( invoker_rights_clause )? ( object_as_part | object_under_part ) ( sqlj_object_type )? ( LEFT_PAREN object_member_spec ( COMMA object_member_spec )* RIGHT_PAREN )? ( modifier_clause )*
        {
            // PLSQLParser.g:480:10: ( invoker_rights_clause )?
            {
                int alt121=2;
                {
                    int LA121_0 = this->LA(1);
                    if ( (LA121_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "AUTHID")))||((equalsIgnoreCase(LT(1)->getText(), "UNDER"))))))
                    {
                        {
                            int LA121_1 = this->LA(2);
                            if ( (LA121_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "AUTHID")))||((equalsIgnoreCase(LT(1)->getText(), "UNDER"))))))
                            {
                                {
                                    int LA121_3 = this->LA(3);
                                    if ( (LA121_3 == SQL92_RESERVED_AS || LA121_3 == SQL92_RESERVED_IS) && ((equalsIgnoreCase(LT(1)->getText(), "AUTHID"))))
                                    {
                                        alt121=1;
                                    }
                                    else if ( (LA121_3 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "AUTHID")))||((equalsIgnoreCase(LT(1)->getText(), "UNDER"))))))
                                    {
                                        {
                                            int LA121_6 = this->LA(4);
                                            if ( (LA121_6 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "AUTHID")))||((equalsIgnoreCase(LT(1)->getText(), "UNDER"))))))
                                            {
                                                {
                                                    int LA121_7 = this->LA(5);
                                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "AUTHID"))))
                                                    {
                                                        alt121=1;
                                                    }
                                                }
                                            }
                                            else if ( (LA121_6 == DELIMITED_ID || LA121_6 == SQL92_RESERVED_DATE) && ((equalsIgnoreCase(LT(1)->getText(), "AUTHID"))))
                                            {
                                                alt121=1;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt121)
                {
            	case 1:
            	    // PLSQLParser.g:480:10: invoker_rights_clause
            	    {
            	        this->followPush(FOLLOW_invoker_rights_clause_in_object_type_def3836);
            	        invoker_rights_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleobject_type_defEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:481:5: ( object_as_part | object_under_part )
            {
                int alt122=2;
                {
                    int LA122_0 = this->LA(1);
                    if ( (LA122_0 == SQL92_RESERVED_AS || LA122_0 == SQL92_RESERVED_IS))
                    {
                        alt122=1;
                    }
                    else if ( (LA122_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "UNDER"))))
                    {
                        alt122=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 122 );
                        ex->set_state( 0 );


                        goto ruleobject_type_defEx;

                    }
                }
                switch (alt122)
                {
            	case 1:
            	    // PLSQLParser.g:481:10: object_as_part
            	    {
            	        this->followPush(FOLLOW_object_as_part_in_object_type_def3848);
            	        object_as_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleobject_type_defEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:482:10: object_under_part
            	    {
            	        this->followPush(FOLLOW_object_under_part_in_object_type_def3859);
            	        object_under_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleobject_type_defEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:484:9: ( sqlj_object_type )?
            {
                int alt123=2;
                {
                    int LA123_0 = this->LA(1);
                    if ( (LA123_0 == REGULAR_ID))
                    {
                        {
                            int LA123_1 = this->LA(2);
                            if ( (LA123_1 == REGULAR_ID))
                            {
                                switch ( this->LA(3) )
                                {
                                    case APPROXIMATE_NUM_LIT:
                                    case BINDVAR:
                                    case CHAR_STRING:
                                    case CHAR_STRING_PERL:
                                    case COLON:
                                    case DELIMITED_ID:
                                    case EXACT_NUM_LIT:
                                    case INTRODUCER:
                                    case LEFT_PAREN:
                                    case MINUS_SIGN:
                                    case NATIONAL_CHAR_STRING_LIT:
                                    case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                                    case PLUS_SIGN:
                                    case SQL92_RESERVED_ALL:
                                    case SQL92_RESERVED_ANY:
                                    case SQL92_RESERVED_CASE:
                                    case SQL92_RESERVED_CURSOR:
                                    case SQL92_RESERVED_DATE:
                                    case SQL92_RESERVED_DEFAULT:
                                    case SQL92_RESERVED_DISTINCT:
                                    case SQL92_RESERVED_EXISTS:
                                    case SQL92_RESERVED_FALSE:
                                    case SQL92_RESERVED_NULL:
                                    case SQL92_RESERVED_PRIOR:
                                    case SQL92_RESERVED_TRUE:
                                    case UNSIGNED_INTEGER:
                                    	{
                                    		alt123=1;
                                    	}
                                        break;
                                    case SQL92_RESERVED_NOT:
                                    	{
                                    		{
                                    		    int LA123_6 = this->LA(4);
                                    		    if ( (LA123_6 == APPROXIMATE_NUM_LIT || LA123_6 == BINDVAR || ((LA123_6 >= CHAR_STRING) && (LA123_6 <= COLON)) || LA123_6 == DELIMITED_ID || LA123_6 == EXACT_NUM_LIT || LA123_6 == INTRODUCER || LA123_6 == LEFT_PAREN || ((LA123_6 >= MINUS_SIGN) && (LA123_6 <= NATIONAL_CHAR_STRING_LIT)) || LA123_6 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA123_6 == PLUS_SIGN || LA123_6 == SQL92_RESERVED_ALL || LA123_6 == SQL92_RESERVED_ANY || LA123_6 == SQL92_RESERVED_CASE || LA123_6 == SQL92_RESERVED_DATE || LA123_6 == SQL92_RESERVED_DEFAULT || LA123_6 == SQL92_RESERVED_DISTINCT || ((LA123_6 >= SQL92_RESERVED_EXISTS) && (LA123_6 <= SQL92_RESERVED_FALSE)) || ((LA123_6 >= SQL92_RESERVED_NOT) && (LA123_6 <= SQL92_RESERVED_NULL)) || LA123_6 == SQL92_RESERVED_PRIOR || LA123_6 == SQL92_RESERVED_TRUE || LA123_6 == UNSIGNED_INTEGER))
                                    		    {
                                    		        alt123=1;
                                    		    }
                                    		    else if ( (LA123_6 == REGULAR_ID))
                                    		    {
                                    		        switch ( this->LA(5) )
                                    		        {
                                    		            case APPROXIMATE_NUM_LIT:
                                    		            case ASTERISK:
                                    		            case BINDVAR:
                                    		            case CARRET_OPERATOR_PART:
                                    		            case CHAR_STRING:
                                    		            case CHAR_STRING_PERL:
                                    		            case COLON:
                                    		            case CONCATENATION_OP:
                                    		            case DELIMITED_ID:
                                    		            case EQUALS_OP:
                                    		            case EXACT_NUM_LIT:
                                    		            case EXCLAMATION_OPERATOR_PART:
                                    		            case GREATER_THAN_OP:
                                    		            case GREATER_THAN_OR_EQUALS_OP:
                                    		            case INTRODUCER:
                                    		            case LEFT_BRACKET:
                                    		            case LEFT_PAREN:
                                    		            case LESS_THAN_OP:
                                    		            case LESS_THAN_OR_EQUALS_OP:
                                    		            case MINUS_SIGN:
                                    		            case NATIONAL_CHAR_STRING_LIT:
                                    		            case NOT_EQUAL_OP:
                                    		            case PERIOD:
                                    		            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                                    		            case PLUS_SIGN:
                                    		            case SOLIDUS:
                                    		            case SQL92_RESERVED_ALL:
                                    		            case SQL92_RESERVED_AND:
                                    		            case SQL92_RESERVED_ANY:
                                    		            case SQL92_RESERVED_BETWEEN:
                                    		            case SQL92_RESERVED_CASE:
                                    		            case SQL92_RESERVED_DATE:
                                    		            case SQL92_RESERVED_DEFAULT:
                                    		            case SQL92_RESERVED_DISTINCT:
                                    		            case SQL92_RESERVED_EXISTS:
                                    		            case SQL92_RESERVED_FALSE:
                                    		            case SQL92_RESERVED_IN:
                                    		            case SQL92_RESERVED_IS:
                                    		            case SQL92_RESERVED_LIKE:
                                    		            case SQL92_RESERVED_NULL:
                                    		            case SQL92_RESERVED_OR:
                                    		            case SQL92_RESERVED_PRIOR:
                                    		            case SQL92_RESERVED_TRUE:
                                    		            case UNSIGNED_INTEGER:
                                    		            case VERTICAL_BAR:
                                    		            	{
                                    		            		alt123=1;
                                    		            	}
                                    		                break;
                                    		            case REGULAR_ID:
                                    		            	{
                                    		            		switch ( this->LA(6) )
                                    		            		{
                                    		            		    case APPROXIMATE_NUM_LIT:
                                    		            		    case ASTERISK:
                                    		            		    case BINDVAR:
                                    		            		    case CARRET_OPERATOR_PART:
                                    		            		    case CHAR_STRING:
                                    		            		    case CHAR_STRING_PERL:
                                    		            		    case COLON:
                                    		            		    case CONCATENATION_OP:
                                    		            		    case DELIMITED_ID:
                                    		            		    case EQUALS_OP:
                                    		            		    case EXACT_NUM_LIT:
                                    		            		    case EXCLAMATION_OPERATOR_PART:
                                    		            		    case GREATER_THAN_OP:
                                    		            		    case GREATER_THAN_OR_EQUALS_OP:
                                    		            		    case INTRODUCER:
                                    		            		    case LEFT_BRACKET:
                                    		            		    case LEFT_PAREN:
                                    		            		    case LESS_THAN_OP:
                                    		            		    case LESS_THAN_OR_EQUALS_OP:
                                    		            		    case MINUS_SIGN:
                                    		            		    case NATIONAL_CHAR_STRING_LIT:
                                    		            		    case NOT_EQUAL_OP:
                                    		            		    case PERIOD:
                                    		            		    case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                                    		            		    case PLUS_SIGN:
                                    		            		    case SOLIDUS:
                                    		            		    case SQL92_RESERVED_ALL:
                                    		            		    case SQL92_RESERVED_AND:
                                    		            		    case SQL92_RESERVED_ANY:
                                    		            		    case SQL92_RESERVED_BETWEEN:
                                    		            		    case SQL92_RESERVED_CASE:
                                    		            		    case SQL92_RESERVED_DATE:
                                    		            		    case SQL92_RESERVED_DEFAULT:
                                    		            		    case SQL92_RESERVED_DISTINCT:
                                    		            		    case SQL92_RESERVED_EXISTS:
                                    		            		    case SQL92_RESERVED_FALSE:
                                    		            		    case SQL92_RESERVED_IN:
                                    		            		    case SQL92_RESERVED_INTERSECT:
                                    		            		    case SQL92_RESERVED_IS:
                                    		            		    case SQL92_RESERVED_LIKE:
                                    		            		    case SQL92_RESERVED_NULL:
                                    		            		    case SQL92_RESERVED_OF:
                                    		            		    case SQL92_RESERVED_OR:
                                    		            		    case SQL92_RESERVED_PRIOR:
                                    		            		    case SQL92_RESERVED_TO:
                                    		            		    case SQL92_RESERVED_TRUE:
                                    		            		    case SQL92_RESERVED_UNION:
                                    		            		    case UNSIGNED_INTEGER:
                                    		            		    case VERTICAL_BAR:
                                    		            		    	{
                                    		            		    		alt123=1;
                                    		            		    	}
                                    		            		        break;
                                    		            		    case REGULAR_ID:
                                    		            		    	{
                                    		            		    		switch ( this->LA(7) )
                                    		            		    		{
                                    		            		    		    case APPROXIMATE_NUM_LIT:
                                    		            		    		    case ASTERISK:
                                    		            		    		    case BINDVAR:
                                    		            		    		    case CARRET_OPERATOR_PART:
                                    		            		    		    case CHAR_STRING:
                                    		            		    		    case CHAR_STRING_PERL:
                                    		            		    		    case COLON:
                                    		            		    		    case CONCATENATION_OP:
                                    		            		    		    case DELIMITED_ID:
                                    		            		    		    case EQUALS_OP:
                                    		            		    		    case EXACT_NUM_LIT:
                                    		            		    		    case EXCLAMATION_OPERATOR_PART:
                                    		            		    		    case GREATER_THAN_OP:
                                    		            		    		    case GREATER_THAN_OR_EQUALS_OP:
                                    		            		    		    case INTRODUCER:
                                    		            		    		    case LEFT_BRACKET:
                                    		            		    		    case LEFT_PAREN:
                                    		            		    		    case LESS_THAN_OP:
                                    		            		    		    case LESS_THAN_OR_EQUALS_OP:
                                    		            		    		    case MINUS_SIGN:
                                    		            		    		    case NATIONAL_CHAR_STRING_LIT:
                                    		            		    		    case NOT_EQUAL_OP:
                                    		            		    		    case PERIOD:
                                    		            		    		    case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                                    		            		    		    case PLSQL_NON_RESERVED_USING:
                                    		            		    		    case PLUS_SIGN:
                                    		            		    		    case SOLIDUS:
                                    		            		    		    case SQL92_RESERVED_ALL:
                                    		            		    		    case SQL92_RESERVED_AND:
                                    		            		    		    case SQL92_RESERVED_ANY:
                                    		            		    		    case SQL92_RESERVED_BETWEEN:
                                    		            		    		    case SQL92_RESERVED_CASE:
                                    		            		    		    case SQL92_RESERVED_DATE:
                                    		            		    		    case SQL92_RESERVED_DEFAULT:
                                    		            		    		    case SQL92_RESERVED_DISTINCT:
                                    		            		    		    case SQL92_RESERVED_EXISTS:
                                    		            		    		    case SQL92_RESERVED_FALSE:
                                    		            		    		    case SQL92_RESERVED_IN:
                                    		            		    		    case SQL92_RESERVED_INTERSECT:
                                    		            		    		    case SQL92_RESERVED_IS:
                                    		            		    		    case SQL92_RESERVED_LIKE:
                                    		            		    		    case SQL92_RESERVED_NULL:
                                    		            		    		    case SQL92_RESERVED_OF:
                                    		            		    		    case SQL92_RESERVED_OR:
                                    		            		    		    case SQL92_RESERVED_PRIOR:
                                    		            		    		    case SQL92_RESERVED_TO:
                                    		            		    		    case SQL92_RESERVED_TRUE:
                                    		            		    		    case SQL92_RESERVED_UNION:
                                    		            		    		    case UNSIGNED_INTEGER:
                                    		            		    		    case VERTICAL_BAR:
                                    		            		    		    	{
                                    		            		    		    		alt123=1;
                                    		            		    		    	}
                                    		            		    		        break;
                                    		            		    		    case REGULAR_ID:
                                    		            		    		    	{
                                    		            		    		    		switch ( this->LA(8) )
                                    		            		    		    		{
                                    		            		    		    		    case APPROXIMATE_NUM_LIT:
                                    		            		    		    		    case ASTERISK:
                                    		            		    		    		    case BINDVAR:
                                    		            		    		    		    case CARRET_OPERATOR_PART:
                                    		            		    		    		    case CHAR_STRING:
                                    		            		    		    		    case CHAR_STRING_PERL:
                                    		            		    		    		    case COLON:
                                    		            		    		    		    case CONCATENATION_OP:
                                    		            		    		    		    case DELIMITED_ID:
                                    		            		    		    		    case EQUALS_OP:
                                    		            		    		    		    case EXACT_NUM_LIT:
                                    		            		    		    		    case EXCLAMATION_OPERATOR_PART:
                                    		            		    		    		    case GREATER_THAN_OP:
                                    		            		    		    		    case GREATER_THAN_OR_EQUALS_OP:
                                    		            		    		    		    case INTRODUCER:
                                    		            		    		    		    case LEFT_BRACKET:
                                    		            		    		    		    case LEFT_PAREN:
                                    		            		    		    		    case LESS_THAN_OP:
                                    		            		    		    		    case LESS_THAN_OR_EQUALS_OP:
                                    		            		    		    		    case MINUS_SIGN:
                                    		            		    		    		    case NATIONAL_CHAR_STRING_LIT:
                                    		            		    		    		    case NOT_EQUAL_OP:
                                    		            		    		    		    case PERIOD:
                                    		            		    		    		    case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                                    		            		    		    		    case PLSQL_NON_RESERVED_USING:
                                    		            		    		    		    case PLUS_SIGN:
                                    		            		    		    		    case SOLIDUS:
                                    		            		    		    		    case SQL92_RESERVED_ALL:
                                    		            		    		    		    case SQL92_RESERVED_AND:
                                    		            		    		    		    case SQL92_RESERVED_ANY:
                                    		            		    		    		    case SQL92_RESERVED_BETWEEN:
                                    		            		    		    		    case SQL92_RESERVED_CASE:
                                    		            		    		    		    case SQL92_RESERVED_DATE:
                                    		            		    		    		    case SQL92_RESERVED_DEFAULT:
                                    		            		    		    		    case SQL92_RESERVED_DISTINCT:
                                    		            		    		    		    case SQL92_RESERVED_EXISTS:
                                    		            		    		    		    case SQL92_RESERVED_FALSE:
                                    		            		    		    		    case SQL92_RESERVED_IN:
                                    		            		    		    		    case SQL92_RESERVED_INTERSECT:
                                    		            		    		    		    case SQL92_RESERVED_IS:
                                    		            		    		    		    case SQL92_RESERVED_LIKE:
                                    		            		    		    		    case SQL92_RESERVED_NULL:
                                    		            		    		    		    case SQL92_RESERVED_OF:
                                    		            		    		    		    case SQL92_RESERVED_OR:
                                    		            		    		    		    case SQL92_RESERVED_PRIOR:
                                    		            		    		    		    case SQL92_RESERVED_TO:
                                    		            		    		    		    case SQL92_RESERVED_TRUE:
                                    		            		    		    		    case SQL92_RESERVED_UNION:
                                    		            		    		    		    case UNSIGNED_INTEGER:
                                    		            		    		    		    case VERTICAL_BAR:
                                    		            		    		    		    	{
                                    		            		    		    		    		alt123=1;
                                    		            		    		    		    	}
                                    		            		    		    		        break;
                                    		            		    		    		    case REGULAR_ID:
                                    		            		    		    		    	{
                                    		            		    		    		    		{
                                    		            		    		    		    		    int LA123_23 = this->LA(9);
                                    		            		    		    		    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "EXTERNAL"))))
                                    		            		    		    		    		    {
                                    		            		    		    		    		        alt123=1;
                                    		            		    		    		    		    }
                                    		            		    		    		    		}
                                    		            		    		    		    	}
                                    		            		    		    		        break;
                                    		            		    		    		    case SQL92_RESERVED_NOT:
                                    		            		    		    		    	{
                                    		            		    		    		    		{
                                    		            		    		    		    		    int LA123_12 = this->LA(9);
                                    		            		    		    		    		    if ( (LA123_12 == SQL92_RESERVED_BETWEEN || LA123_12 == SQL92_RESERVED_IN || LA123_12 == SQL92_RESERVED_LIKE))
                                    		            		    		    		    		    {
                                    		            		    		    		    		        alt123=1;
                                    		            		    		    		    		    }
                                    		            		    		    		    		    else if ( (LA123_12 == REGULAR_ID))
                                    		            		    		    		    		    {
                                    		            		    		    		    		        {
                                    		            		    		    		    		            int LA123_16 = this->LA(10);
                                    		            		    		    		    		            if ( (LA123_16 == APPROXIMATE_NUM_LIT || LA123_16 == BINDVAR || ((LA123_16 >= CHAR_STRING) && (LA123_16 <= COLON)) || LA123_16 == DELIMITED_ID || LA123_16 == EXACT_NUM_LIT || LA123_16 == INTRODUCER || LA123_16 == LEFT_PAREN || ((LA123_16 >= MINUS_SIGN) && (LA123_16 <= NATIONAL_CHAR_STRING_LIT)) || LA123_16 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA123_16 == PLUS_SIGN || LA123_16 == SQL92_RESERVED_ALL || LA123_16 == SQL92_RESERVED_ANY || LA123_16 == SQL92_RESERVED_CASE || LA123_16 == SQL92_RESERVED_DATE || LA123_16 == SQL92_RESERVED_DEFAULT || LA123_16 == SQL92_RESERVED_DISTINCT || ((LA123_16 >= SQL92_RESERVED_EXISTS) && (LA123_16 <= SQL92_RESERVED_FALSE)) || LA123_16 == SQL92_RESERVED_NULL || LA123_16 == SQL92_RESERVED_PRIOR || LA123_16 == SQL92_RESERVED_TRUE || LA123_16 == UNSIGNED_INTEGER))
                                    		            		    		    		    		            {
                                    		            		    		    		    		                alt123=1;
                                    		            		    		    		    		            }
                                    		            		    		    		    		            else if ( (LA123_16 == REGULAR_ID))
                                    		            		    		    		    		            {
                                    		            		    		    		    		                {
                                    		            		    		    		    		                    int LA123_20 = this->LA(11);
                                    		            		    		    		    		                    if ( (LA123_20 == APPROXIMATE_NUM_LIT || LA123_20 == ASTERISK || LA123_20 == BINDVAR || ((LA123_20 >= CARRET_OPERATOR_PART) && (LA123_20 <= COLON)) || ((LA123_20 >= CONCATENATION_OP) && (LA123_20 <= DELIMITED_ID)) || ((LA123_20 >= EQUALS_OP) && (LA123_20 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_20 >= GREATER_THAN_OP) && (LA123_20 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_20 >= INTRODUCER) && (LA123_20 <= NATIONAL_CHAR_STRING_LIT)) || LA123_20 == NOT_EQUAL_OP || ((LA123_20 >= PERIOD) && (LA123_20 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_20 == PLUS_SIGN || LA123_20 == SOLIDUS || LA123_20 == SQL92_RESERVED_ALL || ((LA123_20 >= SQL92_RESERVED_AND) && (LA123_20 <= SQL92_RESERVED_ANY)) || LA123_20 == SQL92_RESERVED_CASE || LA123_20 == SQL92_RESERVED_DATE || LA123_20 == SQL92_RESERVED_DEFAULT || LA123_20 == SQL92_RESERVED_DISTINCT || ((LA123_20 >= SQL92_RESERVED_EXISTS) && (LA123_20 <= SQL92_RESERVED_FALSE)) || LA123_20 == SQL92_RESERVED_IS || LA123_20 == SQL92_RESERVED_NULL || LA123_20 == SQL92_RESERVED_OR || LA123_20 == SQL92_RESERVED_PRIOR || LA123_20 == SQL92_RESERVED_TRUE || ((LA123_20 >= UNSIGNED_INTEGER) && (LA123_20 <= VERTICAL_BAR))))
                                    		            		    		    		    		                    {
                                    		            		    		    		    		                        alt123=1;
                                    		            		    		    		    		                    }
                                    		            		    		    		    		                    else if ( (LA123_20 == REGULAR_ID))
                                    		            		    		    		    		                    {
                                    		            		    		    		    		                        {
                                    		            		    		    		    		                            int LA123_24 = this->LA(12);
                                    		            		    		    		    		                            if ( (LA123_24 == APPROXIMATE_NUM_LIT || LA123_24 == ASTERISK || LA123_24 == BINDVAR || ((LA123_24 >= CARRET_OPERATOR_PART) && (LA123_24 <= COLON)) || ((LA123_24 >= CONCATENATION_OP) && (LA123_24 <= DELIMITED_ID)) || ((LA123_24 >= EQUALS_OP) && (LA123_24 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_24 >= GREATER_THAN_OP) && (LA123_24 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_24 >= INTRODUCER) && (LA123_24 <= NATIONAL_CHAR_STRING_LIT)) || LA123_24 == NOT_EQUAL_OP || ((LA123_24 >= PERIOD) && (LA123_24 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_24 == PLUS_SIGN || LA123_24 == SOLIDUS || LA123_24 == SQL92_RESERVED_ALL || ((LA123_24 >= SQL92_RESERVED_AND) && (LA123_24 <= SQL92_RESERVED_ANY)) || LA123_24 == SQL92_RESERVED_CASE || LA123_24 == SQL92_RESERVED_DATE || LA123_24 == SQL92_RESERVED_DEFAULT || LA123_24 == SQL92_RESERVED_DISTINCT || ((LA123_24 >= SQL92_RESERVED_EXISTS) && (LA123_24 <= SQL92_RESERVED_FALSE)) || LA123_24 == SQL92_RESERVED_INTERSECT || LA123_24 == SQL92_RESERVED_IS || ((LA123_24 >= SQL92_RESERVED_NULL) && (LA123_24 <= SQL92_RESERVED_OF)) || LA123_24 == SQL92_RESERVED_OR || LA123_24 == SQL92_RESERVED_PRIOR || ((LA123_24 >= SQL92_RESERVED_TO) && (LA123_24 <= SQL92_RESERVED_UNION)) || ((LA123_24 >= UNSIGNED_INTEGER) && (LA123_24 <= VERTICAL_BAR))))
                                    		            		    		    		    		                            {
                                    		            		    		    		    		                                alt123=1;
                                    		            		    		    		    		                            }
                                    		            		    		    		    		                            else if ( (LA123_24 == REGULAR_ID))
                                    		            		    		    		    		                            {
                                    		            		    		    		    		                                {
                                    		            		    		    		    		                                    int LA123_26 = this->LA(13);
                                    		            		    		    		    		                                    if ( (LA123_26 == APPROXIMATE_NUM_LIT || LA123_26 == ASTERISK || LA123_26 == BINDVAR || ((LA123_26 >= CARRET_OPERATOR_PART) && (LA123_26 <= COLON)) || ((LA123_26 >= CONCATENATION_OP) && (LA123_26 <= DELIMITED_ID)) || ((LA123_26 >= EQUALS_OP) && (LA123_26 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_26 >= GREATER_THAN_OP) && (LA123_26 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_26 >= INTRODUCER) && (LA123_26 <= NATIONAL_CHAR_STRING_LIT)) || LA123_26 == NOT_EQUAL_OP || ((LA123_26 >= PERIOD) && (LA123_26 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_26 == PLSQL_NON_RESERVED_USING || LA123_26 == PLUS_SIGN || LA123_26 == SOLIDUS || LA123_26 == SQL92_RESERVED_ALL || ((LA123_26 >= SQL92_RESERVED_AND) && (LA123_26 <= SQL92_RESERVED_ANY)) || LA123_26 == SQL92_RESERVED_CASE || LA123_26 == SQL92_RESERVED_DATE || LA123_26 == SQL92_RESERVED_DEFAULT || LA123_26 == SQL92_RESERVED_DISTINCT || ((LA123_26 >= SQL92_RESERVED_EXISTS) && (LA123_26 <= SQL92_RESERVED_FALSE)) || LA123_26 == SQL92_RESERVED_INTERSECT || LA123_26 == SQL92_RESERVED_IS || ((LA123_26 >= SQL92_RESERVED_NULL) && (LA123_26 <= SQL92_RESERVED_OF)) || LA123_26 == SQL92_RESERVED_OR || LA123_26 == SQL92_RESERVED_PRIOR || ((LA123_26 >= SQL92_RESERVED_TO) && (LA123_26 <= SQL92_RESERVED_UNION)) || ((LA123_26 >= UNSIGNED_INTEGER) && (LA123_26 <= VERTICAL_BAR))))
                                    		            		    		    		    		                                    {
                                    		            		    		    		    		                                        alt123=1;
                                    		            		    		    		    		                                    }
                                    		            		    		    		    		                                    else if ( (LA123_26 == REGULAR_ID))
                                    		            		    		    		    		                                    {
                                    		            		    		    		    		                                        {
                                    		            		    		    		    		                                            int LA123_28 = this->LA(14);
                                    		            		    		    		    		                                            if ( (LA123_28 == APPROXIMATE_NUM_LIT || LA123_28 == ASTERISK || LA123_28 == BINDVAR || ((LA123_28 >= CARRET_OPERATOR_PART) && (LA123_28 <= COLON)) || ((LA123_28 >= CONCATENATION_OP) && (LA123_28 <= DELIMITED_ID)) || ((LA123_28 >= EQUALS_OP) && (LA123_28 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_28 >= GREATER_THAN_OP) && (LA123_28 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_28 >= INTRODUCER) && (LA123_28 <= NATIONAL_CHAR_STRING_LIT)) || LA123_28 == NOT_EQUAL_OP || ((LA123_28 >= PERIOD) && (LA123_28 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_28 == PLSQL_NON_RESERVED_USING || LA123_28 == PLUS_SIGN || LA123_28 == SOLIDUS || LA123_28 == SQL92_RESERVED_ALL || ((LA123_28 >= SQL92_RESERVED_AND) && (LA123_28 <= SQL92_RESERVED_ANY)) || LA123_28 == SQL92_RESERVED_CASE || LA123_28 == SQL92_RESERVED_DATE || LA123_28 == SQL92_RESERVED_DEFAULT || LA123_28 == SQL92_RESERVED_DISTINCT || ((LA123_28 >= SQL92_RESERVED_EXISTS) && (LA123_28 <= SQL92_RESERVED_FALSE)) || LA123_28 == SQL92_RESERVED_INTERSECT || LA123_28 == SQL92_RESERVED_IS || ((LA123_28 >= SQL92_RESERVED_NULL) && (LA123_28 <= SQL92_RESERVED_OF)) || LA123_28 == SQL92_RESERVED_OR || LA123_28 == SQL92_RESERVED_PRIOR || ((LA123_28 >= SQL92_RESERVED_TO) && (LA123_28 <= SQL92_RESERVED_UNION)) || ((LA123_28 >= UNSIGNED_INTEGER) && (LA123_28 <= VERTICAL_BAR))))
                                    		            		    		    		    		                                            {
                                    		            		    		    		    		                                                alt123=1;
                                    		            		    		    		    		                                            }
                                    		            		    		    		    		                                            else if ( (LA123_28 == REGULAR_ID))
                                    		            		    		    		    		                                            {
                                    		            		    		    		    		                                                {
                                    		            		    		    		    		                                                    int LA123_30 = this->LA(15);
                                    		            		    		    		    		                                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "EXTERNAL"))))
                                    		            		    		    		    		                                                    {
                                    		            		    		    		    		                                                        alt123=1;
                                    		            		    		    		    		                                                    }
                                    		            		    		    		    		                                                }
                                    		            		    		    		    		                                            }
                                    		            		    		    		    		                                        }
                                    		            		    		    		    		                                    }
                                    		            		    		    		    		                                }
                                    		            		    		    		    		                            }
                                    		            		    		    		    		                        }
                                    		            		    		    		    		                    }
                                    		            		    		    		    		                }
                                    		            		    		    		    		            }
                                    		            		    		    		    		        }
                                    		            		    		    		    		    }
                                    		            		    		    		    		}
                                    		            		    		    		    	}
                                    		            		    		    		        break;
                                    		            		    		    		}

                                    		            		    		    	}
                                    		            		    		        break;
                                    		            		    		    case SQL92_RESERVED_NOT:
                                    		            		    		    	{
                                    		            		    		    		{
                                    		            		    		    		    int LA123_12 = this->LA(8);
                                    		            		    		    		    if ( (LA123_12 == SQL92_RESERVED_BETWEEN || LA123_12 == SQL92_RESERVED_IN || LA123_12 == SQL92_RESERVED_LIKE))
                                    		            		    		    		    {
                                    		            		    		    		        alt123=1;
                                    		            		    		    		    }
                                    		            		    		    		    else if ( (LA123_12 == REGULAR_ID))
                                    		            		    		    		    {
                                    		            		    		    		        {
                                    		            		    		    		            int LA123_16 = this->LA(9);
                                    		            		    		    		            if ( (LA123_16 == APPROXIMATE_NUM_LIT || LA123_16 == BINDVAR || ((LA123_16 >= CHAR_STRING) && (LA123_16 <= COLON)) || LA123_16 == DELIMITED_ID || LA123_16 == EXACT_NUM_LIT || LA123_16 == INTRODUCER || LA123_16 == LEFT_PAREN || ((LA123_16 >= MINUS_SIGN) && (LA123_16 <= NATIONAL_CHAR_STRING_LIT)) || LA123_16 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA123_16 == PLUS_SIGN || LA123_16 == SQL92_RESERVED_ALL || LA123_16 == SQL92_RESERVED_ANY || LA123_16 == SQL92_RESERVED_CASE || LA123_16 == SQL92_RESERVED_DATE || LA123_16 == SQL92_RESERVED_DEFAULT || LA123_16 == SQL92_RESERVED_DISTINCT || ((LA123_16 >= SQL92_RESERVED_EXISTS) && (LA123_16 <= SQL92_RESERVED_FALSE)) || LA123_16 == SQL92_RESERVED_NULL || LA123_16 == SQL92_RESERVED_PRIOR || LA123_16 == SQL92_RESERVED_TRUE || LA123_16 == UNSIGNED_INTEGER))
                                    		            		    		    		            {
                                    		            		    		    		                alt123=1;
                                    		            		    		    		            }
                                    		            		    		    		            else if ( (LA123_16 == REGULAR_ID))
                                    		            		    		    		            {
                                    		            		    		    		                {
                                    		            		    		    		                    int LA123_20 = this->LA(10);
                                    		            		    		    		                    if ( (LA123_20 == APPROXIMATE_NUM_LIT || LA123_20 == ASTERISK || LA123_20 == BINDVAR || ((LA123_20 >= CARRET_OPERATOR_PART) && (LA123_20 <= COLON)) || ((LA123_20 >= CONCATENATION_OP) && (LA123_20 <= DELIMITED_ID)) || ((LA123_20 >= EQUALS_OP) && (LA123_20 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_20 >= GREATER_THAN_OP) && (LA123_20 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_20 >= INTRODUCER) && (LA123_20 <= NATIONAL_CHAR_STRING_LIT)) || LA123_20 == NOT_EQUAL_OP || ((LA123_20 >= PERIOD) && (LA123_20 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_20 == PLUS_SIGN || LA123_20 == SOLIDUS || LA123_20 == SQL92_RESERVED_ALL || ((LA123_20 >= SQL92_RESERVED_AND) && (LA123_20 <= SQL92_RESERVED_ANY)) || LA123_20 == SQL92_RESERVED_CASE || LA123_20 == SQL92_RESERVED_DATE || LA123_20 == SQL92_RESERVED_DEFAULT || LA123_20 == SQL92_RESERVED_DISTINCT || ((LA123_20 >= SQL92_RESERVED_EXISTS) && (LA123_20 <= SQL92_RESERVED_FALSE)) || LA123_20 == SQL92_RESERVED_IS || LA123_20 == SQL92_RESERVED_NULL || LA123_20 == SQL92_RESERVED_OR || LA123_20 == SQL92_RESERVED_PRIOR || LA123_20 == SQL92_RESERVED_TRUE || ((LA123_20 >= UNSIGNED_INTEGER) && (LA123_20 <= VERTICAL_BAR))))
                                    		            		    		    		                    {
                                    		            		    		    		                        alt123=1;
                                    		            		    		    		                    }
                                    		            		    		    		                    else if ( (LA123_20 == REGULAR_ID))
                                    		            		    		    		                    {
                                    		            		    		    		                        {
                                    		            		    		    		                            int LA123_24 = this->LA(11);
                                    		            		    		    		                            if ( (LA123_24 == APPROXIMATE_NUM_LIT || LA123_24 == ASTERISK || LA123_24 == BINDVAR || ((LA123_24 >= CARRET_OPERATOR_PART) && (LA123_24 <= COLON)) || ((LA123_24 >= CONCATENATION_OP) && (LA123_24 <= DELIMITED_ID)) || ((LA123_24 >= EQUALS_OP) && (LA123_24 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_24 >= GREATER_THAN_OP) && (LA123_24 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_24 >= INTRODUCER) && (LA123_24 <= NATIONAL_CHAR_STRING_LIT)) || LA123_24 == NOT_EQUAL_OP || ((LA123_24 >= PERIOD) && (LA123_24 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_24 == PLUS_SIGN || LA123_24 == SOLIDUS || LA123_24 == SQL92_RESERVED_ALL || ((LA123_24 >= SQL92_RESERVED_AND) && (LA123_24 <= SQL92_RESERVED_ANY)) || LA123_24 == SQL92_RESERVED_CASE || LA123_24 == SQL92_RESERVED_DATE || LA123_24 == SQL92_RESERVED_DEFAULT || LA123_24 == SQL92_RESERVED_DISTINCT || ((LA123_24 >= SQL92_RESERVED_EXISTS) && (LA123_24 <= SQL92_RESERVED_FALSE)) || LA123_24 == SQL92_RESERVED_INTERSECT || LA123_24 == SQL92_RESERVED_IS || ((LA123_24 >= SQL92_RESERVED_NULL) && (LA123_24 <= SQL92_RESERVED_OF)) || LA123_24 == SQL92_RESERVED_OR || LA123_24 == SQL92_RESERVED_PRIOR || ((LA123_24 >= SQL92_RESERVED_TO) && (LA123_24 <= SQL92_RESERVED_UNION)) || ((LA123_24 >= UNSIGNED_INTEGER) && (LA123_24 <= VERTICAL_BAR))))
                                    		            		    		    		                            {
                                    		            		    		    		                                alt123=1;
                                    		            		    		    		                            }
                                    		            		    		    		                            else if ( (LA123_24 == REGULAR_ID))
                                    		            		    		    		                            {
                                    		            		    		    		                                {
                                    		            		    		    		                                    int LA123_26 = this->LA(12);
                                    		            		    		    		                                    if ( (LA123_26 == APPROXIMATE_NUM_LIT || LA123_26 == ASTERISK || LA123_26 == BINDVAR || ((LA123_26 >= CARRET_OPERATOR_PART) && (LA123_26 <= COLON)) || ((LA123_26 >= CONCATENATION_OP) && (LA123_26 <= DELIMITED_ID)) || ((LA123_26 >= EQUALS_OP) && (LA123_26 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_26 >= GREATER_THAN_OP) && (LA123_26 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_26 >= INTRODUCER) && (LA123_26 <= NATIONAL_CHAR_STRING_LIT)) || LA123_26 == NOT_EQUAL_OP || ((LA123_26 >= PERIOD) && (LA123_26 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_26 == PLSQL_NON_RESERVED_USING || LA123_26 == PLUS_SIGN || LA123_26 == SOLIDUS || LA123_26 == SQL92_RESERVED_ALL || ((LA123_26 >= SQL92_RESERVED_AND) && (LA123_26 <= SQL92_RESERVED_ANY)) || LA123_26 == SQL92_RESERVED_CASE || LA123_26 == SQL92_RESERVED_DATE || LA123_26 == SQL92_RESERVED_DEFAULT || LA123_26 == SQL92_RESERVED_DISTINCT || ((LA123_26 >= SQL92_RESERVED_EXISTS) && (LA123_26 <= SQL92_RESERVED_FALSE)) || LA123_26 == SQL92_RESERVED_INTERSECT || LA123_26 == SQL92_RESERVED_IS || ((LA123_26 >= SQL92_RESERVED_NULL) && (LA123_26 <= SQL92_RESERVED_OF)) || LA123_26 == SQL92_RESERVED_OR || LA123_26 == SQL92_RESERVED_PRIOR || ((LA123_26 >= SQL92_RESERVED_TO) && (LA123_26 <= SQL92_RESERVED_UNION)) || ((LA123_26 >= UNSIGNED_INTEGER) && (LA123_26 <= VERTICAL_BAR))))
                                    		            		    		    		                                    {
                                    		            		    		    		                                        alt123=1;
                                    		            		    		    		                                    }
                                    		            		    		    		                                    else if ( (LA123_26 == REGULAR_ID))
                                    		            		    		    		                                    {
                                    		            		    		    		                                        {
                                    		            		    		    		                                            int LA123_28 = this->LA(13);
                                    		            		    		    		                                            if ( (LA123_28 == APPROXIMATE_NUM_LIT || LA123_28 == ASTERISK || LA123_28 == BINDVAR || ((LA123_28 >= CARRET_OPERATOR_PART) && (LA123_28 <= COLON)) || ((LA123_28 >= CONCATENATION_OP) && (LA123_28 <= DELIMITED_ID)) || ((LA123_28 >= EQUALS_OP) && (LA123_28 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_28 >= GREATER_THAN_OP) && (LA123_28 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_28 >= INTRODUCER) && (LA123_28 <= NATIONAL_CHAR_STRING_LIT)) || LA123_28 == NOT_EQUAL_OP || ((LA123_28 >= PERIOD) && (LA123_28 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_28 == PLSQL_NON_RESERVED_USING || LA123_28 == PLUS_SIGN || LA123_28 == SOLIDUS || LA123_28 == SQL92_RESERVED_ALL || ((LA123_28 >= SQL92_RESERVED_AND) && (LA123_28 <= SQL92_RESERVED_ANY)) || LA123_28 == SQL92_RESERVED_CASE || LA123_28 == SQL92_RESERVED_DATE || LA123_28 == SQL92_RESERVED_DEFAULT || LA123_28 == SQL92_RESERVED_DISTINCT || ((LA123_28 >= SQL92_RESERVED_EXISTS) && (LA123_28 <= SQL92_RESERVED_FALSE)) || LA123_28 == SQL92_RESERVED_INTERSECT || LA123_28 == SQL92_RESERVED_IS || ((LA123_28 >= SQL92_RESERVED_NULL) && (LA123_28 <= SQL92_RESERVED_OF)) || LA123_28 == SQL92_RESERVED_OR || LA123_28 == SQL92_RESERVED_PRIOR || ((LA123_28 >= SQL92_RESERVED_TO) && (LA123_28 <= SQL92_RESERVED_UNION)) || ((LA123_28 >= UNSIGNED_INTEGER) && (LA123_28 <= VERTICAL_BAR))))
                                    		            		    		    		                                            {
                                    		            		    		    		                                                alt123=1;
                                    		            		    		    		                                            }
                                    		            		    		    		                                            else if ( (LA123_28 == REGULAR_ID))
                                    		            		    		    		                                            {
                                    		            		    		    		                                                {
                                    		            		    		    		                                                    int LA123_30 = this->LA(14);
                                    		            		    		    		                                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "EXTERNAL"))))
                                    		            		    		    		                                                    {
                                    		            		    		    		                                                        alt123=1;
                                    		            		    		    		                                                    }
                                    		            		    		    		                                                }
                                    		            		    		    		                                            }
                                    		            		    		    		                                        }
                                    		            		    		    		                                    }
                                    		            		    		    		                                }
                                    		            		    		    		                            }
                                    		            		    		    		                        }
                                    		            		    		    		                    }
                                    		            		    		    		                }
                                    		            		    		    		            }
                                    		            		    		    		        }
                                    		            		    		    		    }
                                    		            		    		    		}
                                    		            		    		    	}
                                    		            		    		        break;
                                    		            		    		}

                                    		            		    	}
                                    		            		        break;
                                    		            		    case SQL92_RESERVED_NOT:
                                    		            		    	{
                                    		            		    		{
                                    		            		    		    int LA123_12 = this->LA(7);
                                    		            		    		    if ( (LA123_12 == SQL92_RESERVED_BETWEEN || LA123_12 == SQL92_RESERVED_IN || LA123_12 == SQL92_RESERVED_LIKE))
                                    		            		    		    {
                                    		            		    		        alt123=1;
                                    		            		    		    }
                                    		            		    		    else if ( (LA123_12 == REGULAR_ID))
                                    		            		    		    {
                                    		            		    		        {
                                    		            		    		            int LA123_16 = this->LA(8);
                                    		            		    		            if ( (LA123_16 == APPROXIMATE_NUM_LIT || LA123_16 == BINDVAR || ((LA123_16 >= CHAR_STRING) && (LA123_16 <= COLON)) || LA123_16 == DELIMITED_ID || LA123_16 == EXACT_NUM_LIT || LA123_16 == INTRODUCER || LA123_16 == LEFT_PAREN || ((LA123_16 >= MINUS_SIGN) && (LA123_16 <= NATIONAL_CHAR_STRING_LIT)) || LA123_16 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA123_16 == PLUS_SIGN || LA123_16 == SQL92_RESERVED_ALL || LA123_16 == SQL92_RESERVED_ANY || LA123_16 == SQL92_RESERVED_CASE || LA123_16 == SQL92_RESERVED_DATE || LA123_16 == SQL92_RESERVED_DEFAULT || LA123_16 == SQL92_RESERVED_DISTINCT || ((LA123_16 >= SQL92_RESERVED_EXISTS) && (LA123_16 <= SQL92_RESERVED_FALSE)) || LA123_16 == SQL92_RESERVED_NULL || LA123_16 == SQL92_RESERVED_PRIOR || LA123_16 == SQL92_RESERVED_TRUE || LA123_16 == UNSIGNED_INTEGER))
                                    		            		    		            {
                                    		            		    		                alt123=1;
                                    		            		    		            }
                                    		            		    		            else if ( (LA123_16 == REGULAR_ID))
                                    		            		    		            {
                                    		            		    		                {
                                    		            		    		                    int LA123_20 = this->LA(9);
                                    		            		    		                    if ( (LA123_20 == APPROXIMATE_NUM_LIT || LA123_20 == ASTERISK || LA123_20 == BINDVAR || ((LA123_20 >= CARRET_OPERATOR_PART) && (LA123_20 <= COLON)) || ((LA123_20 >= CONCATENATION_OP) && (LA123_20 <= DELIMITED_ID)) || ((LA123_20 >= EQUALS_OP) && (LA123_20 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_20 >= GREATER_THAN_OP) && (LA123_20 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_20 >= INTRODUCER) && (LA123_20 <= NATIONAL_CHAR_STRING_LIT)) || LA123_20 == NOT_EQUAL_OP || ((LA123_20 >= PERIOD) && (LA123_20 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_20 == PLUS_SIGN || LA123_20 == SOLIDUS || LA123_20 == SQL92_RESERVED_ALL || ((LA123_20 >= SQL92_RESERVED_AND) && (LA123_20 <= SQL92_RESERVED_ANY)) || LA123_20 == SQL92_RESERVED_CASE || LA123_20 == SQL92_RESERVED_DATE || LA123_20 == SQL92_RESERVED_DEFAULT || LA123_20 == SQL92_RESERVED_DISTINCT || ((LA123_20 >= SQL92_RESERVED_EXISTS) && (LA123_20 <= SQL92_RESERVED_FALSE)) || LA123_20 == SQL92_RESERVED_IS || LA123_20 == SQL92_RESERVED_NULL || LA123_20 == SQL92_RESERVED_OR || LA123_20 == SQL92_RESERVED_PRIOR || LA123_20 == SQL92_RESERVED_TRUE || ((LA123_20 >= UNSIGNED_INTEGER) && (LA123_20 <= VERTICAL_BAR))))
                                    		            		    		                    {
                                    		            		    		                        alt123=1;
                                    		            		    		                    }
                                    		            		    		                    else if ( (LA123_20 == REGULAR_ID))
                                    		            		    		                    {
                                    		            		    		                        {
                                    		            		    		                            int LA123_24 = this->LA(10);
                                    		            		    		                            if ( (LA123_24 == APPROXIMATE_NUM_LIT || LA123_24 == ASTERISK || LA123_24 == BINDVAR || ((LA123_24 >= CARRET_OPERATOR_PART) && (LA123_24 <= COLON)) || ((LA123_24 >= CONCATENATION_OP) && (LA123_24 <= DELIMITED_ID)) || ((LA123_24 >= EQUALS_OP) && (LA123_24 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_24 >= GREATER_THAN_OP) && (LA123_24 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_24 >= INTRODUCER) && (LA123_24 <= NATIONAL_CHAR_STRING_LIT)) || LA123_24 == NOT_EQUAL_OP || ((LA123_24 >= PERIOD) && (LA123_24 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_24 == PLUS_SIGN || LA123_24 == SOLIDUS || LA123_24 == SQL92_RESERVED_ALL || ((LA123_24 >= SQL92_RESERVED_AND) && (LA123_24 <= SQL92_RESERVED_ANY)) || LA123_24 == SQL92_RESERVED_CASE || LA123_24 == SQL92_RESERVED_DATE || LA123_24 == SQL92_RESERVED_DEFAULT || LA123_24 == SQL92_RESERVED_DISTINCT || ((LA123_24 >= SQL92_RESERVED_EXISTS) && (LA123_24 <= SQL92_RESERVED_FALSE)) || LA123_24 == SQL92_RESERVED_INTERSECT || LA123_24 == SQL92_RESERVED_IS || ((LA123_24 >= SQL92_RESERVED_NULL) && (LA123_24 <= SQL92_RESERVED_OF)) || LA123_24 == SQL92_RESERVED_OR || LA123_24 == SQL92_RESERVED_PRIOR || ((LA123_24 >= SQL92_RESERVED_TO) && (LA123_24 <= SQL92_RESERVED_UNION)) || ((LA123_24 >= UNSIGNED_INTEGER) && (LA123_24 <= VERTICAL_BAR))))
                                    		            		    		                            {
                                    		            		    		                                alt123=1;
                                    		            		    		                            }
                                    		            		    		                            else if ( (LA123_24 == REGULAR_ID))
                                    		            		    		                            {
                                    		            		    		                                {
                                    		            		    		                                    int LA123_26 = this->LA(11);
                                    		            		    		                                    if ( (LA123_26 == APPROXIMATE_NUM_LIT || LA123_26 == ASTERISK || LA123_26 == BINDVAR || ((LA123_26 >= CARRET_OPERATOR_PART) && (LA123_26 <= COLON)) || ((LA123_26 >= CONCATENATION_OP) && (LA123_26 <= DELIMITED_ID)) || ((LA123_26 >= EQUALS_OP) && (LA123_26 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_26 >= GREATER_THAN_OP) && (LA123_26 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_26 >= INTRODUCER) && (LA123_26 <= NATIONAL_CHAR_STRING_LIT)) || LA123_26 == NOT_EQUAL_OP || ((LA123_26 >= PERIOD) && (LA123_26 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_26 == PLSQL_NON_RESERVED_USING || LA123_26 == PLUS_SIGN || LA123_26 == SOLIDUS || LA123_26 == SQL92_RESERVED_ALL || ((LA123_26 >= SQL92_RESERVED_AND) && (LA123_26 <= SQL92_RESERVED_ANY)) || LA123_26 == SQL92_RESERVED_CASE || LA123_26 == SQL92_RESERVED_DATE || LA123_26 == SQL92_RESERVED_DEFAULT || LA123_26 == SQL92_RESERVED_DISTINCT || ((LA123_26 >= SQL92_RESERVED_EXISTS) && (LA123_26 <= SQL92_RESERVED_FALSE)) || LA123_26 == SQL92_RESERVED_INTERSECT || LA123_26 == SQL92_RESERVED_IS || ((LA123_26 >= SQL92_RESERVED_NULL) && (LA123_26 <= SQL92_RESERVED_OF)) || LA123_26 == SQL92_RESERVED_OR || LA123_26 == SQL92_RESERVED_PRIOR || ((LA123_26 >= SQL92_RESERVED_TO) && (LA123_26 <= SQL92_RESERVED_UNION)) || ((LA123_26 >= UNSIGNED_INTEGER) && (LA123_26 <= VERTICAL_BAR))))
                                    		            		    		                                    {
                                    		            		    		                                        alt123=1;
                                    		            		    		                                    }
                                    		            		    		                                    else if ( (LA123_26 == REGULAR_ID))
                                    		            		    		                                    {
                                    		            		    		                                        {
                                    		            		    		                                            int LA123_28 = this->LA(12);
                                    		            		    		                                            if ( (LA123_28 == APPROXIMATE_NUM_LIT || LA123_28 == ASTERISK || LA123_28 == BINDVAR || ((LA123_28 >= CARRET_OPERATOR_PART) && (LA123_28 <= COLON)) || ((LA123_28 >= CONCATENATION_OP) && (LA123_28 <= DELIMITED_ID)) || ((LA123_28 >= EQUALS_OP) && (LA123_28 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_28 >= GREATER_THAN_OP) && (LA123_28 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_28 >= INTRODUCER) && (LA123_28 <= NATIONAL_CHAR_STRING_LIT)) || LA123_28 == NOT_EQUAL_OP || ((LA123_28 >= PERIOD) && (LA123_28 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_28 == PLSQL_NON_RESERVED_USING || LA123_28 == PLUS_SIGN || LA123_28 == SOLIDUS || LA123_28 == SQL92_RESERVED_ALL || ((LA123_28 >= SQL92_RESERVED_AND) && (LA123_28 <= SQL92_RESERVED_ANY)) || LA123_28 == SQL92_RESERVED_CASE || LA123_28 == SQL92_RESERVED_DATE || LA123_28 == SQL92_RESERVED_DEFAULT || LA123_28 == SQL92_RESERVED_DISTINCT || ((LA123_28 >= SQL92_RESERVED_EXISTS) && (LA123_28 <= SQL92_RESERVED_FALSE)) || LA123_28 == SQL92_RESERVED_INTERSECT || LA123_28 == SQL92_RESERVED_IS || ((LA123_28 >= SQL92_RESERVED_NULL) && (LA123_28 <= SQL92_RESERVED_OF)) || LA123_28 == SQL92_RESERVED_OR || LA123_28 == SQL92_RESERVED_PRIOR || ((LA123_28 >= SQL92_RESERVED_TO) && (LA123_28 <= SQL92_RESERVED_UNION)) || ((LA123_28 >= UNSIGNED_INTEGER) && (LA123_28 <= VERTICAL_BAR))))
                                    		            		    		                                            {
                                    		            		    		                                                alt123=1;
                                    		            		    		                                            }
                                    		            		    		                                            else if ( (LA123_28 == REGULAR_ID))
                                    		            		    		                                            {
                                    		            		    		                                                {
                                    		            		    		                                                    int LA123_30 = this->LA(13);
                                    		            		    		                                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "EXTERNAL"))))
                                    		            		    		                                                    {
                                    		            		    		                                                        alt123=1;
                                    		            		    		                                                    }
                                    		            		    		                                                }
                                    		            		    		                                            }
                                    		            		    		                                        }
                                    		            		    		                                    }
                                    		            		    		                                }
                                    		            		    		                            }
                                    		            		    		                        }
                                    		            		    		                    }
                                    		            		    		                }
                                    		            		    		            }
                                    		            		    		        }
                                    		            		    		    }
                                    		            		    		}
                                    		            		    	}
                                    		            		        break;
                                    		            		}

                                    		            	}
                                    		                break;
                                    		            case SQL92_RESERVED_NOT:
                                    		            	{
                                    		            		{
                                    		            		    int LA123_12 = this->LA(6);
                                    		            		    if ( (LA123_12 == SQL92_RESERVED_BETWEEN || LA123_12 == SQL92_RESERVED_IN || LA123_12 == SQL92_RESERVED_LIKE))
                                    		            		    {
                                    		            		        alt123=1;
                                    		            		    }
                                    		            		    else if ( (LA123_12 == REGULAR_ID))
                                    		            		    {
                                    		            		        {
                                    		            		            int LA123_16 = this->LA(7);
                                    		            		            if ( (LA123_16 == APPROXIMATE_NUM_LIT || LA123_16 == BINDVAR || ((LA123_16 >= CHAR_STRING) && (LA123_16 <= COLON)) || LA123_16 == DELIMITED_ID || LA123_16 == EXACT_NUM_LIT || LA123_16 == INTRODUCER || LA123_16 == LEFT_PAREN || ((LA123_16 >= MINUS_SIGN) && (LA123_16 <= NATIONAL_CHAR_STRING_LIT)) || LA123_16 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA123_16 == PLUS_SIGN || LA123_16 == SQL92_RESERVED_ALL || LA123_16 == SQL92_RESERVED_ANY || LA123_16 == SQL92_RESERVED_CASE || LA123_16 == SQL92_RESERVED_DATE || LA123_16 == SQL92_RESERVED_DEFAULT || LA123_16 == SQL92_RESERVED_DISTINCT || ((LA123_16 >= SQL92_RESERVED_EXISTS) && (LA123_16 <= SQL92_RESERVED_FALSE)) || LA123_16 == SQL92_RESERVED_NULL || LA123_16 == SQL92_RESERVED_PRIOR || LA123_16 == SQL92_RESERVED_TRUE || LA123_16 == UNSIGNED_INTEGER))
                                    		            		            {
                                    		            		                alt123=1;
                                    		            		            }
                                    		            		            else if ( (LA123_16 == REGULAR_ID))
                                    		            		            {
                                    		            		                {
                                    		            		                    int LA123_20 = this->LA(8);
                                    		            		                    if ( (LA123_20 == APPROXIMATE_NUM_LIT || LA123_20 == ASTERISK || LA123_20 == BINDVAR || ((LA123_20 >= CARRET_OPERATOR_PART) && (LA123_20 <= COLON)) || ((LA123_20 >= CONCATENATION_OP) && (LA123_20 <= DELIMITED_ID)) || ((LA123_20 >= EQUALS_OP) && (LA123_20 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_20 >= GREATER_THAN_OP) && (LA123_20 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_20 >= INTRODUCER) && (LA123_20 <= NATIONAL_CHAR_STRING_LIT)) || LA123_20 == NOT_EQUAL_OP || ((LA123_20 >= PERIOD) && (LA123_20 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_20 == PLUS_SIGN || LA123_20 == SOLIDUS || LA123_20 == SQL92_RESERVED_ALL || ((LA123_20 >= SQL92_RESERVED_AND) && (LA123_20 <= SQL92_RESERVED_ANY)) || LA123_20 == SQL92_RESERVED_CASE || LA123_20 == SQL92_RESERVED_DATE || LA123_20 == SQL92_RESERVED_DEFAULT || LA123_20 == SQL92_RESERVED_DISTINCT || ((LA123_20 >= SQL92_RESERVED_EXISTS) && (LA123_20 <= SQL92_RESERVED_FALSE)) || LA123_20 == SQL92_RESERVED_IS || LA123_20 == SQL92_RESERVED_NULL || LA123_20 == SQL92_RESERVED_OR || LA123_20 == SQL92_RESERVED_PRIOR || LA123_20 == SQL92_RESERVED_TRUE || ((LA123_20 >= UNSIGNED_INTEGER) && (LA123_20 <= VERTICAL_BAR))))
                                    		            		                    {
                                    		            		                        alt123=1;
                                    		            		                    }
                                    		            		                    else if ( (LA123_20 == REGULAR_ID))
                                    		            		                    {
                                    		            		                        {
                                    		            		                            int LA123_24 = this->LA(9);
                                    		            		                            if ( (LA123_24 == APPROXIMATE_NUM_LIT || LA123_24 == ASTERISK || LA123_24 == BINDVAR || ((LA123_24 >= CARRET_OPERATOR_PART) && (LA123_24 <= COLON)) || ((LA123_24 >= CONCATENATION_OP) && (LA123_24 <= DELIMITED_ID)) || ((LA123_24 >= EQUALS_OP) && (LA123_24 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_24 >= GREATER_THAN_OP) && (LA123_24 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_24 >= INTRODUCER) && (LA123_24 <= NATIONAL_CHAR_STRING_LIT)) || LA123_24 == NOT_EQUAL_OP || ((LA123_24 >= PERIOD) && (LA123_24 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_24 == PLUS_SIGN || LA123_24 == SOLIDUS || LA123_24 == SQL92_RESERVED_ALL || ((LA123_24 >= SQL92_RESERVED_AND) && (LA123_24 <= SQL92_RESERVED_ANY)) || LA123_24 == SQL92_RESERVED_CASE || LA123_24 == SQL92_RESERVED_DATE || LA123_24 == SQL92_RESERVED_DEFAULT || LA123_24 == SQL92_RESERVED_DISTINCT || ((LA123_24 >= SQL92_RESERVED_EXISTS) && (LA123_24 <= SQL92_RESERVED_FALSE)) || LA123_24 == SQL92_RESERVED_INTERSECT || LA123_24 == SQL92_RESERVED_IS || ((LA123_24 >= SQL92_RESERVED_NULL) && (LA123_24 <= SQL92_RESERVED_OF)) || LA123_24 == SQL92_RESERVED_OR || LA123_24 == SQL92_RESERVED_PRIOR || ((LA123_24 >= SQL92_RESERVED_TO) && (LA123_24 <= SQL92_RESERVED_UNION)) || ((LA123_24 >= UNSIGNED_INTEGER) && (LA123_24 <= VERTICAL_BAR))))
                                    		            		                            {
                                    		            		                                alt123=1;
                                    		            		                            }
                                    		            		                            else if ( (LA123_24 == REGULAR_ID))
                                    		            		                            {
                                    		            		                                {
                                    		            		                                    int LA123_26 = this->LA(10);
                                    		            		                                    if ( (LA123_26 == APPROXIMATE_NUM_LIT || LA123_26 == ASTERISK || LA123_26 == BINDVAR || ((LA123_26 >= CARRET_OPERATOR_PART) && (LA123_26 <= COLON)) || ((LA123_26 >= CONCATENATION_OP) && (LA123_26 <= DELIMITED_ID)) || ((LA123_26 >= EQUALS_OP) && (LA123_26 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_26 >= GREATER_THAN_OP) && (LA123_26 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_26 >= INTRODUCER) && (LA123_26 <= NATIONAL_CHAR_STRING_LIT)) || LA123_26 == NOT_EQUAL_OP || ((LA123_26 >= PERIOD) && (LA123_26 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_26 == PLSQL_NON_RESERVED_USING || LA123_26 == PLUS_SIGN || LA123_26 == SOLIDUS || LA123_26 == SQL92_RESERVED_ALL || ((LA123_26 >= SQL92_RESERVED_AND) && (LA123_26 <= SQL92_RESERVED_ANY)) || LA123_26 == SQL92_RESERVED_CASE || LA123_26 == SQL92_RESERVED_DATE || LA123_26 == SQL92_RESERVED_DEFAULT || LA123_26 == SQL92_RESERVED_DISTINCT || ((LA123_26 >= SQL92_RESERVED_EXISTS) && (LA123_26 <= SQL92_RESERVED_FALSE)) || LA123_26 == SQL92_RESERVED_INTERSECT || LA123_26 == SQL92_RESERVED_IS || ((LA123_26 >= SQL92_RESERVED_NULL) && (LA123_26 <= SQL92_RESERVED_OF)) || LA123_26 == SQL92_RESERVED_OR || LA123_26 == SQL92_RESERVED_PRIOR || ((LA123_26 >= SQL92_RESERVED_TO) && (LA123_26 <= SQL92_RESERVED_UNION)) || ((LA123_26 >= UNSIGNED_INTEGER) && (LA123_26 <= VERTICAL_BAR))))
                                    		            		                                    {
                                    		            		                                        alt123=1;
                                    		            		                                    }
                                    		            		                                    else if ( (LA123_26 == REGULAR_ID))
                                    		            		                                    {
                                    		            		                                        {
                                    		            		                                            int LA123_28 = this->LA(11);
                                    		            		                                            if ( (LA123_28 == APPROXIMATE_NUM_LIT || LA123_28 == ASTERISK || LA123_28 == BINDVAR || ((LA123_28 >= CARRET_OPERATOR_PART) && (LA123_28 <= COLON)) || ((LA123_28 >= CONCATENATION_OP) && (LA123_28 <= DELIMITED_ID)) || ((LA123_28 >= EQUALS_OP) && (LA123_28 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_28 >= GREATER_THAN_OP) && (LA123_28 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_28 >= INTRODUCER) && (LA123_28 <= NATIONAL_CHAR_STRING_LIT)) || LA123_28 == NOT_EQUAL_OP || ((LA123_28 >= PERIOD) && (LA123_28 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_28 == PLSQL_NON_RESERVED_USING || LA123_28 == PLUS_SIGN || LA123_28 == SOLIDUS || LA123_28 == SQL92_RESERVED_ALL || ((LA123_28 >= SQL92_RESERVED_AND) && (LA123_28 <= SQL92_RESERVED_ANY)) || LA123_28 == SQL92_RESERVED_CASE || LA123_28 == SQL92_RESERVED_DATE || LA123_28 == SQL92_RESERVED_DEFAULT || LA123_28 == SQL92_RESERVED_DISTINCT || ((LA123_28 >= SQL92_RESERVED_EXISTS) && (LA123_28 <= SQL92_RESERVED_FALSE)) || LA123_28 == SQL92_RESERVED_INTERSECT || LA123_28 == SQL92_RESERVED_IS || ((LA123_28 >= SQL92_RESERVED_NULL) && (LA123_28 <= SQL92_RESERVED_OF)) || LA123_28 == SQL92_RESERVED_OR || LA123_28 == SQL92_RESERVED_PRIOR || ((LA123_28 >= SQL92_RESERVED_TO) && (LA123_28 <= SQL92_RESERVED_UNION)) || ((LA123_28 >= UNSIGNED_INTEGER) && (LA123_28 <= VERTICAL_BAR))))
                                    		            		                                            {
                                    		            		                                                alt123=1;
                                    		            		                                            }
                                    		            		                                            else if ( (LA123_28 == REGULAR_ID))
                                    		            		                                            {
                                    		            		                                                {
                                    		            		                                                    int LA123_30 = this->LA(12);
                                    		            		                                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "EXTERNAL"))))
                                    		            		                                                    {
                                    		            		                                                        alt123=1;
                                    		            		                                                    }
                                    		            		                                                }
                                    		            		                                            }
                                    		            		                                        }
                                    		            		                                    }
                                    		            		                                }
                                    		            		                            }
                                    		            		                        }
                                    		            		                    }
                                    		            		                }
                                    		            		            }
                                    		            		        }
                                    		            		    }
                                    		            		}
                                    		            	}
                                    		                break;
                                    		        }

                                    		    }
                                    		}
                                    	}
                                        break;
                                    case REGULAR_ID:
                                    	{
                                    		switch ( this->LA(4) )
                                    		{
                                    		    case APPROXIMATE_NUM_LIT:
                                    		    case ASTERISK:
                                    		    case BINDVAR:
                                    		    case CARRET_OPERATOR_PART:
                                    		    case CHAR_STRING:
                                    		    case CHAR_STRING_PERL:
                                    		    case COLON:
                                    		    case CONCATENATION_OP:
                                    		    case DELIMITED_ID:
                                    		    case EQUALS_OP:
                                    		    case EXACT_NUM_LIT:
                                    		    case EXCLAMATION_OPERATOR_PART:
                                    		    case GREATER_THAN_OP:
                                    		    case GREATER_THAN_OR_EQUALS_OP:
                                    		    case INTRODUCER:
                                    		    case LEFT_BRACKET:
                                    		    case LEFT_PAREN:
                                    		    case LESS_THAN_OP:
                                    		    case LESS_THAN_OR_EQUALS_OP:
                                    		    case MINUS_SIGN:
                                    		    case NATIONAL_CHAR_STRING_LIT:
                                    		    case NOT_EQUAL_OP:
                                    		    case PERIOD:
                                    		    case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                                    		    case PLUS_SIGN:
                                    		    case SOLIDUS:
                                    		    case SQL92_RESERVED_ALL:
                                    		    case SQL92_RESERVED_AND:
                                    		    case SQL92_RESERVED_ANY:
                                    		    case SQL92_RESERVED_BETWEEN:
                                    		    case SQL92_RESERVED_CASE:
                                    		    case SQL92_RESERVED_DATE:
                                    		    case SQL92_RESERVED_DEFAULT:
                                    		    case SQL92_RESERVED_DISTINCT:
                                    		    case SQL92_RESERVED_EXISTS:
                                    		    case SQL92_RESERVED_FALSE:
                                    		    case SQL92_RESERVED_IN:
                                    		    case SQL92_RESERVED_IS:
                                    		    case SQL92_RESERVED_LIKE:
                                    		    case SQL92_RESERVED_NULL:
                                    		    case SQL92_RESERVED_OR:
                                    		    case SQL92_RESERVED_PRIOR:
                                    		    case SQL92_RESERVED_TRUE:
                                    		    case UNSIGNED_INTEGER:
                                    		    case VERTICAL_BAR:
                                    		    	{
                                    		    		alt123=1;
                                    		    	}
                                    		        break;
                                    		    case REGULAR_ID:
                                    		    	{
                                    		    		switch ( this->LA(5) )
                                    		    		{
                                    		    		    case APPROXIMATE_NUM_LIT:
                                    		    		    case ASTERISK:
                                    		    		    case BINDVAR:
                                    		    		    case CARRET_OPERATOR_PART:
                                    		    		    case CHAR_STRING:
                                    		    		    case CHAR_STRING_PERL:
                                    		    		    case COLON:
                                    		    		    case CONCATENATION_OP:
                                    		    		    case DELIMITED_ID:
                                    		    		    case EQUALS_OP:
                                    		    		    case EXACT_NUM_LIT:
                                    		    		    case EXCLAMATION_OPERATOR_PART:
                                    		    		    case GREATER_THAN_OP:
                                    		    		    case GREATER_THAN_OR_EQUALS_OP:
                                    		    		    case INTRODUCER:
                                    		    		    case LEFT_BRACKET:
                                    		    		    case LEFT_PAREN:
                                    		    		    case LESS_THAN_OP:
                                    		    		    case LESS_THAN_OR_EQUALS_OP:
                                    		    		    case MINUS_SIGN:
                                    		    		    case NATIONAL_CHAR_STRING_LIT:
                                    		    		    case NOT_EQUAL_OP:
                                    		    		    case PERIOD:
                                    		    		    case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                                    		    		    case PLUS_SIGN:
                                    		    		    case SOLIDUS:
                                    		    		    case SQL92_RESERVED_ALL:
                                    		    		    case SQL92_RESERVED_AND:
                                    		    		    case SQL92_RESERVED_ANY:
                                    		    		    case SQL92_RESERVED_BETWEEN:
                                    		    		    case SQL92_RESERVED_CASE:
                                    		    		    case SQL92_RESERVED_DATE:
                                    		    		    case SQL92_RESERVED_DEFAULT:
                                    		    		    case SQL92_RESERVED_DISTINCT:
                                    		    		    case SQL92_RESERVED_EXISTS:
                                    		    		    case SQL92_RESERVED_FALSE:
                                    		    		    case SQL92_RESERVED_IN:
                                    		    		    case SQL92_RESERVED_INTERSECT:
                                    		    		    case SQL92_RESERVED_IS:
                                    		    		    case SQL92_RESERVED_LIKE:
                                    		    		    case SQL92_RESERVED_NULL:
                                    		    		    case SQL92_RESERVED_OF:
                                    		    		    case SQL92_RESERVED_OR:
                                    		    		    case SQL92_RESERVED_PRIOR:
                                    		    		    case SQL92_RESERVED_TO:
                                    		    		    case SQL92_RESERVED_TRUE:
                                    		    		    case SQL92_RESERVED_UNION:
                                    		    		    case UNSIGNED_INTEGER:
                                    		    		    case VERTICAL_BAR:
                                    		    		    	{
                                    		    		    		alt123=1;
                                    		    		    	}
                                    		    		        break;
                                    		    		    case REGULAR_ID:
                                    		    		    	{
                                    		    		    		switch ( this->LA(6) )
                                    		    		    		{
                                    		    		    		    case APPROXIMATE_NUM_LIT:
                                    		    		    		    case ASTERISK:
                                    		    		    		    case BINDVAR:
                                    		    		    		    case CARRET_OPERATOR_PART:
                                    		    		    		    case CHAR_STRING:
                                    		    		    		    case CHAR_STRING_PERL:
                                    		    		    		    case COLON:
                                    		    		    		    case CONCATENATION_OP:
                                    		    		    		    case DELIMITED_ID:
                                    		    		    		    case EQUALS_OP:
                                    		    		    		    case EXACT_NUM_LIT:
                                    		    		    		    case EXCLAMATION_OPERATOR_PART:
                                    		    		    		    case GREATER_THAN_OP:
                                    		    		    		    case GREATER_THAN_OR_EQUALS_OP:
                                    		    		    		    case INTRODUCER:
                                    		    		    		    case LEFT_BRACKET:
                                    		    		    		    case LEFT_PAREN:
                                    		    		    		    case LESS_THAN_OP:
                                    		    		    		    case LESS_THAN_OR_EQUALS_OP:
                                    		    		    		    case MINUS_SIGN:
                                    		    		    		    case NATIONAL_CHAR_STRING_LIT:
                                    		    		    		    case NOT_EQUAL_OP:
                                    		    		    		    case PERIOD:
                                    		    		    		    case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                                    		    		    		    case PLSQL_NON_RESERVED_USING:
                                    		    		    		    case PLUS_SIGN:
                                    		    		    		    case SOLIDUS:
                                    		    		    		    case SQL92_RESERVED_ALL:
                                    		    		    		    case SQL92_RESERVED_AND:
                                    		    		    		    case SQL92_RESERVED_ANY:
                                    		    		    		    case SQL92_RESERVED_BETWEEN:
                                    		    		    		    case SQL92_RESERVED_CASE:
                                    		    		    		    case SQL92_RESERVED_DATE:
                                    		    		    		    case SQL92_RESERVED_DEFAULT:
                                    		    		    		    case SQL92_RESERVED_DISTINCT:
                                    		    		    		    case SQL92_RESERVED_EXISTS:
                                    		    		    		    case SQL92_RESERVED_FALSE:
                                    		    		    		    case SQL92_RESERVED_IN:
                                    		    		    		    case SQL92_RESERVED_INTERSECT:
                                    		    		    		    case SQL92_RESERVED_IS:
                                    		    		    		    case SQL92_RESERVED_LIKE:
                                    		    		    		    case SQL92_RESERVED_NULL:
                                    		    		    		    case SQL92_RESERVED_OF:
                                    		    		    		    case SQL92_RESERVED_OR:
                                    		    		    		    case SQL92_RESERVED_PRIOR:
                                    		    		    		    case SQL92_RESERVED_TO:
                                    		    		    		    case SQL92_RESERVED_TRUE:
                                    		    		    		    case SQL92_RESERVED_UNION:
                                    		    		    		    case UNSIGNED_INTEGER:
                                    		    		    		    case VERTICAL_BAR:
                                    		    		    		    	{
                                    		    		    		    		alt123=1;
                                    		    		    		    	}
                                    		    		    		        break;
                                    		    		    		    case REGULAR_ID:
                                    		    		    		    	{
                                    		    		    		    		switch ( this->LA(7) )
                                    		    		    		    		{
                                    		    		    		    		    case APPROXIMATE_NUM_LIT:
                                    		    		    		    		    case ASTERISK:
                                    		    		    		    		    case BINDVAR:
                                    		    		    		    		    case CARRET_OPERATOR_PART:
                                    		    		    		    		    case CHAR_STRING:
                                    		    		    		    		    case CHAR_STRING_PERL:
                                    		    		    		    		    case COLON:
                                    		    		    		    		    case CONCATENATION_OP:
                                    		    		    		    		    case DELIMITED_ID:
                                    		    		    		    		    case EQUALS_OP:
                                    		    		    		    		    case EXACT_NUM_LIT:
                                    		    		    		    		    case EXCLAMATION_OPERATOR_PART:
                                    		    		    		    		    case GREATER_THAN_OP:
                                    		    		    		    		    case GREATER_THAN_OR_EQUALS_OP:
                                    		    		    		    		    case INTRODUCER:
                                    		    		    		    		    case LEFT_BRACKET:
                                    		    		    		    		    case LEFT_PAREN:
                                    		    		    		    		    case LESS_THAN_OP:
                                    		    		    		    		    case LESS_THAN_OR_EQUALS_OP:
                                    		    		    		    		    case MINUS_SIGN:
                                    		    		    		    		    case NATIONAL_CHAR_STRING_LIT:
                                    		    		    		    		    case NOT_EQUAL_OP:
                                    		    		    		    		    case PERIOD:
                                    		    		    		    		    case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                                    		    		    		    		    case PLSQL_NON_RESERVED_USING:
                                    		    		    		    		    case PLUS_SIGN:
                                    		    		    		    		    case SOLIDUS:
                                    		    		    		    		    case SQL92_RESERVED_ALL:
                                    		    		    		    		    case SQL92_RESERVED_AND:
                                    		    		    		    		    case SQL92_RESERVED_ANY:
                                    		    		    		    		    case SQL92_RESERVED_BETWEEN:
                                    		    		    		    		    case SQL92_RESERVED_CASE:
                                    		    		    		    		    case SQL92_RESERVED_DATE:
                                    		    		    		    		    case SQL92_RESERVED_DEFAULT:
                                    		    		    		    		    case SQL92_RESERVED_DISTINCT:
                                    		    		    		    		    case SQL92_RESERVED_EXISTS:
                                    		    		    		    		    case SQL92_RESERVED_FALSE:
                                    		    		    		    		    case SQL92_RESERVED_IN:
                                    		    		    		    		    case SQL92_RESERVED_INTERSECT:
                                    		    		    		    		    case SQL92_RESERVED_IS:
                                    		    		    		    		    case SQL92_RESERVED_LIKE:
                                    		    		    		    		    case SQL92_RESERVED_NULL:
                                    		    		    		    		    case SQL92_RESERVED_OF:
                                    		    		    		    		    case SQL92_RESERVED_OR:
                                    		    		    		    		    case SQL92_RESERVED_PRIOR:
                                    		    		    		    		    case SQL92_RESERVED_TO:
                                    		    		    		    		    case SQL92_RESERVED_TRUE:
                                    		    		    		    		    case SQL92_RESERVED_UNION:
                                    		    		    		    		    case UNSIGNED_INTEGER:
                                    		    		    		    		    case VERTICAL_BAR:
                                    		    		    		    		    	{
                                    		    		    		    		    		alt123=1;
                                    		    		    		    		    	}
                                    		    		    		    		        break;
                                    		    		    		    		    case REGULAR_ID:
                                    		    		    		    		    	{
                                    		    		    		    		    		{
                                    		    		    		    		    		    int LA123_21 = this->LA(8);
                                    		    		    		    		    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "EXTERNAL"))))
                                    		    		    		    		    		    {
                                    		    		    		    		    		        alt123=1;
                                    		    		    		    		    		    }
                                    		    		    		    		    		}
                                    		    		    		    		    	}
                                    		    		    		    		        break;
                                    		    		    		    		    case SQL92_RESERVED_NOT:
                                    		    		    		    		    	{
                                    		    		    		    		    		{
                                    		    		    		    		    		    int LA123_10 = this->LA(8);
                                    		    		    		    		    		    if ( (LA123_10 == SQL92_RESERVED_BETWEEN || LA123_10 == SQL92_RESERVED_IN || LA123_10 == SQL92_RESERVED_LIKE))
                                    		    		    		    		    		    {
                                    		    		    		    		    		        alt123=1;
                                    		    		    		    		    		    }
                                    		    		    		    		    		    else if ( (LA123_10 == REGULAR_ID))
                                    		    		    		    		    		    {
                                    		    		    		    		    		        {
                                    		    		    		    		    		            int LA123_14 = this->LA(9);
                                    		    		    		    		    		            if ( (LA123_14 == APPROXIMATE_NUM_LIT || LA123_14 == BINDVAR || ((LA123_14 >= CHAR_STRING) && (LA123_14 <= COLON)) || LA123_14 == DELIMITED_ID || LA123_14 == EXACT_NUM_LIT || LA123_14 == INTRODUCER || LA123_14 == LEFT_PAREN || ((LA123_14 >= MINUS_SIGN) && (LA123_14 <= NATIONAL_CHAR_STRING_LIT)) || LA123_14 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA123_14 == PLUS_SIGN || LA123_14 == SQL92_RESERVED_ALL || LA123_14 == SQL92_RESERVED_ANY || LA123_14 == SQL92_RESERVED_CASE || LA123_14 == SQL92_RESERVED_DATE || LA123_14 == SQL92_RESERVED_DEFAULT || LA123_14 == SQL92_RESERVED_DISTINCT || ((LA123_14 >= SQL92_RESERVED_EXISTS) && (LA123_14 <= SQL92_RESERVED_FALSE)) || LA123_14 == SQL92_RESERVED_NULL || LA123_14 == SQL92_RESERVED_PRIOR || LA123_14 == SQL92_RESERVED_TRUE || LA123_14 == UNSIGNED_INTEGER))
                                    		    		    		    		    		            {
                                    		    		    		    		    		                alt123=1;
                                    		    		    		    		    		            }
                                    		    		    		    		    		            else if ( (LA123_14 == REGULAR_ID))
                                    		    		    		    		    		            {
                                    		    		    		    		    		                {
                                    		    		    		    		    		                    int LA123_18 = this->LA(10);
                                    		    		    		    		    		                    if ( (LA123_18 == APPROXIMATE_NUM_LIT || LA123_18 == ASTERISK || LA123_18 == BINDVAR || ((LA123_18 >= CARRET_OPERATOR_PART) && (LA123_18 <= COLON)) || ((LA123_18 >= CONCATENATION_OP) && (LA123_18 <= DELIMITED_ID)) || ((LA123_18 >= EQUALS_OP) && (LA123_18 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_18 >= GREATER_THAN_OP) && (LA123_18 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_18 >= INTRODUCER) && (LA123_18 <= NATIONAL_CHAR_STRING_LIT)) || LA123_18 == NOT_EQUAL_OP || ((LA123_18 >= PERIOD) && (LA123_18 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_18 == PLUS_SIGN || LA123_18 == SOLIDUS || LA123_18 == SQL92_RESERVED_ALL || ((LA123_18 >= SQL92_RESERVED_AND) && (LA123_18 <= SQL92_RESERVED_ANY)) || LA123_18 == SQL92_RESERVED_CASE || LA123_18 == SQL92_RESERVED_DATE || LA123_18 == SQL92_RESERVED_DEFAULT || LA123_18 == SQL92_RESERVED_DISTINCT || ((LA123_18 >= SQL92_RESERVED_EXISTS) && (LA123_18 <= SQL92_RESERVED_FALSE)) || LA123_18 == SQL92_RESERVED_IS || LA123_18 == SQL92_RESERVED_NULL || LA123_18 == SQL92_RESERVED_OR || LA123_18 == SQL92_RESERVED_PRIOR || LA123_18 == SQL92_RESERVED_TRUE || ((LA123_18 >= UNSIGNED_INTEGER) && (LA123_18 <= VERTICAL_BAR))))
                                    		    		    		    		    		                    {
                                    		    		    		    		    		                        alt123=1;
                                    		    		    		    		    		                    }
                                    		    		    		    		    		                    else if ( (LA123_18 == REGULAR_ID))
                                    		    		    		    		    		                    {
                                    		    		    		    		    		                        {
                                    		    		    		    		    		                            int LA123_22 = this->LA(11);
                                    		    		    		    		    		                            if ( (LA123_22 == APPROXIMATE_NUM_LIT || LA123_22 == ASTERISK || LA123_22 == BINDVAR || ((LA123_22 >= CARRET_OPERATOR_PART) && (LA123_22 <= COLON)) || ((LA123_22 >= CONCATENATION_OP) && (LA123_22 <= DELIMITED_ID)) || ((LA123_22 >= EQUALS_OP) && (LA123_22 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_22 >= GREATER_THAN_OP) && (LA123_22 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_22 >= INTRODUCER) && (LA123_22 <= NATIONAL_CHAR_STRING_LIT)) || LA123_22 == NOT_EQUAL_OP || ((LA123_22 >= PERIOD) && (LA123_22 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_22 == PLUS_SIGN || LA123_22 == SOLIDUS || LA123_22 == SQL92_RESERVED_ALL || ((LA123_22 >= SQL92_RESERVED_AND) && (LA123_22 <= SQL92_RESERVED_ANY)) || LA123_22 == SQL92_RESERVED_CASE || LA123_22 == SQL92_RESERVED_DATE || LA123_22 == SQL92_RESERVED_DEFAULT || LA123_22 == SQL92_RESERVED_DISTINCT || ((LA123_22 >= SQL92_RESERVED_EXISTS) && (LA123_22 <= SQL92_RESERVED_FALSE)) || LA123_22 == SQL92_RESERVED_INTERSECT || LA123_22 == SQL92_RESERVED_IS || ((LA123_22 >= SQL92_RESERVED_NULL) && (LA123_22 <= SQL92_RESERVED_OF)) || LA123_22 == SQL92_RESERVED_OR || LA123_22 == SQL92_RESERVED_PRIOR || ((LA123_22 >= SQL92_RESERVED_TO) && (LA123_22 <= SQL92_RESERVED_UNION)) || ((LA123_22 >= UNSIGNED_INTEGER) && (LA123_22 <= VERTICAL_BAR))))
                                    		    		    		    		    		                            {
                                    		    		    		    		    		                                alt123=1;
                                    		    		    		    		    		                            }
                                    		    		    		    		    		                            else if ( (LA123_22 == REGULAR_ID))
                                    		    		    		    		    		                            {
                                    		    		    		    		    		                                {
                                    		    		    		    		    		                                    int LA123_25 = this->LA(12);
                                    		    		    		    		    		                                    if ( (LA123_25 == APPROXIMATE_NUM_LIT || LA123_25 == ASTERISK || LA123_25 == BINDVAR || ((LA123_25 >= CARRET_OPERATOR_PART) && (LA123_25 <= COLON)) || ((LA123_25 >= CONCATENATION_OP) && (LA123_25 <= DELIMITED_ID)) || ((LA123_25 >= EQUALS_OP) && (LA123_25 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_25 >= GREATER_THAN_OP) && (LA123_25 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_25 >= INTRODUCER) && (LA123_25 <= NATIONAL_CHAR_STRING_LIT)) || LA123_25 == NOT_EQUAL_OP || ((LA123_25 >= PERIOD) && (LA123_25 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_25 == PLSQL_NON_RESERVED_USING || LA123_25 == PLUS_SIGN || LA123_25 == SOLIDUS || LA123_25 == SQL92_RESERVED_ALL || ((LA123_25 >= SQL92_RESERVED_AND) && (LA123_25 <= SQL92_RESERVED_ANY)) || LA123_25 == SQL92_RESERVED_CASE || LA123_25 == SQL92_RESERVED_DATE || LA123_25 == SQL92_RESERVED_DEFAULT || LA123_25 == SQL92_RESERVED_DISTINCT || ((LA123_25 >= SQL92_RESERVED_EXISTS) && (LA123_25 <= SQL92_RESERVED_FALSE)) || LA123_25 == SQL92_RESERVED_INTERSECT || LA123_25 == SQL92_RESERVED_IS || ((LA123_25 >= SQL92_RESERVED_NULL) && (LA123_25 <= SQL92_RESERVED_OF)) || LA123_25 == SQL92_RESERVED_OR || LA123_25 == SQL92_RESERVED_PRIOR || ((LA123_25 >= SQL92_RESERVED_TO) && (LA123_25 <= SQL92_RESERVED_UNION)) || ((LA123_25 >= UNSIGNED_INTEGER) && (LA123_25 <= VERTICAL_BAR))))
                                    		    		    		    		    		                                    {
                                    		    		    		    		    		                                        alt123=1;
                                    		    		    		    		    		                                    }
                                    		    		    		    		    		                                    else if ( (LA123_25 == REGULAR_ID))
                                    		    		    		    		    		                                    {
                                    		    		    		    		    		                                        {
                                    		    		    		    		    		                                            int LA123_27 = this->LA(13);
                                    		    		    		    		    		                                            if ( (LA123_27 == APPROXIMATE_NUM_LIT || LA123_27 == ASTERISK || LA123_27 == BINDVAR || ((LA123_27 >= CARRET_OPERATOR_PART) && (LA123_27 <= COLON)) || ((LA123_27 >= CONCATENATION_OP) && (LA123_27 <= DELIMITED_ID)) || ((LA123_27 >= EQUALS_OP) && (LA123_27 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_27 >= GREATER_THAN_OP) && (LA123_27 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_27 >= INTRODUCER) && (LA123_27 <= NATIONAL_CHAR_STRING_LIT)) || LA123_27 == NOT_EQUAL_OP || ((LA123_27 >= PERIOD) && (LA123_27 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_27 == PLSQL_NON_RESERVED_USING || LA123_27 == PLUS_SIGN || LA123_27 == SOLIDUS || LA123_27 == SQL92_RESERVED_ALL || ((LA123_27 >= SQL92_RESERVED_AND) && (LA123_27 <= SQL92_RESERVED_ANY)) || LA123_27 == SQL92_RESERVED_CASE || LA123_27 == SQL92_RESERVED_DATE || LA123_27 == SQL92_RESERVED_DEFAULT || LA123_27 == SQL92_RESERVED_DISTINCT || ((LA123_27 >= SQL92_RESERVED_EXISTS) && (LA123_27 <= SQL92_RESERVED_FALSE)) || LA123_27 == SQL92_RESERVED_INTERSECT || LA123_27 == SQL92_RESERVED_IS || ((LA123_27 >= SQL92_RESERVED_NULL) && (LA123_27 <= SQL92_RESERVED_OF)) || LA123_27 == SQL92_RESERVED_OR || LA123_27 == SQL92_RESERVED_PRIOR || ((LA123_27 >= SQL92_RESERVED_TO) && (LA123_27 <= SQL92_RESERVED_UNION)) || ((LA123_27 >= UNSIGNED_INTEGER) && (LA123_27 <= VERTICAL_BAR))))
                                    		    		    		    		    		                                            {
                                    		    		    		    		    		                                                alt123=1;
                                    		    		    		    		    		                                            }
                                    		    		    		    		    		                                            else if ( (LA123_27 == REGULAR_ID))
                                    		    		    		    		    		                                            {
                                    		    		    		    		    		                                                {
                                    		    		    		    		    		                                                    int LA123_29 = this->LA(14);
                                    		    		    		    		    		                                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "EXTERNAL"))))
                                    		    		    		    		    		                                                    {
                                    		    		    		    		    		                                                        alt123=1;
                                    		    		    		    		    		                                                    }
                                    		    		    		    		    		                                                }
                                    		    		    		    		    		                                            }
                                    		    		    		    		    		                                        }
                                    		    		    		    		    		                                    }
                                    		    		    		    		    		                                }
                                    		    		    		    		    		                            }
                                    		    		    		    		    		                        }
                                    		    		    		    		    		                    }
                                    		    		    		    		    		                }
                                    		    		    		    		    		            }
                                    		    		    		    		    		        }
                                    		    		    		    		    		    }
                                    		    		    		    		    		}
                                    		    		    		    		    	}
                                    		    		    		    		        break;
                                    		    		    		    		}

                                    		    		    		    	}
                                    		    		    		        break;
                                    		    		    		    case SQL92_RESERVED_NOT:
                                    		    		    		    	{
                                    		    		    		    		{
                                    		    		    		    		    int LA123_10 = this->LA(7);
                                    		    		    		    		    if ( (LA123_10 == SQL92_RESERVED_BETWEEN || LA123_10 == SQL92_RESERVED_IN || LA123_10 == SQL92_RESERVED_LIKE))
                                    		    		    		    		    {
                                    		    		    		    		        alt123=1;
                                    		    		    		    		    }
                                    		    		    		    		    else if ( (LA123_10 == REGULAR_ID))
                                    		    		    		    		    {
                                    		    		    		    		        {
                                    		    		    		    		            int LA123_14 = this->LA(8);
                                    		    		    		    		            if ( (LA123_14 == APPROXIMATE_NUM_LIT || LA123_14 == BINDVAR || ((LA123_14 >= CHAR_STRING) && (LA123_14 <= COLON)) || LA123_14 == DELIMITED_ID || LA123_14 == EXACT_NUM_LIT || LA123_14 == INTRODUCER || LA123_14 == LEFT_PAREN || ((LA123_14 >= MINUS_SIGN) && (LA123_14 <= NATIONAL_CHAR_STRING_LIT)) || LA123_14 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA123_14 == PLUS_SIGN || LA123_14 == SQL92_RESERVED_ALL || LA123_14 == SQL92_RESERVED_ANY || LA123_14 == SQL92_RESERVED_CASE || LA123_14 == SQL92_RESERVED_DATE || LA123_14 == SQL92_RESERVED_DEFAULT || LA123_14 == SQL92_RESERVED_DISTINCT || ((LA123_14 >= SQL92_RESERVED_EXISTS) && (LA123_14 <= SQL92_RESERVED_FALSE)) || LA123_14 == SQL92_RESERVED_NULL || LA123_14 == SQL92_RESERVED_PRIOR || LA123_14 == SQL92_RESERVED_TRUE || LA123_14 == UNSIGNED_INTEGER))
                                    		    		    		    		            {
                                    		    		    		    		                alt123=1;
                                    		    		    		    		            }
                                    		    		    		    		            else if ( (LA123_14 == REGULAR_ID))
                                    		    		    		    		            {
                                    		    		    		    		                {
                                    		    		    		    		                    int LA123_18 = this->LA(9);
                                    		    		    		    		                    if ( (LA123_18 == APPROXIMATE_NUM_LIT || LA123_18 == ASTERISK || LA123_18 == BINDVAR || ((LA123_18 >= CARRET_OPERATOR_PART) && (LA123_18 <= COLON)) || ((LA123_18 >= CONCATENATION_OP) && (LA123_18 <= DELIMITED_ID)) || ((LA123_18 >= EQUALS_OP) && (LA123_18 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_18 >= GREATER_THAN_OP) && (LA123_18 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_18 >= INTRODUCER) && (LA123_18 <= NATIONAL_CHAR_STRING_LIT)) || LA123_18 == NOT_EQUAL_OP || ((LA123_18 >= PERIOD) && (LA123_18 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_18 == PLUS_SIGN || LA123_18 == SOLIDUS || LA123_18 == SQL92_RESERVED_ALL || ((LA123_18 >= SQL92_RESERVED_AND) && (LA123_18 <= SQL92_RESERVED_ANY)) || LA123_18 == SQL92_RESERVED_CASE || LA123_18 == SQL92_RESERVED_DATE || LA123_18 == SQL92_RESERVED_DEFAULT || LA123_18 == SQL92_RESERVED_DISTINCT || ((LA123_18 >= SQL92_RESERVED_EXISTS) && (LA123_18 <= SQL92_RESERVED_FALSE)) || LA123_18 == SQL92_RESERVED_IS || LA123_18 == SQL92_RESERVED_NULL || LA123_18 == SQL92_RESERVED_OR || LA123_18 == SQL92_RESERVED_PRIOR || LA123_18 == SQL92_RESERVED_TRUE || ((LA123_18 >= UNSIGNED_INTEGER) && (LA123_18 <= VERTICAL_BAR))))
                                    		    		    		    		                    {
                                    		    		    		    		                        alt123=1;
                                    		    		    		    		                    }
                                    		    		    		    		                    else if ( (LA123_18 == REGULAR_ID))
                                    		    		    		    		                    {
                                    		    		    		    		                        {
                                    		    		    		    		                            int LA123_22 = this->LA(10);
                                    		    		    		    		                            if ( (LA123_22 == APPROXIMATE_NUM_LIT || LA123_22 == ASTERISK || LA123_22 == BINDVAR || ((LA123_22 >= CARRET_OPERATOR_PART) && (LA123_22 <= COLON)) || ((LA123_22 >= CONCATENATION_OP) && (LA123_22 <= DELIMITED_ID)) || ((LA123_22 >= EQUALS_OP) && (LA123_22 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_22 >= GREATER_THAN_OP) && (LA123_22 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_22 >= INTRODUCER) && (LA123_22 <= NATIONAL_CHAR_STRING_LIT)) || LA123_22 == NOT_EQUAL_OP || ((LA123_22 >= PERIOD) && (LA123_22 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_22 == PLUS_SIGN || LA123_22 == SOLIDUS || LA123_22 == SQL92_RESERVED_ALL || ((LA123_22 >= SQL92_RESERVED_AND) && (LA123_22 <= SQL92_RESERVED_ANY)) || LA123_22 == SQL92_RESERVED_CASE || LA123_22 == SQL92_RESERVED_DATE || LA123_22 == SQL92_RESERVED_DEFAULT || LA123_22 == SQL92_RESERVED_DISTINCT || ((LA123_22 >= SQL92_RESERVED_EXISTS) && (LA123_22 <= SQL92_RESERVED_FALSE)) || LA123_22 == SQL92_RESERVED_INTERSECT || LA123_22 == SQL92_RESERVED_IS || ((LA123_22 >= SQL92_RESERVED_NULL) && (LA123_22 <= SQL92_RESERVED_OF)) || LA123_22 == SQL92_RESERVED_OR || LA123_22 == SQL92_RESERVED_PRIOR || ((LA123_22 >= SQL92_RESERVED_TO) && (LA123_22 <= SQL92_RESERVED_UNION)) || ((LA123_22 >= UNSIGNED_INTEGER) && (LA123_22 <= VERTICAL_BAR))))
                                    		    		    		    		                            {
                                    		    		    		    		                                alt123=1;
                                    		    		    		    		                            }
                                    		    		    		    		                            else if ( (LA123_22 == REGULAR_ID))
                                    		    		    		    		                            {
                                    		    		    		    		                                {
                                    		    		    		    		                                    int LA123_25 = this->LA(11);
                                    		    		    		    		                                    if ( (LA123_25 == APPROXIMATE_NUM_LIT || LA123_25 == ASTERISK || LA123_25 == BINDVAR || ((LA123_25 >= CARRET_OPERATOR_PART) && (LA123_25 <= COLON)) || ((LA123_25 >= CONCATENATION_OP) && (LA123_25 <= DELIMITED_ID)) || ((LA123_25 >= EQUALS_OP) && (LA123_25 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_25 >= GREATER_THAN_OP) && (LA123_25 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_25 >= INTRODUCER) && (LA123_25 <= NATIONAL_CHAR_STRING_LIT)) || LA123_25 == NOT_EQUAL_OP || ((LA123_25 >= PERIOD) && (LA123_25 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_25 == PLSQL_NON_RESERVED_USING || LA123_25 == PLUS_SIGN || LA123_25 == SOLIDUS || LA123_25 == SQL92_RESERVED_ALL || ((LA123_25 >= SQL92_RESERVED_AND) && (LA123_25 <= SQL92_RESERVED_ANY)) || LA123_25 == SQL92_RESERVED_CASE || LA123_25 == SQL92_RESERVED_DATE || LA123_25 == SQL92_RESERVED_DEFAULT || LA123_25 == SQL92_RESERVED_DISTINCT || ((LA123_25 >= SQL92_RESERVED_EXISTS) && (LA123_25 <= SQL92_RESERVED_FALSE)) || LA123_25 == SQL92_RESERVED_INTERSECT || LA123_25 == SQL92_RESERVED_IS || ((LA123_25 >= SQL92_RESERVED_NULL) && (LA123_25 <= SQL92_RESERVED_OF)) || LA123_25 == SQL92_RESERVED_OR || LA123_25 == SQL92_RESERVED_PRIOR || ((LA123_25 >= SQL92_RESERVED_TO) && (LA123_25 <= SQL92_RESERVED_UNION)) || ((LA123_25 >= UNSIGNED_INTEGER) && (LA123_25 <= VERTICAL_BAR))))
                                    		    		    		    		                                    {
                                    		    		    		    		                                        alt123=1;
                                    		    		    		    		                                    }
                                    		    		    		    		                                    else if ( (LA123_25 == REGULAR_ID))
                                    		    		    		    		                                    {
                                    		    		    		    		                                        {
                                    		    		    		    		                                            int LA123_27 = this->LA(12);
                                    		    		    		    		                                            if ( (LA123_27 == APPROXIMATE_NUM_LIT || LA123_27 == ASTERISK || LA123_27 == BINDVAR || ((LA123_27 >= CARRET_OPERATOR_PART) && (LA123_27 <= COLON)) || ((LA123_27 >= CONCATENATION_OP) && (LA123_27 <= DELIMITED_ID)) || ((LA123_27 >= EQUALS_OP) && (LA123_27 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_27 >= GREATER_THAN_OP) && (LA123_27 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_27 >= INTRODUCER) && (LA123_27 <= NATIONAL_CHAR_STRING_LIT)) || LA123_27 == NOT_EQUAL_OP || ((LA123_27 >= PERIOD) && (LA123_27 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_27 == PLSQL_NON_RESERVED_USING || LA123_27 == PLUS_SIGN || LA123_27 == SOLIDUS || LA123_27 == SQL92_RESERVED_ALL || ((LA123_27 >= SQL92_RESERVED_AND) && (LA123_27 <= SQL92_RESERVED_ANY)) || LA123_27 == SQL92_RESERVED_CASE || LA123_27 == SQL92_RESERVED_DATE || LA123_27 == SQL92_RESERVED_DEFAULT || LA123_27 == SQL92_RESERVED_DISTINCT || ((LA123_27 >= SQL92_RESERVED_EXISTS) && (LA123_27 <= SQL92_RESERVED_FALSE)) || LA123_27 == SQL92_RESERVED_INTERSECT || LA123_27 == SQL92_RESERVED_IS || ((LA123_27 >= SQL92_RESERVED_NULL) && (LA123_27 <= SQL92_RESERVED_OF)) || LA123_27 == SQL92_RESERVED_OR || LA123_27 == SQL92_RESERVED_PRIOR || ((LA123_27 >= SQL92_RESERVED_TO) && (LA123_27 <= SQL92_RESERVED_UNION)) || ((LA123_27 >= UNSIGNED_INTEGER) && (LA123_27 <= VERTICAL_BAR))))
                                    		    		    		    		                                            {
                                    		    		    		    		                                                alt123=1;
                                    		    		    		    		                                            }
                                    		    		    		    		                                            else if ( (LA123_27 == REGULAR_ID))
                                    		    		    		    		                                            {
                                    		    		    		    		                                                {
                                    		    		    		    		                                                    int LA123_29 = this->LA(13);
                                    		    		    		    		                                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "EXTERNAL"))))
                                    		    		    		    		                                                    {
                                    		    		    		    		                                                        alt123=1;
                                    		    		    		    		                                                    }
                                    		    		    		    		                                                }
                                    		    		    		    		                                            }
                                    		    		    		    		                                        }
                                    		    		    		    		                                    }
                                    		    		    		    		                                }
                                    		    		    		    		                            }
                                    		    		    		    		                        }
                                    		    		    		    		                    }
                                    		    		    		    		                }
                                    		    		    		    		            }
                                    		    		    		    		        }
                                    		    		    		    		    }
                                    		    		    		    		}
                                    		    		    		    	}
                                    		    		    		        break;
                                    		    		    		}

                                    		    		    	}
                                    		    		        break;
                                    		    		    case SQL92_RESERVED_NOT:
                                    		    		    	{
                                    		    		    		{
                                    		    		    		    int LA123_10 = this->LA(6);
                                    		    		    		    if ( (LA123_10 == SQL92_RESERVED_BETWEEN || LA123_10 == SQL92_RESERVED_IN || LA123_10 == SQL92_RESERVED_LIKE))
                                    		    		    		    {
                                    		    		    		        alt123=1;
                                    		    		    		    }
                                    		    		    		    else if ( (LA123_10 == REGULAR_ID))
                                    		    		    		    {
                                    		    		    		        {
                                    		    		    		            int LA123_14 = this->LA(7);
                                    		    		    		            if ( (LA123_14 == APPROXIMATE_NUM_LIT || LA123_14 == BINDVAR || ((LA123_14 >= CHAR_STRING) && (LA123_14 <= COLON)) || LA123_14 == DELIMITED_ID || LA123_14 == EXACT_NUM_LIT || LA123_14 == INTRODUCER || LA123_14 == LEFT_PAREN || ((LA123_14 >= MINUS_SIGN) && (LA123_14 <= NATIONAL_CHAR_STRING_LIT)) || LA123_14 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA123_14 == PLUS_SIGN || LA123_14 == SQL92_RESERVED_ALL || LA123_14 == SQL92_RESERVED_ANY || LA123_14 == SQL92_RESERVED_CASE || LA123_14 == SQL92_RESERVED_DATE || LA123_14 == SQL92_RESERVED_DEFAULT || LA123_14 == SQL92_RESERVED_DISTINCT || ((LA123_14 >= SQL92_RESERVED_EXISTS) && (LA123_14 <= SQL92_RESERVED_FALSE)) || LA123_14 == SQL92_RESERVED_NULL || LA123_14 == SQL92_RESERVED_PRIOR || LA123_14 == SQL92_RESERVED_TRUE || LA123_14 == UNSIGNED_INTEGER))
                                    		    		    		            {
                                    		    		    		                alt123=1;
                                    		    		    		            }
                                    		    		    		            else if ( (LA123_14 == REGULAR_ID))
                                    		    		    		            {
                                    		    		    		                {
                                    		    		    		                    int LA123_18 = this->LA(8);
                                    		    		    		                    if ( (LA123_18 == APPROXIMATE_NUM_LIT || LA123_18 == ASTERISK || LA123_18 == BINDVAR || ((LA123_18 >= CARRET_OPERATOR_PART) && (LA123_18 <= COLON)) || ((LA123_18 >= CONCATENATION_OP) && (LA123_18 <= DELIMITED_ID)) || ((LA123_18 >= EQUALS_OP) && (LA123_18 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_18 >= GREATER_THAN_OP) && (LA123_18 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_18 >= INTRODUCER) && (LA123_18 <= NATIONAL_CHAR_STRING_LIT)) || LA123_18 == NOT_EQUAL_OP || ((LA123_18 >= PERIOD) && (LA123_18 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_18 == PLUS_SIGN || LA123_18 == SOLIDUS || LA123_18 == SQL92_RESERVED_ALL || ((LA123_18 >= SQL92_RESERVED_AND) && (LA123_18 <= SQL92_RESERVED_ANY)) || LA123_18 == SQL92_RESERVED_CASE || LA123_18 == SQL92_RESERVED_DATE || LA123_18 == SQL92_RESERVED_DEFAULT || LA123_18 == SQL92_RESERVED_DISTINCT || ((LA123_18 >= SQL92_RESERVED_EXISTS) && (LA123_18 <= SQL92_RESERVED_FALSE)) || LA123_18 == SQL92_RESERVED_IS || LA123_18 == SQL92_RESERVED_NULL || LA123_18 == SQL92_RESERVED_OR || LA123_18 == SQL92_RESERVED_PRIOR || LA123_18 == SQL92_RESERVED_TRUE || ((LA123_18 >= UNSIGNED_INTEGER) && (LA123_18 <= VERTICAL_BAR))))
                                    		    		    		                    {
                                    		    		    		                        alt123=1;
                                    		    		    		                    }
                                    		    		    		                    else if ( (LA123_18 == REGULAR_ID))
                                    		    		    		                    {
                                    		    		    		                        {
                                    		    		    		                            int LA123_22 = this->LA(9);
                                    		    		    		                            if ( (LA123_22 == APPROXIMATE_NUM_LIT || LA123_22 == ASTERISK || LA123_22 == BINDVAR || ((LA123_22 >= CARRET_OPERATOR_PART) && (LA123_22 <= COLON)) || ((LA123_22 >= CONCATENATION_OP) && (LA123_22 <= DELIMITED_ID)) || ((LA123_22 >= EQUALS_OP) && (LA123_22 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_22 >= GREATER_THAN_OP) && (LA123_22 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_22 >= INTRODUCER) && (LA123_22 <= NATIONAL_CHAR_STRING_LIT)) || LA123_22 == NOT_EQUAL_OP || ((LA123_22 >= PERIOD) && (LA123_22 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_22 == PLUS_SIGN || LA123_22 == SOLIDUS || LA123_22 == SQL92_RESERVED_ALL || ((LA123_22 >= SQL92_RESERVED_AND) && (LA123_22 <= SQL92_RESERVED_ANY)) || LA123_22 == SQL92_RESERVED_CASE || LA123_22 == SQL92_RESERVED_DATE || LA123_22 == SQL92_RESERVED_DEFAULT || LA123_22 == SQL92_RESERVED_DISTINCT || ((LA123_22 >= SQL92_RESERVED_EXISTS) && (LA123_22 <= SQL92_RESERVED_FALSE)) || LA123_22 == SQL92_RESERVED_INTERSECT || LA123_22 == SQL92_RESERVED_IS || ((LA123_22 >= SQL92_RESERVED_NULL) && (LA123_22 <= SQL92_RESERVED_OF)) || LA123_22 == SQL92_RESERVED_OR || LA123_22 == SQL92_RESERVED_PRIOR || ((LA123_22 >= SQL92_RESERVED_TO) && (LA123_22 <= SQL92_RESERVED_UNION)) || ((LA123_22 >= UNSIGNED_INTEGER) && (LA123_22 <= VERTICAL_BAR))))
                                    		    		    		                            {
                                    		    		    		                                alt123=1;
                                    		    		    		                            }
                                    		    		    		                            else if ( (LA123_22 == REGULAR_ID))
                                    		    		    		                            {
                                    		    		    		                                {
                                    		    		    		                                    int LA123_25 = this->LA(10);
                                    		    		    		                                    if ( (LA123_25 == APPROXIMATE_NUM_LIT || LA123_25 == ASTERISK || LA123_25 == BINDVAR || ((LA123_25 >= CARRET_OPERATOR_PART) && (LA123_25 <= COLON)) || ((LA123_25 >= CONCATENATION_OP) && (LA123_25 <= DELIMITED_ID)) || ((LA123_25 >= EQUALS_OP) && (LA123_25 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_25 >= GREATER_THAN_OP) && (LA123_25 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_25 >= INTRODUCER) && (LA123_25 <= NATIONAL_CHAR_STRING_LIT)) || LA123_25 == NOT_EQUAL_OP || ((LA123_25 >= PERIOD) && (LA123_25 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_25 == PLSQL_NON_RESERVED_USING || LA123_25 == PLUS_SIGN || LA123_25 == SOLIDUS || LA123_25 == SQL92_RESERVED_ALL || ((LA123_25 >= SQL92_RESERVED_AND) && (LA123_25 <= SQL92_RESERVED_ANY)) || LA123_25 == SQL92_RESERVED_CASE || LA123_25 == SQL92_RESERVED_DATE || LA123_25 == SQL92_RESERVED_DEFAULT || LA123_25 == SQL92_RESERVED_DISTINCT || ((LA123_25 >= SQL92_RESERVED_EXISTS) && (LA123_25 <= SQL92_RESERVED_FALSE)) || LA123_25 == SQL92_RESERVED_INTERSECT || LA123_25 == SQL92_RESERVED_IS || ((LA123_25 >= SQL92_RESERVED_NULL) && (LA123_25 <= SQL92_RESERVED_OF)) || LA123_25 == SQL92_RESERVED_OR || LA123_25 == SQL92_RESERVED_PRIOR || ((LA123_25 >= SQL92_RESERVED_TO) && (LA123_25 <= SQL92_RESERVED_UNION)) || ((LA123_25 >= UNSIGNED_INTEGER) && (LA123_25 <= VERTICAL_BAR))))
                                    		    		    		                                    {
                                    		    		    		                                        alt123=1;
                                    		    		    		                                    }
                                    		    		    		                                    else if ( (LA123_25 == REGULAR_ID))
                                    		    		    		                                    {
                                    		    		    		                                        {
                                    		    		    		                                            int LA123_27 = this->LA(11);
                                    		    		    		                                            if ( (LA123_27 == APPROXIMATE_NUM_LIT || LA123_27 == ASTERISK || LA123_27 == BINDVAR || ((LA123_27 >= CARRET_OPERATOR_PART) && (LA123_27 <= COLON)) || ((LA123_27 >= CONCATENATION_OP) && (LA123_27 <= DELIMITED_ID)) || ((LA123_27 >= EQUALS_OP) && (LA123_27 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_27 >= GREATER_THAN_OP) && (LA123_27 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_27 >= INTRODUCER) && (LA123_27 <= NATIONAL_CHAR_STRING_LIT)) || LA123_27 == NOT_EQUAL_OP || ((LA123_27 >= PERIOD) && (LA123_27 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_27 == PLSQL_NON_RESERVED_USING || LA123_27 == PLUS_SIGN || LA123_27 == SOLIDUS || LA123_27 == SQL92_RESERVED_ALL || ((LA123_27 >= SQL92_RESERVED_AND) && (LA123_27 <= SQL92_RESERVED_ANY)) || LA123_27 == SQL92_RESERVED_CASE || LA123_27 == SQL92_RESERVED_DATE || LA123_27 == SQL92_RESERVED_DEFAULT || LA123_27 == SQL92_RESERVED_DISTINCT || ((LA123_27 >= SQL92_RESERVED_EXISTS) && (LA123_27 <= SQL92_RESERVED_FALSE)) || LA123_27 == SQL92_RESERVED_INTERSECT || LA123_27 == SQL92_RESERVED_IS || ((LA123_27 >= SQL92_RESERVED_NULL) && (LA123_27 <= SQL92_RESERVED_OF)) || LA123_27 == SQL92_RESERVED_OR || LA123_27 == SQL92_RESERVED_PRIOR || ((LA123_27 >= SQL92_RESERVED_TO) && (LA123_27 <= SQL92_RESERVED_UNION)) || ((LA123_27 >= UNSIGNED_INTEGER) && (LA123_27 <= VERTICAL_BAR))))
                                    		    		    		                                            {
                                    		    		    		                                                alt123=1;
                                    		    		    		                                            }
                                    		    		    		                                            else if ( (LA123_27 == REGULAR_ID))
                                    		    		    		                                            {
                                    		    		    		                                                {
                                    		    		    		                                                    int LA123_29 = this->LA(12);
                                    		    		    		                                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "EXTERNAL"))))
                                    		    		    		                                                    {
                                    		    		    		                                                        alt123=1;
                                    		    		    		                                                    }
                                    		    		    		                                                }
                                    		    		    		                                            }
                                    		    		    		                                        }
                                    		    		    		                                    }
                                    		    		    		                                }
                                    		    		    		                            }
                                    		    		    		                        }
                                    		    		    		                    }
                                    		    		    		                }
                                    		    		    		            }
                                    		    		    		        }
                                    		    		    		    }
                                    		    		    		}
                                    		    		    	}
                                    		    		        break;
                                    		    		}

                                    		    	}
                                    		        break;
                                    		    case SQL92_RESERVED_NOT:
                                    		    	{
                                    		    		{
                                    		    		    int LA123_10 = this->LA(5);
                                    		    		    if ( (LA123_10 == SQL92_RESERVED_BETWEEN || LA123_10 == SQL92_RESERVED_IN || LA123_10 == SQL92_RESERVED_LIKE))
                                    		    		    {
                                    		    		        alt123=1;
                                    		    		    }
                                    		    		    else if ( (LA123_10 == REGULAR_ID))
                                    		    		    {
                                    		    		        {
                                    		    		            int LA123_14 = this->LA(6);
                                    		    		            if ( (LA123_14 == APPROXIMATE_NUM_LIT || LA123_14 == BINDVAR || ((LA123_14 >= CHAR_STRING) && (LA123_14 <= COLON)) || LA123_14 == DELIMITED_ID || LA123_14 == EXACT_NUM_LIT || LA123_14 == INTRODUCER || LA123_14 == LEFT_PAREN || ((LA123_14 >= MINUS_SIGN) && (LA123_14 <= NATIONAL_CHAR_STRING_LIT)) || LA123_14 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA123_14 == PLUS_SIGN || LA123_14 == SQL92_RESERVED_ALL || LA123_14 == SQL92_RESERVED_ANY || LA123_14 == SQL92_RESERVED_CASE || LA123_14 == SQL92_RESERVED_DATE || LA123_14 == SQL92_RESERVED_DEFAULT || LA123_14 == SQL92_RESERVED_DISTINCT || ((LA123_14 >= SQL92_RESERVED_EXISTS) && (LA123_14 <= SQL92_RESERVED_FALSE)) || LA123_14 == SQL92_RESERVED_NULL || LA123_14 == SQL92_RESERVED_PRIOR || LA123_14 == SQL92_RESERVED_TRUE || LA123_14 == UNSIGNED_INTEGER))
                                    		    		            {
                                    		    		                alt123=1;
                                    		    		            }
                                    		    		            else if ( (LA123_14 == REGULAR_ID))
                                    		    		            {
                                    		    		                {
                                    		    		                    int LA123_18 = this->LA(7);
                                    		    		                    if ( (LA123_18 == APPROXIMATE_NUM_LIT || LA123_18 == ASTERISK || LA123_18 == BINDVAR || ((LA123_18 >= CARRET_OPERATOR_PART) && (LA123_18 <= COLON)) || ((LA123_18 >= CONCATENATION_OP) && (LA123_18 <= DELIMITED_ID)) || ((LA123_18 >= EQUALS_OP) && (LA123_18 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_18 >= GREATER_THAN_OP) && (LA123_18 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_18 >= INTRODUCER) && (LA123_18 <= NATIONAL_CHAR_STRING_LIT)) || LA123_18 == NOT_EQUAL_OP || ((LA123_18 >= PERIOD) && (LA123_18 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_18 == PLUS_SIGN || LA123_18 == SOLIDUS || LA123_18 == SQL92_RESERVED_ALL || ((LA123_18 >= SQL92_RESERVED_AND) && (LA123_18 <= SQL92_RESERVED_ANY)) || LA123_18 == SQL92_RESERVED_CASE || LA123_18 == SQL92_RESERVED_DATE || LA123_18 == SQL92_RESERVED_DEFAULT || LA123_18 == SQL92_RESERVED_DISTINCT || ((LA123_18 >= SQL92_RESERVED_EXISTS) && (LA123_18 <= SQL92_RESERVED_FALSE)) || LA123_18 == SQL92_RESERVED_IS || LA123_18 == SQL92_RESERVED_NULL || LA123_18 == SQL92_RESERVED_OR || LA123_18 == SQL92_RESERVED_PRIOR || LA123_18 == SQL92_RESERVED_TRUE || ((LA123_18 >= UNSIGNED_INTEGER) && (LA123_18 <= VERTICAL_BAR))))
                                    		    		                    {
                                    		    		                        alt123=1;
                                    		    		                    }
                                    		    		                    else if ( (LA123_18 == REGULAR_ID))
                                    		    		                    {
                                    		    		                        {
                                    		    		                            int LA123_22 = this->LA(8);
                                    		    		                            if ( (LA123_22 == APPROXIMATE_NUM_LIT || LA123_22 == ASTERISK || LA123_22 == BINDVAR || ((LA123_22 >= CARRET_OPERATOR_PART) && (LA123_22 <= COLON)) || ((LA123_22 >= CONCATENATION_OP) && (LA123_22 <= DELIMITED_ID)) || ((LA123_22 >= EQUALS_OP) && (LA123_22 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_22 >= GREATER_THAN_OP) && (LA123_22 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_22 >= INTRODUCER) && (LA123_22 <= NATIONAL_CHAR_STRING_LIT)) || LA123_22 == NOT_EQUAL_OP || ((LA123_22 >= PERIOD) && (LA123_22 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_22 == PLUS_SIGN || LA123_22 == SOLIDUS || LA123_22 == SQL92_RESERVED_ALL || ((LA123_22 >= SQL92_RESERVED_AND) && (LA123_22 <= SQL92_RESERVED_ANY)) || LA123_22 == SQL92_RESERVED_CASE || LA123_22 == SQL92_RESERVED_DATE || LA123_22 == SQL92_RESERVED_DEFAULT || LA123_22 == SQL92_RESERVED_DISTINCT || ((LA123_22 >= SQL92_RESERVED_EXISTS) && (LA123_22 <= SQL92_RESERVED_FALSE)) || LA123_22 == SQL92_RESERVED_INTERSECT || LA123_22 == SQL92_RESERVED_IS || ((LA123_22 >= SQL92_RESERVED_NULL) && (LA123_22 <= SQL92_RESERVED_OF)) || LA123_22 == SQL92_RESERVED_OR || LA123_22 == SQL92_RESERVED_PRIOR || ((LA123_22 >= SQL92_RESERVED_TO) && (LA123_22 <= SQL92_RESERVED_UNION)) || ((LA123_22 >= UNSIGNED_INTEGER) && (LA123_22 <= VERTICAL_BAR))))
                                    		    		                            {
                                    		    		                                alt123=1;
                                    		    		                            }
                                    		    		                            else if ( (LA123_22 == REGULAR_ID))
                                    		    		                            {
                                    		    		                                {
                                    		    		                                    int LA123_25 = this->LA(9);
                                    		    		                                    if ( (LA123_25 == APPROXIMATE_NUM_LIT || LA123_25 == ASTERISK || LA123_25 == BINDVAR || ((LA123_25 >= CARRET_OPERATOR_PART) && (LA123_25 <= COLON)) || ((LA123_25 >= CONCATENATION_OP) && (LA123_25 <= DELIMITED_ID)) || ((LA123_25 >= EQUALS_OP) && (LA123_25 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_25 >= GREATER_THAN_OP) && (LA123_25 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_25 >= INTRODUCER) && (LA123_25 <= NATIONAL_CHAR_STRING_LIT)) || LA123_25 == NOT_EQUAL_OP || ((LA123_25 >= PERIOD) && (LA123_25 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_25 == PLSQL_NON_RESERVED_USING || LA123_25 == PLUS_SIGN || LA123_25 == SOLIDUS || LA123_25 == SQL92_RESERVED_ALL || ((LA123_25 >= SQL92_RESERVED_AND) && (LA123_25 <= SQL92_RESERVED_ANY)) || LA123_25 == SQL92_RESERVED_CASE || LA123_25 == SQL92_RESERVED_DATE || LA123_25 == SQL92_RESERVED_DEFAULT || LA123_25 == SQL92_RESERVED_DISTINCT || ((LA123_25 >= SQL92_RESERVED_EXISTS) && (LA123_25 <= SQL92_RESERVED_FALSE)) || LA123_25 == SQL92_RESERVED_INTERSECT || LA123_25 == SQL92_RESERVED_IS || ((LA123_25 >= SQL92_RESERVED_NULL) && (LA123_25 <= SQL92_RESERVED_OF)) || LA123_25 == SQL92_RESERVED_OR || LA123_25 == SQL92_RESERVED_PRIOR || ((LA123_25 >= SQL92_RESERVED_TO) && (LA123_25 <= SQL92_RESERVED_UNION)) || ((LA123_25 >= UNSIGNED_INTEGER) && (LA123_25 <= VERTICAL_BAR))))
                                    		    		                                    {
                                    		    		                                        alt123=1;
                                    		    		                                    }
                                    		    		                                    else if ( (LA123_25 == REGULAR_ID))
                                    		    		                                    {
                                    		    		                                        {
                                    		    		                                            int LA123_27 = this->LA(10);
                                    		    		                                            if ( (LA123_27 == APPROXIMATE_NUM_LIT || LA123_27 == ASTERISK || LA123_27 == BINDVAR || ((LA123_27 >= CARRET_OPERATOR_PART) && (LA123_27 <= COLON)) || ((LA123_27 >= CONCATENATION_OP) && (LA123_27 <= DELIMITED_ID)) || ((LA123_27 >= EQUALS_OP) && (LA123_27 <= EXCLAMATION_OPERATOR_PART)) || ((LA123_27 >= GREATER_THAN_OP) && (LA123_27 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA123_27 >= INTRODUCER) && (LA123_27 <= NATIONAL_CHAR_STRING_LIT)) || LA123_27 == NOT_EQUAL_OP || ((LA123_27 >= PERIOD) && (LA123_27 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA123_27 == PLSQL_NON_RESERVED_USING || LA123_27 == PLUS_SIGN || LA123_27 == SOLIDUS || LA123_27 == SQL92_RESERVED_ALL || ((LA123_27 >= SQL92_RESERVED_AND) && (LA123_27 <= SQL92_RESERVED_ANY)) || LA123_27 == SQL92_RESERVED_CASE || LA123_27 == SQL92_RESERVED_DATE || LA123_27 == SQL92_RESERVED_DEFAULT || LA123_27 == SQL92_RESERVED_DISTINCT || ((LA123_27 >= SQL92_RESERVED_EXISTS) && (LA123_27 <= SQL92_RESERVED_FALSE)) || LA123_27 == SQL92_RESERVED_INTERSECT || LA123_27 == SQL92_RESERVED_IS || ((LA123_27 >= SQL92_RESERVED_NULL) && (LA123_27 <= SQL92_RESERVED_OF)) || LA123_27 == SQL92_RESERVED_OR || LA123_27 == SQL92_RESERVED_PRIOR || ((LA123_27 >= SQL92_RESERVED_TO) && (LA123_27 <= SQL92_RESERVED_UNION)) || ((LA123_27 >= UNSIGNED_INTEGER) && (LA123_27 <= VERTICAL_BAR))))
                                    		    		                                            {
                                    		    		                                                alt123=1;
                                    		    		                                            }
                                    		    		                                            else if ( (LA123_27 == REGULAR_ID))
                                    		    		                                            {
                                    		    		                                                {
                                    		    		                                                    int LA123_29 = this->LA(11);
                                    		    		                                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "EXTERNAL"))))
                                    		    		                                                    {
                                    		    		                                                        alt123=1;
                                    		    		                                                    }
                                    		    		                                                }
                                    		    		                                            }
                                    		    		                                        }
                                    		    		                                    }
                                    		    		                                }
                                    		    		                            }
                                    		    		                        }
                                    		    		                    }
                                    		    		                }
                                    		    		            }
                                    		    		        }
                                    		    		    }
                                    		    		}
                                    		    	}
                                    		        break;
                                    		}

                                    	}
                                        break;
                                }

                            }
                        }
                    }
                }
                switch (alt123)
                {
            	case 1:
            	    // PLSQLParser.g:484:9: sqlj_object_type
            	    {
            	        this->followPush(FOLLOW_sqlj_object_type_in_object_type_def3875);
            	        sqlj_object_type();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleobject_type_defEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:485:9: ( LEFT_PAREN object_member_spec ( COMMA object_member_spec )* RIGHT_PAREN )?
            {
                int alt125=2;
                {
                    int LA125_0 = this->LA(1);
                    if ( (LA125_0 == LEFT_PAREN))
                    {
                        alt125=1;
                    }
                }
                switch (alt125)
                {
            	case 1:
            	    // PLSQLParser.g:485:10: LEFT_PAREN object_member_spec ( COMMA object_member_spec )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_object_type_def3887);
            	        if  (this->hasException())
            	        {
            	            goto ruleobject_type_defEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_object_member_spec_in_object_type_def3889);
            	        object_member_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleobject_type_defEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:485:40: ( COMMA object_member_spec )*

            	        for (;;)
            	        {
            	            int alt124=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA124_0 = this->LA(1);
            	                if ( (LA124_0 == COMMA))
            	                {
            	                    alt124=1;
            	                }

            	            }
            	            switch (alt124)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:485:41: COMMA object_member_spec
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_object_type_def3892);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleobject_type_defEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_object_member_spec_in_object_type_def3894);
            	        	        object_member_spec();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleobject_type_defEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop124;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop124: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_object_type_def3898);
            	        if  (this->hasException())
            	        {
            	            goto ruleobject_type_defEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:486:9: ( modifier_clause )*

            for (;;)
            {
                int alt126=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA126_0 = this->LA(1);
                    if ( (LA126_0 == SQL92_RESERVED_NOT))
                    {
                        alt126=1;
                    }
                    else if ( (LA126_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FINAL")))||((equalsIgnoreCase(LT(1)->getText(), "OVERRIDING")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))))))
                    {
                        alt126=1;
                    }

                }
                switch (alt126)
                {
            	case 1:
            	    // PLSQLParser.g:486:9: modifier_clause
            	    {
            	        this->followPush(FOLLOW_modifier_clause_in_object_type_def3910);
            	        modifier_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleobject_type_defEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop126;	/* break out of the loop */
            	    break;
                }
            }
            loop126: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleobject_type_defEx; /* Prevent compiler warnings */
    ruleobject_type_defEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end object_type_def */

/**
 * $ANTLR start object_as_part
 * PLSQLParser.g:489:1: object_as_part : ( is_key | as_key ) ( object_key | varray_type_def | nested_table_type_def ) ;
 */
void
PLSQLParser::object_as_part()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:490:5: ( ( is_key | as_key ) ( object_key | varray_type_def | nested_table_type_def ) )
        // PLSQLParser.g:490:10: ( is_key | as_key ) ( object_key | varray_type_def | nested_table_type_def )
        {
            // PLSQLParser.g:490:10: ( is_key | as_key )
            {
                int alt127=2;
                {
                    int LA127_0 = this->LA(1);
                    if ( (LA127_0 == SQL92_RESERVED_IS))
                    {
                        alt127=1;
                    }
                    else if ( (LA127_0 == SQL92_RESERVED_AS))
                    {
                        alt127=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 127 );
                        ex->set_state( 0 );


                        goto ruleobject_as_partEx;

                    }
                }
                switch (alt127)
                {
            	case 1:
            	    // PLSQLParser.g:490:11: is_key
            	    {
            	        this->followPush(FOLLOW_is_key_in_object_as_part3932);
            	        is_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleobject_as_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:490:18: as_key
            	    {
            	        this->followPush(FOLLOW_as_key_in_object_as_part3934);
            	        as_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleobject_as_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:490:26: ( object_key | varray_type_def | nested_table_type_def )
            {
                int alt128=3;
                {
                    int LA128_0 = this->LA(1);
                    if ( (LA128_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "VARRAY")))||((equalsIgnoreCase(LT(1)->getText(), "OBJECT")))||((equalsIgnoreCase(LT(1)->getText(), "VARYING"))))))
                    {
                        {
                            int LA128_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "OBJECT"))))
                            {
                                alt128=1;
                            }
                            else if ( ((((equalsIgnoreCase(LT(1)->getText(), "VARRAY")))||((equalsIgnoreCase(LT(1)->getText(), "VARYING"))))))
                            {
                                alt128=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 128 );
                                ex->set_state( 1 );


                                goto ruleobject_as_partEx;

                            }
                        }
                    }
                    else if ( (LA128_0 == SQL92_RESERVED_TABLE))
                    {
                        alt128=3;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 128 );
                        ex->set_state( 0 );


                        goto ruleobject_as_partEx;

                    }
                }
                switch (alt128)
                {
            	case 1:
            	    // PLSQLParser.g:490:27: object_key
            	    {
            	        this->followPush(FOLLOW_object_key_in_object_as_part3938);
            	        object_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleobject_as_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:490:38: varray_type_def
            	    {
            	        this->followPush(FOLLOW_varray_type_def_in_object_as_part3940);
            	        varray_type_def();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleobject_as_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLParser.g:490:54: nested_table_type_def
            	    {
            	        this->followPush(FOLLOW_nested_table_type_def_in_object_as_part3942);
            	        nested_table_type_def();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleobject_as_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleobject_as_partEx; /* Prevent compiler warnings */
    ruleobject_as_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end object_as_part */

/**
 * $ANTLR start object_under_part
 * PLSQLParser.g:493:1: object_under_part : under_key type_spec ;
 */
void
PLSQLParser::object_under_part()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:494:5: ( under_key type_spec )
        // PLSQLParser.g:494:10: under_key type_spec
        {
            this->followPush(FOLLOW_under_key_in_object_under_part3963);
            under_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleobject_under_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_spec_in_object_under_part3965);
            type_spec();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleobject_under_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleobject_under_partEx; /* Prevent compiler warnings */
    ruleobject_under_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end object_under_part */

/**
 * $ANTLR start nested_table_type_def
 * PLSQLParser.g:497:1: nested_table_type_def : table_key of_key type_spec ( not_key null_key )? ;
 */
void
PLSQLParser::nested_table_type_def()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:498:5: ( table_key of_key type_spec ( not_key null_key )? )
        // PLSQLParser.g:498:10: table_key of_key type_spec ( not_key null_key )?
        {
            this->followPush(FOLLOW_table_key_in_nested_table_type_def3985);
            table_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulenested_table_type_defEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_of_key_in_nested_table_type_def3987);
            of_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulenested_table_type_defEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_spec_in_nested_table_type_def3989);
            type_spec();

            this->followPop();
            if  (this->hasException())
            {
                goto rulenested_table_type_defEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:499:9: ( not_key null_key )?
            {
                int alt129=2;
                {
                    int LA129_0 = this->LA(1);
                    if ( (LA129_0 == SQL92_RESERVED_NOT))
                    {
                        {
                            int LA129_1 = this->LA(2);
                            if ( (LA129_1 == SQL92_RESERVED_NULL))
                            {
                                alt129=1;
                            }
                        }
                    }
                }
                switch (alt129)
                {
            	case 1:
            	    // PLSQLParser.g:499:10: not_key null_key
            	    {
            	        this->followPush(FOLLOW_not_key_in_nested_table_type_def4000);
            	        not_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulenested_table_type_defEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_null_key_in_nested_table_type_def4002);
            	        null_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulenested_table_type_defEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulenested_table_type_defEx; /* Prevent compiler warnings */
    rulenested_table_type_defEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nested_table_type_def */

/**
 * $ANTLR start sqlj_object_type
 * PLSQLParser.g:502:1: sqlj_object_type : external_key name_key expression language_key java_key using_key ( sqldata_key | customdatum_key | oradata_key ) ;
 */
void
PLSQLParser::sqlj_object_type()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:503:5: ( external_key name_key expression language_key java_key using_key ( sqldata_key | customdatum_key | oradata_key ) )
        // PLSQLParser.g:503:10: external_key name_key expression language_key java_key using_key ( sqldata_key | customdatum_key | oradata_key )
        {
            this->followPush(FOLLOW_external_key_in_sqlj_object_type4024);
            external_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesqlj_object_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_name_key_in_sqlj_object_type4026);
            name_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesqlj_object_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_sqlj_object_type4028);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesqlj_object_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_language_key_in_sqlj_object_type4030);
            language_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesqlj_object_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_java_key_in_sqlj_object_type4032);
            java_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesqlj_object_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_using_key_in_sqlj_object_type4034);
            using_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesqlj_object_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:503:75: ( sqldata_key | customdatum_key | oradata_key )
            {
                int alt130=3;
                {
                    int LA130_0 = this->LA(1);
                    if ( (LA130_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "ORADATA")))||((equalsIgnoreCase(LT(1)->getText(), "CUSTOMDATUM")))||((equalsIgnoreCase(LT(1)->getText(), "SQLDATA"))))))
                    {
                        {
                            int LA130_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "SQLDATA"))))
                            {
                                alt130=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "CUSTOMDATUM"))))
                            {
                                alt130=2;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "ORADATA"))))
                            {
                                alt130=3;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 130 );
                                ex->set_state( 1 );


                                goto rulesqlj_object_typeEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 130 );
                        ex->set_state( 0 );


                        goto rulesqlj_object_typeEx;

                    }
                }
                switch (alt130)
                {
            	case 1:
            	    // PLSQLParser.g:503:76: sqldata_key
            	    {
            	        this->followPush(FOLLOW_sqldata_key_in_sqlj_object_type4037);
            	        sqldata_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesqlj_object_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:503:88: customdatum_key
            	    {
            	        this->followPush(FOLLOW_customdatum_key_in_sqlj_object_type4039);
            	        customdatum_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesqlj_object_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLParser.g:503:104: oradata_key
            	    {
            	        this->followPush(FOLLOW_oradata_key_in_sqlj_object_type4041);
            	        oradata_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesqlj_object_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesqlj_object_typeEx; /* Prevent compiler warnings */
    rulesqlj_object_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sqlj_object_type */

/**
 * $ANTLR start type_body
 * PLSQLParser.g:506:1: type_body : body_key type_name ( is_key | as_key ) type_body_elements ( COMMA type_body_elements )* end_key ;
 */
void
PLSQLParser::type_body()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:507:5: ( body_key type_name ( is_key | as_key ) type_body_elements ( COMMA type_body_elements )* end_key )
        // PLSQLParser.g:507:10: body_key type_name ( is_key | as_key ) type_body_elements ( COMMA type_body_elements )* end_key
        {
            this->followPush(FOLLOW_body_key_in_type_body4062);
            body_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletype_bodyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_name_in_type_body4064);
            type_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletype_bodyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:508:9: ( is_key | as_key )
            {
                int alt131=2;
                {
                    int LA131_0 = this->LA(1);
                    if ( (LA131_0 == SQL92_RESERVED_IS))
                    {
                        alt131=1;
                    }
                    else if ( (LA131_0 == SQL92_RESERVED_AS))
                    {
                        alt131=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 131 );
                        ex->set_state( 0 );


                        goto ruletype_bodyEx;

                    }
                }
                switch (alt131)
                {
            	case 1:
            	    // PLSQLParser.g:508:10: is_key
            	    {
            	        this->followPush(FOLLOW_is_key_in_type_body4075);
            	        is_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:508:17: as_key
            	    {
            	        this->followPush(FOLLOW_as_key_in_type_body4077);
            	        as_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_type_body_elements_in_type_body4080);
            type_body_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletype_bodyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:508:44: ( COMMA type_body_elements )*

            for (;;)
            {
                int alt132=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA132_0 = this->LA(1);
                    if ( (LA132_0 == COMMA))
                    {
                        alt132=1;
                    }

                }
                switch (alt132)
                {
            	case 1:
            	    // PLSQLParser.g:508:45: COMMA type_body_elements
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_type_body4083);
            	        if  (this->hasException())
            	        {
            	            goto ruletype_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_type_body_elements_in_type_body4085);
            	        type_body_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_bodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop132;	/* break out of the loop */
            	    break;
                }
            }
            loop132: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_end_key_in_type_body4097);
            end_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletype_bodyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletype_bodyEx; /* Prevent compiler warnings */
    ruletype_bodyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end type_body */

/**
 * $ANTLR start type_body_elements
 * PLSQLParser.g:512:1: type_body_elements : ( map_order_func_declaration | subprog_decl_in_type );
 */
void
PLSQLParser::type_body_elements()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:513:5: ( map_order_func_declaration | subprog_decl_in_type )

            ANTLR_UINT32 alt133;

            alt133=2;

            {
                int LA133_0 = this->LA(1);
                if ( (LA133_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER")))||((equalsIgnoreCase(LT(1)->getText(), "MAP"))))))
                {
                    {
                        int LA133_1 = this->LA(2);
                        if ( ((equalsIgnoreCase(LT(1)->getText(), "MAP"))))
                        {
                            alt133=1;
                        }
                        else if ( ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))))
                        {
                            alt133=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 133 );
                            ex->set_state( 1 );


                            goto ruletype_body_elementsEx;

                        }
                    }
                }
                else if ( (LA133_0 == SQL92_RESERVED_ORDER))
                {
                    alt133=1;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 133 );
                    ex->set_state( 0 );


                    goto ruletype_body_elementsEx;

                }
            }
            switch (alt133)
            {
        	case 1:
        	    // PLSQLParser.g:513:10: map_order_func_declaration
        	    {
        	        this->followPush(FOLLOW_map_order_func_declaration_in_type_body_elements4117);
        	        map_order_func_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletype_body_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:514:10: subprog_decl_in_type
        	    {
        	        this->followPush(FOLLOW_subprog_decl_in_type_in_type_body_elements4128);
        	        subprog_decl_in_type();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletype_body_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruletype_body_elementsEx; /* Prevent compiler warnings */
    ruletype_body_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end type_body_elements */

/**
 * $ANTLR start map_order_func_declaration
 * PLSQLParser.g:517:1: map_order_func_declaration : ( map_key | order_key ) member_key func_decl_in_type ;
 */
void
PLSQLParser::map_order_func_declaration()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:518:5: ( ( map_key | order_key ) member_key func_decl_in_type )
        // PLSQLParser.g:518:10: ( map_key | order_key ) member_key func_decl_in_type
        {
            // PLSQLParser.g:518:10: ( map_key | order_key )
            {
                int alt134=2;
                {
                    int LA134_0 = this->LA(1);
                    if ( (LA134_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "MAP"))))
                    {
                        alt134=1;
                    }
                    else if ( (LA134_0 == SQL92_RESERVED_ORDER))
                    {
                        alt134=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 134 );
                        ex->set_state( 0 );


                        goto rulemap_order_func_declarationEx;

                    }
                }
                switch (alt134)
                {
            	case 1:
            	    // PLSQLParser.g:518:11: map_key
            	    {
            	        this->followPush(FOLLOW_map_key_in_map_order_func_declaration4149);
            	        map_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemap_order_func_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:518:19: order_key
            	    {
            	        this->followPush(FOLLOW_order_key_in_map_order_func_declaration4151);
            	        order_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemap_order_func_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_member_key_in_map_order_func_declaration4154);
            member_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemap_order_func_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_func_decl_in_type_in_map_order_func_declaration4156);
            func_decl_in_type();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemap_order_func_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemap_order_func_declarationEx; /* Prevent compiler warnings */
    rulemap_order_func_declarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end map_order_func_declaration */

/**
 * $ANTLR start subprog_decl_in_type
 * PLSQLParser.g:521:1: subprog_decl_in_type : ( member_key | static_key ) ( proc_decl_in_type | func_decl_in_type | constructor_declaration ) ;
 */
void
PLSQLParser::subprog_decl_in_type()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:522:5: ( ( member_key | static_key ) ( proc_decl_in_type | func_decl_in_type | constructor_declaration ) )
        // PLSQLParser.g:522:10: ( member_key | static_key ) ( proc_decl_in_type | func_decl_in_type | constructor_declaration )
        {
            // PLSQLParser.g:522:10: ( member_key | static_key )
            {
                int alt135=2;
                {
                    int LA135_0 = this->LA(1);
                    if ( (LA135_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))))
                    {
                        {
                            int LA135_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))
                            {
                                alt135=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "STATIC"))))
                            {
                                alt135=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 135 );
                                ex->set_state( 1 );


                                goto rulesubprog_decl_in_typeEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 135 );
                        ex->set_state( 0 );


                        goto rulesubprog_decl_in_typeEx;

                    }
                }
                switch (alt135)
                {
            	case 1:
            	    // PLSQLParser.g:522:11: member_key
            	    {
            	        this->followPush(FOLLOW_member_key_in_subprog_decl_in_type4177);
            	        member_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubprog_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:522:22: static_key
            	    {
            	        this->followPush(FOLLOW_static_key_in_subprog_decl_in_type4179);
            	        static_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubprog_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:523:5: ( proc_decl_in_type | func_decl_in_type | constructor_declaration )
            {
                int alt136=3;
                {
                    int LA136_0 = this->LA(1);
                    if ( (LA136_0 == SQL92_RESERVED_PROCEDURE))
                    {
                        alt136=1;
                    }
                    else if ( (LA136_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FINAL")))||((equalsIgnoreCase(LT(1)->getText(), "CONSTRUCTOR")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE")))||((equalsIgnoreCase(LT(1)->getText(), "FUNCTION"))))))
                    {
                        {
                            int LA136_2 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "FUNCTION"))))
                            {
                                alt136=2;
                            }
                            else if ( ((((equalsIgnoreCase(LT(1)->getText(), "FINAL")))||((equalsIgnoreCase(LT(1)->getText(), "CONSTRUCTOR")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))))))
                            {
                                alt136=3;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 136 );
                                ex->set_state( 2 );


                                goto rulesubprog_decl_in_typeEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 136 );
                        ex->set_state( 0 );


                        goto rulesubprog_decl_in_typeEx;

                    }
                }
                switch (alt136)
                {
            	case 1:
            	    // PLSQLParser.g:523:10: proc_decl_in_type
            	    {
            	        this->followPush(FOLLOW_proc_decl_in_type_in_subprog_decl_in_type4191);
            	        proc_decl_in_type();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubprog_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:524:10: func_decl_in_type
            	    {
            	        this->followPush(FOLLOW_func_decl_in_type_in_subprog_decl_in_type4202);
            	        func_decl_in_type();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubprog_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLParser.g:525:10: constructor_declaration
            	    {
            	        this->followPush(FOLLOW_constructor_declaration_in_subprog_decl_in_type4213);
            	        constructor_declaration();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubprog_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubprog_decl_in_typeEx; /* Prevent compiler warnings */
    rulesubprog_decl_in_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end subprog_decl_in_type */

/**
 * $ANTLR start proc_decl_in_type
 * PLSQLParser.g:528:1: proc_decl_in_type : procedure_key procedure_name LEFT_PAREN type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN ( is_key | as_key ) ( call_spec | ( declare_key )? ( declare_spec )* body SEMICOLON ) ;
 */
void
PLSQLParser::proc_decl_in_type()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:529:5: ( procedure_key procedure_name LEFT_PAREN type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN ( is_key | as_key ) ( call_spec | ( declare_key )? ( declare_spec )* body SEMICOLON ) )
        // PLSQLParser.g:529:10: procedure_key procedure_name LEFT_PAREN type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN ( is_key | as_key ) ( call_spec | ( declare_key )? ( declare_spec )* body SEMICOLON )
        {
            this->followPush(FOLLOW_procedure_key_in_proc_decl_in_type4234);
            procedure_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleproc_decl_in_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_procedure_name_in_proc_decl_in_type4236);
            procedure_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleproc_decl_in_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_proc_decl_in_type4246);
            if  (this->hasException())
            {
                goto ruleproc_decl_in_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_elements_parameter_in_proc_decl_in_type4248);
            type_elements_parameter();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleproc_decl_in_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:530:44: ( COMMA type_elements_parameter )*

            for (;;)
            {
                int alt137=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA137_0 = this->LA(1);
                    if ( (LA137_0 == COMMA))
                    {
                        alt137=1;
                    }

                }
                switch (alt137)
                {
            	case 1:
            	    // PLSQLParser.g:530:45: COMMA type_elements_parameter
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_proc_decl_in_type4251);
            	        if  (this->hasException())
            	        {
            	            goto ruleproc_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_type_elements_parameter_in_proc_decl_in_type4253);
            	        type_elements_parameter();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleproc_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop137;	/* break out of the loop */
            	    break;
                }
            }
            loop137: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_proc_decl_in_type4257);
            if  (this->hasException())
            {
                goto ruleproc_decl_in_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:531:9: ( is_key | as_key )
            {
                int alt138=2;
                {
                    int LA138_0 = this->LA(1);
                    if ( (LA138_0 == SQL92_RESERVED_IS))
                    {
                        alt138=1;
                    }
                    else if ( (LA138_0 == SQL92_RESERVED_AS))
                    {
                        alt138=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 138 );
                        ex->set_state( 0 );


                        goto ruleproc_decl_in_typeEx;

                    }
                }
                switch (alt138)
                {
            	case 1:
            	    // PLSQLParser.g:531:10: is_key
            	    {
            	        this->followPush(FOLLOW_is_key_in_proc_decl_in_type4268);
            	        is_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleproc_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:531:17: as_key
            	    {
            	        this->followPush(FOLLOW_as_key_in_proc_decl_in_type4270);
            	        as_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleproc_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:532:13: ( call_spec | ( declare_key )? ( declare_spec )* body SEMICOLON )
            {
                int alt141=2;
                {
                    int LA141_0 = this->LA(1);
                    if ( (LA141_0 == REGULAR_ID))
                    {
                        {
                            int LA141_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "LANGUAGE"))))
                            {
                                alt141=1;
                            }
                            else if ( (true))
                            {
                                alt141=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 141 );
                                ex->set_state( 1 );


                                goto ruleproc_decl_in_typeEx;

                            }
                        }
                    }
                    else if ( (LA141_0 == BINDVAR || LA141_0 == COLON || LA141_0 == DELIMITED_ID || LA141_0 == INTRODUCER || LA141_0 == SQL92_RESERVED_BEGIN || LA141_0 == SQL92_RESERVED_CREATE || LA141_0 == SQL92_RESERVED_CURSOR || LA141_0 == SQL92_RESERVED_DECLARE || LA141_0 == SQL92_RESERVED_PROCEDURE))
                    {
                        alt141=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 141 );
                        ex->set_state( 0 );


                        goto ruleproc_decl_in_typeEx;

                    }
                }
                switch (alt141)
                {
            	case 1:
            	    // PLSQLParser.g:532:14: call_spec
            	    {
            	        this->followPush(FOLLOW_call_spec_in_proc_decl_in_type4287);
            	        call_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleproc_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:532:24: ( declare_key )? ( declare_spec )* body SEMICOLON
            	    {
            	        // PLSQLParser.g:532:24: ( declare_key )?
            	        {
            	            int alt139=2;
            	            {
            	                int LA139_0 = this->LA(1);
            	                if ( (LA139_0 == SQL92_RESERVED_DECLARE))
            	                {
            	                    alt139=1;
            	                }
            	            }
            	            switch (alt139)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:532:24: declare_key
            	        	    {
            	        	        this->followPush(FOLLOW_declare_key_in_proc_decl_in_type4289);
            	        	        declare_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleproc_decl_in_typeEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQLParser.g:532:37: ( declare_spec )*

            	        for (;;)
            	        {
            	            int alt140=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA140_0 = this->LA(1);
            	                if ( (LA140_0 == BINDVAR || LA140_0 == COLON || LA140_0 == DELIMITED_ID || LA140_0 == INTRODUCER || LA140_0 == REGULAR_ID || LA140_0 == SQL92_RESERVED_CREATE || LA140_0 == SQL92_RESERVED_CURSOR || LA140_0 == SQL92_RESERVED_PROCEDURE))
            	                {
            	                    alt140=1;
            	                }

            	            }
            	            switch (alt140)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:532:37: declare_spec
            	        	    {
            	        	        this->followPush(FOLLOW_declare_spec_in_proc_decl_in_type4292);
            	        	        declare_spec();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleproc_decl_in_typeEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop140;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop140: ; /* Jump out to here if this rule does not match */


            	        this->followPush(FOLLOW_body_in_proc_decl_in_type4295);
            	        body();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleproc_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_proc_decl_in_type4297);
            	        if  (this->hasException())
            	        {
            	            goto ruleproc_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleproc_decl_in_typeEx; /* Prevent compiler warnings */
    ruleproc_decl_in_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end proc_decl_in_type */

/**
 * $ANTLR start func_decl_in_type
 * PLSQLParser.g:535:1: func_decl_in_type : function_key function_name ( LEFT_PAREN type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN )? return_key type_spec ( is_key | as_key ) ( call_spec | ( declare_key )? ( declare_spec )* body SEMICOLON ) ;
 */
void
PLSQLParser::func_decl_in_type()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:536:5: ( function_key function_name ( LEFT_PAREN type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN )? return_key type_spec ( is_key | as_key ) ( call_spec | ( declare_key )? ( declare_spec )* body SEMICOLON ) )
        // PLSQLParser.g:536:10: function_key function_name ( LEFT_PAREN type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN )? return_key type_spec ( is_key | as_key ) ( call_spec | ( declare_key )? ( declare_spec )* body SEMICOLON )
        {
            this->followPush(FOLLOW_function_key_in_func_decl_in_type4318);
            function_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunc_decl_in_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_function_name_in_func_decl_in_type4320);
            function_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunc_decl_in_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:537:9: ( LEFT_PAREN type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN )?
            {
                int alt143=2;
                {
                    int LA143_0 = this->LA(1);
                    if ( (LA143_0 == LEFT_PAREN))
                    {
                        alt143=1;
                    }
                }
                switch (alt143)
                {
            	case 1:
            	    // PLSQLParser.g:537:10: LEFT_PAREN type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_func_decl_in_type4332);
            	        if  (this->hasException())
            	        {
            	            goto rulefunc_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_type_elements_parameter_in_func_decl_in_type4334);
            	        type_elements_parameter();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunc_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:537:45: ( COMMA type_elements_parameter )*

            	        for (;;)
            	        {
            	            int alt142=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA142_0 = this->LA(1);
            	                if ( (LA142_0 == COMMA))
            	                {
            	                    alt142=1;
            	                }

            	            }
            	            switch (alt142)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:537:46: COMMA type_elements_parameter
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_func_decl_in_type4337);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunc_decl_in_typeEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_type_elements_parameter_in_func_decl_in_type4339);
            	        	        type_elements_parameter();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunc_decl_in_typeEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop142;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop142: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_func_decl_in_type4343);
            	        if  (this->hasException())
            	        {
            	            goto rulefunc_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_return_key_in_func_decl_in_type4356);
            return_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunc_decl_in_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_spec_in_func_decl_in_type4358);
            type_spec();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunc_decl_in_typeEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:539:9: ( is_key | as_key )
            {
                int alt144=2;
                {
                    int LA144_0 = this->LA(1);
                    if ( (LA144_0 == SQL92_RESERVED_IS))
                    {
                        alt144=1;
                    }
                    else if ( (LA144_0 == SQL92_RESERVED_AS))
                    {
                        alt144=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 144 );
                        ex->set_state( 0 );


                        goto rulefunc_decl_in_typeEx;

                    }
                }
                switch (alt144)
                {
            	case 1:
            	    // PLSQLParser.g:539:10: is_key
            	    {
            	        this->followPush(FOLLOW_is_key_in_func_decl_in_type4369);
            	        is_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunc_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:539:17: as_key
            	    {
            	        this->followPush(FOLLOW_as_key_in_func_decl_in_type4371);
            	        as_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunc_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:540:13: ( call_spec | ( declare_key )? ( declare_spec )* body SEMICOLON )
            {
                int alt147=2;
                {
                    int LA147_0 = this->LA(1);
                    if ( (LA147_0 == REGULAR_ID))
                    {
                        {
                            int LA147_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "LANGUAGE"))))
                            {
                                alt147=1;
                            }
                            else if ( (true))
                            {
                                alt147=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 147 );
                                ex->set_state( 1 );


                                goto rulefunc_decl_in_typeEx;

                            }
                        }
                    }
                    else if ( (LA147_0 == BINDVAR || LA147_0 == COLON || LA147_0 == DELIMITED_ID || LA147_0 == INTRODUCER || LA147_0 == SQL92_RESERVED_BEGIN || LA147_0 == SQL92_RESERVED_CREATE || LA147_0 == SQL92_RESERVED_CURSOR || LA147_0 == SQL92_RESERVED_DECLARE || LA147_0 == SQL92_RESERVED_PROCEDURE))
                    {
                        alt147=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 147 );
                        ex->set_state( 0 );


                        goto rulefunc_decl_in_typeEx;

                    }
                }
                switch (alt147)
                {
            	case 1:
            	    // PLSQLParser.g:540:14: call_spec
            	    {
            	        this->followPush(FOLLOW_call_spec_in_func_decl_in_type4387);
            	        call_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunc_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:540:25: ( declare_key )? ( declare_spec )* body SEMICOLON
            	    {
            	        // PLSQLParser.g:540:25: ( declare_key )?
            	        {
            	            int alt145=2;
            	            {
            	                int LA145_0 = this->LA(1);
            	                if ( (LA145_0 == SQL92_RESERVED_DECLARE))
            	                {
            	                    alt145=1;
            	                }
            	            }
            	            switch (alt145)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:540:25: declare_key
            	        	    {
            	        	        this->followPush(FOLLOW_declare_key_in_func_decl_in_type4390);
            	        	        declare_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunc_decl_in_typeEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQLParser.g:540:38: ( declare_spec )*

            	        for (;;)
            	        {
            	            int alt146=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA146_0 = this->LA(1);
            	                if ( (LA146_0 == BINDVAR || LA146_0 == COLON || LA146_0 == DELIMITED_ID || LA146_0 == INTRODUCER || LA146_0 == REGULAR_ID || LA146_0 == SQL92_RESERVED_CREATE || LA146_0 == SQL92_RESERVED_CURSOR || LA146_0 == SQL92_RESERVED_PROCEDURE))
            	                {
            	                    alt146=1;
            	                }

            	            }
            	            switch (alt146)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:540:38: declare_spec
            	        	    {
            	        	        this->followPush(FOLLOW_declare_spec_in_func_decl_in_type4393);
            	        	        declare_spec();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefunc_decl_in_typeEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop146;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop146: ; /* Jump out to here if this rule does not match */


            	        this->followPush(FOLLOW_body_in_func_decl_in_type4396);
            	        body();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunc_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_func_decl_in_type4398);
            	        if  (this->hasException())
            	        {
            	            goto rulefunc_decl_in_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunc_decl_in_typeEx; /* Prevent compiler warnings */
    rulefunc_decl_in_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end func_decl_in_type */

/**
 * $ANTLR start constructor_declaration
 * PLSQLParser.g:543:1: constructor_declaration : ( final_key )? ( instantiable_key )? constructor_key function_key type_spec ( LEFT_PAREN ( self_key in_key out_key type_spec COMMA ) type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN )? return_key self_key as_key result_key ( is_key | as_key ) ( call_spec | ( declare_key )? ( declare_spec )* body SEMICOLON ) ;
 */
void
PLSQLParser::constructor_declaration()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:544:5: ( ( final_key )? ( instantiable_key )? constructor_key function_key type_spec ( LEFT_PAREN ( self_key in_key out_key type_spec COMMA ) type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN )? return_key self_key as_key result_key ( is_key | as_key ) ( call_spec | ( declare_key )? ( declare_spec )* body SEMICOLON ) )
        // PLSQLParser.g:544:10: ( final_key )? ( instantiable_key )? constructor_key function_key type_spec ( LEFT_PAREN ( self_key in_key out_key type_spec COMMA ) type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN )? return_key self_key as_key result_key ( is_key | as_key ) ( call_spec | ( declare_key )? ( declare_spec )* body SEMICOLON )
        {
            // PLSQLParser.g:544:10: ( final_key )?
            {
                int alt148=2;
                {
                    int LA148_0 = this->LA(1);
                    if ( (LA148_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FINAL")))||((equalsIgnoreCase(LT(1)->getText(), "CONSTRUCTOR")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))))))
                    {
                        {
                            int LA148_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "FINAL"))))
                            {
                                alt148=1;
                            }
                        }
                    }
                }
                switch (alt148)
                {
            	case 1:
            	    // PLSQLParser.g:544:10: final_key
            	    {
            	        this->followPush(FOLLOW_final_key_in_constructor_declaration4419);
            	        final_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructor_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:544:21: ( instantiable_key )?
            {
                int alt149=2;
                {
                    int LA149_0 = this->LA(1);
                    if ( (LA149_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "CONSTRUCTOR")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))))))
                    {
                        {
                            int LA149_1 = this->LA(2);
                            if ( (LA149_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "CONSTRUCTOR")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))))))
                            {
                                {
                                    int LA149_2 = this->LA(3);
                                    if ( (LA149_2 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "CONSTRUCTOR")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))))))
                                    {
                                        {
                                            int LA149_3 = this->LA(4);
                                            if ( ((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))))
                                            {
                                                alt149=1;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt149)
                {
            	case 1:
            	    // PLSQLParser.g:544:21: instantiable_key
            	    {
            	        this->followPush(FOLLOW_instantiable_key_in_constructor_declaration4422);
            	        instantiable_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructor_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_constructor_key_in_constructor_declaration4425);
            constructor_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstructor_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_function_key_in_constructor_declaration4427);
            function_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstructor_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_spec_in_constructor_declaration4429);
            type_spec();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstructor_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:545:9: ( LEFT_PAREN ( self_key in_key out_key type_spec COMMA ) type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN )?
            {
                int alt151=2;
                {
                    int LA151_0 = this->LA(1);
                    if ( (LA151_0 == LEFT_PAREN))
                    {
                        alt151=1;
                    }
                }
                switch (alt151)
                {
            	case 1:
            	    // PLSQLParser.g:545:10: LEFT_PAREN ( self_key in_key out_key type_spec COMMA ) type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_constructor_declaration4440);
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructor_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:545:21: ( self_key in_key out_key type_spec COMMA )
            	        // PLSQLParser.g:545:22: self_key in_key out_key type_spec COMMA
            	        {
            	            this->followPush(FOLLOW_self_key_in_constructor_declaration4443);
            	            self_key();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleconstructor_declarationEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	            this->followPush(FOLLOW_in_key_in_constructor_declaration4445);
            	            in_key();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleconstructor_declarationEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	            this->followPush(FOLLOW_out_key_in_constructor_declaration4447);
            	            out_key();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleconstructor_declarationEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	            this->followPush(FOLLOW_type_spec_in_constructor_declaration4449);
            	            type_spec();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleconstructor_declarationEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	             this->matchToken(COMMA, &FOLLOW_COMMA_in_constructor_declaration4451);
            	            if  (this->hasException())
            	            {
            	                goto ruleconstructor_declarationEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }


            	        this->followPush(FOLLOW_type_elements_parameter_in_constructor_declaration4454);
            	        type_elements_parameter();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructor_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:545:87: ( COMMA type_elements_parameter )*

            	        for (;;)
            	        {
            	            int alt150=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA150_0 = this->LA(1);
            	                if ( (LA150_0 == COMMA))
            	                {
            	                    alt150=1;
            	                }

            	            }
            	            switch (alt150)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:545:88: COMMA type_elements_parameter
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_constructor_declaration4457);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleconstructor_declarationEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_type_elements_parameter_in_constructor_declaration4459);
            	        	        type_elements_parameter();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleconstructor_declarationEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop150;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop150: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_constructor_declaration4464);
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructor_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_return_key_in_constructor_declaration4476);
            return_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstructor_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_self_key_in_constructor_declaration4478);
            self_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstructor_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_as_key_in_constructor_declaration4480);
            as_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstructor_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_result_key_in_constructor_declaration4482);
            result_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstructor_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:547:9: ( is_key | as_key )
            {
                int alt152=2;
                {
                    int LA152_0 = this->LA(1);
                    if ( (LA152_0 == SQL92_RESERVED_IS))
                    {
                        alt152=1;
                    }
                    else if ( (LA152_0 == SQL92_RESERVED_AS))
                    {
                        alt152=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 152 );
                        ex->set_state( 0 );


                        goto ruleconstructor_declarationEx;

                    }
                }
                switch (alt152)
                {
            	case 1:
            	    // PLSQLParser.g:547:10: is_key
            	    {
            	        this->followPush(FOLLOW_is_key_in_constructor_declaration4494);
            	        is_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructor_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:547:17: as_key
            	    {
            	        this->followPush(FOLLOW_as_key_in_constructor_declaration4496);
            	        as_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructor_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:548:13: ( call_spec | ( declare_key )? ( declare_spec )* body SEMICOLON )
            {
                int alt155=2;
                {
                    int LA155_0 = this->LA(1);
                    if ( (LA155_0 == REGULAR_ID))
                    {
                        {
                            int LA155_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "LANGUAGE"))))
                            {
                                alt155=1;
                            }
                            else if ( (true))
                            {
                                alt155=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 155 );
                                ex->set_state( 1 );


                                goto ruleconstructor_declarationEx;

                            }
                        }
                    }
                    else if ( (LA155_0 == BINDVAR || LA155_0 == COLON || LA155_0 == DELIMITED_ID || LA155_0 == INTRODUCER || LA155_0 == SQL92_RESERVED_BEGIN || LA155_0 == SQL92_RESERVED_CREATE || LA155_0 == SQL92_RESERVED_CURSOR || LA155_0 == SQL92_RESERVED_DECLARE || LA155_0 == SQL92_RESERVED_PROCEDURE))
                    {
                        alt155=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 155 );
                        ex->set_state( 0 );


                        goto ruleconstructor_declarationEx;

                    }
                }
                switch (alt155)
                {
            	case 1:
            	    // PLSQLParser.g:548:14: call_spec
            	    {
            	        this->followPush(FOLLOW_call_spec_in_constructor_declaration4513);
            	        call_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructor_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:548:25: ( declare_key )? ( declare_spec )* body SEMICOLON
            	    {
            	        // PLSQLParser.g:548:25: ( declare_key )?
            	        {
            	            int alt153=2;
            	            {
            	                int LA153_0 = this->LA(1);
            	                if ( (LA153_0 == SQL92_RESERVED_DECLARE))
            	                {
            	                    alt153=1;
            	                }
            	            }
            	            switch (alt153)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:548:25: declare_key
            	        	    {
            	        	        this->followPush(FOLLOW_declare_key_in_constructor_declaration4516);
            	        	        declare_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleconstructor_declarationEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQLParser.g:548:38: ( declare_spec )*

            	        for (;;)
            	        {
            	            int alt154=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA154_0 = this->LA(1);
            	                if ( (LA154_0 == BINDVAR || LA154_0 == COLON || LA154_0 == DELIMITED_ID || LA154_0 == INTRODUCER || LA154_0 == REGULAR_ID || LA154_0 == SQL92_RESERVED_CREATE || LA154_0 == SQL92_RESERVED_CURSOR || LA154_0 == SQL92_RESERVED_PROCEDURE))
            	                {
            	                    alt154=1;
            	                }

            	            }
            	            switch (alt154)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:548:38: declare_spec
            	        	    {
            	        	        this->followPush(FOLLOW_declare_spec_in_constructor_declaration4519);
            	        	        declare_spec();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleconstructor_declarationEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop154;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop154: ; /* Jump out to here if this rule does not match */


            	        this->followPush(FOLLOW_body_in_constructor_declaration4522);
            	        body();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructor_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_constructor_declaration4524);
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructor_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconstructor_declarationEx; /* Prevent compiler warnings */
    ruleconstructor_declarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end constructor_declaration */

/**
 * $ANTLR start modifier_clause
 * PLSQLParser.g:555:1: modifier_clause : ( not_key )? ( instantiable_key | final_key | overriding_key ) ;
 */
void
PLSQLParser::modifier_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:556:5: ( ( not_key )? ( instantiable_key | final_key | overriding_key ) )
        // PLSQLParser.g:556:10: ( not_key )? ( instantiable_key | final_key | overriding_key )
        {
            // PLSQLParser.g:556:10: ( not_key )?
            {
                int alt156=2;
                {
                    int LA156_0 = this->LA(1);
                    if ( (LA156_0 == SQL92_RESERVED_NOT))
                    {
                        alt156=1;
                    }
                }
                switch (alt156)
                {
            	case 1:
            	    // PLSQLParser.g:556:10: not_key
            	    {
            	        this->followPush(FOLLOW_not_key_in_modifier_clause4549);
            	        not_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodifier_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:556:19: ( instantiable_key | final_key | overriding_key )
            {
                int alt157=3;
                {
                    int LA157_0 = this->LA(1);
                    if ( (LA157_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FINAL")))||((equalsIgnoreCase(LT(1)->getText(), "OVERRIDING")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))))))
                    {
                        {
                            int LA157_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))))
                            {
                                alt157=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "FINAL"))))
                            {
                                alt157=2;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "OVERRIDING"))))
                            {
                                alt157=3;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 157 );
                                ex->set_state( 1 );


                                goto rulemodifier_clauseEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 157 );
                        ex->set_state( 0 );


                        goto rulemodifier_clauseEx;

                    }
                }
                switch (alt157)
                {
            	case 1:
            	    // PLSQLParser.g:556:20: instantiable_key
            	    {
            	        this->followPush(FOLLOW_instantiable_key_in_modifier_clause4553);
            	        instantiable_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodifier_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:556:37: final_key
            	    {
            	        this->followPush(FOLLOW_final_key_in_modifier_clause4555);
            	        final_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodifier_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLParser.g:556:47: overriding_key
            	    {
            	        this->followPush(FOLLOW_overriding_key_in_modifier_clause4557);
            	        overriding_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodifier_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodifier_clauseEx; /* Prevent compiler warnings */
    rulemodifier_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end modifier_clause */

/**
 * $ANTLR start object_member_spec
 * PLSQLParser.g:559:1: object_member_spec options {backtrack=true; } : ( id type_spec ( sqlj_object_type_attr )? | element_spec );
 */
void
PLSQLParser::object_member_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:562:6: ( id type_spec ( sqlj_object_type_attr )? | element_spec )

            ANTLR_UINT32 alt159;

            alt159=2;

            switch ( this->LA(1) )
            {
            case DELIMITED_ID:
            case INTRODUCER:
            	{
            		alt159=1;
            	}
                break;
            case REGULAR_ID:
            	{
            		{
            		    int LA159_2 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred35_PLSQLParser>() )))
            		    {
            		        alt159=1;
            		    }
            		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "FINAL")))||((equalsIgnoreCase(LT(1)->getText(), "CONSTRUCTOR")))||((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "OVERRIDING")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER")))||((equalsIgnoreCase(LT(1)->getText(), "MAP"))))))
            		    {
            		        alt159=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 159 );
            		        ex->set_state( 2 );


            		        goto ruleobject_member_specEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_NOT:
            case SQL92_RESERVED_ORDER:
            	{
            		alt159=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 159 );
                ex->set_state( 0 );


                goto ruleobject_member_specEx;

            }

            switch (alt159)
            {
        	case 1:
        	    // PLSQLParser.g:562:11: id type_spec ( sqlj_object_type_attr )?
        	    {
        	        this->followPush(FOLLOW_id_in_object_member_spec4586);
        	        id();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleobject_member_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_type_spec_in_object_member_spec4588);
        	        type_spec();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleobject_member_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLParser.g:562:24: ( sqlj_object_type_attr )?
        	        {
        	            int alt158=2;
        	            {
        	                int LA158_0 = this->LA(1);
        	                if ( (LA158_0 == REGULAR_ID))
        	                {
        	                    alt158=1;
        	                }
        	            }
        	            switch (alt158)
        	            {
        	        	case 1:
        	        	    // PLSQLParser.g:562:24: sqlj_object_type_attr
        	        	    {
        	        	        this->followPush(FOLLOW_sqlj_object_type_attr_in_object_member_spec4590);
        	        	        sqlj_object_type_attr();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleobject_member_specEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:563:10: element_spec
        	    {
        	        this->followPush(FOLLOW_element_spec_in_object_member_spec4602);
        	        element_spec();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleobject_member_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleobject_member_specEx; /* Prevent compiler warnings */
    ruleobject_member_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end object_member_spec */

/**
 * $ANTLR start sqlj_object_type_attr
 * PLSQLParser.g:566:1: sqlj_object_type_attr : external_key name_key expression ;
 */
void
PLSQLParser::sqlj_object_type_attr()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:567:5: ( external_key name_key expression )
        // PLSQLParser.g:567:10: external_key name_key expression
        {
            this->followPush(FOLLOW_external_key_in_sqlj_object_type_attr4622);
            external_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesqlj_object_type_attrEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_name_key_in_sqlj_object_type_attr4624);
            name_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesqlj_object_type_attrEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_sqlj_object_type_attr4626);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesqlj_object_type_attrEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesqlj_object_type_attrEx; /* Prevent compiler warnings */
    rulesqlj_object_type_attrEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sqlj_object_type_attr */

/**
 * $ANTLR start element_spec
 * PLSQLParser.g:570:1: element_spec : ( modifier_clause )? ( element_spec_options )+ ( COMMA pragma_clause )? ;
 */
void
PLSQLParser::element_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:571:5: ( ( modifier_clause )? ( element_spec_options )+ ( COMMA pragma_clause )? )
        // PLSQLParser.g:571:10: ( modifier_clause )? ( element_spec_options )+ ( COMMA pragma_clause )?
        {
            // PLSQLParser.g:571:10: ( modifier_clause )?
            {
                int alt160=2;
                {
                    int LA160_0 = this->LA(1);
                    if ( (LA160_0 == SQL92_RESERVED_NOT))
                    {
                        alt160=1;
                    }
                    else if ( (LA160_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FINAL")))||((equalsIgnoreCase(LT(1)->getText(), "CONSTRUCTOR")))||((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "OVERRIDING")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER")))||((equalsIgnoreCase(LT(1)->getText(), "MAP"))))))
                    {
                        {
                            int LA160_2 = this->LA(2);
                            if ( ((((equalsIgnoreCase(LT(1)->getText(), "FINAL")))||((equalsIgnoreCase(LT(1)->getText(), "OVERRIDING")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))))))
                            {
                                alt160=1;
                            }
                        }
                    }
                }
                switch (alt160)
                {
            	case 1:
            	    // PLSQLParser.g:571:10: modifier_clause
            	    {
            	        this->followPush(FOLLOW_modifier_clause_in_element_spec4646);
            	        modifier_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleelement_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:572:9: ( element_spec_options )+
            {
                int cnt161=0;

                for (;;)
                {
                    int alt161=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA161_0 = this->LA(1);
            	    if ( (LA161_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FINAL")))||((equalsIgnoreCase(LT(1)->getText(), "CONSTRUCTOR")))||((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER")))||((equalsIgnoreCase(LT(1)->getText(), "MAP"))))))
            	    {
            	        alt161=1;
            	    }
            	    else if ( (LA161_0 == SQL92_RESERVED_ORDER))
            	    {
            	        alt161=1;
            	    }

            	}
            	switch (alt161)
            	{
            	    case 1:
            	        // PLSQLParser.g:572:9: element_spec_options
            	        {
            	            this->followPush(FOLLOW_element_spec_options_in_element_spec4657);
            	            element_spec_options();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleelement_specEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt161 >= 1 )
            		{
            		    goto loop161;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PLSQLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleelement_specEx;
            	}
            	cnt161++;
                }
                loop161: ;	/* Jump to here if this rule does not match */
            }

            // PLSQLParser.g:573:9: ( COMMA pragma_clause )?
            {
                int alt162=2;
                {
                    int LA162_0 = this->LA(1);
                    if ( (LA162_0 == COMMA))
                    {
                        {
                            int LA162_1 = this->LA(2);
                            if ( (LA162_1 == REGULAR_ID))
                            {
                                {
                                    int LA162_3 = this->LA(3);
                                    if ( (LA162_3 == REGULAR_ID))
                                    {
                                        {
                                            int LA162_4 = this->LA(4);
                                            if ( (LA162_4 == LEFT_PAREN))
                                            {
                                                {
                                                    int LA162_5 = this->LA(5);
                                                    if ( (LA162_5 == DELIMITED_ID || LA162_5 == INTRODUCER || LA162_5 == REGULAR_ID || LA162_5 == SQL92_RESERVED_DEFAULT))
                                                    {
                                                        alt162=1;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt162)
                {
            	case 1:
            	    // PLSQLParser.g:573:10: COMMA pragma_clause
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_element_spec4669);
            	        if  (this->hasException())
            	        {
            	            goto ruleelement_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_pragma_clause_in_element_spec4671);
            	        pragma_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleelement_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleelement_specEx; /* Prevent compiler warnings */
    ruleelement_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end element_spec */

/**
 * $ANTLR start element_spec_options
 * PLSQLParser.g:576:1: element_spec_options : ( subprogram_spec | constructor_spec | map_order_function_spec );
 */
void
PLSQLParser::element_spec_options()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:577:5: ( subprogram_spec | constructor_spec | map_order_function_spec )

            ANTLR_UINT32 alt163;

            alt163=3;

            {
                int LA163_0 = this->LA(1);
                if ( (LA163_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FINAL")))||((equalsIgnoreCase(LT(1)->getText(), "CONSTRUCTOR")))||((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER")))||((equalsIgnoreCase(LT(1)->getText(), "MAP"))))))
                {
                    {
                        int LA163_1 = this->LA(2);
                        if ( ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))))
                        {
                            alt163=1;
                        }
                        else if ( ((((equalsIgnoreCase(LT(1)->getText(), "FINAL")))||((equalsIgnoreCase(LT(1)->getText(), "CONSTRUCTOR")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))))))
                        {
                            alt163=2;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "MAP"))))
                        {
                            alt163=3;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 163 );
                            ex->set_state( 1 );


                            goto ruleelement_spec_optionsEx;

                        }
                    }
                }
                else if ( (LA163_0 == SQL92_RESERVED_ORDER))
                {
                    alt163=3;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 163 );
                    ex->set_state( 0 );


                    goto ruleelement_spec_optionsEx;

                }
            }
            switch (alt163)
            {
        	case 1:
        	    // PLSQLParser.g:577:10: subprogram_spec
        	    {
        	        this->followPush(FOLLOW_subprogram_spec_in_element_spec_options4693);
        	        subprogram_spec();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleelement_spec_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:578:10: constructor_spec
        	    {
        	        this->followPush(FOLLOW_constructor_spec_in_element_spec_options4704);
        	        constructor_spec();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleelement_spec_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLParser.g:579:10: map_order_function_spec
        	    {
        	        this->followPush(FOLLOW_map_order_function_spec_in_element_spec_options4715);
        	        map_order_function_spec();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleelement_spec_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleelement_spec_optionsEx; /* Prevent compiler warnings */
    ruleelement_spec_optionsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end element_spec_options */

/**
 * $ANTLR start subprogram_spec
 * PLSQLParser.g:582:1: subprogram_spec : ( member_key | static_key ) ( type_procedure_spec | type_function_spec ) ;
 */
void
PLSQLParser::subprogram_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:583:5: ( ( member_key | static_key ) ( type_procedure_spec | type_function_spec ) )
        // PLSQLParser.g:583:10: ( member_key | static_key ) ( type_procedure_spec | type_function_spec )
        {
            // PLSQLParser.g:583:10: ( member_key | static_key )
            {
                int alt164=2;
                {
                    int LA164_0 = this->LA(1);
                    if ( (LA164_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "STATIC")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))))
                    {
                        {
                            int LA164_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))
                            {
                                alt164=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "STATIC"))))
                            {
                                alt164=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 164 );
                                ex->set_state( 1 );


                                goto rulesubprogram_specEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 164 );
                        ex->set_state( 0 );


                        goto rulesubprogram_specEx;

                    }
                }
                switch (alt164)
                {
            	case 1:
            	    // PLSQLParser.g:583:11: member_key
            	    {
            	        this->followPush(FOLLOW_member_key_in_subprogram_spec4736);
            	        member_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubprogram_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:583:22: static_key
            	    {
            	        this->followPush(FOLLOW_static_key_in_subprogram_spec4738);
            	        static_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubprogram_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:584:9: ( type_procedure_spec | type_function_spec )
            {
                int alt165=2;
                {
                    int LA165_0 = this->LA(1);
                    if ( (LA165_0 == SQL92_RESERVED_PROCEDURE))
                    {
                        alt165=1;
                    }
                    else if ( (LA165_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "FUNCTION"))))
                    {
                        alt165=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 165 );
                        ex->set_state( 0 );


                        goto rulesubprogram_specEx;

                    }
                }
                switch (alt165)
                {
            	case 1:
            	    // PLSQLParser.g:584:10: type_procedure_spec
            	    {
            	        this->followPush(FOLLOW_type_procedure_spec_in_subprogram_spec4750);
            	        type_procedure_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubprogram_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:584:30: type_function_spec
            	    {
            	        this->followPush(FOLLOW_type_function_spec_in_subprogram_spec4752);
            	        type_function_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubprogram_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubprogram_specEx; /* Prevent compiler warnings */
    rulesubprogram_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end subprogram_spec */

/**
 * $ANTLR start type_procedure_spec
 * PLSQLParser.g:587:1: type_procedure_spec : procedure_key procedure_name LEFT_PAREN type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN ( ( is_key | as_key ) call_spec )? ;
 */
void
PLSQLParser::type_procedure_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:588:5: ( procedure_key procedure_name LEFT_PAREN type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN ( ( is_key | as_key ) call_spec )? )
        // PLSQLParser.g:588:10: procedure_key procedure_name LEFT_PAREN type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN ( ( is_key | as_key ) call_spec )?
        {
            this->followPush(FOLLOW_procedure_key_in_type_procedure_spec4773);
            procedure_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletype_procedure_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_procedure_name_in_type_procedure_spec4775);
            procedure_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletype_procedure_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_type_procedure_spec4785);
            if  (this->hasException())
            {
                goto ruletype_procedure_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_elements_parameter_in_type_procedure_spec4787);
            type_elements_parameter();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletype_procedure_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:589:44: ( COMMA type_elements_parameter )*

            for (;;)
            {
                int alt166=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA166_0 = this->LA(1);
                    if ( (LA166_0 == COMMA))
                    {
                        alt166=1;
                    }

                }
                switch (alt166)
                {
            	case 1:
            	    // PLSQLParser.g:589:45: COMMA type_elements_parameter
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_type_procedure_spec4790);
            	        if  (this->hasException())
            	        {
            	            goto ruletype_procedure_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_type_elements_parameter_in_type_procedure_spec4792);
            	        type_elements_parameter();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_procedure_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop166;	/* break out of the loop */
            	    break;
                }
            }
            loop166: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_type_procedure_spec4796);
            if  (this->hasException())
            {
                goto ruletype_procedure_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:590:9: ( ( is_key | as_key ) call_spec )?
            {
                int alt168=2;
                {
                    int LA168_0 = this->LA(1);
                    if ( (LA168_0 == SQL92_RESERVED_AS || LA168_0 == SQL92_RESERVED_IS))
                    {
                        alt168=1;
                    }
                }
                switch (alt168)
                {
            	case 1:
            	    // PLSQLParser.g:590:10: ( is_key | as_key ) call_spec
            	    {
            	        // PLSQLParser.g:590:10: ( is_key | as_key )
            	        {
            	            int alt167=2;
            	            {
            	                int LA167_0 = this->LA(1);
            	                if ( (LA167_0 == SQL92_RESERVED_IS))
            	                {
            	                    alt167=1;
            	                }
            	                else if ( (LA167_0 == SQL92_RESERVED_AS))
            	                {
            	                    alt167=2;
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 167 );
            	                    ex->set_state( 0 );


            	                    goto ruletype_procedure_specEx;

            	                }
            	            }
            	            switch (alt167)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:590:11: is_key
            	        	    {
            	        	        this->followPush(FOLLOW_is_key_in_type_procedure_spec4808);
            	        	        is_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletype_procedure_specEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQLParser.g:590:18: as_key
            	        	    {
            	        	        this->followPush(FOLLOW_as_key_in_type_procedure_spec4810);
            	        	        as_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletype_procedure_specEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_call_spec_in_type_procedure_spec4813);
            	        call_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_procedure_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruletype_procedure_specEx; /* Prevent compiler warnings */
    ruletype_procedure_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end type_procedure_spec */

/**
 * $ANTLR start type_function_spec
 * PLSQLParser.g:593:1: type_function_spec : function_key function_name ( LEFT_PAREN type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN )? return_key ( type_spec | self_key as_key result_key ) ( ( is_key | as_key ) call_spec | external_key ( variable_key )? name_key expression )? ;
 */
void
PLSQLParser::type_function_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:594:5: ( function_key function_name ( LEFT_PAREN type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN )? return_key ( type_spec | self_key as_key result_key ) ( ( is_key | as_key ) call_spec | external_key ( variable_key )? name_key expression )? )
        // PLSQLParser.g:594:10: function_key function_name ( LEFT_PAREN type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN )? return_key ( type_spec | self_key as_key result_key ) ( ( is_key | as_key ) call_spec | external_key ( variable_key )? name_key expression )?
        {
            this->followPush(FOLLOW_function_key_in_type_function_spec4836);
            function_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletype_function_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_function_name_in_type_function_spec4838);
            function_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletype_function_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:595:9: ( LEFT_PAREN type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN )?
            {
                int alt170=2;
                {
                    int LA170_0 = this->LA(1);
                    if ( (LA170_0 == LEFT_PAREN))
                    {
                        alt170=1;
                    }
                }
                switch (alt170)
                {
            	case 1:
            	    // PLSQLParser.g:595:10: LEFT_PAREN type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_type_function_spec4850);
            	        if  (this->hasException())
            	        {
            	            goto ruletype_function_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_type_elements_parameter_in_type_function_spec4852);
            	        type_elements_parameter();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_function_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:595:45: ( COMMA type_elements_parameter )*

            	        for (;;)
            	        {
            	            int alt169=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA169_0 = this->LA(1);
            	                if ( (LA169_0 == COMMA))
            	                {
            	                    alt169=1;
            	                }

            	            }
            	            switch (alt169)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:595:46: COMMA type_elements_parameter
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_type_function_spec4855);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletype_function_specEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_type_elements_parameter_in_type_function_spec4857);
            	        	        type_elements_parameter();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletype_function_specEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop169;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop169: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_type_function_spec4861);
            	        if  (this->hasException())
            	        {
            	            goto ruletype_function_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_return_key_in_type_function_spec4874);
            return_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletype_function_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:596:20: ( type_spec | self_key as_key result_key )
            {
                int alt171=2;
                alt171 = cdfa171.predict(this, this->get_rec(), this->get_istream(), cdfa171 );
                if  (this->hasException())
                {
                    goto ruletype_function_specEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }

                switch (alt171)
                {
            	case 1:
            	    // PLSQLParser.g:596:22: type_spec
            	    {
            	        this->followPush(FOLLOW_type_spec_in_type_function_spec4878);
            	        type_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_function_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:596:34: self_key as_key result_key
            	    {
            	        this->followPush(FOLLOW_self_key_in_type_function_spec4882);
            	        self_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_function_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_as_key_in_type_function_spec4884);
            	        as_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_function_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_result_key_in_type_function_spec4886);
            	        result_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_function_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:597:9: ( ( is_key | as_key ) call_spec | external_key ( variable_key )? name_key expression )?
            {
                int alt174=3;
                {
                    int LA174_0 = this->LA(1);
                    if ( (LA174_0 == SQL92_RESERVED_AS || LA174_0 == SQL92_RESERVED_IS))
                    {
                        alt174=1;
                    }
                    else if ( (LA174_0 == REGULAR_ID))
                    {
                        {
                            int LA174_3 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "EXTERNAL"))))
                            {
                                alt174=2;
                            }
                        }
                    }
                }
                switch (alt174)
                {
            	case 1:
            	    // PLSQLParser.g:597:10: ( is_key | as_key ) call_spec
            	    {
            	        // PLSQLParser.g:597:10: ( is_key | as_key )
            	        {
            	            int alt172=2;
            	            {
            	                int LA172_0 = this->LA(1);
            	                if ( (LA172_0 == SQL92_RESERVED_IS))
            	                {
            	                    alt172=1;
            	                }
            	                else if ( (LA172_0 == SQL92_RESERVED_AS))
            	                {
            	                    alt172=2;
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 172 );
            	                    ex->set_state( 0 );


            	                    goto ruletype_function_specEx;

            	                }
            	            }
            	            switch (alt172)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:597:11: is_key
            	        	    {
            	        	        this->followPush(FOLLOW_is_key_in_type_function_spec4899);
            	        	        is_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletype_function_specEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQLParser.g:597:18: as_key
            	        	    {
            	        	        this->followPush(FOLLOW_as_key_in_type_function_spec4901);
            	        	        as_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletype_function_specEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_call_spec_in_type_function_spec4904);
            	        call_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_function_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:597:38: external_key ( variable_key )? name_key expression
            	    {
            	        this->followPush(FOLLOW_external_key_in_type_function_spec4908);
            	        external_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_function_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:597:51: ( variable_key )?
            	        {
            	            int alt173=2;
            	            {
            	                int LA173_0 = this->LA(1);
            	                if ( (LA173_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "NAME")))||((equalsIgnoreCase(LT(1)->getText(), "VARIABLE"))))))
            	                {
            	                    {
            	                        int LA173_1 = this->LA(2);
            	                        if ( (LA173_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "NAME")))||((equalsIgnoreCase(LT(1)->getText(), "VARIABLE"))))))
            	                        {
            	                            {
            	                                int LA173_2 = this->LA(3);
            	                                if ( ((equalsIgnoreCase(LT(1)->getText(), "VARIABLE"))))
            	                                {
            	                                    alt173=1;
            	                                }
            	                            }
            	                        }
            	                    }
            	                }
            	            }
            	            switch (alt173)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:597:51: variable_key
            	        	    {
            	        	        this->followPush(FOLLOW_variable_key_in_type_function_spec4910);
            	        	        variable_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletype_function_specEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_name_key_in_type_function_spec4913);
            	        name_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_function_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_type_function_spec4915);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletype_function_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruletype_function_specEx; /* Prevent compiler warnings */
    ruletype_function_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end type_function_spec */

/**
 * $ANTLR start constructor_spec
 * PLSQLParser.g:600:1: constructor_spec : ( final_key )? ( instantiable_key )? constructor_key function_key type_spec ( LEFT_PAREN ( self_key in_key out_key type_spec COMMA ) type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN )? return_key self_key as_key result_key ( ( is_key | as_key ) call_spec )? ;
 */
void
PLSQLParser::constructor_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:601:5: ( ( final_key )? ( instantiable_key )? constructor_key function_key type_spec ( LEFT_PAREN ( self_key in_key out_key type_spec COMMA ) type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN )? return_key self_key as_key result_key ( ( is_key | as_key ) call_spec )? )
        // PLSQLParser.g:601:10: ( final_key )? ( instantiable_key )? constructor_key function_key type_spec ( LEFT_PAREN ( self_key in_key out_key type_spec COMMA ) type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN )? return_key self_key as_key result_key ( ( is_key | as_key ) call_spec )?
        {
            // PLSQLParser.g:601:10: ( final_key )?
            {
                int alt175=2;
                {
                    int LA175_0 = this->LA(1);
                    if ( (LA175_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FINAL")))||((equalsIgnoreCase(LT(1)->getText(), "CONSTRUCTOR")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))))))
                    {
                        {
                            int LA175_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "FINAL"))))
                            {
                                alt175=1;
                            }
                        }
                    }
                }
                switch (alt175)
                {
            	case 1:
            	    // PLSQLParser.g:601:10: final_key
            	    {
            	        this->followPush(FOLLOW_final_key_in_constructor_spec4937);
            	        final_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructor_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:601:21: ( instantiable_key )?
            {
                int alt176=2;
                {
                    int LA176_0 = this->LA(1);
                    if ( (LA176_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "CONSTRUCTOR")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))))))
                    {
                        {
                            int LA176_1 = this->LA(2);
                            if ( (LA176_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "CONSTRUCTOR")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))))))
                            {
                                {
                                    int LA176_2 = this->LA(3);
                                    if ( (LA176_2 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "CONSTRUCTOR")))||((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))))))
                                    {
                                        {
                                            int LA176_3 = this->LA(4);
                                            if ( ((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))))
                                            {
                                                alt176=1;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt176)
                {
            	case 1:
            	    // PLSQLParser.g:601:21: instantiable_key
            	    {
            	        this->followPush(FOLLOW_instantiable_key_in_constructor_spec4940);
            	        instantiable_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructor_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_constructor_key_in_constructor_spec4943);
            constructor_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstructor_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_function_key_in_constructor_spec4945);
            function_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstructor_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_spec_in_constructor_spec4947);
            type_spec();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstructor_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:602:9: ( LEFT_PAREN ( self_key in_key out_key type_spec COMMA ) type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN )?
            {
                int alt178=2;
                {
                    int LA178_0 = this->LA(1);
                    if ( (LA178_0 == LEFT_PAREN))
                    {
                        alt178=1;
                    }
                }
                switch (alt178)
                {
            	case 1:
            	    // PLSQLParser.g:602:10: LEFT_PAREN ( self_key in_key out_key type_spec COMMA ) type_elements_parameter ( COMMA type_elements_parameter )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_constructor_spec4958);
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructor_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:602:21: ( self_key in_key out_key type_spec COMMA )
            	        // PLSQLParser.g:602:22: self_key in_key out_key type_spec COMMA
            	        {
            	            this->followPush(FOLLOW_self_key_in_constructor_spec4961);
            	            self_key();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleconstructor_specEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	            this->followPush(FOLLOW_in_key_in_constructor_spec4963);
            	            in_key();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleconstructor_specEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	            this->followPush(FOLLOW_out_key_in_constructor_spec4965);
            	            out_key();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleconstructor_specEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	            this->followPush(FOLLOW_type_spec_in_constructor_spec4967);
            	            type_spec();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleconstructor_specEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	             this->matchToken(COMMA, &FOLLOW_COMMA_in_constructor_spec4969);
            	            if  (this->hasException())
            	            {
            	                goto ruleconstructor_specEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }


            	        this->followPush(FOLLOW_type_elements_parameter_in_constructor_spec4972);
            	        type_elements_parameter();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructor_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:602:87: ( COMMA type_elements_parameter )*

            	        for (;;)
            	        {
            	            int alt177=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA177_0 = this->LA(1);
            	                if ( (LA177_0 == COMMA))
            	                {
            	                    alt177=1;
            	                }

            	            }
            	            switch (alt177)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:602:88: COMMA type_elements_parameter
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_constructor_spec4975);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleconstructor_specEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_type_elements_parameter_in_constructor_spec4977);
            	        	        type_elements_parameter();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleconstructor_specEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop177;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop177: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_constructor_spec4982);
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructor_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_return_key_in_constructor_spec4994);
            return_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstructor_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_self_key_in_constructor_spec4996);
            self_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstructor_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_as_key_in_constructor_spec4998);
            as_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstructor_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_result_key_in_constructor_spec5000);
            result_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconstructor_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:603:47: ( ( is_key | as_key ) call_spec )?
            {
                int alt180=2;
                {
                    int LA180_0 = this->LA(1);
                    if ( (LA180_0 == SQL92_RESERVED_AS || LA180_0 == SQL92_RESERVED_IS))
                    {
                        alt180=1;
                    }
                }
                switch (alt180)
                {
            	case 1:
            	    // PLSQLParser.g:603:48: ( is_key | as_key ) call_spec
            	    {
            	        // PLSQLParser.g:603:48: ( is_key | as_key )
            	        {
            	            int alt179=2;
            	            {
            	                int LA179_0 = this->LA(1);
            	                if ( (LA179_0 == SQL92_RESERVED_IS))
            	                {
            	                    alt179=1;
            	                }
            	                else if ( (LA179_0 == SQL92_RESERVED_AS))
            	                {
            	                    alt179=2;
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 179 );
            	                    ex->set_state( 0 );


            	                    goto ruleconstructor_specEx;

            	                }
            	            }
            	            switch (alt179)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:603:49: is_key
            	        	    {
            	        	        this->followPush(FOLLOW_is_key_in_constructor_spec5004);
            	        	        is_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleconstructor_specEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQLParser.g:603:56: as_key
            	        	    {
            	        	        this->followPush(FOLLOW_as_key_in_constructor_spec5006);
            	        	        as_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleconstructor_specEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_call_spec_in_constructor_spec5009);
            	        call_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconstructor_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconstructor_specEx; /* Prevent compiler warnings */
    ruleconstructor_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end constructor_spec */

/**
 * $ANTLR start map_order_function_spec
 * PLSQLParser.g:606:1: map_order_function_spec : ( map_key | order_key ) member_key type_function_spec ;
 */
void
PLSQLParser::map_order_function_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:607:5: ( ( map_key | order_key ) member_key type_function_spec )
        // PLSQLParser.g:607:10: ( map_key | order_key ) member_key type_function_spec
        {
            // PLSQLParser.g:607:10: ( map_key | order_key )
            {
                int alt181=2;
                {
                    int LA181_0 = this->LA(1);
                    if ( (LA181_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "MAP"))))
                    {
                        alt181=1;
                    }
                    else if ( (LA181_0 == SQL92_RESERVED_ORDER))
                    {
                        alt181=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 181 );
                        ex->set_state( 0 );


                        goto rulemap_order_function_specEx;

                    }
                }
                switch (alt181)
                {
            	case 1:
            	    // PLSQLParser.g:607:11: map_key
            	    {
            	        this->followPush(FOLLOW_map_key_in_map_order_function_spec5032);
            	        map_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemap_order_function_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:607:19: order_key
            	    {
            	        this->followPush(FOLLOW_order_key_in_map_order_function_spec5034);
            	        order_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemap_order_function_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_member_key_in_map_order_function_spec5037);
            member_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemap_order_function_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_function_spec_in_map_order_function_spec5039);
            type_function_spec();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemap_order_function_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemap_order_function_specEx; /* Prevent compiler warnings */
    rulemap_order_function_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end map_order_function_spec */

/**
 * $ANTLR start pragma_clause
 * PLSQLParser.g:610:1: pragma_clause : pragma_key restrict_references_key LEFT_PAREN pragma_elements ( COMMA pragma_elements )* RIGHT_PAREN ;
 */
void
PLSQLParser::pragma_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:611:5: ( pragma_key restrict_references_key LEFT_PAREN pragma_elements ( COMMA pragma_elements )* RIGHT_PAREN )
        // PLSQLParser.g:611:10: pragma_key restrict_references_key LEFT_PAREN pragma_elements ( COMMA pragma_elements )* RIGHT_PAREN
        {
            this->followPush(FOLLOW_pragma_key_in_pragma_clause5059);
            pragma_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepragma_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_restrict_references_key_in_pragma_clause5061);
            restrict_references_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepragma_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_pragma_clause5063);
            if  (this->hasException())
            {
                goto rulepragma_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_pragma_elements_in_pragma_clause5065);
            pragma_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepragma_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:611:72: ( COMMA pragma_elements )*

            for (;;)
            {
                int alt182=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA182_0 = this->LA(1);
                    if ( (LA182_0 == COMMA))
                    {
                        alt182=1;
                    }

                }
                switch (alt182)
                {
            	case 1:
            	    // PLSQLParser.g:611:73: COMMA pragma_elements
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_pragma_clause5068);
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_pragma_elements_in_pragma_clause5070);
            	        pragma_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop182;	/* break out of the loop */
            	    break;
                }
            }
            loop182: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_pragma_clause5074);
            if  (this->hasException())
            {
                goto rulepragma_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepragma_clauseEx; /* Prevent compiler warnings */
    rulepragma_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pragma_clause */

/**
 * $ANTLR start pragma_elements
 * PLSQLParser.g:614:1: pragma_elements : ( id | default_key );
 */
void
PLSQLParser::pragma_elements()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:615:5: ( id | default_key )

            ANTLR_UINT32 alt183;

            alt183=2;

            {
                int LA183_0 = this->LA(1);
                if ( (LA183_0 == DELIMITED_ID || LA183_0 == INTRODUCER || LA183_0 == REGULAR_ID))
                {
                    alt183=1;
                }
                else if ( (LA183_0 == SQL92_RESERVED_DEFAULT))
                {
                    alt183=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 183 );
                    ex->set_state( 0 );


                    goto rulepragma_elementsEx;

                }
            }
            switch (alt183)
            {
        	case 1:
        	    // PLSQLParser.g:615:10: id
        	    {
        	        this->followPush(FOLLOW_id_in_pragma_elements5094);
        	        id();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepragma_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:616:10: default_key
        	    {
        	        this->followPush(FOLLOW_default_key_in_pragma_elements5105);
        	        default_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepragma_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulepragma_elementsEx; /* Prevent compiler warnings */
    rulepragma_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pragma_elements */

/**
 * $ANTLR start type_elements_parameter
 * PLSQLParser.g:619:1: type_elements_parameter : parameter_name type_spec ;
 */
void
PLSQLParser::type_elements_parameter()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:620:5: ( parameter_name type_spec )
        // PLSQLParser.g:620:10: parameter_name type_spec
        {
            this->followPush(FOLLOW_parameter_name_in_type_elements_parameter5125);
            parameter_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletype_elements_parameterEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_spec_in_type_elements_parameter5127);
            type_spec();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletype_elements_parameterEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletype_elements_parameterEx; /* Prevent compiler warnings */
    ruletype_elements_parameterEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end type_elements_parameter */

/**
 * $ANTLR start drop_sequence
 * PLSQLParser.g:628:1: drop_sequence : drop_key sequence_key sequence_name SEMICOLON ;
 */
void
PLSQLParser::drop_sequence()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:629:5: ( drop_key sequence_key sequence_name SEMICOLON )
        // PLSQLParser.g:629:9: drop_key sequence_key sequence_name SEMICOLON
        {
            this->followPush(FOLLOW_drop_key_in_drop_sequence5151);
            drop_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledrop_sequenceEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_sequence_key_in_drop_sequence5153);
            sequence_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledrop_sequenceEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_sequence_name_in_drop_sequence5155);
            sequence_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledrop_sequenceEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_drop_sequence5165);
            if  (this->hasException())
            {
                goto ruledrop_sequenceEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledrop_sequenceEx; /* Prevent compiler warnings */
    ruledrop_sequenceEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end drop_sequence */

/**
 * $ANTLR start alter_sequence
 * PLSQLParser.g:633:1: alter_sequence : alter_key sequence_key sequence_name ( sequence_spec )+ SEMICOLON ;
 */
void
PLSQLParser::alter_sequence()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:634:5: ( alter_key sequence_key sequence_name ( sequence_spec )+ SEMICOLON )
        // PLSQLParser.g:634:10: alter_key sequence_key sequence_name ( sequence_spec )+ SEMICOLON
        {
            this->followPush(FOLLOW_alter_key_in_alter_sequence5185);
            alter_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_sequenceEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_sequence_key_in_alter_sequence5187);
            sequence_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_sequenceEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_sequence_name_in_alter_sequence5189);
            sequence_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulealter_sequenceEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:634:47: ( sequence_spec )+
            {
                int cnt184=0;

                for (;;)
                {
                    int alt184=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA184_0 = this->LA(1);
            	    if ( (LA184_0 == REGULAR_ID || LA184_0 == SQL92_RESERVED_ORDER))
            	    {
            	        alt184=1;
            	    }

            	}
            	switch (alt184)
            	{
            	    case 1:
            	        // PLSQLParser.g:634:47: sequence_spec
            	        {
            	            this->followPush(FOLLOW_sequence_spec_in_alter_sequence5191);
            	            sequence_spec();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulealter_sequenceEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt184 >= 1 )
            		{
            		    goto loop184;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PLSQLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto rulealter_sequenceEx;
            	}
            	cnt184++;
                }
                loop184: ;	/* Jump to here if this rule does not match */
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_alter_sequence5203);
            if  (this->hasException())
            {
                goto rulealter_sequenceEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealter_sequenceEx; /* Prevent compiler warnings */
    rulealter_sequenceEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end alter_sequence */

/**
 * $ANTLR start create_sequence
 * PLSQLParser.g:638:1: create_sequence : create_key sequence_key sequence_name ( sequence_start_clause | sequence_spec )* SEMICOLON ;
 */
void
PLSQLParser::create_sequence()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:639:5: ( create_key sequence_key sequence_name ( sequence_start_clause | sequence_spec )* SEMICOLON )
        // PLSQLParser.g:639:10: create_key sequence_key sequence_name ( sequence_start_clause | sequence_spec )* SEMICOLON
        {
            this->followPush(FOLLOW_create_key_in_create_sequence5223);
            create_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecreate_sequenceEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_sequence_key_in_create_sequence5225);
            sequence_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecreate_sequenceEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_sequence_name_in_create_sequence5227);
            sequence_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecreate_sequenceEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:640:5: ( sequence_start_clause | sequence_spec )*

            for (;;)
            {
                int alt185=3;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA185_0 = this->LA(1);
                    if ( (LA185_0 == PLSQL_RESERVED_START))
                    {
                        alt185=1;
                    }
                    else if ( (LA185_0 == REGULAR_ID || LA185_0 == SQL92_RESERVED_ORDER))
                    {
                        alt185=2;
                    }

                }
                switch (alt185)
                {
            	case 1:
            	    // PLSQLParser.g:640:10: sequence_start_clause
            	    {
            	        this->followPush(FOLLOW_sequence_start_clause_in_create_sequence5238);
            	        sequence_start_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_sequenceEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:641:10: sequence_spec
            	    {
            	        this->followPush(FOLLOW_sequence_spec_in_create_sequence5249);
            	        sequence_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecreate_sequenceEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop185;	/* break out of the loop */
            	    break;
                }
            }
            loop185: ; /* Jump out to here if this rule does not match */


             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_create_sequence5260);
            if  (this->hasException())
            {
                goto rulecreate_sequenceEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecreate_sequenceEx; /* Prevent compiler warnings */
    rulecreate_sequenceEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end create_sequence */

/**
 * $ANTLR start sequence_spec
 * PLSQLParser.g:647:1: sequence_spec : ( increment_key by_key UNSIGNED_INTEGER | maxvalue_key UNSIGNED_INTEGER | nomaxvalue_key | minvalue_key UNSIGNED_INTEGER | nominvalue_key | cycle_key | nocycle_key | cache_key UNSIGNED_INTEGER | nocache_key | order_key | noorder_key );
 */
void
PLSQLParser::sequence_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:648:5: ( increment_key by_key UNSIGNED_INTEGER | maxvalue_key UNSIGNED_INTEGER | nomaxvalue_key | minvalue_key UNSIGNED_INTEGER | nominvalue_key | cycle_key | nocycle_key | cache_key UNSIGNED_INTEGER | nocache_key | order_key | noorder_key )

            ANTLR_UINT32 alt186;

            alt186=11;

            {
                int LA186_0 = this->LA(1);
                if ( (LA186_0 == REGULAR_ID))
                {
                    {
                        int LA186_1 = this->LA(2);
                        if ( (LA186_1 == SQL92_RESERVED_BY) && ((equalsIgnoreCase(LT(1)->getText(), "INCREMENT"))))
                        {
                            alt186=1;
                        }
                        else if ( (LA186_1 == UNSIGNED_INTEGER))
                        {
                            {
                                int LA186_4 = this->LA(3);
                                if ( ((equalsIgnoreCase(LT(1)->getText(), "MAXVALUE"))))
                                {
                                    alt186=2;
                                }
                                else if ( ((equalsIgnoreCase(LT(1)->getText(), "MINVALUE"))))
                                {
                                    alt186=4;
                                }
                                else if ( ((equalsIgnoreCase(LT(1)->getText(), "CACHE"))))
                                {
                                    alt186=8;
                                }
                                else
                                {
                                    if (this->get_backtracking()>0)
                                    {
                                        this->set_failedflag( true );
                                        return ;
                                    }


                                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                    ex->set_decisionNum( 186 );
                                    ex->set_state( 4 );


                                    goto rulesequence_specEx;

                                }
                            }
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NOMAXVALUE"))))
                        {
                            alt186=3;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NOMINVALUE"))))
                        {
                            alt186=5;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "CYCLE"))))
                        {
                            alt186=6;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NOCYCLE"))))
                        {
                            alt186=7;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NOCACHE"))))
                        {
                            alt186=9;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NOORDER"))))
                        {
                            alt186=11;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 186 );
                            ex->set_state( 1 );


                            goto rulesequence_specEx;

                        }
                    }
                }
                else if ( (LA186_0 == SQL92_RESERVED_ORDER))
                {
                    alt186=10;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 186 );
                    ex->set_state( 0 );


                    goto rulesequence_specEx;

                }
            }
            switch (alt186)
            {
        	case 1:
        	    // PLSQLParser.g:648:10: increment_key by_key UNSIGNED_INTEGER
        	    {
        	        this->followPush(FOLLOW_increment_key_in_sequence_spec5282);
        	        increment_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesequence_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_by_key_in_sequence_spec5284);
        	        by_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesequence_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_sequence_spec5286);
        	        if  (this->hasException())
        	        {
        	            goto rulesequence_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:649:10: maxvalue_key UNSIGNED_INTEGER
        	    {
        	        this->followPush(FOLLOW_maxvalue_key_in_sequence_spec5297);
        	        maxvalue_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesequence_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_sequence_spec5299);
        	        if  (this->hasException())
        	        {
        	            goto rulesequence_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLParser.g:650:10: nomaxvalue_key
        	    {
        	        this->followPush(FOLLOW_nomaxvalue_key_in_sequence_spec5310);
        	        nomaxvalue_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesequence_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQLParser.g:651:10: minvalue_key UNSIGNED_INTEGER
        	    {
        	        this->followPush(FOLLOW_minvalue_key_in_sequence_spec5321);
        	        minvalue_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesequence_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_sequence_spec5323);
        	        if  (this->hasException())
        	        {
        	            goto rulesequence_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQLParser.g:652:10: nominvalue_key
        	    {
        	        this->followPush(FOLLOW_nominvalue_key_in_sequence_spec5334);
        	        nominvalue_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesequence_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // PLSQLParser.g:653:10: cycle_key
        	    {
        	        this->followPush(FOLLOW_cycle_key_in_sequence_spec5345);
        	        cycle_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesequence_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 7:
        	    // PLSQLParser.g:654:10: nocycle_key
        	    {
        	        this->followPush(FOLLOW_nocycle_key_in_sequence_spec5356);
        	        nocycle_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesequence_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 8:
        	    // PLSQLParser.g:655:10: cache_key UNSIGNED_INTEGER
        	    {
        	        this->followPush(FOLLOW_cache_key_in_sequence_spec5367);
        	        cache_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesequence_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_sequence_spec5369);
        	        if  (this->hasException())
        	        {
        	            goto rulesequence_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 9:
        	    // PLSQLParser.g:656:10: nocache_key
        	    {
        	        this->followPush(FOLLOW_nocache_key_in_sequence_spec5380);
        	        nocache_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesequence_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 10:
        	    // PLSQLParser.g:657:10: order_key
        	    {
        	        this->followPush(FOLLOW_order_key_in_sequence_spec5391);
        	        order_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesequence_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 11:
        	    // PLSQLParser.g:658:10: noorder_key
        	    {
        	        this->followPush(FOLLOW_noorder_key_in_sequence_spec5402);
        	        noorder_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesequence_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesequence_specEx; /* Prevent compiler warnings */
    rulesequence_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sequence_spec */

/**
 * $ANTLR start sequence_start_clause
 * PLSQLParser.g:661:1: sequence_start_clause : start_key with_key UNSIGNED_INTEGER ;
 */
void
PLSQLParser::sequence_start_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:662:5: ( start_key with_key UNSIGNED_INTEGER )
        // PLSQLParser.g:662:10: start_key with_key UNSIGNED_INTEGER
        {
            this->followPush(FOLLOW_start_key_in_sequence_start_clause5422);
            start_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesequence_start_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_with_key_in_sequence_start_clause5424);
            with_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesequence_start_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(UNSIGNED_INTEGER, &FOLLOW_UNSIGNED_INTEGER_in_sequence_start_clause5426);
            if  (this->hasException())
            {
                goto rulesequence_start_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesequence_start_clauseEx; /* Prevent compiler warnings */
    rulesequence_start_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sequence_start_clause */

/**
 * $ANTLR start invoker_rights_clause
 * PLSQLParser.g:670:1: invoker_rights_clause : authid_key ( current_user_key | definer_key ) ;
 */
void
PLSQLParser::invoker_rights_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:671:5: ( authid_key ( current_user_key | definer_key ) )
        // PLSQLParser.g:671:10: authid_key ( current_user_key | definer_key )
        {
            this->followPush(FOLLOW_authid_key_in_invoker_rights_clause5451);
            authid_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleinvoker_rights_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:671:21: ( current_user_key | definer_key )
            {
                int alt187=2;
                {
                    int LA187_0 = this->LA(1);
                    if ( (LA187_0 == REGULAR_ID))
                    {
                        {
                            int LA187_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "CURRENT_USER"))))
                            {
                                alt187=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "DEFINER"))))
                            {
                                alt187=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 187 );
                                ex->set_state( 1 );


                                goto ruleinvoker_rights_clauseEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 187 );
                        ex->set_state( 0 );


                        goto ruleinvoker_rights_clauseEx;

                    }
                }
                switch (alt187)
                {
            	case 1:
            	    // PLSQLParser.g:671:22: current_user_key
            	    {
            	        this->followPush(FOLLOW_current_user_key_in_invoker_rights_clause5454);
            	        current_user_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleinvoker_rights_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:671:39: definer_key
            	    {
            	        this->followPush(FOLLOW_definer_key_in_invoker_rights_clause5456);
            	        definer_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleinvoker_rights_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinvoker_rights_clauseEx; /* Prevent compiler warnings */
    ruleinvoker_rights_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end invoker_rights_clause */

/**
 * $ANTLR start compiler_parameters_clause
 * PLSQLParser.g:674:1: compiler_parameters_clause : id EQUALS_OP expression ;
 */
void
PLSQLParser::compiler_parameters_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:675:5: ( id EQUALS_OP expression )
        // PLSQLParser.g:675:10: id EQUALS_OP expression
        {
            this->followPush(FOLLOW_id_in_compiler_parameters_clause5477);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecompiler_parameters_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_compiler_parameters_clause5479);
            if  (this->hasException())
            {
                goto rulecompiler_parameters_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_compiler_parameters_clause5481);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecompiler_parameters_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecompiler_parameters_clauseEx; /* Prevent compiler warnings */
    rulecompiler_parameters_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end compiler_parameters_clause */

/**
 * $ANTLR start call_spec
 * PLSQLParser.g:678:1: call_spec : language_key ( java_spec | c_spec ) ;
 */
void
PLSQLParser::call_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:679:5: ( language_key ( java_spec | c_spec ) )
        // PLSQLParser.g:679:10: language_key ( java_spec | c_spec )
        {
            this->followPush(FOLLOW_language_key_in_call_spec5501);
            language_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecall_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:679:23: ( java_spec | c_spec )
            {
                int alt188=2;
                {
                    int LA188_0 = this->LA(1);
                    if ( (LA188_0 == REGULAR_ID))
                    {
                        {
                            int LA188_1 = this->LA(2);
                            if ( (LA188_1 == REGULAR_ID))
                            {
                                {
                                    int LA188_2 = this->LA(3);
                                    if ( (LA188_2 == CHAR_STRING))
                                    {
                                        {
                                            int LA188_3 = this->LA(4);
                                            if ( (LA188_3 == COMMA || ((LA188_3 >= RIGHT_PAREN) && (LA188_3 <= SEMICOLON)) || LA188_3 == SQL92_RESERVED_END || LA188_3 == SQL92_RESERVED_ORDER))
                                            {
                                                alt188=1;
                                            }
                                            else if ( (LA188_3 == REGULAR_ID))
                                            {
                                                {
                                                    int LA188_6 = this->LA(5);
                                                    if ( (LA188_6 == SEMICOLON || LA188_6 == SQL92_RESERVED_NOT || LA188_6 == SQL92_RESERVED_PROCEDURE))
                                                    {
                                                        alt188=1;
                                                    }
                                                    else if ( (LA188_6 == REGULAR_ID))
                                                    {
                                                        {
                                                            int LA188_7 = this->LA(6);
                                                            if ( ((equalsIgnoreCase(LT(1)->getText(), "JAVA"))))
                                                            {
                                                                alt188=1;
                                                            }
                                                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "C"))))
                                                            {
                                                                alt188=2;
                                                            }
                                                            else
                                                            {
                                                                if (this->get_backtracking()>0)
                                                                {
                                                                    this->set_failedflag( true );
                                                                    return ;
                                                                }


                                                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                                                ex->set_decisionNum( 188 );
                                                                ex->set_state( 7 );


                                                                goto rulecall_specEx;

                                                            }
                                                        }
                                                    }
                                                    else if ( (LA188_6 == DELIMITED_ID || LA188_6 == INTRODUCER) && ((equalsIgnoreCase(LT(1)->getText(), "C"))))
                                                    {
                                                        alt188=2;
                                                    }
                                                    else
                                                    {
                                                        if (this->get_backtracking()>0)
                                                        {
                                                            this->set_failedflag( true );
                                                            return ;
                                                        }


                                                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                                        ex->set_decisionNum( 188 );
                                                        ex->set_state( 6 );


                                                        goto rulecall_specEx;

                                                    }
                                                }
                                            }
                                            else
                                            {
                                                if (this->get_backtracking()>0)
                                                {
                                                    this->set_failedflag( true );
                                                    return ;
                                                }


                                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                                ex->set_decisionNum( 188 );
                                                ex->set_state( 3 );


                                                goto rulecall_specEx;

                                            }
                                        }
                                    }
                                    else if ( (LA188_2 == DELIMITED_ID || LA188_2 == INTRODUCER || LA188_2 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "C"))))
                                    {
                                        alt188=2;
                                    }
                                    else
                                    {
                                        if (this->get_backtracking()>0)
                                        {
                                            this->set_failedflag( true );
                                            return ;
                                        }


                                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                        ex->set_decisionNum( 188 );
                                        ex->set_state( 2 );


                                        goto rulecall_specEx;

                                    }
                                }
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 188 );
                                ex->set_state( 1 );


                                goto rulecall_specEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 188 );
                        ex->set_state( 0 );


                        goto rulecall_specEx;

                    }
                }
                switch (alt188)
                {
            	case 1:
            	    // PLSQLParser.g:679:25: java_spec
            	    {
            	        this->followPush(FOLLOW_java_spec_in_call_spec5505);
            	        java_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecall_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:679:37: c_spec
            	    {
            	        this->followPush(FOLLOW_c_spec_in_call_spec5509);
            	        c_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecall_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulecall_specEx; /* Prevent compiler warnings */
    rulecall_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end call_spec */

/**
 * $ANTLR start java_spec
 * PLSQLParser.g:684:1: java_spec : java_key name_key CHAR_STRING ;
 */
void
PLSQLParser::java_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:685:5: ( java_key name_key CHAR_STRING )
        // PLSQLParser.g:685:10: java_key name_key CHAR_STRING
        {
            this->followPush(FOLLOW_java_key_in_java_spec5533);
            java_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejava_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_name_key_in_java_spec5535);
            name_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejava_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(CHAR_STRING, &FOLLOW_CHAR_STRING_in_java_spec5537);
            if  (this->hasException())
            {
                goto rulejava_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulejava_specEx; /* Prevent compiler warnings */
    rulejava_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end java_spec */

/**
 * $ANTLR start c_spec
 * PLSQLParser.g:688:1: c_spec : c_key ( name_key CHAR_STRING )? library_key id ( c_agent_in_clause )? ( with_key context_key )? ( c_parameters_clause )? ;
 */
void
PLSQLParser::c_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:689:5: ( c_key ( name_key CHAR_STRING )? library_key id ( c_agent_in_clause )? ( with_key context_key )? ( c_parameters_clause )? )
        // PLSQLParser.g:689:10: c_key ( name_key CHAR_STRING )? library_key id ( c_agent_in_clause )? ( with_key context_key )? ( c_parameters_clause )?
        {
            this->followPush(FOLLOW_c_key_in_c_spec5557);
            c_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulec_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:689:16: ( name_key CHAR_STRING )?
            {
                int alt189=2;
                {
                    int LA189_0 = this->LA(1);
                    if ( (LA189_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "NAME")))||((equalsIgnoreCase(LT(1)->getText(), "LIBRARY"))))))
                    {
                        {
                            int LA189_1 = this->LA(2);
                            if ( (LA189_1 == CHAR_STRING) && ((equalsIgnoreCase(LT(1)->getText(), "NAME"))))
                            {
                                alt189=1;
                            }
                        }
                    }
                }
                switch (alt189)
                {
            	case 1:
            	    // PLSQLParser.g:689:17: name_key CHAR_STRING
            	    {
            	        this->followPush(FOLLOW_name_key_in_c_spec5560);
            	        name_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulec_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(CHAR_STRING, &FOLLOW_CHAR_STRING_in_c_spec5562);
            	        if  (this->hasException())
            	        {
            	            goto rulec_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_library_key_in_c_spec5575);
            library_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulec_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_id_in_c_spec5577);
            id();

            this->followPop();
            if  (this->hasException())
            {
                goto rulec_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:691:9: ( c_agent_in_clause )?
            {
                int alt190=2;
                {
                    int LA190_0 = this->LA(1);
                    if ( (LA190_0 == REGULAR_ID))
                    {
                        {
                            int LA190_1 = this->LA(2);
                            if ( (LA190_1 == SQL92_RESERVED_IN) && ((equalsIgnoreCase(LT(1)->getText(), "AGENT"))))
                            {
                                alt190=1;
                            }
                        }
                    }
                }
                switch (alt190)
                {
            	case 1:
            	    // PLSQLParser.g:691:9: c_agent_in_clause
            	    {
            	        this->followPush(FOLLOW_c_agent_in_clause_in_c_spec5587);
            	        c_agent_in_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulec_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:691:28: ( with_key context_key )?
            {
                int alt191=2;
                {
                    int LA191_0 = this->LA(1);
                    if ( (LA191_0 == SQL92_RESERVED_WITH))
                    {
                        alt191=1;
                    }
                }
                switch (alt191)
                {
            	case 1:
            	    // PLSQLParser.g:691:29: with_key context_key
            	    {
            	        this->followPush(FOLLOW_with_key_in_c_spec5591);
            	        with_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulec_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_context_key_in_c_spec5593);
            	        context_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulec_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:691:52: ( c_parameters_clause )?
            {
                int alt192=2;
                {
                    int LA192_0 = this->LA(1);
                    if ( (LA192_0 == REGULAR_ID))
                    {
                        {
                            int LA192_1 = this->LA(2);
                            if ( (LA192_1 == LEFT_PAREN) && ((equalsIgnoreCase(LT(1)->getText(), "PARAMETERS"))))
                            {
                                alt192=1;
                            }
                        }
                    }
                }
                switch (alt192)
                {
            	case 1:
            	    // PLSQLParser.g:691:52: c_parameters_clause
            	    {
            	        this->followPush(FOLLOW_c_parameters_clause_in_c_spec5597);
            	        c_parameters_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulec_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulec_specEx; /* Prevent compiler warnings */
    rulec_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end c_spec */

/**
 * $ANTLR start c_agent_in_clause
 * PLSQLParser.g:694:1: c_agent_in_clause : agent_key in_key LEFT_PAREN expression ( COMMA expression )* RIGHT_PAREN ;
 */
void
PLSQLParser::c_agent_in_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:695:5: ( agent_key in_key LEFT_PAREN expression ( COMMA expression )* RIGHT_PAREN )
        // PLSQLParser.g:695:10: agent_key in_key LEFT_PAREN expression ( COMMA expression )* RIGHT_PAREN
        {
            this->followPush(FOLLOW_agent_key_in_c_agent_in_clause5618);
            agent_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulec_agent_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_in_key_in_c_agent_in_clause5620);
            in_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulec_agent_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_c_agent_in_clause5622);
            if  (this->hasException())
            {
                goto rulec_agent_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_c_agent_in_clause5624);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulec_agent_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:695:49: ( COMMA expression )*

            for (;;)
            {
                int alt193=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA193_0 = this->LA(1);
                    if ( (LA193_0 == COMMA))
                    {
                        alt193=1;
                    }

                }
                switch (alt193)
                {
            	case 1:
            	    // PLSQLParser.g:695:50: COMMA expression
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_c_agent_in_clause5627);
            	        if  (this->hasException())
            	        {
            	            goto rulec_agent_in_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_c_agent_in_clause5629);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulec_agent_in_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop193;	/* break out of the loop */
            	    break;
                }
            }
            loop193: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_c_agent_in_clause5633);
            if  (this->hasException())
            {
                goto rulec_agent_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulec_agent_in_clauseEx; /* Prevent compiler warnings */
    rulec_agent_in_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end c_agent_in_clause */

/**
 * $ANTLR start c_parameters_clause
 * PLSQLParser.g:698:1: c_parameters_clause : parameters_key LEFT_PAREN ( expression ( COMMA expression )* | DOUBLE_PERIOD PERIOD ) RIGHT_PAREN ;
 */
void
PLSQLParser::c_parameters_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:699:5: ( parameters_key LEFT_PAREN ( expression ( COMMA expression )* | DOUBLE_PERIOD PERIOD ) RIGHT_PAREN )
        // PLSQLParser.g:699:10: parameters_key LEFT_PAREN ( expression ( COMMA expression )* | DOUBLE_PERIOD PERIOD ) RIGHT_PAREN
        {
            this->followPush(FOLLOW_parameters_key_in_c_parameters_clause5653);
            parameters_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulec_parameters_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_c_parameters_clause5655);
            if  (this->hasException())
            {
                goto rulec_parameters_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:699:36: ( expression ( COMMA expression )* | DOUBLE_PERIOD PERIOD )
            {
                int alt195=2;
                {
                    int LA195_0 = this->LA(1);
                    if ( (LA195_0 == APPROXIMATE_NUM_LIT || LA195_0 == BINDVAR || ((LA195_0 >= CHAR_STRING) && (LA195_0 <= COLON)) || LA195_0 == DELIMITED_ID || LA195_0 == EXACT_NUM_LIT || LA195_0 == INTRODUCER || LA195_0 == LEFT_PAREN || ((LA195_0 >= MINUS_SIGN) && (LA195_0 <= NATIONAL_CHAR_STRING_LIT)) || LA195_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA195_0 == PLUS_SIGN || LA195_0 == REGULAR_ID || LA195_0 == SQL92_RESERVED_ALL || LA195_0 == SQL92_RESERVED_ANY || LA195_0 == SQL92_RESERVED_CASE || ((LA195_0 >= SQL92_RESERVED_CURSOR) && (LA195_0 <= SQL92_RESERVED_DATE)) || LA195_0 == SQL92_RESERVED_DEFAULT || LA195_0 == SQL92_RESERVED_DISTINCT || ((LA195_0 >= SQL92_RESERVED_EXISTS) && (LA195_0 <= SQL92_RESERVED_FALSE)) || ((LA195_0 >= SQL92_RESERVED_NOT) && (LA195_0 <= SQL92_RESERVED_NULL)) || LA195_0 == SQL92_RESERVED_PRIOR || LA195_0 == SQL92_RESERVED_TRUE || LA195_0 == UNSIGNED_INTEGER))
                    {
                        alt195=1;
                    }
                    else if ( (LA195_0 == DOUBLE_PERIOD))
                    {
                        alt195=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 195 );
                        ex->set_state( 0 );


                        goto rulec_parameters_clauseEx;

                    }
                }
                switch (alt195)
                {
            	case 1:
            	    // PLSQLParser.g:699:37: expression ( COMMA expression )*
            	    {
            	        this->followPush(FOLLOW_expression_in_c_parameters_clause5658);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulec_parameters_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:699:48: ( COMMA expression )*

            	        for (;;)
            	        {
            	            int alt194=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA194_0 = this->LA(1);
            	                if ( (LA194_0 == COMMA))
            	                {
            	                    alt194=1;
            	                }

            	            }
            	            switch (alt194)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:699:49: COMMA expression
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_c_parameters_clause5661);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulec_parameters_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_expression_in_c_parameters_clause5663);
            	        	        expression();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulec_parameters_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop194;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop194: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:699:70: DOUBLE_PERIOD PERIOD
            	    {
            	         this->matchToken(DOUBLE_PERIOD, &FOLLOW_DOUBLE_PERIOD_in_c_parameters_clause5669);
            	        if  (this->hasException())
            	        {
            	            goto rulec_parameters_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_c_parameters_clause5671);
            	        if  (this->hasException())
            	        {
            	            goto rulec_parameters_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_c_parameters_clause5674);
            if  (this->hasException())
            {
                goto rulec_parameters_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulec_parameters_clauseEx; /* Prevent compiler warnings */
    rulec_parameters_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end c_parameters_clause */

/**
 * $ANTLR start parameter
 * PLSQLParser.g:704:1: parameter : parameter_name ( in_key | out_key | inout_key | nocopy_key )* ( type_spec )? ( default_value_part )? ;
 */
void
PLSQLParser::parameter()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:705:5: ( parameter_name ( in_key | out_key | inout_key | nocopy_key )* ( type_spec )? ( default_value_part )? )
        // PLSQLParser.g:705:10: parameter_name ( in_key | out_key | inout_key | nocopy_key )* ( type_spec )? ( default_value_part )?
        {
            this->followPush(FOLLOW_parameter_name_in_parameter5696);
            parameter_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleparameterEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:705:25: ( in_key | out_key | inout_key | nocopy_key )*

            for (;;)
            {
                int alt196=5;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA196_0 = this->LA(1);
                    if ( (LA196_0 == REGULAR_ID))
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA196_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "OUT"))))
                            {
                                alt196=2;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "INOUT"))))
                            {
                                alt196=3;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "NOCOPY"))))
                            {
                                alt196=4;
                            }

                        }
                    }
                    else if ( (LA196_0 == SQL92_RESERVED_IN))
                    {
                        alt196=1;
                    }

                }
                switch (alt196)
                {
            	case 1:
            	    // PLSQLParser.g:705:27: in_key
            	    {
            	        this->followPush(FOLLOW_in_key_in_parameter5700);
            	        in_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleparameterEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:705:36: out_key
            	    {
            	        this->followPush(FOLLOW_out_key_in_parameter5704);
            	        out_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleparameterEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLParser.g:705:46: inout_key
            	    {
            	        this->followPush(FOLLOW_inout_key_in_parameter5708);
            	        inout_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleparameterEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 4:
            	    // PLSQLParser.g:705:58: nocopy_key
            	    {
            	        this->followPush(FOLLOW_nocopy_key_in_parameter5712);
            	        nocopy_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleparameterEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop196;	/* break out of the loop */
            	    break;
                }
            }
            loop196: ; /* Jump out to here if this rule does not match */


            // PLSQLParser.g:705:71: ( type_spec )?
            {
                int alt197=2;
                {
                    int LA197_0 = this->LA(1);
                    if ( (LA197_0 == DELIMITED_ID || LA197_0 == REGULAR_ID || LA197_0 == SQL92_RESERVED_DATE))
                    {
                        alt197=1;
                    }
                }
                switch (alt197)
                {
            	case 1:
            	    // PLSQLParser.g:705:71: type_spec
            	    {
            	        this->followPush(FOLLOW_type_spec_in_parameter5716);
            	        type_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleparameterEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:705:82: ( default_value_part )?
            {
                int alt198=2;
                {
                    int LA198_0 = this->LA(1);
                    if ( (LA198_0 == ASSIGN_OP || LA198_0 == SQL92_RESERVED_DEFAULT))
                    {
                        alt198=1;
                    }
                }
                switch (alt198)
                {
            	case 1:
            	    // PLSQLParser.g:705:82: default_value_part
            	    {
            	        this->followPush(FOLLOW_default_value_part_in_parameter5719);
            	        default_value_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleparameterEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleparameterEx; /* Prevent compiler warnings */
    ruleparameterEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end parameter */

/**
 * $ANTLR start default_value_part
 * PLSQLParser.g:708:1: default_value_part : ( ASSIGN_OP | default_key ) expression ;
 */
void
PLSQLParser::default_value_part()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:709:5: ( ( ASSIGN_OP | default_key ) expression )
        // PLSQLParser.g:709:10: ( ASSIGN_OP | default_key ) expression
        {
            // PLSQLParser.g:709:10: ( ASSIGN_OP | default_key )
            {
                int alt199=2;
                {
                    int LA199_0 = this->LA(1);
                    if ( (LA199_0 == ASSIGN_OP))
                    {
                        alt199=1;
                    }
                    else if ( (LA199_0 == SQL92_RESERVED_DEFAULT))
                    {
                        alt199=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 199 );
                        ex->set_state( 0 );


                        goto ruledefault_value_partEx;

                    }
                }
                switch (alt199)
                {
            	case 1:
            	    // PLSQLParser.g:709:11: ASSIGN_OP
            	    {
            	         this->matchToken(ASSIGN_OP, &FOLLOW_ASSIGN_OP_in_default_value_part5741);
            	        if  (this->hasException())
            	        {
            	            goto ruledefault_value_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:709:21: default_key
            	    {
            	        this->followPush(FOLLOW_default_key_in_default_value_part5743);
            	        default_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledefault_value_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_expression_in_default_value_part5746);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledefault_value_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledefault_value_partEx; /* Prevent compiler warnings */
    ruledefault_value_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end default_value_part */

/**
 * $ANTLR start declare_spec
 * PLSQLParser.g:718:1: declare_spec options {backtrack=true; } : ( variable_declaration | subtype_declaration | cursor_declaration | exception_declaration | pragma_declaration | record_declaration | table_declaration | create_procedure_body | create_function_body );
 */
void
PLSQLParser::declare_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:721:6: ( variable_declaration | subtype_declaration | cursor_declaration | exception_declaration | pragma_declaration | record_declaration | table_declaration | create_procedure_body | create_function_body )

            ANTLR_UINT32 alt200;

            alt200=9;

            switch ( this->LA(1) )
            {
            case INTRODUCER:
            	{
            		{
            		    int LA200_1 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred36_PLSQLParser>() )))
            		    {
            		        alt200=1;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred39_PLSQLParser>() )))
            		    {
            		        alt200=4;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred41_PLSQLParser>() )))
            		    {
            		        alt200=6;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred42_PLSQLParser>() )))
            		    {
            		        alt200=7;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 200 );
            		        ex->set_state( 1 );


            		        goto ruledeclare_specEx;

            		    }
            		}
            	}
                break;
            case REGULAR_ID:
            	{
            		{
            		    int LA200_2 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred36_PLSQLParser>() )))
            		    {
            		        alt200=1;
            		    }
            		    else if ( (( (this->msynpred( antlr3::ClassForwarder<synpred37_PLSQLParser>() )) && ((equalsIgnoreCase(LT(1)->getText(), "SUBTYPE"))) )))
            		    {
            		        alt200=2;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred39_PLSQLParser>() )))
            		    {
            		        alt200=4;
            		    }
            		    else if ( (( (this->msynpred( antlr3::ClassForwarder<synpred40_PLSQLParser>() )) && ((equalsIgnoreCase(LT(1)->getText(), "PRAGMA"))) )))
            		    {
            		        alt200=5;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred41_PLSQLParser>() )))
            		    {
            		        alt200=6;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred42_PLSQLParser>() )))
            		    {
            		        alt200=7;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "FUNCTION"))))
            		    {
            		        alt200=9;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 200 );
            		        ex->set_state( 2 );


            		        goto ruledeclare_specEx;

            		    }
            		}
            	}
                break;
            case BINDVAR:
            	{
            		{
            		    int LA200_3 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred36_PLSQLParser>() )))
            		    {
            		        alt200=1;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred41_PLSQLParser>() )))
            		    {
            		        alt200=6;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 200 );
            		        ex->set_state( 3 );


            		        goto ruledeclare_specEx;

            		    }
            		}
            	}
                break;
            case COLON:
            	{
            		{
            		    int LA200_4 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred36_PLSQLParser>() )))
            		    {
            		        alt200=1;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred41_PLSQLParser>() )))
            		    {
            		        alt200=6;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 200 );
            		        ex->set_state( 4 );


            		        goto ruledeclare_specEx;

            		    }
            		}
            	}
                break;
            case DELIMITED_ID:
            	{
            		{
            		    int LA200_5 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred36_PLSQLParser>() )))
            		    {
            		        alt200=1;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred39_PLSQLParser>() )))
            		    {
            		        alt200=4;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred41_PLSQLParser>() )))
            		    {
            		        alt200=6;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred42_PLSQLParser>() )))
            		    {
            		        alt200=7;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 200 );
            		        ex->set_state( 5 );


            		        goto ruledeclare_specEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_CURSOR:
            	{
            		alt200=3;
            	}
                break;
            case SQL92_RESERVED_CREATE:
            	{
            		{
            		    int LA200_7 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred43_PLSQLParser>() )))
            		    {
            		        alt200=8;
            		    }
            		    else if ( (true))
            		    {
            		        alt200=9;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 200 );
            		        ex->set_state( 7 );


            		        goto ruledeclare_specEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_PROCEDURE:
            	{
            		alt200=8;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 200 );
                ex->set_state( 0 );


                goto ruledeclare_specEx;

            }

            switch (alt200)
            {
        	case 1:
        	    // PLSQLParser.g:721:11: variable_declaration
        	    {
        	        this->followPush(FOLLOW_variable_declaration_in_declare_spec5780);
        	        variable_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledeclare_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:722:11: subtype_declaration
        	    {
        	        this->followPush(FOLLOW_subtype_declaration_in_declare_spec5792);
        	        subtype_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledeclare_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLParser.g:723:11: cursor_declaration
        	    {
        	        this->followPush(FOLLOW_cursor_declaration_in_declare_spec5804);
        	        cursor_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledeclare_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQLParser.g:724:11: exception_declaration
        	    {
        	        this->followPush(FOLLOW_exception_declaration_in_declare_spec5816);
        	        exception_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledeclare_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQLParser.g:725:11: pragma_declaration
        	    {
        	        this->followPush(FOLLOW_pragma_declaration_in_declare_spec5828);
        	        pragma_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledeclare_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // PLSQLParser.g:726:11: record_declaration
        	    {
        	        this->followPush(FOLLOW_record_declaration_in_declare_spec5840);
        	        record_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledeclare_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 7:
        	    // PLSQLParser.g:727:11: table_declaration
        	    {
        	        this->followPush(FOLLOW_table_declaration_in_declare_spec5852);
        	        table_declaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledeclare_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 8:
        	    // PLSQLParser.g:728:11: create_procedure_body
        	    {
        	        this->followPush(FOLLOW_create_procedure_body_in_declare_spec5864);
        	        create_procedure_body();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledeclare_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 9:
        	    // PLSQLParser.g:729:11: create_function_body
        	    {
        	        this->followPush(FOLLOW_create_function_body_in_declare_spec5876);
        	        create_function_body();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledeclare_specEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruledeclare_specEx; /* Prevent compiler warnings */
    ruledeclare_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end declare_spec */

/**
 * $ANTLR start variable_declaration
 * PLSQLParser.g:733:1: variable_declaration : variable_name ( constant_key )? type_spec ( not_key null_key )? ( default_value_part )? SEMICOLON ;
 */
void
PLSQLParser::variable_declaration()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:734:5: ( variable_name ( constant_key )? type_spec ( not_key null_key )? ( default_value_part )? SEMICOLON )
        // PLSQLParser.g:734:10: variable_name ( constant_key )? type_spec ( not_key null_key )? ( default_value_part )? SEMICOLON
        {
            this->followPush(FOLLOW_variable_name_in_variable_declaration5897);
            variable_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulevariable_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:734:24: ( constant_key )?
            {
                int alt201=2;
                {
                    int LA201_0 = this->LA(1);
                    if ( (LA201_0 == REGULAR_ID))
                    {
                        {
                            int LA201_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "CONSTANT"))))
                            {
                                alt201=1;
                            }
                        }
                    }
                }
                switch (alt201)
                {
            	case 1:
            	    // PLSQLParser.g:734:24: constant_key
            	    {
            	        this->followPush(FOLLOW_constant_key_in_variable_declaration5899);
            	        constant_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulevariable_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_type_spec_in_variable_declaration5910);
            type_spec();

            this->followPop();
            if  (this->hasException())
            {
                goto rulevariable_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:735:19: ( not_key null_key )?
            {
                int alt202=2;
                {
                    int LA202_0 = this->LA(1);
                    if ( (LA202_0 == SQL92_RESERVED_NOT))
                    {
                        alt202=1;
                    }
                }
                switch (alt202)
                {
            	case 1:
            	    // PLSQLParser.g:735:20: not_key null_key
            	    {
            	        this->followPush(FOLLOW_not_key_in_variable_declaration5913);
            	        not_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulevariable_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_null_key_in_variable_declaration5915);
            	        null_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulevariable_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:736:9: ( default_value_part )?
            {
                int alt203=2;
                {
                    int LA203_0 = this->LA(1);
                    if ( (LA203_0 == ASSIGN_OP || LA203_0 == SQL92_RESERVED_DEFAULT))
                    {
                        alt203=1;
                    }
                }
                switch (alt203)
                {
            	case 1:
            	    // PLSQLParser.g:736:9: default_value_part
            	    {
            	        this->followPush(FOLLOW_default_value_part_in_variable_declaration5928);
            	        default_value_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulevariable_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_variable_declaration5931);
            if  (this->hasException())
            {
                goto rulevariable_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevariable_declarationEx; /* Prevent compiler warnings */
    rulevariable_declarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end variable_declaration */

/**
 * $ANTLR start subtype_declaration
 * PLSQLParser.g:739:1: subtype_declaration : subtype_key type_name is_key type_spec ( range_key expression DOUBLE_PERIOD expression )? ( not_key null_key )? SEMICOLON ;
 */
void
PLSQLParser::subtype_declaration()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:740:7: ( subtype_key type_name is_key type_spec ( range_key expression DOUBLE_PERIOD expression )? ( not_key null_key )? SEMICOLON )
        // PLSQLParser.g:740:12: subtype_key type_name is_key type_spec ( range_key expression DOUBLE_PERIOD expression )? ( not_key null_key )? SEMICOLON
        {
            this->followPush(FOLLOW_subtype_key_in_subtype_declaration5957);
            subtype_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubtype_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_name_in_subtype_declaration5959);
            type_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubtype_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_is_key_in_subtype_declaration5961);
            is_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubtype_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_spec_in_subtype_declaration5963);
            type_spec();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubtype_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:741:11: ( range_key expression DOUBLE_PERIOD expression )?
            {
                int alt204=2;
                {
                    int LA204_0 = this->LA(1);
                    if ( (LA204_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "RANGE"))))
                    {
                        alt204=1;
                    }
                }
                switch (alt204)
                {
            	case 1:
            	    // PLSQLParser.g:741:12: range_key expression DOUBLE_PERIOD expression
            	    {
            	        this->followPush(FOLLOW_range_key_in_subtype_declaration5976);
            	        range_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubtype_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_subtype_declaration5978);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubtype_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(DOUBLE_PERIOD, &FOLLOW_DOUBLE_PERIOD_in_subtype_declaration5980);
            	        if  (this->hasException())
            	        {
            	            goto rulesubtype_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_subtype_declaration5982);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubtype_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:742:11: ( not_key null_key )?
            {
                int alt205=2;
                {
                    int LA205_0 = this->LA(1);
                    if ( (LA205_0 == SQL92_RESERVED_NOT))
                    {
                        alt205=1;
                    }
                }
                switch (alt205)
                {
            	case 1:
            	    // PLSQLParser.g:742:12: not_key null_key
            	    {
            	        this->followPush(FOLLOW_not_key_in_subtype_declaration5997);
            	        not_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubtype_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_null_key_in_subtype_declaration5999);
            	        null_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubtype_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_subtype_declaration6003);
            if  (this->hasException())
            {
                goto rulesubtype_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubtype_declarationEx; /* Prevent compiler warnings */
    rulesubtype_declarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end subtype_declaration */

/**
 * $ANTLR start cursor_declaration
 * PLSQLParser.g:746:1: cursor_declaration : cursor_key cursor_name ( LEFT_PAREN parameter_spec ( COMMA parameter_spec )* RIGHT_PAREN )? ( return_key type_spec )? ( is_key select_statement )? SEMICOLON ;
 */
void
PLSQLParser::cursor_declaration()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:747:5: ( cursor_key cursor_name ( LEFT_PAREN parameter_spec ( COMMA parameter_spec )* RIGHT_PAREN )? ( return_key type_spec )? ( is_key select_statement )? SEMICOLON )
        // PLSQLParser.g:747:10: cursor_key cursor_name ( LEFT_PAREN parameter_spec ( COMMA parameter_spec )* RIGHT_PAREN )? ( return_key type_spec )? ( is_key select_statement )? SEMICOLON
        {
            this->followPush(FOLLOW_cursor_key_in_cursor_declaration6026);
            cursor_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecursor_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_cursor_name_in_cursor_declaration6028);
            cursor_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecursor_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:748:15: ( LEFT_PAREN parameter_spec ( COMMA parameter_spec )* RIGHT_PAREN )?
            {
                int alt207=2;
                {
                    int LA207_0 = this->LA(1);
                    if ( (LA207_0 == LEFT_PAREN))
                    {
                        alt207=1;
                    }
                }
                switch (alt207)
                {
            	case 1:
            	    // PLSQLParser.g:748:16: LEFT_PAREN parameter_spec ( COMMA parameter_spec )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_cursor_declaration6045);
            	        if  (this->hasException())
            	        {
            	            goto rulecursor_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_parameter_spec_in_cursor_declaration6047);
            	        parameter_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecursor_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:748:42: ( COMMA parameter_spec )*

            	        for (;;)
            	        {
            	            int alt206=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA206_0 = this->LA(1);
            	                if ( (LA206_0 == COMMA))
            	                {
            	                    alt206=1;
            	                }

            	            }
            	            switch (alt206)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:748:43: COMMA parameter_spec
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_cursor_declaration6050);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecursor_declarationEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_parameter_spec_in_cursor_declaration6052);
            	        	        parameter_spec();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecursor_declarationEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop206;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop206: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_cursor_declaration6056);
            	        if  (this->hasException())
            	        {
            	            goto rulecursor_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:749:15: ( return_key type_spec )?
            {
                int alt208=2;
                {
                    int LA208_0 = this->LA(1);
                    if ( (LA208_0 == REGULAR_ID))
                    {
                        alt208=1;
                    }
                }
                switch (alt208)
                {
            	case 1:
            	    // PLSQLParser.g:749:16: return_key type_spec
            	    {
            	        this->followPush(FOLLOW_return_key_in_cursor_declaration6076);
            	        return_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecursor_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_type_spec_in_cursor_declaration6078);
            	        type_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecursor_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:749:39: ( is_key select_statement )?
            {
                int alt209=2;
                {
                    int LA209_0 = this->LA(1);
                    if ( (LA209_0 == SQL92_RESERVED_IS))
                    {
                        alt209=1;
                    }
                }
                switch (alt209)
                {
            	case 1:
            	    // PLSQLParser.g:749:40: is_key select_statement
            	    {
            	        this->followPush(FOLLOW_is_key_in_cursor_declaration6083);
            	        is_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecursor_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_select_statement_in_cursor_declaration6085);
            	        select_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecursor_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_cursor_declaration6089);
            if  (this->hasException())
            {
                goto rulecursor_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecursor_declarationEx; /* Prevent compiler warnings */
    rulecursor_declarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cursor_declaration */

/**
 * $ANTLR start parameter_spec
 * PLSQLParser.g:752:1: parameter_spec : parameter_name ( ( in_key )? type_spec )? ( default_value_part )? ;
 */
void
PLSQLParser::parameter_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:753:5: ( parameter_name ( ( in_key )? type_spec )? ( default_value_part )? )
        // PLSQLParser.g:753:10: parameter_name ( ( in_key )? type_spec )? ( default_value_part )?
        {
            this->followPush(FOLLOW_parameter_name_in_parameter_spec6109);
            parameter_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleparameter_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:753:25: ( ( in_key )? type_spec )?
            {
                int alt211=2;
                {
                    int LA211_0 = this->LA(1);
                    if ( (LA211_0 == DELIMITED_ID || LA211_0 == REGULAR_ID || LA211_0 == SQL92_RESERVED_DATE || LA211_0 == SQL92_RESERVED_IN))
                    {
                        alt211=1;
                    }
                }
                switch (alt211)
                {
            	case 1:
            	    // PLSQLParser.g:753:26: ( in_key )? type_spec
            	    {
            	        // PLSQLParser.g:753:26: ( in_key )?
            	        {
            	            int alt210=2;
            	            {
            	                int LA210_0 = this->LA(1);
            	                if ( (LA210_0 == SQL92_RESERVED_IN))
            	                {
            	                    alt210=1;
            	                }
            	            }
            	            switch (alt210)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:753:26: in_key
            	        	    {
            	        	        this->followPush(FOLLOW_in_key_in_parameter_spec6112);
            	        	        in_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleparameter_specEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_type_spec_in_parameter_spec6115);
            	        type_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleparameter_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:754:9: ( default_value_part )?
            {
                int alt212=2;
                {
                    int LA212_0 = this->LA(1);
                    if ( (LA212_0 == ASSIGN_OP || LA212_0 == SQL92_RESERVED_DEFAULT))
                    {
                        alt212=1;
                    }
                }
                switch (alt212)
                {
            	case 1:
            	    // PLSQLParser.g:754:9: default_value_part
            	    {
            	        this->followPush(FOLLOW_default_value_part_in_parameter_spec6128);
            	        default_value_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleparameter_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleparameter_specEx; /* Prevent compiler warnings */
    ruleparameter_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end parameter_spec */

/**
 * $ANTLR start exception_declaration
 * PLSQLParser.g:757:1: exception_declaration : exception_name exception_key SEMICOLON ;
 */
void
PLSQLParser::exception_declaration()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:758:5: ( exception_name exception_key SEMICOLON )
        // PLSQLParser.g:758:10: exception_name exception_key SEMICOLON
        {
            this->followPush(FOLLOW_exception_name_in_exception_declaration6150);
            exception_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexception_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_exception_key_in_exception_declaration6152);
            exception_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexception_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_exception_declaration6154);
            if  (this->hasException())
            {
                goto ruleexception_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexception_declarationEx; /* Prevent compiler warnings */
    ruleexception_declarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exception_declaration */

/**
 * $ANTLR start pragma_declaration
 * PLSQLParser.g:761:1: pragma_declaration : pragma_key ( serially_reusable_key | autonomous_transaction_key | exception_init_key LEFT_PAREN exception_name COMMA numeric RIGHT_PAREN | inline_key LEFT_PAREN id1= id COMMA expression RIGHT_PAREN | restrict_references_key LEFT_PAREN ( id | default_key ) ( COMMA id )+ RIGHT_PAREN ) SEMICOLON ;
 */
void
PLSQLParser::pragma_declaration()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:762:5: ( pragma_key ( serially_reusable_key | autonomous_transaction_key | exception_init_key LEFT_PAREN exception_name COMMA numeric RIGHT_PAREN | inline_key LEFT_PAREN id1= id COMMA expression RIGHT_PAREN | restrict_references_key LEFT_PAREN ( id | default_key ) ( COMMA id )+ RIGHT_PAREN ) SEMICOLON )
        // PLSQLParser.g:762:10: pragma_key ( serially_reusable_key | autonomous_transaction_key | exception_init_key LEFT_PAREN exception_name COMMA numeric RIGHT_PAREN | inline_key LEFT_PAREN id1= id COMMA expression RIGHT_PAREN | restrict_references_key LEFT_PAREN ( id | default_key ) ( COMMA id )+ RIGHT_PAREN ) SEMICOLON
        {
            this->followPush(FOLLOW_pragma_key_in_pragma_declaration6187);
            pragma_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepragma_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:763:9: ( serially_reusable_key | autonomous_transaction_key | exception_init_key LEFT_PAREN exception_name COMMA numeric RIGHT_PAREN | inline_key LEFT_PAREN id1= id COMMA expression RIGHT_PAREN | restrict_references_key LEFT_PAREN ( id | default_key ) ( COMMA id )+ RIGHT_PAREN )
            {
                int alt215=5;
                alt215 = cdfa215.predict(this, this->get_rec(), this->get_istream(), cdfa215 );
                if  (this->hasException())
                {
                    goto rulepragma_declarationEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }

                switch (alt215)
                {
            	case 1:
            	    // PLSQLParser.g:763:14: serially_reusable_key
            	    {
            	        this->followPush(FOLLOW_serially_reusable_key_in_pragma_declaration6202);
            	        serially_reusable_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:764:14: autonomous_transaction_key
            	    {
            	        this->followPush(FOLLOW_autonomous_transaction_key_in_pragma_declaration6218);
            	        autonomous_transaction_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQLParser.g:765:14: exception_init_key LEFT_PAREN exception_name COMMA numeric RIGHT_PAREN
            	    {
            	        this->followPush(FOLLOW_exception_init_key_in_pragma_declaration6233);
            	        exception_init_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_pragma_declaration6235);
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_exception_name_in_pragma_declaration6237);
            	        exception_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_pragma_declaration6239);
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_numeric_in_pragma_declaration6241);
            	        numeric();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_pragma_declaration6243);
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 4:
            	    // PLSQLParser.g:766:14: inline_key LEFT_PAREN id1= id COMMA expression RIGHT_PAREN
            	    {
            	        this->followPush(FOLLOW_inline_key_in_pragma_declaration6259);
            	        inline_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_pragma_declaration6261);
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_in_pragma_declaration6265);
            	        id();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_pragma_declaration6267);
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_pragma_declaration6269);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_pragma_declaration6271);
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 5:
            	    // PLSQLParser.g:767:14: restrict_references_key LEFT_PAREN ( id | default_key ) ( COMMA id )+ RIGHT_PAREN
            	    {
            	        this->followPush(FOLLOW_restrict_references_key_in_pragma_declaration6286);
            	        restrict_references_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_pragma_declaration6288);
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:767:49: ( id | default_key )
            	        {
            	            int alt213=2;
            	            {
            	                int LA213_0 = this->LA(1);
            	                if ( (LA213_0 == DELIMITED_ID || LA213_0 == INTRODUCER || LA213_0 == REGULAR_ID))
            	                {
            	                    alt213=1;
            	                }
            	                else if ( (LA213_0 == SQL92_RESERVED_DEFAULT))
            	                {
            	                    alt213=2;
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 213 );
            	                    ex->set_state( 0 );


            	                    goto rulepragma_declarationEx;

            	                }
            	            }
            	            switch (alt213)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:767:50: id
            	        	    {
            	        	        this->followPush(FOLLOW_id_in_pragma_declaration6291);
            	        	        id();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepragma_declarationEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQLParser.g:767:53: default_key
            	        	    {
            	        	        this->followPush(FOLLOW_default_key_in_pragma_declaration6293);
            	        	        default_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepragma_declarationEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQLParser.g:767:66: ( COMMA id )+
            	        {
            	            int cnt214=0;

            	            for (;;)
            	            {
            	                int alt214=2;
            	        	{
            	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	        	    */
            	        	    int LA214_0 = this->LA(1);
            	        	    if ( (LA214_0 == COMMA))
            	        	    {
            	        	        alt214=1;
            	        	    }

            	        	}
            	        	switch (alt214)
            	        	{
            	        	    case 1:
            	        	        // PLSQLParser.g:767:67: COMMA id
            	        	        {
            	        	             this->matchToken(COMMA, &FOLLOW_COMMA_in_pragma_declaration6297);
            	        	            if  (this->hasException())
            	        	            {
            	        	                goto rulepragma_declarationEx;
            	        	            }
            	        	            if (this->hasFailed())
            	        	            {
            	        	                return ;
            	        	            }


            	        	            this->followPush(FOLLOW_id_in_pragma_declaration6299);
            	        	            id();

            	        	            this->followPop();
            	        	            if  (this->hasException())
            	        	            {
            	        	                goto rulepragma_declarationEx;
            	        	            }
            	        	            if (this->hasFailed())
            	        	            {
            	        	                return ;
            	        	            }


            	        	        }
            	        	        break;

            	        	    default:

            	        		if ( cnt214 >= 1 )
            	        		{
            	        		    goto loop214;
            	        		}
            	        		if (this->get_backtracking()>0)
            	        		{
            	        		    this->set_failedflag( true );
            	        		    return ;
            	        		}

            	        		/* mismatchedSetEx()
            	        		 */
            	        		new ANTLR_Exception< PLSQLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            	        		goto rulepragma_declarationEx;
            	        	}
            	        	cnt214++;
            	            }
            	            loop214: ;	/* Jump to here if this rule does not match */
            	        }

            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_pragma_declaration6303);
            	        if  (this->hasException())
            	        {
            	            goto rulepragma_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_pragma_declaration6323);
            if  (this->hasException())
            {
                goto rulepragma_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepragma_declarationEx; /* Prevent compiler warnings */
    rulepragma_declarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pragma_declaration */

/**
 * $ANTLR start record_declaration
 * PLSQLParser.g:772:1: record_declaration : ( record_type_dec | record_var_dec );
 */
void
PLSQLParser::record_declaration()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:773:5: ( record_type_dec | record_var_dec )

            ANTLR_UINT32 alt216;

            alt216=2;

            alt216 = cdfa216.predict(this, this->get_rec(), this->get_istream(), cdfa216 );
            if  (this->hasException())
            {
                goto rulerecord_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }

            switch (alt216)
            {
        	case 1:
        	    // PLSQLParser.g:773:10: record_type_dec
        	    {
        	        this->followPush(FOLLOW_record_type_dec_in_record_declaration6343);
        	        record_type_dec();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulerecord_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:774:10: record_var_dec
        	    {
        	        this->followPush(FOLLOW_record_var_dec_in_record_declaration6354);
        	        record_var_dec();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulerecord_declarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulerecord_declarationEx; /* Prevent compiler warnings */
    rulerecord_declarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end record_declaration */

/**
 * $ANTLR start record_type_dec
 * PLSQLParser.g:780:1: record_type_dec : type_key type_name is_key ( record_key LEFT_PAREN field_spec ( COMMA field_spec )* RIGHT_PAREN | ref_key cursor_key ( return_key type_spec )? ) SEMICOLON ;
 */
void
PLSQLParser::record_type_dec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:781:5: ( type_key type_name is_key ( record_key LEFT_PAREN field_spec ( COMMA field_spec )* RIGHT_PAREN | ref_key cursor_key ( return_key type_spec )? ) SEMICOLON )
        // PLSQLParser.g:781:10: type_key type_name is_key ( record_key LEFT_PAREN field_spec ( COMMA field_spec )* RIGHT_PAREN | ref_key cursor_key ( return_key type_spec )? ) SEMICOLON
        {
            this->followPush(FOLLOW_type_key_in_record_type_dec6377);
            type_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerecord_type_decEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_name_in_record_type_dec6379);
            type_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerecord_type_decEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_is_key_in_record_type_dec6381);
            is_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerecord_type_decEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:782:5: ( record_key LEFT_PAREN field_spec ( COMMA field_spec )* RIGHT_PAREN | ref_key cursor_key ( return_key type_spec )? )
            {
                int alt219=2;
                {
                    int LA219_0 = this->LA(1);
                    if ( (LA219_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "REF")))||((equalsIgnoreCase(LT(1)->getText(), "RECORD"))))))
                    {
                        {
                            int LA219_1 = this->LA(2);
                            if ( (LA219_1 == LEFT_PAREN) && ((equalsIgnoreCase(LT(1)->getText(), "RECORD"))))
                            {
                                alt219=1;
                            }
                            else if ( (LA219_1 == SQL92_RESERVED_CURSOR) && ((equalsIgnoreCase(LT(1)->getText(), "REF"))))
                            {
                                alt219=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 219 );
                                ex->set_state( 1 );


                                goto rulerecord_type_decEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 219 );
                        ex->set_state( 0 );


                        goto rulerecord_type_decEx;

                    }
                }
                switch (alt219)
                {
            	case 1:
            	    // PLSQLParser.g:782:10: record_key LEFT_PAREN field_spec ( COMMA field_spec )* RIGHT_PAREN
            	    {
            	        this->followPush(FOLLOW_record_key_in_record_type_dec6393);
            	        record_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerecord_type_decEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_record_type_dec6395);
            	        if  (this->hasException())
            	        {
            	            goto rulerecord_type_decEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_field_spec_in_record_type_dec6397);
            	        field_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerecord_type_decEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:782:43: ( COMMA field_spec )*

            	        for (;;)
            	        {
            	            int alt217=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA217_0 = this->LA(1);
            	                if ( (LA217_0 == COMMA))
            	                {
            	                    alt217=1;
            	                }

            	            }
            	            switch (alt217)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:782:45: COMMA field_spec
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_record_type_dec6401);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerecord_type_decEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_field_spec_in_record_type_dec6403);
            	        	        field_spec();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerecord_type_decEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop217;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop217: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_record_type_dec6408);
            	        if  (this->hasException())
            	        {
            	            goto rulerecord_type_decEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:783:10: ref_key cursor_key ( return_key type_spec )?
            	    {
            	        this->followPush(FOLLOW_ref_key_in_record_type_dec6419);
            	        ref_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerecord_type_decEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_cursor_key_in_record_type_dec6421);
            	        cursor_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerecord_type_decEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:783:29: ( return_key type_spec )?
            	        {
            	            int alt218=2;
            	            {
            	                int LA218_0 = this->LA(1);
            	                if ( (LA218_0 == REGULAR_ID))
            	                {
            	                    alt218=1;
            	                }
            	            }
            	            switch (alt218)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:783:30: return_key type_spec
            	        	    {
            	        	        this->followPush(FOLLOW_return_key_in_record_type_dec6424);
            	        	        return_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerecord_type_decEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_type_spec_in_record_type_dec6426);
            	        	        type_spec();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerecord_type_decEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_record_type_dec6439);
            if  (this->hasException())
            {
                goto rulerecord_type_decEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerecord_type_decEx; /* Prevent compiler warnings */
    rulerecord_type_decEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end record_type_dec */

/**
 * $ANTLR start field_spec
 * PLSQLParser.g:787:1: field_spec : column_name ( type_spec )? ( not_key null_key )? ( default_value_part )? ;
 */
void
PLSQLParser::field_spec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:788:5: ( column_name ( type_spec )? ( not_key null_key )? ( default_value_part )? )
        // PLSQLParser.g:788:10: column_name ( type_spec )? ( not_key null_key )? ( default_value_part )?
        {
            this->followPush(FOLLOW_column_name_in_field_spec6459);
            column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefield_specEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:788:22: ( type_spec )?
            {
                int alt220=2;
                {
                    int LA220_0 = this->LA(1);
                    if ( (LA220_0 == DELIMITED_ID || LA220_0 == REGULAR_ID || LA220_0 == SQL92_RESERVED_DATE))
                    {
                        alt220=1;
                    }
                }
                switch (alt220)
                {
            	case 1:
            	    // PLSQLParser.g:788:22: type_spec
            	    {
            	        this->followPush(FOLLOW_type_spec_in_field_spec6461);
            	        type_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefield_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:789:9: ( not_key null_key )?
            {
                int alt221=2;
                {
                    int LA221_0 = this->LA(1);
                    if ( (LA221_0 == SQL92_RESERVED_NOT))
                    {
                        alt221=1;
                    }
                }
                switch (alt221)
                {
            	case 1:
            	    // PLSQLParser.g:789:10: not_key null_key
            	    {
            	        this->followPush(FOLLOW_not_key_in_field_spec6473);
            	        not_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefield_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_null_key_in_field_spec6475);
            	        null_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefield_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:790:9: ( default_value_part )?
            {
                int alt222=2;
                {
                    int LA222_0 = this->LA(1);
                    if ( (LA222_0 == ASSIGN_OP || LA222_0 == SQL92_RESERVED_DEFAULT))
                    {
                        alt222=1;
                    }
                }
                switch (alt222)
                {
            	case 1:
            	    // PLSQLParser.g:790:9: default_value_part
            	    {
            	        this->followPush(FOLLOW_default_value_part_in_field_spec6487);
            	        default_value_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefield_specEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulefield_specEx; /* Prevent compiler warnings */
    rulefield_specEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end field_spec */

/**
 * $ANTLR start record_var_dec
 * PLSQLParser.g:793:1: record_var_dec : record_name type_name ( percent_rowtype_key | percent_type_key ) SEMICOLON ;
 */
void
PLSQLParser::record_var_dec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:794:5: ( record_name type_name ( percent_rowtype_key | percent_type_key ) SEMICOLON )
        // PLSQLParser.g:794:10: record_name type_name ( percent_rowtype_key | percent_type_key ) SEMICOLON
        {
            this->followPush(FOLLOW_record_name_in_record_var_dec6508);
            record_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerecord_var_decEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_name_in_record_var_dec6510);
            type_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerecord_var_decEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:794:32: ( percent_rowtype_key | percent_type_key )
            {
                int alt223=2;
                {
                    int LA223_0 = this->LA(1);
                    if ( (LA223_0 == PERCENT) && ((((equalsIgnoreCase(LT(2)->getText(), "TYPE")))||((equalsIgnoreCase(LT(2)->getText(), "ROWTYPE"))))))
                    {
                        {
                            int LA223_1 = this->LA(2);
                            if ( (LA223_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(2)->getText(), "TYPE")))||((equalsIgnoreCase(LT(2)->getText(), "ROWTYPE"))))))
                            {
                                {
                                    int LA223_2 = this->LA(3);
                                    if ( ((equalsIgnoreCase(LT(2)->getText(), "ROWTYPE"))))
                                    {
                                        alt223=1;
                                    }
                                    else if ( ((equalsIgnoreCase(LT(2)->getText(), "TYPE"))))
                                    {
                                        alt223=2;
                                    }
                                    else
                                    {
                                        if (this->get_backtracking()>0)
                                        {
                                            this->set_failedflag( true );
                                            return ;
                                        }


                                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                        ex->set_decisionNum( 223 );
                                        ex->set_state( 2 );


                                        goto rulerecord_var_decEx;

                                    }
                                }
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 223 );
                                ex->set_state( 1 );


                                goto rulerecord_var_decEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 223 );
                        ex->set_state( 0 );


                        goto rulerecord_var_decEx;

                    }
                }
                switch (alt223)
                {
            	case 1:
            	    // PLSQLParser.g:794:33: percent_rowtype_key
            	    {
            	        this->followPush(FOLLOW_percent_rowtype_key_in_record_var_dec6513);
            	        percent_rowtype_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerecord_var_decEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:794:53: percent_type_key
            	    {
            	        this->followPush(FOLLOW_percent_type_key_in_record_var_dec6515);
            	        percent_type_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerecord_var_decEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_record_var_dec6518);
            if  (this->hasException())
            {
                goto rulerecord_var_decEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerecord_var_decEx; /* Prevent compiler warnings */
    rulerecord_var_decEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end record_var_dec */

/**
 * $ANTLR start table_declaration
 * PLSQLParser.g:799:1: table_declaration : ( table_type_dec | table_var_dec ) SEMICOLON ;
 */
void
PLSQLParser::table_declaration()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:800:5: ( ( table_type_dec | table_var_dec ) SEMICOLON )
        // PLSQLParser.g:800:10: ( table_type_dec | table_var_dec ) SEMICOLON
        {
            // PLSQLParser.g:800:10: ( table_type_dec | table_var_dec )
            {
                int alt224=2;
                alt224 = cdfa224.predict(this, this->get_rec(), this->get_istream(), cdfa224 );
                if  (this->hasException())
                {
                    goto ruletable_declarationEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }

                switch (alt224)
                {
            	case 1:
            	    // PLSQLParser.g:800:11: table_type_dec
            	    {
            	        this->followPush(FOLLOW_table_type_dec_in_table_declaration6541);
            	        table_type_dec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:800:28: table_var_dec
            	    {
            	        this->followPush(FOLLOW_table_var_dec_in_table_declaration6545);
            	        table_var_dec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_declarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_table_declaration6548);
            if  (this->hasException())
            {
                goto ruletable_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_declarationEx; /* Prevent compiler warnings */
    ruletable_declarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_declaration */

/**
 * $ANTLR start table_type_dec
 * PLSQLParser.g:803:1: table_type_dec : type_key type_name is_key ( table_key of_key type_spec ( table_indexed_by_part )? ( not_key null_key )? | varray_type_def ) ;
 */
void
PLSQLParser::table_type_dec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:804:5: ( type_key type_name is_key ( table_key of_key type_spec ( table_indexed_by_part )? ( not_key null_key )? | varray_type_def ) )
        // PLSQLParser.g:804:10: type_key type_name is_key ( table_key of_key type_spec ( table_indexed_by_part )? ( not_key null_key )? | varray_type_def )
        {
            this->followPush(FOLLOW_type_key_in_table_type_dec6568);
            type_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_type_decEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_name_in_table_type_dec6570);
            type_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_type_decEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_is_key_in_table_type_dec6572);
            is_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_type_decEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:805:5: ( table_key of_key type_spec ( table_indexed_by_part )? ( not_key null_key )? | varray_type_def )
            {
                int alt227=2;
                {
                    int LA227_0 = this->LA(1);
                    if ( (LA227_0 == SQL92_RESERVED_TABLE))
                    {
                        alt227=1;
                    }
                    else if ( (LA227_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "VARRAY")))||((equalsIgnoreCase(LT(1)->getText(), "VARYING"))))))
                    {
                        alt227=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 227 );
                        ex->set_state( 0 );


                        goto ruletable_type_decEx;

                    }
                }
                switch (alt227)
                {
            	case 1:
            	    // PLSQLParser.g:805:10: table_key of_key type_spec ( table_indexed_by_part )? ( not_key null_key )?
            	    {
            	        this->followPush(FOLLOW_table_key_in_table_type_dec6584);
            	        table_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_type_decEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_of_key_in_table_type_dec6598);
            	        of_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_type_decEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_type_spec_in_table_type_dec6600);
            	        type_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_type_decEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:807:13: ( table_indexed_by_part )?
            	        {
            	            int alt225=2;
            	            {
            	                int LA225_0 = this->LA(1);
            	                if ( (LA225_0 == PLSQL_RESERVED_INDEX || LA225_0 == REGULAR_ID))
            	                {
            	                    alt225=1;
            	                }
            	            }
            	            switch (alt225)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:807:13: table_indexed_by_part
            	        	    {
            	        	        this->followPush(FOLLOW_table_indexed_by_part_in_table_type_dec6615);
            	        	        table_indexed_by_part();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletable_type_decEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQLParser.g:808:9: ( not_key null_key )?
            	        {
            	            int alt226=2;
            	            {
            	                int LA226_0 = this->LA(1);
            	                if ( (LA226_0 == SQL92_RESERVED_NOT))
            	                {
            	                    alt226=1;
            	                }
            	            }
            	            switch (alt226)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:808:10: not_key null_key
            	        	    {
            	        	        this->followPush(FOLLOW_not_key_in_table_type_dec6627);
            	        	        not_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletable_type_decEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_null_key_in_table_type_dec6629);
            	        	        null_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletable_type_decEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:809:10: varray_type_def
            	    {
            	        this->followPush(FOLLOW_varray_type_def_in_table_type_dec6642);
            	        varray_type_def();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_type_decEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_type_decEx; /* Prevent compiler warnings */
    ruletable_type_decEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_type_dec */

/**
 * $ANTLR start table_indexed_by_part
 * PLSQLParser.g:813:1: table_indexed_by_part : (idx1= indexed_key |idx2= index_key ) by_key type_spec ;
 */
void
PLSQLParser::table_indexed_by_part()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:814:5: ( (idx1= indexed_key |idx2= index_key ) by_key type_spec )
        // PLSQLParser.g:814:10: (idx1= indexed_key |idx2= index_key ) by_key type_spec
        {
            // PLSQLParser.g:814:10: (idx1= indexed_key |idx2= index_key )
            {
                int alt228=2;
                {
                    int LA228_0 = this->LA(1);
                    if ( (LA228_0 == REGULAR_ID))
                    {
                        alt228=1;
                    }
                    else if ( (LA228_0 == PLSQL_RESERVED_INDEX))
                    {
                        alt228=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 228 );
                        ex->set_state( 0 );


                        goto ruletable_indexed_by_partEx;

                    }
                }
                switch (alt228)
                {
            	case 1:
            	    // PLSQLParser.g:814:11: idx1= indexed_key
            	    {
            	        this->followPush(FOLLOW_indexed_key_in_table_indexed_by_part6671);
            	        indexed_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_indexed_by_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:814:28: idx2= index_key
            	    {
            	        this->followPush(FOLLOW_index_key_in_table_indexed_by_part6675);
            	        index_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_indexed_by_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_by_key_in_table_indexed_by_part6678);
            by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_indexed_by_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_spec_in_table_indexed_by_part6680);
            type_spec();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_indexed_by_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_indexed_by_partEx; /* Prevent compiler warnings */
    ruletable_indexed_by_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_indexed_by_part */

/**
 * $ANTLR start varray_type_def
 * PLSQLParser.g:817:1: varray_type_def : ( varray_key | varying_key array_key ) LEFT_PAREN expression RIGHT_PAREN of_key type_spec ( not_key null_key )? ;
 */
void
PLSQLParser::varray_type_def()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:818:5: ( ( varray_key | varying_key array_key ) LEFT_PAREN expression RIGHT_PAREN of_key type_spec ( not_key null_key )? )
        // PLSQLParser.g:818:10: ( varray_key | varying_key array_key ) LEFT_PAREN expression RIGHT_PAREN of_key type_spec ( not_key null_key )?
        {
            // PLSQLParser.g:818:10: ( varray_key | varying_key array_key )
            {
                int alt229=2;
                {
                    int LA229_0 = this->LA(1);
                    if ( (LA229_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "VARRAY")))||((equalsIgnoreCase(LT(1)->getText(), "VARYING"))))))
                    {
                        {
                            int LA229_1 = this->LA(2);
                            if ( (LA229_1 == LEFT_PAREN) && ((equalsIgnoreCase(LT(1)->getText(), "VARRAY"))))
                            {
                                alt229=1;
                            }
                            else if ( (LA229_1 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "VARYING"))))
                            {
                                alt229=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 229 );
                                ex->set_state( 1 );


                                goto rulevarray_type_defEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 229 );
                        ex->set_state( 0 );


                        goto rulevarray_type_defEx;

                    }
                }
                switch (alt229)
                {
            	case 1:
            	    // PLSQLParser.g:818:11: varray_key
            	    {
            	        this->followPush(FOLLOW_varray_key_in_varray_type_def6701);
            	        varray_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulevarray_type_defEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:818:23: varying_key array_key
            	    {
            	        this->followPush(FOLLOW_varying_key_in_varray_type_def6704);
            	        varying_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulevarray_type_defEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_array_key_in_varray_type_def6706);
            	        array_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulevarray_type_defEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_varray_type_def6717);
            if  (this->hasException())
            {
                goto rulevarray_type_defEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_varray_type_def6719);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulevarray_type_defEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_varray_type_def6721);
            if  (this->hasException())
            {
                goto rulevarray_type_defEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_of_key_in_varray_type_def6732);
            of_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulevarray_type_defEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_spec_in_varray_type_def6734);
            type_spec();

            this->followPop();
            if  (this->hasException())
            {
                goto rulevarray_type_defEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:821:9: ( not_key null_key )?
            {
                int alt230=2;
                {
                    int LA230_0 = this->LA(1);
                    if ( (LA230_0 == SQL92_RESERVED_NOT))
                    {
                        {
                            int LA230_1 = this->LA(2);
                            if ( (LA230_1 == SQL92_RESERVED_NULL))
                            {
                                alt230=1;
                            }
                        }
                    }
                }
                switch (alt230)
                {
            	case 1:
            	    // PLSQLParser.g:821:10: not_key null_key
            	    {
            	        this->followPush(FOLLOW_not_key_in_varray_type_def6745);
            	        not_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulevarray_type_defEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_null_key_in_varray_type_def6747);
            	        null_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulevarray_type_defEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulevarray_type_defEx; /* Prevent compiler warnings */
    rulevarray_type_defEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end varray_type_def */

/**
 * $ANTLR start table_var_dec
 * PLSQLParser.g:824:1: table_var_dec : table_var_name type_spec ;
 */
void
PLSQLParser::table_var_dec()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:825:5: ( table_var_name type_spec )
        // PLSQLParser.g:825:10: table_var_name type_spec
        {
            this->followPush(FOLLOW_table_var_name_in_table_var_dec6769);
            table_var_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_var_decEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_type_spec_in_table_var_dec6771);
            type_spec();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_var_decEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_var_decEx; /* Prevent compiler warnings */
    ruletable_var_decEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_var_dec */

/**
 * $ANTLR start seq_of_statements
 * PLSQLParser.g:832:1: seq_of_statements returns [void* p, void*q] : ( statement ( SEMICOLON | EOF ) | label_declaration )+ ;
 */
PLSQLParser::seq_of_statements_return
PLSQLParser::seq_of_statements()
{
    PLSQLParser::seq_of_statements_return retval(this);


    /* Initialize rule variables
     */
      

    retval.call_start_placeholder();


 
    {
        // PLSQLParser.g:833:5: ( ( statement ( SEMICOLON | EOF ) | label_declaration )+ )
        // PLSQLParser.g:833:11: ( statement ( SEMICOLON | EOF ) | label_declaration )+
        {
            // PLSQLParser.g:833:11: ( statement ( SEMICOLON | EOF ) | label_declaration )+
            {
                int cnt231=0;

                for (;;)
                {
                    int alt231=3;
            	switch ( this->LA(1) )
            	{
            	case SQL92_RESERVED_CREATE:
            		{
            			alt231=1;
            		}
            	    break;
            	case SQL92_RESERVED_ALTER:
            		{
            			alt231=1;
            		}
            	    break;
            	case SQL92_RESERVED_GRANT:
            		{
            			alt231=1;
            		}
            	    break;
            	case REGULAR_ID:
            		{
            			alt231=1;
            		}
            	    break;
            	case SQL92_RESERVED_BEGIN:
            		{
            			alt231=1;
            		}
            	    break;
            	case SQL92_RESERVED_DECLARE:
            		{
            			alt231=1;
            		}
            	    break;
            	case INTRODUCER:
            		{
            			alt231=1;
            		}
            	    break;
            	case DELIMITED_ID:
            		{
            			alt231=1;
            		}
            	    break;
            	case BINDVAR:
            		{
            			alt231=1;
            		}
            	    break;
            	case COLON:
            		{
            			alt231=1;
            		}
            	    break;
            	case SQL92_RESERVED_CURSOR:
            		{
            			alt231=1;
            		}
            	    break;
            	case SQL92_RESERVED_PROCEDURE:
            		{
            			alt231=1;
            		}
            	    break;
            	case SQL92_RESERVED_GOTO:
            		{
            			alt231=1;
            		}
            	    break;
            	case PLSQL_RESERVED_IF:
            		{
            			alt231=1;
            		}
            	    break;
            	case SQL92_RESERVED_FOR:
            		{
            			alt231=1;
            		}
            	    break;
            	case SQL92_RESERVED_NULL:
            		{
            			alt231=1;
            		}
            	    break;
            	case SQL92_RESERVED_CASE:
            		{
            			alt231=1;
            		}
            	    break;
            	case PLSQL_RESERVED_LOCK:
            		{
            			alt231=1;
            		}
            	    break;
            	case SQL92_RESERVED_WITH:
            		{
            			alt231=1;
            		}
            	    break;
            	case SQL92_RESERVED_SELECT:
            		{
            			alt231=1;
            		}
            	    break;
            	case LEFT_PAREN:
            		{
            			alt231=1;
            		}
            	    break;
            	case SQL92_RESERVED_UPDATE:
            		{
            			alt231=1;
            		}
            	    break;
            	case SQL92_RESERVED_DELETE:
            		{
            			alt231=1;
            		}
            	    break;
            	case SQL92_RESERVED_INSERT:
            		{
            			alt231=1;
            		}
            	    break;
            	case SQL92_RESERVED_FETCH:
            		{
            			alt231=1;
            		}
            	    break;
            	case LESS_THAN_OP:
            		{
            			alt231=2;
            		}
            	    break;

            	}

            	switch (alt231)
            	{
            	    case 1:
            	        // PLSQLParser.g:833:12: statement ( SEMICOLON | EOF )
            	        {
            	            this->followPush(FOLLOW_statement_in_seq_of_statements6800);
            	            statement();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleseq_of_statementsEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return retval;
            	            }


            	            if ( this->LA(1) == EOF || this->LA(1) == SEMICOLON )
            	            {
            	                this->consume();
            	                this->set_perror_recovery(false);
            	                 this->set_failedflag(false); 

            	            }
            	            else
            	            {
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return retval;
            	                }

            	                new ANTLR_Exception< PLSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                this->get_exception()->set_expectingSet(NULL);

            	                goto ruleseq_of_statementsEx;
            	            }


            	        }
            	        break;
            	    case 2:
            	        // PLSQLParser.g:833:38: label_declaration
            	        {
            	            this->followPush(FOLLOW_label_declaration_in_seq_of_statements6808);
            	            label_declaration();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleseq_of_statementsEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return retval;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt231 >= 1 )
            		{
            		    goto loop231;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PLSQLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleseq_of_statementsEx;
            	}
            	cnt231++;
                }
                loop231: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleseq_of_statementsEx; /* Prevent compiler warnings */
    ruleseq_of_statementsEx: ;
    retval.call_stop_placeholder();



    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retval;
}
/* $ANTLR end seq_of_statements */

/**
 * $ANTLR start label_declaration
 * PLSQLParser.g:836:1: label_declaration : ltp1= LESS_THAN_OP LESS_THAN_OP label_name GREATER_THAN_OP GREATER_THAN_OP ;
 */
void
PLSQLParser::label_declaration()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    ImplTraits::CommonTokenType const* ltp1 = NULL;

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:837:5: (ltp1= LESS_THAN_OP LESS_THAN_OP label_name GREATER_THAN_OP GREATER_THAN_OP )
        // PLSQLParser.g:837:10: ltp1= LESS_THAN_OP LESS_THAN_OP label_name GREATER_THAN_OP GREATER_THAN_OP
        {
            ltp1 =  this->matchToken(LESS_THAN_OP, &FOLLOW_LESS_THAN_OP_in_label_declaration6834);
            if  (this->hasException())
            {
                goto rulelabel_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LESS_THAN_OP, &FOLLOW_LESS_THAN_OP_in_label_declaration6836);
            if  (this->hasException())
            {
                goto rulelabel_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_label_name_in_label_declaration6838);
            label_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelabel_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(GREATER_THAN_OP, &FOLLOW_GREATER_THAN_OP_in_label_declaration6840);
            if  (this->hasException())
            {
                goto rulelabel_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(GREATER_THAN_OP, &FOLLOW_GREATER_THAN_OP_in_label_declaration6842);
            if  (this->hasException())
            {
                goto rulelabel_declarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelabel_declarationEx; /* Prevent compiler warnings */
    rulelabel_declarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end label_declaration */

/**
 * $ANTLR start statement
 * PLSQLParser.g:840:1: statement options {backtrack=true; } : ( create_key swallow_to_semi ( SEMICOLON | EOF ) | alter_key swallow_to_semi ( SEMICOLON | EOF ) | grant_key swallow_to_semi ( SEMICOLON | EOF ) | truncate_key swallow_to_semi ( SEMICOLON | EOF ) | ( begin_key )=> body | ( declare_key )=> block | assignment_statement | continue_statement | exit_statement | goto_statement | if_statement | loop_statement | forall_statement | null_statement | raise_statement | return_statement | case_statement[true] | sql_statement | function_call );
 */
void
PLSQLParser::statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:844:5: ( create_key swallow_to_semi ( SEMICOLON | EOF ) | alter_key swallow_to_semi ( SEMICOLON | EOF ) | grant_key swallow_to_semi ( SEMICOLON | EOF ) | truncate_key swallow_to_semi ( SEMICOLON | EOF ) | ( begin_key )=> body | ( declare_key )=> block | assignment_statement | continue_statement | exit_statement | goto_statement | if_statement | loop_statement | forall_statement | null_statement | raise_statement | return_statement | case_statement[true] | sql_statement | function_call )

            ANTLR_UINT32 alt232;

            alt232=19;

            {
                int LA232_0 = this->LA(1);
                if ( (LA232_0 == SQL92_RESERVED_CREATE))
                {
                    {
                        int LA232_1 = this->LA(2);
                        if ( (this->msynpred( antlr3::ClassForwarder<synpred44_PLSQLParser>() )))
                        {
                            alt232=1;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred49_PLSQLParser>() )))
                        {
                            alt232=6;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 232 );
                            ex->set_state( 1 );


                            goto rulestatementEx;

                        }
                    }
                }
                else if ( (LA232_0 == SQL92_RESERVED_ALTER))
                {
                    alt232=2;
                }
                else if ( (LA232_0 == SQL92_RESERVED_GRANT))
                {
                    alt232=3;
                }
                else if ( (LA232_0 == REGULAR_ID))
                {
                    {
                        int LA232_4 = this->LA(2);
                        if ( (( (this->msynpred( antlr3::ClassForwarder<synpred47_PLSQLParser>() )) && ((equalsIgnoreCase(LT(1)->getText(), "TRUNCATE"))) )))
                        {
                            alt232=4;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred49_PLSQLParser>() )))
                        {
                            alt232=6;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred50_PLSQLParser>() )))
                        {
                            alt232=7;
                        }
                        else if ( (( ((equalsIgnoreCase(LT(1)->getText(), "CONTINUE"))) && (this->msynpred( antlr3::ClassForwarder<synpred51_PLSQLParser>() )) )))
                        {
                            alt232=8;
                        }
                        else if ( (( (this->msynpred( antlr3::ClassForwarder<synpred52_PLSQLParser>() )) && ((equalsIgnoreCase(LT(1)->getText(), "EXIT"))) )))
                        {
                            alt232=9;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred55_PLSQLParser>() )))
                        {
                            alt232=12;
                        }
                        else if ( (( (this->msynpred( antlr3::ClassForwarder<synpred56_PLSQLParser>() )) && ((equalsIgnoreCase(LT(1)->getText(), "FORALL"))) )))
                        {
                            alt232=13;
                        }
                        else if ( (( ((equalsIgnoreCase(LT(1)->getText(), "RAISE"))) && (this->msynpred( antlr3::ClassForwarder<synpred58_PLSQLParser>() )) )))
                        {
                            alt232=15;
                        }
                        else if ( (( ((equalsIgnoreCase(LT(1)->getText(), "RETURN"))) && (this->msynpred( antlr3::ClassForwarder<synpred59_PLSQLParser>() )) )))
                        {
                            alt232=16;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred60_PLSQLParser>() )))
                        {
                            alt232=17;
                        }
                        else if ( (( (this->msynpred( antlr3::ClassForwarder<synpred61_PLSQLParser>() )) && ((((equalsIgnoreCase(LT(1)->getText(), "EXPLAIN")))||((equalsIgnoreCase(LT(1)->getText(), "OPEN")))||((equalsIgnoreCase(LT(1)->getText(), "COMMIT")))||((equalsIgnoreCase(LT(1)->getText(), "MERGE")))||((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT")))||((equalsIgnoreCase(LT(1)->getText(), "EXECUTE")))||((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "CLOSE")))||((equalsIgnoreCase(LT(1)->getText(), "ROLLBACK"))))) )))
                        {
                            alt232=18;
                        }
                        else if ( (true))
                        {
                            alt232=19;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 232 );
                            ex->set_state( 4 );


                            goto rulestatementEx;

                        }
                    }
                }
                else if ( (LA232_0 == SQL92_RESERVED_BEGIN) && (this->msynpred( antlr3::ClassForwarder<synpred48_PLSQLParser>() )))
                {
                    alt232=5;
                }
                else if ( (LA232_0 == SQL92_RESERVED_DECLARE) && (this->msynpred( antlr3::ClassForwarder<synpred49_PLSQLParser>() )))
                {
                    alt232=6;
                }
                else if ( (LA232_0 == INTRODUCER))
                {
                    {
                        int LA232_7 = this->LA(2);
                        if ( (this->msynpred( antlr3::ClassForwarder<synpred49_PLSQLParser>() )))
                        {
                            alt232=6;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred50_PLSQLParser>() )))
                        {
                            alt232=7;
                        }
                        else if ( (true))
                        {
                            alt232=19;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 232 );
                            ex->set_state( 7 );


                            goto rulestatementEx;

                        }
                    }
                }
                else if ( (LA232_0 == DELIMITED_ID))
                {
                    {
                        int LA232_8 = this->LA(2);
                        if ( (this->msynpred( antlr3::ClassForwarder<synpred49_PLSQLParser>() )))
                        {
                            alt232=6;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred50_PLSQLParser>() )))
                        {
                            alt232=7;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred55_PLSQLParser>() )))
                        {
                            alt232=12;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred60_PLSQLParser>() )))
                        {
                            alt232=17;
                        }
                        else if ( (true))
                        {
                            alt232=19;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 232 );
                            ex->set_state( 8 );


                            goto rulestatementEx;

                        }
                    }
                }
                else if ( (LA232_0 == BINDVAR))
                {
                    {
                        int LA232_9 = this->LA(2);
                        if ( (this->msynpred( antlr3::ClassForwarder<synpred49_PLSQLParser>() )))
                        {
                            alt232=6;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred50_PLSQLParser>() )))
                        {
                            alt232=7;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 232 );
                            ex->set_state( 9 );


                            goto rulestatementEx;

                        }
                    }
                }
                else if ( (LA232_0 == COLON))
                {
                    {
                        int LA232_10 = this->LA(2);
                        if ( (this->msynpred( antlr3::ClassForwarder<synpred49_PLSQLParser>() )))
                        {
                            alt232=6;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred50_PLSQLParser>() )))
                        {
                            alt232=7;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 232 );
                            ex->set_state( 10 );


                            goto rulestatementEx;

                        }
                    }
                }
                else if ( (LA232_0 == SQL92_RESERVED_CURSOR) && (this->msynpred( antlr3::ClassForwarder<synpred49_PLSQLParser>() )))
                {
                    alt232=6;
                }
                else if ( (LA232_0 == SQL92_RESERVED_PROCEDURE) && (this->msynpred( antlr3::ClassForwarder<synpred49_PLSQLParser>() )))
                {
                    alt232=6;
                }
                else if ( (LA232_0 == SQL92_RESERVED_GOTO))
                {
                    alt232=10;
                }
                else if ( (LA232_0 == PLSQL_RESERVED_IF))
                {
                    alt232=11;
                }
                else if ( (LA232_0 == SQL92_RESERVED_FOR))
                {
                    alt232=12;
                }
                else if ( (LA232_0 == SQL92_RESERVED_NULL))
                {
                    alt232=14;
                }
                else if ( (LA232_0 == SQL92_RESERVED_CASE))
                {
                    alt232=17;
                }
                else if ( (LA232_0 == LEFT_PAREN || LA232_0 == PLSQL_RESERVED_LOCK || LA232_0 == SQL92_RESERVED_DELETE || LA232_0 == SQL92_RESERVED_FETCH || LA232_0 == SQL92_RESERVED_INSERT || LA232_0 == SQL92_RESERVED_SELECT || LA232_0 == SQL92_RESERVED_UPDATE || LA232_0 == SQL92_RESERVED_WITH))
                {
                    alt232=18;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 232 );
                    ex->set_state( 0 );


                    goto rulestatementEx;

                }
            }
            switch (alt232)
            {
        	case 1:
        	    // PLSQLParser.g:844:10: create_key swallow_to_semi ( SEMICOLON | EOF )
        	    {
        	        this->followPush(FOLLOW_create_key_in_statement6871);
        	        create_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_swallow_to_semi_in_statement6873);
        	        swallow_to_semi();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        if ( this->LA(1) == EOF || this->LA(1) == SEMICOLON )
        	        {
        	            this->consume();
        	            this->set_perror_recovery(false);
        	             this->set_failedflag(false); 

        	        }
        	        else
        	        {
        	            if (this->get_backtracking()>0)
        	            {
        	                this->set_failedflag( true );
        	                return ;
        	            }

        	            new ANTLR_Exception< PLSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            this->get_exception()->set_expectingSet(NULL);

        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:845:10: alter_key swallow_to_semi ( SEMICOLON | EOF )
        	    {
        	        this->followPush(FOLLOW_alter_key_in_statement6890);
        	        alter_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_swallow_to_semi_in_statement6892);
        	        swallow_to_semi();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        if ( this->LA(1) == EOF || this->LA(1) == SEMICOLON )
        	        {
        	            this->consume();
        	            this->set_perror_recovery(false);
        	             this->set_failedflag(false); 

        	        }
        	        else
        	        {
        	            if (this->get_backtracking()>0)
        	            {
        	                this->set_failedflag( true );
        	                return ;
        	            }

        	            new ANTLR_Exception< PLSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            this->get_exception()->set_expectingSet(NULL);

        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLParser.g:846:10: grant_key swallow_to_semi ( SEMICOLON | EOF )
        	    {
        	        this->followPush(FOLLOW_grant_key_in_statement6910);
        	        grant_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_swallow_to_semi_in_statement6912);
        	        swallow_to_semi();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        if ( this->LA(1) == EOF || this->LA(1) == SEMICOLON )
        	        {
        	            this->consume();
        	            this->set_perror_recovery(false);
        	             this->set_failedflag(false); 

        	        }
        	        else
        	        {
        	            if (this->get_backtracking()>0)
        	            {
        	                this->set_failedflag( true );
        	                return ;
        	            }

        	            new ANTLR_Exception< PLSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            this->get_exception()->set_expectingSet(NULL);

        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQLParser.g:847:10: truncate_key swallow_to_semi ( SEMICOLON | EOF )
        	    {
        	        this->followPush(FOLLOW_truncate_key_in_statement6930);
        	        truncate_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_swallow_to_semi_in_statement6932);
        	        swallow_to_semi();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        if ( this->LA(1) == EOF || this->LA(1) == SEMICOLON )
        	        {
        	            this->consume();
        	            this->set_perror_recovery(false);
        	             this->set_failedflag(false); 

        	        }
        	        else
        	        {
        	            if (this->get_backtracking()>0)
        	            {
        	                this->set_failedflag( true );
        	                return ;
        	            }

        	            new ANTLR_Exception< PLSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            this->get_exception()->set_expectingSet(NULL);

        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQLParser.g:848:10: ( begin_key )=> body
        	    {
        	        this->followPush(FOLLOW_body_in_statement6956);
        	        body();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // PLSQLParser.g:849:10: ( declare_key )=> block
        	    {
        	        this->followPush(FOLLOW_block_in_statement6973);
        	        block();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 7:
        	    // PLSQLParser.g:850:10: assignment_statement
        	    {
        	        this->followPush(FOLLOW_assignment_statement_in_statement6984);
        	        assignment_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 8:
        	    // PLSQLParser.g:851:10: continue_statement
        	    {
        	        this->followPush(FOLLOW_continue_statement_in_statement6995);
        	        continue_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 9:
        	    // PLSQLParser.g:852:10: exit_statement
        	    {
        	        this->followPush(FOLLOW_exit_statement_in_statement7006);
        	        exit_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 10:
        	    // PLSQLParser.g:853:10: goto_statement
        	    {
        	        this->followPush(FOLLOW_goto_statement_in_statement7017);
        	        goto_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 11:
        	    // PLSQLParser.g:854:10: if_statement
        	    {
        	        this->followPush(FOLLOW_if_statement_in_statement7028);
        	        if_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 12:
        	    // PLSQLParser.g:855:10: loop_statement
        	    {
        	        this->followPush(FOLLOW_loop_statement_in_statement7039);
        	        loop_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 13:
        	    // PLSQLParser.g:856:10: forall_statement
        	    {
        	        this->followPush(FOLLOW_forall_statement_in_statement7050);
        	        forall_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 14:
        	    // PLSQLParser.g:857:10: null_statement
        	    {
        	        this->followPush(FOLLOW_null_statement_in_statement7061);
        	        null_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 15:
        	    // PLSQLParser.g:858:10: raise_statement
        	    {
        	        this->followPush(FOLLOW_raise_statement_in_statement7072);
        	        raise_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 16:
        	    // PLSQLParser.g:859:10: return_statement
        	    {
        	        this->followPush(FOLLOW_return_statement_in_statement7083);
        	        return_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 17:
        	    // PLSQLParser.g:860:10: case_statement[true]
        	    {
        	        this->followPush(FOLLOW_case_statement_in_statement7094);
        	        case_statement(true);

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 18:
        	    // PLSQLParser.g:861:10: sql_statement
        	    {
        	        this->followPush(FOLLOW_sql_statement_in_statement7106);
        	        sql_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 19:
        	    // PLSQLParser.g:862:10: function_call
        	    {
        	        this->followPush(FOLLOW_function_call_in_statement7117);
        	        function_call();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end statement */

/**
 * $ANTLR start assignment_statement
 * PLSQLParser.g:865:1: assignment_statement : ( general_element | bind_variable ) ASSIGN_OP expression ;
 */
void
PLSQLParser::assignment_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:866:5: ( ( general_element | bind_variable ) ASSIGN_OP expression )
        // PLSQLParser.g:866:11: ( general_element | bind_variable ) ASSIGN_OP expression
        {
            // PLSQLParser.g:866:11: ( general_element | bind_variable )
            {
                int alt233=2;
                {
                    int LA233_0 = this->LA(1);
                    if ( (LA233_0 == DELIMITED_ID || LA233_0 == INTRODUCER || LA233_0 == REGULAR_ID))
                    {
                        alt233=1;
                    }
                    else if ( (LA233_0 == BINDVAR || LA233_0 == COLON))
                    {
                        alt233=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 233 );
                        ex->set_state( 0 );


                        goto ruleassignment_statementEx;

                    }
                }
                switch (alt233)
                {
            	case 1:
            	    // PLSQLParser.g:866:12: general_element
            	    {
            	        this->followPush(FOLLOW_general_element_in_assignment_statement7139);
            	        general_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleassignment_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:866:28: bind_variable
            	    {
            	        this->followPush(FOLLOW_bind_variable_in_assignment_statement7141);
            	        bind_variable();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleassignment_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(ASSIGN_OP, &FOLLOW_ASSIGN_OP_in_assignment_statement7144);
            if  (this->hasException())
            {
                goto ruleassignment_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_assignment_statement7146);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleassignment_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleassignment_statementEx; /* Prevent compiler warnings */
    ruleassignment_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end assignment_statement */

/**
 * $ANTLR start continue_statement
 * PLSQLParser.g:869:1: continue_statement : continue_key ( label_name )? ( when_key condition )? ;
 */
void
PLSQLParser::continue_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:870:5: ( continue_key ( label_name )? ( when_key condition )? )
        // PLSQLParser.g:870:10: continue_key ( label_name )? ( when_key condition )?
        {
            this->followPush(FOLLOW_continue_key_in_continue_statement7166);
            continue_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecontinue_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:870:23: ( label_name )?
            {
                int alt234=2;
                {
                    int LA234_0 = this->LA(1);
                    if ( (LA234_0 == DELIMITED_ID || LA234_0 == REGULAR_ID))
                    {
                        alt234=1;
                    }
                }
                switch (alt234)
                {
            	case 1:
            	    // PLSQLParser.g:870:23: label_name
            	    {
            	        this->followPush(FOLLOW_label_name_in_continue_statement7168);
            	        label_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecontinue_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:870:35: ( when_key condition )?
            {
                int alt235=2;
                {
                    int LA235_0 = this->LA(1);
                    if ( (LA235_0 == SQL92_RESERVED_WHEN))
                    {
                        alt235=1;
                    }
                }
                switch (alt235)
                {
            	case 1:
            	    // PLSQLParser.g:870:36: when_key condition
            	    {
            	        this->followPush(FOLLOW_when_key_in_continue_statement7172);
            	        when_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecontinue_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_condition_in_continue_statement7174);
            	        condition();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecontinue_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulecontinue_statementEx; /* Prevent compiler warnings */
    rulecontinue_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end continue_statement */

/**
 * $ANTLR start exit_statement
 * PLSQLParser.g:873:1: exit_statement : exit_key ( label_name )? ( when_key condition )? ;
 */
void
PLSQLParser::exit_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:874:5: ( exit_key ( label_name )? ( when_key condition )? )
        // PLSQLParser.g:874:10: exit_key ( label_name )? ( when_key condition )?
        {
            this->followPush(FOLLOW_exit_key_in_exit_statement7196);
            exit_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexit_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:874:19: ( label_name )?
            {
                int alt236=2;
                {
                    int LA236_0 = this->LA(1);
                    if ( (LA236_0 == DELIMITED_ID || LA236_0 == REGULAR_ID))
                    {
                        alt236=1;
                    }
                }
                switch (alt236)
                {
            	case 1:
            	    // PLSQLParser.g:874:19: label_name
            	    {
            	        this->followPush(FOLLOW_label_name_in_exit_statement7198);
            	        label_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexit_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:874:31: ( when_key condition )?
            {
                int alt237=2;
                {
                    int LA237_0 = this->LA(1);
                    if ( (LA237_0 == SQL92_RESERVED_WHEN))
                    {
                        alt237=1;
                    }
                }
                switch (alt237)
                {
            	case 1:
            	    // PLSQLParser.g:874:32: when_key condition
            	    {
            	        this->followPush(FOLLOW_when_key_in_exit_statement7202);
            	        when_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexit_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_condition_in_exit_statement7204);
            	        condition();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexit_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexit_statementEx; /* Prevent compiler warnings */
    ruleexit_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exit_statement */

/**
 * $ANTLR start goto_statement
 * PLSQLParser.g:877:1: goto_statement : goto_key label_name ;
 */
void
PLSQLParser::goto_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:878:5: ( goto_key label_name )
        // PLSQLParser.g:878:10: goto_key label_name
        {
            this->followPush(FOLLOW_goto_key_in_goto_statement7226);
            goto_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulegoto_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_label_name_in_goto_statement7228);
            label_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulegoto_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulegoto_statementEx; /* Prevent compiler warnings */
    rulegoto_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end goto_statement */

/**
 * $ANTLR start if_statement
 * PLSQLParser.g:881:1: if_statement : if_key condition then_key seq_of_statements ( elsif_part )* ( else_part )? end_key if_key ;
 */
void
PLSQLParser::if_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:882:5: ( if_key condition then_key seq_of_statements ( elsif_part )* ( else_part )? end_key if_key )
        // PLSQLParser.g:882:10: if_key condition then_key seq_of_statements ( elsif_part )* ( else_part )? end_key if_key
        {
            this->followPush(FOLLOW_if_key_in_if_statement7248);
            if_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleif_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_condition_in_if_statement7250);
            condition();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleif_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_then_key_in_if_statement7252);
            then_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleif_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_seq_of_statements_in_if_statement7254);
            seq_of_statements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleif_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:883:9: ( elsif_part )*

            for (;;)
            {
                int alt238=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA238_0 = this->LA(1);
                    if ( (LA238_0 == PLSQL_NON_RESERVED_ELSIF))
                    {
                        alt238=1;
                    }

                }
                switch (alt238)
                {
            	case 1:
            	    // PLSQLParser.g:883:9: elsif_part
            	    {
            	        this->followPush(FOLLOW_elsif_part_in_if_statement7264);
            	        elsif_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleif_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop238;	/* break out of the loop */
            	    break;
                }
            }
            loop238: ; /* Jump out to here if this rule does not match */


            // PLSQLParser.g:883:21: ( else_part )?
            {
                int alt239=2;
                {
                    int LA239_0 = this->LA(1);
                    if ( (LA239_0 == SQL92_RESERVED_ELSE))
                    {
                        alt239=1;
                    }
                }
                switch (alt239)
                {
            	case 1:
            	    // PLSQLParser.g:883:21: else_part
            	    {
            	        this->followPush(FOLLOW_else_part_in_if_statement7267);
            	        else_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleif_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_end_key_in_if_statement7278);
            end_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleif_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_if_key_in_if_statement7280);
            if_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleif_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleif_statementEx; /* Prevent compiler warnings */
    ruleif_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end if_statement */

/**
 * $ANTLR start elsif_part
 * PLSQLParser.g:887:1: elsif_part : elsif_key condition then_key seq_of_statements ;
 */
void
PLSQLParser::elsif_part()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:888:5: ( elsif_key condition then_key seq_of_statements )
        // PLSQLParser.g:888:10: elsif_key condition then_key seq_of_statements
        {
            this->followPush(FOLLOW_elsif_key_in_elsif_part7300);
            elsif_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleelsif_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_condition_in_elsif_part7302);
            condition();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleelsif_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_then_key_in_elsif_part7304);
            then_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleelsif_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_seq_of_statements_in_elsif_part7306);
            seq_of_statements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleelsif_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleelsif_partEx; /* Prevent compiler warnings */
    ruleelsif_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end elsif_part */

/**
 * $ANTLR start else_part
 * PLSQLParser.g:891:1: else_part : else_key seq_of_statements ;
 */
void
PLSQLParser::else_part()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:892:5: ( else_key seq_of_statements )
        // PLSQLParser.g:892:10: else_key seq_of_statements
        {
            this->followPush(FOLLOW_else_key_in_else_part7326);
            else_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleelse_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_seq_of_statements_in_else_part7328);
            seq_of_statements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleelse_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleelse_partEx; /* Prevent compiler warnings */
    ruleelse_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end else_part */

/**
 * $ANTLR start loop_statement
 * PLSQLParser.g:895:1: loop_statement : ( label_name )? ( while_key condition | for_key cursor_loop_param )? loop_key seq_of_statements end_key loop_key ( label_name )? ;
 */
void
PLSQLParser::loop_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:896:5: ( ( label_name )? ( while_key condition | for_key cursor_loop_param )? loop_key seq_of_statements end_key loop_key ( label_name )? )
        // PLSQLParser.g:896:10: ( label_name )? ( while_key condition | for_key cursor_loop_param )? loop_key seq_of_statements end_key loop_key ( label_name )?
        {
            // PLSQLParser.g:896:10: ( label_name )?
            {
                int alt240=2;
                {
                    int LA240_0 = this->LA(1);
                    if ( (LA240_0 == REGULAR_ID))
                    {
                        {
                            int LA240_1 = this->LA(2);
                            if ( (!( ((((equalsIgnoreCase(LT(1)->getText(), "LOOP")))||((equalsIgnoreCase(LT(1)->getText(), "WHILE"))))) )))
                            {
                                alt240=1;
                            }
                        }
                    }
                    else if ( (LA240_0 == DELIMITED_ID))
                    {
                        alt240=1;
                    }
                }
                switch (alt240)
                {
            	case 1:
            	    // PLSQLParser.g:896:10: label_name
            	    {
            	        this->followPush(FOLLOW_label_name_in_loop_statement7348);
            	        label_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleloop_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:897:9: ( while_key condition | for_key cursor_loop_param )?
            {
                int alt241=3;
                {
                    int LA241_0 = this->LA(1);
                    if ( (LA241_0 == REGULAR_ID))
                    {
                        {
                            int LA241_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "WHILE"))))
                            {
                                alt241=1;
                            }
                        }
                    }
                    else if ( (LA241_0 == SQL92_RESERVED_FOR))
                    {
                        alt241=2;
                    }
                }
                switch (alt241)
                {
            	case 1:
            	    // PLSQLParser.g:897:10: while_key condition
            	    {
            	        this->followPush(FOLLOW_while_key_in_loop_statement7360);
            	        while_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleloop_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_condition_in_loop_statement7362);
            	        condition();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleloop_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:897:32: for_key cursor_loop_param
            	    {
            	        this->followPush(FOLLOW_for_key_in_loop_statement7366);
            	        for_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleloop_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_cursor_loop_param_in_loop_statement7368);
            	        cursor_loop_param();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleloop_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_loop_key_in_loop_statement7380);
            loop_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleloop_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_seq_of_statements_in_loop_statement7390);
            seq_of_statements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleloop_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_end_key_in_loop_statement7400);
            end_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleloop_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_loop_key_in_loop_statement7402);
            loop_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleloop_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:900:26: ( label_name )?
            {
                int alt242=2;
                {
                    int LA242_0 = this->LA(1);
                    if ( (LA242_0 == DELIMITED_ID || LA242_0 == REGULAR_ID))
                    {
                        alt242=1;
                    }
                }
                switch (alt242)
                {
            	case 1:
            	    // PLSQLParser.g:900:26: label_name
            	    {
            	        this->followPush(FOLLOW_label_name_in_loop_statement7404);
            	        label_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleloop_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleloop_statementEx; /* Prevent compiler warnings */
    ruleloop_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end loop_statement */

/**
 * $ANTLR start cursor_loop_param
 * PLSQLParser.g:905:1: cursor_loop_param : ( ( index_name in_key ( reverse_key )? lower_bound DOUBLE_PERIOD )=> index_name in_key ( reverse_key )? lower_bound DOUBLE_PERIOD upper_bound | record_name in_key ( cursor_name ( expression_list )? | LEFT_PAREN select_statement RIGHT_PAREN ) );
 */
void
PLSQLParser::cursor_loop_param()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:906:5: ( ( index_name in_key ( reverse_key )? lower_bound DOUBLE_PERIOD )=> index_name in_key ( reverse_key )? lower_bound DOUBLE_PERIOD upper_bound | record_name in_key ( cursor_name ( expression_list )? | LEFT_PAREN select_statement RIGHT_PAREN ) )

            ANTLR_UINT32 alt246;

            alt246=2;

            switch ( this->LA(1) )
            {
            case INTRODUCER:
            	{
            		{
            		    int LA246_1 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred62_PLSQLParser>() )))
            		    {
            		        alt246=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt246=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 246 );
            		        ex->set_state( 1 );


            		        goto rulecursor_loop_paramEx;

            		    }
            		}
            	}
                break;
            case DELIMITED_ID:
            case REGULAR_ID:
            	{
            		{
            		    int LA246_2 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred62_PLSQLParser>() )))
            		    {
            		        alt246=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt246=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 246 );
            		        ex->set_state( 2 );


            		        goto rulecursor_loop_paramEx;

            		    }
            		}
            	}
                break;
            case BINDVAR:
            case COLON:
            	{
            		alt246=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 246 );
                ex->set_state( 0 );


                goto rulecursor_loop_paramEx;

            }

            switch (alt246)
            {
        	case 1:
        	    // PLSQLParser.g:906:10: ( index_name in_key ( reverse_key )? lower_bound DOUBLE_PERIOD )=> index_name in_key ( reverse_key )? lower_bound DOUBLE_PERIOD upper_bound
        	    {
        	        this->followPush(FOLLOW_index_name_in_cursor_loop_param7454);
        	        index_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecursor_loop_paramEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_in_key_in_cursor_loop_param7456);
        	        in_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecursor_loop_paramEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLParser.g:907:31: ( reverse_key )?
        	        {
        	            int alt243=2;
        	            {
        	                int LA243_0 = this->LA(1);
        	                if ( (LA243_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA243_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "REVERSE"))))
        	                        {
        	                            alt243=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt243)
        	            {
        	        	case 1:
        	        	    // PLSQLParser.g:907:31: reverse_key
        	        	    {
        	        	        this->followPush(FOLLOW_reverse_key_in_cursor_loop_param7458);
        	        	        reverse_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecursor_loop_paramEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_lower_bound_in_cursor_loop_param7461);
        	        lower_bound();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecursor_loop_paramEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(DOUBLE_PERIOD, &FOLLOW_DOUBLE_PERIOD_in_cursor_loop_param7463);
        	        if  (this->hasException())
        	        {
        	            goto rulecursor_loop_paramEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_upper_bound_in_cursor_loop_param7465);
        	        upper_bound();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecursor_loop_paramEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:908:11: record_name in_key ( cursor_name ( expression_list )? | LEFT_PAREN select_statement RIGHT_PAREN )
        	    {
        	        this->followPush(FOLLOW_record_name_in_cursor_loop_param7477);
        	        record_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecursor_loop_paramEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_in_key_in_cursor_loop_param7479);
        	        in_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecursor_loop_paramEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLParser.g:908:30: ( cursor_name ( expression_list )? | LEFT_PAREN select_statement RIGHT_PAREN )
        	        {
        	            int alt245=2;
        	            {
        	                int LA245_0 = this->LA(1);
        	                if ( (LA245_0 == BINDVAR || LA245_0 == COLON || LA245_0 == DELIMITED_ID || LA245_0 == INTRODUCER || LA245_0 == REGULAR_ID))
        	                {
        	                    alt245=1;
        	                }
        	                else if ( (LA245_0 == LEFT_PAREN))
        	                {
        	                    alt245=2;
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 245 );
        	                    ex->set_state( 0 );


        	                    goto rulecursor_loop_paramEx;

        	                }
        	            }
        	            switch (alt245)
        	            {
        	        	case 1:
        	        	    // PLSQLParser.g:908:32: cursor_name ( expression_list )?
        	        	    {
        	        	        this->followPush(FOLLOW_cursor_name_in_cursor_loop_param7483);
        	        	        cursor_name();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecursor_loop_paramEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQLParser.g:908:44: ( expression_list )?
        	        	        {
        	        	            int alt244=2;
        	        	            {
        	        	                int LA244_0 = this->LA(1);
        	        	                if ( (LA244_0 == LEFT_PAREN))
        	        	                {
        	        	                    alt244=1;
        	        	                }
        	        	            }
        	        	            switch (alt244)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQLParser.g:908:44: expression_list
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_expression_list_in_cursor_loop_param7485);
        	        	        	        expression_list();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulecursor_loop_paramEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQLParser.g:908:63: LEFT_PAREN select_statement RIGHT_PAREN
        	        	    {
        	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_cursor_loop_param7490);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecursor_loop_paramEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_select_statement_in_cursor_loop_param7492);
        	        	        select_statement();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecursor_loop_paramEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_cursor_loop_param7494);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecursor_loop_paramEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulecursor_loop_paramEx; /* Prevent compiler warnings */
    rulecursor_loop_paramEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cursor_loop_param */

/**
 * $ANTLR start forall_statement
 * PLSQLParser.g:912:1: forall_statement : forall_key index_name in_key bounds_clause sql_statement ( save_key exceptions_key )? ;
 */
void
PLSQLParser::forall_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:913:5: ( forall_key index_name in_key bounds_clause sql_statement ( save_key exceptions_key )? )
        // PLSQLParser.g:913:10: forall_key index_name in_key bounds_clause sql_statement ( save_key exceptions_key )?
        {
            this->followPush(FOLLOW_forall_key_in_forall_statement7516);
            forall_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleforall_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_index_name_in_forall_statement7518);
            index_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleforall_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_in_key_in_forall_statement7520);
            in_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleforall_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_bounds_clause_in_forall_statement7522);
            bounds_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleforall_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_sql_statement_in_forall_statement7524);
            sql_statement();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleforall_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:913:67: ( save_key exceptions_key )?
            {
                int alt247=2;
                {
                    int LA247_0 = this->LA(1);
                    if ( (LA247_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "SAVE"))))
                    {
                        alt247=1;
                    }
                }
                switch (alt247)
                {
            	case 1:
            	    // PLSQLParser.g:913:68: save_key exceptions_key
            	    {
            	        this->followPush(FOLLOW_save_key_in_forall_statement7527);
            	        save_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleforall_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_exceptions_key_in_forall_statement7529);
            	        exceptions_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleforall_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleforall_statementEx; /* Prevent compiler warnings */
    ruleforall_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end forall_statement */

/**
 * $ANTLR start bounds_clause
 * PLSQLParser.g:916:1: bounds_clause : ( lower_bound DOUBLE_PERIOD upper_bound | indices_key of_key collection_name ( between_bound )? | values_key of_key index_name );
 */
void
PLSQLParser::bounds_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:917:5: ( lower_bound DOUBLE_PERIOD upper_bound | indices_key of_key collection_name ( between_bound )? | values_key of_key index_name )

            ANTLR_UINT32 alt249;

            alt249=3;

            switch ( this->LA(1) )
            {
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case DELIMITED_ID:
            case EXACT_NUM_LIT:
            case INTRODUCER:
            case LEFT_PAREN:
            case MINUS_SIGN:
            case NATIONAL_CHAR_STRING_LIT:
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            case PLUS_SIGN:
            case SQL92_RESERVED_ALL:
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_CASE:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_DISTINCT:
            case SQL92_RESERVED_EXISTS:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_PRIOR:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt249=1;
            	}
                break;
            case REGULAR_ID:
            	{
            		{
            		    int LA249_2 = this->LA(2);
            		    if ( (LA249_2 == MINUS_SIGN || LA249_2 == PLUS_SIGN))
            		    {
            		        alt249=1;
            		    }
            		    else if ( (LA249_2 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA249_2 == SQL92_RESERVED_PRIOR) && (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )))
            		    {
            		        alt249=1;
            		    }
            		    else if ( (LA249_2 == REGULAR_ID))
            		    {
            		        alt249=1;
            		    }
            		    else if ( (LA249_2 == SQL92_RESERVED_ALL || LA249_2 == SQL92_RESERVED_DISTINCT) && (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )))
            		    {
            		        alt249=1;
            		    }
            		    else if ( (LA249_2 == DELIMITED_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||(( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )))))
            		    {
            		        alt249=1;
            		    }
            		    else if ( (LA249_2 == SQL92_RESERVED_CASE))
            		    {
            		        alt249=1;
            		    }
            		    else if ( (LA249_2 == SQL92_RESERVED_ANY || LA249_2 == SQL92_RESERVED_EXISTS) && (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )))
            		    {
            		        alt249=1;
            		    }
            		    else if ( (LA249_2 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||(( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )))))
            		    {
            		        alt249=1;
            		    }
            		    else if ( (LA249_2 == BINDVAR || LA249_2 == COLON))
            		    {
            		        alt249=1;
            		    }
            		    else if ( (LA249_2 == APPROXIMATE_NUM_LIT || LA249_2 == EXACT_NUM_LIT || LA249_2 == SQL92_RESERVED_DATE || LA249_2 == UNSIGNED_INTEGER) && (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )))
            		    {
            		        alt249=1;
            		    }
            		    else if ( (((LA249_2 >= CHAR_STRING) && (LA249_2 <= CHAR_STRING_PERL)) || LA249_2 == NATIONAL_CHAR_STRING_LIT))
            		    {
            		        alt249=1;
            		    }
            		    else if ( (LA249_2 == SQL92_RESERVED_DEFAULT || LA249_2 == SQL92_RESERVED_FALSE || LA249_2 == SQL92_RESERVED_NULL || LA249_2 == SQL92_RESERVED_TRUE) && (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )))
            		    {
            		        alt249=1;
            		    }
            		    else if ( (LA249_2 == ASTERISK || LA249_2 == CONCATENATION_OP || LA249_2 == DOUBLE_PERIOD || ((LA249_2 >= LEFT_BRACKET) && (LA249_2 <= LEFT_PAREN)) || LA249_2 == PERIOD || LA249_2 == SOLIDUS || LA249_2 == VERTICAL_BAR))
            		    {
            		        alt249=1;
            		    }
            		    else if ( (LA249_2 == SQL92_RESERVED_OF) && ((equalsIgnoreCase(LT(1)->getText(), "INDICES"))))
            		    {
            		        alt249=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 249 );
            		        ex->set_state( 2 );


            		        goto rulebounds_clauseEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_VALUES:
            	{
            		alt249=3;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 249 );
                ex->set_state( 0 );


                goto rulebounds_clauseEx;

            }

            switch (alt249)
            {
        	case 1:
        	    // PLSQLParser.g:917:10: lower_bound DOUBLE_PERIOD upper_bound
        	    {
        	        this->followPush(FOLLOW_lower_bound_in_bounds_clause7551);
        	        lower_bound();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulebounds_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(DOUBLE_PERIOD, &FOLLOW_DOUBLE_PERIOD_in_bounds_clause7553);
        	        if  (this->hasException())
        	        {
        	            goto rulebounds_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_upper_bound_in_bounds_clause7555);
        	        upper_bound();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulebounds_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:918:10: indices_key of_key collection_name ( between_bound )?
        	    {
        	        this->followPush(FOLLOW_indices_key_in_bounds_clause7566);
        	        indices_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulebounds_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_of_key_in_bounds_clause7568);
        	        of_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulebounds_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_collection_name_in_bounds_clause7570);
        	        collection_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulebounds_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQLParser.g:918:45: ( between_bound )?
        	        {
        	            int alt248=2;
        	            {
        	                int LA248_0 = this->LA(1);
        	                if ( (LA248_0 == SQL92_RESERVED_BETWEEN))
        	                {
        	                    alt248=1;
        	                }
        	            }
        	            switch (alt248)
        	            {
        	        	case 1:
        	        	    // PLSQLParser.g:918:45: between_bound
        	        	    {
        	        	        this->followPush(FOLLOW_between_bound_in_bounds_clause7572);
        	        	        between_bound();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulebounds_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // PLSQLParser.g:919:10: values_key of_key index_name
        	    {
        	        this->followPush(FOLLOW_values_key_in_bounds_clause7584);
        	        values_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulebounds_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_of_key_in_bounds_clause7586);
        	        of_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulebounds_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_index_name_in_bounds_clause7588);
        	        index_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulebounds_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulebounds_clauseEx; /* Prevent compiler warnings */
    rulebounds_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end bounds_clause */

/**
 * $ANTLR start between_bound
 * PLSQLParser.g:922:1: between_bound : between_key lower_bound and_key upper_bound ;
 */
void
PLSQLParser::between_bound()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:923:5: ( between_key lower_bound and_key upper_bound )
        // PLSQLParser.g:923:10: between_key lower_bound and_key upper_bound
        {
            this->followPush(FOLLOW_between_key_in_between_bound7608);
            between_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebetween_boundEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_lower_bound_in_between_bound7610);
            lower_bound();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebetween_boundEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_and_key_in_between_bound7612);
            and_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebetween_boundEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_upper_bound_in_between_bound7614);
            upper_bound();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebetween_boundEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebetween_boundEx; /* Prevent compiler warnings */
    rulebetween_boundEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end between_bound */

/**
 * $ANTLR start lower_bound
 * PLSQLParser.g:926:1: lower_bound : concatenation ;
 */
void
PLSQLParser::lower_bound()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:927:5: ( concatenation )
        // PLSQLParser.g:927:10: concatenation
        {
            this->followPush(FOLLOW_concatenation_in_lower_bound7634);
            concatenation();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelower_boundEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelower_boundEx; /* Prevent compiler warnings */
    rulelower_boundEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end lower_bound */

/**
 * $ANTLR start upper_bound
 * PLSQLParser.g:930:1: upper_bound : concatenation ;
 */
void
PLSQLParser::upper_bound()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:931:5: ( concatenation )
        // PLSQLParser.g:931:10: concatenation
        {
            this->followPush(FOLLOW_concatenation_in_upper_bound7654);
            concatenation();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleupper_boundEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleupper_boundEx; /* Prevent compiler warnings */
    ruleupper_boundEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end upper_bound */

/**
 * $ANTLR start null_statement
 * PLSQLParser.g:934:1: null_statement : null_key ;
 */
void
PLSQLParser::null_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:935:5: ( null_key )
        // PLSQLParser.g:935:10: null_key
        {
            this->followPush(FOLLOW_null_key_in_null_statement7674);
            null_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulenull_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenull_statementEx; /* Prevent compiler warnings */
    rulenull_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end null_statement */

/**
 * $ANTLR start raise_statement
 * PLSQLParser.g:938:1: raise_statement : raise_key ( exception_name )? ;
 */
void
PLSQLParser::raise_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:939:5: ( raise_key ( exception_name )? )
        // PLSQLParser.g:939:10: raise_key ( exception_name )?
        {
            this->followPush(FOLLOW_raise_key_in_raise_statement7694);
            raise_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleraise_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:939:20: ( exception_name )?
            {
                int alt250=2;
                {
                    int LA250_0 = this->LA(1);
                    if ( (LA250_0 == DELIMITED_ID || LA250_0 == INTRODUCER || LA250_0 == REGULAR_ID))
                    {
                        alt250=1;
                    }
                }
                switch (alt250)
                {
            	case 1:
            	    // PLSQLParser.g:939:20: exception_name
            	    {
            	        this->followPush(FOLLOW_exception_name_in_raise_statement7696);
            	        exception_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleraise_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleraise_statementEx; /* Prevent compiler warnings */
    ruleraise_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end raise_statement */

/**
 * $ANTLR start return_statement
 * PLSQLParser.g:942:1: return_statement : return_key (cn1= condition )? ;
 */
void
PLSQLParser::return_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:943:5: ( return_key (cn1= condition )? )
        // PLSQLParser.g:943:10: return_key (cn1= condition )?
        {
            this->followPush(FOLLOW_return_key_in_return_statement7717);
            return_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereturn_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:943:24: (cn1= condition )?
            {
                int alt251=2;
                {
                    int LA251_0 = this->LA(1);
                    if ( (LA251_0 == APPROXIMATE_NUM_LIT || LA251_0 == BINDVAR || ((LA251_0 >= CHAR_STRING) && (LA251_0 <= COLON)) || LA251_0 == DELIMITED_ID || LA251_0 == EXACT_NUM_LIT || LA251_0 == INTRODUCER || LA251_0 == LEFT_PAREN || ((LA251_0 >= MINUS_SIGN) && (LA251_0 <= NATIONAL_CHAR_STRING_LIT)) || LA251_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA251_0 == PLUS_SIGN || LA251_0 == REGULAR_ID || LA251_0 == SQL92_RESERVED_ALL || LA251_0 == SQL92_RESERVED_ANY || LA251_0 == SQL92_RESERVED_CASE || ((LA251_0 >= SQL92_RESERVED_CURSOR) && (LA251_0 <= SQL92_RESERVED_DATE)) || LA251_0 == SQL92_RESERVED_DEFAULT || LA251_0 == SQL92_RESERVED_DISTINCT || ((LA251_0 >= SQL92_RESERVED_EXISTS) && (LA251_0 <= SQL92_RESERVED_FALSE)) || ((LA251_0 >= SQL92_RESERVED_NOT) && (LA251_0 <= SQL92_RESERVED_NULL)) || LA251_0 == SQL92_RESERVED_PRIOR || LA251_0 == SQL92_RESERVED_TRUE || LA251_0 == UNSIGNED_INTEGER))
                    {
                        alt251=1;
                    }
                }
                switch (alt251)
                {
            	case 1:
            	    // PLSQLParser.g:943:24: cn1= condition
            	    {
            	        this->followPush(FOLLOW_condition_in_return_statement7721);
            	        condition();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulereturn_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulereturn_statementEx; /* Prevent compiler warnings */
    rulereturn_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end return_statement */

/**
 * $ANTLR start function_call
 * PLSQLParser.g:946:1: function_call : ( call_key )? routine_name ( function_argument )? ;
 */
void
PLSQLParser::function_call()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:947:5: ( ( call_key )? routine_name ( function_argument )? )
        // PLSQLParser.g:947:10: ( call_key )? routine_name ( function_argument )?
        {
            // PLSQLParser.g:947:10: ( call_key )?
            {
                int alt252=2;
                {
                    int LA252_0 = this->LA(1);
                    if ( (LA252_0 == REGULAR_ID))
                    {
                        {
                            int LA252_1 = this->LA(2);
                            if ( (LA252_1 == DELIMITED_ID || LA252_1 == INTRODUCER || LA252_1 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "CALL"))))
                            {
                                alt252=1;
                            }
                        }
                    }
                }
                switch (alt252)
                {
            	case 1:
            	    // PLSQLParser.g:947:10: call_key
            	    {
            	        this->followPush(FOLLOW_call_key_in_function_call7742);
            	        call_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_callEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_routine_name_in_function_call7745);
            routine_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunction_callEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:947:33: ( function_argument )?
            {
                int alt253=2;
                {
                    int LA253_0 = this->LA(1);
                    if ( (LA253_0 == LEFT_PAREN))
                    {
                        alt253=1;
                    }
                }
                switch (alt253)
                {
            	case 1:
            	    // PLSQLParser.g:947:33: function_argument
            	    {
            	        this->followPush(FOLLOW_function_argument_in_function_call7747);
            	        function_argument();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunction_callEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunction_callEx; /* Prevent compiler warnings */
    rulefunction_callEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end function_call */

/**
 * $ANTLR start body
 * PLSQLParser.g:950:1: body : begin_key seq_of_statements ( exception_clause )? end_key ( label_name )? ;
 */
void
PLSQLParser::body()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:951:5: ( begin_key seq_of_statements ( exception_clause )? end_key ( label_name )? )
        // PLSQLParser.g:951:10: begin_key seq_of_statements ( exception_clause )? end_key ( label_name )?
        {
            this->followPush(FOLLOW_begin_key_in_body7768);
            begin_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebodyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_seq_of_statements_in_body7778);
            seq_of_statements();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebodyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:953:9: ( exception_clause )?
            {
                int alt254=2;
                {
                    int LA254_0 = this->LA(1);
                    if ( (LA254_0 == SQL92_RESERVED_EXCEPTION))
                    {
                        alt254=1;
                    }
                }
                switch (alt254)
                {
            	case 1:
            	    // PLSQLParser.g:953:9: exception_clause
            	    {
            	        this->followPush(FOLLOW_exception_clause_in_body7788);
            	        exception_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulebodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_end_key_in_body7799);
            end_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebodyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:954:17: ( label_name )?
            {
                int alt255=2;
                {
                    int LA255_0 = this->LA(1);
                    if ( (LA255_0 == REGULAR_ID))
                    {
                        {
                            int LA255_1 = this->LA(2);
                            if ( (LA255_1 == EOF || LA255_1 == SEMICOLON))
                            {
                                alt255=1;
                            }
                            else if ( (LA255_1 == REGULAR_ID))
                            {
                                {
                                    int LA255_4 = this->LA(3);
                                    if ( (LA255_4 == REGULAR_ID))
                                    {
                                        {
                                            int LA255_5 = this->LA(4);
                                            if ( (LA255_5 == SEMICOLON))
                                            {
                                                {
                                                    int LA255_6 = this->LA(5);
                                                    if ( (!( ((((equalsIgnoreCase(LT(1)->getText(), "AFTER")))||((equalsIgnoreCase(LT(1)->getText(), "BEFORE"))))) )))
                                                    {
                                                        alt255=1;
                                                    }
                                                }
                                            }
                                            else if ( (LA255_5 == REGULAR_ID))
                                            {
                                                alt255=1;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else if ( (LA255_0 == DELIMITED_ID))
                    {
                        alt255=1;
                    }
                }
                switch (alt255)
                {
            	case 1:
            	    // PLSQLParser.g:954:17: label_name
            	    {
            	        this->followPush(FOLLOW_label_name_in_body7801);
            	        label_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulebodyEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulebodyEx; /* Prevent compiler warnings */
    rulebodyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end body */

/**
 * $ANTLR start exception_clause
 * PLSQLParser.g:959:1: exception_clause : exception_key ( exception_handler )+ ;
 */
void
PLSQLParser::exception_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:960:5: ( exception_key ( exception_handler )+ )
        // PLSQLParser.g:960:10: exception_key ( exception_handler )+
        {
            this->followPush(FOLLOW_exception_key_in_exception_clause7824);
            exception_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexception_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:960:24: ( exception_handler )+
            {
                int cnt256=0;

                for (;;)
                {
                    int alt256=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA256_0 = this->LA(1);
            	    if ( (LA256_0 == SQL92_RESERVED_WHEN))
            	    {
            	        alt256=1;
            	    }

            	}
            	switch (alt256)
            	{
            	    case 1:
            	        // PLSQLParser.g:960:24: exception_handler
            	        {
            	            this->followPush(FOLLOW_exception_handler_in_exception_clause7826);
            	            exception_handler();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleexception_clauseEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt256 >= 1 )
            		{
            		    goto loop256;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PLSQLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleexception_clauseEx;
            	}
            	cnt256++;
                }
                loop256: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexception_clauseEx; /* Prevent compiler warnings */
    ruleexception_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exception_clause */

/**
 * $ANTLR start exception_handler
 * PLSQLParser.g:963:1: exception_handler : when_key exception_name ( or_key exception_name )* then_key seq_of_statements ;
 */
void
PLSQLParser::exception_handler()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:964:5: ( when_key exception_name ( or_key exception_name )* then_key seq_of_statements )
        // PLSQLParser.g:964:10: when_key exception_name ( or_key exception_name )* then_key seq_of_statements
        {
            this->followPush(FOLLOW_when_key_in_exception_handler7847);
            when_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexception_handlerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_exception_name_in_exception_handler7849);
            exception_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexception_handlerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:964:34: ( or_key exception_name )*

            for (;;)
            {
                int alt257=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA257_0 = this->LA(1);
                    if ( (LA257_0 == SQL92_RESERVED_OR))
                    {
                        alt257=1;
                    }

                }
                switch (alt257)
                {
            	case 1:
            	    // PLSQLParser.g:964:35: or_key exception_name
            	    {
            	        this->followPush(FOLLOW_or_key_in_exception_handler7852);
            	        or_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexception_handlerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_exception_name_in_exception_handler7854);
            	        exception_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexception_handlerEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop257;	/* break out of the loop */
            	    break;
                }
            }
            loop257: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_then_key_in_exception_handler7858);
            then_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexception_handlerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_seq_of_statements_in_exception_handler7868);
            seq_of_statements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexception_handlerEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexception_handlerEx; /* Prevent compiler warnings */
    ruleexception_handlerEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exception_handler */

/**
 * $ANTLR start trigger_block
 * PLSQLParser.g:970:1: trigger_block : ( ( declare_key )? ( declare_spec )+ )? body ;
 */
void
PLSQLParser::trigger_block()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:971:5: ( ( ( declare_key )? ( declare_spec )+ )? body )
        // PLSQLParser.g:971:10: ( ( declare_key )? ( declare_spec )+ )? body
        {
            // PLSQLParser.g:971:10: ( ( declare_key )? ( declare_spec )+ )?
            {
                int alt260=2;
                {
                    int LA260_0 = this->LA(1);
                    if ( (LA260_0 == BINDVAR || LA260_0 == COLON || LA260_0 == DELIMITED_ID || LA260_0 == INTRODUCER || LA260_0 == REGULAR_ID || LA260_0 == SQL92_RESERVED_CREATE || LA260_0 == SQL92_RESERVED_CURSOR || LA260_0 == SQL92_RESERVED_DECLARE || LA260_0 == SQL92_RESERVED_PROCEDURE))
                    {
                        alt260=1;
                    }
                }
                switch (alt260)
                {
            	case 1:
            	    // PLSQLParser.g:971:11: ( declare_key )? ( declare_spec )+
            	    {
            	        // PLSQLParser.g:971:11: ( declare_key )?
            	        {
            	            int alt258=2;
            	            {
            	                int LA258_0 = this->LA(1);
            	                if ( (LA258_0 == SQL92_RESERVED_DECLARE))
            	                {
            	                    alt258=1;
            	                }
            	            }
            	            switch (alt258)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:971:11: declare_key
            	        	    {
            	        	        this->followPush(FOLLOW_declare_key_in_trigger_block7891);
            	        	        declare_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletrigger_blockEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQLParser.g:971:24: ( declare_spec )+
            	        {
            	            int cnt259=0;

            	            for (;;)
            	            {
            	                int alt259=2;
            	        	{
            	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	        	    */
            	        	    int LA259_0 = this->LA(1);
            	        	    if ( (LA259_0 == BINDVAR || LA259_0 == COLON || LA259_0 == DELIMITED_ID || LA259_0 == INTRODUCER || LA259_0 == REGULAR_ID || LA259_0 == SQL92_RESERVED_CREATE || LA259_0 == SQL92_RESERVED_CURSOR || LA259_0 == SQL92_RESERVED_PROCEDURE))
            	        	    {
            	        	        alt259=1;
            	        	    }

            	        	}
            	        	switch (alt259)
            	        	{
            	        	    case 1:
            	        	        // PLSQLParser.g:971:24: declare_spec
            	        	        {
            	        	            this->followPush(FOLLOW_declare_spec_in_trigger_block7894);
            	        	            declare_spec();

            	        	            this->followPop();
            	        	            if  (this->hasException())
            	        	            {
            	        	                goto ruletrigger_blockEx;
            	        	            }
            	        	            if (this->hasFailed())
            	        	            {
            	        	                return ;
            	        	            }


            	        	        }
            	        	        break;

            	        	    default:

            	        		if ( cnt259 >= 1 )
            	        		{
            	        		    goto loop259;
            	        		}
            	        		if (this->get_backtracking()>0)
            	        		{
            	        		    this->set_failedflag( true );
            	        		    return ;
            	        		}

            	        		/* mismatchedSetEx()
            	        		 */
            	        		new ANTLR_Exception< PLSQLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            	        		goto ruletrigger_blockEx;
            	        	}
            	        	cnt259++;
            	            }
            	            loop259: ;	/* Jump to here if this rule does not match */
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_body_in_trigger_block7907);
            body();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletrigger_blockEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletrigger_blockEx; /* Prevent compiler warnings */
    ruletrigger_blockEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end trigger_block */

/**
 * $ANTLR start block
 * PLSQLParser.g:975:1: block : ( declare_key )? ( declare_spec )+ body ;
 */
void
PLSQLParser::block()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:976:5: ( ( declare_key )? ( declare_spec )+ body )
        // PLSQLParser.g:976:10: ( declare_key )? ( declare_spec )+ body
        {
            // PLSQLParser.g:976:10: ( declare_key )?
            {
                int alt261=2;
                {
                    int LA261_0 = this->LA(1);
                    if ( (LA261_0 == SQL92_RESERVED_DECLARE))
                    {
                        alt261=1;
                    }
                }
                switch (alt261)
                {
            	case 1:
            	    // PLSQLParser.g:976:10: declare_key
            	    {
            	        this->followPush(FOLLOW_declare_key_in_block7927);
            	        declare_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleblockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:976:23: ( declare_spec )+
            {
                int cnt262=0;

                for (;;)
                {
                    int alt262=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA262_0 = this->LA(1);
            	    if ( (LA262_0 == BINDVAR || LA262_0 == COLON || LA262_0 == DELIMITED_ID || LA262_0 == INTRODUCER || LA262_0 == REGULAR_ID || LA262_0 == SQL92_RESERVED_CREATE || LA262_0 == SQL92_RESERVED_CURSOR || LA262_0 == SQL92_RESERVED_PROCEDURE))
            	    {
            	        alt262=1;
            	    }

            	}
            	switch (alt262)
            	{
            	    case 1:
            	        // PLSQLParser.g:976:23: declare_spec
            	        {
            	            this->followPush(FOLLOW_declare_spec_in_block7930);
            	            declare_spec();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleblockEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt262 >= 1 )
            		{
            		    goto loop262;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PLSQLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleblockEx;
            	}
            	cnt262++;
                }
                loop262: ;	/* Jump to here if this rule does not match */
            }

            this->followPush(FOLLOW_body_in_block7941);
            body();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleblockEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleblockEx; /* Prevent compiler warnings */
    ruleblockEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end block */

/**
 * $ANTLR start sql_statement
 * PLSQLParser.g:984:1: sql_statement options {backtrack=true; } : ( execute_immediate | data_manipulation_language_statements | cursor_manipulation_statements | transaction_control_statements );
 */
void
PLSQLParser::sql_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:987:6: ( execute_immediate | data_manipulation_language_statements | cursor_manipulation_statements | transaction_control_statements )

            ANTLR_UINT32 alt263;

            alt263=4;

            alt263 = cdfa263.predict(this, this->get_rec(), this->get_istream(), cdfa263 );
            if  (this->hasException())
            {
                goto rulesql_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }

            switch (alt263)
            {
        	case 1:
        	    // PLSQLParser.g:987:11: execute_immediate
        	    {
        	        this->followPush(FOLLOW_execute_immediate_in_sql_statement7973);
        	        execute_immediate();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesql_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:988:10: data_manipulation_language_statements
        	    {
        	        this->followPush(FOLLOW_data_manipulation_language_statements_in_sql_statement7984);
        	        data_manipulation_language_statements();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesql_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLParser.g:989:10: cursor_manipulation_statements
        	    {
        	        this->followPush(FOLLOW_cursor_manipulation_statements_in_sql_statement7995);
        	        cursor_manipulation_statements();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesql_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQLParser.g:990:10: transaction_control_statements
        	    {
        	        this->followPush(FOLLOW_transaction_control_statements_in_sql_statement8006);
        	        transaction_control_statements();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesql_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesql_statementEx; /* Prevent compiler warnings */
    rulesql_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sql_statement */

/**
 * $ANTLR start execute_immediate
 * PLSQLParser.g:993:1: execute_immediate : execute_key immediate_key expression ( into_clause ( using_clause )? | using_clause ( dynamic_returning_clause )? | dynamic_returning_clause )? ;
 */
void
PLSQLParser::execute_immediate()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:994:5: ( execute_key immediate_key expression ( into_clause ( using_clause )? | using_clause ( dynamic_returning_clause )? | dynamic_returning_clause )? )
        // PLSQLParser.g:994:10: execute_key immediate_key expression ( into_clause ( using_clause )? | using_clause ( dynamic_returning_clause )? | dynamic_returning_clause )?
        {
            this->followPush(FOLLOW_execute_key_in_execute_immediate8026);
            execute_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexecute_immediateEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_immediate_key_in_execute_immediate8028);
            immediate_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexecute_immediateEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_execute_immediate8030);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexecute_immediateEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:995:5: ( into_clause ( using_clause )? | using_clause ( dynamic_returning_clause )? | dynamic_returning_clause )?
            {
                int alt266=4;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_INTO:
                    	{
                    		alt266=1;
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA266_2 = this->LA(2);
                    		    if ( (LA266_2 == REGULAR_ID))
                    		    {
                    		        {
                    		            int LA266_5 = this->LA(3);
                    		            if ( (LA266_5 == SQL92_RESERVED_INTO) && ((equalsIgnoreCase(LT(1)->getText(), "BULK"))))
                    		            {
                    		                alt266=1;
                    		            }
                    		            else if ( (LA266_5 == REGULAR_ID))
                    		            {
                    		                alt266=3;
                    		            }
                    		        }
                    		    }
                    		    else if ( (LA266_2 == SQL92_RESERVED_INTO))
                    		    {
                    		        alt266=3;
                    		    }
                    		}
                    	}
                        break;
                    case PLSQL_NON_RESERVED_USING:
                    	{
                    		alt266=2;
                    	}
                        break;
                }

                switch (alt266)
                {
            	case 1:
            	    // PLSQLParser.g:995:10: into_clause ( using_clause )?
            	    {
            	        this->followPush(FOLLOW_into_clause_in_execute_immediate8041);
            	        into_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexecute_immediateEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:995:22: ( using_clause )?
            	        {
            	            int alt264=2;
            	            {
            	                int LA264_0 = this->LA(1);
            	                if ( (LA264_0 == PLSQL_NON_RESERVED_USING))
            	                {
            	                    alt264=1;
            	                }
            	            }
            	            switch (alt264)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:995:22: using_clause
            	        	    {
            	        	        this->followPush(FOLLOW_using_clause_in_execute_immediate8043);
            	        	        using_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleexecute_immediateEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:996:10: using_clause ( dynamic_returning_clause )?
            	    {
            	        this->followPush(FOLLOW_using_clause_in_execute_immediate8055);
            	        using_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexecute_immediateEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:996:23: ( dynamic_returning_clause )?
            	        {
            	            int alt265=2;
            	            {
            	                int LA265_0 = this->LA(1);
            	                if ( (LA265_0 == REGULAR_ID))
            	                {
            	                    {
            	                        int LA265_1 = this->LA(2);
            	                        if ( (LA265_1 == SQL92_RESERVED_INTO))
            	                        {
            	                            alt265=1;
            	                        }
            	                        else if ( (LA265_1 == REGULAR_ID))
            	                        {
            	                            {
            	                                int LA265_4 = this->LA(3);
            	                                if ( (LA265_4 == REGULAR_ID))
            	                                {
            	                                    alt265=1;
            	                                }
            	                            }
            	                        }
            	                    }
            	                }
            	            }
            	            switch (alt265)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:996:23: dynamic_returning_clause
            	        	    {
            	        	        this->followPush(FOLLOW_dynamic_returning_clause_in_execute_immediate8057);
            	        	        dynamic_returning_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleexecute_immediateEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 3:
            	    // PLSQLParser.g:997:10: dynamic_returning_clause
            	    {
            	        this->followPush(FOLLOW_dynamic_returning_clause_in_execute_immediate8069);
            	        dynamic_returning_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexecute_immediateEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexecute_immediateEx; /* Prevent compiler warnings */
    ruleexecute_immediateEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end execute_immediate */

/**
 * $ANTLR start dynamic_returning_clause
 * PLSQLParser.g:1002:1: dynamic_returning_clause : ( returning_key | return_key ) into_clause ;
 */
void
PLSQLParser::dynamic_returning_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:1003:5: ( ( returning_key | return_key ) into_clause )
        // PLSQLParser.g:1003:10: ( returning_key | return_key ) into_clause
        {
            // PLSQLParser.g:1003:10: ( returning_key | return_key )
            {
                int alt267=2;
                {
                    int LA267_0 = this->LA(1);
                    if ( (LA267_0 == REGULAR_ID))
                    {
                        {
                            int LA267_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "RETURNING"))))
                            {
                                alt267=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "RETURN"))))
                            {
                                alt267=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 267 );
                                ex->set_state( 1 );


                                goto ruledynamic_returning_clauseEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 267 );
                        ex->set_state( 0 );


                        goto ruledynamic_returning_clauseEx;

                    }
                }
                switch (alt267)
                {
            	case 1:
            	    // PLSQLParser.g:1003:11: returning_key
            	    {
            	        this->followPush(FOLLOW_returning_key_in_dynamic_returning_clause8098);
            	        returning_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledynamic_returning_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:1003:25: return_key
            	    {
            	        this->followPush(FOLLOW_return_key_in_dynamic_returning_clause8100);
            	        return_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledynamic_returning_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_into_clause_in_dynamic_returning_clause8103);
            into_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledynamic_returning_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledynamic_returning_clauseEx; /* Prevent compiler warnings */
    ruledynamic_returning_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dynamic_returning_clause */

/**
 * $ANTLR start data_manipulation_language_statements
 * PLSQLParser.g:1010:1: data_manipulation_language_statements : ( merge_statement | lock_table_statement | select_statement | update_statement | delete_statement | insert_statement | explain_statement );
 */
void
PLSQLParser::data_manipulation_language_statements()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:1011:5: ( merge_statement | lock_table_statement | select_statement | update_statement | delete_statement | insert_statement | explain_statement )

            ANTLR_UINT32 alt268;

            alt268=7;

            {
                int LA268_0 = this->LA(1);
                if ( (LA268_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "EXPLAIN")))||((equalsIgnoreCase(LT(1)->getText(), "MERGE"))))))
                {
                    {
                        int LA268_1 = this->LA(2);
                        if ( (LA268_1 == SQL92_RESERVED_INTO) && ((equalsIgnoreCase(LT(1)->getText(), "MERGE"))))
                        {
                            alt268=1;
                        }
                        else if ( (LA268_1 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "EXPLAIN"))))
                        {
                            alt268=7;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 268 );
                            ex->set_state( 1 );


                            goto ruledata_manipulation_language_statementsEx;

                        }
                    }
                }
                else if ( (LA268_0 == PLSQL_RESERVED_LOCK))
                {
                    alt268=2;
                }
                else if ( (LA268_0 == LEFT_PAREN || LA268_0 == SQL92_RESERVED_SELECT || LA268_0 == SQL92_RESERVED_WITH))
                {
                    alt268=3;
                }
                else if ( (LA268_0 == SQL92_RESERVED_UPDATE))
                {
                    alt268=4;
                }
                else if ( (LA268_0 == SQL92_RESERVED_DELETE))
                {
                    alt268=5;
                }
                else if ( (LA268_0 == SQL92_RESERVED_INSERT))
                {
                    alt268=6;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 268 );
                    ex->set_state( 0 );


                    goto ruledata_manipulation_language_statementsEx;

                }
            }
            switch (alt268)
            {
        	case 1:
        	    // PLSQLParser.g:1011:10: merge_statement
        	    {
        	        this->followPush(FOLLOW_merge_statement_in_data_manipulation_language_statements8127);
        	        merge_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledata_manipulation_language_statementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:1012:10: lock_table_statement
        	    {
        	        this->followPush(FOLLOW_lock_table_statement_in_data_manipulation_language_statements8138);
        	        lock_table_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledata_manipulation_language_statementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLParser.g:1013:10: select_statement
        	    {
        	        this->followPush(FOLLOW_select_statement_in_data_manipulation_language_statements8149);
        	        select_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledata_manipulation_language_statementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQLParser.g:1014:10: update_statement
        	    {
        	        this->followPush(FOLLOW_update_statement_in_data_manipulation_language_statements8160);
        	        update_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledata_manipulation_language_statementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQLParser.g:1015:10: delete_statement
        	    {
        	        this->followPush(FOLLOW_delete_statement_in_data_manipulation_language_statements8171);
        	        delete_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledata_manipulation_language_statementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // PLSQLParser.g:1016:10: insert_statement
        	    {
        	        this->followPush(FOLLOW_insert_statement_in_data_manipulation_language_statements8182);
        	        insert_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledata_manipulation_language_statementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 7:
        	    // PLSQLParser.g:1017:10: explain_statement
        	    {
        	        this->followPush(FOLLOW_explain_statement_in_data_manipulation_language_statements8193);
        	        explain_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledata_manipulation_language_statementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruledata_manipulation_language_statementsEx; /* Prevent compiler warnings */
    ruledata_manipulation_language_statementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end data_manipulation_language_statements */

/**
 * $ANTLR start cursor_manipulation_statements
 * PLSQLParser.g:1024:1: cursor_manipulation_statements : ( close_statement | open_statement | fetch_statement | open_for_statement );
 */
void
PLSQLParser::cursor_manipulation_statements()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:1025:5: ( close_statement | open_statement | fetch_statement | open_for_statement )

            ANTLR_UINT32 alt269;

            alt269=4;

            alt269 = cdfa269.predict(this, this->get_rec(), this->get_istream(), cdfa269 );
            if  (this->hasException())
            {
                goto rulecursor_manipulation_statementsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }

            switch (alt269)
            {
        	case 1:
        	    // PLSQLParser.g:1025:10: close_statement
        	    {
        	        this->followPush(FOLLOW_close_statement_in_cursor_manipulation_statements8217);
        	        close_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecursor_manipulation_statementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:1026:10: open_statement
        	    {
        	        this->followPush(FOLLOW_open_statement_in_cursor_manipulation_statements8228);
        	        open_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecursor_manipulation_statementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLParser.g:1027:10: fetch_statement
        	    {
        	        this->followPush(FOLLOW_fetch_statement_in_cursor_manipulation_statements8239);
        	        fetch_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecursor_manipulation_statementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQLParser.g:1028:10: open_for_statement
        	    {
        	        this->followPush(FOLLOW_open_for_statement_in_cursor_manipulation_statements8250);
        	        open_for_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecursor_manipulation_statementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulecursor_manipulation_statementsEx; /* Prevent compiler warnings */
    rulecursor_manipulation_statementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cursor_manipulation_statements */

/**
 * $ANTLR start close_statement
 * PLSQLParser.g:1031:1: close_statement : close_key cursor_name ;
 */
void
PLSQLParser::close_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:1032:5: ( close_key cursor_name )
        // PLSQLParser.g:1032:11: close_key cursor_name
        {
            this->followPush(FOLLOW_close_key_in_close_statement8271);
            close_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleclose_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_cursor_name_in_close_statement8273);
            cursor_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleclose_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleclose_statementEx; /* Prevent compiler warnings */
    ruleclose_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end close_statement */

/**
 * $ANTLR start open_statement
 * PLSQLParser.g:1035:1: open_statement : open_key cursor_name ( expression_list )? ;
 */
void
PLSQLParser::open_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:1036:5: ( open_key cursor_name ( expression_list )? )
        // PLSQLParser.g:1036:10: open_key cursor_name ( expression_list )?
        {
            this->followPush(FOLLOW_open_key_in_open_statement8293);
            open_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleopen_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_cursor_name_in_open_statement8295);
            cursor_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleopen_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:1036:31: ( expression_list )?
            {
                int alt270=2;
                {
                    int LA270_0 = this->LA(1);
                    if ( (LA270_0 == LEFT_PAREN))
                    {
                        alt270=1;
                    }
                }
                switch (alt270)
                {
            	case 1:
            	    // PLSQLParser.g:1036:31: expression_list
            	    {
            	        this->followPush(FOLLOW_expression_list_in_open_statement8297);
            	        expression_list();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleopen_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleopen_statementEx; /* Prevent compiler warnings */
    ruleopen_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end open_statement */

/**
 * $ANTLR start fetch_statement
 * PLSQLParser.g:1039:1: fetch_statement : fetch_key cursor_name (it1= into_key variable_name ( COMMA variable_name )* | bulk_key collect_key into_key variable_name ( COMMA variable_name )* ) ;
 */
void
PLSQLParser::fetch_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:1040:5: ( fetch_key cursor_name (it1= into_key variable_name ( COMMA variable_name )* | bulk_key collect_key into_key variable_name ( COMMA variable_name )* ) )
        // PLSQLParser.g:1040:10: fetch_key cursor_name (it1= into_key variable_name ( COMMA variable_name )* | bulk_key collect_key into_key variable_name ( COMMA variable_name )* )
        {
            this->followPush(FOLLOW_fetch_key_in_fetch_statement8318);
            fetch_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefetch_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_cursor_name_in_fetch_statement8320);
            cursor_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefetch_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:1041:5: (it1= into_key variable_name ( COMMA variable_name )* | bulk_key collect_key into_key variable_name ( COMMA variable_name )* )
            {
                int alt273=2;
                {
                    int LA273_0 = this->LA(1);
                    if ( (LA273_0 == SQL92_RESERVED_INTO))
                    {
                        alt273=1;
                    }
                    else if ( (LA273_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "BULK"))))
                    {
                        alt273=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 273 );
                        ex->set_state( 0 );


                        goto rulefetch_statementEx;

                    }
                }
                switch (alt273)
                {
            	case 1:
            	    // PLSQLParser.g:1041:10: it1= into_key variable_name ( COMMA variable_name )*
            	    {
            	        this->followPush(FOLLOW_into_key_in_fetch_statement8334);
            	        into_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefetch_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_variable_name_in_fetch_statement8336);
            	        variable_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefetch_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:1041:37: ( COMMA variable_name )*

            	        for (;;)
            	        {
            	            int alt271=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA271_0 = this->LA(1);
            	                if ( (LA271_0 == COMMA))
            	                {
            	                    alt271=1;
            	                }

            	            }
            	            switch (alt271)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:1041:38: COMMA variable_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_fetch_statement8339);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefetch_statementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_variable_name_in_fetch_statement8341);
            	        	        variable_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefetch_statementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop271;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop271: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:1042:10: bulk_key collect_key into_key variable_name ( COMMA variable_name )*
            	    {
            	        this->followPush(FOLLOW_bulk_key_in_fetch_statement8355);
            	        bulk_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefetch_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_collect_key_in_fetch_statement8357);
            	        collect_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefetch_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_into_key_in_fetch_statement8359);
            	        into_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefetch_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_variable_name_in_fetch_statement8361);
            	        variable_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefetch_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:1042:54: ( COMMA variable_name )*

            	        for (;;)
            	        {
            	            int alt272=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA272_0 = this->LA(1);
            	                if ( (LA272_0 == COMMA))
            	                {
            	                    alt272=1;
            	                }

            	            }
            	            switch (alt272)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:1042:55: COMMA variable_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_fetch_statement8364);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefetch_statementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_variable_name_in_fetch_statement8366);
            	        	        variable_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefetch_statementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop272;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop272: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulefetch_statementEx; /* Prevent compiler warnings */
    rulefetch_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end fetch_statement */

/**
 * $ANTLR start open_for_statement
 * PLSQLParser.g:1046:1: open_for_statement : open_key variable_name for_key ( ( select_key | with_key )=> select_statement | expression ) ( using_clause )? ;
 */
void
PLSQLParser::open_for_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:1047:5: ( open_key variable_name for_key ( ( select_key | with_key )=> select_statement | expression ) ( using_clause )? )
        // PLSQLParser.g:1047:10: open_key variable_name for_key ( ( select_key | with_key )=> select_statement | expression ) ( using_clause )?
        {
            this->followPush(FOLLOW_open_key_in_open_for_statement8395);
            open_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleopen_for_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_variable_name_in_open_for_statement8397);
            variable_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleopen_for_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_for_key_in_open_for_statement8399);
            for_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleopen_for_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:1048:5: ( ( select_key | with_key )=> select_statement | expression )
            {
                int alt274=2;
                {
                    int LA274_0 = this->LA(1);
                    if ( (LA274_0 == SQL92_RESERVED_WITH) && (this->msynpred( antlr3::ClassForwarder<synpred66_PLSQLParser>() )))
                    {
                        alt274=1;
                    }
                    else if ( (LA274_0 == SQL92_RESERVED_SELECT) && (this->msynpred( antlr3::ClassForwarder<synpred66_PLSQLParser>() )))
                    {
                        alt274=1;
                    }
                    else if ( (LA274_0 == LEFT_PAREN))
                    {
                        {
                            int LA274_3 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred66_PLSQLParser>() )))
                            {
                                alt274=1;
                            }
                            else if ( (true))
                            {
                                alt274=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 274 );
                                ex->set_state( 3 );


                                goto ruleopen_for_statementEx;

                            }
                        }
                    }
                    else if ( (LA274_0 == APPROXIMATE_NUM_LIT || LA274_0 == BINDVAR || ((LA274_0 >= CHAR_STRING) && (LA274_0 <= COLON)) || LA274_0 == DELIMITED_ID || LA274_0 == EXACT_NUM_LIT || LA274_0 == INTRODUCER || ((LA274_0 >= MINUS_SIGN) && (LA274_0 <= NATIONAL_CHAR_STRING_LIT)) || LA274_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA274_0 == PLUS_SIGN || LA274_0 == REGULAR_ID || LA274_0 == SQL92_RESERVED_ALL || LA274_0 == SQL92_RESERVED_ANY || LA274_0 == SQL92_RESERVED_CASE || ((LA274_0 >= SQL92_RESERVED_CURSOR) && (LA274_0 <= SQL92_RESERVED_DATE)) || LA274_0 == SQL92_RESERVED_DEFAULT || LA274_0 == SQL92_RESERVED_DISTINCT || ((LA274_0 >= SQL92_RESERVED_EXISTS) && (LA274_0 <= SQL92_RESERVED_FALSE)) || ((LA274_0 >= SQL92_RESERVED_NOT) && (LA274_0 <= SQL92_RESERVED_NULL)) || LA274_0 == SQL92_RESERVED_PRIOR || LA274_0 == SQL92_RESERVED_TRUE || LA274_0 == UNSIGNED_INTEGER))
                    {
                        alt274=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 274 );
                        ex->set_state( 0 );


                        goto ruleopen_for_statementEx;

                    }
                }
                switch (alt274)
                {
            	case 1:
            	    // PLSQLParser.g:1048:10: ( select_key | with_key )=> select_statement
            	    {
            	        this->followPush(FOLLOW_select_statement_in_open_for_statement8417);
            	        select_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleopen_for_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:1049:10: expression
            	    {
            	        this->followPush(FOLLOW_expression_in_open_for_statement8428);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleopen_for_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:1051:9: ( using_clause )?
            {
                int alt275=2;
                {
                    int LA275_0 = this->LA(1);
                    if ( (LA275_0 == PLSQL_NON_RESERVED_USING))
                    {
                        alt275=1;
                    }
                }
                switch (alt275)
                {
            	case 1:
            	    // PLSQLParser.g:1051:9: using_clause
            	    {
            	        this->followPush(FOLLOW_using_clause_in_open_for_statement8444);
            	        using_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleopen_for_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleopen_for_statementEx; /* Prevent compiler warnings */
    ruleopen_for_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end open_for_statement */

/**
 * $ANTLR start transaction_control_statements
 * PLSQLParser.g:1058:1: transaction_control_statements : ( set_transaction_command | set_constraint_command | commit_statement | rollback_statement | savepoint_statement );
 */
void
PLSQLParser::transaction_control_statements()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQLParser.g:1059:5: ( set_transaction_command | set_constraint_command | commit_statement | rollback_statement | savepoint_statement )

            ANTLR_UINT32 alt276;

            alt276=5;

            {
                int LA276_0 = this->LA(1);
                if ( (LA276_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "COMMIT")))||((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT")))||((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "ROLLBACK"))))))
                {
                    {
                        int LA276_1 = this->LA(2);
                        if ( (LA276_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT")))||((equalsIgnoreCase(LT(1)->getText(), "SET"))))))
                        {
                            {
                                int LA276_2 = this->LA(3);
                                if ( (LA276_2 == DELIMITED_ID || LA276_2 == INTRODUCER || LA276_2 == REGULAR_ID || LA276_2 == SQL92_RESERVED_ALL) && ((equalsIgnoreCase(LT(1)->getText(), "SET"))))
                                {
                                    alt276=2;
                                }
                                else if ( ((equalsIgnoreCase(LT(1)->getText(), "SET"))))
                                {
                                    alt276=1;
                                }
                                else if ( ((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT"))))
                                {
                                    alt276=5;
                                }
                                else
                                {
                                    if (this->get_backtracking()>0)
                                    {
                                        this->set_failedflag( true );
                                        return ;
                                    }


                                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                    ex->set_decisionNum( 276 );
                                    ex->set_state( 2 );


                                    goto ruletransaction_control_statementsEx;

                                }
                            }
                        }
                        else if ( (LA276_1 == DELIMITED_ID || LA276_1 == INTRODUCER) && ((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT"))))
                        {
                            alt276=5;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "COMMIT"))))
                        {
                            alt276=3;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "ROLLBACK"))))
                        {
                            alt276=4;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 276 );
                            ex->set_state( 1 );


                            goto ruletransaction_control_statementsEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 276 );
                    ex->set_state( 0 );


                    goto ruletransaction_control_statementsEx;

                }
            }
            switch (alt276)
            {
        	case 1:
        	    // PLSQLParser.g:1059:10: set_transaction_command
        	    {
        	        this->followPush(FOLLOW_set_transaction_command_in_transaction_control_statements8469);
        	        set_transaction_command();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletransaction_control_statementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQLParser.g:1060:10: set_constraint_command
        	    {
        	        this->followPush(FOLLOW_set_constraint_command_in_transaction_control_statements8480);
        	        set_constraint_command();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletransaction_control_statementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQLParser.g:1061:10: commit_statement
        	    {
        	        this->followPush(FOLLOW_commit_statement_in_transaction_control_statements8491);
        	        commit_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletransaction_control_statementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQLParser.g:1062:10: rollback_statement
        	    {
        	        this->followPush(FOLLOW_rollback_statement_in_transaction_control_statements8502);
        	        rollback_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletransaction_control_statementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQLParser.g:1063:10: savepoint_statement
        	    {
        	        this->followPush(FOLLOW_savepoint_statement_in_transaction_control_statements8513);
        	        savepoint_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletransaction_control_statementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruletransaction_control_statementsEx; /* Prevent compiler warnings */
    ruletransaction_control_statementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end transaction_control_statements */

/**
 * $ANTLR start set_transaction_command
 * PLSQLParser.g:1066:1: set_transaction_command : set_key transaction_key ( read_key ( only_key | write_key ) | isolation_key level_key ( serializable_key | read_key committed_key ) | use_key rollback_key segment_key rollback_segment_name )? ( name_key quoted_string )? ;
 */
void
PLSQLParser::set_transaction_command()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:1067:5: ( set_key transaction_key ( read_key ( only_key | write_key ) | isolation_key level_key ( serializable_key | read_key committed_key ) | use_key rollback_key segment_key rollback_segment_name )? ( name_key quoted_string )? )
        // PLSQLParser.g:1067:10: set_key transaction_key ( read_key ( only_key | write_key ) | isolation_key level_key ( serializable_key | read_key committed_key ) | use_key rollback_key segment_key rollback_segment_name )? ( name_key quoted_string )?
        {
            this->followPush(FOLLOW_set_key_in_set_transaction_command8533);
            set_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleset_transaction_commandEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_transaction_key_in_set_transaction_command8535);
            transaction_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleset_transaction_commandEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:1068:5: ( read_key ( only_key | write_key ) | isolation_key level_key ( serializable_key | read_key committed_key ) | use_key rollback_key segment_key rollback_segment_name )?
            {
                int alt279=4;
                {
                    int LA279_0 = this->LA(1);
                    if ( (LA279_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "NAME")))||((equalsIgnoreCase(LT(1)->getText(), "READ")))||((equalsIgnoreCase(LT(1)->getText(), "USE")))||((equalsIgnoreCase(LT(1)->getText(), "ISOLATION")))||((equalsIgnoreCase(LT(1)->getText(), "SAVE"))))))
                    {
                        {
                            int LA279_1 = this->LA(2);
                            if ( (LA279_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "READ")))||((equalsIgnoreCase(LT(1)->getText(), "USE")))||((equalsIgnoreCase(LT(1)->getText(), "SAVE")))||((equalsIgnoreCase(LT(1)->getText(), "ISOLATION"))))))
                            {
                                {
                                    int LA279_3 = this->LA(3);
                                    if ( (LA279_3 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "USE")))||((equalsIgnoreCase(LT(1)->getText(), "ISOLATION"))))))
                                    {
                                        {
                                            int LA279_5 = this->LA(4);
                                            if ( (LA279_5 == EOF || LA279_5 == SEMICOLON) && ((equalsIgnoreCase(LT(1)->getText(), "ISOLATION"))))
                                            {
                                                alt279=2;
                                            }
                                            else if ( (LA279_5 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "USE")))||((equalsIgnoreCase(LT(1)->getText(), "ISOLATION"))))))
                                            {
                                                {
                                                    int LA279_8 = this->LA(5);
                                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "ISOLATION"))))
                                                    {
                                                        alt279=2;
                                                    }
                                                    else if ( ((equalsIgnoreCase(LT(1)->getText(), "USE"))))
                                                    {
                                                        alt279=3;
                                                    }
                                                }
                                            }
                                            else if ( (LA279_5 == DELIMITED_ID || LA279_5 == INTRODUCER) && ((equalsIgnoreCase(LT(1)->getText(), "USE"))))
                                            {
                                                alt279=3;
                                            }
                                        }
                                    }
                                    else if ( ((equalsIgnoreCase(LT(1)->getText(), "READ"))))
                                    {
                                        alt279=1;
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt279)
                {
            	case 1:
            	    // PLSQLParser.g:1068:10: read_key ( only_key | write_key )
            	    {
            	        this->followPush(FOLLOW_read_key_in_set_transaction_command8547);
            	        read_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleset_transaction_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:1068:19: ( only_key | write_key )
            	        {
            	            int alt277=2;
            	            {
            	                int LA277_0 = this->LA(1);
            	                if ( (LA277_0 == REGULAR_ID))
            	                {
            	                    {
            	                        int LA277_1 = this->LA(2);
            	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "ONLY"))))
            	                        {
            	                            alt277=1;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "WRITE"))))
            	                        {
            	                            alt277=2;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 277 );
            	                            ex->set_state( 1 );


            	                            goto ruleset_transaction_commandEx;

            	                        }
            	                    }
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 277 );
            	                    ex->set_state( 0 );


            	                    goto ruleset_transaction_commandEx;

            	                }
            	            }
            	            switch (alt277)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:1068:20: only_key
            	        	    {
            	        	        this->followPush(FOLLOW_only_key_in_set_transaction_command8550);
            	        	        only_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleset_transaction_commandEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQLParser.g:1068:29: write_key
            	        	    {
            	        	        this->followPush(FOLLOW_write_key_in_set_transaction_command8552);
            	        	        write_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleset_transaction_commandEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:1069:10: isolation_key level_key ( serializable_key | read_key committed_key )
            	    {
            	        this->followPush(FOLLOW_isolation_key_in_set_transaction_command8564);
            	        isolation_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleset_transaction_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_level_key_in_set_transaction_command8566);
            	        level_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleset_transaction_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:1069:34: ( serializable_key | read_key committed_key )
            	        {
            	            int alt278=2;
            	            {
            	                int LA278_0 = this->LA(1);
            	                if ( (LA278_0 == REGULAR_ID))
            	                {
            	                    {
            	                        int LA278_1 = this->LA(2);
            	                        if ( (LA278_1 == EOF || LA278_1 == SEMICOLON))
            	                        {
            	                            alt278=1;
            	                        }
            	                        else if ( (LA278_1 == REGULAR_ID))
            	                        {
            	                            {
            	                                int LA278_3 = this->LA(3);
            	                                if ( (LA278_3 == EOF || LA278_3 == SEMICOLON) && ((equalsIgnoreCase(LT(1)->getText(), "READ"))))
            	                                {
            	                                    alt278=2;
            	                                }
            	                                else if ( (((LA278_3 >= CHAR_STRING) && (LA278_3 <= CHAR_STRING_PERL)) || LA278_3 == NATIONAL_CHAR_STRING_LIT))
            	                                {
            	                                    alt278=1;
            	                                }
            	                                else if ( (LA278_3 == REGULAR_ID))
            	                                {
            	                                    {
            	                                        int LA278_5 = this->LA(4);
            	                                        if ( (LA278_5 == EOF || LA278_5 == SEMICOLON))
            	                                        {
            	                                            alt278=1;
            	                                        }
            	                                        else if ( (((LA278_5 >= CHAR_STRING) && (LA278_5 <= CHAR_STRING_PERL)) || LA278_5 == NATIONAL_CHAR_STRING_LIT || LA278_5 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "READ"))))
            	                                        {
            	                                            alt278=2;
            	                                        }
            	                                        else
            	                                        {
            	                                            if (this->get_backtracking()>0)
            	                                            {
            	                                                this->set_failedflag( true );
            	                                                return ;
            	                                            }


            	                                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                                            ex->set_decisionNum( 278 );
            	                                            ex->set_state( 5 );


            	                                            goto ruleset_transaction_commandEx;

            	                                        }
            	                                    }
            	                                }
            	                                else
            	                                {
            	                                    if (this->get_backtracking()>0)
            	                                    {
            	                                        this->set_failedflag( true );
            	                                        return ;
            	                                    }


            	                                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                                    ex->set_decisionNum( 278 );
            	                                    ex->set_state( 3 );


            	                                    goto ruleset_transaction_commandEx;

            	                                }
            	                            }
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 278 );
            	                            ex->set_state( 1 );


            	                            goto ruleset_transaction_commandEx;

            	                        }
            	                    }
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 278 );
            	                    ex->set_state( 0 );


            	                    goto ruleset_transaction_commandEx;

            	                }
            	            }
            	            switch (alt278)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:1069:35: serializable_key
            	        	    {
            	        	        this->followPush(FOLLOW_serializable_key_in_set_transaction_command8569);
            	        	        serializable_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleset_transaction_commandEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQLParser.g:1069:52: read_key committed_key
            	        	    {
            	        	        this->followPush(FOLLOW_read_key_in_set_transaction_command8571);
            	        	        read_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleset_transaction_commandEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_committed_key_in_set_transaction_command8573);
            	        	        committed_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleset_transaction_commandEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 3:
            	    // PLSQLParser.g:1070:10: use_key rollback_key segment_key rollback_segment_name
            	    {
            	        this->followPush(FOLLOW_use_key_in_set_transaction_command8585);
            	        use_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleset_transaction_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_rollback_key_in_set_transaction_command8587);
            	        rollback_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleset_transaction_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_segment_key_in_set_transaction_command8589);
            	        segment_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleset_transaction_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_rollback_segment_name_in_set_transaction_command8591);
            	        rollback_segment_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleset_transaction_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:1072:9: ( name_key quoted_string )?
            {
                int alt280=2;
                {
                    int LA280_0 = this->LA(1);
                    if ( (LA280_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "NAME")))||((equalsIgnoreCase(LT(1)->getText(), "SAVE"))))))
                    {
                        {
                            int LA280_1 = this->LA(2);
                            if ( (((LA280_1 >= CHAR_STRING) && (LA280_1 <= CHAR_STRING_PERL)) || LA280_1 == NATIONAL_CHAR_STRING_LIT) && ((equalsIgnoreCase(LT(1)->getText(), "NAME"))))
                            {
                                alt280=1;
                            }
                        }
                    }
                }
                switch (alt280)
                {
            	case 1:
            	    // PLSQLParser.g:1072:10: name_key quoted_string
            	    {
            	        this->followPush(FOLLOW_name_key_in_set_transaction_command8609);
            	        name_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleset_transaction_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_quoted_string_in_set_transaction_command8611);
            	        quoted_string();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleset_transaction_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleset_transaction_commandEx; /* Prevent compiler warnings */
    ruleset_transaction_commandEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end set_transaction_command */

/**
 * $ANTLR start set_constraint_command
 * PLSQLParser.g:1075:1: set_constraint_command : set_key ( constraint_key | constraints_key ) ( all_key | constraint_name ( COMMA constraint_name )* ) ( immediate_key | deferred_key ) ;
 */
void
PLSQLParser::set_constraint_command()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:1076:5: ( set_key ( constraint_key | constraints_key ) ( all_key | constraint_name ( COMMA constraint_name )* ) ( immediate_key | deferred_key ) )
        // PLSQLParser.g:1076:10: set_key ( constraint_key | constraints_key ) ( all_key | constraint_name ( COMMA constraint_name )* ) ( immediate_key | deferred_key )
        {
            this->followPush(FOLLOW_set_key_in_set_constraint_command8633);
            set_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleset_constraint_commandEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:1076:18: ( constraint_key | constraints_key )
            {
                int alt281=2;
                {
                    int LA281_0 = this->LA(1);
                    if ( (LA281_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "CONSTRAINTS")))||((equalsIgnoreCase(LT(1)->getText(), "CONSTRAINT"))))))
                    {
                        {
                            int LA281_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "CONSTRAINT"))))
                            {
                                alt281=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "CONSTRAINTS"))))
                            {
                                alt281=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 281 );
                                ex->set_state( 1 );


                                goto ruleset_constraint_commandEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 281 );
                        ex->set_state( 0 );


                        goto ruleset_constraint_commandEx;

                    }
                }
                switch (alt281)
                {
            	case 1:
            	    // PLSQLParser.g:1076:20: constraint_key
            	    {
            	        this->followPush(FOLLOW_constraint_key_in_set_constraint_command8637);
            	        constraint_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleset_constraint_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:1076:37: constraints_key
            	    {
            	        this->followPush(FOLLOW_constraints_key_in_set_constraint_command8641);
            	        constraints_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleset_constraint_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:1077:9: ( all_key | constraint_name ( COMMA constraint_name )* )
            {
                int alt283=2;
                {
                    int LA283_0 = this->LA(1);
                    if ( (LA283_0 == SQL92_RESERVED_ALL))
                    {
                        alt283=1;
                    }
                    else if ( (LA283_0 == DELIMITED_ID || LA283_0 == INTRODUCER || LA283_0 == REGULAR_ID))
                    {
                        alt283=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 283 );
                        ex->set_state( 0 );


                        goto ruleset_constraint_commandEx;

                    }
                }
                switch (alt283)
                {
            	case 1:
            	    // PLSQLParser.g:1077:11: all_key
            	    {
            	        this->followPush(FOLLOW_all_key_in_set_constraint_command8655);
            	        all_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleset_constraint_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:1077:21: constraint_name ( COMMA constraint_name )*
            	    {
            	        this->followPush(FOLLOW_constraint_name_in_set_constraint_command8659);
            	        constraint_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleset_constraint_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:1077:37: ( COMMA constraint_name )*

            	        for (;;)
            	        {
            	            int alt282=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA282_0 = this->LA(1);
            	                if ( (LA282_0 == COMMA))
            	                {
            	                    alt282=1;
            	                }

            	            }
            	            switch (alt282)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:1077:38: COMMA constraint_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_set_constraint_command8662);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleset_constraint_commandEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_constraint_name_in_set_constraint_command8664);
            	        	        constraint_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleset_constraint_commandEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop282;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop282: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:1078:9: ( immediate_key | deferred_key )
            {
                int alt284=2;
                {
                    int LA284_0 = this->LA(1);
                    if ( (LA284_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "DEFERRED")))||((equalsIgnoreCase(LT(1)->getText(), "IMMEDIATE"))))))
                    {
                        {
                            int LA284_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "IMMEDIATE"))))
                            {
                                alt284=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "DEFERRED"))))
                            {
                                alt284=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 284 );
                                ex->set_state( 1 );


                                goto ruleset_constraint_commandEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 284 );
                        ex->set_state( 0 );


                        goto ruleset_constraint_commandEx;

                    }
                }
                switch (alt284)
                {
            	case 1:
            	    // PLSQLParser.g:1078:10: immediate_key
            	    {
            	        this->followPush(FOLLOW_immediate_key_in_set_constraint_command8679);
            	        immediate_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleset_constraint_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:1078:24: deferred_key
            	    {
            	        this->followPush(FOLLOW_deferred_key_in_set_constraint_command8681);
            	        deferred_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleset_constraint_commandEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleset_constraint_commandEx; /* Prevent compiler warnings */
    ruleset_constraint_commandEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end set_constraint_command */

/**
 * $ANTLR start commit_statement
 * PLSQLParser.g:1081:1: commit_statement : commit_key ( work_key )? ( comment_key expression | force_key ( corrupt_xid_key expression | corrupt_xid_all_key | expression ( COMMA expression )? ) )? ( write_clause )? ;
 */
void
PLSQLParser::commit_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:1082:5: ( commit_key ( work_key )? ( comment_key expression | force_key ( corrupt_xid_key expression | corrupt_xid_all_key | expression ( COMMA expression )? ) )? ( write_clause )? )
        // PLSQLParser.g:1082:11: commit_key ( work_key )? ( comment_key expression | force_key ( corrupt_xid_key expression | corrupt_xid_all_key | expression ( COMMA expression )? ) )? ( write_clause )?
        {
            this->followPush(FOLLOW_commit_key_in_commit_statement8703);
            commit_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecommit_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:1082:22: ( work_key )?
            {
                int alt285=2;
                {
                    int LA285_0 = this->LA(1);
                    if ( (LA285_0 == REGULAR_ID))
                    {
                        {
                            int LA285_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "WORK"))))
                            {
                                alt285=1;
                            }
                        }
                    }
                }
                switch (alt285)
                {
            	case 1:
            	    // PLSQLParser.g:1082:22: work_key
            	    {
            	        this->followPush(FOLLOW_work_key_in_commit_statement8705);
            	        work_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecommit_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:1083:5: ( comment_key expression | force_key ( corrupt_xid_key expression | corrupt_xid_all_key | expression ( COMMA expression )? ) )?
            {
                int alt288=3;
                {
                    int LA288_0 = this->LA(1);
                    if ( (LA288_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "COMMENT")))||((equalsIgnoreCase(LT(1)->getText(), "FORCE")))||((equalsIgnoreCase(LT(1)->getText(), "WRITE")))||((equalsIgnoreCase(LT(1)->getText(), "SAVE"))))))
                    {
                        {
                            int LA288_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "COMMENT"))))
                            {
                                alt288=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "FORCE"))))
                            {
                                alt288=2;
                            }
                        }
                    }
                }
                switch (alt288)
                {
            	case 1:
            	    // PLSQLParser.g:1083:10: comment_key expression
            	    {
            	        this->followPush(FOLLOW_comment_key_in_commit_statement8717);
            	        comment_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecommit_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_commit_statement8719);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecommit_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:1084:10: force_key ( corrupt_xid_key expression | corrupt_xid_all_key | expression ( COMMA expression )? )
            	    {
            	        this->followPush(FOLLOW_force_key_in_commit_statement8730);
            	        force_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecommit_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:1084:20: ( corrupt_xid_key expression | corrupt_xid_all_key | expression ( COMMA expression )? )
            	        {
            	            int alt287=3;
            	            {
            	                int LA287_0 = this->LA(1);
            	                if ( (LA287_0 == REGULAR_ID))
            	                {
            	                    {
            	                        int LA287_1 = this->LA(2);
            	                        if ( (LA287_1 == APPROXIMATE_NUM_LIT || LA287_1 == BINDVAR || ((LA287_1 >= CHAR_STRING) && (LA287_1 <= COLON)) || LA287_1 == DELIMITED_ID || LA287_1 == EXACT_NUM_LIT || LA287_1 == INTRODUCER || LA287_1 == LEFT_PAREN || ((LA287_1 >= MINUS_SIGN) && (LA287_1 <= NATIONAL_CHAR_STRING_LIT)) || LA287_1 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA287_1 == PLUS_SIGN || LA287_1 == REGULAR_ID || LA287_1 == SQL92_RESERVED_ALL || LA287_1 == SQL92_RESERVED_ANY || LA287_1 == SQL92_RESERVED_CASE || ((LA287_1 >= SQL92_RESERVED_CURSOR) && (LA287_1 <= SQL92_RESERVED_DATE)) || LA287_1 == SQL92_RESERVED_DEFAULT || LA287_1 == SQL92_RESERVED_DISTINCT || ((LA287_1 >= SQL92_RESERVED_EXISTS) && (LA287_1 <= SQL92_RESERVED_FALSE)) || ((LA287_1 >= SQL92_RESERVED_NOT) && (LA287_1 <= SQL92_RESERVED_NULL)) || LA287_1 == SQL92_RESERVED_PRIOR || LA287_1 == SQL92_RESERVED_TRUE || LA287_1 == UNSIGNED_INTEGER) && ((equalsIgnoreCase(LT(1)->getText(), "CORRUPT_XID"))))
            	                        {
            	                            alt287=1;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "CORRUPT_XID_ALL"))))
            	                        {
            	                            alt287=2;
            	                        }
            	                        else if ( (true))
            	                        {
            	                            alt287=3;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 287 );
            	                            ex->set_state( 1 );


            	                            goto rulecommit_statementEx;

            	                        }
            	                    }
            	                }
            	                else if ( (LA287_0 == APPROXIMATE_NUM_LIT || LA287_0 == BINDVAR || ((LA287_0 >= CHAR_STRING) && (LA287_0 <= COLON)) || LA287_0 == DELIMITED_ID || LA287_0 == EXACT_NUM_LIT || LA287_0 == INTRODUCER || LA287_0 == LEFT_PAREN || ((LA287_0 >= MINUS_SIGN) && (LA287_0 <= NATIONAL_CHAR_STRING_LIT)) || LA287_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA287_0 == PLUS_SIGN || LA287_0 == SQL92_RESERVED_ALL || LA287_0 == SQL92_RESERVED_ANY || LA287_0 == SQL92_RESERVED_CASE || ((LA287_0 >= SQL92_RESERVED_CURSOR) && (LA287_0 <= SQL92_RESERVED_DATE)) || LA287_0 == SQL92_RESERVED_DEFAULT || LA287_0 == SQL92_RESERVED_DISTINCT || ((LA287_0 >= SQL92_RESERVED_EXISTS) && (LA287_0 <= SQL92_RESERVED_FALSE)) || ((LA287_0 >= SQL92_RESERVED_NOT) && (LA287_0 <= SQL92_RESERVED_NULL)) || LA287_0 == SQL92_RESERVED_PRIOR || LA287_0 == SQL92_RESERVED_TRUE || LA287_0 == UNSIGNED_INTEGER))
            	                {
            	                    alt287=3;
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 287 );
            	                    ex->set_state( 0 );


            	                    goto rulecommit_statementEx;

            	                }
            	            }
            	            switch (alt287)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:1084:21: corrupt_xid_key expression
            	        	    {
            	        	        this->followPush(FOLLOW_corrupt_xid_key_in_commit_statement8733);
            	        	        corrupt_xid_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecommit_statementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_expression_in_commit_statement8735);
            	        	        expression();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecommit_statementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQLParser.g:1084:49: corrupt_xid_all_key
            	        	    {
            	        	        this->followPush(FOLLOW_corrupt_xid_all_key_in_commit_statement8738);
            	        	        corrupt_xid_all_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecommit_statementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // PLSQLParser.g:1084:71: expression ( COMMA expression )?
            	        	    {
            	        	        this->followPush(FOLLOW_expression_in_commit_statement8742);
            	        	        expression();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecommit_statementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // PLSQLParser.g:1084:82: ( COMMA expression )?
            	        	        {
            	        	            int alt286=2;
            	        	            {
            	        	                int LA286_0 = this->LA(1);
            	        	                if ( (LA286_0 == COMMA))
            	        	                {
            	        	                    alt286=1;
            	        	                }
            	        	            }
            	        	            switch (alt286)
            	        	            {
            	        	        	case 1:
            	        	        	    // PLSQLParser.g:1084:83: COMMA expression
            	        	        	    {
            	        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_commit_statement8745);
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto rulecommit_statementEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	        this->followPush(FOLLOW_expression_in_commit_statement8747);
            	        	        	        expression();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto rulecommit_statementEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // PLSQLParser.g:1086:9: ( write_clause )?
            {
                int alt289=2;
                {
                    int LA289_0 = this->LA(1);
                    if ( (LA289_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "WRITE")))||((equalsIgnoreCase(LT(1)->getText(), "SAVE"))))))
                    {
                        {
                            int LA289_1 = this->LA(2);
                            if ( (LA289_1 == EOF || LA289_1 == PLSQL_RESERVED_NOWAIT || LA289_1 == SEMICOLON) && ((equalsIgnoreCase(LT(1)->getText(), "WRITE"))))
                            {
                                alt289=1;
                            }
                            else if ( (LA289_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "WRITE")))||((equalsIgnoreCase(LT(1)->getText(), "SAVE"))))))
                            {
                                {
                                    int LA289_4 = this->LA(3);
                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "WRITE"))))
                                    {
                                        alt289=1;
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt289)
                {
            	case 1:
            	    // PLSQLParser.g:1086:9: write_clause
            	    {
            	        this->followPush(FOLLOW_write_clause_in_commit_statement8767);
            	        write_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecommit_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulecommit_statementEx; /* Prevent compiler warnings */
    rulecommit_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end commit_statement */

/**
 * $ANTLR start write_clause
 * PLSQLParser.g:1089:1: write_clause : write_key ( wait_key | nowait_key )? ( immediate_key | batch_key )? ;
 */
void
PLSQLParser::write_clause()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:1090:5: ( write_key ( wait_key | nowait_key )? ( immediate_key | batch_key )? )
        // PLSQLParser.g:1090:10: write_key ( wait_key | nowait_key )? ( immediate_key | batch_key )?
        {
            this->followPush(FOLLOW_write_key_in_write_clause8788);
            write_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulewrite_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:1090:20: ( wait_key | nowait_key )?
            {
                int alt290=3;
                {
                    int LA290_0 = this->LA(1);
                    if ( (LA290_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "BATCH")))||((equalsIgnoreCase(LT(1)->getText(), "IMMEDIATE")))||((equalsIgnoreCase(LT(1)->getText(), "WAIT")))||((equalsIgnoreCase(LT(1)->getText(), "SAVE"))))))
                    {
                        {
                            int LA290_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "WAIT"))))
                            {
                                alt290=1;
                            }
                        }
                    }
                    else if ( (LA290_0 == PLSQL_RESERVED_NOWAIT))
                    {
                        alt290=2;
                    }
                }
                switch (alt290)
                {
            	case 1:
            	    // PLSQLParser.g:1090:21: wait_key
            	    {
            	        this->followPush(FOLLOW_wait_key_in_write_clause8791);
            	        wait_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewrite_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:1090:30: nowait_key
            	    {
            	        this->followPush(FOLLOW_nowait_key_in_write_clause8793);
            	        nowait_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewrite_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:1090:43: ( immediate_key | batch_key )?
            {
                int alt291=3;
                {
                    int LA291_0 = this->LA(1);
                    if ( (LA291_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "BATCH")))||((equalsIgnoreCase(LT(1)->getText(), "IMMEDIATE")))||((equalsIgnoreCase(LT(1)->getText(), "SAVE"))))))
                    {
                        {
                            int LA291_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "IMMEDIATE"))))
                            {
                                alt291=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "BATCH"))))
                            {
                                alt291=2;
                            }
                        }
                    }
                }
                switch (alt291)
                {
            	case 1:
            	    // PLSQLParser.g:1090:44: immediate_key
            	    {
            	        this->followPush(FOLLOW_immediate_key_in_write_clause8798);
            	        immediate_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewrite_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:1090:58: batch_key
            	    {
            	        this->followPush(FOLLOW_batch_key_in_write_clause8800);
            	        batch_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewrite_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulewrite_clauseEx; /* Prevent compiler warnings */
    rulewrite_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end write_clause */

/**
 * $ANTLR start rollback_statement
 * PLSQLParser.g:1093:1: rollback_statement : rollback_key ( work_key )? ( to_key ( savepoint_key )? savepoint_name | force_key quoted_string )? ;
 */
void
PLSQLParser::rollback_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:1094:5: ( rollback_key ( work_key )? ( to_key ( savepoint_key )? savepoint_name | force_key quoted_string )? )
        // PLSQLParser.g:1094:11: rollback_key ( work_key )? ( to_key ( savepoint_key )? savepoint_name | force_key quoted_string )?
        {
            this->followPush(FOLLOW_rollback_key_in_rollback_statement8823);
            rollback_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerollback_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQLParser.g:1094:24: ( work_key )?
            {
                int alt292=2;
                {
                    int LA292_0 = this->LA(1);
                    if ( (LA292_0 == REGULAR_ID))
                    {
                        {
                            int LA292_1 = this->LA(2);
                            if ( (LA292_1 == EOF || LA292_1 == SEMICOLON || LA292_1 == SQL92_RESERVED_TO))
                            {
                                alt292=1;
                            }
                            else if ( (LA292_1 == REGULAR_ID))
                            {
                                {
                                    int LA292_4 = this->LA(3);
                                    if ( (((LA292_4 >= CHAR_STRING) && (LA292_4 <= CHAR_STRING_PERL)) || LA292_4 == NATIONAL_CHAR_STRING_LIT || LA292_4 == REGULAR_ID))
                                    {
                                        alt292=1;
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt292)
                {
            	case 1:
            	    // PLSQLParser.g:1094:24: work_key
            	    {
            	        this->followPush(FOLLOW_work_key_in_rollback_statement8825);
            	        work_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerollback_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQLParser.g:1095:5: ( to_key ( savepoint_key )? savepoint_name | force_key quoted_string )?
            {
                int alt294=3;
                {
                    int LA294_0 = this->LA(1);
                    if ( (LA294_0 == SQL92_RESERVED_TO))
                    {
                        alt294=1;
                    }
                    else if ( (LA294_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FORCE")))||((equalsIgnoreCase(LT(1)->getText(), "SAVE"))))))
                    {
                        {
                            int LA294_2 = this->LA(2);
                            if ( (((LA294_2 >= CHAR_STRING) && (LA294_2 <= CHAR_STRING_PERL)) || LA294_2 == NATIONAL_CHAR_STRING_LIT) && ((equalsIgnoreCase(LT(1)->getText(), "FORCE"))))
                            {
                                alt294=2;
                            }
                        }
                    }
                }
                switch (alt294)
                {
            	case 1:
            	    // PLSQLParser.g:1095:11: to_key ( savepoint_key )? savepoint_name
            	    {
            	        this->followPush(FOLLOW_to_key_in_rollback_statement8838);
            	        to_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerollback_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQLParser.g:1095:18: ( savepoint_key )?
            	        {
            	            int alt293=2;
            	            {
            	                int LA293_0 = this->LA(1);
            	                if ( (LA293_0 == REGULAR_ID))
            	                {
            	                    {
            	                        int LA293_1 = this->LA(2);
            	                        if ( (LA293_1 == DELIMITED_ID || LA293_1 == INTRODUCER) && ((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT"))))
            	                        {
            	                            alt293=1;
            	                        }
            	                        else if ( (LA293_1 == REGULAR_ID))
            	                        {
            	                            {
            	                                int LA293_4 = this->LA(3);
            	                                if ( (LA293_4 == EOF || LA293_4 == SEMICOLON) && ((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT"))))
            	                                {
            	                                    alt293=1;
            	                                }
            	                                else if ( (LA293_4 == REGULAR_ID))
            	                                {
            	                                    {
            	                                        int LA293_5 = this->LA(4);
            	                                        if ( (LA293_5 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT"))))
            	                                        {
            	                                            alt293=1;
            	                                        }
            	                                    }
            	                                }
            	                            }
            	                        }
            	                    }
            	                }
            	            }
            	            switch (alt293)
            	            {
            	        	case 1:
            	        	    // PLSQLParser.g:1095:18: savepoint_key
            	        	    {
            	        	        this->followPush(FOLLOW_savepoint_key_in_rollback_statement8840);
            	        	        savepoint_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerollback_statementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_savepoint_name_in_rollback_statement8843);
            	        savepoint_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerollback_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQLParser.g:1096:10: force_key quoted_string
            	    {
            	        this->followPush(FOLLOW_force_key_in_rollback_statement8854);
            	        force_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerollback_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_quoted_string_in_rollback_statement8856);
            	        quoted_string();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerollback_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulerollback_statementEx; /* Prevent compiler warnings */
    rulerollback_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rollback_statement */

/**
 * $ANTLR start savepoint_statement
 * PLSQLParser.g:1100:1: savepoint_statement : savepoint_key savepoint_name ;
 */
void
PLSQLParser::savepoint_statement()
{
        PLSQLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLParser.g:1101:5: ( savepoint_key savepoint_name )
        // PLSQLParser.g:1101:10: savepoint_key savepoint_name
        {
            this->followPush(FOLLOW_savepoint_key_in_savepoint_statement8883);
            savepoint_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesavepoint_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_savepoint_name_in_savepoint_statement8885);
            savepoint_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesavepoint_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesavepoint_statementEx; /* Prevent compiler warnings */
    rulesavepoint_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end savepoint_statement */

// $ANTLR start synpred1_PLSQLParser
void PLSQLParser::msynpred1_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:71:11: ( alter_function )
    // PLSQLParser.g:71:11: alter_function
    {
        this->followPush(FOLLOW_alter_function_in_synpred1_PLSQLParser175);
        alter_function();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred1_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred1_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred1_PLSQLParserEx: ;
}
// $ANTLR end synpred1_PLSQLParser

// $ANTLR start synpred2_PLSQLParser
void PLSQLParser::msynpred2_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:72:10: ( alter_package )
    // PLSQLParser.g:72:10: alter_package
    {
        this->followPush(FOLLOW_alter_package_in_synpred2_PLSQLParser186);
        alter_package();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred2_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred2_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred2_PLSQLParserEx: ;
}
// $ANTLR end synpred2_PLSQLParser

// $ANTLR start synpred3_PLSQLParser
void PLSQLParser::msynpred3_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:73:10: ( alter_procedure )
    // PLSQLParser.g:73:10: alter_procedure
    {
        this->followPush(FOLLOW_alter_procedure_in_synpred3_PLSQLParser197);
        alter_procedure();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred3_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred3_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred3_PLSQLParserEx: ;
}
// $ANTLR end synpred3_PLSQLParser

// $ANTLR start synpred4_PLSQLParser
void PLSQLParser::msynpred4_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:74:10: ( alter_sequence )
    // PLSQLParser.g:74:10: alter_sequence
    {
        this->followPush(FOLLOW_alter_sequence_in_synpred4_PLSQLParser208);
        alter_sequence();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred4_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred4_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred4_PLSQLParserEx: ;
}
// $ANTLR end synpred4_PLSQLParser

// $ANTLR start synpred5_PLSQLParser
void PLSQLParser::msynpred5_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:75:10: ( alter_trigger )
    // PLSQLParser.g:75:10: alter_trigger
    {
        this->followPush(FOLLOW_alter_trigger_in_synpred5_PLSQLParser219);
        alter_trigger();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred5_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred5_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred5_PLSQLParserEx: ;
}
// $ANTLR end synpred5_PLSQLParser

// $ANTLR start synpred6_PLSQLParser
void PLSQLParser::msynpred6_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:76:10: ( alter_type )
    // PLSQLParser.g:76:10: alter_type
    {
        this->followPush(FOLLOW_alter_type_in_synpred6_PLSQLParser230);
        alter_type();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred6_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred6_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred6_PLSQLParserEx: ;
}
// $ANTLR end synpred6_PLSQLParser

// $ANTLR start synpred7_PLSQLParser
void PLSQLParser::msynpred7_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:78:10: ( create_function_body )
    // PLSQLParser.g:78:10: create_function_body
    {
        this->followPush(FOLLOW_create_function_body_in_synpred7_PLSQLParser242);
        create_function_body();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred7_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred7_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred7_PLSQLParserEx: ;
}
// $ANTLR end synpred7_PLSQLParser

// $ANTLR start synpred8_PLSQLParser
void PLSQLParser::msynpred8_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:79:10: ( create_procedure_body )
    // PLSQLParser.g:79:10: create_procedure_body
    {
        this->followPush(FOLLOW_create_procedure_body_in_synpred8_PLSQLParser253);
        create_procedure_body();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred8_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred8_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred8_PLSQLParserEx: ;
}
// $ANTLR end synpred8_PLSQLParser

// $ANTLR start synpred9_PLSQLParser
void PLSQLParser::msynpred9_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:80:10: ( create_package )
    // PLSQLParser.g:80:10: create_package
    {
        this->followPush(FOLLOW_create_package_in_synpred9_PLSQLParser264);
        create_package();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred9_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred9_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred9_PLSQLParserEx: ;
}
// $ANTLR end synpred9_PLSQLParser

// $ANTLR start synpred10_PLSQLParser
void PLSQLParser::msynpred10_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:88:10: ( create_sequence )
    // PLSQLParser.g:88:10: create_sequence
    {
        this->followPush(FOLLOW_create_sequence_in_synpred10_PLSQLParser282);
        create_sequence();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred10_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred10_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred10_PLSQLParserEx: ;
}
// $ANTLR end synpred10_PLSQLParser

// $ANTLR start synpred11_PLSQLParser
void PLSQLParser::msynpred11_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:89:10: ( create_trigger )
    // PLSQLParser.g:89:10: create_trigger
    {
        this->followPush(FOLLOW_create_trigger_in_synpred11_PLSQLParser293);
        create_trigger();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred11_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred11_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred11_PLSQLParserEx: ;
}
// $ANTLR end synpred11_PLSQLParser

// $ANTLR start synpred12_PLSQLParser
void PLSQLParser::msynpred12_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:90:10: ( create_type )
    // PLSQLParser.g:90:10: create_type
    {
        this->followPush(FOLLOW_create_type_in_synpred12_PLSQLParser304);
        create_type();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred12_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred12_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred12_PLSQLParserEx: ;
}
// $ANTLR end synpred12_PLSQLParser

// $ANTLR start synpred13_PLSQLParser
void PLSQLParser::msynpred13_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:92:10: ( drop_function )
    // PLSQLParser.g:92:10: drop_function
    {
        this->followPush(FOLLOW_drop_function_in_synpred13_PLSQLParser316);
        drop_function();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred13_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred13_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred13_PLSQLParserEx: ;
}
// $ANTLR end synpred13_PLSQLParser

// $ANTLR start synpred14_PLSQLParser
void PLSQLParser::msynpred14_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:93:10: ( drop_package )
    // PLSQLParser.g:93:10: drop_package
    {
        this->followPush(FOLLOW_drop_package_in_synpred14_PLSQLParser327);
        drop_package();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred14_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred14_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred14_PLSQLParserEx: ;
}
// $ANTLR end synpred14_PLSQLParser

// $ANTLR start synpred15_PLSQLParser
void PLSQLParser::msynpred15_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:94:10: ( drop_procedure )
    // PLSQLParser.g:94:10: drop_procedure
    {
        this->followPush(FOLLOW_drop_procedure_in_synpred15_PLSQLParser338);
        drop_procedure();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred15_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred15_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred15_PLSQLParserEx: ;
}
// $ANTLR end synpred15_PLSQLParser

// $ANTLR start synpred16_PLSQLParser
void PLSQLParser::msynpred16_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:95:10: ( drop_sequence )
    // PLSQLParser.g:95:10: drop_sequence
    {
        this->followPush(FOLLOW_drop_sequence_in_synpred16_PLSQLParser349);
        drop_sequence();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred16_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred16_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred16_PLSQLParserEx: ;
}
// $ANTLR end synpred16_PLSQLParser

// $ANTLR start synpred17_PLSQLParser
void PLSQLParser::msynpred17_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:96:10: ( drop_trigger )
    // PLSQLParser.g:96:10: drop_trigger
    {
        this->followPush(FOLLOW_drop_trigger_in_synpred17_PLSQLParser360);
        drop_trigger();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred17_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred17_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred17_PLSQLParserEx: ;
}
// $ANTLR end synpred17_PLSQLParser

// $ANTLR start synpred18_PLSQLParser
void PLSQLParser::msynpred18_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:97:10: ( drop_type )
    // PLSQLParser.g:97:10: drop_type
    {
        this->followPush(FOLLOW_drop_type_in_synpred18_PLSQLParser371);
        drop_type();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred18_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred18_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred18_PLSQLParserEx: ;
}
// $ANTLR end synpred18_PLSQLParser

// $ANTLR start synpred19_PLSQLParser
void PLSQLParser::msynpred19_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:201:11: ( variable_declaration )
    // PLSQLParser.g:201:11: variable_declaration
    {
        this->followPush(FOLLOW_variable_declaration_in_synpred19_PLSQLParser1354);
        variable_declaration();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred19_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred19_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred19_PLSQLParserEx: ;
}
// $ANTLR end synpred19_PLSQLParser

// $ANTLR start synpred20_PLSQLParser
void PLSQLParser::msynpred20_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:202:11: ( subtype_declaration )
    // PLSQLParser.g:202:11: subtype_declaration
    {
        this->followPush(FOLLOW_subtype_declaration_in_synpred20_PLSQLParser1366);
        subtype_declaration();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred20_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred20_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred20_PLSQLParserEx: ;
}
// $ANTLR end synpred20_PLSQLParser

// $ANTLR start synpred22_PLSQLParser
void PLSQLParser::msynpred22_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:204:11: ( exception_declaration )
    // PLSQLParser.g:204:11: exception_declaration
    {
        this->followPush(FOLLOW_exception_declaration_in_synpred22_PLSQLParser1390);
        exception_declaration();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred22_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred22_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred22_PLSQLParserEx: ;
}
// $ANTLR end synpred22_PLSQLParser

// $ANTLR start synpred23_PLSQLParser
void PLSQLParser::msynpred23_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:205:11: ( record_declaration )
    // PLSQLParser.g:205:11: record_declaration
    {
        this->followPush(FOLLOW_record_declaration_in_synpred23_PLSQLParser1402);
        record_declaration();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred23_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred23_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred23_PLSQLParserEx: ;
}
// $ANTLR end synpred23_PLSQLParser

// $ANTLR start synpred24_PLSQLParser
void PLSQLParser::msynpred24_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:206:11: ( table_declaration )
    // PLSQLParser.g:206:11: table_declaration
    {
        this->followPush(FOLLOW_table_declaration_in_synpred24_PLSQLParser1414);
        table_declaration();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred24_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred24_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred24_PLSQLParserEx: ;
}
// $ANTLR end synpred24_PLSQLParser

// $ANTLR start synpred26_PLSQLParser
void PLSQLParser::msynpred26_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:225:12: ( variable_declaration )
    // PLSQLParser.g:225:12: variable_declaration
    {
        this->followPush(FOLLOW_variable_declaration_in_synpred26_PLSQLParser1586);
        variable_declaration();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred26_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred26_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred26_PLSQLParserEx: ;
}
// $ANTLR end synpred26_PLSQLParser

// $ANTLR start synpred27_PLSQLParser
void PLSQLParser::msynpred27_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:226:11: ( subtype_declaration )
    // PLSQLParser.g:226:11: subtype_declaration
    {
        this->followPush(FOLLOW_subtype_declaration_in_synpred27_PLSQLParser1599);
        subtype_declaration();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred27_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred27_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred27_PLSQLParserEx: ;
}
// $ANTLR end synpred27_PLSQLParser

// $ANTLR start synpred29_PLSQLParser
void PLSQLParser::msynpred29_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:228:11: ( exception_declaration )
    // PLSQLParser.g:228:11: exception_declaration
    {
        this->followPush(FOLLOW_exception_declaration_in_synpred29_PLSQLParser1625);
        exception_declaration();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred29_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred29_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred29_PLSQLParserEx: ;
}
// $ANTLR end synpred29_PLSQLParser

// $ANTLR start synpred30_PLSQLParser
void PLSQLParser::msynpred30_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:229:11: ( record_declaration )
    // PLSQLParser.g:229:11: record_declaration
    {
        this->followPush(FOLLOW_record_declaration_in_synpred30_PLSQLParser1638);
        record_declaration();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred30_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred30_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred30_PLSQLParserEx: ;
}
// $ANTLR end synpred30_PLSQLParser

// $ANTLR start synpred31_PLSQLParser
void PLSQLParser::msynpred31_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:230:11: ( table_declaration )
    // PLSQLParser.g:230:11: table_declaration
    {
        this->followPush(FOLLOW_table_declaration_in_synpred31_PLSQLParser1650);
        table_declaration();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred31_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred31_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred31_PLSQLParserEx: ;
}
// $ANTLR end synpred31_PLSQLParser

// $ANTLR start synpred32_PLSQLParser
void PLSQLParser::msynpred32_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:231:11: ( create_procedure_body )
    // PLSQLParser.g:231:11: create_procedure_body
    {
        this->followPush(FOLLOW_create_procedure_body_in_synpred32_PLSQLParser1662);
        create_procedure_body();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred32_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred32_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred32_PLSQLParserEx: ;
}
// $ANTLR end synpred32_PLSQLParser

// $ANTLR start synpred33_PLSQLParser
void PLSQLParser::msynpred33_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:321:10: ( compound_key trigger_key )
    // PLSQLParser.g:321:11: compound_key trigger_key
    {
        this->followPush(FOLLOW_compound_key_in_synpred33_PLSQLParser2449);
        compound_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred33_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_trigger_key_in_synpred33_PLSQLParser2451);
        trigger_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred33_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred33_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred33_PLSQLParserEx: ;
}
// $ANTLR end synpred33_PLSQLParser

// $ANTLR start synpred34_PLSQLParser
void PLSQLParser::msynpred34_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:322:10: ( call_key id )
    // PLSQLParser.g:322:11: call_key id
    {
        this->followPush(FOLLOW_call_key_in_synpred34_PLSQLParser2467);
        call_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred34_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_id_in_synpred34_PLSQLParser2469);
        id();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred34_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred34_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred34_PLSQLParserEx: ;
}
// $ANTLR end synpred34_PLSQLParser

// $ANTLR start synpred35_PLSQLParser
void PLSQLParser::msynpred35_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:562:11: ( id type_spec ( sqlj_object_type_attr )? )
    // PLSQLParser.g:562:11: id type_spec ( sqlj_object_type_attr )?
    {
        this->followPush(FOLLOW_id_in_synpred35_PLSQLParser4586);
        id();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred35_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_type_spec_in_synpred35_PLSQLParser4588);
        type_spec();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred35_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        // PLSQLParser.g:562:24: ( sqlj_object_type_attr )?
        {
            int alt295=2;
            {
                int LA295_0 = this->LA(1);
                if ( (LA295_0 == REGULAR_ID))
                {
                    alt295=1;
                }
            }
            switch (alt295)
            {
        	case 1:
        	    // PLSQLParser.g:562:24: sqlj_object_type_attr
        	    {
        	        this->followPush(FOLLOW_sqlj_object_type_attr_in_synpred35_PLSQLParser4590);
        	        sqlj_object_type_attr();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred35_PLSQLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

    }


goto rulesynpred35_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred35_PLSQLParserEx: ;
}
// $ANTLR end synpred35_PLSQLParser

// $ANTLR start synpred36_PLSQLParser
void PLSQLParser::msynpred36_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:721:11: ( variable_declaration )
    // PLSQLParser.g:721:11: variable_declaration
    {
        this->followPush(FOLLOW_variable_declaration_in_synpred36_PLSQLParser5780);
        variable_declaration();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred36_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred36_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred36_PLSQLParserEx: ;
}
// $ANTLR end synpred36_PLSQLParser

// $ANTLR start synpred37_PLSQLParser
void PLSQLParser::msynpred37_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:722:11: ( subtype_declaration )
    // PLSQLParser.g:722:11: subtype_declaration
    {
        this->followPush(FOLLOW_subtype_declaration_in_synpred37_PLSQLParser5792);
        subtype_declaration();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred37_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred37_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred37_PLSQLParserEx: ;
}
// $ANTLR end synpred37_PLSQLParser

// $ANTLR start synpred39_PLSQLParser
void PLSQLParser::msynpred39_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:724:11: ( exception_declaration )
    // PLSQLParser.g:724:11: exception_declaration
    {
        this->followPush(FOLLOW_exception_declaration_in_synpred39_PLSQLParser5816);
        exception_declaration();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred39_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred39_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred39_PLSQLParserEx: ;
}
// $ANTLR end synpred39_PLSQLParser

// $ANTLR start synpred40_PLSQLParser
void PLSQLParser::msynpred40_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:725:11: ( pragma_declaration )
    // PLSQLParser.g:725:11: pragma_declaration
    {
        this->followPush(FOLLOW_pragma_declaration_in_synpred40_PLSQLParser5828);
        pragma_declaration();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred40_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred40_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred40_PLSQLParserEx: ;
}
// $ANTLR end synpred40_PLSQLParser

// $ANTLR start synpred41_PLSQLParser
void PLSQLParser::msynpred41_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:726:11: ( record_declaration )
    // PLSQLParser.g:726:11: record_declaration
    {
        this->followPush(FOLLOW_record_declaration_in_synpred41_PLSQLParser5840);
        record_declaration();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred41_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred41_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred41_PLSQLParserEx: ;
}
// $ANTLR end synpred41_PLSQLParser

// $ANTLR start synpred42_PLSQLParser
void PLSQLParser::msynpred42_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:727:11: ( table_declaration )
    // PLSQLParser.g:727:11: table_declaration
    {
        this->followPush(FOLLOW_table_declaration_in_synpred42_PLSQLParser5852);
        table_declaration();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred42_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred42_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred42_PLSQLParserEx: ;
}
// $ANTLR end synpred42_PLSQLParser

// $ANTLR start synpred43_PLSQLParser
void PLSQLParser::msynpred43_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:728:11: ( create_procedure_body )
    // PLSQLParser.g:728:11: create_procedure_body
    {
        this->followPush(FOLLOW_create_procedure_body_in_synpred43_PLSQLParser5864);
        create_procedure_body();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred43_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred43_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred43_PLSQLParserEx: ;
}
// $ANTLR end synpred43_PLSQLParser

// $ANTLR start synpred44_PLSQLParser
void PLSQLParser::msynpred44_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:844:10: ( create_key swallow_to_semi ( SEMICOLON | EOF ) )
    // PLSQLParser.g:844:10: create_key swallow_to_semi ( SEMICOLON | EOF )
    {
        this->followPush(FOLLOW_create_key_in_synpred44_PLSQLParser6871);
        create_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred44_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_swallow_to_semi_in_synpred44_PLSQLParser6873);
        swallow_to_semi();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred44_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        if ( this->LA(1) == EOF || this->LA(1) == SEMICOLON )
        {
            this->consume();
            this->set_perror_recovery(false);
             this->set_failedflag(false); 

        }
        else
        {
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            new ANTLR_Exception< PLSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
            this->get_exception()->set_expectingSet(NULL);

            goto rulesynpred44_PLSQLParserEx;
        }


    }


goto rulesynpred44_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred44_PLSQLParserEx: ;
}
// $ANTLR end synpred44_PLSQLParser

// $ANTLR start synpred47_PLSQLParser
void PLSQLParser::msynpred47_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:847:10: ( truncate_key swallow_to_semi ( SEMICOLON | EOF ) )
    // PLSQLParser.g:847:10: truncate_key swallow_to_semi ( SEMICOLON | EOF )
    {
        this->followPush(FOLLOW_truncate_key_in_synpred47_PLSQLParser6930);
        truncate_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred47_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_swallow_to_semi_in_synpred47_PLSQLParser6932);
        swallow_to_semi();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred47_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        if ( this->LA(1) == EOF || this->LA(1) == SEMICOLON )
        {
            this->consume();
            this->set_perror_recovery(false);
             this->set_failedflag(false); 

        }
        else
        {
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            new ANTLR_Exception< PLSQLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
            this->get_exception()->set_expectingSet(NULL);

            goto rulesynpred47_PLSQLParserEx;
        }


    }


goto rulesynpred47_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred47_PLSQLParserEx: ;
}
// $ANTLR end synpred47_PLSQLParser

// $ANTLR start synpred48_PLSQLParser
void PLSQLParser::msynpred48_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:848:10: ( begin_key )
    // PLSQLParser.g:848:11: begin_key
    {
        this->followPush(FOLLOW_begin_key_in_synpred48_PLSQLParser6951);
        begin_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred48_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred48_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred48_PLSQLParserEx: ;
}
// $ANTLR end synpred48_PLSQLParser

// $ANTLR start synpred49_PLSQLParser
void PLSQLParser::msynpred49_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:849:10: ( declare_key )
    // PLSQLParser.g:849:11: declare_key
    {
        this->followPush(FOLLOW_declare_key_in_synpred49_PLSQLParser6968);
        declare_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred49_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred49_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred49_PLSQLParserEx: ;
}
// $ANTLR end synpred49_PLSQLParser

// $ANTLR start synpred50_PLSQLParser
void PLSQLParser::msynpred50_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:850:10: ( assignment_statement )
    // PLSQLParser.g:850:10: assignment_statement
    {
        this->followPush(FOLLOW_assignment_statement_in_synpred50_PLSQLParser6984);
        assignment_statement();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred50_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred50_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred50_PLSQLParserEx: ;
}
// $ANTLR end synpred50_PLSQLParser

// $ANTLR start synpred51_PLSQLParser
void PLSQLParser::msynpred51_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:851:10: ( continue_statement )
    // PLSQLParser.g:851:10: continue_statement
    {
        this->followPush(FOLLOW_continue_statement_in_synpred51_PLSQLParser6995);
        continue_statement();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred51_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred51_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred51_PLSQLParserEx: ;
}
// $ANTLR end synpred51_PLSQLParser

// $ANTLR start synpred52_PLSQLParser
void PLSQLParser::msynpred52_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:852:10: ( exit_statement )
    // PLSQLParser.g:852:10: exit_statement
    {
        this->followPush(FOLLOW_exit_statement_in_synpred52_PLSQLParser7006);
        exit_statement();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred52_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred52_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred52_PLSQLParserEx: ;
}
// $ANTLR end synpred52_PLSQLParser

// $ANTLR start synpred55_PLSQLParser
void PLSQLParser::msynpred55_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:855:10: ( loop_statement )
    // PLSQLParser.g:855:10: loop_statement
    {
        this->followPush(FOLLOW_loop_statement_in_synpred55_PLSQLParser7039);
        loop_statement();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred55_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred55_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred55_PLSQLParserEx: ;
}
// $ANTLR end synpred55_PLSQLParser

// $ANTLR start synpred56_PLSQLParser
void PLSQLParser::msynpred56_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:856:10: ( forall_statement )
    // PLSQLParser.g:856:10: forall_statement
    {
        this->followPush(FOLLOW_forall_statement_in_synpred56_PLSQLParser7050);
        forall_statement();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred56_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred56_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred56_PLSQLParserEx: ;
}
// $ANTLR end synpred56_PLSQLParser

// $ANTLR start synpred58_PLSQLParser
void PLSQLParser::msynpred58_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:858:10: ( raise_statement )
    // PLSQLParser.g:858:10: raise_statement
    {
        this->followPush(FOLLOW_raise_statement_in_synpred58_PLSQLParser7072);
        raise_statement();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred58_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred58_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred58_PLSQLParserEx: ;
}
// $ANTLR end synpred58_PLSQLParser

// $ANTLR start synpred59_PLSQLParser
void PLSQLParser::msynpred59_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:859:10: ( return_statement )
    // PLSQLParser.g:859:10: return_statement
    {
        this->followPush(FOLLOW_return_statement_in_synpred59_PLSQLParser7083);
        return_statement();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred59_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred59_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred59_PLSQLParserEx: ;
}
// $ANTLR end synpred59_PLSQLParser

// $ANTLR start synpred60_PLSQLParser
void PLSQLParser::msynpred60_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:860:10: ( case_statement[true] )
    // PLSQLParser.g:860:10: case_statement[true]
    {
        this->followPush(FOLLOW_case_statement_in_synpred60_PLSQLParser7094);
        case_statement(true);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred60_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred60_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred60_PLSQLParserEx: ;
}
// $ANTLR end synpred60_PLSQLParser

// $ANTLR start synpred61_PLSQLParser
void PLSQLParser::msynpred61_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:861:10: ( sql_statement )
    // PLSQLParser.g:861:10: sql_statement
    {
        this->followPush(FOLLOW_sql_statement_in_synpred61_PLSQLParser7106);
        sql_statement();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred61_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred61_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred61_PLSQLParserEx: ;
}
// $ANTLR end synpred61_PLSQLParser

// $ANTLR start synpred62_PLSQLParser
void PLSQLParser::msynpred62_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:906:10: ( index_name in_key ( reverse_key )? lower_bound DOUBLE_PERIOD )
    // PLSQLParser.g:906:11: index_name in_key ( reverse_key )? lower_bound DOUBLE_PERIOD
    {
        this->followPush(FOLLOW_index_name_in_synpred62_PLSQLParser7428);
        index_name();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred62_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_in_key_in_synpred62_PLSQLParser7430);
        in_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred62_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        // PLSQLParser.g:906:29: ( reverse_key )?
        {
            int alt296=2;
            {
                int LA296_0 = this->LA(1);
                if ( (LA296_0 == REGULAR_ID))
                {
                    {
                        int LA296_1 = this->LA(2);
                        if ( ((equalsIgnoreCase(LT(1)->getText(), "REVERSE"))))
                        {
                            alt296=1;
                        }
                    }
                }
            }
            switch (alt296)
            {
        	case 1:
        	    // PLSQLParser.g:906:29: reverse_key
        	    {
        	        this->followPush(FOLLOW_reverse_key_in_synpred62_PLSQLParser7432);
        	        reverse_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred62_PLSQLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

        this->followPush(FOLLOW_lower_bound_in_synpred62_PLSQLParser7435);
        lower_bound();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred62_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(DOUBLE_PERIOD, &FOLLOW_DOUBLE_PERIOD_in_synpred62_PLSQLParser7437);
        if  (this->hasException())
        {
            goto rulesynpred62_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred62_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred62_PLSQLParserEx: ;
}
// $ANTLR end synpred62_PLSQLParser

// $ANTLR start synpred65_PLSQLParser
void PLSQLParser::msynpred65_PLSQLParser_fragment(  )
{
    // PLSQLParser.g:989:10: ( cursor_manipulation_statements )
    // PLSQLParser.g:989:10: cursor_manipulation_statements
    {
        this->followPush(FOLLOW_cursor_manipulation_statements_in_synpred65_PLSQLParser7995);
        cursor_manipulation_statements();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred65_PLSQLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred65_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred65_PLSQLParserEx: ;
}
// $ANTLR end synpred65_PLSQLParser

// $ANTLR start synpred66_PLSQLParser
void PLSQLParser::msynpred66_PLSQLParser_fragment(  )
{
    {
        //  PLSQLParser.g:1048:10: ( select_key | with_key )

        ANTLR_UINT32 alt297;

        alt297=2;

        {
            int LA297_0 = this->LA(1);
            if ( (LA297_0 == SQL92_RESERVED_SELECT))
            {
                alt297=1;
            }
            else if ( (LA297_0 == SQL92_RESERVED_WITH))
            {
                alt297=2;
            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }


                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 297 );
                ex->set_state( 0 );


                goto rulesynpred66_PLSQLParserEx;

            }
        }
        switch (alt297)
        {
    	case 1:
    	    // PLSQLParser.g:1048:11: select_key
    	    {
    	        this->followPush(FOLLOW_select_key_in_synpred66_PLSQLParser8411);
    	        select_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred66_PLSQLParserEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;
    	case 2:
    	    // PLSQLParser.g:1048:22: with_key
    	    {
    	        this->followPush(FOLLOW_with_key_in_synpred66_PLSQLParser8413);
    	        with_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred66_PLSQLParserEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;

        }
    }

goto rulesynpred66_PLSQLParserEx; /* Prevent compiler warnings */
rulesynpred66_PLSQLParserEx: ;
}
// $ANTLR end synpred66_PLSQLParser
	// Delegated methods that appear to be a part of this
	// parser
	//
    void PLSQLParser::validate_key()
    {
m_gPLSQLKeys->validate_key();
    }

    void PLSQLParser::main_key()
    {
m_gPLSQLKeys->main_key();
    }

    void PLSQLParser::oid_key()
    {
m_gPLSQLKeys->oid_key();
    }

    void PLSQLParser::escape_key()
    {
m_gPLSQLKeys->escape_key();
    }

    void PLSQLParser::authid_key()
    {
m_gPLSQLKeys->authid_key();
    }

    void PLSQLParser::long_key()
    {
m_gPLSQLKeys->long_key();
    }

    void PLSQLParser::connect_key()
    {
m_gPLSQLKeys->connect_key();
    }

    void PLSQLParser::varying_key()
    {
m_gPLSQLKeys->varying_key();
    }

    void PLSQLParser::explain_statement()
    {
m_gPLSQL_DMLParser->explain_statement();
    }

    void PLSQLParser::cost_matrix_clause()
    {
m_gPLSQL_DMLParser->cost_matrix_clause();
    }

    void PLSQLParser::desc_key()
    {
m_gPLSQLKeys->desc_key();
    }

    void PLSQLParser::final_key()
    {
m_gPLSQLKeys->final_key();
    }

    void PLSQLParser::updated_key()
    {
m_gPLSQLKeys->updated_key();
    }

    void PLSQLParser::to_key()
    {
m_gPLSQLKeys->to_key();
    }

    void PLSQLParser::merge_update_clause()
    {
m_gPLSQL_DMLParser->merge_update_clause();
    }

    void PLSQLParser::percent_type_key()
    {
m_gPLSQLKeys->percent_type_key();
    }

    void PLSQLParser::treat_key()
    {
m_gPLSQLKeys->treat_key();
    }

    void PLSQLParser::xmlroot_key()
    {
m_gPLSQLKeys->xmlroot_key();
    }

    void PLSQLParser::table_collection_expression()
    {
m_gPLSQL_DMLParser->table_collection_expression();
    }

    void PLSQLParser::routine_name()
    {
m_gPLSQLCommons->routine_name();
    }

    void PLSQLParser::stantard_function_enabling_over()
    {
m_gPLSQL_DMLParser->stantard_function_enabling_over();
    }

    void PLSQLParser::add_key()
    {
m_gPLSQLKeys->add_key();
    }

    void PLSQLParser::chartorowid_key()
    {
m_gPLSQLKeys->chartorowid_key();
    }

    void PLSQLParser::shutdown_key()
    {
m_gPLSQLKeys->shutdown_key();
    }

    void PLSQLParser::where_key()
    {
m_gPLSQLKeys->where_key();
    }

    void PLSQLParser::collect_order_by_part()
    {
m_gPLSQL_DMLParser->collect_order_by_part();
    }

    void PLSQLParser::depth_key()
    {
m_gPLSQLKeys->depth_key();
    }

    void PLSQLParser::char_set_name()
    {
m_gPLSQLCommons->char_set_name();
    }

    void PLSQLParser::table_key()
    {
m_gPLSQLKeys->table_key();
    }

    void PLSQLParser::show_key()
    {
m_gPLSQLKeys->show_key();
    }

    void PLSQLParser::partition_key()
    {
m_gPLSQLKeys->partition_key();
    }

    void PLSQLParser::select_statement()
    {
m_gPLSQL_DMLParser->select_statement();
    }

    void PLSQLParser::count_key()
    {
m_gPLSQLKeys->count_key();
    }

    void PLSQLParser::distinct_key()
    {
m_gPLSQLKeys->distinct_key();
    }

    void PLSQLParser::blob_key()
    {
m_gPLSQLKeys->blob_key();
    }

    void PLSQLParser::if_key()
    {
m_gPLSQLKeys->if_key();
    }

    void PLSQLParser::insert_key()
    {
m_gPLSQLKeys->insert_key();
    }

    void PLSQLParser::ignore_key()
    {
m_gPLSQLKeys->ignore_key();
    }

    void PLSQLParser::deterministic_key()
    {
m_gPLSQLKeys->deterministic_key();
    }

    void PLSQLParser::pivot_in_clause()
    {
m_gPLSQL_DMLParser->pivot_in_clause();
    }

    void PLSQLParser::to_date_key()
    {
m_gPLSQLKeys->to_date_key();
    }

    void PLSQLParser::minute_key()
    {
m_gPLSQLKeys->minute_key();
    }

    void PLSQLParser::committed_key()
    {
m_gPLSQLKeys->committed_key();
    }

    void PLSQLParser::sample_key()
    {
m_gPLSQLKeys->sample_key();
    }

    void PLSQLParser::trigger_key()
    {
m_gPLSQLKeys->trigger_key();
    }

    void PLSQLParser::invalidate_key()
    {
m_gPLSQLKeys->invalidate_key();
    }

    void PLSQLParser::prior_key()
    {
m_gPLSQLKeys->prior_key();
    }

    void PLSQLParser::xml_passing_clause()
    {
m_gPLSQL_DMLParser->xml_passing_clause();
    }

    void PLSQLParser::pivot_element()
    {
m_gPLSQL_DMLParser->pivot_element();
    }

    void PLSQLParser::restrict_references_key()
    {
m_gPLSQLKeys->restrict_references_key();
    }

    void PLSQLParser::model_expression()
    {
m_gPLSQL_DMLParser->model_expression();
    }

    void PLSQLParser::floor_key()
    {
m_gPLSQLKeys->floor_key();
    }

    void PLSQLParser::values_clause()
    {
m_gPLSQL_DMLParser->values_clause();
    }

    void PLSQLParser::type_name()
    {
m_gPLSQLCommons->type_name();
    }

    void PLSQLParser::errors_key()
    {
m_gPLSQLKeys->errors_key();
    }

    void PLSQLParser::package_name()
    {
m_gPLSQLCommons->package_name();
    }

    void PLSQLParser::sqrt_key()
    {
m_gPLSQLKeys->sqrt_key();
    }

    void PLSQLParser::group_by_elements()
    {
m_gPLSQL_DMLParser->group_by_elements();
    }

    void PLSQLParser::sequential_key()
    {
m_gPLSQLKeys->sequential_key();
    }

    void PLSQLParser::the_key()
    {
m_gPLSQLKeys->the_key();
    }

    void PLSQLParser::work_key()
    {
m_gPLSQLKeys->work_key();
    }

    void PLSQLParser::intersect_key()
    {
m_gPLSQLKeys->intersect_key();
    }

    void PLSQLParser::fetch_key()
    {
m_gPLSQLKeys->fetch_key();
    }

    void PLSQLParser::reject_key()
    {
m_gPLSQLKeys->reject_key();
    }

    void PLSQLParser::size_key()
    {
m_gPLSQLKeys->size_key();
    }

    void PLSQLParser::min_key()
    {
m_gPLSQLKeys->min_key();
    }

    void PLSQLParser::percent_notfound_key()
    {
m_gPLSQLKeys->percent_notfound_key();
    }

    void PLSQLParser::statistics_key()
    {
m_gPLSQLKeys->statistics_key();
    }

    void PLSQLParser::join_clause()
    {
m_gPLSQL_DMLParser->join_clause();
    }

    void PLSQLParser::share_key()
    {
m_gPLSQLKeys->share_key();
    }

    void PLSQLParser::variable_name()
    {
m_gPLSQLCommons->variable_name();
    }

    void PLSQLParser::oserror_key()
    {
m_gPLSQLKeys->oserror_key();
    }

    void PLSQLParser::multi_column_for_loop()
    {
m_gPLSQL_DMLParser->multi_column_for_loop();
    }

    void PLSQLParser::char_length_key()
    {
m_gPLSQLKeys->char_length_key();
    }

    void PLSQLParser::cube_key()
    {
m_gPLSQLKeys->cube_key();
    }

    void PLSQLParser::time_key()
    {
m_gPLSQLKeys->time_key();
    }

    void PLSQLParser::datetime_expression()
    {
m_gPLSQL_DMLParser->datetime_expression();
    }

    void PLSQLParser::until_key()
    {
m_gPLSQLKeys->until_key();
    }

    void PLSQLParser::timeout_key()
    {
m_gPLSQLKeys->timeout_key();
    }

    void PLSQLParser::multiset_key()
    {
m_gPLSQLKeys->multiset_key();
    }

    void PLSQLParser::dense_rank_key()
    {
m_gPLSQLKeys->dense_rank_key();
    }

    void PLSQLParser::exit_key()
    {
m_gPLSQLKeys->exit_key();
    }

    void PLSQLParser::single_key()
    {
m_gPLSQLKeys->single_key();
    }

    void PLSQLParser::binary_float_min_subnormal_key()
    {
m_gPLSQLKeys->binary_float_min_subnormal_key();
    }

    void PLSQLParser::batch_key()
    {
m_gPLSQLKeys->batch_key();
    }

    void PLSQLParser::trailing_key()
    {
m_gPLSQLKeys->trailing_key();
    }

    void PLSQLParser::chr_key()
    {
m_gPLSQLKeys->chr_key();
    }

    void PLSQLParser::main_model_name()
    {
m_gPLSQLCommons->main_model_name();
    }

    void PLSQLParser::alias_quoted_string()
    {
m_gPLSQLCommons->alias_quoted_string();
    }

    void PLSQLParser::mod_key()
    {
m_gPLSQLKeys->mod_key();
    }

    void PLSQLParser::unknown_key()
    {
m_gPLSQLKeys->unknown_key();
    }

    void PLSQLParser::join_using_part()
    {
m_gPLSQL_DMLParser->join_using_part();
    }

    void PLSQLParser::logoff_key()
    {
m_gPLSQLKeys->logoff_key();
    }

    void PLSQLParser::percent_rowcount_key()
    {
m_gPLSQLKeys->percent_rowcount_key();
    }

    void PLSQLParser::only_key()
    {
m_gPLSQLKeys->only_key();
    }

    void PLSQLParser::tableview_name()
    {
m_gPLSQLCommons->tableview_name();
    }

    void PLSQLParser::date_key()
    {
m_gPLSQLKeys->date_key();
    }

    void PLSQLParser::element_key()
    {
m_gPLSQLKeys->element_key();
    }

    void PLSQLParser::truncate_key()
    {
m_gPLSQLKeys->truncate_key();
    }

    void PLSQLParser::quantified_expression()
    {
m_gPLSQL_DMLParser->quantified_expression();
    }

    void PLSQLParser::xmlelement_key()
    {
m_gPLSQLKeys->xmlelement_key();
    }

    void PLSQLParser::respect_key()
    {
m_gPLSQLKeys->respect_key();
    }

    void PLSQLParser::model_clause()
    {
m_gPLSQL_DMLParser->model_clause();
    }

    void PLSQLParser::model_rules_clause()
    {
m_gPLSQL_DMLParser->model_rules_clause();
    }

    void PLSQLParser::by_key()
    {
m_gPLSQLKeys->by_key();
    }

    void PLSQLParser::rollback_key()
    {
m_gPLSQLKeys->rollback_key();
    }

    void PLSQLParser::search_key()
    {
m_gPLSQLKeys->search_key();
    }

    void PLSQLParser::pivot_for_clause()
    {
m_gPLSQL_DMLParser->pivot_for_clause();
    }

    void PLSQLParser::following_key()
    {
m_gPLSQLKeys->following_key();
    }

    void PLSQLParser::context_key()
    {
m_gPLSQLKeys->context_key();
    }

    void PLSQLParser::entityescaping_key()
    {
m_gPLSQLKeys->entityescaping_key();
    }

    void PLSQLParser::lock_table_element()
    {
m_gPLSQL_DMLParser->lock_table_element();
    }

    void PLSQLParser::compound_expression()
    {
m_gPLSQL_DMLParser->compound_expression();
    }

    void PLSQLParser::positive_key()
    {
m_gPLSQLKeys->positive_key();
    }

    void PLSQLParser::interval_expression()
    {
m_gPLSQL_DMLParser->interval_expression();
    }

    void PLSQLParser::noschemacheck_key()
    {
m_gPLSQLKeys->noschemacheck_key();
    }

    void PLSQLParser::unbounded_key()
    {
m_gPLSQLKeys->unbounded_key();
    }

    void PLSQLParser::bind_variable()
    {
m_gPLSQLCommons->bind_variable();
    }

    void PLSQLParser::minvalue_key()
    {
m_gPLSQLKeys->minvalue_key();
    }

    void PLSQLParser::octet_length_key()
    {
m_gPLSQLKeys->octet_length_key();
    }

    void PLSQLParser::zone_key()
    {
m_gPLSQLKeys->zone_key();
    }

    void PLSQLParser::cycle_clause()
    {
m_gPLSQL_DMLParser->cycle_clause();
    }

    void PLSQLParser::current_time_key()
    {
m_gPLSQLKeys->current_time_key();
    }

    void PLSQLParser::return_rows_clause()
    {
m_gPLSQL_DMLParser->return_rows_clause();
    }

    void PLSQLParser::keep_clause()
    {
m_gPLSQLCommons->keep_clause();
    }

    void PLSQLParser::hide_key()
    {
m_gPLSQLKeys->hide_key();
    }

    void PLSQLParser::char_key()
    {
m_gPLSQLKeys->char_key();
    }

    void PLSQLParser::parent_key()
    {
m_gPLSQLKeys->parent_key();
    }

    void PLSQLParser::external_key()
    {
m_gPLSQLKeys->external_key();
    }

    void PLSQLParser::hash_key()
    {
m_gPLSQLKeys->hash_key();
    }

    void PLSQLParser::timestamp_ltz_unconstrained_key()
    {
m_gPLSQLKeys->timestamp_ltz_unconstrained_key();
    }

    void PLSQLParser::data_key()
    {
m_gPLSQLKeys->data_key();
    }

    void PLSQLParser::merge_insert_clause()
    {
m_gPLSQL_DMLParser->merge_insert_clause();
    }

    void PLSQLParser::document_key()
    {
m_gPLSQLKeys->document_key();
    }

    void PLSQLParser::simple_case_when_part()
    {
m_gPLSQL_DMLParser->simple_case_when_part();
    }

    void PLSQLParser::current_of_clause()
    {
m_gPLSQLCommons->current_of_clause();
    }

    void PLSQLParser::exit_command()
    {
m_gSQLPLUSParser->exit_command();
    }

    void PLSQLParser::start_part()
    {
m_gPLSQL_DMLParser->start_part();
    }

    void PLSQLParser::nocopy_key()
    {
m_gPLSQLKeys->nocopy_key();
    }

    void PLSQLParser::compile_key()
    {
m_gPLSQLKeys->compile_key();
    }

    void PLSQLParser::parameter_name()
    {
m_gPLSQLCommons->parameter_name();
    }

    void PLSQLParser::follows_key()
    {
m_gPLSQLKeys->follows_key();
    }

    void PLSQLParser::values_key()
    {
m_gPLSQLKeys->values_key();
    }

    void PLSQLParser::cast_key()
    {
m_gPLSQLKeys->cast_key();
    }

    void PLSQLParser::sign_key()
    {
m_gPLSQLKeys->sign_key();
    }

    void PLSQLParser::cache_key()
    {
m_gPLSQLKeys->cache_key();
    }

    void PLSQLParser::double_key()
    {
m_gPLSQLKeys->double_key();
    }

    void PLSQLParser::precision_key()
    {
m_gPLSQLKeys->precision_key();
    }

    void PLSQLParser::year_key()
    {
m_gPLSQLKeys->year_key();
    }

    void PLSQLParser::a_key()
    {
m_gPLSQLKeys->a_key();
    }

    void PLSQLParser::rowid_key()
    {
m_gPLSQLKeys->rowid_key();
    }

    void PLSQLParser::decode_key()
    {
m_gPLSQLKeys->decode_key();
    }

    void PLSQLParser::package_key()
    {
m_gPLSQLKeys->package_key();
    }

    void PLSQLParser::nvl_key()
    {
m_gPLSQLKeys->nvl_key();
    }

    void PLSQLParser::off_key()
    {
m_gPLSQLKeys->off_key();
    }

    void PLSQLParser::not_key()
    {
m_gPLSQLKeys->not_key();
    }

    void PLSQLParser::servererror_key()
    {
m_gPLSQLKeys->servererror_key();
    }

    void PLSQLParser::deferred_key()
    {
m_gPLSQLKeys->deferred_key();
    }

    void PLSQLParser::model_rules_element()
    {
m_gPLSQL_DMLParser->model_rules_element();
    }

    void PLSQLParser::procedure_key()
    {
m_gPLSQLKeys->procedure_key();
    }

    void PLSQLParser::delete_statement()
    {
m_gPLSQL_DMLParser->delete_statement();
    }

    void PLSQLParser::path_key()
    {
m_gPLSQLKeys->path_key();
    }

    void PLSQLParser::merge_key()
    {
m_gPLSQLKeys->merge_key();
    }

    void PLSQLParser::sessiontimezone_key()
    {
m_gPLSQLKeys->sessiontimezone_key();
    }

    void PLSQLParser::single_column_for_loop()
    {
m_gPLSQL_DMLParser->single_column_for_loop();
    }

    void PLSQLParser::last_value_key()
    {
m_gPLSQLKeys->last_value_key();
    }

    void PLSQLParser::commit_key()
    {
m_gPLSQLKeys->commit_key();
    }

    void PLSQLParser::parameters_key()
    {
m_gPLSQLKeys->parameters_key();
    }

    void PLSQLParser::snapshot_key()
    {
m_gPLSQLKeys->snapshot_key();
    }

    void PLSQLParser::join_on_part()
    {
m_gPLSQL_DMLParser->join_on_part();
    }

    void PLSQLParser::indicator_key()
    {
m_gPLSQLKeys->indicator_key();
    }

    void PLSQLParser::infinite_key()
    {
m_gPLSQLKeys->infinite_key();
    }

    void PLSQLParser::main_model()
    {
m_gPLSQL_DMLParser->main_model();
    }

    void PLSQLParser::signtype_key()
    {
m_gPLSQLKeys->signtype_key();
    }

    void PLSQLParser::compound_key()
    {
m_gPLSQLKeys->compound_key();
    }

    void PLSQLParser::initcap_key()
    {
m_gPLSQLKeys->initcap_key();
    }

    void PLSQLParser::order_by_clause()
    {
m_gPLSQL_DMLParser->order_by_clause();
    }

    void PLSQLParser::index_name()
    {
m_gPLSQLCommons->index_name();
    }

    void PLSQLParser::yes_key()
    {
m_gPLSQLKeys->yes_key();
    }

    void PLSQLParser::rename_key()
    {
m_gPLSQLKeys->rename_key();
    }

    void PLSQLParser::subpartition_key()
    {
m_gPLSQLKeys->subpartition_key();
    }

    void PLSQLParser::multiset_comparsion()
    {
m_gPLSQL_DMLParser->multiset_comparsion();
    }

    void PLSQLParser::rollup_cube_clause()
    {
m_gPLSQL_DMLParser->rollup_cube_clause();
    }

    void PLSQLParser::nocache_key()
    {
m_gPLSQLKeys->nocache_key();
    }

    void PLSQLParser::error_logging_clause()
    {
m_gPLSQL_DMLParser->error_logging_clause();
    }

    void PLSQLParser::member_key()
    {
m_gPLSQLKeys->member_key();
    }

    void PLSQLParser::pragma_key()
    {
m_gPLSQLKeys->pragma_key();
    }

    void PLSQLParser::reference_model()
    {
m_gPLSQL_DMLParser->reference_model();
    }

    void PLSQLParser::declare_key()
    {
m_gPLSQLKeys->declare_key();
    }

    void PLSQLParser::xml_table_column()
    {
m_gPLSQL_DMLParser->xml_table_column();
    }

    void PLSQLParser::native_datatype_element()
    {
m_gPLSQLCommons->native_datatype_element();
    }

    void PLSQLParser::xmlcolattval_key()
    {
m_gPLSQLKeys->xmlcolattval_key();
    }

    void PLSQLParser::sets_key()
    {
m_gPLSQLKeys->sets_key();
    }

    void PLSQLParser::quoted_string()
    {
m_gPLSQLCommons->quoted_string();
    }

    void PLSQLParser::update_set_clause()
    {
m_gPLSQL_DMLParser->update_set_clause();
    }

    void PLSQLParser::query_partition_clause()
    {
m_gPLSQL_DMLParser->query_partition_clause();
    }

    void PLSQLParser::type_key()
    {
m_gPLSQLKeys->type_key();
    }

    void PLSQLParser::like2_key()
    {
m_gPLSQLKeys->like2_key();
    }

    void PLSQLParser::cell_assignment()
    {
m_gPLSQL_DMLParser->cell_assignment();
    }

    void PLSQLParser::link_key()
    {
m_gPLSQLKeys->link_key();
    }

    void PLSQLParser::outer_join_type()
    {
m_gPLSQL_DMLParser->outer_join_type();
    }

    void PLSQLParser::comment_key()
    {
m_gPLSQLKeys->comment_key();
    }

    void PLSQLParser::set_key()
    {
m_gPLSQLKeys->set_key();
    }

    void PLSQLParser::dimension_key()
    {
m_gPLSQLKeys->dimension_key();
    }

    void PLSQLParser::static_key()
    {
m_gPLSQLKeys->static_key();
    }

    void PLSQLParser::nulls_key()
    {
m_gPLSQLKeys->nulls_key();
    }

    void PLSQLParser::serially_reusable_key()
    {
m_gPLSQLKeys->serially_reusable_key();
    }

    void PLSQLParser::under_key()
    {
m_gPLSQLKeys->under_key();
    }

    void PLSQLParser::noentityescaping_key()
    {
m_gPLSQLKeys->noentityescaping_key();
    }

    void PLSQLParser::argument()
    {
m_gPLSQLCommons->argument();
    }

    void PLSQLParser::reference_key()
    {
m_gPLSQLKeys->reference_key();
    }

    void PLSQLParser::until_part()
    {
m_gPLSQL_DMLParser->until_part();
    }

    void PLSQLParser::constraints_key()
    {
m_gPLSQLKeys->constraints_key();
    }

    void PLSQLParser::version_key()
    {
m_gPLSQLKeys->version_key();
    }

    void PLSQLParser::dec_key()
    {
m_gPLSQLKeys->dec_key();
    }

    void PLSQLParser::within_key()
    {
m_gPLSQLKeys->within_key();
    }

    void PLSQLParser::query_block()
    {
m_gPLSQL_DMLParser->query_block();
    }

    void PLSQLParser::link_name()
    {
m_gPLSQLCommons->link_name();
    }

    void PLSQLParser::instead_key()
    {
m_gPLSQLKeys->instead_key();
    }

    void PLSQLParser::function_argument_analytic()
    {
m_gPLSQLCommons->function_argument_analytic();
    }

    void PLSQLParser::rowidtochar_key()
    {
m_gPLSQLKeys->rowidtochar_key();
    }

    void PLSQLParser::order_key()
    {
m_gPLSQLKeys->order_key();
    }

    void PLSQLParser::decrement_key()
    {
m_gPLSQLKeys->decrement_key();
    }

    void PLSQLParser::function_key()
    {
m_gPLSQLKeys->function_key();
    }

    void PLSQLParser::function_argument_modeling()
    {
m_gPLSQLCommons->function_argument_modeling();
    }

    void PLSQLParser::seed_key()
    {
m_gPLSQLKeys->seed_key();
    }

    void PLSQLParser::current_key()
    {
m_gPLSQLKeys->current_key();
    }

    void PLSQLParser::auto_key()
    {
m_gPLSQLKeys->auto_key();
    }

    void PLSQLParser::error_logging_reject_part()
    {
m_gPLSQL_DMLParser->error_logging_reject_part();
    }

    void PLSQLParser::wellformed_key()
    {
m_gPLSQLKeys->wellformed_key();
    }

    void PLSQLParser::model_rules_part()
    {
m_gPLSQL_DMLParser->model_rules_part();
    }

    void PLSQLParser::coalesce_key()
    {
m_gPLSQLKeys->coalesce_key();
    }

    void PLSQLParser::unpivot_in_clause()
    {
m_gPLSQL_DMLParser->unpivot_in_clause();
    }

    void PLSQLParser::plan_key()
    {
m_gPLSQLKeys->plan_key();
    }

    void PLSQLParser::skip_key()
    {
m_gPLSQLKeys->skip_key();
    }

    void PLSQLParser::submultiset_key()
    {
m_gPLSQLKeys->submultiset_key();
    }

    void PLSQLParser::update_statement()
    {
m_gPLSQL_DMLParser->update_statement();
    }

    void PLSQLParser::identified_key()
    {
m_gPLSQLKeys->identified_key();
    }

    void PLSQLParser::execute_key()
    {
m_gPLSQLKeys->execute_key();
    }

    void PLSQLParser::startup_key()
    {
m_gPLSQLKeys->startup_key();
    }

    void PLSQLParser::reuse_key()
    {
m_gPLSQLKeys->reuse_key();
    }

    void PLSQLParser::automatic_key()
    {
m_gPLSQLKeys->automatic_key();
    }

    void PLSQLParser::xml_multiuse_expression_element()
    {
m_gPLSQL_DMLParser->xml_multiuse_expression_element();
    }

    void PLSQLParser::object_key()
    {
m_gPLSQLKeys->object_key();
    }

    void PLSQLParser::constant_key()
    {
m_gPLSQLKeys->constant_key();
    }

    void PLSQLParser::including_key()
    {
m_gPLSQLKeys->including_key();
    }

    void PLSQLParser::cost_class_name()
    {
m_gPLSQLCommons->cost_class_name();
    }

    void PLSQLParser::for_update_clause()
    {
m_gPLSQL_DMLParser->for_update_clause();
    }

    void PLSQLParser::having_clause()
    {
m_gPLSQL_DMLParser->having_clause();
    }

    void PLSQLParser::datatype()
    {
m_gPLSQLCommons->datatype();
    }

    void PLSQLParser::elsif_key()
    {
m_gPLSQLKeys->elsif_key();
    }

    void PLSQLParser::grouping_sets_elements()
    {
m_gPLSQL_DMLParser->grouping_sets_elements();
    }

    void PLSQLParser::nowait_key()
    {
m_gPLSQLKeys->nowait_key();
    }

    void PLSQLParser::from_key()
    {
m_gPLSQLKeys->from_key();
    }

    void PLSQLParser::model_column()
    {
m_gPLSQL_DMLParser->model_column();
    }

    void PLSQLParser::definer_key()
    {
m_gPLSQLKeys->definer_key();
    }

    void PLSQLParser::integer_key()
    {
m_gPLSQLKeys->integer_key();
    }

    void PLSQLParser::power_key()
    {
m_gPLSQLKeys->power_key();
    }

    void PLSQLParser::revoke_key()
    {
m_gPLSQLKeys->revoke_key();
    }

    void PLSQLParser::reference_model_name()
    {
m_gPLSQLCommons->reference_model_name();
    }

    void PLSQLParser::binary_float_max_normal_key()
    {
m_gPLSQLKeys->binary_float_max_normal_key();
    }

    void PLSQLParser::sequence_key()
    {
m_gPLSQLKeys->sequence_key();
    }

    void PLSQLParser::multi_table_insert()
    {
m_gPLSQL_DMLParser->multi_table_insert();
    }

    void PLSQLParser::additive_expression()
    {
m_gPLSQL_DMLParser->additive_expression();
    }

    void PLSQLParser::schema_key()
    {
m_gPLSQLKeys->schema_key();
    }

    void PLSQLParser::result_key()
    {
m_gPLSQLKeys->result_key();
    }

    void PLSQLParser::binary_double_nan_key()
    {
m_gPLSQLKeys->binary_double_nan_key();
    }

    void PLSQLParser::include_key()
    {
m_gPLSQLKeys->include_key();
    }

    void PLSQLParser::exclude_key()
    {
m_gPLSQLKeys->exclude_key();
    }

    void PLSQLParser::nocycle_key()
    {
m_gPLSQLKeys->nocycle_key();
    }

    void PLSQLParser::full_key()
    {
m_gPLSQLKeys->full_key();
    }

    void PLSQLParser::none_key()
    {
m_gPLSQLKeys->none_key();
    }

    void PLSQLParser::session_key()
    {
m_gPLSQLKeys->session_key();
    }

    void PLSQLParser::implementation_type_name()
    {
m_gPLSQLCommons->implementation_type_name();
    }

    void PLSQLParser::trim_key()
    {
m_gPLSQLKeys->trim_key();
    }

    void PLSQLParser::subquery_factoring_clause()
    {
m_gPLSQL_DMLParser->subquery_factoring_clause();
    }

    void PLSQLParser::nan_key()
    {
m_gPLSQLKeys->nan_key();
    }

    void PLSQLParser::nchar_key()
    {
m_gPLSQLKeys->nchar_key();
    }

    void PLSQLParser::warning_key()
    {
m_gPLSQLKeys->warning_key();
    }

    void PLSQLParser::content_key()
    {
m_gPLSQLKeys->content_key();
    }

    void PLSQLParser::lpad_key()
    {
m_gPLSQLKeys->lpad_key();
    }

    void PLSQLParser::convert_key()
    {
m_gPLSQLKeys->convert_key();
    }

    void PLSQLParser::xml_general_default_part()
    {
m_gPLSQL_DMLParser->xml_general_default_part();
    }

    void PLSQLParser::column_name()
    {
m_gPLSQLCommons->column_name();
    }

    void PLSQLParser::else_key()
    {
m_gPLSQLKeys->else_key();
    }

    void PLSQLParser::suspend_key()
    {
m_gPLSQLKeys->suspend_key();
    }

    void PLSQLParser::statement_id_key()
    {
m_gPLSQLKeys->statement_id_key();
    }

    void PLSQLParser::raise_key()
    {
m_gPLSQLKeys->raise_key();
    }

    void PLSQLParser::translate_key()
    {
m_gPLSQLKeys->translate_key();
    }

    void PLSQLParser::asc_key()
    {
m_gPLSQLKeys->asc_key();
    }

    void PLSQLParser::exception_name()
    {
m_gPLSQLCommons->exception_name();
    }

    void PLSQLParser::use_key()
    {
m_gPLSQLKeys->use_key();
    }

    void PLSQLParser::enable_key()
    {
m_gPLSQLKeys->enable_key();
    }

    void PLSQLParser::where_clause()
    {
m_gPLSQLCommons->where_clause();
    }

    void PLSQLParser::multiset_type()
    {
m_gPLSQL_DMLParser->multiset_type();
    }

    void PLSQLParser::binary_double_max_subnormal_key()
    {
m_gPLSQLKeys->binary_double_max_subnormal_key();
    }

    void PLSQLParser::select_list_elements()
    {
m_gPLSQL_DMLParser->select_list_elements();
    }

    void PLSQLParser::concatenation_op()
    {
m_gPLSQLCommons->concatenation_op();
    }

    void PLSQLParser::like_key()
    {
m_gPLSQLKeys->like_key();
    }

    void PLSQLParser::language_key()
    {
m_gPLSQLKeys->language_key();
    }

    void PLSQLParser::exceptions_key()
    {
m_gPLSQLKeys->exceptions_key();
    }

    void PLSQLParser::group_by_clause()
    {
m_gPLSQL_DMLParser->group_by_clause();
    }

    void PLSQLParser::substitutable_key()
    {
m_gPLSQLKeys->substitutable_key();
    }

    void PLSQLParser::hour_key()
    {
m_gPLSQLKeys->hour_key();
    }

    void PLSQLParser::avg_key()
    {
m_gPLSQLKeys->avg_key();
    }

    void PLSQLParser::system_key()
    {
m_gPLSQLKeys->system_key();
    }

    void PLSQLParser::like4_key()
    {
m_gPLSQLKeys->like4_key();
    }

    void PLSQLParser::canonical_key()
    {
m_gPLSQLKeys->canonical_key();
    }

    void PLSQLParser::in_elements()
    {
m_gPLSQL_DMLParser->in_elements();
    }

    void PLSQLParser::insert_statement()
    {
m_gPLSQL_DMLParser->insert_statement();
    }

    void PLSQLParser::within_or_over_part()
    {
m_gPLSQL_DMLParser->within_or_over_part();
    }

    void PLSQLParser::continue_key()
    {
m_gPLSQLKeys->continue_key();
    }

    void PLSQLParser::dml_table_expression_clause()
    {
m_gPLSQL_DMLParser->dml_table_expression_clause();
    }

    void PLSQLParser::boolean_key()
    {
m_gPLSQLKeys->boolean_key();
    }

    void PLSQLParser::drop_key()
    {
m_gPLSQLKeys->drop_key();
    }

    void PLSQLParser::outer_key()
    {
m_gPLSQLKeys->outer_key();
    }

    void PLSQLParser::any_key()
    {
m_gPLSQLKeys->any_key();
    }

    void PLSQLParser::start_key()
    {
m_gPLSQLKeys->start_key();
    }

    void PLSQLParser::concatenation()
    {
m_gPLSQL_DMLParser->concatenation();
    }

    void PLSQLParser::precision_part()
    {
m_gPLSQLCommons->precision_part();
    }

    void PLSQLParser::check_key()
    {
m_gPLSQLKeys->check_key();
    }

    void PLSQLParser::savepoint_key()
    {
m_gPLSQLKeys->savepoint_key();
    }

    void PLSQLParser::number_key()
    {
m_gPLSQLKeys->number_key();
    }

    void PLSQLParser::to_number_key()
    {
m_gPLSQLKeys->to_number_key();
    }

    void PLSQLParser::library_key()
    {
m_gPLSQLKeys->library_key();
    }

    void PLSQLParser::equality_expression()
    {
m_gPLSQL_DMLParser->equality_expression();
    }

    void PLSQLParser::name_key()
    {
m_gPLSQLKeys->name_key();
    }

    void PLSQLParser::goto_key()
    {
m_gPLSQLKeys->goto_key();
    }

    void PLSQLParser::collate_key()
    {
m_gPLSQLKeys->collate_key();
    }

    void PLSQLParser::false_key()
    {
m_gPLSQLKeys->false_key();
    }

    void PLSQLParser::system_user_key()
    {
m_gPLSQLKeys->system_user_key();
    }

    void PLSQLParser::greatest_key()
    {
m_gPLSQLKeys->greatest_key();
    }

    void PLSQLParser::sql_plus_command()
    {
m_gSQLPLUSParser->sql_plus_command();
    }

    void PLSQLParser::partition_extension_clause()
    {
m_gPLSQLCommons->partition_extension_clause();
    }

    void PLSQLParser::xml_namespaces_clause()
    {
m_gPLSQL_DMLParser->xml_namespaces_clause();
    }

    void PLSQLParser::while_key()
    {
m_gPLSQLKeys->while_key();
    }

    void PLSQLParser::local_key()
    {
m_gPLSQLKeys->local_key();
    }

    void PLSQLParser::read_key()
    {
m_gPLSQLKeys->read_key();
    }

    void PLSQLParser::order_by_elements()
    {
m_gPLSQL_DMLParser->order_by_elements();
    }

    void PLSQLParser::disassociate_key()
    {
m_gPLSQLKeys->disassociate_key();
    }

    void PLSQLParser::cascade_key()
    {
m_gPLSQLKeys->cascade_key();
    }

    void PLSQLParser::at_key()
    {
m_gPLSQLKeys->at_key();
    }

    void PLSQLParser::expression_list()
    {
m_gPLSQL_DMLParser->expression_list();
    }

    void PLSQLParser::except_key()
    {
m_gPLSQLKeys->except_key();
    }

    void PLSQLParser::xmltable_key()
    {
m_gPLSQLKeys->xmltable_key();
    }

    void PLSQLParser::using_clause()
    {
m_gPLSQL_DMLParser->using_clause();
    }

    void PLSQLParser::likec_key()
    {
m_gPLSQLKeys->likec_key();
    }

    void PLSQLParser::constructor_key()
    {
m_gPLSQLKeys->constructor_key();
    }

    void PLSQLParser::model_column_partition_part()
    {
m_gPLSQL_DMLParser->model_column_partition_part();
    }

    void PLSQLParser::timestamp_unconstrained_key()
    {
m_gPLSQLKeys->timestamp_unconstrained_key();
    }

    void PLSQLParser::wait_key()
    {
m_gPLSQLKeys->wait_key();
    }

    void PLSQLParser::indices_key()
    {
m_gPLSQLKeys->indices_key();
    }

    void PLSQLParser::lock_key()
    {
m_gPLSQLKeys->lock_key();
    }

    void PLSQLParser::second_key()
    {
m_gPLSQLKeys->second_key();
    }

    void PLSQLParser::map_key()
    {
m_gPLSQLKeys->map_key();
    }

    void PLSQLParser::expression_or_vector()
    {
m_gPLSQL_DMLParser->expression_or_vector();
    }

    void PLSQLParser::ceil_key()
    {
m_gPLSQLKeys->ceil_key();
    }

    void PLSQLParser::pivot_key()
    {
m_gPLSQLKeys->pivot_key();
    }

    void PLSQLParser::inout_key()
    {
m_gPLSQLKeys->inout_key();
    }

    void PLSQLParser::subtype_key()
    {
m_gPLSQLKeys->subtype_key();
    }

    void PLSQLParser::table_ref()
    {
m_gPLSQL_DMLParser->table_ref();
    }

    void PLSQLParser::preceding_key()
    {
m_gPLSQLKeys->preceding_key();
    }

    void PLSQLParser::maxvalue_key()
    {
m_gPLSQLKeys->maxvalue_key();
    }

    void PLSQLParser::expression_wrapper()
    {
m_gPLSQL_DMLParser->expression_wrapper();
    }

    void PLSQLParser::after_key()
    {
m_gPLSQLKeys->after_key();
    }

    void PLSQLParser::nested_key()
    {
m_gPLSQLKeys->nested_key();
    }

    void PLSQLParser::merge_element()
    {
m_gPLSQL_DMLParser->merge_element();
    }

    void PLSQLParser::having_key()
    {
m_gPLSQLKeys->having_key();
    }

    void PLSQLParser::autonomous_transaction_key()
    {
m_gPLSQLKeys->autonomous_transaction_key();
    }

    void PLSQLParser::dsinterval_unconstrained_key()
    {
m_gPLSQLKeys->dsinterval_unconstrained_key();
    }

    void PLSQLParser::model_key()
    {
m_gPLSQLKeys->model_key();
    }

    void PLSQLParser::seed_part()
    {
m_gPLSQL_DMLParser->seed_part();
    }

    void PLSQLParser::option_key()
    {
m_gPLSQLKeys->option_key();
    }

    void PLSQLParser::char_cs_key()
    {
m_gPLSQLKeys->char_cs_key();
    }

    void PLSQLParser::subquery_restriction_clause()
    {
m_gPLSQL_DMLParser->subquery_restriction_clause();
    }

    void PLSQLParser::merge_statement()
    {
m_gPLSQL_DMLParser->merge_statement();
    }

    void PLSQLParser::selected_element()
    {
m_gPLSQL_DMLParser->selected_element();
    }

    void PLSQLParser::like_type()
    {
m_gPLSQL_DMLParser->like_type();
    }

    void PLSQLParser::subquery_operation_part()
    {
m_gPLSQL_DMLParser->subquery_operation_part();
    }

    void PLSQLParser::less_than_or_equals_op()
    {
m_gPLSQLCommons->less_than_or_equals_op();
    }

    void PLSQLParser::replace_key()
    {
m_gPLSQLKeys->replace_key();
    }

    void PLSQLParser::attribute_name()
    {
m_gPLSQLCommons->attribute_name();
    }

    void PLSQLParser::when_key()
    {
m_gPLSQLKeys->when_key();
    }

    void PLSQLParser::both_key()
    {
m_gPLSQLKeys->both_key();
    }

    void PLSQLParser::pivot_clause()
    {
m_gPLSQL_DMLParser->pivot_clause();
    }

    void PLSQLParser::rollback_segment_name()
    {
m_gPLSQLCommons->rollback_segment_name();
    }

    void PLSQLParser::customdatum_key()
    {
m_gPLSQLKeys->customdatum_key();
    }

    void PLSQLParser::corrupt_xid_key()
    {
m_gPLSQLKeys->corrupt_xid_key();
    }

    void PLSQLParser::label_name()
    {
m_gPLSQLCommons->label_name();
    }

    void PLSQLParser::java_key()
    {
m_gPLSQLKeys->java_key();
    }

    void PLSQLParser::case_else_part()
    {
m_gPLSQL_DMLParser->case_else_part();
    }

    void PLSQLParser::soundex_key()
    {
m_gPLSQLKeys->soundex_key();
    }

    void PLSQLParser::xmlroot_param_standalone_part()
    {
m_gPLSQL_DMLParser->xmlroot_param_standalone_part();
    }

    void PLSQLParser::simple_integer_key()
    {
m_gPLSQLKeys->simple_integer_key();
    }

    void PLSQLParser::unpivot_clause()
    {
m_gPLSQL_DMLParser->unpivot_clause();
    }

    void PLSQLParser::extend_key()
    {
m_gPLSQLKeys->extend_key();
    }

    void PLSQLParser::with_key()
    {
m_gPLSQLKeys->with_key();
    }

    void PLSQLParser::xmlquery_key()
    {
m_gPLSQLKeys->xmlquery_key();
    }

    void PLSQLParser::select_key()
    {
m_gPLSQLKeys->select_key();
    }

    void PLSQLParser::join_key()
    {
m_gPLSQLKeys->join_key();
    }

    void PLSQLParser::pivot_in_clause_element()
    {
m_gPLSQL_DMLParser->pivot_in_clause_element();
    }

    void PLSQLParser::ltrim_key()
    {
m_gPLSQLKeys->ltrim_key();
    }

    void PLSQLParser::alter_key()
    {
m_gPLSQLKeys->alter_key();
    }

    void PLSQLParser::xmlexists_key()
    {
m_gPLSQLKeys->xmlexists_key();
    }

    void PLSQLParser::constraint_key()
    {
m_gPLSQLKeys->constraint_key();
    }

    void PLSQLParser::associate_key()
    {
m_gPLSQLKeys->associate_key();
    }

    void PLSQLParser::simple_case_statement()
    {
m_gPLSQL_DMLParser->simple_case_statement();
    }

    void PLSQLParser::binary_float_infinity_key()
    {
m_gPLSQLKeys->binary_float_infinity_key();
    }

    void PLSQLParser::write_key()
    {
m_gPLSQLKeys->write_key();
    }

    void PLSQLParser::save_key()
    {
m_gPLSQLKeys->save_key();
    }

    void PLSQLParser::model_column_list()
    {
m_gPLSQL_DMLParser->model_column_list();
    }

    void PLSQLParser::out_key()
    {
m_gPLSQLKeys->out_key();
    }

    void PLSQLParser::cost_key()
    {
m_gPLSQLKeys->cost_key();
    }

    void PLSQLParser::overriding_key()
    {
m_gPLSQLKeys->overriding_key();
    }

    void PLSQLParser::conditional_insert_when_part()
    {
m_gPLSQL_DMLParser->conditional_insert_when_part();
    }

    void PLSQLParser::transaction_key()
    {
m_gPLSQLKeys->transaction_key();
    }

    void PLSQLParser::positiven_key()
    {
m_gPLSQLKeys->positiven_key();
    }

    void PLSQLParser::mlslabel_key()
    {
m_gPLSQLKeys->mlslabel_key();
    }

    void PLSQLParser::rawtohex_key()
    {
m_gPLSQLKeys->rawtohex_key();
    }

    void PLSQLParser::lock_table_statement()
    {
m_gPLSQL_DMLParser->lock_table_statement();
    }

    void PLSQLParser::statement_key()
    {
m_gPLSQLKeys->statement_key();
    }

    void PLSQLParser::uid_key()
    {
m_gPLSQLKeys->uid_key();
    }

    void PLSQLParser::substring_key()
    {
m_gPLSQLKeys->substring_key();
    }

    void PLSQLParser::xml_column_name()
    {
m_gPLSQLCommons->xml_column_name();
    }

    void PLSQLParser::union_key()
    {
m_gPLSQLKeys->union_key();
    }

    void PLSQLParser::factoring_element()
    {
m_gPLSQL_DMLParser->factoring_element();
    }

    void PLSQLParser::id()
    {
m_gPLSQLCommons->id();
    }

    void PLSQLParser::cluster_key()
    {
m_gPLSQLKeys->cluster_key();
    }

    void PLSQLParser::binary_double_min_normal_key()
    {
m_gPLSQLKeys->binary_double_min_normal_key();
    }

    void PLSQLParser::new_key()
    {
m_gPLSQLKeys->new_key();
    }

    void PLSQLParser::sqldata_key()
    {
m_gPLSQLKeys->sqldata_key();
    }

    void PLSQLParser::dml_key()
    {
m_gPLSQLKeys->dml_key();
    }

    void PLSQLParser::case_key()
    {
m_gPLSQLKeys->case_key();
    }

    void PLSQLParser::xmlroot_param_version_part()
    {
m_gPLSQL_DMLParser->xmlroot_param_version_part();
    }

    void PLSQLParser::parallel_enable_key()
    {
m_gPLSQLKeys->parallel_enable_key();
    }

    void PLSQLParser::schema_name()
    {
m_gPLSQLCommons->schema_name();
    }

    void PLSQLParser::corrupt_xid_all_key()
    {
m_gPLSQLKeys->corrupt_xid_all_key();
    }

    void PLSQLParser::exception_key()
    {
m_gPLSQLKeys->exception_key();
    }

    void PLSQLParser::exists_key()
    {
m_gPLSQLKeys->exists_key();
    }

    void PLSQLParser::type_spec()
    {
m_gPLSQLCommons->type_spec();
    }

    void PLSQLParser::to_char_key()
    {
m_gPLSQLKeys->to_char_key();
    }

    void PLSQLParser::for_update_options()
    {
m_gPLSQL_DMLParser->for_update_options();
    }

    void PLSQLParser::limit_key()
    {
m_gPLSQLKeys->limit_key();
    }

    void PLSQLParser::in_key()
    {
m_gPLSQLKeys->in_key();
    }

    void PLSQLParser::immediate_key()
    {
m_gPLSQLKeys->immediate_key();
    }

    void PLSQLParser::advise_key()
    {
m_gPLSQLKeys->advise_key();
    }

    void PLSQLParser::varchar2_key()
    {
m_gPLSQLKeys->varchar2_key();
    }

    void PLSQLParser::yminterval_unconstrained_key()
    {
m_gPLSQLKeys->yminterval_unconstrained_key();
    }

    void PLSQLParser::int_key()
    {
m_gPLSQLKeys->int_key();
    }

    void PLSQLParser::least_key()
    {
m_gPLSQLKeys->least_key();
    }

    void PLSQLParser::columns_key()
    {
m_gPLSQLKeys->columns_key();
    }

    void PLSQLParser::query_key()
    {
m_gPLSQLKeys->query_key();
    }

    void PLSQLParser::range_key()
    {
m_gPLSQLKeys->range_key();
    }

    void PLSQLParser::sum_key()
    {
m_gPLSQLKeys->sum_key();
    }

    void PLSQLParser::clob_key()
    {
m_gPLSQLKeys->clob_key();
    }

    void PLSQLParser::breadth_key()
    {
m_gPLSQLKeys->breadth_key();
    }

    void PLSQLParser::character_length_key()
    {
m_gPLSQLKeys->character_length_key();
    }

    void PLSQLParser::negated_expression()
    {
m_gPLSQL_DMLParser->negated_expression();
    }

    void PLSQLParser::xmlserialize_param_version_part()
    {
m_gPLSQL_DMLParser->xmlserialize_param_version_part();
    }

    void PLSQLParser::nothing_key()
    {
m_gPLSQLKeys->nothing_key();
    }

    void PLSQLParser::natural_key()
    {
m_gPLSQLKeys->natural_key();
    }

    void PLSQLParser::indent_key()
    {
m_gPLSQLKeys->indent_key();
    }

    void PLSQLParser::merge_update_delete_part()
    {
m_gPLSQL_DMLParser->merge_update_delete_part();
    }

    void PLSQLParser::cross_key()
    {
m_gPLSQLKeys->cross_key();
    }

    void PLSQLParser::nclob_key()
    {
m_gPLSQLKeys->nclob_key();
    }

    void PLSQLParser::evalname_key()
    {
m_gPLSQLKeys->evalname_key();
    }

    void PLSQLParser::xmlnamespaces_key()
    {
m_gPLSQLKeys->xmlnamespaces_key();
    }

    void PLSQLParser::xmlforest_key()
    {
m_gPLSQLKeys->xmlforest_key();
    }

    void PLSQLParser::standard_function()
    {
m_gPLSQL_DMLParser->standard_function();
    }

    void PLSQLParser::multiset_expression()
    {
m_gPLSQL_DMLParser->multiset_expression();
    }

    void PLSQLParser::numeric_key()
    {
m_gPLSQLKeys->numeric_key();
    }

    void PLSQLParser::present_key()
    {
m_gPLSQLKeys->present_key();
    }

    void PLSQLParser::inner_key()
    {
m_gPLSQLKeys->inner_key();
    }

    void PLSQLParser::set_command()
    {
m_gSQLPLUSParser->set_command();
    }

    void PLSQLParser::pls_integer_key()
    {
m_gPLSQLKeys->pls_integer_key();
    }

    void PLSQLParser::self_key()
    {
m_gPLSQLKeys->self_key();
    }

    void PLSQLParser::windowing_type()
    {
m_gPLSQL_DMLParser->windowing_type();
    }

    void PLSQLParser::for_increment_decrement_type()
    {
m_gPLSQL_DMLParser->for_increment_decrement_type();
    }

    void PLSQLParser::begin_key()
    {
m_gPLSQLKeys->begin_key();
    }

    void PLSQLParser::searched_case_statement()
    {
m_gPLSQL_DMLParser->searched_case_statement();
    }

    void PLSQLParser::left_key()
    {
m_gPLSQLKeys->left_key();
    }

    void PLSQLParser::whenever_key()
    {
m_gPLSQLKeys->whenever_key();
    }

    void PLSQLParser::record_key()
    {
m_gPLSQLKeys->record_key();
    }

    void PLSQLParser::mode_key()
    {
m_gPLSQLKeys->mode_key();
    }

    void PLSQLParser::all_key()
    {
m_gPLSQLKeys->all_key();
    }

    void PLSQLParser::selected_tableview()
    {
m_gPLSQL_DMLParser->selected_tableview();
    }

    void PLSQLParser::varchar_key()
    {
m_gPLSQLKeys->varchar_key();
    }

    void PLSQLParser::table_var_name()
    {
m_gPLSQLCommons->table_var_name();
    }

    void PLSQLParser::upper_key()
    {
m_gPLSQLKeys->upper_key();
    }

    void PLSQLParser::between_key()
    {
m_gPLSQLKeys->between_key();
    }

    void PLSQLParser::current_user_key()
    {
m_gPLSQLKeys->current_user_key();
    }

    void PLSQLParser::timezone_minute_key()
    {
m_gPLSQLKeys->timezone_minute_key();
    }

    void PLSQLParser::month_key()
    {
m_gPLSQLKeys->month_key();
    }

    void PLSQLParser::update_key()
    {
m_gPLSQLKeys->update_key();
    }

    void PLSQLParser::oradata_key()
    {
m_gPLSQLKeys->oradata_key();
    }

    void PLSQLParser::extract_key()
    {
m_gPLSQLKeys->extract_key();
    }

    void PLSQLParser::or_key()
    {
m_gPLSQLKeys->or_key();
    }

    void PLSQLParser::lower_key()
    {
m_gPLSQLKeys->lower_key();
    }

    void PLSQLParser::referencing_key()
    {
m_gPLSQLKeys->referencing_key();
    }

    void PLSQLParser::of_key()
    {
m_gPLSQLKeys->of_key();
    }

    void PLSQLParser::over_clause()
    {
m_gPLSQL_DMLParser->over_clause();
    }

    void PLSQLParser::defaults_key()
    {
m_gPLSQLKeys->defaults_key();
    }

    void PLSQLParser::ref_key()
    {
m_gPLSQLKeys->ref_key();
    }

    void PLSQLParser::value_key()
    {
m_gPLSQLKeys->value_key();
    }

    void PLSQLParser::percent_found_key()
    {
m_gPLSQLKeys->percent_found_key();
    }

    void PLSQLParser::binary_float_nan_key()
    {
m_gPLSQLKeys->binary_float_nan_key();
    }

    void PLSQLParser::return_key()
    {
m_gPLSQLKeys->return_key();
    }

    void PLSQLParser::into_clause()
    {
m_gPLSQLCommons->into_clause();
    }

    void PLSQLParser::aggregate_key()
    {
m_gPLSQLKeys->aggregate_key();
    }

    void PLSQLParser::nav_key()
    {
m_gPLSQLKeys->nav_key();
    }

    void PLSQLParser::table_alias()
    {
m_gPLSQLCommons->table_alias();
    }

    void PLSQLParser::exception_init_key()
    {
m_gPLSQLKeys->exception_init_key();
    }

    void PLSQLParser::over_key()
    {
m_gPLSQLKeys->over_key();
    }

    void PLSQLParser::timestamp_key()
    {
m_gPLSQLKeys->timestamp_key();
    }

    void PLSQLParser::sysdate_key()
    {
m_gPLSQLKeys->sysdate_key();
    }

    void PLSQLParser::timezone_abbr_key()
    {
m_gPLSQLKeys->timezone_abbr_key();
    }

    void PLSQLParser::inline_key()
    {
m_gPLSQLKeys->inline_key();
    }

    void PLSQLParser::scn_key()
    {
m_gPLSQLKeys->scn_key();
    }

    void PLSQLParser::varray_key()
    {
m_gPLSQLKeys->varray_key();
    }

    void PLSQLParser::measures_key()
    {
m_gPLSQLKeys->measures_key();
    }

    void PLSQLParser::respect_or_ignore_nulls()
    {
m_gPLSQLCommons->respect_or_ignore_nulls();
    }

    void PLSQLParser::instantiable_key()
    {
m_gPLSQLKeys->instantiable_key();
    }

    void PLSQLParser::level_key()
    {
m_gPLSQLKeys->level_key();
    }

    void PLSQLParser::result_cache_key()
    {
m_gPLSQLKeys->result_cache_key();
    }

    void PLSQLParser::nullif_key()
    {
m_gPLSQLKeys->nullif_key();
    }

    void PLSQLParser::variable_key()
    {
m_gPLSQLKeys->variable_key();
    }

    void PLSQLParser::reverse_key()
    {
m_gPLSQLKeys->reverse_key();
    }

    void PLSQLParser::null_key()
    {
m_gPLSQLKeys->null_key();
    }

    void PLSQLParser::round_key()
    {
m_gPLSQLKeys->round_key();
    }

    void PLSQLParser::unpivot_key()
    {
m_gPLSQLKeys->unpivot_key();
    }

    void PLSQLParser::c_key()
    {
m_gPLSQLKeys->c_key();
    }

    void PLSQLParser::grant_key()
    {
m_gPLSQLKeys->grant_key();
    }

    void PLSQLParser::delete_key()
    {
m_gPLSQLKeys->delete_key();
    }

    void PLSQLParser::agent_key()
    {
m_gPLSQLKeys->agent_key();
    }

    void PLSQLParser::xmlserialize_param_enconding_part()
    {
m_gPLSQL_DMLParser->xmlserialize_param_enconding_part();
    }

    void PLSQLParser::collection_name()
    {
m_gPLSQLCommons->collection_name();
    }

    void PLSQLParser::locked_key()
    {
m_gPLSQLKeys->locked_key();
    }

    void PLSQLParser::vsize_key()
    {
m_gPLSQLKeys->vsize_key();
    }

    void PLSQLParser::stantard_function_enabling_using()
    {
m_gPLSQL_DMLParser->stantard_function_enabling_using();
    }

    void PLSQLParser::current_timestamp_key()
    {
m_gPLSQLKeys->current_timestamp_key();
    }

    void PLSQLParser::binary_float_min_normal_key()
    {
m_gPLSQLKeys->binary_float_min_normal_key();
    }

    void PLSQLParser::constant()
    {
m_gPLSQLCommons->constant();
    }

    void PLSQLParser::subquery_basic_elements()
    {
m_gPLSQL_DMLParser->subquery_basic_elements();
    }

    void PLSQLParser::for_key()
    {
m_gPLSQLKeys->for_key();
    }

    void PLSQLParser::standalone_key()
    {
m_gPLSQLKeys->standalone_key();
    }

    void PLSQLParser::role_key()
    {
m_gPLSQLKeys->role_key();
    }

    void PLSQLParser::real_key()
    {
m_gPLSQLKeys->real_key();
    }

    void PLSQLParser::each_key()
    {
m_gPLSQLKeys->each_key();
    }

    void PLSQLParser::multi_table_element()
    {
m_gPLSQL_DMLParser->multi_table_element();
    }

    void PLSQLParser::record_name()
    {
m_gPLSQLCommons->record_name();
    }

    void PLSQLParser::percent_isopen_key()
    {
m_gPLSQLKeys->percent_isopen_key();
    }

    void PLSQLParser::logon_key()
    {
m_gPLSQLKeys->logon_key();
    }

    void PLSQLParser::lock_mode()
    {
m_gPLSQL_DMLParser->lock_mode();
    }

    void PLSQLParser::failure_key()
    {
m_gPLSQLKeys->failure_key();
    }

    void PLSQLParser::segment_key()
    {
m_gPLSQLKeys->segment_key();
    }

    void PLSQLParser::flashback_query_clause()
    {
m_gPLSQL_DMLParser->flashback_query_clause();
    }

    void PLSQLParser::leading_key()
    {
m_gPLSQLKeys->leading_key();
    }

    void PLSQLParser::old_key()
    {
m_gPLSQLKeys->old_key();
    }

    void PLSQLParser::model_column_clauses()
    {
m_gPLSQL_DMLParser->model_column_clauses();
    }

    void PLSQLParser::bit_length_key()
    {
m_gPLSQLKeys->bit_length_key();
    }

    void PLSQLParser::ordinality_key()
    {
m_gPLSQLKeys->ordinality_key();
    }

    void PLSQLParser::cycle_key()
    {
m_gPLSQLKeys->cycle_key();
    }

    void PLSQLParser::general_element()
    {
m_gPLSQLCommons->general_element();
    }

    void PLSQLParser::concatenation_wrapper()
    {
m_gPLSQL_DMLParser->concatenation_wrapper();
    }

    void PLSQLParser::general_element_part()
    {
m_gPLSQLCommons->general_element_part();
    }

    void PLSQLParser::xmlparse_key()
    {
m_gPLSQLKeys->xmlparse_key();
    }

    void PLSQLParser::procedure_name()
    {
m_gPLSQLCommons->procedure_name();
    }

    void PLSQLParser::upsert_key()
    {
m_gPLSQLKeys->upsert_key();
    }

    void PLSQLParser::minus_key()
    {
m_gPLSQLKeys->minus_key();
    }

    void PLSQLParser::byte_key()
    {
m_gPLSQLKeys->byte_key();
    }

    void PLSQLParser::serializable_key()
    {
m_gPLSQLKeys->serializable_key();
    }

    void PLSQLParser::unique_key()
    {
m_gPLSQLKeys->unique_key();
    }

    void PLSQLParser::column_alias()
    {
m_gPLSQLCommons->column_alias();
    }

    void PLSQLParser::savepoint_name()
    {
m_gPLSQLCommons->savepoint_name();
    }

    void PLSQLParser::binary_double_infinity_key()
    {
m_gPLSQLKeys->binary_double_infinity_key();
    }

    void PLSQLParser::loop_key()
    {
m_gPLSQLKeys->loop_key();
    }

    void PLSQLParser::nomaxvalue_key()
    {
m_gPLSQLKeys->nomaxvalue_key();
    }

    void PLSQLParser::xml_attributes_clause()
    {
m_gPLSQL_DMLParser->xml_attributes_clause();
    }

    void PLSQLParser::xmlserialize_param_ident_part()
    {
m_gPLSQL_DMLParser->xmlserialize_param_ident_part();
    }

    void PLSQLParser::timestamp_tz_unconstrained_key()
    {
m_gPLSQLKeys->timestamp_tz_unconstrained_key();
    }

    void PLSQLParser::unary_expression()
    {
m_gPLSQL_DMLParser->unary_expression();
    }

    void PLSQLParser::greater_than_or_equals_op()
    {
m_gPLSQLCommons->greater_than_or_equals_op();
    }

    void PLSQLParser::match_key()
    {
m_gPLSQLKeys->match_key();
    }

    void PLSQLParser::binary_integer_key()
    {
m_gPLSQLKeys->binary_integer_key();
    }

    void PLSQLParser::end_key()
    {
m_gPLSQLKeys->end_key();
    }

    void PLSQLParser::xml_key()
    {
m_gPLSQLKeys->xml_key();
    }

    void PLSQLParser::dump_key()
    {
m_gPLSQLKeys->dump_key();
    }

    void PLSQLParser::aggregate_function_name()
    {
m_gPLSQLCommons->aggregate_function_name();
    }

    void PLSQLParser::vector_expr()
    {
m_gPLSQL_DMLParser->vector_expr();
    }

    void PLSQLParser::timezone_hour_key()
    {
m_gPLSQLKeys->timezone_hour_key();
    }

    void PLSQLParser::corresponding_key()
    {
m_gPLSQLKeys->corresponding_key();
    }

    void PLSQLParser::into_key()
    {
m_gPLSQLKeys->into_key();
    }

    void PLSQLParser::userenv_key()
    {
m_gPLSQLKeys->userenv_key();
    }

    void PLSQLParser::as_key()
    {
m_gPLSQLKeys->as_key();
    }

    void PLSQLParser::id_expression()
    {
m_gPLSQLCommons->id_expression();
    }

    void PLSQLParser::variance_key()
    {
m_gPLSQLKeys->variance_key();
    }

    void PLSQLParser::default_key()
    {
m_gPLSQLKeys->default_key();
    }

    void PLSQLParser::binary_double_min_subnormal_key()
    {
m_gPLSQLKeys->binary_double_min_subnormal_key();
    }

    void PLSQLParser::noaudit_key()
    {
m_gPLSQLKeys->noaudit_key();
    }

    void PLSQLParser::disable_key()
    {
m_gPLSQLKeys->disable_key();
    }

    void PLSQLParser::is_key()
    {
m_gPLSQLKeys->is_key();
    }

    void PLSQLParser::single_table_insert()
    {
m_gPLSQL_DMLParser->single_table_insert();
    }

    void PLSQLParser::analyze_key()
    {
m_gPLSQLKeys->analyze_key();
    }

    void PLSQLParser::function_name()
    {
m_gPLSQLCommons->function_name();
    }

    void PLSQLParser::connect_by_root_key()
    {
m_gPLSQLKeys->connect_by_root_key();
    }

    void PLSQLParser::pivot_in_clause_elements()
    {
m_gPLSQL_DMLParser->pivot_in_clause_elements();
    }

    void PLSQLParser::unlimited_key()
    {
m_gPLSQLKeys->unlimited_key();
    }

    void PLSQLParser::body_key()
    {
m_gPLSQLKeys->body_key();
    }

    void PLSQLParser::ascii_key()
    {
m_gPLSQLKeys->ascii_key();
    }

    void PLSQLParser::dbtimezone_key()
    {
m_gPLSQLKeys->dbtimezone_key();
    }

    void PLSQLParser::guard_key()
    {
m_gPLSQLKeys->guard_key();
    }

    void PLSQLParser::partial_key()
    {
m_gPLSQLKeys->partial_key();
    }

    void PLSQLParser::nvarchar2_key()
    {
m_gPLSQLKeys->nvarchar2_key();
    }

    void PLSQLParser::sample_clause()
    {
m_gPLSQL_DMLParser->sample_clause();
    }

    void PLSQLParser::relies_on_key()
    {
m_gPLSQLKeys->relies_on_key();
    }

    void PLSQLParser::iterate_key()
    {
m_gPLSQLKeys->iterate_key();
    }

    void PLSQLParser::current_date_key()
    {
m_gPLSQLKeys->current_date_key();
    }

    void PLSQLParser::settings_key()
    {
m_gPLSQLKeys->settings_key();
    }

    void PLSQLParser::percent_rowtype_key()
    {
m_gPLSQLKeys->percent_rowtype_key();
    }

    void PLSQLParser::pipelined_key()
    {
m_gPLSQLKeys->pipelined_key();
    }

    void PLSQLParser::error_logging_into_part()
    {
m_gPLSQL_DMLParser->error_logging_into_part();
    }

    void PLSQLParser::conditional_insert_else_part()
    {
m_gPLSQL_DMLParser->conditional_insert_else_part();
    }

    void PLSQLParser::rtrim_key()
    {
m_gPLSQLKeys->rtrim_key();
    }

    void PLSQLParser::sequence_name()
    {
m_gPLSQLCommons->sequence_name();
    }

    void PLSQLParser::max_key()
    {
m_gPLSQLKeys->max_key();
    }

    void PLSQLParser::bit_key()
    {
m_gPLSQLKeys->bit_key();
    }

    void PLSQLParser::on_key()
    {
m_gPLSQLKeys->on_key();
    }

    void PLSQLParser::row_key()
    {
m_gPLSQLKeys->row_key();
    }

    void PLSQLParser::string_key()
    {
m_gPLSQLKeys->string_key();
    }

    void PLSQLParser::attribute_key()
    {
m_gPLSQLKeys->attribute_key();
    }

    void PLSQLParser::module_key()
    {
m_gPLSQLKeys->module_key();
    }

    void PLSQLParser::specification_key()
    {
m_gPLSQLKeys->specification_key();
    }

    void PLSQLParser::hextoraw_key()
    {
m_gPLSQLKeys->hextoraw_key();
    }

    void PLSQLParser::session_user_key()
    {
m_gPLSQLKeys->session_user_key();
    }

    void PLSQLParser::length_key()
    {
m_gPLSQLKeys->length_key();
    }

    void PLSQLParser::trunc_key()
    {
m_gPLSQLKeys->trunc_key();
    }

    void PLSQLParser::some_key()
    {
m_gPLSQLKeys->some_key();
    }

    void PLSQLParser::database_key()
    {
m_gPLSQLKeys->database_key();
    }

    void PLSQLParser::serveroutput_key()
    {
m_gPLSQLKeys->serveroutput_key();
    }

    void PLSQLParser::cursor_name()
    {
m_gPLSQLCommons->cursor_name();
    }

    void PLSQLParser::column_based_update_set_clause()
    {
m_gPLSQL_DMLParser->column_based_update_set_clause();
    }

    void PLSQLParser::sqlerror_key()
    {
m_gPLSQLKeys->sqlerror_key();
    }

    void PLSQLParser::model_expression_element()
    {
m_gPLSQL_DMLParser->model_expression_element();
    }

    void PLSQLParser::whenever_command()
    {
m_gSQLPLUSParser->whenever_command();
    }

    void PLSQLParser::condition()
    {
m_gPLSQL_DMLParser->condition();
    }

    void PLSQLParser::windowing_elements()
    {
m_gPLSQL_DMLParser->windowing_elements();
    }

    void PLSQLParser::stantard_function_pedictions()
    {
m_gPLSQL_DMLParser->stantard_function_pedictions();
    }

    void PLSQLParser::global_key()
    {
m_gPLSQLKeys->global_key();
    }

    void PLSQLParser::cursor_expression()
    {
m_gPLSQL_DMLParser->cursor_expression();
    }

    void PLSQLParser::empty_key()
    {
m_gPLSQLKeys->empty_key();
    }

    void PLSQLParser::no_key()
    {
m_gPLSQLKeys->no_key();
    }

    void PLSQLParser::prompt_command()
    {
m_gSQLPLUSParser->prompt_command();
    }

    void PLSQLParser::compatibility_key()
    {
m_gPLSQLKeys->compatibility_key();
    }

    void PLSQLParser::first_value_key()
    {
m_gPLSQLKeys->first_value_key();
    }

    void PLSQLParser::rules_key()
    {
m_gPLSQLKeys->rules_key();
    }

    void PLSQLParser::modify_key()
    {
m_gPLSQLKeys->modify_key();
    }

    void PLSQLParser::schemacheck_key()
    {
m_gPLSQLKeys->schemacheck_key();
    }

    void PLSQLParser::passing_key()
    {
m_gPLSQLKeys->passing_key();
    }

    void PLSQLParser::timezone_region_key()
    {
m_gPLSQLKeys->timezone_region_key();
    }

    void PLSQLParser::model_iterate_clause()
    {
m_gPLSQL_DMLParser->model_iterate_clause();
    }

    void PLSQLParser::forall_key()
    {
m_gPLSQLKeys->forall_key();
    }

    void PLSQLParser::increment_key()
    {
m_gPLSQLKeys->increment_key();
    }

    void PLSQLParser::position_key()
    {
m_gPLSQLKeys->position_key();
    }

    void PLSQLParser::grouping_sets_clause()
    {
m_gPLSQL_DMLParser->grouping_sets_clause();
    }

    void PLSQLParser::index_key()
    {
m_gPLSQLKeys->index_key();
    }

    void PLSQLParser::audit_key()
    {
m_gPLSQLKeys->audit_key();
    }

    void PLSQLParser::static_returning_clause()
    {
m_gPLSQL_DMLParser->static_returning_clause();
    }

    void PLSQLParser::call_key()
    {
m_gPLSQLKeys->call_key();
    }

    void PLSQLParser::exclusive_key()
    {
m_gPLSQLKeys->exclusive_key();
    }

    void PLSQLParser::from_clause()
    {
m_gPLSQL_DMLParser->from_clause();
    }

    void PLSQLParser::collect_key()
    {
m_gPLSQLKeys->collect_key();
    }

    void PLSQLParser::ddl_key()
    {
m_gPLSQLKeys->ddl_key();
    }

    void PLSQLParser::xmlagg_key()
    {
m_gPLSQLKeys->xmlagg_key();
    }

    void PLSQLParser::siblings_key()
    {
m_gPLSQLKeys->siblings_key();
    }

    void PLSQLParser::instr_key()
    {
m_gPLSQLKeys->instr_key();
    }

    void PLSQLParser::outer_join_sign()
    {
m_gPLSQLCommons->outer_join_sign();
    }

    void PLSQLParser::user_key()
    {
m_gPLSQLKeys->user_key();
    }

    void PLSQLParser::rollup_key()
    {
m_gPLSQLKeys->rollup_key();
    }

    void PLSQLParser::xmlattributes_key()
    {
m_gPLSQLKeys->xmlattributes_key();
    }

    void PLSQLParser::multiply_expression()
    {
m_gPLSQL_DMLParser->multiply_expression();
    }

    void PLSQLParser::table_ref_aux()
    {
m_gPLSQL_DMLParser->table_ref_aux();
    }

    void PLSQLParser::and_key()
    {
m_gPLSQLKeys->and_key();
    }

    void PLSQLParser::subquery()
    {
m_gPLSQL_DMLParser->subquery();
    }

    void PLSQLParser::numeric()
    {
m_gPLSQLCommons->numeric();
    }

    void PLSQLParser::relational_expression()
    {
m_gPLSQL_DMLParser->relational_expression();
    }

    void PLSQLParser::returning_key()
    {
m_gPLSQLKeys->returning_key();
    }

    void PLSQLParser::hierarchical_query_clause()
    {
m_gPLSQL_DMLParser->hierarchical_query_clause();
    }

    void PLSQLParser::raw_key()
    {
m_gPLSQLKeys->raw_key();
    }

    void PLSQLParser::decimal_key()
    {
m_gPLSQLKeys->decimal_key();
    }

    void PLSQLParser::true_key()
    {
m_gPLSQLKeys->true_key();
    }

    void PLSQLParser::indexed_key()
    {
m_gPLSQLKeys->indexed_key();
    }

    void PLSQLParser::national_key()
    {
m_gPLSQLKeys->national_key();
    }

    void PLSQLParser::constraint_name()
    {
m_gPLSQLCommons->constraint_name();
    }

    void PLSQLParser::case_statement(int isStatementParameter)
    {
m_gPLSQL_DMLParser->case_statement(isStatementParameter);
    }

    void PLSQLParser::float_key()
    {
m_gPLSQLKeys->float_key();
    }

    void PLSQLParser::table_ref_list()
    {
m_gPLSQL_DMLParser->table_ref_list();
    }

    void PLSQLParser::not_equal_op()
    {
m_gPLSQLCommons->not_equal_op();
    }

    void PLSQLParser::windowing_clause()
    {
m_gPLSQL_DMLParser->windowing_clause();
    }

    void PLSQLParser::naturaln_key()
    {
m_gPLSQLKeys->naturaln_key();
    }

    void PLSQLParser::explain_key()
    {
m_gPLSQLKeys->explain_key();
    }

    void PLSQLParser::rows_key()
    {
m_gPLSQLKeys->rows_key();
    }

    void PLSQLParser::nchar_cs_key()
    {
m_gPLSQLKeys->nchar_cs_key();
    }

    void PLSQLParser::force_key()
    {
m_gPLSQLKeys->force_key();
    }

    void PLSQLParser::abs_key()
    {
m_gPLSQLKeys->abs_key();
    }

    void PLSQLParser::noorder_key()
    {
m_gPLSQLKeys->noorder_key();
    }

    void PLSQLParser::wait_nowait_part()
    {
m_gPLSQL_DMLParser->wait_nowait_part();
    }

    void PLSQLParser::bfile_key()
    {
m_gPLSQLKeys->bfile_key();
    }

    void PLSQLParser::day_key()
    {
m_gPLSQLKeys->day_key();
    }

    void PLSQLParser::cursor_key()
    {
m_gPLSQLKeys->cursor_key();
    }

    void PLSQLParser::between_elements()
    {
m_gPLSQL_DMLParser->between_elements();
    }

    void PLSQLParser::parallel_key()
    {
m_gPLSQLKeys->parallel_key();
    }

    void PLSQLParser::for_like_part()
    {
m_gPLSQL_DMLParser->for_like_part();
    }

    void PLSQLParser::db_role_change_key()
    {
m_gPLSQLKeys->db_role_change_key();
    }

    void PLSQLParser::nextval_key()
    {
m_gPLSQLKeys->nextval_key();
    }

    void PLSQLParser::then_key()
    {
m_gPLSQLKeys->then_key();
    }

    void PLSQLParser::character_key()
    {
m_gPLSQLKeys->character_key();
    }

    void PLSQLParser::substr_key()
    {
m_gPLSQLKeys->substr_key();
    }

    void PLSQLParser::stddev_key()
    {
m_gPLSQLKeys->stddev_key();
    }

    void PLSQLParser::group_key()
    {
m_gPLSQLKeys->group_key();
    }

    void PLSQLParser::rpad_key()
    {
m_gPLSQLKeys->rpad_key();
    }

    void PLSQLParser::using_element()
    {
m_gPLSQL_DMLParser->using_element();
    }

    void PLSQLParser::query_name()
    {
m_gPLSQLCommons->query_name();
    }

    void PLSQLParser::xmlserialize_key()
    {
m_gPLSQLKeys->xmlserialize_key();
    }

    void PLSQLParser::multiset_op()
    {
m_gPLSQLCommons->multiset_op();
    }

    void PLSQLParser::condition_wrapper()
    {
m_gPLSQL_DMLParser->condition_wrapper();
    }

    void PLSQLParser::binary_double_max_normal_key()
    {
m_gPLSQLKeys->binary_double_max_normal_key();
    }

    void PLSQLParser::create_key()
    {
m_gPLSQLKeys->create_key();
    }

    void PLSQLParser::stantard_function_enabling_within_or_over()
    {
m_gPLSQL_DMLParser->stantard_function_enabling_within_or_over();
    }

    void PLSQLParser::concat_key()
    {
m_gPLSQLKeys->concat_key();
    }

    void PLSQLParser::smallint_key()
    {
m_gPLSQLKeys->smallint_key();
    }

    void PLSQLParser::for_update_of_part()
    {
m_gPLSQL_DMLParser->for_update_of_part();
    }

    void PLSQLParser::grouping_key()
    {
m_gPLSQLKeys->grouping_key();
    }

    void PLSQLParser::logical_and_expression()
    {
m_gPLSQL_DMLParser->logical_and_expression();
    }

    void PLSQLParser::conditional_insert_clause()
    {
m_gPLSQL_DMLParser->conditional_insert_clause();
    }

    void PLSQLParser::resumable_key()
    {
m_gPLSQLKeys->resumable_key();
    }

    void PLSQLParser::trigger_name()
    {
m_gPLSQLCommons->trigger_name();
    }

    void PLSQLParser::binary_float_key()
    {
m_gPLSQLKeys->binary_float_key();
    }

    void PLSQLParser::xmlcast_key()
    {
m_gPLSQLKeys->xmlcast_key();
    }

    void PLSQLParser::close_key()
    {
m_gPLSQLKeys->close_key();
    }

    void PLSQLParser::search_clause()
    {
m_gPLSQL_DMLParser->search_clause();
    }

    void PLSQLParser::keep_key()
    {
m_gPLSQLKeys->keep_key();
    }

    void PLSQLParser::using_key()
    {
m_gPLSQLKeys->using_key();
    }

    void PLSQLParser::interval_key()
    {
m_gPLSQLKeys->interval_key();
    }

    void PLSQLParser::block_key()
    {
m_gPLSQLKeys->block_key();
    }

    void PLSQLParser::searched_case_when_part()
    {
m_gPLSQL_DMLParser->searched_case_when_part();
    }

    void PLSQLParser::xmlpi_key()
    {
m_gPLSQLKeys->xmlpi_key();
    }

    void PLSQLParser::last_key()
    {
m_gPLSQLKeys->last_key();
    }

    void PLSQLParser::unpivot_in_elements()
    {
m_gPLSQL_DMLParser->unpivot_in_elements();
    }

    void PLSQLParser::log_key()
    {
m_gPLSQLKeys->log_key();
    }

    void PLSQLParser::array_key()
    {
m_gPLSQLKeys->array_key();
    }

    void PLSQLParser::matched_key()
    {
m_gPLSQLKeys->matched_key();
    }

    void PLSQLParser::table_element()
    {
m_gPLSQLCommons->table_element();
    }

    void PLSQLParser::right_key()
    {
m_gPLSQLKeys->right_key();
    }

    void PLSQLParser::versions_key()
    {
m_gPLSQLKeys->versions_key();
    }

    void PLSQLParser::decompose_key()
    {
m_gPLSQLKeys->decompose_key();
    }

    void PLSQLParser::encoding_key()
    {
m_gPLSQLKeys->encoding_key();
    }

    void PLSQLParser::success_key()
    {
m_gPLSQLKeys->success_key();
    }

    void PLSQLParser::binary_double_key()
    {
m_gPLSQLKeys->binary_double_key();
    }

    void PLSQLParser::isolation_key()
    {
m_gPLSQLKeys->isolation_key();
    }

    void PLSQLParser::insert_into_clause()
    {
m_gPLSQL_DMLParser->insert_into_clause();
    }

    void PLSQLParser::general_table_ref()
    {
m_gPLSQL_DMLParser->general_table_ref();
    }

    void PLSQLParser::before_key()
    {
m_gPLSQLKeys->before_key();
    }

    void PLSQLParser::debug_key()
    {
m_gPLSQLKeys->debug_key();
    }

    void PLSQLParser::open_key()
    {
m_gPLSQLKeys->open_key();
    }

    void PLSQLParser::bulk_key()
    {
m_gPLSQLKeys->bulk_key();
    }

    void PLSQLParser::first_key()
    {
m_gPLSQLKeys->first_key();
    }

    void PLSQLParser::expression()
    {
m_gPLSQL_DMLParser->expression();
    }

    void PLSQLParser::cell_reference_options()
    {
m_gPLSQL_DMLParser->cell_reference_options();
    }

    void PLSQLParser::nominvalue_key()
    {
m_gPLSQLKeys->nominvalue_key();
    }

    void PLSQLParser::atom()
    {
m_gPLSQL_DMLParser->atom();
    }

    void PLSQLParser::binary_float_max_subnormal_key()
    {
m_gPLSQLKeys->binary_float_max_subnormal_key();
    }

    void PLSQLParser::urowid_key()
    {
m_gPLSQLKeys->urowid_key();
    }

    void PLSQLParser::like_escape_part()
    {
m_gPLSQL_DMLParser->like_escape_part();
    }

    void PLSQLParser::function_argument()
    {
m_gPLSQLCommons->function_argument();
    }

/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred9_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred9_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred31_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred31_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred17_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred17_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred59_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred59_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred19_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred19_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred52_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred52_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred65_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred65_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred43_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred43_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred44_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred44_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred22_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred22_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred12_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred12_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred5_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred5_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred60_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred60_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred11_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred11_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred35_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred35_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred2_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred2_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred6_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred6_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred34_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred34_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred56_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred56_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred29_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred29_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred36_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred36_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred3_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred3_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred37_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred37_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred50_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred50_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred33_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred33_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred58_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred58_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred41_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred41_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred23_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred23_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred13_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred13_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred40_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred40_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred62_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred62_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred18_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred18_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred15_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred15_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred14_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred14_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred47_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred47_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred30_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred30_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred16_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred16_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred66_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred66_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred39_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred39_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred7_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred7_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred10_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred10_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred32_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred32_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred8_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred8_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred1_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred1_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred51_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred51_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred20_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred20_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred26_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred26_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred61_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred61_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred24_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred24_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred48_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred48_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred27_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred27_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred55_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred55_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred42_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred42_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred4_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred4_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser::msynpred( antlr3::ClassForwarder< synpred49_PLSQLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred49_PLSQLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

}

/* End of code
 * =============================================================================
 */
