/** \file
 *  This C++ source file was generated by $ANTLR version 3.5.2-SNAPSHOT
 *
 *     -  From the grammar source file : PLSQLKeys.g
 *     -                            On : 2013-10-07 21:32:07
 *     -                for the parser : PLSQLParser_PLSQLKeysParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "PLSQLParser_PLSQLKeys.hpp"
// Include delegator definition header files
//
#include "PLSQLParser.hpp" 

/* ----------------------------------------- */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "LICENSE");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

namespace 
         User
 {
using namespace antlr3;

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "PLSQLKeys.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* PLSQLParser_PLSQLKeys::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new PLSQLParser_PLSQLKeys parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PLSQLParser_PLSQLKeys::PLSQLParser_PLSQLKeys( StreamType* instream, PLSQLParser* gPLSQLParser)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream, gPLSQLParser);
}

/** \brief Create a new PLSQLParser_PLSQLKeys parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PLSQLParser_PLSQLKeys::PLSQLParser_PLSQLKeys( StreamType* instream, RecognizerSharedStateType* state, PLSQLParser* gPLSQLParser)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream , gPLSQLParser);
}

void PLSQLParser_PLSQLKeys::init(StreamType* instream, PLSQLParser* gPLSQLParser)
{
     	// Install the pointers back to lexers that will delegate us to perform certain functions
     	// for them.
     	//
     		m_gPLSQLParser = gPLSQLParser;
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( PLSQLParserTokenNames );


}

void
PLSQLParser_PLSQLKeys::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
PLSQLParser_PLSQLKeys::~PLSQLParser_PLSQLKeys()
 {
}

/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return PLSQLParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_CREATE_in_create_key48_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_CREATE_in_create_key48( FOLLOW_SQL92_RESERVED_CREATE_in_create_key48_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_replace_key78_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_replace_key78( FOLLOW_REGULAR_ID_in_replace_key78_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_package_key101_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_package_key101( FOLLOW_REGULAR_ID_in_package_key101_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_body_key123_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_body_key123( FOLLOW_REGULAR_ID_in_body_key123_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_BEGIN_in_begin_key143_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_BEGIN_in_begin_key143( FOLLOW_SQL92_RESERVED_BEGIN_in_begin_key143_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_exit_key165_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_exit_key165( FOLLOW_REGULAR_ID_in_exit_key165_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DECLARE_in_declare_key185_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DECLARE_in_declare_key185( FOLLOW_SQL92_RESERVED_DECLARE_in_declare_key185_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_EXCEPTION_in_exception_key205_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_EXCEPTION_in_exception_key205( FOLLOW_SQL92_RESERVED_EXCEPTION_in_exception_key205_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_serveroutput_key227_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_serveroutput_key227( FOLLOW_REGULAR_ID_in_serveroutput_key227_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_off_key249_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_off_key249( FOLLOW_REGULAR_ID_in_off_key249_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_constant_key271_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_constant_key271( FOLLOW_REGULAR_ID_in_constant_key271_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_subtype_key293_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_subtype_key293( FOLLOW_REGULAR_ID_in_subtype_key293_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_CURSOR_in_cursor_key313_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_CURSOR_in_cursor_key313( FOLLOW_SQL92_RESERVED_CURSOR_in_cursor_key313_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nextval_key336_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nextval_key336( FOLLOW_REGULAR_ID_in_nextval_key336_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_GOTO_in_goto_key356_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_GOTO_in_goto_key356( FOLLOW_SQL92_RESERVED_GOTO_in_goto_key356_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_execute_key378_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_execute_key378( FOLLOW_REGULAR_ID_in_execute_key378_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_immediate_key401_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_immediate_key401( FOLLOW_REGULAR_ID_in_immediate_key401_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_return_key423_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_return_key423( FOLLOW_REGULAR_ID_in_return_key423_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_PROCEDURE_in_procedure_key443_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_PROCEDURE_in_procedure_key443( FOLLOW_SQL92_RESERVED_PROCEDURE_in_procedure_key443_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_function_key466_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_function_key466( FOLLOW_REGULAR_ID_in_function_key466_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_pragma_key488_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_pragma_key488( FOLLOW_REGULAR_ID_in_pragma_key488_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_exception_init_key510_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_exception_init_key510( FOLLOW_REGULAR_ID_in_exception_init_key510_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_type_key533_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_type_key533( FOLLOW_REGULAR_ID_in_type_key533_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_record_key556_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_record_key556( FOLLOW_REGULAR_ID_in_record_key556_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_indexed_key578_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_indexed_key578( FOLLOW_REGULAR_ID_in_indexed_key578_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_INDEX_in_index_key598_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_INDEX_in_index_key598( FOLLOW_PLSQL_RESERVED_INDEX_in_index_key598_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PERCENT_in_percent_notfound_key621_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PERCENT_in_percent_notfound_key621( FOLLOW_PERCENT_in_percent_notfound_key621_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_percent_notfound_key623_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_percent_notfound_key623( FOLLOW_REGULAR_ID_in_percent_notfound_key623_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PERCENT_in_percent_found_key646_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PERCENT_in_percent_found_key646( FOLLOW_PERCENT_in_percent_found_key646_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_percent_found_key648_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_percent_found_key648( FOLLOW_REGULAR_ID_in_percent_found_key648_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PERCENT_in_percent_isopen_key671_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PERCENT_in_percent_isopen_key671( FOLLOW_PERCENT_in_percent_isopen_key671_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_percent_isopen_key673_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_percent_isopen_key673( FOLLOW_REGULAR_ID_in_percent_isopen_key673_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PERCENT_in_percent_rowcount_key696_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PERCENT_in_percent_rowcount_key696( FOLLOW_PERCENT_in_percent_rowcount_key696_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_percent_rowcount_key698_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_percent_rowcount_key698( FOLLOW_REGULAR_ID_in_percent_rowcount_key698_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PERCENT_in_percent_rowtype_key721_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PERCENT_in_percent_rowtype_key721( FOLLOW_PERCENT_in_percent_rowtype_key721_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_percent_rowtype_key723_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_percent_rowtype_key723( FOLLOW_REGULAR_ID_in_percent_rowtype_key723_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PERCENT_in_percent_type_key747_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PERCENT_in_percent_type_key747( FOLLOW_PERCENT_in_percent_type_key747_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_percent_type_key749_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_percent_type_key749( FOLLOW_REGULAR_ID_in_percent_type_key749_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_out_key772_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_out_key772( FOLLOW_REGULAR_ID_in_out_key772_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_inout_key794_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_inout_key794( FOLLOW_REGULAR_ID_in_inout_key794_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_extend_key817_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_extend_key817( FOLLOW_REGULAR_ID_in_extend_key817_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_raise_key839_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_raise_key839( FOLLOW_REGULAR_ID_in_raise_key839_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_while_key861_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_while_key861( FOLLOW_REGULAR_ID_in_while_key861_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_loop_key883_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_loop_key883( FOLLOW_REGULAR_ID_in_loop_key883_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_commit_key906_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_commit_key906( FOLLOW_REGULAR_ID_in_commit_key906_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_work_key928_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_work_key928( FOLLOW_REGULAR_ID_in_work_key928_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_IF_in_if_key948_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_IF_in_if_key948( FOLLOW_PLSQL_RESERVED_IF_in_if_key948_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_ELSIF_in_elsif_key968_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_ELSIF_in_elsif_key968( FOLLOW_PLSQL_NON_RESERVED_ELSIF_in_elsif_key968_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_authid_key991_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_authid_key991( FOLLOW_REGULAR_ID_in_authid_key991_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_definer_key1013_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_definer_key1013( FOLLOW_REGULAR_ID_in_definer_key1013_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_external_key1035_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_external_key1035( FOLLOW_REGULAR_ID_in_external_key1035_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_language_key1057_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_language_key1057( FOLLOW_REGULAR_ID_in_language_key1057_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_java_key1079_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_java_key1079( FOLLOW_REGULAR_ID_in_java_key1079_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_name_key1102_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_name_key1102( FOLLOW_REGULAR_ID_in_name_key1102_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_deterministic_key1125_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_deterministic_key1125( FOLLOW_REGULAR_ID_in_deterministic_key1125_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_parallel_enable_key1148_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_parallel_enable_key1148( FOLLOW_REGULAR_ID_in_parallel_enable_key1148_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_result_cache_key1171_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_result_cache_key1171( FOLLOW_REGULAR_ID_in_result_cache_key1171_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_pipelined_key1194_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_pipelined_key1194( FOLLOW_REGULAR_ID_in_pipelined_key1194_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_aggregate_key1216_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_aggregate_key1216( FOLLOW_REGULAR_ID_in_aggregate_key1216_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ALTER_in_alter_key1236_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ALTER_in_alter_key1236( FOLLOW_SQL92_RESERVED_ALTER_in_alter_key1236_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_compile_key1258_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_compile_key1258( FOLLOW_REGULAR_ID_in_compile_key1258_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_debug_key1281_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_debug_key1281( FOLLOW_REGULAR_ID_in_debug_key1281_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_reuse_key1303_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_reuse_key1303( FOLLOW_REGULAR_ID_in_reuse_key1303_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_settings_key1325_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_settings_key1325( FOLLOW_REGULAR_ID_in_settings_key1325_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_specification_key1347_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_specification_key1347( FOLLOW_REGULAR_ID_in_specification_key1347_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DROP_in_drop_key1367_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DROP_in_drop_key1367( FOLLOW_SQL92_RESERVED_DROP_in_drop_key1367_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_trigger_key1390_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_trigger_key1390( FOLLOW_REGULAR_ID_in_trigger_key1390_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_force_key1413_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_force_key1413( FOLLOW_REGULAR_ID_in_force_key1413_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_validate_key1435_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_validate_key1435( FOLLOW_REGULAR_ID_in_validate_key1435_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ref_key1458_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ref_key1458( FOLLOW_REGULAR_ID_in_ref_key1458_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_array_key1481_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_array_key1481( FOLLOW_REGULAR_ID_in_array_key1481_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_varray_key1504_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_varray_key1504( FOLLOW_REGULAR_ID_in_varray_key1504_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_pls_integer_key1527_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_pls_integer_key1527( FOLLOW_REGULAR_ID_in_pls_integer_key1527_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_serially_reusable_key1550_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_serially_reusable_key1550( FOLLOW_REGULAR_ID_in_serially_reusable_key1550_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_autonomous_transaction_key1573_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_autonomous_transaction_key1573( FOLLOW_REGULAR_ID_in_autonomous_transaction_key1573_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_inline_key1596_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_inline_key1596( FOLLOW_REGULAR_ID_in_inline_key1596_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_restrict_references_key1619_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_restrict_references_key1619( FOLLOW_REGULAR_ID_in_restrict_references_key1619_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_exceptions_key1642_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_exceptions_key1642( FOLLOW_REGULAR_ID_in_exceptions_key1642_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_save_key1666_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_save_key1666( FOLLOW_REGULAR_ID_in_save_key1666_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_forall_key1689_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_forall_key1689( FOLLOW_REGULAR_ID_in_forall_key1689_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_continue_key1712_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_continue_key1712( FOLLOW_REGULAR_ID_in_continue_key1712_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_indices_key1735_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_indices_key1735( FOLLOW_REGULAR_ID_in_indices_key1735_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_VALUES_in_values_key1755_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_VALUES_in_values_key1755( FOLLOW_SQL92_RESERVED_VALUES_in_values_key1755_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_CASE_in_case_key1775_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_CASE_in_case_key1775( FOLLOW_SQL92_RESERVED_CASE_in_case_key1775_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_bulk_key1798_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_bulk_key1798( FOLLOW_REGULAR_ID_in_bulk_key1798_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_collect_key1821_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_collect_key1821( FOLLOW_REGULAR_ID_in_collect_key1821_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_committed_key1843_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_committed_key1843( FOLLOW_REGULAR_ID_in_committed_key1843_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_use_key1866_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_use_key1866( FOLLOW_REGULAR_ID_in_use_key1866_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_level_key1888_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_level_key1888( FOLLOW_REGULAR_ID_in_level_key1888_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_isolation_key1911_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_isolation_key1911( FOLLOW_REGULAR_ID_in_isolation_key1911_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_serializable_key1933_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_serializable_key1933( FOLLOW_REGULAR_ID_in_serializable_key1933_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_segment_key1955_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_segment_key1955( FOLLOW_REGULAR_ID_in_segment_key1955_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_write_key1978_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_write_key1978( FOLLOW_REGULAR_ID_in_write_key1978_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_wait_key2001_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_wait_key2001( FOLLOW_REGULAR_ID_in_wait_key2001_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_corrupt_xid_all_key2024_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_corrupt_xid_all_key2024( FOLLOW_REGULAR_ID_in_corrupt_xid_all_key2024_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_corrupt_xid_key2047_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_corrupt_xid_key2047( FOLLOW_REGULAR_ID_in_corrupt_xid_key2047_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_batch_key2070_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_batch_key2070( FOLLOW_REGULAR_ID_in_batch_key2070_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_session_key2093_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_session_key2093( FOLLOW_REGULAR_ID_in_session_key2093_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_role_key2116_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_role_key2116( FOLLOW_REGULAR_ID_in_role_key2116_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_constraint_key2139_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_constraint_key2139( FOLLOW_REGULAR_ID_in_constraint_key2139_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_constraints_key2162_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_constraints_key2162( FOLLOW_REGULAR_ID_in_constraints_key2162_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_call_key2185_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_call_key2185( FOLLOW_REGULAR_ID_in_call_key2185_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_explain_key2208_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_explain_key2208( FOLLOW_REGULAR_ID_in_explain_key2208_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_merge_key2231_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_merge_key2231( FOLLOW_REGULAR_ID_in_merge_key2231_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_plan_key2254_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_plan_key2254( FOLLOW_REGULAR_ID_in_plan_key2254_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_system_key2277_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_system_key2277( FOLLOW_REGULAR_ID_in_system_key2277_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_subpartition_key2300_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_subpartition_key2300( FOLLOW_REGULAR_ID_in_subpartition_key2300_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_partition_key2323_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_partition_key2323( FOLLOW_REGULAR_ID_in_partition_key2323_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_matched_key2346_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_matched_key2346( FOLLOW_REGULAR_ID_in_matched_key2346_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_reject_key2369_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_reject_key2369( FOLLOW_REGULAR_ID_in_reject_key2369_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_log_key2392_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_log_key2392( FOLLOW_REGULAR_ID_in_log_key2392_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_unlimited_key2415_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_unlimited_key2415( FOLLOW_REGULAR_ID_in_unlimited_key2415_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_limit_key2438_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_limit_key2438( FOLLOW_REGULAR_ID_in_limit_key2438_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_errors_key2461_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_errors_key2461( FOLLOW_REGULAR_ID_in_errors_key2461_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timestamp_tz_unconstrained_key2484_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timestamp_tz_unconstrained_key2484( FOLLOW_REGULAR_ID_in_timestamp_tz_unconstrained_key2484_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_urowid_key2507_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_urowid_key2507( FOLLOW_REGULAR_ID_in_urowid_key2507_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_min_subnormal_key2530_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_min_subnormal_key2530( FOLLOW_REGULAR_ID_in_binary_float_min_subnormal_key2530_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_min_normal_key2553_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_min_normal_key2553( FOLLOW_REGULAR_ID_in_binary_double_min_normal_key2553_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_max_normal_key2576_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_max_normal_key2576( FOLLOW_REGULAR_ID_in_binary_float_max_normal_key2576_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_positiven_key2599_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_positiven_key2599( FOLLOW_REGULAR_ID_in_positiven_key2599_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timezone_abbr_key2622_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timezone_abbr_key2622( FOLLOW_REGULAR_ID_in_timezone_abbr_key2622_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_min_subnormal_key2645_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_min_subnormal_key2645( FOLLOW_REGULAR_ID_in_binary_double_min_subnormal_key2645_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_max_subnormal_key2668_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_max_subnormal_key2668( FOLLOW_REGULAR_ID_in_binary_float_max_subnormal_key2668_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_key2691_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_key2691( FOLLOW_REGULAR_ID_in_binary_double_key2691_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_bfile_key2714_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_bfile_key2714( FOLLOW_REGULAR_ID_in_bfile_key2714_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_infinity_key2737_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_infinity_key2737( FOLLOW_REGULAR_ID_in_binary_double_infinity_key2737_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timezone_region_key2760_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timezone_region_key2760( FOLLOW_REGULAR_ID_in_timezone_region_key2760_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timestamp_ltz_unconstrained_key2783_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timestamp_ltz_unconstrained_key2783( FOLLOW_REGULAR_ID_in_timestamp_ltz_unconstrained_key2783_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_naturaln_key2806_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_naturaln_key2806( FOLLOW_REGULAR_ID_in_naturaln_key2806_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_simple_integer_key2829_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_simple_integer_key2829( FOLLOW_REGULAR_ID_in_simple_integer_key2829_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_max_subnormal_key2852_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_max_subnormal_key2852( FOLLOW_REGULAR_ID_in_binary_double_max_subnormal_key2852_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_byte_key2875_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_byte_key2875( FOLLOW_REGULAR_ID_in_byte_key2875_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_infinity_key2898_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_infinity_key2898( FOLLOW_REGULAR_ID_in_binary_float_infinity_key2898_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_key2921_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_key2921( FOLLOW_REGULAR_ID_in_binary_float_key2921_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_range_key2944_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_range_key2944( FOLLOW_REGULAR_ID_in_range_key2944_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nclob_key2967_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nclob_key2967( FOLLOW_REGULAR_ID_in_nclob_key2967_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_clob_key2990_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_clob_key2990( FOLLOW_REGULAR_ID_in_clob_key2990_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dsinterval_unconstrained_key3013_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dsinterval_unconstrained_key3013( FOLLOW_REGULAR_ID_in_dsinterval_unconstrained_key3013_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_yminterval_unconstrained_key3036_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_yminterval_unconstrained_key3036( FOLLOW_REGULAR_ID_in_yminterval_unconstrained_key3036_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rowid_key3059_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rowid_key3059( FOLLOW_REGULAR_ID_in_rowid_key3059_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_nan_key3082_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_nan_key3082( FOLLOW_REGULAR_ID_in_binary_double_nan_key3082_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timestamp_unconstrained_key3105_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timestamp_unconstrained_key3105( FOLLOW_REGULAR_ID_in_timestamp_unconstrained_key3105_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_min_normal_key3128_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_min_normal_key3128( FOLLOW_REGULAR_ID_in_binary_float_min_normal_key3128_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_signtype_key3151_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_signtype_key3151( FOLLOW_REGULAR_ID_in_signtype_key3151_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_blob_key3174_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_blob_key3174( FOLLOW_REGULAR_ID_in_blob_key3174_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nvarchar2_key3197_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nvarchar2_key3197( FOLLOW_REGULAR_ID_in_nvarchar2_key3197_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_max_normal_key3220_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_max_normal_key3220( FOLLOW_REGULAR_ID_in_binary_double_max_normal_key3220_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_nan_key3243_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_nan_key3243( FOLLOW_REGULAR_ID_in_binary_float_nan_key3243_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_string_key3266_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_string_key3266( FOLLOW_REGULAR_ID_in_string_key3266_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_c_key3289_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_c_key3289( FOLLOW_REGULAR_ID_in_c_key3289_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_library_key3312_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_library_key3312( FOLLOW_REGULAR_ID_in_library_key3312_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_context_key3335_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_context_key3335( FOLLOW_REGULAR_ID_in_context_key3335_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_parameters_key3358_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_parameters_key3358( FOLLOW_REGULAR_ID_in_parameters_key3358_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_agent_key3381_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_agent_key3381( FOLLOW_REGULAR_ID_in_agent_key3381_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cluster_key3404_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cluster_key3404( FOLLOW_REGULAR_ID_in_cluster_key3404_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_hash_key3427_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_hash_key3427( FOLLOW_REGULAR_ID_in_hash_key3427_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_relies_on_key3450_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_relies_on_key3450( FOLLOW_REGULAR_ID_in_relies_on_key3450_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_returning_key3473_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_returning_key3473( FOLLOW_REGULAR_ID_in_returning_key3473_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_statement_id_key3500_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_statement_id_key3500( FOLLOW_REGULAR_ID_in_statement_id_key3500_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_deferred_key3523_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_deferred_key3523( FOLLOW_REGULAR_ID_in_deferred_key3523_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_advise_key3546_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_advise_key3546( FOLLOW_REGULAR_ID_in_advise_key3546_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_resumable_key3569_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_resumable_key3569( FOLLOW_REGULAR_ID_in_resumable_key3569_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timeout_key3592_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timeout_key3592( FOLLOW_REGULAR_ID_in_timeout_key3592_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_parallel_key3615_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_parallel_key3615( FOLLOW_REGULAR_ID_in_parallel_key3615_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ddl_key3638_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ddl_key3638( FOLLOW_REGULAR_ID_in_ddl_key3638_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_query_key3661_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_query_key3661( FOLLOW_REGULAR_ID_in_query_key3661_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dml_key3684_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dml_key3684( FOLLOW_REGULAR_ID_in_dml_key3684_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_guard_key3707_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_guard_key3707( FOLLOW_REGULAR_ID_in_guard_key3707_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nothing_key3730_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nothing_key3730( FOLLOW_REGULAR_ID_in_nothing_key3730_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_enable_key3753_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_enable_key3753( FOLLOW_REGULAR_ID_in_enable_key3753_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_database_key3776_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_database_key3776( FOLLOW_REGULAR_ID_in_database_key3776_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_disable_key3799_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_disable_key3799( FOLLOW_REGULAR_ID_in_disable_key3799_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_link_key3822_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_link_key3822( FOLLOW_REGULAR_ID_in_link_key3822_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_IDENTIFIED_in_identified_key3842_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_IDENTIFIED_in_identified_key3842( FOLLOW_PLSQL_RESERVED_IDENTIFIED_in_identified_key3842_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_none_key3865_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_none_key3865( FOLLOW_REGULAR_ID_in_none_key3865_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_before_key3888_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_before_key3888( FOLLOW_REGULAR_ID_in_before_key3888_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_referencing_key3912_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_referencing_key3912( FOLLOW_REGULAR_ID_in_referencing_key3912_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_logon_key3935_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_logon_key3935( FOLLOW_REGULAR_ID_in_logon_key3935_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_after_key3957_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_after_key3957( FOLLOW_REGULAR_ID_in_after_key3957_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_schema_key3980_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_schema_key3980( FOLLOW_REGULAR_ID_in_schema_key3980_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_GRANT_in_grant_key4000_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_GRANT_in_grant_key4000( FOLLOW_SQL92_RESERVED_GRANT_in_grant_key4000_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_truncate_key4023_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_truncate_key4023( FOLLOW_REGULAR_ID_in_truncate_key4023_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_startup_key4046_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_startup_key4046( FOLLOW_REGULAR_ID_in_startup_key4046_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_statistics_key4069_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_statistics_key4069( FOLLOW_REGULAR_ID_in_statistics_key4069_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_noaudit_key4092_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_noaudit_key4092( FOLLOW_REGULAR_ID_in_noaudit_key4092_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_suspend_key4115_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_suspend_key4115( FOLLOW_REGULAR_ID_in_suspend_key4115_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_audit_key4138_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_audit_key4138( FOLLOW_REGULAR_ID_in_audit_key4138_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_disassociate_key4161_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_disassociate_key4161( FOLLOW_REGULAR_ID_in_disassociate_key4161_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_shutdown_key4185_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_shutdown_key4185( FOLLOW_REGULAR_ID_in_shutdown_key4185_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_compound_key4208_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_compound_key4208( FOLLOW_REGULAR_ID_in_compound_key4208_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_servererror_key4231_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_servererror_key4231( FOLLOW_REGULAR_ID_in_servererror_key4231_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_parent_key4254_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_parent_key4254( FOLLOW_REGULAR_ID_in_parent_key4254_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_follows_key4277_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_follows_key4277( FOLLOW_REGULAR_ID_in_follows_key4277_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nested_key4300_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nested_key4300( FOLLOW_REGULAR_ID_in_nested_key4300_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_old_key4323_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_old_key4323( FOLLOW_REGULAR_ID_in_old_key4323_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_statement_key4346_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_statement_key4346( FOLLOW_REGULAR_ID_in_statement_key4346_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_db_role_change_key4369_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_db_role_change_key4369( FOLLOW_REGULAR_ID_in_db_role_change_key4369_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_each_key4392_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_each_key4392( FOLLOW_REGULAR_ID_in_each_key4392_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_logoff_key4415_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_logoff_key4415( FOLLOW_REGULAR_ID_in_logoff_key4415_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_analyze_key4438_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_analyze_key4438( FOLLOW_REGULAR_ID_in_analyze_key4438_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_instead_key4461_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_instead_key4461( FOLLOW_REGULAR_ID_in_instead_key4461_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_associate_key4484_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_associate_key4484( FOLLOW_REGULAR_ID_in_associate_key4484_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_new_key4507_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_new_key4507( FOLLOW_REGULAR_ID_in_new_key4507_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_REVOKE_in_revoke_key4527_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_REVOKE_in_revoke_key4527( FOLLOW_SQL92_RESERVED_REVOKE_in_revoke_key4527_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rename_key4550_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rename_key4550( FOLLOW_REGULAR_ID_in_rename_key4550_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_customdatum_key4574_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_customdatum_key4574( FOLLOW_REGULAR_ID_in_customdatum_key4574_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_oradata_key4597_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_oradata_key4597( FOLLOW_REGULAR_ID_in_oradata_key4597_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_constructor_key4620_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_constructor_key4620( FOLLOW_REGULAR_ID_in_constructor_key4620_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sqldata_key4643_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sqldata_key4643( FOLLOW_REGULAR_ID_in_sqldata_key4643_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_member_key4666_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_member_key4666( FOLLOW_REGULAR_ID_in_member_key4666_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_self_key4689_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_self_key4689( FOLLOW_REGULAR_ID_in_self_key4689_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_object_key4712_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_object_key4712( FOLLOW_REGULAR_ID_in_object_key4712_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_variable_key4735_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_variable_key4735( FOLLOW_REGULAR_ID_in_variable_key4735_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_instantiable_key4758_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_instantiable_key4758( FOLLOW_REGULAR_ID_in_instantiable_key4758_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_final_key4781_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_final_key4781( FOLLOW_REGULAR_ID_in_final_key4781_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_static_key4804_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_static_key4804( FOLLOW_REGULAR_ID_in_static_key4804_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_oid_key4827_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_oid_key4827( FOLLOW_REGULAR_ID_in_oid_key4827_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_result_key4850_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_result_key4850( FOLLOW_REGULAR_ID_in_result_key4850_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_under_key4873_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_under_key4873( FOLLOW_REGULAR_ID_in_under_key4873_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_map_key4896_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_map_key4896( FOLLOW_REGULAR_ID_in_map_key4896_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_overriding_key4919_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_overriding_key4919( FOLLOW_REGULAR_ID_in_overriding_key4919_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_add_key4942_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_add_key4942( FOLLOW_REGULAR_ID_in_add_key4942_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_modify_key4965_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_modify_key4965( FOLLOW_REGULAR_ID_in_modify_key4965_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_including_key4988_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_including_key4988( FOLLOW_REGULAR_ID_in_including_key4988_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_substitutable_key5011_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_substitutable_key5011( FOLLOW_REGULAR_ID_in_substitutable_key5011_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_attribute_key5034_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_attribute_key5034( FOLLOW_REGULAR_ID_in_attribute_key5034_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cascade_key5057_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cascade_key5057( FOLLOW_REGULAR_ID_in_cascade_key5057_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_data_key5081_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_data_key5081( FOLLOW_REGULAR_ID_in_data_key5081_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_invalidate_key5103_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_invalidate_key5103( FOLLOW_REGULAR_ID_in_invalidate_key5103_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_element_key5126_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_element_key5126( FOLLOW_REGULAR_ID_in_element_key5126_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_first_key5149_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_first_key5149( FOLLOW_REGULAR_ID_in_first_key5149_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_CHECK_in_check_key5169_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_CHECK_in_check_key5169( FOLLOW_SQL92_RESERVED_CHECK_in_check_key5169_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_OPTION_in_option_key5189_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_OPTION_in_option_key5189( FOLLOW_SQL92_RESERVED_OPTION_in_option_key5189_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nocycle_key5212_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nocycle_key5212( FOLLOW_REGULAR_ID_in_nocycle_key5212_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_locked_key5235_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_locked_key5235( FOLLOW_REGULAR_ID_in_locked_key5235_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_block_key5258_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_block_key5258( FOLLOW_REGULAR_ID_in_block_key5258_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xml_key5281_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xml_key5281( FOLLOW_REGULAR_ID_in_xml_key5281_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_PIVOT_in_pivot_key5302_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_PIVOT_in_pivot_key5302( FOLLOW_PLSQL_NON_RESERVED_PIVOT_in_pivot_key5302_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_PRIOR_in_prior_key5322_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_PRIOR_in_prior_key5322( FOLLOW_SQL92_RESERVED_PRIOR_in_prior_key5322_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sequential_key5345_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sequential_key5345( FOLLOW_REGULAR_ID_in_sequential_key5345_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_single_key5368_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_single_key5368( FOLLOW_REGULAR_ID_in_single_key5368_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_skip_key5391_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_skip_key5391( FOLLOW_REGULAR_ID_in_skip_key5391_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_MODEL_in_model_key5420_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_MODEL_in_model_key5420( FOLLOW_PLSQL_NON_RESERVED_MODEL_in_model_key5420_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_updated_key5443_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_updated_key5443( FOLLOW_REGULAR_ID_in_updated_key5443_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_increment_key5466_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_increment_key5466( FOLLOW_REGULAR_ID_in_increment_key5466_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_exclude_key5489_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_exclude_key5489( FOLLOW_REGULAR_ID_in_exclude_key5489_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_reference_key5512_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_reference_key5512( FOLLOW_REGULAR_ID_in_reference_key5512_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sets_key5535_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sets_key5535( FOLLOW_REGULAR_ID_in_sets_key5535_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_until_key5558_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_until_key5558( FOLLOW_REGULAR_ID_in_until_key5558_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_seed_key5581_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_seed_key5581( FOLLOW_REGULAR_ID_in_seed_key5581_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_maxvalue_key5604_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_maxvalue_key5604( FOLLOW_REGULAR_ID_in_maxvalue_key5604_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_siblings_key5627_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_siblings_key5627( FOLLOW_REGULAR_ID_in_siblings_key5627_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cube_key5650_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cube_key5650( FOLLOW_REGULAR_ID_in_cube_key5650_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nulls_key5673_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nulls_key5673( FOLLOW_REGULAR_ID_in_nulls_key5673_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dimension_key5696_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dimension_key5696( FOLLOW_REGULAR_ID_in_dimension_key5696_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_scn_key5719_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_scn_key5719( FOLLOW_REGULAR_ID_in_scn_key5719_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_snapshot_key5742_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_snapshot_key5742( FOLLOW_REGULAR_ID_in_snapshot_key5742_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_decrement_key5765_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_decrement_key5765( FOLLOW_REGULAR_ID_in_decrement_key5765_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_UNPIVOT_in_unpivot_key5785_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_UNPIVOT_in_unpivot_key5785( FOLLOW_PLSQL_NON_RESERVED_UNPIVOT_in_unpivot_key5785_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_keep_key5808_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_keep_key5808( FOLLOW_REGULAR_ID_in_keep_key5808_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_measures_key5831_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_measures_key5831( FOLLOW_REGULAR_ID_in_measures_key5831_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rows_key5854_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rows_key5854( FOLLOW_REGULAR_ID_in_rows_key5854_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sample_key5877_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sample_key5877( FOLLOW_REGULAR_ID_in_sample_key5877_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_upsert_key5900_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_upsert_key5900( FOLLOW_REGULAR_ID_in_upsert_key5900_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_versions_key5923_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_versions_key5923( FOLLOW_REGULAR_ID_in_versions_key5923_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rules_key5946_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rules_key5946( FOLLOW_REGULAR_ID_in_rules_key5946_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_iterate_key5969_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_iterate_key5969( FOLLOW_REGULAR_ID_in_iterate_key5969_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_minvalue_key5992_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_minvalue_key5992( FOLLOW_REGULAR_ID_in_minvalue_key5992_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rollup_key6015_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rollup_key6015( FOLLOW_REGULAR_ID_in_rollup_key6015_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nav_key6038_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nav_key6038( FOLLOW_REGULAR_ID_in_nav_key6038_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_automatic_key6061_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_automatic_key6061( FOLLOW_REGULAR_ID_in_automatic_key6061_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_last_key6084_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_last_key6084( FOLLOW_REGULAR_ID_in_last_key6084_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_main_key6107_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_main_key6107( FOLLOW_REGULAR_ID_in_main_key6107_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_grouping_key6130_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_grouping_key6130( FOLLOW_REGULAR_ID_in_grouping_key6130_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_include_key6153_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_include_key6153( FOLLOW_REGULAR_ID_in_include_key6153_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ignore_key6176_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ignore_key6176( FOLLOW_REGULAR_ID_in_ignore_key6176_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_respect_key6199_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_respect_key6199( FOLLOW_REGULAR_ID_in_respect_key6199_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_UNIQUE_in_unique_key6219_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_UNIQUE_in_unique_key6219( FOLLOW_SQL92_RESERVED_UNIQUE_in_unique_key6219_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_submultiset_key6242_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_submultiset_key6242( FOLLOW_REGULAR_ID_in_submultiset_key6242_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_at_key6265_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_at_key6265( FOLLOW_REGULAR_ID_in_at_key6265_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_a_key6289_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_a_key6289( FOLLOW_REGULAR_ID_in_a_key6289_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_empty_key6312_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_empty_key6312( FOLLOW_REGULAR_ID_in_empty_key6312_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_likec_key6335_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_likec_key6335( FOLLOW_REGULAR_ID_in_likec_key6335_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nan_key6358_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nan_key6358( FOLLOW_REGULAR_ID_in_nan_key6358_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_infinite_key6381_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_infinite_key6381( FOLLOW_REGULAR_ID_in_infinite_key6381_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_like2_key6404_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_like2_key6404( FOLLOW_REGULAR_ID_in_like2_key6404_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_like4_key6427_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_like4_key6427( FOLLOW_REGULAR_ID_in_like4_key6427_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_present_key6450_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_present_key6450( FOLLOW_REGULAR_ID_in_present_key6450_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dbtimezone_key6473_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dbtimezone_key6473( FOLLOW_REGULAR_ID_in_dbtimezone_key6473_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sessiontimezone_key6496_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sessiontimezone_key6496( FOLLOW_REGULAR_ID_in_sessiontimezone_key6496_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nchar_cs_key6519_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nchar_cs_key6519( FOLLOW_REGULAR_ID_in_nchar_cs_key6519_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_decompose_key6542_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_decompose_key6542( FOLLOW_REGULAR_ID_in_decompose_key6542_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_following_key6565_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_following_key6565( FOLLOW_REGULAR_ID_in_following_key6565_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_first_value_key6588_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_first_value_key6588( FOLLOW_REGULAR_ID_in_first_value_key6588_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_preceding_key6611_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_preceding_key6611( FOLLOW_REGULAR_ID_in_preceding_key6611_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_within_key6634_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_within_key6634( FOLLOW_REGULAR_ID_in_within_key6634_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_canonical_key6657_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_canonical_key6657( FOLLOW_REGULAR_ID_in_canonical_key6657_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_compatibility_key6680_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_compatibility_key6680( FOLLOW_REGULAR_ID_in_compatibility_key6680_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_over_key6703_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_over_key6703( FOLLOW_REGULAR_ID_in_over_key6703_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_multiset_key6726_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_multiset_key6726( FOLLOW_REGULAR_ID_in_multiset_key6726_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_CONNECT_BY_ROOT_in_connect_by_root_key6746_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_CONNECT_BY_ROOT_in_connect_by_root_key6746( FOLLOW_PLSQL_NON_RESERVED_CONNECT_BY_ROOT_in_connect_by_root_key6746_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_last_value_key6769_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_last_value_key6769( FOLLOW_REGULAR_ID_in_last_value_key6769_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_CURRENT_in_current_key6789_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_CURRENT_in_current_key6789( FOLLOW_SQL92_RESERVED_CURRENT_in_current_key6789_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_unbounded_key6812_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_unbounded_key6812( FOLLOW_REGULAR_ID_in_unbounded_key6812_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dense_rank_key6835_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dense_rank_key6835( FOLLOW_REGULAR_ID_in_dense_rank_key6835_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cost_key6858_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cost_key6858( FOLLOW_REGULAR_ID_in_cost_key6858_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_char_cs_key6881_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_char_cs_key6881( FOLLOW_REGULAR_ID_in_char_cs_key6881_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_auto_key6904_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_auto_key6904( FOLLOW_REGULAR_ID_in_auto_key6904_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_treat_key6927_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_treat_key6927( FOLLOW_REGULAR_ID_in_treat_key6927_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_content_key6950_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_content_key6950( FOLLOW_REGULAR_ID_in_content_key6950_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlparse_key6973_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlparse_key6973( FOLLOW_REGULAR_ID_in_xmlparse_key6973_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlelement_key6996_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlelement_key6996( FOLLOW_REGULAR_ID_in_xmlelement_key6996_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_entityescaping_key7019_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_entityescaping_key7019( FOLLOW_REGULAR_ID_in_entityescaping_key7019_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_standalone_key7042_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_standalone_key7042( FOLLOW_REGULAR_ID_in_standalone_key7042_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_wellformed_key7065_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_wellformed_key7065( FOLLOW_REGULAR_ID_in_wellformed_key7065_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlexists_key7088_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlexists_key7088( FOLLOW_REGULAR_ID_in_xmlexists_key7088_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_version_key7111_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_version_key7111( FOLLOW_REGULAR_ID_in_version_key7111_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlcast_key7134_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlcast_key7134( FOLLOW_REGULAR_ID_in_xmlcast_key7134_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_yes_key7157_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_yes_key7157( FOLLOW_REGULAR_ID_in_yes_key7157_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_no_key7180_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_no_key7180( FOLLOW_REGULAR_ID_in_no_key7180_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_evalname_key7203_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_evalname_key7203( FOLLOW_REGULAR_ID_in_evalname_key7203_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlpi_key7226_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlpi_key7226( FOLLOW_REGULAR_ID_in_xmlpi_key7226_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlcolattval_key7249_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlcolattval_key7249( FOLLOW_REGULAR_ID_in_xmlcolattval_key7249_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_document_key7272_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_document_key7272( FOLLOW_REGULAR_ID_in_document_key7272_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlforest_key7295_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlforest_key7295( FOLLOW_REGULAR_ID_in_xmlforest_key7295_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_passing_key7318_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_passing_key7318( FOLLOW_REGULAR_ID_in_passing_key7318_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_columns_key7342_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_columns_key7342( FOLLOW_REGULAR_ID_in_columns_key7342_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_indent_key7365_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_indent_key7365( FOLLOW_REGULAR_ID_in_indent_key7365_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_hide_key7388_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_hide_key7388( FOLLOW_REGULAR_ID_in_hide_key7388_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlagg_key7411_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlagg_key7411( FOLLOW_REGULAR_ID_in_xmlagg_key7411_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_path_key7434_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_path_key7434( FOLLOW_REGULAR_ID_in_path_key7434_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlnamespaces_key7457_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlnamespaces_key7457( FOLLOW_REGULAR_ID_in_xmlnamespaces_key7457_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_SIZE_in_size_key7477_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_SIZE_in_size_key7477( FOLLOW_SQL92_RESERVED_SIZE_in_size_key7477_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_noschemacheck_key7500_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_noschemacheck_key7500( FOLLOW_REGULAR_ID_in_noschemacheck_key7500_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_noentityescaping_key7523_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_noentityescaping_key7523( FOLLOW_REGULAR_ID_in_noentityescaping_key7523_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlquery_key7546_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlquery_key7546( FOLLOW_REGULAR_ID_in_xmlquery_key7546_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmltable_key7569_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmltable_key7569( FOLLOW_REGULAR_ID_in_xmltable_key7569_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlroot_key7592_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlroot_key7592( FOLLOW_REGULAR_ID_in_xmlroot_key7592_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_schemacheck_key7615_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_schemacheck_key7615( FOLLOW_REGULAR_ID_in_schemacheck_key7615_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlattributes_key7638_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlattributes_key7638( FOLLOW_REGULAR_ID_in_xmlattributes_key7638_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_encoding_key7661_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_encoding_key7661( FOLLOW_REGULAR_ID_in_encoding_key7661_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_show_key7684_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_show_key7684( FOLLOW_REGULAR_ID_in_show_key7684_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlserialize_key7707_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlserialize_key7707( FOLLOW_REGULAR_ID_in_xmlserialize_key7707_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ordinality_key7730_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ordinality_key7730( FOLLOW_REGULAR_ID_in_ordinality_key7730_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_defaults_key7753_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_defaults_key7753( FOLLOW_REGULAR_ID_in_defaults_key7753_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sqlerror_key7775_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sqlerror_key7775( FOLLOW_REGULAR_ID_in_sqlerror_key7775_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_oserror_key7799_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_oserror_key7799( FOLLOW_REGULAR_ID_in_oserror_key7799_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_success_key7822_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_success_key7822( FOLLOW_REGULAR_ID_in_success_key7822_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_warning_key7845_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_warning_key7845( FOLLOW_REGULAR_ID_in_warning_key7845_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_failure_key7868_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_failure_key7868( FOLLOW_REGULAR_ID_in_failure_key7868_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_INSERT_in_insert_key7889_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_INSERT_in_insert_key7889( FOLLOW_SQL92_RESERVED_INSERT_in_insert_key7889_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ORDER_in_order_key7909_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ORDER_in_order_key7909( FOLLOW_SQL92_RESERVED_ORDER_in_order_key7909_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_MINUS_in_minus_key7929_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_MINUS_in_minus_key7929( FOLLOW_PLSQL_RESERVED_MINUS_in_minus_key7929_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_row_key7951_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_row_key7951( FOLLOW_REGULAR_ID_in_row_key7951_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_mod_key7973_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_mod_key7973( FOLLOW_REGULAR_ID_in_mod_key7973_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_raw_key7996_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_raw_key7996( FOLLOW_REGULAR_ID_in_raw_key7996_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_power_key8018_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_power_key8018( FOLLOW_REGULAR_ID_in_power_key8018_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_LOCK_in_lock_key8038_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_LOCK_in_lock_key8038( FOLLOW_PLSQL_RESERVED_LOCK_in_lock_key8038_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_EXISTS_in_exists_key8058_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_EXISTS_in_exists_key8058( FOLLOW_SQL92_RESERVED_EXISTS_in_exists_key8058_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_HAVING_in_having_key8078_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_HAVING_in_having_key8078( FOLLOW_SQL92_RESERVED_HAVING_in_having_key8078_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ANY_in_any_key8098_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ANY_in_any_key8098( FOLLOW_SQL92_RESERVED_ANY_in_any_key8098_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_WITH_in_with_key8118_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_WITH_in_with_key8118( FOLLOW_SQL92_RESERVED_WITH_in_with_key8118_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_transaction_key8141_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_transaction_key8141( FOLLOW_REGULAR_ID_in_transaction_key8141_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rawtohex_key8163_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rawtohex_key8163( FOLLOW_REGULAR_ID_in_rawtohex_key8163_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_number_key8186_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_number_key8186( FOLLOW_REGULAR_ID_in_number_key8186_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nocopy_key8209_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nocopy_key8209( FOLLOW_REGULAR_ID_in_nocopy_key8209_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_TO_in_to_key8229_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_TO_in_to_key8229( FOLLOW_SQL92_RESERVED_TO_in_to_key8229_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_abs_key8251_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_abs_key8251( FOLLOW_REGULAR_ID_in_abs_key8251_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rollback_key8274_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rollback_key8274( FOLLOW_REGULAR_ID_in_rollback_key8274_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_SHARE_in_share_key8294_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_SHARE_in_share_key8294( FOLLOW_PLSQL_RESERVED_SHARE_in_share_key8294_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_greatest_key8316_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_greatest_key8316( FOLLOW_REGULAR_ID_in_greatest_key8316_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_vsize_key8338_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_vsize_key8338( FOLLOW_REGULAR_ID_in_vsize_key8338_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_EXCLUSIVE_in_exclusive_key8358_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_EXCLUSIVE_in_exclusive_key8358( FOLLOW_PLSQL_RESERVED_EXCLUSIVE_in_exclusive_key8358_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_varchar2_key8381_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_varchar2_key8381( FOLLOW_REGULAR_ID_in_varchar2_key8381_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rowidtochar_key8403_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rowidtochar_key8403( FOLLOW_REGULAR_ID_in_rowidtochar_key8403_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_open_key8426_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_open_key8426( FOLLOW_REGULAR_ID_in_open_key8426_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_comment_key8449_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_comment_key8449( FOLLOW_REGULAR_ID_in_comment_key8449_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sqrt_key8471_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sqrt_key8471( FOLLOW_REGULAR_ID_in_sqrt_key8471_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_instr_key8493_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_instr_key8493( FOLLOW_REGULAR_ID_in_instr_key8493_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_NOWAIT_in_nowait_key8513_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_NOWAIT_in_nowait_key8513( FOLLOW_PLSQL_RESERVED_NOWAIT_in_nowait_key8513_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_lpad_key8535_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_lpad_key8535( FOLLOW_REGULAR_ID_in_lpad_key8535_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_boolean_key8558_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_boolean_key8558( FOLLOW_REGULAR_ID_in_boolean_key8558_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rpad_key8580_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rpad_key8580( FOLLOW_REGULAR_ID_in_rpad_key8580_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_savepoint_key8603_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_savepoint_key8603( FOLLOW_REGULAR_ID_in_savepoint_key8603_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_decode_key8625_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_decode_key8625( FOLLOW_REGULAR_ID_in_decode_key8625_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_reverse_key8647_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_reverse_key8647( FOLLOW_REGULAR_ID_in_reverse_key8647_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_least_key8669_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_least_key8669( FOLLOW_REGULAR_ID_in_least_key8669_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nvl_key8691_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nvl_key8691( FOLLOW_REGULAR_ID_in_nvl_key8691_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_variance_key8713_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_variance_key8713( FOLLOW_REGULAR_ID_in_variance_key8713_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_START_in_start_key8733_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_START_in_start_key8733( FOLLOW_PLSQL_RESERVED_START_in_start_key8733_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DESC_in_desc_key8753_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DESC_in_desc_key8753( FOLLOW_SQL92_RESERVED_DESC_in_desc_key8753_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_concat_key8775_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_concat_key8775( FOLLOW_REGULAR_ID_in_concat_key8775_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dump_key8797_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dump_key8797( FOLLOW_REGULAR_ID_in_dump_key8797_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_soundex_key8819_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_soundex_key8819( FOLLOW_REGULAR_ID_in_soundex_key8819_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_positive_key8842_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_positive_key8842( FOLLOW_REGULAR_ID_in_positive_key8842_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_UNION_in_union_key8862_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_UNION_in_union_key8862( FOLLOW_SQL92_RESERVED_UNION_in_union_key8862_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ascii_key8884_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ascii_key8884( FOLLOW_REGULAR_ID_in_ascii_key8884_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_CONNECT_in_connect_key8904_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_CONNECT_in_connect_key8904( FOLLOW_SQL92_RESERVED_CONNECT_in_connect_key8904_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ASC_in_asc_key8924_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ASC_in_asc_key8924( FOLLOW_SQL92_RESERVED_ASC_in_asc_key8924_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_hextoraw_key8946_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_hextoraw_key8946( FOLLOW_REGULAR_ID_in_hextoraw_key8946_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_to_date_key8968_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_to_date_key8968( FOLLOW_REGULAR_ID_in_to_date_key8968_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_floor_key8990_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_floor_key8990( FOLLOW_REGULAR_ID_in_floor_key8990_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sign_key9012_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sign_key9012( FOLLOW_REGULAR_ID_in_sign_key9012_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_UPDATE_in_update_key9032_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_UPDATE_in_update_key9032( FOLLOW_SQL92_RESERVED_UPDATE_in_update_key9032_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_trunc_key9054_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_trunc_key9054( FOLLOW_REGULAR_ID_in_trunc_key9054_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rtrim_key9076_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rtrim_key9076( FOLLOW_REGULAR_ID_in_rtrim_key9076_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_close_key9099_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_close_key9099( FOLLOW_REGULAR_ID_in_close_key9099_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_to_char_key9121_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_to_char_key9121( FOLLOW_REGULAR_ID_in_to_char_key9121_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ltrim_key9143_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ltrim_key9143( FOLLOW_REGULAR_ID_in_ltrim_key9143_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_MODE_in_mode_key9163_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_MODE_in_mode_key9163( FOLLOW_PLSQL_RESERVED_MODE_in_mode_key9163_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_uid_key9185_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_uid_key9185( FOLLOW_REGULAR_ID_in_uid_key9185_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_chr_key9207_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_chr_key9207( FOLLOW_REGULAR_ID_in_chr_key9207_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_INTERSECT_in_intersect_key9227_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_INTERSECT_in_intersect_key9227( FOLLOW_SQL92_RESERVED_INTERSECT_in_intersect_key9227_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_chartorowid_key9249_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_chartorowid_key9249( FOLLOW_REGULAR_ID_in_chartorowid_key9249_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_mlslabel_key9272_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_mlslabel_key9272( FOLLOW_REGULAR_ID_in_mlslabel_key9272_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_userenv_key9294_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_userenv_key9294( FOLLOW_REGULAR_ID_in_userenv_key9294_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_stddev_key9316_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_stddev_key9316( FOLLOW_REGULAR_ID_in_stddev_key9316_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_length_key9338_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_length_key9338( FOLLOW_REGULAR_ID_in_length_key9338_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_FETCH_in_fetch_key9358_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_FETCH_in_fetch_key9358( FOLLOW_SQL92_RESERVED_FETCH_in_fetch_key9358_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_GROUP_in_group_key9378_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_GROUP_in_group_key9378( FOLLOW_SQL92_RESERVED_GROUP_in_group_key9378_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sysdate_key9400_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sysdate_key9400( FOLLOW_REGULAR_ID_in_sysdate_key9400_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_integer_key9423_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_integer_key9423( FOLLOW_REGULAR_ID_in_binary_integer_key9423_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_to_number_key9445_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_to_number_key9445( FOLLOW_REGULAR_ID_in_to_number_key9445_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_substr_key9467_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_substr_key9467( FOLLOW_REGULAR_ID_in_substr_key9467_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ceil_key9489_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ceil_key9489( FOLLOW_REGULAR_ID_in_ceil_key9489_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_initcap_key9511_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_initcap_key9511( FOLLOW_REGULAR_ID_in_initcap_key9511_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_round_key9533_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_round_key9533( FOLLOW_REGULAR_ID_in_round_key9533_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_long_key9556_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_long_key9556( FOLLOW_REGULAR_ID_in_long_key9556_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_read_key9579_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_read_key9579( FOLLOW_REGULAR_ID_in_read_key9579_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_only_key9601_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_only_key9601( FOLLOW_REGULAR_ID_in_only_key9601_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_set_key9624_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_set_key9624( FOLLOW_REGULAR_ID_in_set_key9624_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nullif_key9646_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nullif_key9646( FOLLOW_REGULAR_ID_in_nullif_key9646_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_coalesce_key9668_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_coalesce_key9668( FOLLOW_REGULAR_ID_in_coalesce_key9668_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_count_key9690_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_count_key9690( FOLLOW_REGULAR_ID_in_count_key9690_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_avg_key9711_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_avg_key9711( FOLLOW_REGULAR_ID_in_avg_key9711_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_max_key9732_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_max_key9732( FOLLOW_REGULAR_ID_in_max_key9732_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_min_key9753_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_min_key9753( FOLLOW_REGULAR_ID_in_min_key9753_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sum_key9774_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sum_key9774( FOLLOW_REGULAR_ID_in_sum_key9774_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_unknown_key9796_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_unknown_key9796( FOLLOW_REGULAR_ID_in_unknown_key9796_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_escape_key9818_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_escape_key9818( FOLLOW_REGULAR_ID_in_escape_key9818_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_some_key9840_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_some_key9840( FOLLOW_REGULAR_ID_in_some_key9840_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_match_key9862_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_match_key9862( FOLLOW_REGULAR_ID_in_match_key9862_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cast_key9884_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cast_key9884( FOLLOW_REGULAR_ID_in_cast_key9884_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_full_key9907_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_full_key9907( FOLLOW_REGULAR_ID_in_full_key9907_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_partial_key9929_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_partial_key9929( FOLLOW_REGULAR_ID_in_partial_key9929_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_character_key9952_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_character_key9952( FOLLOW_REGULAR_ID_in_character_key9952_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_except_key9974_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_except_key9974( FOLLOW_REGULAR_ID_in_except_key9974_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_char_key9997_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_char_key9997( FOLLOW_REGULAR_ID_in_char_key9997_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_varying_key10020_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_varying_key10020( FOLLOW_REGULAR_ID_in_varying_key10020_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_varchar_key10043_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_varchar_key10043( FOLLOW_REGULAR_ID_in_varchar_key10043_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_national_key10065_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_national_key10065( FOLLOW_REGULAR_ID_in_national_key10065_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nchar_key10087_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nchar_key10087( FOLLOW_REGULAR_ID_in_nchar_key10087_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_bit_key10108_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_bit_key10108( FOLLOW_REGULAR_ID_in_bit_key10108_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_float_key10130_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_float_key10130( FOLLOW_REGULAR_ID_in_float_key10130_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_real_key10157_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_real_key10157( FOLLOW_REGULAR_ID_in_real_key10157_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_double_key10180_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_double_key10180( FOLLOW_REGULAR_ID_in_double_key10180_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_precision_key10202_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_precision_key10202( FOLLOW_REGULAR_ID_in_precision_key10202_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_interval_key10225_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_interval_key10225( FOLLOW_REGULAR_ID_in_interval_key10225_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_time_key10247_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_time_key10247( FOLLOW_REGULAR_ID_in_time_key10247_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_zone_key10270_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_zone_key10270( FOLLOW_REGULAR_ID_in_zone_key10270_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timestamp_key10292_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timestamp_key10292( FOLLOW_REGULAR_ID_in_timestamp_key10292_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DATE_in_date_key10312_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DATE_in_date_key10312( FOLLOW_SQL92_RESERVED_DATE_in_date_key10312_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_numeric_key10335_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_numeric_key10335( FOLLOW_REGULAR_ID_in_numeric_key10335_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_decimal_key10358_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_decimal_key10358( FOLLOW_REGULAR_ID_in_decimal_key10358_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dec_key10381_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dec_key10381( FOLLOW_REGULAR_ID_in_dec_key10381_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_integer_key10404_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_integer_key10404( FOLLOW_REGULAR_ID_in_integer_key10404_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_int_key10427_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_int_key10427( FOLLOW_REGULAR_ID_in_int_key10427_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_smallint_key10450_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_smallint_key10450( FOLLOW_REGULAR_ID_in_smallint_key10450_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_corresponding_key10472_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_corresponding_key10472( FOLLOW_REGULAR_ID_in_corresponding_key10472_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cross_key10495_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cross_key10495( FOLLOW_REGULAR_ID_in_cross_key10495_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_join_key10518_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_join_key10518( FOLLOW_REGULAR_ID_in_join_key10518_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_left_key10541_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_left_key10541( FOLLOW_REGULAR_ID_in_left_key10541_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_right_key10564_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_right_key10564( FOLLOW_REGULAR_ID_in_right_key10564_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_inner_key10587_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_inner_key10587( FOLLOW_REGULAR_ID_in_inner_key10587_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_natural_key10610_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_natural_key10610( FOLLOW_REGULAR_ID_in_natural_key10610_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_outer_key10633_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_outer_key10633( FOLLOW_REGULAR_ID_in_outer_key10633_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_USING_in_using_key10653_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_USING_in_using_key10653( FOLLOW_PLSQL_NON_RESERVED_USING_in_using_key10653_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_indicator_key10675_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_indicator_key10675( FOLLOW_REGULAR_ID_in_indicator_key10675_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_user_key10697_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_user_key10697( FOLLOW_REGULAR_ID_in_user_key10697_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_current_user_key10719_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_current_user_key10719( FOLLOW_REGULAR_ID_in_current_user_key10719_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_session_user_key10741_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_session_user_key10741( FOLLOW_REGULAR_ID_in_session_user_key10741_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_system_user_key10763_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_system_user_key10763( FOLLOW_REGULAR_ID_in_system_user_key10763_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_value_key10785_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_value_key10785( FOLLOW_REGULAR_ID_in_value_key10785_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_substring_key10808_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_substring_key10808( FOLLOW_REGULAR_ID_in_substring_key10808_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_upper_key10830_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_upper_key10830( FOLLOW_REGULAR_ID_in_upper_key10830_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_lower_key10852_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_lower_key10852( FOLLOW_REGULAR_ID_in_lower_key10852_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_convert_key10874_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_convert_key10874( FOLLOW_REGULAR_ID_in_convert_key10874_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_translate_key10896_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_translate_key10896( FOLLOW_REGULAR_ID_in_translate_key10896_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_trim_key10918_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_trim_key10918( FOLLOW_REGULAR_ID_in_trim_key10918_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_leading_key10940_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_leading_key10940( FOLLOW_REGULAR_ID_in_leading_key10940_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_trailing_key10962_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_trailing_key10962( FOLLOW_REGULAR_ID_in_trailing_key10962_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_both_key10984_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_both_key10984( FOLLOW_REGULAR_ID_in_both_key10984_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_collate_key11006_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_collate_key11006( FOLLOW_REGULAR_ID_in_collate_key11006_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_position_key11028_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_position_key11028( FOLLOW_REGULAR_ID_in_position_key11028_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_extract_key11050_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_extract_key11050( FOLLOW_REGULAR_ID_in_extract_key11050_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_second_key11072_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_second_key11072( FOLLOW_REGULAR_ID_in_second_key11072_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timezone_hour_key11094_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timezone_hour_key11094( FOLLOW_REGULAR_ID_in_timezone_hour_key11094_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timezone_minute_key11116_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timezone_minute_key11116( FOLLOW_REGULAR_ID_in_timezone_minute_key11116_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_char_length_key11138_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_char_length_key11138( FOLLOW_REGULAR_ID_in_char_length_key11138_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_octet_length_key11160_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_octet_length_key11160( FOLLOW_REGULAR_ID_in_octet_length_key11160_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_character_length_key11182_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_character_length_key11182( FOLLOW_REGULAR_ID_in_character_length_key11182_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_bit_length_key11204_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_bit_length_key11204( FOLLOW_REGULAR_ID_in_bit_length_key11204_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_local_key11226_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_local_key11226( FOLLOW_REGULAR_ID_in_local_key11226_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_current_timestamp_key11248_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_current_timestamp_key11248( FOLLOW_REGULAR_ID_in_current_timestamp_key11248_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_current_date_key11270_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_current_date_key11270( FOLLOW_REGULAR_ID_in_current_date_key11270_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_current_time_key11292_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_current_time_key11292( FOLLOW_REGULAR_ID_in_current_time_key11292_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_module_key11314_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_module_key11314( FOLLOW_REGULAR_ID_in_module_key11314_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_global_key11336_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_global_key11336( FOLLOW_REGULAR_ID_in_global_key11336_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_year_key11359_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_year_key11359( FOLLOW_REGULAR_ID_in_year_key11359_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_month_key11381_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_month_key11381( FOLLOW_REGULAR_ID_in_month_key11381_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_day_key11404_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_day_key11404( FOLLOW_REGULAR_ID_in_day_key11404_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_hour_key11426_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_hour_key11426( FOLLOW_REGULAR_ID_in_hour_key11426_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_minute_key11448_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_minute_key11448( FOLLOW_REGULAR_ID_in_minute_key11448_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_whenever_key11470_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_whenever_key11470( FOLLOW_REGULAR_ID_in_whenever_key11470_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_IS_in_is_key11490_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_IS_in_is_key11490( FOLLOW_SQL92_RESERVED_IS_in_is_key11490_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ELSE_in_else_key11510_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ELSE_in_else_key11510( FOLLOW_SQL92_RESERVED_ELSE_in_else_key11510_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_TABLE_in_table_key11530_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_TABLE_in_table_key11530( FOLLOW_SQL92_RESERVED_TABLE_in_table_key11530_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_THE_in_the_key11550_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_THE_in_the_key11550( FOLLOW_SQL92_RESERVED_THE_in_the_key11550_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_THEN_in_then_key11570_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_THEN_in_then_key11570( FOLLOW_SQL92_RESERVED_THEN_in_then_key11570_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_END_in_end_key11590_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_END_in_end_key11590( FOLLOW_SQL92_RESERVED_END_in_end_key11590_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ALL_in_all_key11610_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ALL_in_all_key11610( FOLLOW_SQL92_RESERVED_ALL_in_all_key11610_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ON_in_on_key11630_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ON_in_on_key11630( FOLLOW_SQL92_RESERVED_ON_in_on_key11630_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_OR_in_or_key11650_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_OR_in_or_key11650( FOLLOW_SQL92_RESERVED_OR_in_or_key11650_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_AND_in_and_key11670_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_AND_in_and_key11670( FOLLOW_SQL92_RESERVED_AND_in_and_key11670_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_NOT_in_not_key11690_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_NOT_in_not_key11690( FOLLOW_SQL92_RESERVED_NOT_in_not_key11690_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_TRUE_in_true_key11710_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_TRUE_in_true_key11710( FOLLOW_SQL92_RESERVED_TRUE_in_true_key11710_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_FALSE_in_false_key11730_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_FALSE_in_false_key11730( FOLLOW_SQL92_RESERVED_FALSE_in_false_key11730_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DEFAULT_in_default_key11750_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DEFAULT_in_default_key11750( FOLLOW_SQL92_RESERVED_DEFAULT_in_default_key11750_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DISTINCT_in_distinct_key11770_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DISTINCT_in_distinct_key11770( FOLLOW_SQL92_RESERVED_DISTINCT_in_distinct_key11770_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_INTO_in_into_key11790_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_INTO_in_into_key11790( FOLLOW_SQL92_RESERVED_INTO_in_into_key11790_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_BY_in_by_key11810_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_BY_in_by_key11810( FOLLOW_SQL92_RESERVED_BY_in_by_key11810_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_AS_in_as_key11830_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_AS_in_as_key11830( FOLLOW_SQL92_RESERVED_AS_in_as_key11830_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_IN_in_in_key11850_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_IN_in_in_key11850( FOLLOW_SQL92_RESERVED_IN_in_in_key11850_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_OF_in_of_key11870_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_OF_in_of_key11870( FOLLOW_SQL92_RESERVED_OF_in_of_key11870_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_NULL_in_null_key11890_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_NULL_in_null_key11890( FOLLOW_SQL92_RESERVED_NULL_in_null_key11890_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_FOR_in_for_key11910_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_FOR_in_for_key11910( FOLLOW_SQL92_RESERVED_FOR_in_for_key11910_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_SELECT_in_select_key11930_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_SELECT_in_select_key11930( FOLLOW_SQL92_RESERVED_SELECT_in_select_key11930_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_WHEN_in_when_key11950_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_WHEN_in_when_key11950( FOLLOW_SQL92_RESERVED_WHEN_in_when_key11950_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DELETE_in_delete_key11970_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DELETE_in_delete_key11970( FOLLOW_SQL92_RESERVED_DELETE_in_delete_key11970_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_BETWEEN_in_between_key11990_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_BETWEEN_in_between_key11990( FOLLOW_SQL92_RESERVED_BETWEEN_in_between_key11990_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_LIKE_in_like_key12010_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_LIKE_in_like_key12010( FOLLOW_SQL92_RESERVED_LIKE_in_like_key12010_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_FROM_in_from_key12030_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_FROM_in_from_key12030( FOLLOW_SQL92_RESERVED_FROM_in_from_key12030_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_WHERE_in_where_key12050_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_WHERE_in_where_key12050( FOLLOW_SQL92_RESERVED_WHERE_in_where_key12050_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sequence_key12072_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sequence_key12072( FOLLOW_REGULAR_ID_in_sequence_key12072_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_noorder_key12094_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_noorder_key12094( FOLLOW_REGULAR_ID_in_noorder_key12094_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cycle_key12116_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cycle_key12116( FOLLOW_REGULAR_ID_in_cycle_key12116_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cache_key12138_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cache_key12138( FOLLOW_REGULAR_ID_in_cache_key12138_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nocache_key12160_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nocache_key12160( FOLLOW_REGULAR_ID_in_nocache_key12160_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nomaxvalue_key12182_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nomaxvalue_key12182( FOLLOW_REGULAR_ID_in_nomaxvalue_key12182_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nominvalue_key12204_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nominvalue_key12204( FOLLOW_REGULAR_ID_in_nominvalue_key12204_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_search_key12226_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_search_key12226( FOLLOW_REGULAR_ID_in_search_key12226_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_depth_key12248_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_depth_key12248( FOLLOW_REGULAR_ID_in_depth_key12248_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_breadth_key12270_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_breadth_key12270( FOLLOW_REGULAR_ID_in_breadth_key12270_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start create_key
 * PLSQLKeys.g:38:1: create_key : SQL92_RESERVED_CREATE ;
 */
void
PLSQLParser_PLSQLKeys::create_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:39:5: ( SQL92_RESERVED_CREATE )
        // PLSQLKeys.g:39:10: SQL92_RESERVED_CREATE
        {
             this->matchToken(SQL92_RESERVED_CREATE, &FOLLOW_SQL92_RESERVED_CREATE_in_create_key48);
            if  (this->hasException())
            {
                goto rulecreate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecreate_keyEx; /* Prevent compiler warnings */
    rulecreate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end create_key */

/**
 * $ANTLR start replace_key
 * PLSQLKeys.g:42:1: replace_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::replace_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:44:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:44:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "REPLACE" ))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"REPLACE\" )" );
                    ex->set_ruleName( "replace_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_replace_key78);
            if  (this->hasException())
            {
                goto rulereplace_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereplace_keyEx; /* Prevent compiler warnings */
    rulereplace_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end replace_key */

/**
 * $ANTLR start package_key
 * PLSQLKeys.g:47:1: package_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::package_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:48:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:48:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PACKAGE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PACKAGE\")" );
                    ex->set_ruleName( "package_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_package_key101);
            if  (this->hasException())
            {
                goto rulepackage_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepackage_keyEx; /* Prevent compiler warnings */
    rulepackage_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end package_key */

/**
 * $ANTLR start body_key
 * PLSQLKeys.g:51:1: body_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::body_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:52:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:52:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BODY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BODY\")" );
                    ex->set_ruleName( "body_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_body_key123);
            if  (this->hasException())
            {
                goto rulebody_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebody_keyEx; /* Prevent compiler warnings */
    rulebody_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end body_key */

/**
 * $ANTLR start begin_key
 * PLSQLKeys.g:55:1: begin_key : SQL92_RESERVED_BEGIN ;
 */
void
PLSQLParser_PLSQLKeys::begin_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:56:5: ( SQL92_RESERVED_BEGIN )
        // PLSQLKeys.g:56:10: SQL92_RESERVED_BEGIN
        {
             this->matchToken(SQL92_RESERVED_BEGIN, &FOLLOW_SQL92_RESERVED_BEGIN_in_begin_key143);
            if  (this->hasException())
            {
                goto rulebegin_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebegin_keyEx; /* Prevent compiler warnings */
    rulebegin_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end begin_key */

/**
 * $ANTLR start exit_key
 * PLSQLKeys.g:59:1: exit_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::exit_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:60:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:60:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXIT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXIT\")" );
                    ex->set_ruleName( "exit_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_exit_key165);
            if  (this->hasException())
            {
                goto ruleexit_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexit_keyEx; /* Prevent compiler warnings */
    ruleexit_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exit_key */

/**
 * $ANTLR start declare_key
 * PLSQLKeys.g:63:1: declare_key : SQL92_RESERVED_DECLARE ;
 */
void
PLSQLParser_PLSQLKeys::declare_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:64:5: ( SQL92_RESERVED_DECLARE )
        // PLSQLKeys.g:64:10: SQL92_RESERVED_DECLARE
        {
             this->matchToken(SQL92_RESERVED_DECLARE, &FOLLOW_SQL92_RESERVED_DECLARE_in_declare_key185);
            if  (this->hasException())
            {
                goto ruledeclare_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledeclare_keyEx; /* Prevent compiler warnings */
    ruledeclare_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end declare_key */

/**
 * $ANTLR start exception_key
 * PLSQLKeys.g:67:1: exception_key : SQL92_RESERVED_EXCEPTION ;
 */
void
PLSQLParser_PLSQLKeys::exception_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:68:5: ( SQL92_RESERVED_EXCEPTION )
        // PLSQLKeys.g:68:10: SQL92_RESERVED_EXCEPTION
        {
             this->matchToken(SQL92_RESERVED_EXCEPTION, &FOLLOW_SQL92_RESERVED_EXCEPTION_in_exception_key205);
            if  (this->hasException())
            {
                goto ruleexception_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexception_keyEx; /* Prevent compiler warnings */
    ruleexception_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exception_key */

/**
 * $ANTLR start serveroutput_key
 * PLSQLKeys.g:71:1: serveroutput_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::serveroutput_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:72:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:72:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SERVEROUTPUT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SERVEROUTPUT\")" );
                    ex->set_ruleName( "serveroutput_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_serveroutput_key227);
            if  (this->hasException())
            {
                goto ruleserveroutput_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleserveroutput_keyEx; /* Prevent compiler warnings */
    ruleserveroutput_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end serveroutput_key */

/**
 * $ANTLR start off_key
 * PLSQLKeys.g:75:1: off_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::off_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:76:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:76:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OFF"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OFF\")" );
                    ex->set_ruleName( "off_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_off_key249);
            if  (this->hasException())
            {
                goto ruleoff_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleoff_keyEx; /* Prevent compiler warnings */
    ruleoff_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end off_key */

/**
 * $ANTLR start constant_key
 * PLSQLKeys.g:79:1: constant_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::constant_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:80:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:80:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CONSTANT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CONSTANT\")" );
                    ex->set_ruleName( "constant_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_constant_key271);
            if  (this->hasException())
            {
                goto ruleconstant_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconstant_keyEx; /* Prevent compiler warnings */
    ruleconstant_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end constant_key */

/**
 * $ANTLR start subtype_key
 * PLSQLKeys.g:83:1: subtype_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::subtype_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:84:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:84:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SUBTYPE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SUBTYPE\")" );
                    ex->set_ruleName( "subtype_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_subtype_key293);
            if  (this->hasException())
            {
                goto rulesubtype_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubtype_keyEx; /* Prevent compiler warnings */
    rulesubtype_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end subtype_key */

/**
 * $ANTLR start cursor_key
 * PLSQLKeys.g:87:1: cursor_key : SQL92_RESERVED_CURSOR ;
 */
void
PLSQLParser_PLSQLKeys::cursor_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:88:5: ( SQL92_RESERVED_CURSOR )
        // PLSQLKeys.g:88:10: SQL92_RESERVED_CURSOR
        {
             this->matchToken(SQL92_RESERVED_CURSOR, &FOLLOW_SQL92_RESERVED_CURSOR_in_cursor_key313);
            if  (this->hasException())
            {
                goto rulecursor_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecursor_keyEx; /* Prevent compiler warnings */
    rulecursor_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cursor_key */

/**
 * $ANTLR start nextval_key
 * PLSQLKeys.g:91:1: nextval_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nextval_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:92:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:92:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NEXTVAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NEXTVAL\")" );
                    ex->set_ruleName( "nextval_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nextval_key336);
            if  (this->hasException())
            {
                goto rulenextval_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenextval_keyEx; /* Prevent compiler warnings */
    rulenextval_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nextval_key */

/**
 * $ANTLR start goto_key
 * PLSQLKeys.g:95:1: goto_key : SQL92_RESERVED_GOTO ;
 */
void
PLSQLParser_PLSQLKeys::goto_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:96:5: ( SQL92_RESERVED_GOTO )
        // PLSQLKeys.g:96:10: SQL92_RESERVED_GOTO
        {
             this->matchToken(SQL92_RESERVED_GOTO, &FOLLOW_SQL92_RESERVED_GOTO_in_goto_key356);
            if  (this->hasException())
            {
                goto rulegoto_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulegoto_keyEx; /* Prevent compiler warnings */
    rulegoto_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end goto_key */

/**
 * $ANTLR start execute_key
 * PLSQLKeys.g:99:1: execute_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::execute_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:100:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:100:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXECUTE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXECUTE\")" );
                    ex->set_ruleName( "execute_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_execute_key378);
            if  (this->hasException())
            {
                goto ruleexecute_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexecute_keyEx; /* Prevent compiler warnings */
    ruleexecute_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end execute_key */

/**
 * $ANTLR start immediate_key
 * PLSQLKeys.g:103:1: immediate_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::immediate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:104:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:104:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "IMMEDIATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"IMMEDIATE\")" );
                    ex->set_ruleName( "immediate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_immediate_key401);
            if  (this->hasException())
            {
                goto ruleimmediate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleimmediate_keyEx; /* Prevent compiler warnings */
    ruleimmediate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end immediate_key */

/**
 * $ANTLR start return_key
 * PLSQLKeys.g:107:1: return_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::return_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:108:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:108:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RETURN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RETURN\")" );
                    ex->set_ruleName( "return_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_return_key423);
            if  (this->hasException())
            {
                goto rulereturn_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereturn_keyEx; /* Prevent compiler warnings */
    rulereturn_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end return_key */

/**
 * $ANTLR start procedure_key
 * PLSQLKeys.g:111:1: procedure_key : SQL92_RESERVED_PROCEDURE ;
 */
void
PLSQLParser_PLSQLKeys::procedure_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:112:5: ( SQL92_RESERVED_PROCEDURE )
        // PLSQLKeys.g:112:10: SQL92_RESERVED_PROCEDURE
        {
             this->matchToken(SQL92_RESERVED_PROCEDURE, &FOLLOW_SQL92_RESERVED_PROCEDURE_in_procedure_key443);
            if  (this->hasException())
            {
                goto ruleprocedure_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprocedure_keyEx; /* Prevent compiler warnings */
    ruleprocedure_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end procedure_key */

/**
 * $ANTLR start function_key
 * PLSQLKeys.g:115:1: function_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::function_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:116:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:116:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FUNCTION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FUNCTION\")" );
                    ex->set_ruleName( "function_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_function_key466);
            if  (this->hasException())
            {
                goto rulefunction_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunction_keyEx; /* Prevent compiler warnings */
    rulefunction_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end function_key */

/**
 * $ANTLR start pragma_key
 * PLSQLKeys.g:119:1: pragma_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::pragma_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:120:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:120:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PRAGMA"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PRAGMA\")" );
                    ex->set_ruleName( "pragma_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_pragma_key488);
            if  (this->hasException())
            {
                goto rulepragma_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepragma_keyEx; /* Prevent compiler warnings */
    rulepragma_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pragma_key */

/**
 * $ANTLR start exception_init_key
 * PLSQLKeys.g:123:1: exception_init_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::exception_init_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:124:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:124:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXCEPTION_INIT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXCEPTION_INIT\")" );
                    ex->set_ruleName( "exception_init_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_exception_init_key510);
            if  (this->hasException())
            {
                goto ruleexception_init_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexception_init_keyEx; /* Prevent compiler warnings */
    ruleexception_init_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exception_init_key */

/**
 * $ANTLR start type_key
 * PLSQLKeys.g:127:1: type_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::type_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:128:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:128:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TYPE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TYPE\")" );
                    ex->set_ruleName( "type_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_type_key533);
            if  (this->hasException())
            {
                goto ruletype_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletype_keyEx; /* Prevent compiler warnings */
    ruletype_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end type_key */

/**
 * $ANTLR start record_key
 * PLSQLKeys.g:131:1: record_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::record_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:132:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:132:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RECORD"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RECORD\")" );
                    ex->set_ruleName( "record_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_record_key556);
            if  (this->hasException())
            {
                goto rulerecord_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerecord_keyEx; /* Prevent compiler warnings */
    rulerecord_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end record_key */

/**
 * $ANTLR start indexed_key
 * PLSQLKeys.g:135:1: indexed_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::indexed_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:136:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:136:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INDEXED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INDEXED\")" );
                    ex->set_ruleName( "indexed_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_indexed_key578);
            if  (this->hasException())
            {
                goto ruleindexed_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleindexed_keyEx; /* Prevent compiler warnings */
    ruleindexed_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end indexed_key */

/**
 * $ANTLR start index_key
 * PLSQLKeys.g:139:1: index_key : PLSQL_RESERVED_INDEX ;
 */
void
PLSQLParser_PLSQLKeys::index_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:140:5: ( PLSQL_RESERVED_INDEX )
        // PLSQLKeys.g:140:10: PLSQL_RESERVED_INDEX
        {
             this->matchToken(PLSQL_RESERVED_INDEX, &FOLLOW_PLSQL_RESERVED_INDEX_in_index_key598);
            if  (this->hasException())
            {
                goto ruleindex_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleindex_keyEx; /* Prevent compiler warnings */
    ruleindex_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end index_key */

/**
 * $ANTLR start percent_notfound_key
 * PLSQLKeys.g:143:1: percent_notfound_key :{...}? => PERCENT REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::percent_notfound_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:144:5: ({...}? => PERCENT REGULAR_ID )
        // PLSQLKeys.g:144:10: {...}? => PERCENT REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(2)->getText(), "NOTFOUND"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(2)->getText(), \"NOTFOUND\")" );
                    ex->set_ruleName( "percent_notfound_key" );


            }

             this->matchToken(PERCENT, &FOLLOW_PERCENT_in_percent_notfound_key621);
            if  (this->hasException())
            {
                goto rulepercent_notfound_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_percent_notfound_key623);
            if  (this->hasException())
            {
                goto rulepercent_notfound_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepercent_notfound_keyEx; /* Prevent compiler warnings */
    rulepercent_notfound_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end percent_notfound_key */

/**
 * $ANTLR start percent_found_key
 * PLSQLKeys.g:147:1: percent_found_key :{...}? => PERCENT REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::percent_found_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:148:5: ({...}? => PERCENT REGULAR_ID )
        // PLSQLKeys.g:148:10: {...}? => PERCENT REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(2)->getText(), "FOUND"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(2)->getText(), \"FOUND\")" );
                    ex->set_ruleName( "percent_found_key" );


            }

             this->matchToken(PERCENT, &FOLLOW_PERCENT_in_percent_found_key646);
            if  (this->hasException())
            {
                goto rulepercent_found_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_percent_found_key648);
            if  (this->hasException())
            {
                goto rulepercent_found_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepercent_found_keyEx; /* Prevent compiler warnings */
    rulepercent_found_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end percent_found_key */

/**
 * $ANTLR start percent_isopen_key
 * PLSQLKeys.g:151:1: percent_isopen_key :{...}? => PERCENT REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::percent_isopen_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:152:5: ({...}? => PERCENT REGULAR_ID )
        // PLSQLKeys.g:152:10: {...}? => PERCENT REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(2)->getText(), "ISOPEN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(2)->getText(), \"ISOPEN\")" );
                    ex->set_ruleName( "percent_isopen_key" );


            }

             this->matchToken(PERCENT, &FOLLOW_PERCENT_in_percent_isopen_key671);
            if  (this->hasException())
            {
                goto rulepercent_isopen_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_percent_isopen_key673);
            if  (this->hasException())
            {
                goto rulepercent_isopen_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepercent_isopen_keyEx; /* Prevent compiler warnings */
    rulepercent_isopen_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end percent_isopen_key */

/**
 * $ANTLR start percent_rowcount_key
 * PLSQLKeys.g:155:1: percent_rowcount_key :{...}? => PERCENT REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::percent_rowcount_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:156:5: ({...}? => PERCENT REGULAR_ID )
        // PLSQLKeys.g:156:10: {...}? => PERCENT REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(2)->getText(), "ROWCOUNT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(2)->getText(), \"ROWCOUNT\")" );
                    ex->set_ruleName( "percent_rowcount_key" );


            }

             this->matchToken(PERCENT, &FOLLOW_PERCENT_in_percent_rowcount_key696);
            if  (this->hasException())
            {
                goto rulepercent_rowcount_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_percent_rowcount_key698);
            if  (this->hasException())
            {
                goto rulepercent_rowcount_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepercent_rowcount_keyEx; /* Prevent compiler warnings */
    rulepercent_rowcount_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end percent_rowcount_key */

/**
 * $ANTLR start percent_rowtype_key
 * PLSQLKeys.g:159:1: percent_rowtype_key :{...}? => PERCENT REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::percent_rowtype_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:160:5: ({...}? => PERCENT REGULAR_ID )
        // PLSQLKeys.g:160:10: {...}? => PERCENT REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(2)->getText(), "ROWTYPE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(2)->getText(), \"ROWTYPE\")" );
                    ex->set_ruleName( "percent_rowtype_key" );


            }

             this->matchToken(PERCENT, &FOLLOW_PERCENT_in_percent_rowtype_key721);
            if  (this->hasException())
            {
                goto rulepercent_rowtype_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_percent_rowtype_key723);
            if  (this->hasException())
            {
                goto rulepercent_rowtype_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepercent_rowtype_keyEx; /* Prevent compiler warnings */
    rulepercent_rowtype_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end percent_rowtype_key */

/**
 * $ANTLR start percent_type_key
 * PLSQLKeys.g:163:1: percent_type_key :{...}? => PERCENT REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::percent_type_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:164:5: ({...}? => PERCENT REGULAR_ID )
        // PLSQLKeys.g:164:10: {...}? => PERCENT REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(2)->getText(), "TYPE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(2)->getText(), \"TYPE\")" );
                    ex->set_ruleName( "percent_type_key" );


            }

             this->matchToken(PERCENT, &FOLLOW_PERCENT_in_percent_type_key747);
            if  (this->hasException())
            {
                goto rulepercent_type_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_percent_type_key749);
            if  (this->hasException())
            {
                goto rulepercent_type_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepercent_type_keyEx; /* Prevent compiler warnings */
    rulepercent_type_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end percent_type_key */

/**
 * $ANTLR start out_key
 * PLSQLKeys.g:167:1: out_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::out_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:168:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:168:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OUT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OUT\")" );
                    ex->set_ruleName( "out_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_out_key772);
            if  (this->hasException())
            {
                goto ruleout_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleout_keyEx; /* Prevent compiler warnings */
    ruleout_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end out_key */

/**
 * $ANTLR start inout_key
 * PLSQLKeys.g:171:1: inout_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::inout_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:172:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:172:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INOUT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INOUT\")" );
                    ex->set_ruleName( "inout_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_inout_key794);
            if  (this->hasException())
            {
                goto ruleinout_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinout_keyEx; /* Prevent compiler warnings */
    ruleinout_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end inout_key */

/**
 * $ANTLR start extend_key
 * PLSQLKeys.g:175:1: extend_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::extend_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:176:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:176:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXTEND"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXTEND\")" );
                    ex->set_ruleName( "extend_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_extend_key817);
            if  (this->hasException())
            {
                goto ruleextend_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleextend_keyEx; /* Prevent compiler warnings */
    ruleextend_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end extend_key */

/**
 * $ANTLR start raise_key
 * PLSQLKeys.g:179:1: raise_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::raise_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:180:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:180:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RAISE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RAISE\")" );
                    ex->set_ruleName( "raise_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_raise_key839);
            if  (this->hasException())
            {
                goto ruleraise_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleraise_keyEx; /* Prevent compiler warnings */
    ruleraise_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end raise_key */

/**
 * $ANTLR start while_key
 * PLSQLKeys.g:183:1: while_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::while_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:184:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:184:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "WHILE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"WHILE\")" );
                    ex->set_ruleName( "while_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_while_key861);
            if  (this->hasException())
            {
                goto rulewhile_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewhile_keyEx; /* Prevent compiler warnings */
    rulewhile_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end while_key */

/**
 * $ANTLR start loop_key
 * PLSQLKeys.g:187:1: loop_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::loop_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:188:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:188:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LOOP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LOOP\")" );
                    ex->set_ruleName( "loop_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_loop_key883);
            if  (this->hasException())
            {
                goto ruleloop_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleloop_keyEx; /* Prevent compiler warnings */
    ruleloop_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end loop_key */

/**
 * $ANTLR start commit_key
 * PLSQLKeys.g:191:1: commit_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::commit_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:192:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:192:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COMMIT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COMMIT\")" );
                    ex->set_ruleName( "commit_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_commit_key906);
            if  (this->hasException())
            {
                goto rulecommit_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecommit_keyEx; /* Prevent compiler warnings */
    rulecommit_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end commit_key */

/**
 * $ANTLR start work_key
 * PLSQLKeys.g:195:1: work_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::work_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:196:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:196:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "WORK"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"WORK\")" );
                    ex->set_ruleName( "work_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_work_key928);
            if  (this->hasException())
            {
                goto rulework_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulework_keyEx; /* Prevent compiler warnings */
    rulework_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end work_key */

/**
 * $ANTLR start if_key
 * PLSQLKeys.g:199:1: if_key : PLSQL_RESERVED_IF ;
 */
void
PLSQLParser_PLSQLKeys::if_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:200:5: ( PLSQL_RESERVED_IF )
        // PLSQLKeys.g:200:10: PLSQL_RESERVED_IF
        {
             this->matchToken(PLSQL_RESERVED_IF, &FOLLOW_PLSQL_RESERVED_IF_in_if_key948);
            if  (this->hasException())
            {
                goto ruleif_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleif_keyEx; /* Prevent compiler warnings */
    ruleif_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end if_key */

/**
 * $ANTLR start elsif_key
 * PLSQLKeys.g:203:1: elsif_key : PLSQL_NON_RESERVED_ELSIF ;
 */
void
PLSQLParser_PLSQLKeys::elsif_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:204:5: ( PLSQL_NON_RESERVED_ELSIF )
        // PLSQLKeys.g:204:10: PLSQL_NON_RESERVED_ELSIF
        {
             this->matchToken(PLSQL_NON_RESERVED_ELSIF, &FOLLOW_PLSQL_NON_RESERVED_ELSIF_in_elsif_key968);
            if  (this->hasException())
            {
                goto ruleelsif_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleelsif_keyEx; /* Prevent compiler warnings */
    ruleelsif_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end elsif_key */

/**
 * $ANTLR start authid_key
 * PLSQLKeys.g:207:1: authid_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::authid_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:208:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:208:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AUTHID"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AUTHID\")" );
                    ex->set_ruleName( "authid_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_authid_key991);
            if  (this->hasException())
            {
                goto ruleauthid_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleauthid_keyEx; /* Prevent compiler warnings */
    ruleauthid_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end authid_key */

/**
 * $ANTLR start definer_key
 * PLSQLKeys.g:211:1: definer_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::definer_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:212:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:212:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DEFINER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DEFINER\")" );
                    ex->set_ruleName( "definer_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_definer_key1013);
            if  (this->hasException())
            {
                goto ruledefiner_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledefiner_keyEx; /* Prevent compiler warnings */
    ruledefiner_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end definer_key */

/**
 * $ANTLR start external_key
 * PLSQLKeys.g:215:1: external_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::external_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:216:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:216:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXTERNAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXTERNAL\")" );
                    ex->set_ruleName( "external_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_external_key1035);
            if  (this->hasException())
            {
                goto ruleexternal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexternal_keyEx; /* Prevent compiler warnings */
    ruleexternal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end external_key */

/**
 * $ANTLR start language_key
 * PLSQLKeys.g:219:1: language_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::language_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:220:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:220:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LANGUAGE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LANGUAGE\")" );
                    ex->set_ruleName( "language_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_language_key1057);
            if  (this->hasException())
            {
                goto rulelanguage_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelanguage_keyEx; /* Prevent compiler warnings */
    rulelanguage_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end language_key */

/**
 * $ANTLR start java_key
 * PLSQLKeys.g:223:1: java_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::java_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:224:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:224:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "JAVA"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"JAVA\")" );
                    ex->set_ruleName( "java_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_java_key1079);
            if  (this->hasException())
            {
                goto rulejava_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulejava_keyEx; /* Prevent compiler warnings */
    rulejava_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end java_key */

/**
 * $ANTLR start name_key
 * PLSQLKeys.g:227:1: name_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::name_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:228:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:228:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NAME"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NAME\")" );
                    ex->set_ruleName( "name_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_name_key1102);
            if  (this->hasException())
            {
                goto rulename_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulename_keyEx; /* Prevent compiler warnings */
    rulename_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end name_key */

/**
 * $ANTLR start deterministic_key
 * PLSQLKeys.g:231:1: deterministic_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::deterministic_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:232:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:232:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DETERMINISTIC"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DETERMINISTIC\")" );
                    ex->set_ruleName( "deterministic_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_deterministic_key1125);
            if  (this->hasException())
            {
                goto ruledeterministic_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledeterministic_keyEx; /* Prevent compiler warnings */
    ruledeterministic_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end deterministic_key */

/**
 * $ANTLR start parallel_enable_key
 * PLSQLKeys.g:235:1: parallel_enable_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::parallel_enable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:236:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:236:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PARALLEL_ENABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PARALLEL_ENABLE\")" );
                    ex->set_ruleName( "parallel_enable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_parallel_enable_key1148);
            if  (this->hasException())
            {
                goto ruleparallel_enable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleparallel_enable_keyEx; /* Prevent compiler warnings */
    ruleparallel_enable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end parallel_enable_key */

/**
 * $ANTLR start result_cache_key
 * PLSQLKeys.g:239:1: result_cache_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::result_cache_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:240:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:240:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RESULT_CACHE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RESULT_CACHE\")" );
                    ex->set_ruleName( "result_cache_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_result_cache_key1171);
            if  (this->hasException())
            {
                goto ruleresult_cache_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleresult_cache_keyEx; /* Prevent compiler warnings */
    ruleresult_cache_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end result_cache_key */

/**
 * $ANTLR start pipelined_key
 * PLSQLKeys.g:243:1: pipelined_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::pipelined_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:244:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:244:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PIPELINED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PIPELINED\")" );
                    ex->set_ruleName( "pipelined_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_pipelined_key1194);
            if  (this->hasException())
            {
                goto rulepipelined_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepipelined_keyEx; /* Prevent compiler warnings */
    rulepipelined_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pipelined_key */

/**
 * $ANTLR start aggregate_key
 * PLSQLKeys.g:247:1: aggregate_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::aggregate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:248:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:248:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AGGREGATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AGGREGATE\")" );
                    ex->set_ruleName( "aggregate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_aggregate_key1216);
            if  (this->hasException())
            {
                goto ruleaggregate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleaggregate_keyEx; /* Prevent compiler warnings */
    ruleaggregate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end aggregate_key */

/**
 * $ANTLR start alter_key
 * PLSQLKeys.g:251:1: alter_key : SQL92_RESERVED_ALTER ;
 */
void
PLSQLParser_PLSQLKeys::alter_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:252:5: ( SQL92_RESERVED_ALTER )
        // PLSQLKeys.g:252:10: SQL92_RESERVED_ALTER
        {
             this->matchToken(SQL92_RESERVED_ALTER, &FOLLOW_SQL92_RESERVED_ALTER_in_alter_key1236);
            if  (this->hasException())
            {
                goto rulealter_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealter_keyEx; /* Prevent compiler warnings */
    rulealter_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end alter_key */

/**
 * $ANTLR start compile_key
 * PLSQLKeys.g:255:1: compile_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::compile_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:256:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:256:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COMPILE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COMPILE\")" );
                    ex->set_ruleName( "compile_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_compile_key1258);
            if  (this->hasException())
            {
                goto rulecompile_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecompile_keyEx; /* Prevent compiler warnings */
    rulecompile_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end compile_key */

/**
 * $ANTLR start debug_key
 * PLSQLKeys.g:259:1: debug_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::debug_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:260:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:260:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DEBUG"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DEBUG\")" );
                    ex->set_ruleName( "debug_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_debug_key1281);
            if  (this->hasException())
            {
                goto ruledebug_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledebug_keyEx; /* Prevent compiler warnings */
    ruledebug_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end debug_key */

/**
 * $ANTLR start reuse_key
 * PLSQLKeys.g:263:1: reuse_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::reuse_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:264:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:264:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "REUSE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"REUSE\")" );
                    ex->set_ruleName( "reuse_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_reuse_key1303);
            if  (this->hasException())
            {
                goto rulereuse_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereuse_keyEx; /* Prevent compiler warnings */
    rulereuse_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end reuse_key */

/**
 * $ANTLR start settings_key
 * PLSQLKeys.g:267:1: settings_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::settings_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:268:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:268:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SETTINGS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SETTINGS\")" );
                    ex->set_ruleName( "settings_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_settings_key1325);
            if  (this->hasException())
            {
                goto rulesettings_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesettings_keyEx; /* Prevent compiler warnings */
    rulesettings_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end settings_key */

/**
 * $ANTLR start specification_key
 * PLSQLKeys.g:271:1: specification_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::specification_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:272:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:272:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SPECIFICATION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SPECIFICATION\")" );
                    ex->set_ruleName( "specification_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_specification_key1347);
            if  (this->hasException())
            {
                goto rulespecification_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulespecification_keyEx; /* Prevent compiler warnings */
    rulespecification_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end specification_key */

/**
 * $ANTLR start drop_key
 * PLSQLKeys.g:275:1: drop_key : SQL92_RESERVED_DROP ;
 */
void
PLSQLParser_PLSQLKeys::drop_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:276:5: ( SQL92_RESERVED_DROP )
        // PLSQLKeys.g:276:10: SQL92_RESERVED_DROP
        {
             this->matchToken(SQL92_RESERVED_DROP, &FOLLOW_SQL92_RESERVED_DROP_in_drop_key1367);
            if  (this->hasException())
            {
                goto ruledrop_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledrop_keyEx; /* Prevent compiler warnings */
    ruledrop_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end drop_key */

/**
 * $ANTLR start trigger_key
 * PLSQLKeys.g:279:1: trigger_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::trigger_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:280:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:280:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TRIGGER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TRIGGER\")" );
                    ex->set_ruleName( "trigger_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_trigger_key1390);
            if  (this->hasException())
            {
                goto ruletrigger_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletrigger_keyEx; /* Prevent compiler warnings */
    ruletrigger_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end trigger_key */

/**
 * $ANTLR start force_key
 * PLSQLKeys.g:283:1: force_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::force_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:284:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:284:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FORCE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FORCE\")" );
                    ex->set_ruleName( "force_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_force_key1413);
            if  (this->hasException())
            {
                goto ruleforce_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleforce_keyEx; /* Prevent compiler warnings */
    ruleforce_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end force_key */

/**
 * $ANTLR start validate_key
 * PLSQLKeys.g:287:1: validate_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::validate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:288:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:288:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VALIDATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VALIDATE\")" );
                    ex->set_ruleName( "validate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_validate_key1435);
            if  (this->hasException())
            {
                goto rulevalidate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevalidate_keyEx; /* Prevent compiler warnings */
    rulevalidate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end validate_key */

/**
 * $ANTLR start ref_key
 * PLSQLKeys.g:291:1: ref_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::ref_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:292:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:292:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "REF"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"REF\")" );
                    ex->set_ruleName( "ref_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ref_key1458);
            if  (this->hasException())
            {
                goto ruleref_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleref_keyEx; /* Prevent compiler warnings */
    ruleref_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end ref_key */

/**
 * $ANTLR start array_key
 * PLSQLKeys.g:295:1: array_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::array_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:296:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:296:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ARRAY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ARRAY\")" );
                    ex->set_ruleName( "array_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_array_key1481);
            if  (this->hasException())
            {
                goto rulearray_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulearray_keyEx; /* Prevent compiler warnings */
    rulearray_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end array_key */

/**
 * $ANTLR start varray_key
 * PLSQLKeys.g:299:1: varray_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::varray_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:300:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:300:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VARRAY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VARRAY\")" );
                    ex->set_ruleName( "varray_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_varray_key1504);
            if  (this->hasException())
            {
                goto rulevarray_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevarray_keyEx; /* Prevent compiler warnings */
    rulevarray_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end varray_key */

/**
 * $ANTLR start pls_integer_key
 * PLSQLKeys.g:303:1: pls_integer_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::pls_integer_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:304:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:304:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PLS_INTEGER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PLS_INTEGER\")" );
                    ex->set_ruleName( "pls_integer_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_pls_integer_key1527);
            if  (this->hasException())
            {
                goto rulepls_integer_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepls_integer_keyEx; /* Prevent compiler warnings */
    rulepls_integer_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pls_integer_key */

/**
 * $ANTLR start serially_reusable_key
 * PLSQLKeys.g:307:1: serially_reusable_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::serially_reusable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:308:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:308:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SERIALLY_REUSABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SERIALLY_REUSABLE\")" );
                    ex->set_ruleName( "serially_reusable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_serially_reusable_key1550);
            if  (this->hasException())
            {
                goto ruleserially_reusable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleserially_reusable_keyEx; /* Prevent compiler warnings */
    ruleserially_reusable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end serially_reusable_key */

/**
 * $ANTLR start autonomous_transaction_key
 * PLSQLKeys.g:311:1: autonomous_transaction_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::autonomous_transaction_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:312:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:312:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AUTONOMOUS_TRANSACTION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AUTONOMOUS_TRANSACTION\")" );
                    ex->set_ruleName( "autonomous_transaction_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_autonomous_transaction_key1573);
            if  (this->hasException())
            {
                goto ruleautonomous_transaction_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleautonomous_transaction_keyEx; /* Prevent compiler warnings */
    ruleautonomous_transaction_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end autonomous_transaction_key */

/**
 * $ANTLR start inline_key
 * PLSQLKeys.g:315:1: inline_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::inline_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:316:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:316:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INLINE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INLINE\")" );
                    ex->set_ruleName( "inline_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_inline_key1596);
            if  (this->hasException())
            {
                goto ruleinline_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinline_keyEx; /* Prevent compiler warnings */
    ruleinline_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end inline_key */

/**
 * $ANTLR start restrict_references_key
 * PLSQLKeys.g:319:1: restrict_references_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::restrict_references_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:320:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:320:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RESTRICT_REFERENCES\")" );
                    ex->set_ruleName( "restrict_references_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_restrict_references_key1619);
            if  (this->hasException())
            {
                goto rulerestrict_references_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerestrict_references_keyEx; /* Prevent compiler warnings */
    rulerestrict_references_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end restrict_references_key */

/**
 * $ANTLR start exceptions_key
 * PLSQLKeys.g:323:1: exceptions_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::exceptions_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:324:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:324:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXCEPTIONS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXCEPTIONS\")" );
                    ex->set_ruleName( "exceptions_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_exceptions_key1642);
            if  (this->hasException())
            {
                goto ruleexceptions_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexceptions_keyEx; /* Prevent compiler warnings */
    ruleexceptions_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exceptions_key */

/**
 * $ANTLR start save_key
 * PLSQLKeys.g:327:1: save_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::save_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:328:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:328:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SAVE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SAVE\")" );
                    ex->set_ruleName( "save_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_save_key1666);
            if  (this->hasException())
            {
                goto rulesave_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesave_keyEx; /* Prevent compiler warnings */
    rulesave_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end save_key */

/**
 * $ANTLR start forall_key
 * PLSQLKeys.g:331:1: forall_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::forall_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:332:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:332:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FORALL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FORALL\")" );
                    ex->set_ruleName( "forall_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_forall_key1689);
            if  (this->hasException())
            {
                goto ruleforall_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleforall_keyEx; /* Prevent compiler warnings */
    ruleforall_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end forall_key */

/**
 * $ANTLR start continue_key
 * PLSQLKeys.g:335:1: continue_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::continue_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:336:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:336:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CONTINUE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CONTINUE\")" );
                    ex->set_ruleName( "continue_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_continue_key1712);
            if  (this->hasException())
            {
                goto rulecontinue_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecontinue_keyEx; /* Prevent compiler warnings */
    rulecontinue_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end continue_key */

/**
 * $ANTLR start indices_key
 * PLSQLKeys.g:339:1: indices_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::indices_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:340:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:340:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INDICES"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INDICES\")" );
                    ex->set_ruleName( "indices_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_indices_key1735);
            if  (this->hasException())
            {
                goto ruleindices_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleindices_keyEx; /* Prevent compiler warnings */
    ruleindices_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end indices_key */

/**
 * $ANTLR start values_key
 * PLSQLKeys.g:343:1: values_key : SQL92_RESERVED_VALUES ;
 */
void
PLSQLParser_PLSQLKeys::values_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:344:5: ( SQL92_RESERVED_VALUES )
        // PLSQLKeys.g:344:10: SQL92_RESERVED_VALUES
        {
             this->matchToken(SQL92_RESERVED_VALUES, &FOLLOW_SQL92_RESERVED_VALUES_in_values_key1755);
            if  (this->hasException())
            {
                goto rulevalues_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevalues_keyEx; /* Prevent compiler warnings */
    rulevalues_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end values_key */

/**
 * $ANTLR start case_key
 * PLSQLKeys.g:347:1: case_key : SQL92_RESERVED_CASE ;
 */
void
PLSQLParser_PLSQLKeys::case_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:348:5: ( SQL92_RESERVED_CASE )
        // PLSQLKeys.g:348:10: SQL92_RESERVED_CASE
        {
             this->matchToken(SQL92_RESERVED_CASE, &FOLLOW_SQL92_RESERVED_CASE_in_case_key1775);
            if  (this->hasException())
            {
                goto rulecase_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecase_keyEx; /* Prevent compiler warnings */
    rulecase_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end case_key */

/**
 * $ANTLR start bulk_key
 * PLSQLKeys.g:351:1: bulk_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::bulk_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:352:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:352:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BULK"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BULK\")" );
                    ex->set_ruleName( "bulk_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_bulk_key1798);
            if  (this->hasException())
            {
                goto rulebulk_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebulk_keyEx; /* Prevent compiler warnings */
    rulebulk_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end bulk_key */

/**
 * $ANTLR start collect_key
 * PLSQLKeys.g:355:1: collect_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::collect_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:356:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:356:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COLLECT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COLLECT\")" );
                    ex->set_ruleName( "collect_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_collect_key1821);
            if  (this->hasException())
            {
                goto rulecollect_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecollect_keyEx; /* Prevent compiler warnings */
    rulecollect_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end collect_key */

/**
 * $ANTLR start committed_key
 * PLSQLKeys.g:359:1: committed_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::committed_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:360:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:360:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COMMITTED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COMMITTED\")" );
                    ex->set_ruleName( "committed_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_committed_key1843);
            if  (this->hasException())
            {
                goto rulecommitted_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecommitted_keyEx; /* Prevent compiler warnings */
    rulecommitted_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end committed_key */

/**
 * $ANTLR start use_key
 * PLSQLKeys.g:363:1: use_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::use_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:364:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:364:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "USE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"USE\")" );
                    ex->set_ruleName( "use_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_use_key1866);
            if  (this->hasException())
            {
                goto ruleuse_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleuse_keyEx; /* Prevent compiler warnings */
    ruleuse_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end use_key */

/**
 * $ANTLR start level_key
 * PLSQLKeys.g:367:1: level_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::level_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:368:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:368:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LEVEL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LEVEL\")" );
                    ex->set_ruleName( "level_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_level_key1888);
            if  (this->hasException())
            {
                goto rulelevel_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelevel_keyEx; /* Prevent compiler warnings */
    rulelevel_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end level_key */

/**
 * $ANTLR start isolation_key
 * PLSQLKeys.g:371:1: isolation_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::isolation_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:372:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:372:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ISOLATION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ISOLATION\")" );
                    ex->set_ruleName( "isolation_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_isolation_key1911);
            if  (this->hasException())
            {
                goto ruleisolation_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleisolation_keyEx; /* Prevent compiler warnings */
    ruleisolation_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end isolation_key */

/**
 * $ANTLR start serializable_key
 * PLSQLKeys.g:375:1: serializable_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::serializable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:376:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:376:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SERIALIZABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SERIALIZABLE\")" );
                    ex->set_ruleName( "serializable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_serializable_key1933);
            if  (this->hasException())
            {
                goto ruleserializable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleserializable_keyEx; /* Prevent compiler warnings */
    ruleserializable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end serializable_key */

/**
 * $ANTLR start segment_key
 * PLSQLKeys.g:379:1: segment_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::segment_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:380:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:380:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SEGMENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SEGMENT\")" );
                    ex->set_ruleName( "segment_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_segment_key1955);
            if  (this->hasException())
            {
                goto rulesegment_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesegment_keyEx; /* Prevent compiler warnings */
    rulesegment_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end segment_key */

/**
 * $ANTLR start write_key
 * PLSQLKeys.g:383:1: write_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::write_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:384:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:384:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "WRITE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"WRITE\")" );
                    ex->set_ruleName( "write_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_write_key1978);
            if  (this->hasException())
            {
                goto rulewrite_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewrite_keyEx; /* Prevent compiler warnings */
    rulewrite_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end write_key */

/**
 * $ANTLR start wait_key
 * PLSQLKeys.g:387:1: wait_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::wait_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:388:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:388:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "WAIT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"WAIT\")" );
                    ex->set_ruleName( "wait_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_wait_key2001);
            if  (this->hasException())
            {
                goto rulewait_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewait_keyEx; /* Prevent compiler warnings */
    rulewait_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end wait_key */

/**
 * $ANTLR start corrupt_xid_all_key
 * PLSQLKeys.g:391:1: corrupt_xid_all_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::corrupt_xid_all_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:392:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:392:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CORRUPT_XID_ALL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CORRUPT_XID_ALL\")" );
                    ex->set_ruleName( "corrupt_xid_all_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_corrupt_xid_all_key2024);
            if  (this->hasException())
            {
                goto rulecorrupt_xid_all_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecorrupt_xid_all_keyEx; /* Prevent compiler warnings */
    rulecorrupt_xid_all_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end corrupt_xid_all_key */

/**
 * $ANTLR start corrupt_xid_key
 * PLSQLKeys.g:395:1: corrupt_xid_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::corrupt_xid_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:396:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:396:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CORRUPT_XID"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CORRUPT_XID\")" );
                    ex->set_ruleName( "corrupt_xid_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_corrupt_xid_key2047);
            if  (this->hasException())
            {
                goto rulecorrupt_xid_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecorrupt_xid_keyEx; /* Prevent compiler warnings */
    rulecorrupt_xid_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end corrupt_xid_key */

/**
 * $ANTLR start batch_key
 * PLSQLKeys.g:399:1: batch_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::batch_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:400:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:400:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BATCH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BATCH\")" );
                    ex->set_ruleName( "batch_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_batch_key2070);
            if  (this->hasException())
            {
                goto rulebatch_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebatch_keyEx; /* Prevent compiler warnings */
    rulebatch_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end batch_key */

/**
 * $ANTLR start session_key
 * PLSQLKeys.g:403:1: session_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::session_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:404:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:404:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SESSION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SESSION\")" );
                    ex->set_ruleName( "session_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_session_key2093);
            if  (this->hasException())
            {
                goto rulesession_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesession_keyEx; /* Prevent compiler warnings */
    rulesession_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end session_key */

/**
 * $ANTLR start role_key
 * PLSQLKeys.g:407:1: role_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::role_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:408:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:408:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ROLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ROLE\")" );
                    ex->set_ruleName( "role_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_role_key2116);
            if  (this->hasException())
            {
                goto rulerole_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerole_keyEx; /* Prevent compiler warnings */
    rulerole_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end role_key */

/**
 * $ANTLR start constraint_key
 * PLSQLKeys.g:411:1: constraint_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::constraint_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:412:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:412:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CONSTRAINT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CONSTRAINT\")" );
                    ex->set_ruleName( "constraint_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_constraint_key2139);
            if  (this->hasException())
            {
                goto ruleconstraint_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconstraint_keyEx; /* Prevent compiler warnings */
    ruleconstraint_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end constraint_key */

/**
 * $ANTLR start constraints_key
 * PLSQLKeys.g:415:1: constraints_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::constraints_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:416:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:416:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CONSTRAINTS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CONSTRAINTS\")" );
                    ex->set_ruleName( "constraints_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_constraints_key2162);
            if  (this->hasException())
            {
                goto ruleconstraints_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconstraints_keyEx; /* Prevent compiler warnings */
    ruleconstraints_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end constraints_key */

/**
 * $ANTLR start call_key
 * PLSQLKeys.g:419:1: call_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::call_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:420:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:420:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CALL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CALL\")" );
                    ex->set_ruleName( "call_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_call_key2185);
            if  (this->hasException())
            {
                goto rulecall_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecall_keyEx; /* Prevent compiler warnings */
    rulecall_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end call_key */

/**
 * $ANTLR start explain_key
 * PLSQLKeys.g:423:1: explain_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::explain_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:424:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:424:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXPLAIN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXPLAIN\")" );
                    ex->set_ruleName( "explain_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_explain_key2208);
            if  (this->hasException())
            {
                goto ruleexplain_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexplain_keyEx; /* Prevent compiler warnings */
    ruleexplain_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end explain_key */

/**
 * $ANTLR start merge_key
 * PLSQLKeys.g:427:1: merge_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::merge_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:428:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:428:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MERGE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MERGE\")" );
                    ex->set_ruleName( "merge_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_merge_key2231);
            if  (this->hasException())
            {
                goto rulemerge_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemerge_keyEx; /* Prevent compiler warnings */
    rulemerge_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end merge_key */

/**
 * $ANTLR start plan_key
 * PLSQLKeys.g:431:1: plan_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::plan_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:432:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:432:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PLAN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PLAN\")" );
                    ex->set_ruleName( "plan_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_plan_key2254);
            if  (this->hasException())
            {
                goto ruleplan_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleplan_keyEx; /* Prevent compiler warnings */
    ruleplan_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end plan_key */

/**
 * $ANTLR start system_key
 * PLSQLKeys.g:435:1: system_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::system_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:436:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:436:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SYSTEM"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SYSTEM\")" );
                    ex->set_ruleName( "system_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_system_key2277);
            if  (this->hasException())
            {
                goto rulesystem_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesystem_keyEx; /* Prevent compiler warnings */
    rulesystem_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end system_key */

/**
 * $ANTLR start subpartition_key
 * PLSQLKeys.g:439:1: subpartition_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::subpartition_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:440:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:440:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SUBPARTITION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SUBPARTITION\")" );
                    ex->set_ruleName( "subpartition_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_subpartition_key2300);
            if  (this->hasException())
            {
                goto rulesubpartition_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubpartition_keyEx; /* Prevent compiler warnings */
    rulesubpartition_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end subpartition_key */

/**
 * $ANTLR start partition_key
 * PLSQLKeys.g:443:1: partition_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::partition_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:444:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:444:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PARTITION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PARTITION\")" );
                    ex->set_ruleName( "partition_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_partition_key2323);
            if  (this->hasException())
            {
                goto rulepartition_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepartition_keyEx; /* Prevent compiler warnings */
    rulepartition_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end partition_key */

/**
 * $ANTLR start matched_key
 * PLSQLKeys.g:447:1: matched_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::matched_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:448:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:448:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MATCHED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MATCHED\")" );
                    ex->set_ruleName( "matched_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_matched_key2346);
            if  (this->hasException())
            {
                goto rulematched_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulematched_keyEx; /* Prevent compiler warnings */
    rulematched_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end matched_key */

/**
 * $ANTLR start reject_key
 * PLSQLKeys.g:451:1: reject_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::reject_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:452:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:452:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "REJECT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"REJECT\")" );
                    ex->set_ruleName( "reject_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_reject_key2369);
            if  (this->hasException())
            {
                goto rulereject_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereject_keyEx; /* Prevent compiler warnings */
    rulereject_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end reject_key */

/**
 * $ANTLR start log_key
 * PLSQLKeys.g:455:1: log_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::log_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:456:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:456:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LOG"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LOG\")" );
                    ex->set_ruleName( "log_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_log_key2392);
            if  (this->hasException())
            {
                goto rulelog_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelog_keyEx; /* Prevent compiler warnings */
    rulelog_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end log_key */

/**
 * $ANTLR start unlimited_key
 * PLSQLKeys.g:459:1: unlimited_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::unlimited_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:460:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:460:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UNLIMITED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UNLIMITED\")" );
                    ex->set_ruleName( "unlimited_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_unlimited_key2415);
            if  (this->hasException())
            {
                goto ruleunlimited_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunlimited_keyEx; /* Prevent compiler warnings */
    ruleunlimited_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unlimited_key */

/**
 * $ANTLR start limit_key
 * PLSQLKeys.g:463:1: limit_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::limit_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:464:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:464:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LIMIT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LIMIT\")" );
                    ex->set_ruleName( "limit_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_limit_key2438);
            if  (this->hasException())
            {
                goto rulelimit_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelimit_keyEx; /* Prevent compiler warnings */
    rulelimit_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end limit_key */

/**
 * $ANTLR start errors_key
 * PLSQLKeys.g:467:1: errors_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::errors_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:468:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:468:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ERRORS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ERRORS\")" );
                    ex->set_ruleName( "errors_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_errors_key2461);
            if  (this->hasException())
            {
                goto ruleerrors_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleerrors_keyEx; /* Prevent compiler warnings */
    ruleerrors_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end errors_key */

/**
 * $ANTLR start timestamp_tz_unconstrained_key
 * PLSQLKeys.g:471:1: timestamp_tz_unconstrained_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::timestamp_tz_unconstrained_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:472:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:472:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_TZ_UNCONSTRAINED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIMESTAMP_TZ_UNCONSTRAINED\")" );
                    ex->set_ruleName( "timestamp_tz_unconstrained_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timestamp_tz_unconstrained_key2484);
            if  (this->hasException())
            {
                goto ruletimestamp_tz_unconstrained_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletimestamp_tz_unconstrained_keyEx; /* Prevent compiler warnings */
    ruletimestamp_tz_unconstrained_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timestamp_tz_unconstrained_key */

/**
 * $ANTLR start urowid_key
 * PLSQLKeys.g:475:1: urowid_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::urowid_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:476:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:476:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UROWID"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UROWID\")" );
                    ex->set_ruleName( "urowid_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_urowid_key2507);
            if  (this->hasException())
            {
                goto ruleurowid_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleurowid_keyEx; /* Prevent compiler warnings */
    ruleurowid_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end urowid_key */

/**
 * $ANTLR start binary_float_min_subnormal_key
 * PLSQLKeys.g:479:1: binary_float_min_subnormal_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_float_min_subnormal_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:480:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:480:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT_MIN_SUBNORMAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_FLOAT_MIN_SUBNORMAL\")" );
                    ex->set_ruleName( "binary_float_min_subnormal_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_min_subnormal_key2530);
            if  (this->hasException())
            {
                goto rulebinary_float_min_subnormal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_float_min_subnormal_keyEx; /* Prevent compiler warnings */
    rulebinary_float_min_subnormal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_float_min_subnormal_key */

/**
 * $ANTLR start binary_double_min_normal_key
 * PLSQLKeys.g:483:1: binary_double_min_normal_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_double_min_normal_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:484:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:484:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE_MIN_NORMAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_DOUBLE_MIN_NORMAL\")" );
                    ex->set_ruleName( "binary_double_min_normal_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_min_normal_key2553);
            if  (this->hasException())
            {
                goto rulebinary_double_min_normal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_double_min_normal_keyEx; /* Prevent compiler warnings */
    rulebinary_double_min_normal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_double_min_normal_key */

/**
 * $ANTLR start binary_float_max_normal_key
 * PLSQLKeys.g:487:1: binary_float_max_normal_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_float_max_normal_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:488:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:488:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT_MAX_NORMAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_FLOAT_MAX_NORMAL\")" );
                    ex->set_ruleName( "binary_float_max_normal_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_max_normal_key2576);
            if  (this->hasException())
            {
                goto rulebinary_float_max_normal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_float_max_normal_keyEx; /* Prevent compiler warnings */
    rulebinary_float_max_normal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_float_max_normal_key */

/**
 * $ANTLR start positiven_key
 * PLSQLKeys.g:491:1: positiven_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::positiven_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:492:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:492:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "POSITIVEN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"POSITIVEN\")" );
                    ex->set_ruleName( "positiven_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_positiven_key2599);
            if  (this->hasException())
            {
                goto rulepositiven_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepositiven_keyEx; /* Prevent compiler warnings */
    rulepositiven_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end positiven_key */

/**
 * $ANTLR start timezone_abbr_key
 * PLSQLKeys.g:495:1: timezone_abbr_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::timezone_abbr_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:496:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:496:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_ABBR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIMEZONE_ABBR\")" );
                    ex->set_ruleName( "timezone_abbr_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timezone_abbr_key2622);
            if  (this->hasException())
            {
                goto ruletimezone_abbr_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletimezone_abbr_keyEx; /* Prevent compiler warnings */
    ruletimezone_abbr_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timezone_abbr_key */

/**
 * $ANTLR start binary_double_min_subnormal_key
 * PLSQLKeys.g:499:1: binary_double_min_subnormal_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_double_min_subnormal_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:500:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:500:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE_MIN_SUBNORMAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_DOUBLE_MIN_SUBNORMAL\")" );
                    ex->set_ruleName( "binary_double_min_subnormal_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_min_subnormal_key2645);
            if  (this->hasException())
            {
                goto rulebinary_double_min_subnormal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_double_min_subnormal_keyEx; /* Prevent compiler warnings */
    rulebinary_double_min_subnormal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_double_min_subnormal_key */

/**
 * $ANTLR start binary_float_max_subnormal_key
 * PLSQLKeys.g:503:1: binary_float_max_subnormal_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_float_max_subnormal_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:504:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:504:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT_MAX_SUBNORMAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_FLOAT_MAX_SUBNORMAL\")" );
                    ex->set_ruleName( "binary_float_max_subnormal_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_max_subnormal_key2668);
            if  (this->hasException())
            {
                goto rulebinary_float_max_subnormal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_float_max_subnormal_keyEx; /* Prevent compiler warnings */
    rulebinary_float_max_subnormal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_float_max_subnormal_key */

/**
 * $ANTLR start binary_double_key
 * PLSQLKeys.g:507:1: binary_double_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_double_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:508:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:508:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_DOUBLE\")" );
                    ex->set_ruleName( "binary_double_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_key2691);
            if  (this->hasException())
            {
                goto rulebinary_double_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_double_keyEx; /* Prevent compiler warnings */
    rulebinary_double_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_double_key */

/**
 * $ANTLR start bfile_key
 * PLSQLKeys.g:511:1: bfile_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::bfile_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:512:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:512:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BFILE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BFILE\")" );
                    ex->set_ruleName( "bfile_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_bfile_key2714);
            if  (this->hasException())
            {
                goto rulebfile_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebfile_keyEx; /* Prevent compiler warnings */
    rulebfile_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end bfile_key */

/**
 * $ANTLR start binary_double_infinity_key
 * PLSQLKeys.g:515:1: binary_double_infinity_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_double_infinity_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:516:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:516:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE_INFINITY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_DOUBLE_INFINITY\")" );
                    ex->set_ruleName( "binary_double_infinity_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_infinity_key2737);
            if  (this->hasException())
            {
                goto rulebinary_double_infinity_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_double_infinity_keyEx; /* Prevent compiler warnings */
    rulebinary_double_infinity_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_double_infinity_key */

/**
 * $ANTLR start timezone_region_key
 * PLSQLKeys.g:519:1: timezone_region_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::timezone_region_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:520:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:520:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_REGION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIMEZONE_REGION\")" );
                    ex->set_ruleName( "timezone_region_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timezone_region_key2760);
            if  (this->hasException())
            {
                goto ruletimezone_region_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletimezone_region_keyEx; /* Prevent compiler warnings */
    ruletimezone_region_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timezone_region_key */

/**
 * $ANTLR start timestamp_ltz_unconstrained_key
 * PLSQLKeys.g:523:1: timestamp_ltz_unconstrained_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::timestamp_ltz_unconstrained_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:524:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:524:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_LTZ_UNCONSTRAINED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIMESTAMP_LTZ_UNCONSTRAINED\")" );
                    ex->set_ruleName( "timestamp_ltz_unconstrained_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timestamp_ltz_unconstrained_key2783);
            if  (this->hasException())
            {
                goto ruletimestamp_ltz_unconstrained_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletimestamp_ltz_unconstrained_keyEx; /* Prevent compiler warnings */
    ruletimestamp_ltz_unconstrained_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timestamp_ltz_unconstrained_key */

/**
 * $ANTLR start naturaln_key
 * PLSQLKeys.g:527:1: naturaln_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::naturaln_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:528:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:528:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NATURALN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NATURALN\")" );
                    ex->set_ruleName( "naturaln_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_naturaln_key2806);
            if  (this->hasException())
            {
                goto rulenaturaln_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenaturaln_keyEx; /* Prevent compiler warnings */
    rulenaturaln_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end naturaln_key */

/**
 * $ANTLR start simple_integer_key
 * PLSQLKeys.g:531:1: simple_integer_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::simple_integer_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:532:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:532:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SIMPLE_INTEGER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SIMPLE_INTEGER\")" );
                    ex->set_ruleName( "simple_integer_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_simple_integer_key2829);
            if  (this->hasException())
            {
                goto rulesimple_integer_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesimple_integer_keyEx; /* Prevent compiler warnings */
    rulesimple_integer_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end simple_integer_key */

/**
 * $ANTLR start binary_double_max_subnormal_key
 * PLSQLKeys.g:535:1: binary_double_max_subnormal_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_double_max_subnormal_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:536:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:536:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE_MAX_SUBNORMAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_DOUBLE_MAX_SUBNORMAL\")" );
                    ex->set_ruleName( "binary_double_max_subnormal_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_max_subnormal_key2852);
            if  (this->hasException())
            {
                goto rulebinary_double_max_subnormal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_double_max_subnormal_keyEx; /* Prevent compiler warnings */
    rulebinary_double_max_subnormal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_double_max_subnormal_key */

/**
 * $ANTLR start byte_key
 * PLSQLKeys.g:539:1: byte_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::byte_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:540:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:540:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BYTE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BYTE\")" );
                    ex->set_ruleName( "byte_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_byte_key2875);
            if  (this->hasException())
            {
                goto rulebyte_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebyte_keyEx; /* Prevent compiler warnings */
    rulebyte_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end byte_key */

/**
 * $ANTLR start binary_float_infinity_key
 * PLSQLKeys.g:543:1: binary_float_infinity_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_float_infinity_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:544:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:544:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT_INFINITY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_FLOAT_INFINITY\")" );
                    ex->set_ruleName( "binary_float_infinity_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_infinity_key2898);
            if  (this->hasException())
            {
                goto rulebinary_float_infinity_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_float_infinity_keyEx; /* Prevent compiler warnings */
    rulebinary_float_infinity_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_float_infinity_key */

/**
 * $ANTLR start binary_float_key
 * PLSQLKeys.g:547:1: binary_float_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_float_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:548:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:548:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_FLOAT\")" );
                    ex->set_ruleName( "binary_float_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_key2921);
            if  (this->hasException())
            {
                goto rulebinary_float_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_float_keyEx; /* Prevent compiler warnings */
    rulebinary_float_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_float_key */

/**
 * $ANTLR start range_key
 * PLSQLKeys.g:551:1: range_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::range_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:552:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:552:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RANGE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RANGE\")" );
                    ex->set_ruleName( "range_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_range_key2944);
            if  (this->hasException())
            {
                goto rulerange_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerange_keyEx; /* Prevent compiler warnings */
    rulerange_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end range_key */

/**
 * $ANTLR start nclob_key
 * PLSQLKeys.g:555:1: nclob_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nclob_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:556:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:556:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NCLOB"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NCLOB\")" );
                    ex->set_ruleName( "nclob_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nclob_key2967);
            if  (this->hasException())
            {
                goto rulenclob_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenclob_keyEx; /* Prevent compiler warnings */
    rulenclob_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nclob_key */

/**
 * $ANTLR start clob_key
 * PLSQLKeys.g:559:1: clob_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::clob_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:560:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:560:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CLOB"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CLOB\")" );
                    ex->set_ruleName( "clob_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_clob_key2990);
            if  (this->hasException())
            {
                goto ruleclob_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleclob_keyEx; /* Prevent compiler warnings */
    ruleclob_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end clob_key */

/**
 * $ANTLR start dsinterval_unconstrained_key
 * PLSQLKeys.g:563:1: dsinterval_unconstrained_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::dsinterval_unconstrained_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:564:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:564:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DSINTERVAL_UNCONSTRAINED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DSINTERVAL_UNCONSTRAINED\")" );
                    ex->set_ruleName( "dsinterval_unconstrained_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dsinterval_unconstrained_key3013);
            if  (this->hasException())
            {
                goto ruledsinterval_unconstrained_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledsinterval_unconstrained_keyEx; /* Prevent compiler warnings */
    ruledsinterval_unconstrained_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dsinterval_unconstrained_key */

/**
 * $ANTLR start yminterval_unconstrained_key
 * PLSQLKeys.g:567:1: yminterval_unconstrained_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::yminterval_unconstrained_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:568:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:568:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "YMINTERVAL_UNCONSTRAINED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"YMINTERVAL_UNCONSTRAINED\")" );
                    ex->set_ruleName( "yminterval_unconstrained_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_yminterval_unconstrained_key3036);
            if  (this->hasException())
            {
                goto ruleyminterval_unconstrained_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleyminterval_unconstrained_keyEx; /* Prevent compiler warnings */
    ruleyminterval_unconstrained_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end yminterval_unconstrained_key */

/**
 * $ANTLR start rowid_key
 * PLSQLKeys.g:571:1: rowid_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rowid_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:572:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:572:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ROWID"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ROWID\")" );
                    ex->set_ruleName( "rowid_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rowid_key3059);
            if  (this->hasException())
            {
                goto rulerowid_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerowid_keyEx; /* Prevent compiler warnings */
    rulerowid_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rowid_key */

/**
 * $ANTLR start binary_double_nan_key
 * PLSQLKeys.g:575:1: binary_double_nan_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_double_nan_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:576:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:576:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE_NAN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_DOUBLE_NAN\")" );
                    ex->set_ruleName( "binary_double_nan_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_nan_key3082);
            if  (this->hasException())
            {
                goto rulebinary_double_nan_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_double_nan_keyEx; /* Prevent compiler warnings */
    rulebinary_double_nan_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_double_nan_key */

/**
 * $ANTLR start timestamp_unconstrained_key
 * PLSQLKeys.g:579:1: timestamp_unconstrained_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::timestamp_unconstrained_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:580:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:580:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_UNCONSTRAINED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIMESTAMP_UNCONSTRAINED\")" );
                    ex->set_ruleName( "timestamp_unconstrained_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timestamp_unconstrained_key3105);
            if  (this->hasException())
            {
                goto ruletimestamp_unconstrained_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletimestamp_unconstrained_keyEx; /* Prevent compiler warnings */
    ruletimestamp_unconstrained_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timestamp_unconstrained_key */

/**
 * $ANTLR start binary_float_min_normal_key
 * PLSQLKeys.g:583:1: binary_float_min_normal_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_float_min_normal_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:584:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:584:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT_MIN_NORMAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_FLOAT_MIN_NORMAL\")" );
                    ex->set_ruleName( "binary_float_min_normal_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_min_normal_key3128);
            if  (this->hasException())
            {
                goto rulebinary_float_min_normal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_float_min_normal_keyEx; /* Prevent compiler warnings */
    rulebinary_float_min_normal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_float_min_normal_key */

/**
 * $ANTLR start signtype_key
 * PLSQLKeys.g:587:1: signtype_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::signtype_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:588:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:588:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SIGNTYPE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SIGNTYPE\")" );
                    ex->set_ruleName( "signtype_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_signtype_key3151);
            if  (this->hasException())
            {
                goto rulesigntype_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesigntype_keyEx; /* Prevent compiler warnings */
    rulesigntype_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end signtype_key */

/**
 * $ANTLR start blob_key
 * PLSQLKeys.g:591:1: blob_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::blob_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:592:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:592:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BLOB"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BLOB\")" );
                    ex->set_ruleName( "blob_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_blob_key3174);
            if  (this->hasException())
            {
                goto ruleblob_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleblob_keyEx; /* Prevent compiler warnings */
    ruleblob_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end blob_key */

/**
 * $ANTLR start nvarchar2_key
 * PLSQLKeys.g:595:1: nvarchar2_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nvarchar2_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:596:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:596:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NVARCHAR2"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NVARCHAR2\")" );
                    ex->set_ruleName( "nvarchar2_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nvarchar2_key3197);
            if  (this->hasException())
            {
                goto rulenvarchar2_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenvarchar2_keyEx; /* Prevent compiler warnings */
    rulenvarchar2_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nvarchar2_key */

/**
 * $ANTLR start binary_double_max_normal_key
 * PLSQLKeys.g:599:1: binary_double_max_normal_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_double_max_normal_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:600:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:600:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE_MAX_NORMAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_DOUBLE_MAX_NORMAL\")" );
                    ex->set_ruleName( "binary_double_max_normal_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_max_normal_key3220);
            if  (this->hasException())
            {
                goto rulebinary_double_max_normal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_double_max_normal_keyEx; /* Prevent compiler warnings */
    rulebinary_double_max_normal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_double_max_normal_key */

/**
 * $ANTLR start binary_float_nan_key
 * PLSQLKeys.g:603:1: binary_float_nan_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_float_nan_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:604:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:604:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT_NAN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_FLOAT_NAN\")" );
                    ex->set_ruleName( "binary_float_nan_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_nan_key3243);
            if  (this->hasException())
            {
                goto rulebinary_float_nan_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_float_nan_keyEx; /* Prevent compiler warnings */
    rulebinary_float_nan_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_float_nan_key */

/**
 * $ANTLR start string_key
 * PLSQLKeys.g:607:1: string_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::string_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:608:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:608:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "STRING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"STRING\")" );
                    ex->set_ruleName( "string_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_string_key3266);
            if  (this->hasException())
            {
                goto rulestring_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestring_keyEx; /* Prevent compiler warnings */
    rulestring_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end string_key */

/**
 * $ANTLR start c_key
 * PLSQLKeys.g:611:1: c_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::c_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:612:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:612:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "C"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"C\")" );
                    ex->set_ruleName( "c_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_c_key3289);
            if  (this->hasException())
            {
                goto rulec_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulec_keyEx; /* Prevent compiler warnings */
    rulec_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end c_key */

/**
 * $ANTLR start library_key
 * PLSQLKeys.g:615:1: library_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::library_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:616:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:616:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LIBRARY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LIBRARY\")" );
                    ex->set_ruleName( "library_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_library_key3312);
            if  (this->hasException())
            {
                goto rulelibrary_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelibrary_keyEx; /* Prevent compiler warnings */
    rulelibrary_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end library_key */

/**
 * $ANTLR start context_key
 * PLSQLKeys.g:619:1: context_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::context_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:620:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:620:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CONTEXT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CONTEXT\")" );
                    ex->set_ruleName( "context_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_context_key3335);
            if  (this->hasException())
            {
                goto rulecontext_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecontext_keyEx; /* Prevent compiler warnings */
    rulecontext_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end context_key */

/**
 * $ANTLR start parameters_key
 * PLSQLKeys.g:623:1: parameters_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::parameters_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:624:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:624:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PARAMETERS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PARAMETERS\")" );
                    ex->set_ruleName( "parameters_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_parameters_key3358);
            if  (this->hasException())
            {
                goto ruleparameters_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleparameters_keyEx; /* Prevent compiler warnings */
    ruleparameters_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end parameters_key */

/**
 * $ANTLR start agent_key
 * PLSQLKeys.g:627:1: agent_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::agent_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:628:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:628:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AGENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AGENT\")" );
                    ex->set_ruleName( "agent_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_agent_key3381);
            if  (this->hasException())
            {
                goto ruleagent_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleagent_keyEx; /* Prevent compiler warnings */
    ruleagent_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end agent_key */

/**
 * $ANTLR start cluster_key
 * PLSQLKeys.g:631:1: cluster_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::cluster_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:632:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:632:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CLUSTER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CLUSTER\")" );
                    ex->set_ruleName( "cluster_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cluster_key3404);
            if  (this->hasException())
            {
                goto rulecluster_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecluster_keyEx; /* Prevent compiler warnings */
    rulecluster_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cluster_key */

/**
 * $ANTLR start hash_key
 * PLSQLKeys.g:635:1: hash_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::hash_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:636:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:636:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "HASH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"HASH\")" );
                    ex->set_ruleName( "hash_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_hash_key3427);
            if  (this->hasException())
            {
                goto rulehash_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulehash_keyEx; /* Prevent compiler warnings */
    rulehash_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end hash_key */

/**
 * $ANTLR start relies_on_key
 * PLSQLKeys.g:639:1: relies_on_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::relies_on_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:640:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:640:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RELIES_ON"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RELIES_ON\")" );
                    ex->set_ruleName( "relies_on_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_relies_on_key3450);
            if  (this->hasException())
            {
                goto rulerelies_on_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerelies_on_keyEx; /* Prevent compiler warnings */
    rulerelies_on_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end relies_on_key */

/**
 * $ANTLR start returning_key
 * PLSQLKeys.g:643:1: returning_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::returning_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:644:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:644:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RETURNING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RETURNING\")" );
                    ex->set_ruleName( "returning_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_returning_key3473);
            if  (this->hasException())
            {
                goto rulereturning_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereturning_keyEx; /* Prevent compiler warnings */
    rulereturning_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end returning_key */

/**
 * $ANTLR start statement_id_key
 * PLSQLKeys.g:647:1: statement_id_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::statement_id_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:648:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:648:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "STATEMENT_ID"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"STATEMENT_ID\")" );
                    ex->set_ruleName( "statement_id_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_statement_id_key3500);
            if  (this->hasException())
            {
                goto rulestatement_id_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestatement_id_keyEx; /* Prevent compiler warnings */
    rulestatement_id_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end statement_id_key */

/**
 * $ANTLR start deferred_key
 * PLSQLKeys.g:651:1: deferred_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::deferred_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:652:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:652:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DEFERRED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DEFERRED\")" );
                    ex->set_ruleName( "deferred_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_deferred_key3523);
            if  (this->hasException())
            {
                goto ruledeferred_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledeferred_keyEx; /* Prevent compiler warnings */
    ruledeferred_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end deferred_key */

/**
 * $ANTLR start advise_key
 * PLSQLKeys.g:655:1: advise_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::advise_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:656:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:656:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ADVISE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ADVISE\")" );
                    ex->set_ruleName( "advise_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_advise_key3546);
            if  (this->hasException())
            {
                goto ruleadvise_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleadvise_keyEx; /* Prevent compiler warnings */
    ruleadvise_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end advise_key */

/**
 * $ANTLR start resumable_key
 * PLSQLKeys.g:659:1: resumable_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::resumable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:660:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:660:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RESUMABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RESUMABLE\")" );
                    ex->set_ruleName( "resumable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_resumable_key3569);
            if  (this->hasException())
            {
                goto ruleresumable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleresumable_keyEx; /* Prevent compiler warnings */
    ruleresumable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end resumable_key */

/**
 * $ANTLR start timeout_key
 * PLSQLKeys.g:663:1: timeout_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::timeout_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:664:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:664:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIMEOUT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIMEOUT\")" );
                    ex->set_ruleName( "timeout_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timeout_key3592);
            if  (this->hasException())
            {
                goto ruletimeout_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletimeout_keyEx; /* Prevent compiler warnings */
    ruletimeout_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timeout_key */

/**
 * $ANTLR start parallel_key
 * PLSQLKeys.g:667:1: parallel_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::parallel_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:668:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:668:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PARALLEL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PARALLEL\")" );
                    ex->set_ruleName( "parallel_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_parallel_key3615);
            if  (this->hasException())
            {
                goto ruleparallel_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleparallel_keyEx; /* Prevent compiler warnings */
    ruleparallel_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end parallel_key */

/**
 * $ANTLR start ddl_key
 * PLSQLKeys.g:671:1: ddl_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::ddl_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:672:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:672:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DDL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DDL\")" );
                    ex->set_ruleName( "ddl_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ddl_key3638);
            if  (this->hasException())
            {
                goto ruleddl_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleddl_keyEx; /* Prevent compiler warnings */
    ruleddl_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end ddl_key */

/**
 * $ANTLR start query_key
 * PLSQLKeys.g:675:1: query_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::query_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:676:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:676:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "QUERY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"QUERY\")" );
                    ex->set_ruleName( "query_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_query_key3661);
            if  (this->hasException())
            {
                goto rulequery_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulequery_keyEx; /* Prevent compiler warnings */
    rulequery_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end query_key */

/**
 * $ANTLR start dml_key
 * PLSQLKeys.g:679:1: dml_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::dml_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:680:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:680:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DML"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DML\")" );
                    ex->set_ruleName( "dml_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dml_key3684);
            if  (this->hasException())
            {
                goto ruledml_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledml_keyEx; /* Prevent compiler warnings */
    ruledml_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dml_key */

/**
 * $ANTLR start guard_key
 * PLSQLKeys.g:683:1: guard_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::guard_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:684:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:684:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "GUARD"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"GUARD\")" );
                    ex->set_ruleName( "guard_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_guard_key3707);
            if  (this->hasException())
            {
                goto ruleguard_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleguard_keyEx; /* Prevent compiler warnings */
    ruleguard_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end guard_key */

/**
 * $ANTLR start nothing_key
 * PLSQLKeys.g:687:1: nothing_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nothing_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:688:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:688:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOTHING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOTHING\")" );
                    ex->set_ruleName( "nothing_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nothing_key3730);
            if  (this->hasException())
            {
                goto rulenothing_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenothing_keyEx; /* Prevent compiler warnings */
    rulenothing_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nothing_key */

/**
 * $ANTLR start enable_key
 * PLSQLKeys.g:691:1: enable_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::enable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:692:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:692:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ENABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ENABLE\")" );
                    ex->set_ruleName( "enable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_enable_key3753);
            if  (this->hasException())
            {
                goto ruleenable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleenable_keyEx; /* Prevent compiler warnings */
    ruleenable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end enable_key */

/**
 * $ANTLR start database_key
 * PLSQLKeys.g:695:1: database_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::database_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:696:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:696:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DATABASE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DATABASE\")" );
                    ex->set_ruleName( "database_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_database_key3776);
            if  (this->hasException())
            {
                goto ruledatabase_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledatabase_keyEx; /* Prevent compiler warnings */
    ruledatabase_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end database_key */

/**
 * $ANTLR start disable_key
 * PLSQLKeys.g:699:1: disable_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::disable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:700:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:700:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DISABLE\")" );
                    ex->set_ruleName( "disable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_disable_key3799);
            if  (this->hasException())
            {
                goto ruledisable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledisable_keyEx; /* Prevent compiler warnings */
    ruledisable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end disable_key */

/**
 * $ANTLR start link_key
 * PLSQLKeys.g:703:1: link_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::link_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:704:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:704:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LINK"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LINK\")" );
                    ex->set_ruleName( "link_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_link_key3822);
            if  (this->hasException())
            {
                goto rulelink_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelink_keyEx; /* Prevent compiler warnings */
    rulelink_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end link_key */

/**
 * $ANTLR start identified_key
 * PLSQLKeys.g:707:1: identified_key : PLSQL_RESERVED_IDENTIFIED ;
 */
void
PLSQLParser_PLSQLKeys::identified_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:708:5: ( PLSQL_RESERVED_IDENTIFIED )
        // PLSQLKeys.g:708:10: PLSQL_RESERVED_IDENTIFIED
        {
             this->matchToken(PLSQL_RESERVED_IDENTIFIED, &FOLLOW_PLSQL_RESERVED_IDENTIFIED_in_identified_key3842);
            if  (this->hasException())
            {
                goto ruleidentified_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleidentified_keyEx; /* Prevent compiler warnings */
    ruleidentified_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end identified_key */

/**
 * $ANTLR start none_key
 * PLSQLKeys.g:711:1: none_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::none_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:712:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:712:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NONE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NONE\")" );
                    ex->set_ruleName( "none_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_none_key3865);
            if  (this->hasException())
            {
                goto rulenone_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenone_keyEx; /* Prevent compiler warnings */
    rulenone_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end none_key */

/**
 * $ANTLR start before_key
 * PLSQLKeys.g:715:1: before_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::before_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:716:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:716:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BEFORE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BEFORE\")" );
                    ex->set_ruleName( "before_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_before_key3888);
            if  (this->hasException())
            {
                goto rulebefore_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebefore_keyEx; /* Prevent compiler warnings */
    rulebefore_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end before_key */

/**
 * $ANTLR start referencing_key
 * PLSQLKeys.g:719:1: referencing_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::referencing_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:720:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:720:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"REFERENCING\")" );
                    ex->set_ruleName( "referencing_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_referencing_key3912);
            if  (this->hasException())
            {
                goto rulereferencing_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereferencing_keyEx; /* Prevent compiler warnings */
    rulereferencing_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end referencing_key */

/**
 * $ANTLR start logon_key
 * PLSQLKeys.g:723:1: logon_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::logon_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:724:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:724:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LOGON"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LOGON\")" );
                    ex->set_ruleName( "logon_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_logon_key3935);
            if  (this->hasException())
            {
                goto rulelogon_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelogon_keyEx; /* Prevent compiler warnings */
    rulelogon_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end logon_key */

/**
 * $ANTLR start after_key
 * PLSQLKeys.g:727:1: after_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::after_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:728:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:728:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AFTER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AFTER\")" );
                    ex->set_ruleName( "after_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_after_key3957);
            if  (this->hasException())
            {
                goto ruleafter_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleafter_keyEx; /* Prevent compiler warnings */
    ruleafter_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end after_key */

/**
 * $ANTLR start schema_key
 * PLSQLKeys.g:731:1: schema_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::schema_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:732:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:732:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SCHEMA"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SCHEMA\")" );
                    ex->set_ruleName( "schema_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_schema_key3980);
            if  (this->hasException())
            {
                goto ruleschema_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleschema_keyEx; /* Prevent compiler warnings */
    ruleschema_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end schema_key */

/**
 * $ANTLR start grant_key
 * PLSQLKeys.g:735:1: grant_key : SQL92_RESERVED_GRANT ;
 */
void
PLSQLParser_PLSQLKeys::grant_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:736:5: ( SQL92_RESERVED_GRANT )
        // PLSQLKeys.g:736:10: SQL92_RESERVED_GRANT
        {
             this->matchToken(SQL92_RESERVED_GRANT, &FOLLOW_SQL92_RESERVED_GRANT_in_grant_key4000);
            if  (this->hasException())
            {
                goto rulegrant_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulegrant_keyEx; /* Prevent compiler warnings */
    rulegrant_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end grant_key */

/**
 * $ANTLR start truncate_key
 * PLSQLKeys.g:739:1: truncate_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::truncate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:740:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:740:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TRUNCATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TRUNCATE\")" );
                    ex->set_ruleName( "truncate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_truncate_key4023);
            if  (this->hasException())
            {
                goto ruletruncate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletruncate_keyEx; /* Prevent compiler warnings */
    ruletruncate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end truncate_key */

/**
 * $ANTLR start startup_key
 * PLSQLKeys.g:743:1: startup_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::startup_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:744:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:744:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "STARTUP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"STARTUP\")" );
                    ex->set_ruleName( "startup_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_startup_key4046);
            if  (this->hasException())
            {
                goto rulestartup_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestartup_keyEx; /* Prevent compiler warnings */
    rulestartup_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end startup_key */

/**
 * $ANTLR start statistics_key
 * PLSQLKeys.g:747:1: statistics_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::statistics_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:748:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:748:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "STATISTICS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"STATISTICS\")" );
                    ex->set_ruleName( "statistics_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_statistics_key4069);
            if  (this->hasException())
            {
                goto rulestatistics_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestatistics_keyEx; /* Prevent compiler warnings */
    rulestatistics_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end statistics_key */

/**
 * $ANTLR start noaudit_key
 * PLSQLKeys.g:751:1: noaudit_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::noaudit_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:752:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:752:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOAUDIT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOAUDIT\")" );
                    ex->set_ruleName( "noaudit_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_noaudit_key4092);
            if  (this->hasException())
            {
                goto rulenoaudit_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenoaudit_keyEx; /* Prevent compiler warnings */
    rulenoaudit_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end noaudit_key */

/**
 * $ANTLR start suspend_key
 * PLSQLKeys.g:755:1: suspend_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::suspend_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:756:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:756:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SUSPEND"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SUSPEND\")" );
                    ex->set_ruleName( "suspend_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_suspend_key4115);
            if  (this->hasException())
            {
                goto rulesuspend_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesuspend_keyEx; /* Prevent compiler warnings */
    rulesuspend_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end suspend_key */

/**
 * $ANTLR start audit_key
 * PLSQLKeys.g:759:1: audit_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::audit_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:760:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:760:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AUDIT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AUDIT\")" );
                    ex->set_ruleName( "audit_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_audit_key4138);
            if  (this->hasException())
            {
                goto ruleaudit_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleaudit_keyEx; /* Prevent compiler warnings */
    ruleaudit_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end audit_key */

/**
 * $ANTLR start disassociate_key
 * PLSQLKeys.g:763:1: disassociate_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::disassociate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:764:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:764:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DISASSOCIATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DISASSOCIATE\")" );
                    ex->set_ruleName( "disassociate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_disassociate_key4161);
            if  (this->hasException())
            {
                goto ruledisassociate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledisassociate_keyEx; /* Prevent compiler warnings */
    ruledisassociate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end disassociate_key */

/**
 * $ANTLR start shutdown_key
 * PLSQLKeys.g:767:1: shutdown_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::shutdown_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:768:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:768:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SHUTDOWN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SHUTDOWN\")" );
                    ex->set_ruleName( "shutdown_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_shutdown_key4185);
            if  (this->hasException())
            {
                goto ruleshutdown_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleshutdown_keyEx; /* Prevent compiler warnings */
    ruleshutdown_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end shutdown_key */

/**
 * $ANTLR start compound_key
 * PLSQLKeys.g:771:1: compound_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::compound_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:772:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:772:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COMPOUND\")" );
                    ex->set_ruleName( "compound_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_compound_key4208);
            if  (this->hasException())
            {
                goto rulecompound_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecompound_keyEx; /* Prevent compiler warnings */
    rulecompound_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end compound_key */

/**
 * $ANTLR start servererror_key
 * PLSQLKeys.g:775:1: servererror_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::servererror_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:776:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:776:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SERVERERROR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SERVERERROR\")" );
                    ex->set_ruleName( "servererror_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_servererror_key4231);
            if  (this->hasException())
            {
                goto ruleservererror_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleservererror_keyEx; /* Prevent compiler warnings */
    ruleservererror_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end servererror_key */

/**
 * $ANTLR start parent_key
 * PLSQLKeys.g:779:1: parent_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::parent_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:780:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:780:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PARENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PARENT\")" );
                    ex->set_ruleName( "parent_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_parent_key4254);
            if  (this->hasException())
            {
                goto ruleparent_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleparent_keyEx; /* Prevent compiler warnings */
    ruleparent_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end parent_key */

/**
 * $ANTLR start follows_key
 * PLSQLKeys.g:783:1: follows_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::follows_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:784:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:784:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FOLLOWS\")" );
                    ex->set_ruleName( "follows_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_follows_key4277);
            if  (this->hasException())
            {
                goto rulefollows_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefollows_keyEx; /* Prevent compiler warnings */
    rulefollows_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end follows_key */

/**
 * $ANTLR start nested_key
 * PLSQLKeys.g:787:1: nested_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nested_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:788:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:788:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NESTED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NESTED\")" );
                    ex->set_ruleName( "nested_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nested_key4300);
            if  (this->hasException())
            {
                goto rulenested_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenested_keyEx; /* Prevent compiler warnings */
    rulenested_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nested_key */

/**
 * $ANTLR start old_key
 * PLSQLKeys.g:791:1: old_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::old_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:792:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:792:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OLD"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OLD\")" );
                    ex->set_ruleName( "old_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_old_key4323);
            if  (this->hasException())
            {
                goto ruleold_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleold_keyEx; /* Prevent compiler warnings */
    ruleold_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end old_key */

/**
 * $ANTLR start statement_key
 * PLSQLKeys.g:795:1: statement_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::statement_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:796:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:796:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "STATEMENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"STATEMENT\")" );
                    ex->set_ruleName( "statement_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_statement_key4346);
            if  (this->hasException())
            {
                goto rulestatement_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestatement_keyEx; /* Prevent compiler warnings */
    rulestatement_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end statement_key */

/**
 * $ANTLR start db_role_change_key
 * PLSQLKeys.g:799:1: db_role_change_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::db_role_change_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:800:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:800:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DB_ROLE_CHANGE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DB_ROLE_CHANGE\")" );
                    ex->set_ruleName( "db_role_change_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_db_role_change_key4369);
            if  (this->hasException())
            {
                goto ruledb_role_change_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledb_role_change_keyEx; /* Prevent compiler warnings */
    ruledb_role_change_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end db_role_change_key */

/**
 * $ANTLR start each_key
 * PLSQLKeys.g:803:1: each_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::each_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:804:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:804:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EACH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EACH\")" );
                    ex->set_ruleName( "each_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_each_key4392);
            if  (this->hasException())
            {
                goto ruleeach_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleeach_keyEx; /* Prevent compiler warnings */
    ruleeach_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end each_key */

/**
 * $ANTLR start logoff_key
 * PLSQLKeys.g:807:1: logoff_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::logoff_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:808:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:808:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LOGOFF"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LOGOFF\")" );
                    ex->set_ruleName( "logoff_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_logoff_key4415);
            if  (this->hasException())
            {
                goto rulelogoff_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelogoff_keyEx; /* Prevent compiler warnings */
    rulelogoff_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end logoff_key */

/**
 * $ANTLR start analyze_key
 * PLSQLKeys.g:811:1: analyze_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::analyze_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:812:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:812:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ANALYZE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ANALYZE\")" );
                    ex->set_ruleName( "analyze_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_analyze_key4438);
            if  (this->hasException())
            {
                goto ruleanalyze_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleanalyze_keyEx; /* Prevent compiler warnings */
    ruleanalyze_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end analyze_key */

/**
 * $ANTLR start instead_key
 * PLSQLKeys.g:815:1: instead_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::instead_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:816:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:816:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INSTEAD"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INSTEAD\")" );
                    ex->set_ruleName( "instead_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_instead_key4461);
            if  (this->hasException())
            {
                goto ruleinstead_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinstead_keyEx; /* Prevent compiler warnings */
    ruleinstead_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end instead_key */

/**
 * $ANTLR start associate_key
 * PLSQLKeys.g:819:1: associate_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::associate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:820:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:820:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ASSOCIATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ASSOCIATE\")" );
                    ex->set_ruleName( "associate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_associate_key4484);
            if  (this->hasException())
            {
                goto ruleassociate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleassociate_keyEx; /* Prevent compiler warnings */
    ruleassociate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end associate_key */

/**
 * $ANTLR start new_key
 * PLSQLKeys.g:823:1: new_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::new_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:824:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:824:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NEW"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NEW\")" );
                    ex->set_ruleName( "new_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_new_key4507);
            if  (this->hasException())
            {
                goto rulenew_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenew_keyEx; /* Prevent compiler warnings */
    rulenew_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end new_key */

/**
 * $ANTLR start revoke_key
 * PLSQLKeys.g:827:1: revoke_key : SQL92_RESERVED_REVOKE ;
 */
void
PLSQLParser_PLSQLKeys::revoke_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:828:5: ( SQL92_RESERVED_REVOKE )
        // PLSQLKeys.g:828:10: SQL92_RESERVED_REVOKE
        {
             this->matchToken(SQL92_RESERVED_REVOKE, &FOLLOW_SQL92_RESERVED_REVOKE_in_revoke_key4527);
            if  (this->hasException())
            {
                goto rulerevoke_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerevoke_keyEx; /* Prevent compiler warnings */
    rulerevoke_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end revoke_key */

/**
 * $ANTLR start rename_key
 * PLSQLKeys.g:831:1: rename_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rename_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:832:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:832:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RENAME"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RENAME\")" );
                    ex->set_ruleName( "rename_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rename_key4550);
            if  (this->hasException())
            {
                goto rulerename_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerename_keyEx; /* Prevent compiler warnings */
    rulerename_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rename_key */

/**
 * $ANTLR start customdatum_key
 * PLSQLKeys.g:835:1: customdatum_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::customdatum_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:836:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:836:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CUSTOMDATUM"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CUSTOMDATUM\")" );
                    ex->set_ruleName( "customdatum_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_customdatum_key4574);
            if  (this->hasException())
            {
                goto rulecustomdatum_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecustomdatum_keyEx; /* Prevent compiler warnings */
    rulecustomdatum_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end customdatum_key */

/**
 * $ANTLR start oradata_key
 * PLSQLKeys.g:839:1: oradata_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::oradata_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:840:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:840:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ORADATA"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ORADATA\")" );
                    ex->set_ruleName( "oradata_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_oradata_key4597);
            if  (this->hasException())
            {
                goto ruleoradata_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleoradata_keyEx; /* Prevent compiler warnings */
    ruleoradata_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end oradata_key */

/**
 * $ANTLR start constructor_key
 * PLSQLKeys.g:843:1: constructor_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::constructor_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:844:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:844:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CONSTRUCTOR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CONSTRUCTOR\")" );
                    ex->set_ruleName( "constructor_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_constructor_key4620);
            if  (this->hasException())
            {
                goto ruleconstructor_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconstructor_keyEx; /* Prevent compiler warnings */
    ruleconstructor_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end constructor_key */

/**
 * $ANTLR start sqldata_key
 * PLSQLKeys.g:847:1: sqldata_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sqldata_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:848:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:848:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SQLDATA"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SQLDATA\")" );
                    ex->set_ruleName( "sqldata_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sqldata_key4643);
            if  (this->hasException())
            {
                goto rulesqldata_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesqldata_keyEx; /* Prevent compiler warnings */
    rulesqldata_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sqldata_key */

/**
 * $ANTLR start member_key
 * PLSQLKeys.g:851:1: member_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::member_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:852:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:852:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MEMBER\")" );
                    ex->set_ruleName( "member_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_member_key4666);
            if  (this->hasException())
            {
                goto rulemember_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemember_keyEx; /* Prevent compiler warnings */
    rulemember_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end member_key */

/**
 * $ANTLR start self_key
 * PLSQLKeys.g:855:1: self_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::self_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:856:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:856:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SELF"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SELF\")" );
                    ex->set_ruleName( "self_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_self_key4689);
            if  (this->hasException())
            {
                goto ruleself_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleself_keyEx; /* Prevent compiler warnings */
    ruleself_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end self_key */

/**
 * $ANTLR start object_key
 * PLSQLKeys.g:859:1: object_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::object_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:860:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:860:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OBJECT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OBJECT\")" );
                    ex->set_ruleName( "object_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_object_key4712);
            if  (this->hasException())
            {
                goto ruleobject_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleobject_keyEx; /* Prevent compiler warnings */
    ruleobject_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end object_key */

/**
 * $ANTLR start variable_key
 * PLSQLKeys.g:863:1: variable_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::variable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:864:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:864:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VARIABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VARIABLE\")" );
                    ex->set_ruleName( "variable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_variable_key4735);
            if  (this->hasException())
            {
                goto rulevariable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevariable_keyEx; /* Prevent compiler warnings */
    rulevariable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end variable_key */

/**
 * $ANTLR start instantiable_key
 * PLSQLKeys.g:867:1: instantiable_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::instantiable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:868:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:868:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INSTANTIABLE\")" );
                    ex->set_ruleName( "instantiable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_instantiable_key4758);
            if  (this->hasException())
            {
                goto ruleinstantiable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinstantiable_keyEx; /* Prevent compiler warnings */
    ruleinstantiable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end instantiable_key */

/**
 * $ANTLR start final_key
 * PLSQLKeys.g:871:1: final_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::final_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:872:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:872:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FINAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FINAL\")" );
                    ex->set_ruleName( "final_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_final_key4781);
            if  (this->hasException())
            {
                goto rulefinal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefinal_keyEx; /* Prevent compiler warnings */
    rulefinal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end final_key */

/**
 * $ANTLR start static_key
 * PLSQLKeys.g:875:1: static_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::static_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:876:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:876:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "STATIC"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"STATIC\")" );
                    ex->set_ruleName( "static_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_static_key4804);
            if  (this->hasException())
            {
                goto rulestatic_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestatic_keyEx; /* Prevent compiler warnings */
    rulestatic_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end static_key */

/**
 * $ANTLR start oid_key
 * PLSQLKeys.g:879:1: oid_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::oid_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:880:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:880:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OID"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OID\")" );
                    ex->set_ruleName( "oid_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_oid_key4827);
            if  (this->hasException())
            {
                goto ruleoid_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleoid_keyEx; /* Prevent compiler warnings */
    ruleoid_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end oid_key */

/**
 * $ANTLR start result_key
 * PLSQLKeys.g:883:1: result_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::result_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:884:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:884:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RESULT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RESULT\")" );
                    ex->set_ruleName( "result_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_result_key4850);
            if  (this->hasException())
            {
                goto ruleresult_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleresult_keyEx; /* Prevent compiler warnings */
    ruleresult_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end result_key */

/**
 * $ANTLR start under_key
 * PLSQLKeys.g:887:1: under_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::under_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:888:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:888:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UNDER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UNDER\")" );
                    ex->set_ruleName( "under_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_under_key4873);
            if  (this->hasException())
            {
                goto ruleunder_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunder_keyEx; /* Prevent compiler warnings */
    ruleunder_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end under_key */

/**
 * $ANTLR start map_key
 * PLSQLKeys.g:891:1: map_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::map_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:892:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:892:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MAP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MAP\")" );
                    ex->set_ruleName( "map_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_map_key4896);
            if  (this->hasException())
            {
                goto rulemap_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemap_keyEx; /* Prevent compiler warnings */
    rulemap_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end map_key */

/**
 * $ANTLR start overriding_key
 * PLSQLKeys.g:895:1: overriding_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::overriding_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:896:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:896:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OVERRIDING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OVERRIDING\")" );
                    ex->set_ruleName( "overriding_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_overriding_key4919);
            if  (this->hasException())
            {
                goto ruleoverriding_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleoverriding_keyEx; /* Prevent compiler warnings */
    ruleoverriding_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end overriding_key */

/**
 * $ANTLR start add_key
 * PLSQLKeys.g:899:1: add_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::add_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:900:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:900:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ADD"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ADD\")" );
                    ex->set_ruleName( "add_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_add_key4942);
            if  (this->hasException())
            {
                goto ruleadd_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleadd_keyEx; /* Prevent compiler warnings */
    ruleadd_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end add_key */

/**
 * $ANTLR start modify_key
 * PLSQLKeys.g:903:1: modify_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::modify_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:904:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:904:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MODIFY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MODIFY\")" );
                    ex->set_ruleName( "modify_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_modify_key4965);
            if  (this->hasException())
            {
                goto rulemodify_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodify_keyEx; /* Prevent compiler warnings */
    rulemodify_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end modify_key */

/**
 * $ANTLR start including_key
 * PLSQLKeys.g:907:1: including_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::including_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:908:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:908:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INCLUDING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INCLUDING\")" );
                    ex->set_ruleName( "including_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_including_key4988);
            if  (this->hasException())
            {
                goto ruleincluding_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleincluding_keyEx; /* Prevent compiler warnings */
    ruleincluding_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end including_key */

/**
 * $ANTLR start substitutable_key
 * PLSQLKeys.g:911:1: substitutable_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::substitutable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:912:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:912:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SUBSTITUTABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SUBSTITUTABLE\")" );
                    ex->set_ruleName( "substitutable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_substitutable_key5011);
            if  (this->hasException())
            {
                goto rulesubstitutable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubstitutable_keyEx; /* Prevent compiler warnings */
    rulesubstitutable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end substitutable_key */

/**
 * $ANTLR start attribute_key
 * PLSQLKeys.g:915:1: attribute_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::attribute_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:916:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:916:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ATTRIBUTE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ATTRIBUTE\")" );
                    ex->set_ruleName( "attribute_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_attribute_key5034);
            if  (this->hasException())
            {
                goto ruleattribute_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleattribute_keyEx; /* Prevent compiler warnings */
    ruleattribute_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end attribute_key */

/**
 * $ANTLR start cascade_key
 * PLSQLKeys.g:919:1: cascade_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::cascade_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:920:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:920:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CASCADE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CASCADE\")" );
                    ex->set_ruleName( "cascade_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cascade_key5057);
            if  (this->hasException())
            {
                goto rulecascade_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecascade_keyEx; /* Prevent compiler warnings */
    rulecascade_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cascade_key */

/**
 * $ANTLR start data_key
 * PLSQLKeys.g:923:1: data_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::data_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:924:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:924:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DATA"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DATA\")" );
                    ex->set_ruleName( "data_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_data_key5081);
            if  (this->hasException())
            {
                goto ruledata_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledata_keyEx; /* Prevent compiler warnings */
    ruledata_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end data_key */

/**
 * $ANTLR start invalidate_key
 * PLSQLKeys.g:927:1: invalidate_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::invalidate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:928:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:928:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INVALIDATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INVALIDATE\")" );
                    ex->set_ruleName( "invalidate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_invalidate_key5103);
            if  (this->hasException())
            {
                goto ruleinvalidate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinvalidate_keyEx; /* Prevent compiler warnings */
    ruleinvalidate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end invalidate_key */

/**
 * $ANTLR start element_key
 * PLSQLKeys.g:931:1: element_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::element_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:932:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:932:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ELEMENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ELEMENT\")" );
                    ex->set_ruleName( "element_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_element_key5126);
            if  (this->hasException())
            {
                goto ruleelement_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleelement_keyEx; /* Prevent compiler warnings */
    ruleelement_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end element_key */

/**
 * $ANTLR start first_key
 * PLSQLKeys.g:935:1: first_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::first_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:936:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:936:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FIRST"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FIRST\")" );
                    ex->set_ruleName( "first_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_first_key5149);
            if  (this->hasException())
            {
                goto rulefirst_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefirst_keyEx; /* Prevent compiler warnings */
    rulefirst_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end first_key */

/**
 * $ANTLR start check_key
 * PLSQLKeys.g:939:1: check_key : SQL92_RESERVED_CHECK ;
 */
void
PLSQLParser_PLSQLKeys::check_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:940:5: ( SQL92_RESERVED_CHECK )
        // PLSQLKeys.g:940:10: SQL92_RESERVED_CHECK
        {
             this->matchToken(SQL92_RESERVED_CHECK, &FOLLOW_SQL92_RESERVED_CHECK_in_check_key5169);
            if  (this->hasException())
            {
                goto rulecheck_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecheck_keyEx; /* Prevent compiler warnings */
    rulecheck_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end check_key */

/**
 * $ANTLR start option_key
 * PLSQLKeys.g:943:1: option_key : SQL92_RESERVED_OPTION ;
 */
void
PLSQLParser_PLSQLKeys::option_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:944:5: ( SQL92_RESERVED_OPTION )
        // PLSQLKeys.g:944:10: SQL92_RESERVED_OPTION
        {
             this->matchToken(SQL92_RESERVED_OPTION, &FOLLOW_SQL92_RESERVED_OPTION_in_option_key5189);
            if  (this->hasException())
            {
                goto ruleoption_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleoption_keyEx; /* Prevent compiler warnings */
    ruleoption_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end option_key */

/**
 * $ANTLR start nocycle_key
 * PLSQLKeys.g:947:1: nocycle_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nocycle_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:948:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:948:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOCYCLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOCYCLE\")" );
                    ex->set_ruleName( "nocycle_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nocycle_key5212);
            if  (this->hasException())
            {
                goto rulenocycle_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenocycle_keyEx; /* Prevent compiler warnings */
    rulenocycle_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nocycle_key */

/**
 * $ANTLR start locked_key
 * PLSQLKeys.g:951:1: locked_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::locked_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:952:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:952:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LOCKED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LOCKED\")" );
                    ex->set_ruleName( "locked_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_locked_key5235);
            if  (this->hasException())
            {
                goto rulelocked_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelocked_keyEx; /* Prevent compiler warnings */
    rulelocked_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end locked_key */

/**
 * $ANTLR start block_key
 * PLSQLKeys.g:955:1: block_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::block_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:956:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:956:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BLOCK"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BLOCK\")" );
                    ex->set_ruleName( "block_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_block_key5258);
            if  (this->hasException())
            {
                goto ruleblock_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleblock_keyEx; /* Prevent compiler warnings */
    ruleblock_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end block_key */

/**
 * $ANTLR start xml_key
 * PLSQLKeys.g:959:1: xml_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xml_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:960:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:960:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XML"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XML\")" );
                    ex->set_ruleName( "xml_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xml_key5281);
            if  (this->hasException())
            {
                goto rulexml_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexml_keyEx; /* Prevent compiler warnings */
    rulexml_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xml_key */

/**
 * $ANTLR start pivot_key
 * PLSQLKeys.g:963:1: pivot_key : PLSQL_NON_RESERVED_PIVOT ;
 */
void
PLSQLParser_PLSQLKeys::pivot_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:964:5: ( PLSQL_NON_RESERVED_PIVOT )
        // PLSQLKeys.g:964:11: PLSQL_NON_RESERVED_PIVOT
        {
             this->matchToken(PLSQL_NON_RESERVED_PIVOT, &FOLLOW_PLSQL_NON_RESERVED_PIVOT_in_pivot_key5302);
            if  (this->hasException())
            {
                goto rulepivot_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepivot_keyEx; /* Prevent compiler warnings */
    rulepivot_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pivot_key */

/**
 * $ANTLR start prior_key
 * PLSQLKeys.g:967:1: prior_key : SQL92_RESERVED_PRIOR ;
 */
void
PLSQLParser_PLSQLKeys::prior_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:968:5: ( SQL92_RESERVED_PRIOR )
        // PLSQLKeys.g:968:10: SQL92_RESERVED_PRIOR
        {
             this->matchToken(SQL92_RESERVED_PRIOR, &FOLLOW_SQL92_RESERVED_PRIOR_in_prior_key5322);
            if  (this->hasException())
            {
                goto ruleprior_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprior_keyEx; /* Prevent compiler warnings */
    ruleprior_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prior_key */

/**
 * $ANTLR start sequential_key
 * PLSQLKeys.g:971:1: sequential_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sequential_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:972:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:972:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SEQUENTIAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SEQUENTIAL\")" );
                    ex->set_ruleName( "sequential_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sequential_key5345);
            if  (this->hasException())
            {
                goto rulesequential_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesequential_keyEx; /* Prevent compiler warnings */
    rulesequential_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sequential_key */

/**
 * $ANTLR start single_key
 * PLSQLKeys.g:975:1: single_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::single_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:976:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:976:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SINGLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SINGLE\")" );
                    ex->set_ruleName( "single_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_single_key5368);
            if  (this->hasException())
            {
                goto rulesingle_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesingle_keyEx; /* Prevent compiler warnings */
    rulesingle_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end single_key */

/**
 * $ANTLR start skip_key
 * PLSQLKeys.g:979:1: skip_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::skip_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:980:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:980:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SKIP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SKIP\")" );
                    ex->set_ruleName( "skip_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_skip_key5391);
            if  (this->hasException())
            {
                goto ruleskip_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleskip_keyEx; /* Prevent compiler warnings */
    ruleskip_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end skip_key */

/**
 * $ANTLR start model_key
 * PLSQLKeys.g:983:1: model_key : PLSQL_NON_RESERVED_MODEL ;
 */
void
PLSQLParser_PLSQLKeys::model_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:984:5: ( PLSQL_NON_RESERVED_MODEL )
        // PLSQLKeys.g:985:9: PLSQL_NON_RESERVED_MODEL
        {
             this->matchToken(PLSQL_NON_RESERVED_MODEL, &FOLLOW_PLSQL_NON_RESERVED_MODEL_in_model_key5420);
            if  (this->hasException())
            {
                goto rulemodel_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_keyEx; /* Prevent compiler warnings */
    rulemodel_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_key */

/**
 * $ANTLR start updated_key
 * PLSQLKeys.g:988:1: updated_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::updated_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:989:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:989:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UPDATED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UPDATED\")" );
                    ex->set_ruleName( "updated_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_updated_key5443);
            if  (this->hasException())
            {
                goto ruleupdated_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleupdated_keyEx; /* Prevent compiler warnings */
    ruleupdated_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end updated_key */

/**
 * $ANTLR start increment_key
 * PLSQLKeys.g:992:1: increment_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::increment_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:993:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:993:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INCREMENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INCREMENT\")" );
                    ex->set_ruleName( "increment_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_increment_key5466);
            if  (this->hasException())
            {
                goto ruleincrement_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleincrement_keyEx; /* Prevent compiler warnings */
    ruleincrement_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end increment_key */

/**
 * $ANTLR start exclude_key
 * PLSQLKeys.g:996:1: exclude_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::exclude_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:997:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:997:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXCLUDE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXCLUDE\")" );
                    ex->set_ruleName( "exclude_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_exclude_key5489);
            if  (this->hasException())
            {
                goto ruleexclude_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexclude_keyEx; /* Prevent compiler warnings */
    ruleexclude_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exclude_key */

/**
 * $ANTLR start reference_key
 * PLSQLKeys.g:1000:1: reference_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::reference_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1001:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1001:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "REFERENCE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"REFERENCE\")" );
                    ex->set_ruleName( "reference_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_reference_key5512);
            if  (this->hasException())
            {
                goto rulereference_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereference_keyEx; /* Prevent compiler warnings */
    rulereference_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end reference_key */

/**
 * $ANTLR start sets_key
 * PLSQLKeys.g:1004:1: sets_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sets_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1005:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1005:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SETS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SETS\")" );
                    ex->set_ruleName( "sets_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sets_key5535);
            if  (this->hasException())
            {
                goto rulesets_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesets_keyEx; /* Prevent compiler warnings */
    rulesets_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sets_key */

/**
 * $ANTLR start until_key
 * PLSQLKeys.g:1008:1: until_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::until_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1009:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1009:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UNTIL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UNTIL\")" );
                    ex->set_ruleName( "until_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_until_key5558);
            if  (this->hasException())
            {
                goto ruleuntil_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleuntil_keyEx; /* Prevent compiler warnings */
    ruleuntil_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end until_key */

/**
 * $ANTLR start seed_key
 * PLSQLKeys.g:1012:1: seed_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::seed_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1013:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1013:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SEED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SEED\")" );
                    ex->set_ruleName( "seed_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_seed_key5581);
            if  (this->hasException())
            {
                goto ruleseed_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleseed_keyEx; /* Prevent compiler warnings */
    ruleseed_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end seed_key */

/**
 * $ANTLR start maxvalue_key
 * PLSQLKeys.g:1016:1: maxvalue_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::maxvalue_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1017:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1017:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MAXVALUE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MAXVALUE\")" );
                    ex->set_ruleName( "maxvalue_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_maxvalue_key5604);
            if  (this->hasException())
            {
                goto rulemaxvalue_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemaxvalue_keyEx; /* Prevent compiler warnings */
    rulemaxvalue_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end maxvalue_key */

/**
 * $ANTLR start siblings_key
 * PLSQLKeys.g:1020:1: siblings_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::siblings_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1021:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1021:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SIBLINGS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SIBLINGS\")" );
                    ex->set_ruleName( "siblings_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_siblings_key5627);
            if  (this->hasException())
            {
                goto rulesiblings_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesiblings_keyEx; /* Prevent compiler warnings */
    rulesiblings_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end siblings_key */

/**
 * $ANTLR start cube_key
 * PLSQLKeys.g:1024:1: cube_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::cube_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1025:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1025:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CUBE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CUBE\")" );
                    ex->set_ruleName( "cube_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cube_key5650);
            if  (this->hasException())
            {
                goto rulecube_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecube_keyEx; /* Prevent compiler warnings */
    rulecube_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cube_key */

/**
 * $ANTLR start nulls_key
 * PLSQLKeys.g:1028:1: nulls_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nulls_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1029:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1029:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NULLS\")" );
                    ex->set_ruleName( "nulls_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nulls_key5673);
            if  (this->hasException())
            {
                goto rulenulls_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenulls_keyEx; /* Prevent compiler warnings */
    rulenulls_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nulls_key */

/**
 * $ANTLR start dimension_key
 * PLSQLKeys.g:1032:1: dimension_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::dimension_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1033:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1033:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DIMENSION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DIMENSION\")" );
                    ex->set_ruleName( "dimension_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dimension_key5696);
            if  (this->hasException())
            {
                goto ruledimension_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledimension_keyEx; /* Prevent compiler warnings */
    ruledimension_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dimension_key */

/**
 * $ANTLR start scn_key
 * PLSQLKeys.g:1036:1: scn_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::scn_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1037:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1037:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SCN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SCN\")" );
                    ex->set_ruleName( "scn_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_scn_key5719);
            if  (this->hasException())
            {
                goto rulescn_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulescn_keyEx; /* Prevent compiler warnings */
    rulescn_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end scn_key */

/**
 * $ANTLR start snapshot_key
 * PLSQLKeys.g:1040:1: snapshot_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::snapshot_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1041:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1041:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SNAPSHOT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SNAPSHOT\")" );
                    ex->set_ruleName( "snapshot_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_snapshot_key5742);
            if  (this->hasException())
            {
                goto rulesnapshot_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesnapshot_keyEx; /* Prevent compiler warnings */
    rulesnapshot_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end snapshot_key */

/**
 * $ANTLR start decrement_key
 * PLSQLKeys.g:1044:1: decrement_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::decrement_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1045:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1045:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DECREMENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DECREMENT\")" );
                    ex->set_ruleName( "decrement_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_decrement_key5765);
            if  (this->hasException())
            {
                goto ruledecrement_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledecrement_keyEx; /* Prevent compiler warnings */
    ruledecrement_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end decrement_key */

/**
 * $ANTLR start unpivot_key
 * PLSQLKeys.g:1048:1: unpivot_key : PLSQL_NON_RESERVED_UNPIVOT ;
 */
void
PLSQLParser_PLSQLKeys::unpivot_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1049:5: ( PLSQL_NON_RESERVED_UNPIVOT )
        // PLSQLKeys.g:1049:10: PLSQL_NON_RESERVED_UNPIVOT
        {
             this->matchToken(PLSQL_NON_RESERVED_UNPIVOT, &FOLLOW_PLSQL_NON_RESERVED_UNPIVOT_in_unpivot_key5785);
            if  (this->hasException())
            {
                goto ruleunpivot_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunpivot_keyEx; /* Prevent compiler warnings */
    ruleunpivot_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unpivot_key */

/**
 * $ANTLR start keep_key
 * PLSQLKeys.g:1052:1: keep_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::keep_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1053:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1053:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "KEEP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"KEEP\")" );
                    ex->set_ruleName( "keep_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_keep_key5808);
            if  (this->hasException())
            {
                goto rulekeep_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulekeep_keyEx; /* Prevent compiler warnings */
    rulekeep_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end keep_key */

/**
 * $ANTLR start measures_key
 * PLSQLKeys.g:1056:1: measures_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::measures_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1057:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1057:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MEASURES"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MEASURES\")" );
                    ex->set_ruleName( "measures_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_measures_key5831);
            if  (this->hasException())
            {
                goto rulemeasures_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemeasures_keyEx; /* Prevent compiler warnings */
    rulemeasures_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end measures_key */

/**
 * $ANTLR start rows_key
 * PLSQLKeys.g:1060:1: rows_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rows_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1061:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1061:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ROWS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ROWS\")" );
                    ex->set_ruleName( "rows_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rows_key5854);
            if  (this->hasException())
            {
                goto rulerows_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerows_keyEx; /* Prevent compiler warnings */
    rulerows_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rows_key */

/**
 * $ANTLR start sample_key
 * PLSQLKeys.g:1064:1: sample_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sample_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1065:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1065:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SAMPLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SAMPLE\")" );
                    ex->set_ruleName( "sample_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sample_key5877);
            if  (this->hasException())
            {
                goto rulesample_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesample_keyEx; /* Prevent compiler warnings */
    rulesample_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sample_key */

/**
 * $ANTLR start upsert_key
 * PLSQLKeys.g:1068:1: upsert_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::upsert_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1069:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1069:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UPSERT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UPSERT\")" );
                    ex->set_ruleName( "upsert_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_upsert_key5900);
            if  (this->hasException())
            {
                goto ruleupsert_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleupsert_keyEx; /* Prevent compiler warnings */
    ruleupsert_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end upsert_key */

/**
 * $ANTLR start versions_key
 * PLSQLKeys.g:1072:1: versions_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::versions_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1073:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1073:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VERSIONS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VERSIONS\")" );
                    ex->set_ruleName( "versions_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_versions_key5923);
            if  (this->hasException())
            {
                goto ruleversions_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleversions_keyEx; /* Prevent compiler warnings */
    ruleversions_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end versions_key */

/**
 * $ANTLR start rules_key
 * PLSQLKeys.g:1076:1: rules_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rules_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1077:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1077:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RULES"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RULES\")" );
                    ex->set_ruleName( "rules_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rules_key5946);
            if  (this->hasException())
            {
                goto rulerules_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerules_keyEx; /* Prevent compiler warnings */
    rulerules_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rules_key */

/**
 * $ANTLR start iterate_key
 * PLSQLKeys.g:1080:1: iterate_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::iterate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1081:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1081:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ITERATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ITERATE\")" );
                    ex->set_ruleName( "iterate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_iterate_key5969);
            if  (this->hasException())
            {
                goto ruleiterate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleiterate_keyEx; /* Prevent compiler warnings */
    ruleiterate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end iterate_key */

/**
 * $ANTLR start minvalue_key
 * PLSQLKeys.g:1084:1: minvalue_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::minvalue_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1085:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1085:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MINVALUE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MINVALUE\")" );
                    ex->set_ruleName( "minvalue_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_minvalue_key5992);
            if  (this->hasException())
            {
                goto ruleminvalue_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleminvalue_keyEx; /* Prevent compiler warnings */
    ruleminvalue_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end minvalue_key */

/**
 * $ANTLR start rollup_key
 * PLSQLKeys.g:1088:1: rollup_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rollup_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1089:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1089:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ROLLUP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ROLLUP\")" );
                    ex->set_ruleName( "rollup_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rollup_key6015);
            if  (this->hasException())
            {
                goto rulerollup_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerollup_keyEx; /* Prevent compiler warnings */
    rulerollup_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rollup_key */

/**
 * $ANTLR start nav_key
 * PLSQLKeys.g:1092:1: nav_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nav_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1093:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1093:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NAV"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NAV\")" );
                    ex->set_ruleName( "nav_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nav_key6038);
            if  (this->hasException())
            {
                goto rulenav_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenav_keyEx; /* Prevent compiler warnings */
    rulenav_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nav_key */

/**
 * $ANTLR start automatic_key
 * PLSQLKeys.g:1096:1: automatic_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::automatic_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1097:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1097:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AUTOMATIC"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AUTOMATIC\")" );
                    ex->set_ruleName( "automatic_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_automatic_key6061);
            if  (this->hasException())
            {
                goto ruleautomatic_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleautomatic_keyEx; /* Prevent compiler warnings */
    ruleautomatic_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end automatic_key */

/**
 * $ANTLR start last_key
 * PLSQLKeys.g:1100:1: last_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::last_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1101:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1101:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LAST"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LAST\")" );
                    ex->set_ruleName( "last_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_last_key6084);
            if  (this->hasException())
            {
                goto rulelast_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelast_keyEx; /* Prevent compiler warnings */
    rulelast_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end last_key */

/**
 * $ANTLR start main_key
 * PLSQLKeys.g:1104:1: main_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::main_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1105:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1105:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MAIN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MAIN\")" );
                    ex->set_ruleName( "main_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_main_key6107);
            if  (this->hasException())
            {
                goto rulemain_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemain_keyEx; /* Prevent compiler warnings */
    rulemain_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end main_key */

/**
 * $ANTLR start grouping_key
 * PLSQLKeys.g:1108:1: grouping_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::grouping_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1109:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1109:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "GROUPING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"GROUPING\")" );
                    ex->set_ruleName( "grouping_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_grouping_key6130);
            if  (this->hasException())
            {
                goto rulegrouping_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulegrouping_keyEx; /* Prevent compiler warnings */
    rulegrouping_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end grouping_key */

/**
 * $ANTLR start include_key
 * PLSQLKeys.g:1112:1: include_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::include_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1113:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1113:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INCLUDE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INCLUDE\")" );
                    ex->set_ruleName( "include_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_include_key6153);
            if  (this->hasException())
            {
                goto ruleinclude_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinclude_keyEx; /* Prevent compiler warnings */
    ruleinclude_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end include_key */

/**
 * $ANTLR start ignore_key
 * PLSQLKeys.g:1116:1: ignore_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::ignore_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1117:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1117:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "IGNORE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"IGNORE\")" );
                    ex->set_ruleName( "ignore_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ignore_key6176);
            if  (this->hasException())
            {
                goto ruleignore_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleignore_keyEx; /* Prevent compiler warnings */
    ruleignore_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end ignore_key */

/**
 * $ANTLR start respect_key
 * PLSQLKeys.g:1120:1: respect_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::respect_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1121:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1121:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RESPECT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RESPECT\")" );
                    ex->set_ruleName( "respect_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_respect_key6199);
            if  (this->hasException())
            {
                goto rulerespect_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerespect_keyEx; /* Prevent compiler warnings */
    rulerespect_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end respect_key */

/**
 * $ANTLR start unique_key
 * PLSQLKeys.g:1124:1: unique_key : SQL92_RESERVED_UNIQUE ;
 */
void
PLSQLParser_PLSQLKeys::unique_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1125:5: ( SQL92_RESERVED_UNIQUE )
        // PLSQLKeys.g:1125:10: SQL92_RESERVED_UNIQUE
        {
             this->matchToken(SQL92_RESERVED_UNIQUE, &FOLLOW_SQL92_RESERVED_UNIQUE_in_unique_key6219);
            if  (this->hasException())
            {
                goto ruleunique_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunique_keyEx; /* Prevent compiler warnings */
    ruleunique_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unique_key */

/**
 * $ANTLR start submultiset_key
 * PLSQLKeys.g:1128:1: submultiset_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::submultiset_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1129:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1129:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SUBMULTISET"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SUBMULTISET\")" );
                    ex->set_ruleName( "submultiset_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_submultiset_key6242);
            if  (this->hasException())
            {
                goto rulesubmultiset_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubmultiset_keyEx; /* Prevent compiler warnings */
    rulesubmultiset_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end submultiset_key */

/**
 * $ANTLR start at_key
 * PLSQLKeys.g:1132:1: at_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::at_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1133:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1133:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AT\")" );
                    ex->set_ruleName( "at_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_at_key6265);
            if  (this->hasException())
            {
                goto ruleat_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleat_keyEx; /* Prevent compiler warnings */
    ruleat_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end at_key */

/**
 * $ANTLR start a_key
 * PLSQLKeys.g:1137:1: a_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::a_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1138:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1138:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "A"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"A\")" );
                    ex->set_ruleName( "a_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_a_key6289);
            if  (this->hasException())
            {
                goto rulea_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulea_keyEx; /* Prevent compiler warnings */
    rulea_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end a_key */

/**
 * $ANTLR start empty_key
 * PLSQLKeys.g:1141:1: empty_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::empty_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1142:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1142:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EMPTY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EMPTY\")" );
                    ex->set_ruleName( "empty_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_empty_key6312);
            if  (this->hasException())
            {
                goto ruleempty_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleempty_keyEx; /* Prevent compiler warnings */
    ruleempty_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end empty_key */

/**
 * $ANTLR start likec_key
 * PLSQLKeys.g:1145:1: likec_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::likec_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1146:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1146:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LIKEC"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LIKEC\")" );
                    ex->set_ruleName( "likec_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_likec_key6335);
            if  (this->hasException())
            {
                goto rulelikec_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelikec_keyEx; /* Prevent compiler warnings */
    rulelikec_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end likec_key */

/**
 * $ANTLR start nan_key
 * PLSQLKeys.g:1149:1: nan_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nan_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1150:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1150:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NAN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NAN\")" );
                    ex->set_ruleName( "nan_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nan_key6358);
            if  (this->hasException())
            {
                goto rulenan_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenan_keyEx; /* Prevent compiler warnings */
    rulenan_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nan_key */

/**
 * $ANTLR start infinite_key
 * PLSQLKeys.g:1153:1: infinite_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::infinite_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1154:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1154:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INFINITE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INFINITE\")" );
                    ex->set_ruleName( "infinite_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_infinite_key6381);
            if  (this->hasException())
            {
                goto ruleinfinite_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinfinite_keyEx; /* Prevent compiler warnings */
    ruleinfinite_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end infinite_key */

/**
 * $ANTLR start like2_key
 * PLSQLKeys.g:1157:1: like2_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::like2_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1158:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1158:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LIKE2"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LIKE2\")" );
                    ex->set_ruleName( "like2_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_like2_key6404);
            if  (this->hasException())
            {
                goto rulelike2_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelike2_keyEx; /* Prevent compiler warnings */
    rulelike2_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end like2_key */

/**
 * $ANTLR start like4_key
 * PLSQLKeys.g:1161:1: like4_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::like4_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1162:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1162:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LIKE4"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LIKE4\")" );
                    ex->set_ruleName( "like4_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_like4_key6427);
            if  (this->hasException())
            {
                goto rulelike4_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelike4_keyEx; /* Prevent compiler warnings */
    rulelike4_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end like4_key */

/**
 * $ANTLR start present_key
 * PLSQLKeys.g:1165:1: present_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::present_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1166:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1166:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PRESENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PRESENT\")" );
                    ex->set_ruleName( "present_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_present_key6450);
            if  (this->hasException())
            {
                goto rulepresent_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepresent_keyEx; /* Prevent compiler warnings */
    rulepresent_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end present_key */

/**
 * $ANTLR start dbtimezone_key
 * PLSQLKeys.g:1169:1: dbtimezone_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::dbtimezone_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1170:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1170:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DBTIMEZONE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DBTIMEZONE\")" );
                    ex->set_ruleName( "dbtimezone_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dbtimezone_key6473);
            if  (this->hasException())
            {
                goto ruledbtimezone_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledbtimezone_keyEx; /* Prevent compiler warnings */
    ruledbtimezone_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dbtimezone_key */

/**
 * $ANTLR start sessiontimezone_key
 * PLSQLKeys.g:1173:1: sessiontimezone_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sessiontimezone_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1174:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1174:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SESSIONTIMEZONE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SESSIONTIMEZONE\")" );
                    ex->set_ruleName( "sessiontimezone_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sessiontimezone_key6496);
            if  (this->hasException())
            {
                goto rulesessiontimezone_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesessiontimezone_keyEx; /* Prevent compiler warnings */
    rulesessiontimezone_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sessiontimezone_key */

/**
 * $ANTLR start nchar_cs_key
 * PLSQLKeys.g:1177:1: nchar_cs_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nchar_cs_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1178:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1178:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NCHAR_CS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NCHAR_CS\")" );
                    ex->set_ruleName( "nchar_cs_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nchar_cs_key6519);
            if  (this->hasException())
            {
                goto rulenchar_cs_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenchar_cs_keyEx; /* Prevent compiler warnings */
    rulenchar_cs_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nchar_cs_key */

/**
 * $ANTLR start decompose_key
 * PLSQLKeys.g:1181:1: decompose_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::decompose_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1182:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1182:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DECOMPOSE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DECOMPOSE\")" );
                    ex->set_ruleName( "decompose_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_decompose_key6542);
            if  (this->hasException())
            {
                goto ruledecompose_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledecompose_keyEx; /* Prevent compiler warnings */
    ruledecompose_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end decompose_key */

/**
 * $ANTLR start following_key
 * PLSQLKeys.g:1185:1: following_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::following_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1186:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1186:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FOLLOWING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FOLLOWING\")" );
                    ex->set_ruleName( "following_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_following_key6565);
            if  (this->hasException())
            {
                goto rulefollowing_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefollowing_keyEx; /* Prevent compiler warnings */
    rulefollowing_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end following_key */

/**
 * $ANTLR start first_value_key
 * PLSQLKeys.g:1189:1: first_value_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::first_value_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1190:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1190:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FIRST_VALUE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FIRST_VALUE\")" );
                    ex->set_ruleName( "first_value_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_first_value_key6588);
            if  (this->hasException())
            {
                goto rulefirst_value_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefirst_value_keyEx; /* Prevent compiler warnings */
    rulefirst_value_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end first_value_key */

/**
 * $ANTLR start preceding_key
 * PLSQLKeys.g:1193:1: preceding_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::preceding_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1194:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1194:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PRECEDING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PRECEDING\")" );
                    ex->set_ruleName( "preceding_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_preceding_key6611);
            if  (this->hasException())
            {
                goto rulepreceding_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepreceding_keyEx; /* Prevent compiler warnings */
    rulepreceding_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end preceding_key */

/**
 * $ANTLR start within_key
 * PLSQLKeys.g:1197:1: within_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::within_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1198:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1198:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "WITHIN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"WITHIN\")" );
                    ex->set_ruleName( "within_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_within_key6634);
            if  (this->hasException())
            {
                goto rulewithin_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewithin_keyEx; /* Prevent compiler warnings */
    rulewithin_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end within_key */

/**
 * $ANTLR start canonical_key
 * PLSQLKeys.g:1201:1: canonical_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::canonical_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1202:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1202:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CANONICAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CANONICAL\")" );
                    ex->set_ruleName( "canonical_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_canonical_key6657);
            if  (this->hasException())
            {
                goto rulecanonical_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecanonical_keyEx; /* Prevent compiler warnings */
    rulecanonical_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end canonical_key */

/**
 * $ANTLR start compatibility_key
 * PLSQLKeys.g:1205:1: compatibility_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::compatibility_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1206:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1206:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COMPATIBILITY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COMPATIBILITY\")" );
                    ex->set_ruleName( "compatibility_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_compatibility_key6680);
            if  (this->hasException())
            {
                goto rulecompatibility_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecompatibility_keyEx; /* Prevent compiler warnings */
    rulecompatibility_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end compatibility_key */

/**
 * $ANTLR start over_key
 * PLSQLKeys.g:1209:1: over_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::over_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1210:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1210:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OVER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OVER\")" );
                    ex->set_ruleName( "over_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_over_key6703);
            if  (this->hasException())
            {
                goto ruleover_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleover_keyEx; /* Prevent compiler warnings */
    ruleover_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end over_key */

/**
 * $ANTLR start multiset_key
 * PLSQLKeys.g:1213:1: multiset_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::multiset_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1214:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1214:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MULTISET"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MULTISET\")" );
                    ex->set_ruleName( "multiset_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_multiset_key6726);
            if  (this->hasException())
            {
                goto rulemultiset_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemultiset_keyEx; /* Prevent compiler warnings */
    rulemultiset_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multiset_key */

/**
 * $ANTLR start connect_by_root_key
 * PLSQLKeys.g:1217:1: connect_by_root_key : PLSQL_NON_RESERVED_CONNECT_BY_ROOT ;
 */
void
PLSQLParser_PLSQLKeys::connect_by_root_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1218:5: ( PLSQL_NON_RESERVED_CONNECT_BY_ROOT )
        // PLSQLKeys.g:1218:10: PLSQL_NON_RESERVED_CONNECT_BY_ROOT
        {
             this->matchToken(PLSQL_NON_RESERVED_CONNECT_BY_ROOT, &FOLLOW_PLSQL_NON_RESERVED_CONNECT_BY_ROOT_in_connect_by_root_key6746);
            if  (this->hasException())
            {
                goto ruleconnect_by_root_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconnect_by_root_keyEx; /* Prevent compiler warnings */
    ruleconnect_by_root_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end connect_by_root_key */

/**
 * $ANTLR start last_value_key
 * PLSQLKeys.g:1221:1: last_value_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::last_value_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1222:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1222:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LAST_VALUE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LAST_VALUE\")" );
                    ex->set_ruleName( "last_value_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_last_value_key6769);
            if  (this->hasException())
            {
                goto rulelast_value_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelast_value_keyEx; /* Prevent compiler warnings */
    rulelast_value_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end last_value_key */

/**
 * $ANTLR start current_key
 * PLSQLKeys.g:1225:1: current_key : SQL92_RESERVED_CURRENT ;
 */
void
PLSQLParser_PLSQLKeys::current_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1226:5: ( SQL92_RESERVED_CURRENT )
        // PLSQLKeys.g:1226:10: SQL92_RESERVED_CURRENT
        {
             this->matchToken(SQL92_RESERVED_CURRENT, &FOLLOW_SQL92_RESERVED_CURRENT_in_current_key6789);
            if  (this->hasException())
            {
                goto rulecurrent_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecurrent_keyEx; /* Prevent compiler warnings */
    rulecurrent_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end current_key */

/**
 * $ANTLR start unbounded_key
 * PLSQLKeys.g:1229:1: unbounded_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::unbounded_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1230:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1230:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UNBOUNDED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UNBOUNDED\")" );
                    ex->set_ruleName( "unbounded_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_unbounded_key6812);
            if  (this->hasException())
            {
                goto ruleunbounded_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunbounded_keyEx; /* Prevent compiler warnings */
    ruleunbounded_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unbounded_key */

/**
 * $ANTLR start dense_rank_key
 * PLSQLKeys.g:1233:1: dense_rank_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::dense_rank_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1234:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1234:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DENSE_RANK"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DENSE_RANK\")" );
                    ex->set_ruleName( "dense_rank_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dense_rank_key6835);
            if  (this->hasException())
            {
                goto ruledense_rank_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledense_rank_keyEx; /* Prevent compiler warnings */
    ruledense_rank_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dense_rank_key */

/**
 * $ANTLR start cost_key
 * PLSQLKeys.g:1237:1: cost_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::cost_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1238:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1238:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COST"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COST\")" );
                    ex->set_ruleName( "cost_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cost_key6858);
            if  (this->hasException())
            {
                goto rulecost_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecost_keyEx; /* Prevent compiler warnings */
    rulecost_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cost_key */

/**
 * $ANTLR start char_cs_key
 * PLSQLKeys.g:1241:1: char_cs_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::char_cs_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1242:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1242:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CHAR_CS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CHAR_CS\")" );
                    ex->set_ruleName( "char_cs_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_char_cs_key6881);
            if  (this->hasException())
            {
                goto rulechar_cs_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulechar_cs_keyEx; /* Prevent compiler warnings */
    rulechar_cs_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end char_cs_key */

/**
 * $ANTLR start auto_key
 * PLSQLKeys.g:1245:1: auto_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::auto_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1246:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1246:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AUTO"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AUTO\")" );
                    ex->set_ruleName( "auto_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_auto_key6904);
            if  (this->hasException())
            {
                goto ruleauto_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleauto_keyEx; /* Prevent compiler warnings */
    ruleauto_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end auto_key */

/**
 * $ANTLR start treat_key
 * PLSQLKeys.g:1249:1: treat_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::treat_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1250:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1250:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TREAT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TREAT\")" );
                    ex->set_ruleName( "treat_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_treat_key6927);
            if  (this->hasException())
            {
                goto ruletreat_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletreat_keyEx; /* Prevent compiler warnings */
    ruletreat_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end treat_key */

/**
 * $ANTLR start content_key
 * PLSQLKeys.g:1253:1: content_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::content_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1254:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1254:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CONTENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CONTENT\")" );
                    ex->set_ruleName( "content_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_content_key6950);
            if  (this->hasException())
            {
                goto rulecontent_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecontent_keyEx; /* Prevent compiler warnings */
    rulecontent_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end content_key */

/**
 * $ANTLR start xmlparse_key
 * PLSQLKeys.g:1257:1: xmlparse_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlparse_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1258:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1258:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLPARSE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLPARSE\")" );
                    ex->set_ruleName( "xmlparse_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlparse_key6973);
            if  (this->hasException())
            {
                goto rulexmlparse_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlparse_keyEx; /* Prevent compiler warnings */
    rulexmlparse_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlparse_key */

/**
 * $ANTLR start xmlelement_key
 * PLSQLKeys.g:1261:1: xmlelement_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlelement_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1262:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1262:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLELEMENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLELEMENT\")" );
                    ex->set_ruleName( "xmlelement_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlelement_key6996);
            if  (this->hasException())
            {
                goto rulexmlelement_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlelement_keyEx; /* Prevent compiler warnings */
    rulexmlelement_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlelement_key */

/**
 * $ANTLR start entityescaping_key
 * PLSQLKeys.g:1265:1: entityescaping_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::entityescaping_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1266:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1266:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ENTITYESCAPING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ENTITYESCAPING\")" );
                    ex->set_ruleName( "entityescaping_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_entityescaping_key7019);
            if  (this->hasException())
            {
                goto ruleentityescaping_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleentityescaping_keyEx; /* Prevent compiler warnings */
    ruleentityescaping_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end entityescaping_key */

/**
 * $ANTLR start standalone_key
 * PLSQLKeys.g:1269:1: standalone_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::standalone_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1270:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1270:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "STANDALONE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"STANDALONE\")" );
                    ex->set_ruleName( "standalone_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_standalone_key7042);
            if  (this->hasException())
            {
                goto rulestandalone_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestandalone_keyEx; /* Prevent compiler warnings */
    rulestandalone_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end standalone_key */

/**
 * $ANTLR start wellformed_key
 * PLSQLKeys.g:1273:1: wellformed_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::wellformed_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1274:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1274:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "WELLFORMED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"WELLFORMED\")" );
                    ex->set_ruleName( "wellformed_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_wellformed_key7065);
            if  (this->hasException())
            {
                goto rulewellformed_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewellformed_keyEx; /* Prevent compiler warnings */
    rulewellformed_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end wellformed_key */

/**
 * $ANTLR start xmlexists_key
 * PLSQLKeys.g:1277:1: xmlexists_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlexists_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1278:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1278:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLEXISTS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLEXISTS\")" );
                    ex->set_ruleName( "xmlexists_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlexists_key7088);
            if  (this->hasException())
            {
                goto rulexmlexists_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlexists_keyEx; /* Prevent compiler warnings */
    rulexmlexists_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlexists_key */

/**
 * $ANTLR start version_key
 * PLSQLKeys.g:1281:1: version_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::version_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1282:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1282:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VERSION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VERSION\")" );
                    ex->set_ruleName( "version_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_version_key7111);
            if  (this->hasException())
            {
                goto ruleversion_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleversion_keyEx; /* Prevent compiler warnings */
    ruleversion_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end version_key */

/**
 * $ANTLR start xmlcast_key
 * PLSQLKeys.g:1285:1: xmlcast_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlcast_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1286:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1286:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLCAST"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLCAST\")" );
                    ex->set_ruleName( "xmlcast_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlcast_key7134);
            if  (this->hasException())
            {
                goto rulexmlcast_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlcast_keyEx; /* Prevent compiler warnings */
    rulexmlcast_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlcast_key */

/**
 * $ANTLR start yes_key
 * PLSQLKeys.g:1289:1: yes_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::yes_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1290:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1290:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "YES"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"YES\")" );
                    ex->set_ruleName( "yes_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_yes_key7157);
            if  (this->hasException())
            {
                goto ruleyes_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleyes_keyEx; /* Prevent compiler warnings */
    ruleyes_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end yes_key */

/**
 * $ANTLR start no_key
 * PLSQLKeys.g:1293:1: no_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::no_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1294:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1294:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NO"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NO\")" );
                    ex->set_ruleName( "no_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_no_key7180);
            if  (this->hasException())
            {
                goto ruleno_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleno_keyEx; /* Prevent compiler warnings */
    ruleno_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end no_key */

/**
 * $ANTLR start evalname_key
 * PLSQLKeys.g:1297:1: evalname_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::evalname_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1298:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1298:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EVALNAME"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EVALNAME\")" );
                    ex->set_ruleName( "evalname_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_evalname_key7203);
            if  (this->hasException())
            {
                goto ruleevalname_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleevalname_keyEx; /* Prevent compiler warnings */
    ruleevalname_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end evalname_key */

/**
 * $ANTLR start xmlpi_key
 * PLSQLKeys.g:1301:1: xmlpi_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlpi_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1302:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1302:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLPI"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLPI\")" );
                    ex->set_ruleName( "xmlpi_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlpi_key7226);
            if  (this->hasException())
            {
                goto rulexmlpi_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlpi_keyEx; /* Prevent compiler warnings */
    rulexmlpi_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlpi_key */

/**
 * $ANTLR start xmlcolattval_key
 * PLSQLKeys.g:1305:1: xmlcolattval_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlcolattval_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1306:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1306:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLCOLATTVAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLCOLATTVAL\")" );
                    ex->set_ruleName( "xmlcolattval_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlcolattval_key7249);
            if  (this->hasException())
            {
                goto rulexmlcolattval_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlcolattval_keyEx; /* Prevent compiler warnings */
    rulexmlcolattval_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlcolattval_key */

/**
 * $ANTLR start document_key
 * PLSQLKeys.g:1309:1: document_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::document_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1310:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1310:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DOCUMENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DOCUMENT\")" );
                    ex->set_ruleName( "document_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_document_key7272);
            if  (this->hasException())
            {
                goto ruledocument_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledocument_keyEx; /* Prevent compiler warnings */
    ruledocument_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end document_key */

/**
 * $ANTLR start xmlforest_key
 * PLSQLKeys.g:1313:1: xmlforest_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlforest_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1314:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1314:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLFOREST"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLFOREST\")" );
                    ex->set_ruleName( "xmlforest_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlforest_key7295);
            if  (this->hasException())
            {
                goto rulexmlforest_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlforest_keyEx; /* Prevent compiler warnings */
    rulexmlforest_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlforest_key */

/**
 * $ANTLR start passing_key
 * PLSQLKeys.g:1317:1: passing_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::passing_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1318:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1318:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PASSING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PASSING\")" );
                    ex->set_ruleName( "passing_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_passing_key7318);
            if  (this->hasException())
            {
                goto rulepassing_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepassing_keyEx; /* Prevent compiler warnings */
    rulepassing_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end passing_key */

/**
 * $ANTLR start columns_key
 * PLSQLKeys.g:1321:1: columns_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::columns_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1322:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1322:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COLUMNS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COLUMNS\")" );
                    ex->set_ruleName( "columns_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_columns_key7342);
            if  (this->hasException())
            {
                goto rulecolumns_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecolumns_keyEx; /* Prevent compiler warnings */
    rulecolumns_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end columns_key */

/**
 * $ANTLR start indent_key
 * PLSQLKeys.g:1325:1: indent_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::indent_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1326:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1326:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INDENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INDENT\")" );
                    ex->set_ruleName( "indent_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_indent_key7365);
            if  (this->hasException())
            {
                goto ruleindent_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleindent_keyEx; /* Prevent compiler warnings */
    ruleindent_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end indent_key */

/**
 * $ANTLR start hide_key
 * PLSQLKeys.g:1329:1: hide_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::hide_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1330:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1330:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "HIDE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"HIDE\")" );
                    ex->set_ruleName( "hide_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_hide_key7388);
            if  (this->hasException())
            {
                goto rulehide_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulehide_keyEx; /* Prevent compiler warnings */
    rulehide_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end hide_key */

/**
 * $ANTLR start xmlagg_key
 * PLSQLKeys.g:1333:1: xmlagg_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlagg_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1334:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1334:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLAGG"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLAGG\")" );
                    ex->set_ruleName( "xmlagg_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlagg_key7411);
            if  (this->hasException())
            {
                goto rulexmlagg_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlagg_keyEx; /* Prevent compiler warnings */
    rulexmlagg_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlagg_key */

/**
 * $ANTLR start path_key
 * PLSQLKeys.g:1337:1: path_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::path_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1338:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1338:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PATH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PATH\")" );
                    ex->set_ruleName( "path_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_path_key7434);
            if  (this->hasException())
            {
                goto rulepath_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepath_keyEx; /* Prevent compiler warnings */
    rulepath_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end path_key */

/**
 * $ANTLR start xmlnamespaces_key
 * PLSQLKeys.g:1341:1: xmlnamespaces_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlnamespaces_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1342:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1342:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLNAMESPACES"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLNAMESPACES\")" );
                    ex->set_ruleName( "xmlnamespaces_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlnamespaces_key7457);
            if  (this->hasException())
            {
                goto rulexmlnamespaces_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlnamespaces_keyEx; /* Prevent compiler warnings */
    rulexmlnamespaces_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlnamespaces_key */

/**
 * $ANTLR start size_key
 * PLSQLKeys.g:1345:1: size_key : SQL92_RESERVED_SIZE ;
 */
void
PLSQLParser_PLSQLKeys::size_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1346:5: ( SQL92_RESERVED_SIZE )
        // PLSQLKeys.g:1346:10: SQL92_RESERVED_SIZE
        {
             this->matchToken(SQL92_RESERVED_SIZE, &FOLLOW_SQL92_RESERVED_SIZE_in_size_key7477);
            if  (this->hasException())
            {
                goto rulesize_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesize_keyEx; /* Prevent compiler warnings */
    rulesize_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end size_key */

/**
 * $ANTLR start noschemacheck_key
 * PLSQLKeys.g:1349:1: noschemacheck_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::noschemacheck_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1350:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1350:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOSCHEMACHECK"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOSCHEMACHECK\")" );
                    ex->set_ruleName( "noschemacheck_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_noschemacheck_key7500);
            if  (this->hasException())
            {
                goto rulenoschemacheck_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenoschemacheck_keyEx; /* Prevent compiler warnings */
    rulenoschemacheck_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end noschemacheck_key */

/**
 * $ANTLR start noentityescaping_key
 * PLSQLKeys.g:1353:1: noentityescaping_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::noentityescaping_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1354:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1354:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOENTITYESCAPING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOENTITYESCAPING\")" );
                    ex->set_ruleName( "noentityescaping_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_noentityescaping_key7523);
            if  (this->hasException())
            {
                goto rulenoentityescaping_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenoentityescaping_keyEx; /* Prevent compiler warnings */
    rulenoentityescaping_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end noentityescaping_key */

/**
 * $ANTLR start xmlquery_key
 * PLSQLKeys.g:1357:1: xmlquery_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlquery_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1358:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1358:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLQUERY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLQUERY\")" );
                    ex->set_ruleName( "xmlquery_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlquery_key7546);
            if  (this->hasException())
            {
                goto rulexmlquery_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlquery_keyEx; /* Prevent compiler warnings */
    rulexmlquery_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlquery_key */

/**
 * $ANTLR start xmltable_key
 * PLSQLKeys.g:1361:1: xmltable_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmltable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1362:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1362:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLTABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLTABLE\")" );
                    ex->set_ruleName( "xmltable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmltable_key7569);
            if  (this->hasException())
            {
                goto rulexmltable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmltable_keyEx; /* Prevent compiler warnings */
    rulexmltable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmltable_key */

/**
 * $ANTLR start xmlroot_key
 * PLSQLKeys.g:1365:1: xmlroot_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlroot_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1366:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1366:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLROOT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLROOT\")" );
                    ex->set_ruleName( "xmlroot_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlroot_key7592);
            if  (this->hasException())
            {
                goto rulexmlroot_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlroot_keyEx; /* Prevent compiler warnings */
    rulexmlroot_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlroot_key */

/**
 * $ANTLR start schemacheck_key
 * PLSQLKeys.g:1369:1: schemacheck_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::schemacheck_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1370:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1370:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SCHEMACHECK"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SCHEMACHECK\")" );
                    ex->set_ruleName( "schemacheck_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_schemacheck_key7615);
            if  (this->hasException())
            {
                goto ruleschemacheck_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleschemacheck_keyEx; /* Prevent compiler warnings */
    ruleschemacheck_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end schemacheck_key */

/**
 * $ANTLR start xmlattributes_key
 * PLSQLKeys.g:1373:1: xmlattributes_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlattributes_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1374:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1374:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLATTRIBUTES"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLATTRIBUTES\")" );
                    ex->set_ruleName( "xmlattributes_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlattributes_key7638);
            if  (this->hasException())
            {
                goto rulexmlattributes_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlattributes_keyEx; /* Prevent compiler warnings */
    rulexmlattributes_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlattributes_key */

/**
 * $ANTLR start encoding_key
 * PLSQLKeys.g:1377:1: encoding_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::encoding_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1378:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1378:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ENCODING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ENCODING\")" );
                    ex->set_ruleName( "encoding_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_encoding_key7661);
            if  (this->hasException())
            {
                goto ruleencoding_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleencoding_keyEx; /* Prevent compiler warnings */
    ruleencoding_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end encoding_key */

/**
 * $ANTLR start show_key
 * PLSQLKeys.g:1381:1: show_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::show_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1382:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1382:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SHOW"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SHOW\")" );
                    ex->set_ruleName( "show_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_show_key7684);
            if  (this->hasException())
            {
                goto ruleshow_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleshow_keyEx; /* Prevent compiler warnings */
    ruleshow_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end show_key */

/**
 * $ANTLR start xmlserialize_key
 * PLSQLKeys.g:1385:1: xmlserialize_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlserialize_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1386:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1386:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLSERIALIZE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLSERIALIZE\")" );
                    ex->set_ruleName( "xmlserialize_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlserialize_key7707);
            if  (this->hasException())
            {
                goto rulexmlserialize_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlserialize_keyEx; /* Prevent compiler warnings */
    rulexmlserialize_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlserialize_key */

/**
 * $ANTLR start ordinality_key
 * PLSQLKeys.g:1389:1: ordinality_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::ordinality_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1390:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1390:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ORDINALITY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ORDINALITY\")" );
                    ex->set_ruleName( "ordinality_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ordinality_key7730);
            if  (this->hasException())
            {
                goto ruleordinality_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleordinality_keyEx; /* Prevent compiler warnings */
    ruleordinality_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end ordinality_key */

/**
 * $ANTLR start defaults_key
 * PLSQLKeys.g:1393:1: defaults_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::defaults_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1394:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1394:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DEFAULTS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DEFAULTS\")" );
                    ex->set_ruleName( "defaults_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_defaults_key7753);
            if  (this->hasException())
            {
                goto ruledefaults_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledefaults_keyEx; /* Prevent compiler warnings */
    ruledefaults_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end defaults_key */

/**
 * $ANTLR start sqlerror_key
 * PLSQLKeys.g:1397:1: sqlerror_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sqlerror_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1398:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1398:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SQLERROR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SQLERROR\")" );
                    ex->set_ruleName( "sqlerror_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sqlerror_key7775);
            if  (this->hasException())
            {
                goto rulesqlerror_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesqlerror_keyEx; /* Prevent compiler warnings */
    rulesqlerror_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sqlerror_key */

/**
 * $ANTLR start oserror_key
 * PLSQLKeys.g:1401:1: oserror_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::oserror_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1402:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1402:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OSERROR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OSERROR\")" );
                    ex->set_ruleName( "oserror_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_oserror_key7799);
            if  (this->hasException())
            {
                goto ruleoserror_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleoserror_keyEx; /* Prevent compiler warnings */
    ruleoserror_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end oserror_key */

/**
 * $ANTLR start success_key
 * PLSQLKeys.g:1405:1: success_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::success_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1406:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1406:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SUCCESS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SUCCESS\")" );
                    ex->set_ruleName( "success_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_success_key7822);
            if  (this->hasException())
            {
                goto rulesuccess_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesuccess_keyEx; /* Prevent compiler warnings */
    rulesuccess_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end success_key */

/**
 * $ANTLR start warning_key
 * PLSQLKeys.g:1409:1: warning_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::warning_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1410:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1410:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "WARNING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"WARNING\")" );
                    ex->set_ruleName( "warning_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_warning_key7845);
            if  (this->hasException())
            {
                goto rulewarning_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewarning_keyEx; /* Prevent compiler warnings */
    rulewarning_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end warning_key */

/**
 * $ANTLR start failure_key
 * PLSQLKeys.g:1413:1: failure_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::failure_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1414:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1414:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FAILURE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FAILURE\")" );
                    ex->set_ruleName( "failure_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_failure_key7868);
            if  (this->hasException())
            {
                goto rulefailure_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefailure_keyEx; /* Prevent compiler warnings */
    rulefailure_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end failure_key */

/**
 * $ANTLR start insert_key
 * PLSQLKeys.g:1417:1: insert_key : SQL92_RESERVED_INSERT ;
 */
void
PLSQLParser_PLSQLKeys::insert_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1418:5: ( SQL92_RESERVED_INSERT )
        // PLSQLKeys.g:1418:10: SQL92_RESERVED_INSERT
        {
             this->matchToken(SQL92_RESERVED_INSERT, &FOLLOW_SQL92_RESERVED_INSERT_in_insert_key7889);
            if  (this->hasException())
            {
                goto ruleinsert_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinsert_keyEx; /* Prevent compiler warnings */
    ruleinsert_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end insert_key */

/**
 * $ANTLR start order_key
 * PLSQLKeys.g:1421:1: order_key : SQL92_RESERVED_ORDER ;
 */
void
PLSQLParser_PLSQLKeys::order_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1422:5: ( SQL92_RESERVED_ORDER )
        // PLSQLKeys.g:1422:10: SQL92_RESERVED_ORDER
        {
             this->matchToken(SQL92_RESERVED_ORDER, &FOLLOW_SQL92_RESERVED_ORDER_in_order_key7909);
            if  (this->hasException())
            {
                goto ruleorder_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleorder_keyEx; /* Prevent compiler warnings */
    ruleorder_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end order_key */

/**
 * $ANTLR start minus_key
 * PLSQLKeys.g:1425:1: minus_key : PLSQL_RESERVED_MINUS ;
 */
void
PLSQLParser_PLSQLKeys::minus_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1426:5: ( PLSQL_RESERVED_MINUS )
        // PLSQLKeys.g:1426:10: PLSQL_RESERVED_MINUS
        {
             this->matchToken(PLSQL_RESERVED_MINUS, &FOLLOW_PLSQL_RESERVED_MINUS_in_minus_key7929);
            if  (this->hasException())
            {
                goto ruleminus_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleminus_keyEx; /* Prevent compiler warnings */
    ruleminus_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end minus_key */

/**
 * $ANTLR start row_key
 * PLSQLKeys.g:1429:1: row_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::row_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1430:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1430:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ROW"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ROW\")" );
                    ex->set_ruleName( "row_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_row_key7951);
            if  (this->hasException())
            {
                goto rulerow_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerow_keyEx; /* Prevent compiler warnings */
    rulerow_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end row_key */

/**
 * $ANTLR start mod_key
 * PLSQLKeys.g:1433:1: mod_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::mod_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1434:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1434:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MOD"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MOD\")" );
                    ex->set_ruleName( "mod_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_mod_key7973);
            if  (this->hasException())
            {
                goto rulemod_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemod_keyEx; /* Prevent compiler warnings */
    rulemod_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end mod_key */

/**
 * $ANTLR start raw_key
 * PLSQLKeys.g:1437:1: raw_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::raw_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1438:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1438:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RAW"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RAW\")" );
                    ex->set_ruleName( "raw_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_raw_key7996);
            if  (this->hasException())
            {
                goto ruleraw_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleraw_keyEx; /* Prevent compiler warnings */
    ruleraw_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end raw_key */

/**
 * $ANTLR start power_key
 * PLSQLKeys.g:1441:1: power_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::power_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1442:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1442:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "POWER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"POWER\")" );
                    ex->set_ruleName( "power_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_power_key8018);
            if  (this->hasException())
            {
                goto rulepower_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepower_keyEx; /* Prevent compiler warnings */
    rulepower_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end power_key */

/**
 * $ANTLR start lock_key
 * PLSQLKeys.g:1445:1: lock_key : PLSQL_RESERVED_LOCK ;
 */
void
PLSQLParser_PLSQLKeys::lock_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1446:5: ( PLSQL_RESERVED_LOCK )
        // PLSQLKeys.g:1446:10: PLSQL_RESERVED_LOCK
        {
             this->matchToken(PLSQL_RESERVED_LOCK, &FOLLOW_PLSQL_RESERVED_LOCK_in_lock_key8038);
            if  (this->hasException())
            {
                goto rulelock_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelock_keyEx; /* Prevent compiler warnings */
    rulelock_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end lock_key */

/**
 * $ANTLR start exists_key
 * PLSQLKeys.g:1449:1: exists_key : SQL92_RESERVED_EXISTS ;
 */
void
PLSQLParser_PLSQLKeys::exists_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1450:5: ( SQL92_RESERVED_EXISTS )
        // PLSQLKeys.g:1450:10: SQL92_RESERVED_EXISTS
        {
             this->matchToken(SQL92_RESERVED_EXISTS, &FOLLOW_SQL92_RESERVED_EXISTS_in_exists_key8058);
            if  (this->hasException())
            {
                goto ruleexists_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexists_keyEx; /* Prevent compiler warnings */
    ruleexists_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exists_key */

/**
 * $ANTLR start having_key
 * PLSQLKeys.g:1453:1: having_key : SQL92_RESERVED_HAVING ;
 */
void
PLSQLParser_PLSQLKeys::having_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1454:5: ( SQL92_RESERVED_HAVING )
        // PLSQLKeys.g:1454:10: SQL92_RESERVED_HAVING
        {
             this->matchToken(SQL92_RESERVED_HAVING, &FOLLOW_SQL92_RESERVED_HAVING_in_having_key8078);
            if  (this->hasException())
            {
                goto rulehaving_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulehaving_keyEx; /* Prevent compiler warnings */
    rulehaving_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end having_key */

/**
 * $ANTLR start any_key
 * PLSQLKeys.g:1457:1: any_key : SQL92_RESERVED_ANY ;
 */
void
PLSQLParser_PLSQLKeys::any_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1458:5: ( SQL92_RESERVED_ANY )
        // PLSQLKeys.g:1458:10: SQL92_RESERVED_ANY
        {
             this->matchToken(SQL92_RESERVED_ANY, &FOLLOW_SQL92_RESERVED_ANY_in_any_key8098);
            if  (this->hasException())
            {
                goto ruleany_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleany_keyEx; /* Prevent compiler warnings */
    ruleany_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end any_key */

/**
 * $ANTLR start with_key
 * PLSQLKeys.g:1461:1: with_key : SQL92_RESERVED_WITH ;
 */
void
PLSQLParser_PLSQLKeys::with_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1462:5: ( SQL92_RESERVED_WITH )
        // PLSQLKeys.g:1462:10: SQL92_RESERVED_WITH
        {
             this->matchToken(SQL92_RESERVED_WITH, &FOLLOW_SQL92_RESERVED_WITH_in_with_key8118);
            if  (this->hasException())
            {
                goto rulewith_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewith_keyEx; /* Prevent compiler warnings */
    rulewith_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end with_key */

/**
 * $ANTLR start transaction_key
 * PLSQLKeys.g:1465:1: transaction_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::transaction_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1466:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1466:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TRANSACTION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TRANSACTION\")" );
                    ex->set_ruleName( "transaction_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_transaction_key8141);
            if  (this->hasException())
            {
                goto ruletransaction_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletransaction_keyEx; /* Prevent compiler warnings */
    ruletransaction_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end transaction_key */

/**
 * $ANTLR start rawtohex_key
 * PLSQLKeys.g:1469:1: rawtohex_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rawtohex_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1470:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1470:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RAWTOHEX"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RAWTOHEX\")" );
                    ex->set_ruleName( "rawtohex_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rawtohex_key8163);
            if  (this->hasException())
            {
                goto rulerawtohex_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerawtohex_keyEx; /* Prevent compiler warnings */
    rulerawtohex_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rawtohex_key */

/**
 * $ANTLR start number_key
 * PLSQLKeys.g:1473:1: number_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::number_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1474:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1474:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NUMBER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NUMBER\")" );
                    ex->set_ruleName( "number_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_number_key8186);
            if  (this->hasException())
            {
                goto rulenumber_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenumber_keyEx; /* Prevent compiler warnings */
    rulenumber_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end number_key */

/**
 * $ANTLR start nocopy_key
 * PLSQLKeys.g:1477:1: nocopy_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nocopy_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1478:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1478:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOCOPY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOCOPY\")" );
                    ex->set_ruleName( "nocopy_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nocopy_key8209);
            if  (this->hasException())
            {
                goto rulenocopy_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenocopy_keyEx; /* Prevent compiler warnings */
    rulenocopy_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nocopy_key */

/**
 * $ANTLR start to_key
 * PLSQLKeys.g:1481:1: to_key : SQL92_RESERVED_TO ;
 */
void
PLSQLParser_PLSQLKeys::to_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1482:5: ( SQL92_RESERVED_TO )
        // PLSQLKeys.g:1482:10: SQL92_RESERVED_TO
        {
             this->matchToken(SQL92_RESERVED_TO, &FOLLOW_SQL92_RESERVED_TO_in_to_key8229);
            if  (this->hasException())
            {
                goto ruleto_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleto_keyEx; /* Prevent compiler warnings */
    ruleto_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end to_key */

/**
 * $ANTLR start abs_key
 * PLSQLKeys.g:1485:1: abs_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::abs_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1486:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1486:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ABS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ABS\")" );
                    ex->set_ruleName( "abs_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_abs_key8251);
            if  (this->hasException())
            {
                goto ruleabs_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleabs_keyEx; /* Prevent compiler warnings */
    ruleabs_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end abs_key */

/**
 * $ANTLR start rollback_key
 * PLSQLKeys.g:1489:1: rollback_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rollback_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1490:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1490:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ROLLBACK"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ROLLBACK\")" );
                    ex->set_ruleName( "rollback_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rollback_key8274);
            if  (this->hasException())
            {
                goto rulerollback_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerollback_keyEx; /* Prevent compiler warnings */
    rulerollback_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rollback_key */

/**
 * $ANTLR start share_key
 * PLSQLKeys.g:1493:1: share_key : PLSQL_RESERVED_SHARE ;
 */
void
PLSQLParser_PLSQLKeys::share_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1494:5: ( PLSQL_RESERVED_SHARE )
        // PLSQLKeys.g:1494:10: PLSQL_RESERVED_SHARE
        {
             this->matchToken(PLSQL_RESERVED_SHARE, &FOLLOW_PLSQL_RESERVED_SHARE_in_share_key8294);
            if  (this->hasException())
            {
                goto ruleshare_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleshare_keyEx; /* Prevent compiler warnings */
    ruleshare_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end share_key */

/**
 * $ANTLR start greatest_key
 * PLSQLKeys.g:1497:1: greatest_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::greatest_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1498:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1498:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "GREATEST"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"GREATEST\")" );
                    ex->set_ruleName( "greatest_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_greatest_key8316);
            if  (this->hasException())
            {
                goto rulegreatest_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulegreatest_keyEx; /* Prevent compiler warnings */
    rulegreatest_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end greatest_key */

/**
 * $ANTLR start vsize_key
 * PLSQLKeys.g:1501:1: vsize_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::vsize_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1502:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1502:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VSIZE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VSIZE\")" );
                    ex->set_ruleName( "vsize_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_vsize_key8338);
            if  (this->hasException())
            {
                goto rulevsize_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevsize_keyEx; /* Prevent compiler warnings */
    rulevsize_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end vsize_key */

/**
 * $ANTLR start exclusive_key
 * PLSQLKeys.g:1505:1: exclusive_key : PLSQL_RESERVED_EXCLUSIVE ;
 */
void
PLSQLParser_PLSQLKeys::exclusive_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1506:5: ( PLSQL_RESERVED_EXCLUSIVE )
        // PLSQLKeys.g:1506:10: PLSQL_RESERVED_EXCLUSIVE
        {
             this->matchToken(PLSQL_RESERVED_EXCLUSIVE, &FOLLOW_PLSQL_RESERVED_EXCLUSIVE_in_exclusive_key8358);
            if  (this->hasException())
            {
                goto ruleexclusive_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexclusive_keyEx; /* Prevent compiler warnings */
    ruleexclusive_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exclusive_key */

/**
 * $ANTLR start varchar2_key
 * PLSQLKeys.g:1509:1: varchar2_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::varchar2_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1510:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1510:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VARCHAR2"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VARCHAR2\")" );
                    ex->set_ruleName( "varchar2_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_varchar2_key8381);
            if  (this->hasException())
            {
                goto rulevarchar2_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevarchar2_keyEx; /* Prevent compiler warnings */
    rulevarchar2_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end varchar2_key */

/**
 * $ANTLR start rowidtochar_key
 * PLSQLKeys.g:1513:1: rowidtochar_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rowidtochar_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1514:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1514:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ROWIDTOCHAR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ROWIDTOCHAR\")" );
                    ex->set_ruleName( "rowidtochar_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rowidtochar_key8403);
            if  (this->hasException())
            {
                goto rulerowidtochar_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerowidtochar_keyEx; /* Prevent compiler warnings */
    rulerowidtochar_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rowidtochar_key */

/**
 * $ANTLR start open_key
 * PLSQLKeys.g:1517:1: open_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::open_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1518:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1518:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OPEN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OPEN\")" );
                    ex->set_ruleName( "open_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_open_key8426);
            if  (this->hasException())
            {
                goto ruleopen_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleopen_keyEx; /* Prevent compiler warnings */
    ruleopen_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end open_key */

/**
 * $ANTLR start comment_key
 * PLSQLKeys.g:1521:1: comment_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::comment_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1522:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1522:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COMMENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COMMENT\")" );
                    ex->set_ruleName( "comment_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_comment_key8449);
            if  (this->hasException())
            {
                goto rulecomment_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecomment_keyEx; /* Prevent compiler warnings */
    rulecomment_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end comment_key */

/**
 * $ANTLR start sqrt_key
 * PLSQLKeys.g:1525:1: sqrt_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sqrt_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1526:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1526:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SQRT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SQRT\")" );
                    ex->set_ruleName( "sqrt_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sqrt_key8471);
            if  (this->hasException())
            {
                goto rulesqrt_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesqrt_keyEx; /* Prevent compiler warnings */
    rulesqrt_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sqrt_key */

/**
 * $ANTLR start instr_key
 * PLSQLKeys.g:1529:1: instr_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::instr_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1530:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1530:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INSTR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INSTR\")" );
                    ex->set_ruleName( "instr_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_instr_key8493);
            if  (this->hasException())
            {
                goto ruleinstr_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinstr_keyEx; /* Prevent compiler warnings */
    ruleinstr_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end instr_key */

/**
 * $ANTLR start nowait_key
 * PLSQLKeys.g:1533:1: nowait_key : PLSQL_RESERVED_NOWAIT ;
 */
void
PLSQLParser_PLSQLKeys::nowait_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1534:5: ( PLSQL_RESERVED_NOWAIT )
        // PLSQLKeys.g:1534:10: PLSQL_RESERVED_NOWAIT
        {
             this->matchToken(PLSQL_RESERVED_NOWAIT, &FOLLOW_PLSQL_RESERVED_NOWAIT_in_nowait_key8513);
            if  (this->hasException())
            {
                goto rulenowait_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenowait_keyEx; /* Prevent compiler warnings */
    rulenowait_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nowait_key */

/**
 * $ANTLR start lpad_key
 * PLSQLKeys.g:1537:1: lpad_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::lpad_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1538:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1538:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LPAD"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LPAD\")" );
                    ex->set_ruleName( "lpad_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_lpad_key8535);
            if  (this->hasException())
            {
                goto rulelpad_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelpad_keyEx; /* Prevent compiler warnings */
    rulelpad_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end lpad_key */

/**
 * $ANTLR start boolean_key
 * PLSQLKeys.g:1541:1: boolean_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::boolean_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1542:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1542:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BOOLEAN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BOOLEAN\")" );
                    ex->set_ruleName( "boolean_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_boolean_key8558);
            if  (this->hasException())
            {
                goto ruleboolean_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleboolean_keyEx; /* Prevent compiler warnings */
    ruleboolean_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end boolean_key */

/**
 * $ANTLR start rpad_key
 * PLSQLKeys.g:1545:1: rpad_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rpad_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1546:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1546:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RPAD"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RPAD\")" );
                    ex->set_ruleName( "rpad_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rpad_key8580);
            if  (this->hasException())
            {
                goto rulerpad_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerpad_keyEx; /* Prevent compiler warnings */
    rulerpad_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rpad_key */

/**
 * $ANTLR start savepoint_key
 * PLSQLKeys.g:1549:1: savepoint_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::savepoint_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1550:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1550:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SAVEPOINT\")" );
                    ex->set_ruleName( "savepoint_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_savepoint_key8603);
            if  (this->hasException())
            {
                goto rulesavepoint_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesavepoint_keyEx; /* Prevent compiler warnings */
    rulesavepoint_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end savepoint_key */

/**
 * $ANTLR start decode_key
 * PLSQLKeys.g:1553:1: decode_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::decode_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1554:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1554:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DECODE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DECODE\")" );
                    ex->set_ruleName( "decode_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_decode_key8625);
            if  (this->hasException())
            {
                goto ruledecode_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledecode_keyEx; /* Prevent compiler warnings */
    ruledecode_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end decode_key */

/**
 * $ANTLR start reverse_key
 * PLSQLKeys.g:1557:1: reverse_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::reverse_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1558:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1558:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "REVERSE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"REVERSE\")" );
                    ex->set_ruleName( "reverse_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_reverse_key8647);
            if  (this->hasException())
            {
                goto rulereverse_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereverse_keyEx; /* Prevent compiler warnings */
    rulereverse_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end reverse_key */

/**
 * $ANTLR start least_key
 * PLSQLKeys.g:1561:1: least_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::least_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1562:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1562:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LEAST"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LEAST\")" );
                    ex->set_ruleName( "least_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_least_key8669);
            if  (this->hasException())
            {
                goto ruleleast_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleleast_keyEx; /* Prevent compiler warnings */
    ruleleast_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end least_key */

/**
 * $ANTLR start nvl_key
 * PLSQLKeys.g:1565:1: nvl_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nvl_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1566:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1566:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NVL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NVL\")" );
                    ex->set_ruleName( "nvl_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nvl_key8691);
            if  (this->hasException())
            {
                goto rulenvl_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenvl_keyEx; /* Prevent compiler warnings */
    rulenvl_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nvl_key */

/**
 * $ANTLR start variance_key
 * PLSQLKeys.g:1569:1: variance_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::variance_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1570:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1570:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VARIANCE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VARIANCE\")" );
                    ex->set_ruleName( "variance_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_variance_key8713);
            if  (this->hasException())
            {
                goto rulevariance_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevariance_keyEx; /* Prevent compiler warnings */
    rulevariance_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end variance_key */

/**
 * $ANTLR start start_key
 * PLSQLKeys.g:1573:1: start_key : PLSQL_RESERVED_START ;
 */
void
PLSQLParser_PLSQLKeys::start_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1574:5: ( PLSQL_RESERVED_START )
        // PLSQLKeys.g:1574:10: PLSQL_RESERVED_START
        {
             this->matchToken(PLSQL_RESERVED_START, &FOLLOW_PLSQL_RESERVED_START_in_start_key8733);
            if  (this->hasException())
            {
                goto rulestart_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestart_keyEx; /* Prevent compiler warnings */
    rulestart_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end start_key */

/**
 * $ANTLR start desc_key
 * PLSQLKeys.g:1577:1: desc_key : SQL92_RESERVED_DESC ;
 */
void
PLSQLParser_PLSQLKeys::desc_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1578:5: ( SQL92_RESERVED_DESC )
        // PLSQLKeys.g:1578:10: SQL92_RESERVED_DESC
        {
             this->matchToken(SQL92_RESERVED_DESC, &FOLLOW_SQL92_RESERVED_DESC_in_desc_key8753);
            if  (this->hasException())
            {
                goto ruledesc_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledesc_keyEx; /* Prevent compiler warnings */
    ruledesc_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end desc_key */

/**
 * $ANTLR start concat_key
 * PLSQLKeys.g:1581:1: concat_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::concat_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1582:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1582:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CONCAT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CONCAT\")" );
                    ex->set_ruleName( "concat_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_concat_key8775);
            if  (this->hasException())
            {
                goto ruleconcat_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconcat_keyEx; /* Prevent compiler warnings */
    ruleconcat_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end concat_key */

/**
 * $ANTLR start dump_key
 * PLSQLKeys.g:1585:1: dump_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::dump_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1586:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1586:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DUMP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DUMP\")" );
                    ex->set_ruleName( "dump_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dump_key8797);
            if  (this->hasException())
            {
                goto ruledump_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledump_keyEx; /* Prevent compiler warnings */
    ruledump_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dump_key */

/**
 * $ANTLR start soundex_key
 * PLSQLKeys.g:1589:1: soundex_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::soundex_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1590:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1590:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SOUNDEX"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SOUNDEX\")" );
                    ex->set_ruleName( "soundex_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_soundex_key8819);
            if  (this->hasException())
            {
                goto rulesoundex_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesoundex_keyEx; /* Prevent compiler warnings */
    rulesoundex_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end soundex_key */

/**
 * $ANTLR start positive_key
 * PLSQLKeys.g:1593:1: positive_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::positive_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1594:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1594:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "POSITIVE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"POSITIVE\")" );
                    ex->set_ruleName( "positive_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_positive_key8842);
            if  (this->hasException())
            {
                goto rulepositive_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepositive_keyEx; /* Prevent compiler warnings */
    rulepositive_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end positive_key */

/**
 * $ANTLR start union_key
 * PLSQLKeys.g:1597:1: union_key : SQL92_RESERVED_UNION ;
 */
void
PLSQLParser_PLSQLKeys::union_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1598:5: ( SQL92_RESERVED_UNION )
        // PLSQLKeys.g:1598:10: SQL92_RESERVED_UNION
        {
             this->matchToken(SQL92_RESERVED_UNION, &FOLLOW_SQL92_RESERVED_UNION_in_union_key8862);
            if  (this->hasException())
            {
                goto ruleunion_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunion_keyEx; /* Prevent compiler warnings */
    ruleunion_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end union_key */

/**
 * $ANTLR start ascii_key
 * PLSQLKeys.g:1601:1: ascii_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::ascii_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1602:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1602:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ASCII"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ASCII\")" );
                    ex->set_ruleName( "ascii_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ascii_key8884);
            if  (this->hasException())
            {
                goto ruleascii_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleascii_keyEx; /* Prevent compiler warnings */
    ruleascii_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end ascii_key */

/**
 * $ANTLR start connect_key
 * PLSQLKeys.g:1605:1: connect_key : SQL92_RESERVED_CONNECT ;
 */
void
PLSQLParser_PLSQLKeys::connect_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1606:5: ( SQL92_RESERVED_CONNECT )
        // PLSQLKeys.g:1606:10: SQL92_RESERVED_CONNECT
        {
             this->matchToken(SQL92_RESERVED_CONNECT, &FOLLOW_SQL92_RESERVED_CONNECT_in_connect_key8904);
            if  (this->hasException())
            {
                goto ruleconnect_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconnect_keyEx; /* Prevent compiler warnings */
    ruleconnect_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end connect_key */

/**
 * $ANTLR start asc_key
 * PLSQLKeys.g:1609:1: asc_key : SQL92_RESERVED_ASC ;
 */
void
PLSQLParser_PLSQLKeys::asc_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1610:5: ( SQL92_RESERVED_ASC )
        // PLSQLKeys.g:1610:10: SQL92_RESERVED_ASC
        {
             this->matchToken(SQL92_RESERVED_ASC, &FOLLOW_SQL92_RESERVED_ASC_in_asc_key8924);
            if  (this->hasException())
            {
                goto ruleasc_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleasc_keyEx; /* Prevent compiler warnings */
    ruleasc_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end asc_key */

/**
 * $ANTLR start hextoraw_key
 * PLSQLKeys.g:1613:1: hextoraw_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::hextoraw_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1614:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1614:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "HEXTORAW"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"HEXTORAW\")" );
                    ex->set_ruleName( "hextoraw_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_hextoraw_key8946);
            if  (this->hasException())
            {
                goto rulehextoraw_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulehextoraw_keyEx; /* Prevent compiler warnings */
    rulehextoraw_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end hextoraw_key */

/**
 * $ANTLR start to_date_key
 * PLSQLKeys.g:1617:1: to_date_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::to_date_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1618:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1618:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TO_DATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TO_DATE\")" );
                    ex->set_ruleName( "to_date_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_to_date_key8968);
            if  (this->hasException())
            {
                goto ruleto_date_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleto_date_keyEx; /* Prevent compiler warnings */
    ruleto_date_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end to_date_key */

/**
 * $ANTLR start floor_key
 * PLSQLKeys.g:1621:1: floor_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::floor_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1622:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1622:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FLOOR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FLOOR\")" );
                    ex->set_ruleName( "floor_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_floor_key8990);
            if  (this->hasException())
            {
                goto rulefloor_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefloor_keyEx; /* Prevent compiler warnings */
    rulefloor_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end floor_key */

/**
 * $ANTLR start sign_key
 * PLSQLKeys.g:1625:1: sign_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sign_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1626:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1626:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SIGN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SIGN\")" );
                    ex->set_ruleName( "sign_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sign_key9012);
            if  (this->hasException())
            {
                goto rulesign_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesign_keyEx; /* Prevent compiler warnings */
    rulesign_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sign_key */

/**
 * $ANTLR start update_key
 * PLSQLKeys.g:1629:1: update_key : SQL92_RESERVED_UPDATE ;
 */
void
PLSQLParser_PLSQLKeys::update_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1630:5: ( SQL92_RESERVED_UPDATE )
        // PLSQLKeys.g:1630:10: SQL92_RESERVED_UPDATE
        {
             this->matchToken(SQL92_RESERVED_UPDATE, &FOLLOW_SQL92_RESERVED_UPDATE_in_update_key9032);
            if  (this->hasException())
            {
                goto ruleupdate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleupdate_keyEx; /* Prevent compiler warnings */
    ruleupdate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end update_key */

/**
 * $ANTLR start trunc_key
 * PLSQLKeys.g:1633:1: trunc_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::trunc_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1634:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1634:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TRUNC"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TRUNC\")" );
                    ex->set_ruleName( "trunc_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_trunc_key9054);
            if  (this->hasException())
            {
                goto ruletrunc_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletrunc_keyEx; /* Prevent compiler warnings */
    ruletrunc_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end trunc_key */

/**
 * $ANTLR start rtrim_key
 * PLSQLKeys.g:1637:1: rtrim_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rtrim_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1638:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1638:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RTRIM"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RTRIM\")" );
                    ex->set_ruleName( "rtrim_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rtrim_key9076);
            if  (this->hasException())
            {
                goto rulertrim_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulertrim_keyEx; /* Prevent compiler warnings */
    rulertrim_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rtrim_key */

/**
 * $ANTLR start close_key
 * PLSQLKeys.g:1641:1: close_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::close_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1642:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1642:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CLOSE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CLOSE\")" );
                    ex->set_ruleName( "close_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_close_key9099);
            if  (this->hasException())
            {
                goto ruleclose_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleclose_keyEx; /* Prevent compiler warnings */
    ruleclose_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end close_key */

/**
 * $ANTLR start to_char_key
 * PLSQLKeys.g:1645:1: to_char_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::to_char_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1646:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1646:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TO_CHAR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TO_CHAR\")" );
                    ex->set_ruleName( "to_char_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_to_char_key9121);
            if  (this->hasException())
            {
                goto ruleto_char_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleto_char_keyEx; /* Prevent compiler warnings */
    ruleto_char_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end to_char_key */

/**
 * $ANTLR start ltrim_key
 * PLSQLKeys.g:1649:1: ltrim_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::ltrim_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1650:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1650:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LTRIM"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LTRIM\")" );
                    ex->set_ruleName( "ltrim_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ltrim_key9143);
            if  (this->hasException())
            {
                goto ruleltrim_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleltrim_keyEx; /* Prevent compiler warnings */
    ruleltrim_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end ltrim_key */

/**
 * $ANTLR start mode_key
 * PLSQLKeys.g:1653:1: mode_key : PLSQL_RESERVED_MODE ;
 */
void
PLSQLParser_PLSQLKeys::mode_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1654:5: ( PLSQL_RESERVED_MODE )
        // PLSQLKeys.g:1654:10: PLSQL_RESERVED_MODE
        {
             this->matchToken(PLSQL_RESERVED_MODE, &FOLLOW_PLSQL_RESERVED_MODE_in_mode_key9163);
            if  (this->hasException())
            {
                goto rulemode_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemode_keyEx; /* Prevent compiler warnings */
    rulemode_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end mode_key */

/**
 * $ANTLR start uid_key
 * PLSQLKeys.g:1657:1: uid_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::uid_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1658:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1658:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UID"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UID\")" );
                    ex->set_ruleName( "uid_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_uid_key9185);
            if  (this->hasException())
            {
                goto ruleuid_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleuid_keyEx; /* Prevent compiler warnings */
    ruleuid_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end uid_key */

/**
 * $ANTLR start chr_key
 * PLSQLKeys.g:1661:1: chr_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::chr_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1662:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1662:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CHR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CHR\")" );
                    ex->set_ruleName( "chr_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_chr_key9207);
            if  (this->hasException())
            {
                goto rulechr_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulechr_keyEx; /* Prevent compiler warnings */
    rulechr_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end chr_key */

/**
 * $ANTLR start intersect_key
 * PLSQLKeys.g:1665:1: intersect_key : SQL92_RESERVED_INTERSECT ;
 */
void
PLSQLParser_PLSQLKeys::intersect_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1666:5: ( SQL92_RESERVED_INTERSECT )
        // PLSQLKeys.g:1666:10: SQL92_RESERVED_INTERSECT
        {
             this->matchToken(SQL92_RESERVED_INTERSECT, &FOLLOW_SQL92_RESERVED_INTERSECT_in_intersect_key9227);
            if  (this->hasException())
            {
                goto ruleintersect_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintersect_keyEx; /* Prevent compiler warnings */
    ruleintersect_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end intersect_key */

/**
 * $ANTLR start chartorowid_key
 * PLSQLKeys.g:1669:1: chartorowid_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::chartorowid_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1670:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1670:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CHARTOROWID"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CHARTOROWID\")" );
                    ex->set_ruleName( "chartorowid_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_chartorowid_key9249);
            if  (this->hasException())
            {
                goto rulechartorowid_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulechartorowid_keyEx; /* Prevent compiler warnings */
    rulechartorowid_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end chartorowid_key */

/**
 * $ANTLR start mlslabel_key
 * PLSQLKeys.g:1673:1: mlslabel_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::mlslabel_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1674:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1674:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MLSLABEL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MLSLABEL\")" );
                    ex->set_ruleName( "mlslabel_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_mlslabel_key9272);
            if  (this->hasException())
            {
                goto rulemlslabel_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemlslabel_keyEx; /* Prevent compiler warnings */
    rulemlslabel_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end mlslabel_key */

/**
 * $ANTLR start userenv_key
 * PLSQLKeys.g:1677:1: userenv_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::userenv_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1678:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1678:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "USERENV"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"USERENV\")" );
                    ex->set_ruleName( "userenv_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_userenv_key9294);
            if  (this->hasException())
            {
                goto ruleuserenv_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleuserenv_keyEx; /* Prevent compiler warnings */
    ruleuserenv_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end userenv_key */

/**
 * $ANTLR start stddev_key
 * PLSQLKeys.g:1681:1: stddev_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::stddev_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1682:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1682:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "STDDEV"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"STDDEV\")" );
                    ex->set_ruleName( "stddev_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_stddev_key9316);
            if  (this->hasException())
            {
                goto rulestddev_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestddev_keyEx; /* Prevent compiler warnings */
    rulestddev_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end stddev_key */

/**
 * $ANTLR start length_key
 * PLSQLKeys.g:1685:1: length_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::length_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1686:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1686:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LENGTH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LENGTH\")" );
                    ex->set_ruleName( "length_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_length_key9338);
            if  (this->hasException())
            {
                goto rulelength_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelength_keyEx; /* Prevent compiler warnings */
    rulelength_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end length_key */

/**
 * $ANTLR start fetch_key
 * PLSQLKeys.g:1689:1: fetch_key : SQL92_RESERVED_FETCH ;
 */
void
PLSQLParser_PLSQLKeys::fetch_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1690:5: ( SQL92_RESERVED_FETCH )
        // PLSQLKeys.g:1690:10: SQL92_RESERVED_FETCH
        {
             this->matchToken(SQL92_RESERVED_FETCH, &FOLLOW_SQL92_RESERVED_FETCH_in_fetch_key9358);
            if  (this->hasException())
            {
                goto rulefetch_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefetch_keyEx; /* Prevent compiler warnings */
    rulefetch_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end fetch_key */

/**
 * $ANTLR start group_key
 * PLSQLKeys.g:1693:1: group_key : SQL92_RESERVED_GROUP ;
 */
void
PLSQLParser_PLSQLKeys::group_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1694:5: ( SQL92_RESERVED_GROUP )
        // PLSQLKeys.g:1694:10: SQL92_RESERVED_GROUP
        {
             this->matchToken(SQL92_RESERVED_GROUP, &FOLLOW_SQL92_RESERVED_GROUP_in_group_key9378);
            if  (this->hasException())
            {
                goto rulegroup_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulegroup_keyEx; /* Prevent compiler warnings */
    rulegroup_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end group_key */

/**
 * $ANTLR start sysdate_key
 * PLSQLKeys.g:1697:1: sysdate_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sysdate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1698:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1698:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SYSDATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SYSDATE\")" );
                    ex->set_ruleName( "sysdate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sysdate_key9400);
            if  (this->hasException())
            {
                goto rulesysdate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesysdate_keyEx; /* Prevent compiler warnings */
    rulesysdate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sysdate_key */

/**
 * $ANTLR start binary_integer_key
 * PLSQLKeys.g:1701:1: binary_integer_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_integer_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1702:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1702:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_INTEGER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_INTEGER\")" );
                    ex->set_ruleName( "binary_integer_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_integer_key9423);
            if  (this->hasException())
            {
                goto rulebinary_integer_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_integer_keyEx; /* Prevent compiler warnings */
    rulebinary_integer_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_integer_key */

/**
 * $ANTLR start to_number_key
 * PLSQLKeys.g:1705:1: to_number_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::to_number_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1706:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1706:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TO_NUMBER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TO_NUMBER\")" );
                    ex->set_ruleName( "to_number_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_to_number_key9445);
            if  (this->hasException())
            {
                goto ruleto_number_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleto_number_keyEx; /* Prevent compiler warnings */
    ruleto_number_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end to_number_key */

/**
 * $ANTLR start substr_key
 * PLSQLKeys.g:1709:1: substr_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::substr_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1710:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1710:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SUBSTR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SUBSTR\")" );
                    ex->set_ruleName( "substr_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_substr_key9467);
            if  (this->hasException())
            {
                goto rulesubstr_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubstr_keyEx; /* Prevent compiler warnings */
    rulesubstr_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end substr_key */

/**
 * $ANTLR start ceil_key
 * PLSQLKeys.g:1713:1: ceil_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::ceil_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1714:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1714:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CEIL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CEIL\")" );
                    ex->set_ruleName( "ceil_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ceil_key9489);
            if  (this->hasException())
            {
                goto ruleceil_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleceil_keyEx; /* Prevent compiler warnings */
    ruleceil_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end ceil_key */

/**
 * $ANTLR start initcap_key
 * PLSQLKeys.g:1717:1: initcap_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::initcap_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1718:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1718:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INITCAP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INITCAP\")" );
                    ex->set_ruleName( "initcap_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_initcap_key9511);
            if  (this->hasException())
            {
                goto ruleinitcap_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinitcap_keyEx; /* Prevent compiler warnings */
    ruleinitcap_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end initcap_key */

/**
 * $ANTLR start round_key
 * PLSQLKeys.g:1721:1: round_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::round_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1722:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1722:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ROUND"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ROUND\")" );
                    ex->set_ruleName( "round_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_round_key9533);
            if  (this->hasException())
            {
                goto ruleround_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleround_keyEx; /* Prevent compiler warnings */
    ruleround_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end round_key */

/**
 * $ANTLR start long_key
 * PLSQLKeys.g:1725:1: long_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::long_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1726:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1726:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LONG"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LONG\")" );
                    ex->set_ruleName( "long_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_long_key9556);
            if  (this->hasException())
            {
                goto rulelong_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelong_keyEx; /* Prevent compiler warnings */
    rulelong_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end long_key */

/**
 * $ANTLR start read_key
 * PLSQLKeys.g:1729:1: read_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::read_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1730:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1730:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "READ"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"READ\")" );
                    ex->set_ruleName( "read_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_read_key9579);
            if  (this->hasException())
            {
                goto ruleread_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleread_keyEx; /* Prevent compiler warnings */
    ruleread_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end read_key */

/**
 * $ANTLR start only_key
 * PLSQLKeys.g:1733:1: only_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::only_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1734:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1734:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ONLY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ONLY\")" );
                    ex->set_ruleName( "only_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_only_key9601);
            if  (this->hasException())
            {
                goto ruleonly_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleonly_keyEx; /* Prevent compiler warnings */
    ruleonly_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end only_key */

/**
 * $ANTLR start set_key
 * PLSQLKeys.g:1737:1: set_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::set_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1738:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1738:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SET"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SET\")" );
                    ex->set_ruleName( "set_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_set_key9624);
            if  (this->hasException())
            {
                goto ruleset_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleset_keyEx; /* Prevent compiler warnings */
    ruleset_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end set_key */

/**
 * $ANTLR start nullif_key
 * PLSQLKeys.g:1741:1: nullif_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nullif_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1742:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1742:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NULLIF"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NULLIF\")" );
                    ex->set_ruleName( "nullif_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nullif_key9646);
            if  (this->hasException())
            {
                goto rulenullif_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenullif_keyEx; /* Prevent compiler warnings */
    rulenullif_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nullif_key */

/**
 * $ANTLR start coalesce_key
 * PLSQLKeys.g:1745:1: coalesce_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::coalesce_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1746:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1746:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COALESCE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COALESCE\")" );
                    ex->set_ruleName( "coalesce_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_coalesce_key9668);
            if  (this->hasException())
            {
                goto rulecoalesce_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecoalesce_keyEx; /* Prevent compiler warnings */
    rulecoalesce_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end coalesce_key */

/**
 * $ANTLR start count_key
 * PLSQLKeys.g:1749:1: count_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::count_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1750:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1750:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COUNT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COUNT\")" );
                    ex->set_ruleName( "count_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_count_key9690);
            if  (this->hasException())
            {
                goto rulecount_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecount_keyEx; /* Prevent compiler warnings */
    rulecount_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end count_key */

/**
 * $ANTLR start avg_key
 * PLSQLKeys.g:1753:1: avg_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::avg_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1753:12: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1753:17: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AVG"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AVG\")" );
                    ex->set_ruleName( "avg_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_avg_key9711);
            if  (this->hasException())
            {
                goto ruleavg_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleavg_keyEx; /* Prevent compiler warnings */
    ruleavg_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end avg_key */

/**
 * $ANTLR start max_key
 * PLSQLKeys.g:1756:1: max_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::max_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1756:12: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1756:17: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MAX"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MAX\")" );
                    ex->set_ruleName( "max_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_max_key9732);
            if  (this->hasException())
            {
                goto rulemax_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemax_keyEx; /* Prevent compiler warnings */
    rulemax_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end max_key */

/**
 * $ANTLR start min_key
 * PLSQLKeys.g:1759:1: min_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::min_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1759:12: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1759:17: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MIN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MIN\")" );
                    ex->set_ruleName( "min_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_min_key9753);
            if  (this->hasException())
            {
                goto rulemin_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemin_keyEx; /* Prevent compiler warnings */
    rulemin_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end min_key */

/**
 * $ANTLR start sum_key
 * PLSQLKeys.g:1762:1: sum_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sum_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1762:12: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1762:17: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SUM"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SUM\")" );
                    ex->set_ruleName( "sum_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sum_key9774);
            if  (this->hasException())
            {
                goto rulesum_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesum_keyEx; /* Prevent compiler warnings */
    rulesum_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sum_key */

/**
 * $ANTLR start unknown_key
 * PLSQLKeys.g:1765:1: unknown_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::unknown_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1766:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1766:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UNKNOWN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UNKNOWN\")" );
                    ex->set_ruleName( "unknown_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_unknown_key9796);
            if  (this->hasException())
            {
                goto ruleunknown_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunknown_keyEx; /* Prevent compiler warnings */
    ruleunknown_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unknown_key */

/**
 * $ANTLR start escape_key
 * PLSQLKeys.g:1769:1: escape_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::escape_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1770:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1770:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ESCAPE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ESCAPE\")" );
                    ex->set_ruleName( "escape_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_escape_key9818);
            if  (this->hasException())
            {
                goto ruleescape_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleescape_keyEx; /* Prevent compiler warnings */
    ruleescape_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end escape_key */

/**
 * $ANTLR start some_key
 * PLSQLKeys.g:1773:1: some_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::some_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1774:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1774:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SOME"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SOME\")" );
                    ex->set_ruleName( "some_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_some_key9840);
            if  (this->hasException())
            {
                goto rulesome_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesome_keyEx; /* Prevent compiler warnings */
    rulesome_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end some_key */

/**
 * $ANTLR start match_key
 * PLSQLKeys.g:1777:1: match_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::match_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1778:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1778:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MATCH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MATCH\")" );
                    ex->set_ruleName( "match_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_match_key9862);
            if  (this->hasException())
            {
                goto rulematch_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulematch_keyEx; /* Prevent compiler warnings */
    rulematch_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end match_key */

/**
 * $ANTLR start cast_key
 * PLSQLKeys.g:1781:1: cast_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::cast_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1782:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1782:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CAST"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CAST\")" );
                    ex->set_ruleName( "cast_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cast_key9884);
            if  (this->hasException())
            {
                goto rulecast_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecast_keyEx; /* Prevent compiler warnings */
    rulecast_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cast_key */

/**
 * $ANTLR start full_key
 * PLSQLKeys.g:1785:1: full_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::full_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1786:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1786:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FULL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FULL\")" );
                    ex->set_ruleName( "full_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_full_key9907);
            if  (this->hasException())
            {
                goto rulefull_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefull_keyEx; /* Prevent compiler warnings */
    rulefull_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end full_key */

/**
 * $ANTLR start partial_key
 * PLSQLKeys.g:1789:1: partial_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::partial_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1790:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1790:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PARTIAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PARTIAL\")" );
                    ex->set_ruleName( "partial_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_partial_key9929);
            if  (this->hasException())
            {
                goto rulepartial_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepartial_keyEx; /* Prevent compiler warnings */
    rulepartial_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end partial_key */

/**
 * $ANTLR start character_key
 * PLSQLKeys.g:1793:1: character_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::character_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1794:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1794:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CHARACTER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CHARACTER\")" );
                    ex->set_ruleName( "character_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_character_key9952);
            if  (this->hasException())
            {
                goto rulecharacter_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecharacter_keyEx; /* Prevent compiler warnings */
    rulecharacter_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end character_key */

/**
 * $ANTLR start except_key
 * PLSQLKeys.g:1797:1: except_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::except_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1798:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1798:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXCEPT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXCEPT\")" );
                    ex->set_ruleName( "except_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_except_key9974);
            if  (this->hasException())
            {
                goto ruleexcept_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexcept_keyEx; /* Prevent compiler warnings */
    ruleexcept_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end except_key */

/**
 * $ANTLR start char_key
 * PLSQLKeys.g:1801:1: char_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::char_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1802:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1802:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CHAR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CHAR\")" );
                    ex->set_ruleName( "char_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_char_key9997);
            if  (this->hasException())
            {
                goto rulechar_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulechar_keyEx; /* Prevent compiler warnings */
    rulechar_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end char_key */

/**
 * $ANTLR start varying_key
 * PLSQLKeys.g:1805:1: varying_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::varying_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1806:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1806:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VARYING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VARYING\")" );
                    ex->set_ruleName( "varying_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_varying_key10020);
            if  (this->hasException())
            {
                goto rulevarying_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevarying_keyEx; /* Prevent compiler warnings */
    rulevarying_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end varying_key */

/**
 * $ANTLR start varchar_key
 * PLSQLKeys.g:1809:1: varchar_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::varchar_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1810:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1810:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VARCHAR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VARCHAR\")" );
                    ex->set_ruleName( "varchar_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_varchar_key10043);
            if  (this->hasException())
            {
                goto rulevarchar_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevarchar_keyEx; /* Prevent compiler warnings */
    rulevarchar_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end varchar_key */

/**
 * $ANTLR start national_key
 * PLSQLKeys.g:1813:1: national_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::national_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1814:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1814:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NATIONAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NATIONAL\")" );
                    ex->set_ruleName( "national_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_national_key10065);
            if  (this->hasException())
            {
                goto rulenational_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenational_keyEx; /* Prevent compiler warnings */
    rulenational_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end national_key */

/**
 * $ANTLR start nchar_key
 * PLSQLKeys.g:1817:1: nchar_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nchar_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1818:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1818:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NCHAR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NCHAR\")" );
                    ex->set_ruleName( "nchar_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nchar_key10087);
            if  (this->hasException())
            {
                goto rulenchar_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenchar_keyEx; /* Prevent compiler warnings */
    rulenchar_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nchar_key */

/**
 * $ANTLR start bit_key
 * PLSQLKeys.g:1821:1: bit_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::bit_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1821:12: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1821:17: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BIT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BIT\")" );
                    ex->set_ruleName( "bit_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_bit_key10108);
            if  (this->hasException())
            {
                goto rulebit_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebit_keyEx; /* Prevent compiler warnings */
    rulebit_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end bit_key */

/**
 * $ANTLR start float_key
 * PLSQLKeys.g:1824:1: float_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::float_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1825:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1825:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FLOAT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FLOAT\")" );
                    ex->set_ruleName( "float_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_float_key10130);
            if  (this->hasException())
            {
                goto rulefloat_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefloat_keyEx; /* Prevent compiler warnings */
    rulefloat_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end float_key */

/**
 * $ANTLR start real_key
 * PLSQLKeys.g:1828:1: real_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::real_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1829:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1829:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "REAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"REAL\")" );
                    ex->set_ruleName( "real_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_real_key10157);
            if  (this->hasException())
            {
                goto rulereal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereal_keyEx; /* Prevent compiler warnings */
    rulereal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end real_key */

/**
 * $ANTLR start double_key
 * PLSQLKeys.g:1832:1: double_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::double_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1833:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1833:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DOUBLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DOUBLE\")" );
                    ex->set_ruleName( "double_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_double_key10180);
            if  (this->hasException())
            {
                goto ruledouble_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledouble_keyEx; /* Prevent compiler warnings */
    ruledouble_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end double_key */

/**
 * $ANTLR start precision_key
 * PLSQLKeys.g:1836:1: precision_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::precision_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1837:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1837:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PRECISION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PRECISION\")" );
                    ex->set_ruleName( "precision_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_precision_key10202);
            if  (this->hasException())
            {
                goto ruleprecision_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprecision_keyEx; /* Prevent compiler warnings */
    ruleprecision_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end precision_key */

/**
 * $ANTLR start interval_key
 * PLSQLKeys.g:1840:1: interval_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::interval_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1841:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1841:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INTERVAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INTERVAL\")" );
                    ex->set_ruleName( "interval_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_interval_key10225);
            if  (this->hasException())
            {
                goto ruleinterval_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinterval_keyEx; /* Prevent compiler warnings */
    ruleinterval_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end interval_key */

/**
 * $ANTLR start time_key
 * PLSQLKeys.g:1844:1: time_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::time_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1845:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1845:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIME"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIME\")" );
                    ex->set_ruleName( "time_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_time_key10247);
            if  (this->hasException())
            {
                goto ruletime_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletime_keyEx; /* Prevent compiler warnings */
    ruletime_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end time_key */

/**
 * $ANTLR start zone_key
 * PLSQLKeys.g:1848:1: zone_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::zone_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1849:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1849:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ZONE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ZONE\")" );
                    ex->set_ruleName( "zone_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_zone_key10270);
            if  (this->hasException())
            {
                goto rulezone_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulezone_keyEx; /* Prevent compiler warnings */
    rulezone_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end zone_key */

/**
 * $ANTLR start timestamp_key
 * PLSQLKeys.g:1852:1: timestamp_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::timestamp_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1853:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1853:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIMESTAMP\")" );
                    ex->set_ruleName( "timestamp_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timestamp_key10292);
            if  (this->hasException())
            {
                goto ruletimestamp_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletimestamp_keyEx; /* Prevent compiler warnings */
    ruletimestamp_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timestamp_key */

/**
 * $ANTLR start date_key
 * PLSQLKeys.g:1856:1: date_key : SQL92_RESERVED_DATE ;
 */
void
PLSQLParser_PLSQLKeys::date_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1857:5: ( SQL92_RESERVED_DATE )
        // PLSQLKeys.g:1857:10: SQL92_RESERVED_DATE
        {
             this->matchToken(SQL92_RESERVED_DATE, &FOLLOW_SQL92_RESERVED_DATE_in_date_key10312);
            if  (this->hasException())
            {
                goto ruledate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledate_keyEx; /* Prevent compiler warnings */
    ruledate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end date_key */

/**
 * $ANTLR start numeric_key
 * PLSQLKeys.g:1860:1: numeric_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::numeric_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1861:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1861:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NUMERIC"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NUMERIC\")" );
                    ex->set_ruleName( "numeric_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_numeric_key10335);
            if  (this->hasException())
            {
                goto rulenumeric_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenumeric_keyEx; /* Prevent compiler warnings */
    rulenumeric_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end numeric_key */

/**
 * $ANTLR start decimal_key
 * PLSQLKeys.g:1864:1: decimal_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::decimal_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1865:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1865:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DECIMAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DECIMAL\")" );
                    ex->set_ruleName( "decimal_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_decimal_key10358);
            if  (this->hasException())
            {
                goto ruledecimal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledecimal_keyEx; /* Prevent compiler warnings */
    ruledecimal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end decimal_key */

/**
 * $ANTLR start dec_key
 * PLSQLKeys.g:1868:1: dec_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::dec_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1869:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1869:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DEC"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DEC\")" );
                    ex->set_ruleName( "dec_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dec_key10381);
            if  (this->hasException())
            {
                goto ruledec_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledec_keyEx; /* Prevent compiler warnings */
    ruledec_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dec_key */

/**
 * $ANTLR start integer_key
 * PLSQLKeys.g:1872:1: integer_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::integer_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1873:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1873:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INTEGER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INTEGER\")" );
                    ex->set_ruleName( "integer_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_integer_key10404);
            if  (this->hasException())
            {
                goto ruleinteger_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinteger_keyEx; /* Prevent compiler warnings */
    ruleinteger_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end integer_key */

/**
 * $ANTLR start int_key
 * PLSQLKeys.g:1876:1: int_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::int_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1877:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1877:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INT\")" );
                    ex->set_ruleName( "int_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_int_key10427);
            if  (this->hasException())
            {
                goto ruleint_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleint_keyEx; /* Prevent compiler warnings */
    ruleint_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end int_key */

/**
 * $ANTLR start smallint_key
 * PLSQLKeys.g:1880:1: smallint_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::smallint_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1881:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1881:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SMALLINT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SMALLINT\")" );
                    ex->set_ruleName( "smallint_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_smallint_key10450);
            if  (this->hasException())
            {
                goto rulesmallint_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesmallint_keyEx; /* Prevent compiler warnings */
    rulesmallint_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end smallint_key */

/**
 * $ANTLR start corresponding_key
 * PLSQLKeys.g:1884:1: corresponding_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::corresponding_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1885:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1885:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CORRESPONDING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CORRESPONDING\")" );
                    ex->set_ruleName( "corresponding_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_corresponding_key10472);
            if  (this->hasException())
            {
                goto rulecorresponding_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecorresponding_keyEx; /* Prevent compiler warnings */
    rulecorresponding_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end corresponding_key */

/**
 * $ANTLR start cross_key
 * PLSQLKeys.g:1888:1: cross_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::cross_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1889:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1889:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CROSS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CROSS\")" );
                    ex->set_ruleName( "cross_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cross_key10495);
            if  (this->hasException())
            {
                goto rulecross_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecross_keyEx; /* Prevent compiler warnings */
    rulecross_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cross_key */

/**
 * $ANTLR start join_key
 * PLSQLKeys.g:1892:1: join_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::join_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1893:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1893:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "JOIN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"JOIN\")" );
                    ex->set_ruleName( "join_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_join_key10518);
            if  (this->hasException())
            {
                goto rulejoin_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulejoin_keyEx; /* Prevent compiler warnings */
    rulejoin_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end join_key */

/**
 * $ANTLR start left_key
 * PLSQLKeys.g:1896:1: left_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::left_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1897:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1897:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LEFT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LEFT\")" );
                    ex->set_ruleName( "left_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_left_key10541);
            if  (this->hasException())
            {
                goto ruleleft_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleleft_keyEx; /* Prevent compiler warnings */
    ruleleft_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end left_key */

/**
 * $ANTLR start right_key
 * PLSQLKeys.g:1900:1: right_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::right_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1901:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1901:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RIGHT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RIGHT\")" );
                    ex->set_ruleName( "right_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_right_key10564);
            if  (this->hasException())
            {
                goto ruleright_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleright_keyEx; /* Prevent compiler warnings */
    ruleright_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end right_key */

/**
 * $ANTLR start inner_key
 * PLSQLKeys.g:1904:1: inner_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::inner_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1905:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1905:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INNER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INNER\")" );
                    ex->set_ruleName( "inner_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_inner_key10587);
            if  (this->hasException())
            {
                goto ruleinner_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinner_keyEx; /* Prevent compiler warnings */
    ruleinner_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end inner_key */

/**
 * $ANTLR start natural_key
 * PLSQLKeys.g:1908:1: natural_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::natural_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1909:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1909:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NATURAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NATURAL\")" );
                    ex->set_ruleName( "natural_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_natural_key10610);
            if  (this->hasException())
            {
                goto rulenatural_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenatural_keyEx; /* Prevent compiler warnings */
    rulenatural_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end natural_key */

/**
 * $ANTLR start outer_key
 * PLSQLKeys.g:1912:1: outer_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::outer_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1913:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1913:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OUTER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OUTER\")" );
                    ex->set_ruleName( "outer_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_outer_key10633);
            if  (this->hasException())
            {
                goto ruleouter_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleouter_keyEx; /* Prevent compiler warnings */
    ruleouter_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end outer_key */

/**
 * $ANTLR start using_key
 * PLSQLKeys.g:1916:1: using_key : PLSQL_NON_RESERVED_USING ;
 */
void
PLSQLParser_PLSQLKeys::using_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1917:5: ( PLSQL_NON_RESERVED_USING )
        // PLSQLKeys.g:1917:10: PLSQL_NON_RESERVED_USING
        {
             this->matchToken(PLSQL_NON_RESERVED_USING, &FOLLOW_PLSQL_NON_RESERVED_USING_in_using_key10653);
            if  (this->hasException())
            {
                goto ruleusing_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleusing_keyEx; /* Prevent compiler warnings */
    ruleusing_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end using_key */

/**
 * $ANTLR start indicator_key
 * PLSQLKeys.g:1920:1: indicator_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::indicator_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1921:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1921:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INDICATOR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INDICATOR\")" );
                    ex->set_ruleName( "indicator_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_indicator_key10675);
            if  (this->hasException())
            {
                goto ruleindicator_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleindicator_keyEx; /* Prevent compiler warnings */
    ruleindicator_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end indicator_key */

/**
 * $ANTLR start user_key
 * PLSQLKeys.g:1924:1: user_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::user_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1925:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1925:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "USER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"USER\")" );
                    ex->set_ruleName( "user_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_user_key10697);
            if  (this->hasException())
            {
                goto ruleuser_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleuser_keyEx; /* Prevent compiler warnings */
    ruleuser_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end user_key */

/**
 * $ANTLR start current_user_key
 * PLSQLKeys.g:1928:1: current_user_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::current_user_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1929:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1929:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CURRENT_USER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CURRENT_USER\")" );
                    ex->set_ruleName( "current_user_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_current_user_key10719);
            if  (this->hasException())
            {
                goto rulecurrent_user_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecurrent_user_keyEx; /* Prevent compiler warnings */
    rulecurrent_user_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end current_user_key */

/**
 * $ANTLR start session_user_key
 * PLSQLKeys.g:1932:1: session_user_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::session_user_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1933:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1933:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SESSION_USER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SESSION_USER\")" );
                    ex->set_ruleName( "session_user_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_session_user_key10741);
            if  (this->hasException())
            {
                goto rulesession_user_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesession_user_keyEx; /* Prevent compiler warnings */
    rulesession_user_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end session_user_key */

/**
 * $ANTLR start system_user_key
 * PLSQLKeys.g:1936:1: system_user_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::system_user_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1937:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1937:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SYSTEM_USER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SYSTEM_USER\")" );
                    ex->set_ruleName( "system_user_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_system_user_key10763);
            if  (this->hasException())
            {
                goto rulesystem_user_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesystem_user_keyEx; /* Prevent compiler warnings */
    rulesystem_user_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end system_user_key */

/**
 * $ANTLR start value_key
 * PLSQLKeys.g:1940:1: value_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::value_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1941:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1941:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VALUE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VALUE\")" );
                    ex->set_ruleName( "value_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_value_key10785);
            if  (this->hasException())
            {
                goto rulevalue_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevalue_keyEx; /* Prevent compiler warnings */
    rulevalue_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end value_key */

/**
 * $ANTLR start substring_key
 * PLSQLKeys.g:1944:1: substring_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::substring_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1945:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1945:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SUBSTRING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SUBSTRING\")" );
                    ex->set_ruleName( "substring_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_substring_key10808);
            if  (this->hasException())
            {
                goto rulesubstring_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubstring_keyEx; /* Prevent compiler warnings */
    rulesubstring_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end substring_key */

/**
 * $ANTLR start upper_key
 * PLSQLKeys.g:1948:1: upper_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::upper_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1949:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1949:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UPPER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UPPER\")" );
                    ex->set_ruleName( "upper_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_upper_key10830);
            if  (this->hasException())
            {
                goto ruleupper_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleupper_keyEx; /* Prevent compiler warnings */
    ruleupper_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end upper_key */

/**
 * $ANTLR start lower_key
 * PLSQLKeys.g:1952:1: lower_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::lower_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1953:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1953:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LOWER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LOWER\")" );
                    ex->set_ruleName( "lower_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_lower_key10852);
            if  (this->hasException())
            {
                goto rulelower_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelower_keyEx; /* Prevent compiler warnings */
    rulelower_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end lower_key */

/**
 * $ANTLR start convert_key
 * PLSQLKeys.g:1956:1: convert_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::convert_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1957:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1957:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CONVERT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CONVERT\")" );
                    ex->set_ruleName( "convert_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_convert_key10874);
            if  (this->hasException())
            {
                goto ruleconvert_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconvert_keyEx; /* Prevent compiler warnings */
    ruleconvert_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end convert_key */

/**
 * $ANTLR start translate_key
 * PLSQLKeys.g:1960:1: translate_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::translate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1961:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1961:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TRANSLATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TRANSLATE\")" );
                    ex->set_ruleName( "translate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_translate_key10896);
            if  (this->hasException())
            {
                goto ruletranslate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletranslate_keyEx; /* Prevent compiler warnings */
    ruletranslate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end translate_key */

/**
 * $ANTLR start trim_key
 * PLSQLKeys.g:1964:1: trim_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::trim_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1965:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1965:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TRIM"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TRIM\")" );
                    ex->set_ruleName( "trim_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_trim_key10918);
            if  (this->hasException())
            {
                goto ruletrim_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletrim_keyEx; /* Prevent compiler warnings */
    ruletrim_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end trim_key */

/**
 * $ANTLR start leading_key
 * PLSQLKeys.g:1968:1: leading_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::leading_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1969:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1969:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LEADING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LEADING\")" );
                    ex->set_ruleName( "leading_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_leading_key10940);
            if  (this->hasException())
            {
                goto ruleleading_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleleading_keyEx; /* Prevent compiler warnings */
    ruleleading_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end leading_key */

/**
 * $ANTLR start trailing_key
 * PLSQLKeys.g:1972:1: trailing_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::trailing_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1973:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1973:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TRAILING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TRAILING\")" );
                    ex->set_ruleName( "trailing_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_trailing_key10962);
            if  (this->hasException())
            {
                goto ruletrailing_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletrailing_keyEx; /* Prevent compiler warnings */
    ruletrailing_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end trailing_key */

/**
 * $ANTLR start both_key
 * PLSQLKeys.g:1976:1: both_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::both_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1977:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1977:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BOTH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BOTH\")" );
                    ex->set_ruleName( "both_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_both_key10984);
            if  (this->hasException())
            {
                goto ruleboth_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleboth_keyEx; /* Prevent compiler warnings */
    ruleboth_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end both_key */

/**
 * $ANTLR start collate_key
 * PLSQLKeys.g:1980:1: collate_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::collate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1981:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1981:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COLLATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COLLATE\")" );
                    ex->set_ruleName( "collate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_collate_key11006);
            if  (this->hasException())
            {
                goto rulecollate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecollate_keyEx; /* Prevent compiler warnings */
    rulecollate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end collate_key */

/**
 * $ANTLR start position_key
 * PLSQLKeys.g:1984:1: position_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::position_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1985:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1985:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "POSITION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"POSITION\")" );
                    ex->set_ruleName( "position_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_position_key11028);
            if  (this->hasException())
            {
                goto ruleposition_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleposition_keyEx; /* Prevent compiler warnings */
    ruleposition_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end position_key */

/**
 * $ANTLR start extract_key
 * PLSQLKeys.g:1988:1: extract_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::extract_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1989:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1989:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXTRACT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXTRACT\")" );
                    ex->set_ruleName( "extract_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_extract_key11050);
            if  (this->hasException())
            {
                goto ruleextract_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleextract_keyEx; /* Prevent compiler warnings */
    ruleextract_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end extract_key */

/**
 * $ANTLR start second_key
 * PLSQLKeys.g:1992:1: second_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::second_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1993:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1993:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SECOND"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SECOND\")" );
                    ex->set_ruleName( "second_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_second_key11072);
            if  (this->hasException())
            {
                goto rulesecond_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesecond_keyEx; /* Prevent compiler warnings */
    rulesecond_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end second_key */

/**
 * $ANTLR start timezone_hour_key
 * PLSQLKeys.g:1996:1: timezone_hour_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::timezone_hour_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1997:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1997:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_HOUR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIMEZONE_HOUR\")" );
                    ex->set_ruleName( "timezone_hour_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timezone_hour_key11094);
            if  (this->hasException())
            {
                goto ruletimezone_hour_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletimezone_hour_keyEx; /* Prevent compiler warnings */
    ruletimezone_hour_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timezone_hour_key */

/**
 * $ANTLR start timezone_minute_key
 * PLSQLKeys.g:2000:1: timezone_minute_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::timezone_minute_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2001:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2001:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_MINUTE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIMEZONE_MINUTE\")" );
                    ex->set_ruleName( "timezone_minute_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timezone_minute_key11116);
            if  (this->hasException())
            {
                goto ruletimezone_minute_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletimezone_minute_keyEx; /* Prevent compiler warnings */
    ruletimezone_minute_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timezone_minute_key */

/**
 * $ANTLR start char_length_key
 * PLSQLKeys.g:2004:1: char_length_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::char_length_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2005:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2005:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CHAR_LENGTH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CHAR_LENGTH\")" );
                    ex->set_ruleName( "char_length_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_char_length_key11138);
            if  (this->hasException())
            {
                goto rulechar_length_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulechar_length_keyEx; /* Prevent compiler warnings */
    rulechar_length_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end char_length_key */

/**
 * $ANTLR start octet_length_key
 * PLSQLKeys.g:2008:1: octet_length_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::octet_length_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2009:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2009:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OCTET_LENGTH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OCTET_LENGTH\")" );
                    ex->set_ruleName( "octet_length_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_octet_length_key11160);
            if  (this->hasException())
            {
                goto ruleoctet_length_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleoctet_length_keyEx; /* Prevent compiler warnings */
    ruleoctet_length_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end octet_length_key */

/**
 * $ANTLR start character_length_key
 * PLSQLKeys.g:2012:1: character_length_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::character_length_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2013:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2013:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CHARACTER_LENGTH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CHARACTER_LENGTH\")" );
                    ex->set_ruleName( "character_length_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_character_length_key11182);
            if  (this->hasException())
            {
                goto rulecharacter_length_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecharacter_length_keyEx; /* Prevent compiler warnings */
    rulecharacter_length_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end character_length_key */

/**
 * $ANTLR start bit_length_key
 * PLSQLKeys.g:2016:1: bit_length_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::bit_length_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2017:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2017:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BIT_LENGTH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BIT_LENGTH\")" );
                    ex->set_ruleName( "bit_length_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_bit_length_key11204);
            if  (this->hasException())
            {
                goto rulebit_length_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebit_length_keyEx; /* Prevent compiler warnings */
    rulebit_length_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end bit_length_key */

/**
 * $ANTLR start local_key
 * PLSQLKeys.g:2020:1: local_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::local_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2021:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2021:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LOCAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LOCAL\")" );
                    ex->set_ruleName( "local_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_local_key11226);
            if  (this->hasException())
            {
                goto rulelocal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelocal_keyEx; /* Prevent compiler warnings */
    rulelocal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end local_key */

/**
 * $ANTLR start current_timestamp_key
 * PLSQLKeys.g:2024:1: current_timestamp_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::current_timestamp_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2025:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2025:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CURRENT_TIMESTAMP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CURRENT_TIMESTAMP\")" );
                    ex->set_ruleName( "current_timestamp_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_current_timestamp_key11248);
            if  (this->hasException())
            {
                goto rulecurrent_timestamp_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecurrent_timestamp_keyEx; /* Prevent compiler warnings */
    rulecurrent_timestamp_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end current_timestamp_key */

/**
 * $ANTLR start current_date_key
 * PLSQLKeys.g:2028:1: current_date_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::current_date_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2029:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2029:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CURRENT_DATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CURRENT_DATE\")" );
                    ex->set_ruleName( "current_date_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_current_date_key11270);
            if  (this->hasException())
            {
                goto rulecurrent_date_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecurrent_date_keyEx; /* Prevent compiler warnings */
    rulecurrent_date_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end current_date_key */

/**
 * $ANTLR start current_time_key
 * PLSQLKeys.g:2032:1: current_time_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::current_time_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2033:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2033:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CURRENT_TIME"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CURRENT_TIME\")" );
                    ex->set_ruleName( "current_time_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_current_time_key11292);
            if  (this->hasException())
            {
                goto rulecurrent_time_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecurrent_time_keyEx; /* Prevent compiler warnings */
    rulecurrent_time_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end current_time_key */

/**
 * $ANTLR start module_key
 * PLSQLKeys.g:2036:1: module_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::module_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2037:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2037:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MODULE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MODULE\")" );
                    ex->set_ruleName( "module_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_module_key11314);
            if  (this->hasException())
            {
                goto rulemodule_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodule_keyEx; /* Prevent compiler warnings */
    rulemodule_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end module_key */

/**
 * $ANTLR start global_key
 * PLSQLKeys.g:2040:1: global_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::global_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2041:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2041:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "GLOBAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"GLOBAL\")" );
                    ex->set_ruleName( "global_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_global_key11336);
            if  (this->hasException())
            {
                goto ruleglobal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleglobal_keyEx; /* Prevent compiler warnings */
    ruleglobal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end global_key */

/**
 * $ANTLR start year_key
 * PLSQLKeys.g:2044:1: year_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::year_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2045:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:2045:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "YEAR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"YEAR\")" );
                    ex->set_ruleName( "year_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_year_key11359);
            if  (this->hasException())
            {
                goto ruleyear_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleyear_keyEx; /* Prevent compiler warnings */
    ruleyear_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end year_key */

/**
 * $ANTLR start month_key
 * PLSQLKeys.g:2048:1: month_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::month_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2049:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2049:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MONTH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MONTH\")" );
                    ex->set_ruleName( "month_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_month_key11381);
            if  (this->hasException())
            {
                goto rulemonth_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemonth_keyEx; /* Prevent compiler warnings */
    rulemonth_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end month_key */

/**
 * $ANTLR start day_key
 * PLSQLKeys.g:2052:1: day_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::day_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2053:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:2053:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DAY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DAY\")" );
                    ex->set_ruleName( "day_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_day_key11404);
            if  (this->hasException())
            {
                goto ruleday_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleday_keyEx; /* Prevent compiler warnings */
    ruleday_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end day_key */

/**
 * $ANTLR start hour_key
 * PLSQLKeys.g:2056:1: hour_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::hour_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2057:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2057:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "HOUR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"HOUR\")" );
                    ex->set_ruleName( "hour_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_hour_key11426);
            if  (this->hasException())
            {
                goto rulehour_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulehour_keyEx; /* Prevent compiler warnings */
    rulehour_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end hour_key */

/**
 * $ANTLR start minute_key
 * PLSQLKeys.g:2060:1: minute_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::minute_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2061:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2061:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MINUTE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MINUTE\")" );
                    ex->set_ruleName( "minute_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_minute_key11448);
            if  (this->hasException())
            {
                goto ruleminute_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleminute_keyEx; /* Prevent compiler warnings */
    ruleminute_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end minute_key */

/**
 * $ANTLR start whenever_key
 * PLSQLKeys.g:2064:1: whenever_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::whenever_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2065:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2065:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "WHENEVER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"WHENEVER\")" );
                    ex->set_ruleName( "whenever_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_whenever_key11470);
            if  (this->hasException())
            {
                goto rulewhenever_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewhenever_keyEx; /* Prevent compiler warnings */
    rulewhenever_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end whenever_key */

/**
 * $ANTLR start is_key
 * PLSQLKeys.g:2068:1: is_key : SQL92_RESERVED_IS ;
 */
void
PLSQLParser_PLSQLKeys::is_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2069:5: ( SQL92_RESERVED_IS )
        // PLSQLKeys.g:2069:10: SQL92_RESERVED_IS
        {
             this->matchToken(SQL92_RESERVED_IS, &FOLLOW_SQL92_RESERVED_IS_in_is_key11490);
            if  (this->hasException())
            {
                goto ruleis_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleis_keyEx; /* Prevent compiler warnings */
    ruleis_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end is_key */

/**
 * $ANTLR start else_key
 * PLSQLKeys.g:2072:1: else_key : SQL92_RESERVED_ELSE ;
 */
void
PLSQLParser_PLSQLKeys::else_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2073:5: ( SQL92_RESERVED_ELSE )
        // PLSQLKeys.g:2073:10: SQL92_RESERVED_ELSE
        {
             this->matchToken(SQL92_RESERVED_ELSE, &FOLLOW_SQL92_RESERVED_ELSE_in_else_key11510);
            if  (this->hasException())
            {
                goto ruleelse_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleelse_keyEx; /* Prevent compiler warnings */
    ruleelse_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end else_key */

/**
 * $ANTLR start table_key
 * PLSQLKeys.g:2076:1: table_key : SQL92_RESERVED_TABLE ;
 */
void
PLSQLParser_PLSQLKeys::table_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2077:5: ( SQL92_RESERVED_TABLE )
        // PLSQLKeys.g:2077:10: SQL92_RESERVED_TABLE
        {
             this->matchToken(SQL92_RESERVED_TABLE, &FOLLOW_SQL92_RESERVED_TABLE_in_table_key11530);
            if  (this->hasException())
            {
                goto ruletable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_keyEx; /* Prevent compiler warnings */
    ruletable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_key */

/**
 * $ANTLR start the_key
 * PLSQLKeys.g:2080:1: the_key : SQL92_RESERVED_THE ;
 */
void
PLSQLParser_PLSQLKeys::the_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2081:5: ( SQL92_RESERVED_THE )
        // PLSQLKeys.g:2081:10: SQL92_RESERVED_THE
        {
             this->matchToken(SQL92_RESERVED_THE, &FOLLOW_SQL92_RESERVED_THE_in_the_key11550);
            if  (this->hasException())
            {
                goto rulethe_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulethe_keyEx; /* Prevent compiler warnings */
    rulethe_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end the_key */

/**
 * $ANTLR start then_key
 * PLSQLKeys.g:2084:1: then_key : SQL92_RESERVED_THEN ;
 */
void
PLSQLParser_PLSQLKeys::then_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2085:5: ( SQL92_RESERVED_THEN )
        // PLSQLKeys.g:2085:10: SQL92_RESERVED_THEN
        {
             this->matchToken(SQL92_RESERVED_THEN, &FOLLOW_SQL92_RESERVED_THEN_in_then_key11570);
            if  (this->hasException())
            {
                goto rulethen_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulethen_keyEx; /* Prevent compiler warnings */
    rulethen_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end then_key */

/**
 * $ANTLR start end_key
 * PLSQLKeys.g:2088:1: end_key : SQL92_RESERVED_END ;
 */
void
PLSQLParser_PLSQLKeys::end_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2089:5: ( SQL92_RESERVED_END )
        // PLSQLKeys.g:2089:10: SQL92_RESERVED_END
        {
             this->matchToken(SQL92_RESERVED_END, &FOLLOW_SQL92_RESERVED_END_in_end_key11590);
            if  (this->hasException())
            {
                goto ruleend_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleend_keyEx; /* Prevent compiler warnings */
    ruleend_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end end_key */

/**
 * $ANTLR start all_key
 * PLSQLKeys.g:2092:1: all_key : SQL92_RESERVED_ALL ;
 */
void
PLSQLParser_PLSQLKeys::all_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2093:5: ( SQL92_RESERVED_ALL )
        // PLSQLKeys.g:2093:10: SQL92_RESERVED_ALL
        {
             this->matchToken(SQL92_RESERVED_ALL, &FOLLOW_SQL92_RESERVED_ALL_in_all_key11610);
            if  (this->hasException())
            {
                goto ruleall_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleall_keyEx; /* Prevent compiler warnings */
    ruleall_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end all_key */

/**
 * $ANTLR start on_key
 * PLSQLKeys.g:2096:1: on_key : SQL92_RESERVED_ON ;
 */
void
PLSQLParser_PLSQLKeys::on_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2097:5: ( SQL92_RESERVED_ON )
        // PLSQLKeys.g:2097:10: SQL92_RESERVED_ON
        {
             this->matchToken(SQL92_RESERVED_ON, &FOLLOW_SQL92_RESERVED_ON_in_on_key11630);
            if  (this->hasException())
            {
                goto ruleon_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleon_keyEx; /* Prevent compiler warnings */
    ruleon_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end on_key */

/**
 * $ANTLR start or_key
 * PLSQLKeys.g:2100:1: or_key : SQL92_RESERVED_OR ;
 */
void
PLSQLParser_PLSQLKeys::or_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2101:5: ( SQL92_RESERVED_OR )
        // PLSQLKeys.g:2101:10: SQL92_RESERVED_OR
        {
             this->matchToken(SQL92_RESERVED_OR, &FOLLOW_SQL92_RESERVED_OR_in_or_key11650);
            if  (this->hasException())
            {
                goto ruleor_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleor_keyEx; /* Prevent compiler warnings */
    ruleor_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end or_key */

/**
 * $ANTLR start and_key
 * PLSQLKeys.g:2104:1: and_key : SQL92_RESERVED_AND ;
 */
void
PLSQLParser_PLSQLKeys::and_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2105:5: ( SQL92_RESERVED_AND )
        // PLSQLKeys.g:2105:10: SQL92_RESERVED_AND
        {
             this->matchToken(SQL92_RESERVED_AND, &FOLLOW_SQL92_RESERVED_AND_in_and_key11670);
            if  (this->hasException())
            {
                goto ruleand_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleand_keyEx; /* Prevent compiler warnings */
    ruleand_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end and_key */

/**
 * $ANTLR start not_key
 * PLSQLKeys.g:2108:1: not_key : SQL92_RESERVED_NOT ;
 */
void
PLSQLParser_PLSQLKeys::not_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2109:5: ( SQL92_RESERVED_NOT )
        // PLSQLKeys.g:2109:10: SQL92_RESERVED_NOT
        {
             this->matchToken(SQL92_RESERVED_NOT, &FOLLOW_SQL92_RESERVED_NOT_in_not_key11690);
            if  (this->hasException())
            {
                goto rulenot_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenot_keyEx; /* Prevent compiler warnings */
    rulenot_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end not_key */

/**
 * $ANTLR start true_key
 * PLSQLKeys.g:2112:1: true_key : SQL92_RESERVED_TRUE ;
 */
void
PLSQLParser_PLSQLKeys::true_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2113:5: ( SQL92_RESERVED_TRUE )
        // PLSQLKeys.g:2113:10: SQL92_RESERVED_TRUE
        {
             this->matchToken(SQL92_RESERVED_TRUE, &FOLLOW_SQL92_RESERVED_TRUE_in_true_key11710);
            if  (this->hasException())
            {
                goto ruletrue_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletrue_keyEx; /* Prevent compiler warnings */
    ruletrue_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end true_key */

/**
 * $ANTLR start false_key
 * PLSQLKeys.g:2116:1: false_key : SQL92_RESERVED_FALSE ;
 */
void
PLSQLParser_PLSQLKeys::false_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2117:5: ( SQL92_RESERVED_FALSE )
        // PLSQLKeys.g:2117:10: SQL92_RESERVED_FALSE
        {
             this->matchToken(SQL92_RESERVED_FALSE, &FOLLOW_SQL92_RESERVED_FALSE_in_false_key11730);
            if  (this->hasException())
            {
                goto rulefalse_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefalse_keyEx; /* Prevent compiler warnings */
    rulefalse_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end false_key */

/**
 * $ANTLR start default_key
 * PLSQLKeys.g:2120:1: default_key : SQL92_RESERVED_DEFAULT ;
 */
void
PLSQLParser_PLSQLKeys::default_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2121:5: ( SQL92_RESERVED_DEFAULT )
        // PLSQLKeys.g:2121:10: SQL92_RESERVED_DEFAULT
        {
             this->matchToken(SQL92_RESERVED_DEFAULT, &FOLLOW_SQL92_RESERVED_DEFAULT_in_default_key11750);
            if  (this->hasException())
            {
                goto ruledefault_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledefault_keyEx; /* Prevent compiler warnings */
    ruledefault_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end default_key */

/**
 * $ANTLR start distinct_key
 * PLSQLKeys.g:2124:1: distinct_key : SQL92_RESERVED_DISTINCT ;
 */
void
PLSQLParser_PLSQLKeys::distinct_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2125:5: ( SQL92_RESERVED_DISTINCT )
        // PLSQLKeys.g:2125:10: SQL92_RESERVED_DISTINCT
        {
             this->matchToken(SQL92_RESERVED_DISTINCT, &FOLLOW_SQL92_RESERVED_DISTINCT_in_distinct_key11770);
            if  (this->hasException())
            {
                goto ruledistinct_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledistinct_keyEx; /* Prevent compiler warnings */
    ruledistinct_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end distinct_key */

/**
 * $ANTLR start into_key
 * PLSQLKeys.g:2128:1: into_key : SQL92_RESERVED_INTO ;
 */
void
PLSQLParser_PLSQLKeys::into_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2129:5: ( SQL92_RESERVED_INTO )
        // PLSQLKeys.g:2129:10: SQL92_RESERVED_INTO
        {
             this->matchToken(SQL92_RESERVED_INTO, &FOLLOW_SQL92_RESERVED_INTO_in_into_key11790);
            if  (this->hasException())
            {
                goto ruleinto_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinto_keyEx; /* Prevent compiler warnings */
    ruleinto_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end into_key */

/**
 * $ANTLR start by_key
 * PLSQLKeys.g:2132:1: by_key : SQL92_RESERVED_BY ;
 */
void
PLSQLParser_PLSQLKeys::by_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2133:5: ( SQL92_RESERVED_BY )
        // PLSQLKeys.g:2133:10: SQL92_RESERVED_BY
        {
             this->matchToken(SQL92_RESERVED_BY, &FOLLOW_SQL92_RESERVED_BY_in_by_key11810);
            if  (this->hasException())
            {
                goto ruleby_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleby_keyEx; /* Prevent compiler warnings */
    ruleby_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end by_key */

/**
 * $ANTLR start as_key
 * PLSQLKeys.g:2136:1: as_key : SQL92_RESERVED_AS ;
 */
void
PLSQLParser_PLSQLKeys::as_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2137:5: ( SQL92_RESERVED_AS )
        // PLSQLKeys.g:2137:10: SQL92_RESERVED_AS
        {
             this->matchToken(SQL92_RESERVED_AS, &FOLLOW_SQL92_RESERVED_AS_in_as_key11830);
            if  (this->hasException())
            {
                goto ruleas_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleas_keyEx; /* Prevent compiler warnings */
    ruleas_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end as_key */

/**
 * $ANTLR start in_key
 * PLSQLKeys.g:2140:1: in_key : SQL92_RESERVED_IN ;
 */
void
PLSQLParser_PLSQLKeys::in_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2141:5: ( SQL92_RESERVED_IN )
        // PLSQLKeys.g:2141:10: SQL92_RESERVED_IN
        {
             this->matchToken(SQL92_RESERVED_IN, &FOLLOW_SQL92_RESERVED_IN_in_in_key11850);
            if  (this->hasException())
            {
                goto rulein_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulein_keyEx; /* Prevent compiler warnings */
    rulein_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end in_key */

/**
 * $ANTLR start of_key
 * PLSQLKeys.g:2144:1: of_key : SQL92_RESERVED_OF ;
 */
void
PLSQLParser_PLSQLKeys::of_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2145:5: ( SQL92_RESERVED_OF )
        // PLSQLKeys.g:2145:10: SQL92_RESERVED_OF
        {
             this->matchToken(SQL92_RESERVED_OF, &FOLLOW_SQL92_RESERVED_OF_in_of_key11870);
            if  (this->hasException())
            {
                goto ruleof_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleof_keyEx; /* Prevent compiler warnings */
    ruleof_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end of_key */

/**
 * $ANTLR start null_key
 * PLSQLKeys.g:2148:1: null_key : SQL92_RESERVED_NULL ;
 */
void
PLSQLParser_PLSQLKeys::null_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2149:5: ( SQL92_RESERVED_NULL )
        // PLSQLKeys.g:2149:10: SQL92_RESERVED_NULL
        {
             this->matchToken(SQL92_RESERVED_NULL, &FOLLOW_SQL92_RESERVED_NULL_in_null_key11890);
            if  (this->hasException())
            {
                goto rulenull_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenull_keyEx; /* Prevent compiler warnings */
    rulenull_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end null_key */

/**
 * $ANTLR start for_key
 * PLSQLKeys.g:2152:1: for_key : SQL92_RESERVED_FOR ;
 */
void
PLSQLParser_PLSQLKeys::for_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2153:5: ( SQL92_RESERVED_FOR )
        // PLSQLKeys.g:2153:10: SQL92_RESERVED_FOR
        {
             this->matchToken(SQL92_RESERVED_FOR, &FOLLOW_SQL92_RESERVED_FOR_in_for_key11910);
            if  (this->hasException())
            {
                goto rulefor_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefor_keyEx; /* Prevent compiler warnings */
    rulefor_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end for_key */

/**
 * $ANTLR start select_key
 * PLSQLKeys.g:2156:1: select_key : SQL92_RESERVED_SELECT ;
 */
void
PLSQLParser_PLSQLKeys::select_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2157:5: ( SQL92_RESERVED_SELECT )
        // PLSQLKeys.g:2157:10: SQL92_RESERVED_SELECT
        {
             this->matchToken(SQL92_RESERVED_SELECT, &FOLLOW_SQL92_RESERVED_SELECT_in_select_key11930);
            if  (this->hasException())
            {
                goto ruleselect_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleselect_keyEx; /* Prevent compiler warnings */
    ruleselect_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end select_key */

/**
 * $ANTLR start when_key
 * PLSQLKeys.g:2160:1: when_key : SQL92_RESERVED_WHEN ;
 */
void
PLSQLParser_PLSQLKeys::when_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2161:5: ( SQL92_RESERVED_WHEN )
        // PLSQLKeys.g:2161:10: SQL92_RESERVED_WHEN
        {
             this->matchToken(SQL92_RESERVED_WHEN, &FOLLOW_SQL92_RESERVED_WHEN_in_when_key11950);
            if  (this->hasException())
            {
                goto rulewhen_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewhen_keyEx; /* Prevent compiler warnings */
    rulewhen_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end when_key */

/**
 * $ANTLR start delete_key
 * PLSQLKeys.g:2164:1: delete_key : SQL92_RESERVED_DELETE ;
 */
void
PLSQLParser_PLSQLKeys::delete_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2165:5: ( SQL92_RESERVED_DELETE )
        // PLSQLKeys.g:2165:10: SQL92_RESERVED_DELETE
        {
             this->matchToken(SQL92_RESERVED_DELETE, &FOLLOW_SQL92_RESERVED_DELETE_in_delete_key11970);
            if  (this->hasException())
            {
                goto ruledelete_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledelete_keyEx; /* Prevent compiler warnings */
    ruledelete_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end delete_key */

/**
 * $ANTLR start between_key
 * PLSQLKeys.g:2168:1: between_key : SQL92_RESERVED_BETWEEN ;
 */
void
PLSQLParser_PLSQLKeys::between_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2169:5: ( SQL92_RESERVED_BETWEEN )
        // PLSQLKeys.g:2169:10: SQL92_RESERVED_BETWEEN
        {
             this->matchToken(SQL92_RESERVED_BETWEEN, &FOLLOW_SQL92_RESERVED_BETWEEN_in_between_key11990);
            if  (this->hasException())
            {
                goto rulebetween_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebetween_keyEx; /* Prevent compiler warnings */
    rulebetween_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end between_key */

/**
 * $ANTLR start like_key
 * PLSQLKeys.g:2172:1: like_key : SQL92_RESERVED_LIKE ;
 */
void
PLSQLParser_PLSQLKeys::like_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2173:5: ( SQL92_RESERVED_LIKE )
        // PLSQLKeys.g:2173:10: SQL92_RESERVED_LIKE
        {
             this->matchToken(SQL92_RESERVED_LIKE, &FOLLOW_SQL92_RESERVED_LIKE_in_like_key12010);
            if  (this->hasException())
            {
                goto rulelike_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelike_keyEx; /* Prevent compiler warnings */
    rulelike_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end like_key */

/**
 * $ANTLR start from_key
 * PLSQLKeys.g:2176:1: from_key : SQL92_RESERVED_FROM ;
 */
void
PLSQLParser_PLSQLKeys::from_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2177:5: ( SQL92_RESERVED_FROM )
        // PLSQLKeys.g:2177:10: SQL92_RESERVED_FROM
        {
             this->matchToken(SQL92_RESERVED_FROM, &FOLLOW_SQL92_RESERVED_FROM_in_from_key12030);
            if  (this->hasException())
            {
                goto rulefrom_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefrom_keyEx; /* Prevent compiler warnings */
    rulefrom_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end from_key */

/**
 * $ANTLR start where_key
 * PLSQLKeys.g:2180:1: where_key : SQL92_RESERVED_WHERE ;
 */
void
PLSQLParser_PLSQLKeys::where_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2181:5: ( SQL92_RESERVED_WHERE )
        // PLSQLKeys.g:2181:10: SQL92_RESERVED_WHERE
        {
             this->matchToken(SQL92_RESERVED_WHERE, &FOLLOW_SQL92_RESERVED_WHERE_in_where_key12050);
            if  (this->hasException())
            {
                goto rulewhere_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewhere_keyEx; /* Prevent compiler warnings */
    rulewhere_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end where_key */

/**
 * $ANTLR start sequence_key
 * PLSQLKeys.g:2184:1: sequence_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sequence_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2185:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2185:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SEQUENCE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SEQUENCE\")" );
                    ex->set_ruleName( "sequence_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sequence_key12072);
            if  (this->hasException())
            {
                goto rulesequence_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesequence_keyEx; /* Prevent compiler warnings */
    rulesequence_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sequence_key */

/**
 * $ANTLR start noorder_key
 * PLSQLKeys.g:2188:1: noorder_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::noorder_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2189:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2189:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOORDER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOORDER\")" );
                    ex->set_ruleName( "noorder_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_noorder_key12094);
            if  (this->hasException())
            {
                goto rulenoorder_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenoorder_keyEx; /* Prevent compiler warnings */
    rulenoorder_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end noorder_key */

/**
 * $ANTLR start cycle_key
 * PLSQLKeys.g:2192:1: cycle_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::cycle_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2193:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2193:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CYCLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CYCLE\")" );
                    ex->set_ruleName( "cycle_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cycle_key12116);
            if  (this->hasException())
            {
                goto rulecycle_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecycle_keyEx; /* Prevent compiler warnings */
    rulecycle_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cycle_key */

/**
 * $ANTLR start cache_key
 * PLSQLKeys.g:2196:1: cache_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::cache_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2197:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2197:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CACHE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CACHE\")" );
                    ex->set_ruleName( "cache_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cache_key12138);
            if  (this->hasException())
            {
                goto rulecache_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecache_keyEx; /* Prevent compiler warnings */
    rulecache_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cache_key */

/**
 * $ANTLR start nocache_key
 * PLSQLKeys.g:2200:1: nocache_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nocache_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2201:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2201:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOCACHE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOCACHE\")" );
                    ex->set_ruleName( "nocache_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nocache_key12160);
            if  (this->hasException())
            {
                goto rulenocache_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenocache_keyEx; /* Prevent compiler warnings */
    rulenocache_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nocache_key */

/**
 * $ANTLR start nomaxvalue_key
 * PLSQLKeys.g:2204:1: nomaxvalue_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nomaxvalue_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2205:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2205:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOMAXVALUE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOMAXVALUE\")" );
                    ex->set_ruleName( "nomaxvalue_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nomaxvalue_key12182);
            if  (this->hasException())
            {
                goto rulenomaxvalue_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenomaxvalue_keyEx; /* Prevent compiler warnings */
    rulenomaxvalue_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nomaxvalue_key */

/**
 * $ANTLR start nominvalue_key
 * PLSQLKeys.g:2208:1: nominvalue_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nominvalue_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2209:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2209:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOMINVALUE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOMINVALUE\")" );
                    ex->set_ruleName( "nominvalue_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nominvalue_key12204);
            if  (this->hasException())
            {
                goto rulenominvalue_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenominvalue_keyEx; /* Prevent compiler warnings */
    rulenominvalue_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nominvalue_key */

/**
 * $ANTLR start search_key
 * PLSQLKeys.g:2212:1: search_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::search_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2213:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2213:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SEARCH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SEARCH\")" );
                    ex->set_ruleName( "search_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_search_key12226);
            if  (this->hasException())
            {
                goto rulesearch_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesearch_keyEx; /* Prevent compiler warnings */
    rulesearch_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end search_key */

/**
 * $ANTLR start depth_key
 * PLSQLKeys.g:2216:1: depth_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::depth_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2217:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2217:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DEPTH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DEPTH\")" );
                    ex->set_ruleName( "depth_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_depth_key12248);
            if  (this->hasException())
            {
                goto ruledepth_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledepth_keyEx; /* Prevent compiler warnings */
    ruledepth_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end depth_key */

/**
 * $ANTLR start breadth_key
 * PLSQLKeys.g:2220:1: breadth_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::breadth_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2221:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2221:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BREADTH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BREADTH\")" );
                    ex->set_ruleName( "breadth_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_breadth_key12270);
            if  (this->hasException())
            {
                goto rulebreadth_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebreadth_keyEx; /* Prevent compiler warnings */
    rulebreadth_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end breadth_key */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

}

/* End of code
 * =============================================================================
 */
