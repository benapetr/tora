/** \file
 *  This C++ source file was generated by $ANTLR version 3.5.2-SNAPSHOT
 *
 *     -  From the grammar source file : PLSQLKeys.g
 *     -                            On : 2013-10-27 10:35:41
 *     -                for the parser : PLSQLParser_PLSQLKeysParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "PLSQLParser_PLSQLKeys.hpp"
// Include delegator definition header files
//
#include "PLSQLParser.hpp" 

/* ----------------------------------------- */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "LICENSE");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

namespace  Antlr3BackendImpl  {
using namespace antlr3;

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "PLSQLKeys.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* PLSQLParser_PLSQLKeys::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new PLSQLParser_PLSQLKeys parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PLSQLParser_PLSQLKeys::PLSQLParser_PLSQLKeys( StreamType* instream, PLSQLParser* gPLSQLParser)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream, gPLSQLParser);
}

/** \brief Create a new PLSQLParser_PLSQLKeys parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PLSQLParser_PLSQLKeys::PLSQLParser_PLSQLKeys( StreamType* instream, RecognizerSharedStateType* state, PLSQLParser* gPLSQLParser)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream , gPLSQLParser);
}

void PLSQLParser_PLSQLKeys::init(StreamType* instream, PLSQLParser* gPLSQLParser)
{
     	// Install the pointers back to lexers that will delegate us to perform certain functions
     	// for them.
     	//
     		m_gPLSQLParser = gPLSQLParser;
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( PLSQLParserTokenNames );


}

void
PLSQLParser_PLSQLKeys::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
PLSQLParser_PLSQLKeys::~PLSQLParser_PLSQLKeys()
 {
}

/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return PLSQLParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_CREATE_in_create_key47_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_CREATE_in_create_key47( FOLLOW_SQL92_RESERVED_CREATE_in_create_key47_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_replace_key77_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_replace_key77( FOLLOW_REGULAR_ID_in_replace_key77_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_package_key100_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_package_key100( FOLLOW_REGULAR_ID_in_package_key100_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_body_key122_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_body_key122( FOLLOW_REGULAR_ID_in_body_key122_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_BEGIN_in_begin_key142_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_BEGIN_in_begin_key142( FOLLOW_SQL92_RESERVED_BEGIN_in_begin_key142_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_exit_key164_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_exit_key164( FOLLOW_REGULAR_ID_in_exit_key164_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DECLARE_in_declare_key184_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DECLARE_in_declare_key184( FOLLOW_SQL92_RESERVED_DECLARE_in_declare_key184_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_EXCEPTION_in_exception_key204_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_EXCEPTION_in_exception_key204( FOLLOW_SQL92_RESERVED_EXCEPTION_in_exception_key204_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_serveroutput_key226_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_serveroutput_key226( FOLLOW_REGULAR_ID_in_serveroutput_key226_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_off_key248_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_off_key248( FOLLOW_REGULAR_ID_in_off_key248_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_constant_key270_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_constant_key270( FOLLOW_REGULAR_ID_in_constant_key270_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_subtype_key292_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_subtype_key292( FOLLOW_REGULAR_ID_in_subtype_key292_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_CURSOR_in_cursor_key312_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_CURSOR_in_cursor_key312( FOLLOW_SQL92_RESERVED_CURSOR_in_cursor_key312_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nextval_key335_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nextval_key335( FOLLOW_REGULAR_ID_in_nextval_key335_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_GOTO_in_goto_key355_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_GOTO_in_goto_key355( FOLLOW_SQL92_RESERVED_GOTO_in_goto_key355_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_execute_key377_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_execute_key377( FOLLOW_REGULAR_ID_in_execute_key377_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_immediate_key400_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_immediate_key400( FOLLOW_REGULAR_ID_in_immediate_key400_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_return_key422_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_return_key422( FOLLOW_REGULAR_ID_in_return_key422_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_PROCEDURE_in_procedure_key442_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_PROCEDURE_in_procedure_key442( FOLLOW_SQL92_RESERVED_PROCEDURE_in_procedure_key442_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_function_key465_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_function_key465( FOLLOW_REGULAR_ID_in_function_key465_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_pragma_key487_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_pragma_key487( FOLLOW_REGULAR_ID_in_pragma_key487_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_exception_init_key509_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_exception_init_key509( FOLLOW_REGULAR_ID_in_exception_init_key509_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_type_key532_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_type_key532( FOLLOW_REGULAR_ID_in_type_key532_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_record_key555_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_record_key555( FOLLOW_REGULAR_ID_in_record_key555_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_indexed_key577_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_indexed_key577( FOLLOW_REGULAR_ID_in_indexed_key577_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_INDEX_in_index_key597_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_INDEX_in_index_key597( FOLLOW_PLSQL_RESERVED_INDEX_in_index_key597_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PERCENT_in_percent_notfound_key620_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PERCENT_in_percent_notfound_key620( FOLLOW_PERCENT_in_percent_notfound_key620_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_percent_notfound_key622_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_percent_notfound_key622( FOLLOW_REGULAR_ID_in_percent_notfound_key622_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PERCENT_in_percent_found_key645_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PERCENT_in_percent_found_key645( FOLLOW_PERCENT_in_percent_found_key645_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_percent_found_key647_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_percent_found_key647( FOLLOW_REGULAR_ID_in_percent_found_key647_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PERCENT_in_percent_isopen_key670_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PERCENT_in_percent_isopen_key670( FOLLOW_PERCENT_in_percent_isopen_key670_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_percent_isopen_key672_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_percent_isopen_key672( FOLLOW_REGULAR_ID_in_percent_isopen_key672_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PERCENT_in_percent_rowcount_key695_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PERCENT_in_percent_rowcount_key695( FOLLOW_PERCENT_in_percent_rowcount_key695_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_percent_rowcount_key697_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_percent_rowcount_key697( FOLLOW_REGULAR_ID_in_percent_rowcount_key697_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PERCENT_in_percent_rowtype_key720_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PERCENT_in_percent_rowtype_key720( FOLLOW_PERCENT_in_percent_rowtype_key720_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_percent_rowtype_key722_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_percent_rowtype_key722( FOLLOW_REGULAR_ID_in_percent_rowtype_key722_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PERCENT_in_percent_type_key746_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PERCENT_in_percent_type_key746( FOLLOW_PERCENT_in_percent_type_key746_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_percent_type_key748_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_percent_type_key748( FOLLOW_REGULAR_ID_in_percent_type_key748_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_out_key771_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_out_key771( FOLLOW_REGULAR_ID_in_out_key771_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_inout_key793_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_inout_key793( FOLLOW_REGULAR_ID_in_inout_key793_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_extend_key816_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_extend_key816( FOLLOW_REGULAR_ID_in_extend_key816_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_raise_key838_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_raise_key838( FOLLOW_REGULAR_ID_in_raise_key838_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_while_key860_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_while_key860( FOLLOW_REGULAR_ID_in_while_key860_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_loop_key882_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_loop_key882( FOLLOW_REGULAR_ID_in_loop_key882_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_commit_key905_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_commit_key905( FOLLOW_REGULAR_ID_in_commit_key905_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_work_key927_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_work_key927( FOLLOW_REGULAR_ID_in_work_key927_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_IF_in_if_key947_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_IF_in_if_key947( FOLLOW_PLSQL_RESERVED_IF_in_if_key947_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_ELSIF_in_elsif_key967_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_ELSIF_in_elsif_key967( FOLLOW_PLSQL_NON_RESERVED_ELSIF_in_elsif_key967_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_authid_key990_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_authid_key990( FOLLOW_REGULAR_ID_in_authid_key990_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_definer_key1012_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_definer_key1012( FOLLOW_REGULAR_ID_in_definer_key1012_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_external_key1034_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_external_key1034( FOLLOW_REGULAR_ID_in_external_key1034_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_language_key1056_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_language_key1056( FOLLOW_REGULAR_ID_in_language_key1056_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_java_key1078_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_java_key1078( FOLLOW_REGULAR_ID_in_java_key1078_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_name_key1101_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_name_key1101( FOLLOW_REGULAR_ID_in_name_key1101_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_deterministic_key1124_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_deterministic_key1124( FOLLOW_REGULAR_ID_in_deterministic_key1124_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_parallel_enable_key1147_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_parallel_enable_key1147( FOLLOW_REGULAR_ID_in_parallel_enable_key1147_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_result_cache_key1170_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_result_cache_key1170( FOLLOW_REGULAR_ID_in_result_cache_key1170_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_pipelined_key1193_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_pipelined_key1193( FOLLOW_REGULAR_ID_in_pipelined_key1193_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_aggregate_key1215_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_aggregate_key1215( FOLLOW_REGULAR_ID_in_aggregate_key1215_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ALTER_in_alter_key1235_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ALTER_in_alter_key1235( FOLLOW_SQL92_RESERVED_ALTER_in_alter_key1235_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_compile_key1257_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_compile_key1257( FOLLOW_REGULAR_ID_in_compile_key1257_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_debug_key1280_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_debug_key1280( FOLLOW_REGULAR_ID_in_debug_key1280_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_reuse_key1302_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_reuse_key1302( FOLLOW_REGULAR_ID_in_reuse_key1302_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_settings_key1324_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_settings_key1324( FOLLOW_REGULAR_ID_in_settings_key1324_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_specification_key1346_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_specification_key1346( FOLLOW_REGULAR_ID_in_specification_key1346_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DROP_in_drop_key1366_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DROP_in_drop_key1366( FOLLOW_SQL92_RESERVED_DROP_in_drop_key1366_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_trigger_key1389_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_trigger_key1389( FOLLOW_REGULAR_ID_in_trigger_key1389_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_force_key1412_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_force_key1412( FOLLOW_REGULAR_ID_in_force_key1412_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_validate_key1434_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_validate_key1434( FOLLOW_REGULAR_ID_in_validate_key1434_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ref_key1457_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ref_key1457( FOLLOW_REGULAR_ID_in_ref_key1457_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_array_key1480_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_array_key1480( FOLLOW_REGULAR_ID_in_array_key1480_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_varray_key1503_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_varray_key1503( FOLLOW_REGULAR_ID_in_varray_key1503_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_pls_integer_key1526_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_pls_integer_key1526( FOLLOW_REGULAR_ID_in_pls_integer_key1526_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_serially_reusable_key1549_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_serially_reusable_key1549( FOLLOW_REGULAR_ID_in_serially_reusable_key1549_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_autonomous_transaction_key1572_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_autonomous_transaction_key1572( FOLLOW_REGULAR_ID_in_autonomous_transaction_key1572_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_inline_key1595_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_inline_key1595( FOLLOW_REGULAR_ID_in_inline_key1595_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_restrict_references_key1618_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_restrict_references_key1618( FOLLOW_REGULAR_ID_in_restrict_references_key1618_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_exceptions_key1641_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_exceptions_key1641( FOLLOW_REGULAR_ID_in_exceptions_key1641_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_save_key1665_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_save_key1665( FOLLOW_REGULAR_ID_in_save_key1665_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_forall_key1688_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_forall_key1688( FOLLOW_REGULAR_ID_in_forall_key1688_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_continue_key1711_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_continue_key1711( FOLLOW_REGULAR_ID_in_continue_key1711_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_indices_key1734_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_indices_key1734( FOLLOW_REGULAR_ID_in_indices_key1734_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_VALUES_in_values_key1754_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_VALUES_in_values_key1754( FOLLOW_SQL92_RESERVED_VALUES_in_values_key1754_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_CASE_in_case_key1774_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_CASE_in_case_key1774( FOLLOW_SQL92_RESERVED_CASE_in_case_key1774_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_bulk_key1797_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_bulk_key1797( FOLLOW_REGULAR_ID_in_bulk_key1797_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_collect_key1820_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_collect_key1820( FOLLOW_REGULAR_ID_in_collect_key1820_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_committed_key1842_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_committed_key1842( FOLLOW_REGULAR_ID_in_committed_key1842_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_use_key1865_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_use_key1865( FOLLOW_REGULAR_ID_in_use_key1865_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_level_key1887_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_level_key1887( FOLLOW_REGULAR_ID_in_level_key1887_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_isolation_key1910_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_isolation_key1910( FOLLOW_REGULAR_ID_in_isolation_key1910_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_serializable_key1932_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_serializable_key1932( FOLLOW_REGULAR_ID_in_serializable_key1932_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_segment_key1954_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_segment_key1954( FOLLOW_REGULAR_ID_in_segment_key1954_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_write_key1977_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_write_key1977( FOLLOW_REGULAR_ID_in_write_key1977_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_wait_key2000_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_wait_key2000( FOLLOW_REGULAR_ID_in_wait_key2000_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_corrupt_xid_all_key2023_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_corrupt_xid_all_key2023( FOLLOW_REGULAR_ID_in_corrupt_xid_all_key2023_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_corrupt_xid_key2046_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_corrupt_xid_key2046( FOLLOW_REGULAR_ID_in_corrupt_xid_key2046_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_batch_key2069_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_batch_key2069( FOLLOW_REGULAR_ID_in_batch_key2069_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_session_key2092_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_session_key2092( FOLLOW_REGULAR_ID_in_session_key2092_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_role_key2115_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_role_key2115( FOLLOW_REGULAR_ID_in_role_key2115_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_constraint_key2138_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_constraint_key2138( FOLLOW_REGULAR_ID_in_constraint_key2138_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_constraints_key2161_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_constraints_key2161( FOLLOW_REGULAR_ID_in_constraints_key2161_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_call_key2184_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_call_key2184( FOLLOW_REGULAR_ID_in_call_key2184_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_explain_key2207_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_explain_key2207( FOLLOW_REGULAR_ID_in_explain_key2207_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_merge_key2230_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_merge_key2230( FOLLOW_REGULAR_ID_in_merge_key2230_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_plan_key2253_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_plan_key2253( FOLLOW_REGULAR_ID_in_plan_key2253_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_system_key2276_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_system_key2276( FOLLOW_REGULAR_ID_in_system_key2276_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_subpartition_key2299_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_subpartition_key2299( FOLLOW_REGULAR_ID_in_subpartition_key2299_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_partition_key2322_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_partition_key2322( FOLLOW_REGULAR_ID_in_partition_key2322_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_matched_key2345_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_matched_key2345( FOLLOW_REGULAR_ID_in_matched_key2345_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_reject_key2368_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_reject_key2368( FOLLOW_REGULAR_ID_in_reject_key2368_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_log_key2391_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_log_key2391( FOLLOW_REGULAR_ID_in_log_key2391_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_unlimited_key2414_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_unlimited_key2414( FOLLOW_REGULAR_ID_in_unlimited_key2414_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_limit_key2437_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_limit_key2437( FOLLOW_REGULAR_ID_in_limit_key2437_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_errors_key2460_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_errors_key2460( FOLLOW_REGULAR_ID_in_errors_key2460_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timestamp_tz_unconstrained_key2483_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timestamp_tz_unconstrained_key2483( FOLLOW_REGULAR_ID_in_timestamp_tz_unconstrained_key2483_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_urowid_key2506_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_urowid_key2506( FOLLOW_REGULAR_ID_in_urowid_key2506_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_min_subnormal_key2529_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_min_subnormal_key2529( FOLLOW_REGULAR_ID_in_binary_float_min_subnormal_key2529_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_min_normal_key2552_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_min_normal_key2552( FOLLOW_REGULAR_ID_in_binary_double_min_normal_key2552_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_max_normal_key2575_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_max_normal_key2575( FOLLOW_REGULAR_ID_in_binary_float_max_normal_key2575_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_positiven_key2598_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_positiven_key2598( FOLLOW_REGULAR_ID_in_positiven_key2598_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timezone_abbr_key2621_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timezone_abbr_key2621( FOLLOW_REGULAR_ID_in_timezone_abbr_key2621_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_min_subnormal_key2644_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_min_subnormal_key2644( FOLLOW_REGULAR_ID_in_binary_double_min_subnormal_key2644_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_max_subnormal_key2667_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_max_subnormal_key2667( FOLLOW_REGULAR_ID_in_binary_float_max_subnormal_key2667_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_key2690_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_key2690( FOLLOW_REGULAR_ID_in_binary_double_key2690_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_bfile_key2713_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_bfile_key2713( FOLLOW_REGULAR_ID_in_bfile_key2713_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_infinity_key2736_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_infinity_key2736( FOLLOW_REGULAR_ID_in_binary_double_infinity_key2736_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timezone_region_key2759_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timezone_region_key2759( FOLLOW_REGULAR_ID_in_timezone_region_key2759_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timestamp_ltz_unconstrained_key2782_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timestamp_ltz_unconstrained_key2782( FOLLOW_REGULAR_ID_in_timestamp_ltz_unconstrained_key2782_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_naturaln_key2805_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_naturaln_key2805( FOLLOW_REGULAR_ID_in_naturaln_key2805_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_simple_integer_key2828_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_simple_integer_key2828( FOLLOW_REGULAR_ID_in_simple_integer_key2828_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_max_subnormal_key2851_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_max_subnormal_key2851( FOLLOW_REGULAR_ID_in_binary_double_max_subnormal_key2851_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_byte_key2874_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_byte_key2874( FOLLOW_REGULAR_ID_in_byte_key2874_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_infinity_key2897_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_infinity_key2897( FOLLOW_REGULAR_ID_in_binary_float_infinity_key2897_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_key2920_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_key2920( FOLLOW_REGULAR_ID_in_binary_float_key2920_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_range_key2943_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_range_key2943( FOLLOW_REGULAR_ID_in_range_key2943_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nclob_key2966_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nclob_key2966( FOLLOW_REGULAR_ID_in_nclob_key2966_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_clob_key2989_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_clob_key2989( FOLLOW_REGULAR_ID_in_clob_key2989_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dsinterval_unconstrained_key3012_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dsinterval_unconstrained_key3012( FOLLOW_REGULAR_ID_in_dsinterval_unconstrained_key3012_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_yminterval_unconstrained_key3035_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_yminterval_unconstrained_key3035( FOLLOW_REGULAR_ID_in_yminterval_unconstrained_key3035_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rowid_key3058_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rowid_key3058( FOLLOW_REGULAR_ID_in_rowid_key3058_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_nan_key3081_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_nan_key3081( FOLLOW_REGULAR_ID_in_binary_double_nan_key3081_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timestamp_unconstrained_key3104_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timestamp_unconstrained_key3104( FOLLOW_REGULAR_ID_in_timestamp_unconstrained_key3104_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_min_normal_key3127_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_min_normal_key3127( FOLLOW_REGULAR_ID_in_binary_float_min_normal_key3127_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_signtype_key3150_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_signtype_key3150( FOLLOW_REGULAR_ID_in_signtype_key3150_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_blob_key3173_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_blob_key3173( FOLLOW_REGULAR_ID_in_blob_key3173_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nvarchar2_key3196_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nvarchar2_key3196( FOLLOW_REGULAR_ID_in_nvarchar2_key3196_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_double_max_normal_key3219_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_double_max_normal_key3219( FOLLOW_REGULAR_ID_in_binary_double_max_normal_key3219_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_float_nan_key3242_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_float_nan_key3242( FOLLOW_REGULAR_ID_in_binary_float_nan_key3242_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_string_key3265_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_string_key3265( FOLLOW_REGULAR_ID_in_string_key3265_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_c_key3288_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_c_key3288( FOLLOW_REGULAR_ID_in_c_key3288_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_library_key3311_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_library_key3311( FOLLOW_REGULAR_ID_in_library_key3311_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_context_key3334_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_context_key3334( FOLLOW_REGULAR_ID_in_context_key3334_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_parameters_key3357_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_parameters_key3357( FOLLOW_REGULAR_ID_in_parameters_key3357_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_agent_key3380_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_agent_key3380( FOLLOW_REGULAR_ID_in_agent_key3380_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cluster_key3403_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cluster_key3403( FOLLOW_REGULAR_ID_in_cluster_key3403_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_hash_key3426_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_hash_key3426( FOLLOW_REGULAR_ID_in_hash_key3426_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_relies_on_key3449_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_relies_on_key3449( FOLLOW_REGULAR_ID_in_relies_on_key3449_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_returning_key3472_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_returning_key3472( FOLLOW_REGULAR_ID_in_returning_key3472_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_statement_id_key3499_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_statement_id_key3499( FOLLOW_REGULAR_ID_in_statement_id_key3499_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_deferred_key3522_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_deferred_key3522( FOLLOW_REGULAR_ID_in_deferred_key3522_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_advise_key3545_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_advise_key3545( FOLLOW_REGULAR_ID_in_advise_key3545_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_resumable_key3568_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_resumable_key3568( FOLLOW_REGULAR_ID_in_resumable_key3568_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timeout_key3591_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timeout_key3591( FOLLOW_REGULAR_ID_in_timeout_key3591_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_parallel_key3614_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_parallel_key3614( FOLLOW_REGULAR_ID_in_parallel_key3614_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ddl_key3637_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ddl_key3637( FOLLOW_REGULAR_ID_in_ddl_key3637_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_query_key3660_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_query_key3660( FOLLOW_REGULAR_ID_in_query_key3660_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dml_key3683_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dml_key3683( FOLLOW_REGULAR_ID_in_dml_key3683_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_guard_key3706_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_guard_key3706( FOLLOW_REGULAR_ID_in_guard_key3706_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nothing_key3729_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nothing_key3729( FOLLOW_REGULAR_ID_in_nothing_key3729_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_enable_key3752_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_enable_key3752( FOLLOW_REGULAR_ID_in_enable_key3752_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_database_key3775_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_database_key3775( FOLLOW_REGULAR_ID_in_database_key3775_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_disable_key3798_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_disable_key3798( FOLLOW_REGULAR_ID_in_disable_key3798_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_link_key3821_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_link_key3821( FOLLOW_REGULAR_ID_in_link_key3821_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_IDENTIFIED_in_identified_key3841_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_IDENTIFIED_in_identified_key3841( FOLLOW_PLSQL_RESERVED_IDENTIFIED_in_identified_key3841_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_none_key3864_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_none_key3864( FOLLOW_REGULAR_ID_in_none_key3864_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_before_key3887_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_before_key3887( FOLLOW_REGULAR_ID_in_before_key3887_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_referencing_key3911_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_referencing_key3911( FOLLOW_REGULAR_ID_in_referencing_key3911_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_logon_key3934_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_logon_key3934( FOLLOW_REGULAR_ID_in_logon_key3934_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_after_key3956_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_after_key3956( FOLLOW_REGULAR_ID_in_after_key3956_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_schema_key3979_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_schema_key3979( FOLLOW_REGULAR_ID_in_schema_key3979_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_GRANT_in_grant_key3999_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_GRANT_in_grant_key3999( FOLLOW_SQL92_RESERVED_GRANT_in_grant_key3999_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_truncate_key4022_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_truncate_key4022( FOLLOW_REGULAR_ID_in_truncate_key4022_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_startup_key4045_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_startup_key4045( FOLLOW_REGULAR_ID_in_startup_key4045_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_statistics_key4068_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_statistics_key4068( FOLLOW_REGULAR_ID_in_statistics_key4068_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_noaudit_key4091_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_noaudit_key4091( FOLLOW_REGULAR_ID_in_noaudit_key4091_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_suspend_key4114_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_suspend_key4114( FOLLOW_REGULAR_ID_in_suspend_key4114_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_audit_key4137_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_audit_key4137( FOLLOW_REGULAR_ID_in_audit_key4137_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_disassociate_key4160_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_disassociate_key4160( FOLLOW_REGULAR_ID_in_disassociate_key4160_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_shutdown_key4184_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_shutdown_key4184( FOLLOW_REGULAR_ID_in_shutdown_key4184_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_compound_key4207_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_compound_key4207( FOLLOW_REGULAR_ID_in_compound_key4207_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_servererror_key4230_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_servererror_key4230( FOLLOW_REGULAR_ID_in_servererror_key4230_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_parent_key4253_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_parent_key4253( FOLLOW_REGULAR_ID_in_parent_key4253_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_follows_key4276_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_follows_key4276( FOLLOW_REGULAR_ID_in_follows_key4276_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nested_key4299_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nested_key4299( FOLLOW_REGULAR_ID_in_nested_key4299_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_old_key4322_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_old_key4322( FOLLOW_REGULAR_ID_in_old_key4322_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_statement_key4345_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_statement_key4345( FOLLOW_REGULAR_ID_in_statement_key4345_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_db_role_change_key4368_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_db_role_change_key4368( FOLLOW_REGULAR_ID_in_db_role_change_key4368_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_each_key4391_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_each_key4391( FOLLOW_REGULAR_ID_in_each_key4391_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_logoff_key4414_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_logoff_key4414( FOLLOW_REGULAR_ID_in_logoff_key4414_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_analyze_key4437_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_analyze_key4437( FOLLOW_REGULAR_ID_in_analyze_key4437_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_instead_key4460_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_instead_key4460( FOLLOW_REGULAR_ID_in_instead_key4460_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_associate_key4483_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_associate_key4483( FOLLOW_REGULAR_ID_in_associate_key4483_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_new_key4506_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_new_key4506( FOLLOW_REGULAR_ID_in_new_key4506_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_REVOKE_in_revoke_key4526_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_REVOKE_in_revoke_key4526( FOLLOW_SQL92_RESERVED_REVOKE_in_revoke_key4526_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rename_key4549_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rename_key4549( FOLLOW_REGULAR_ID_in_rename_key4549_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_customdatum_key4573_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_customdatum_key4573( FOLLOW_REGULAR_ID_in_customdatum_key4573_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_oradata_key4596_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_oradata_key4596( FOLLOW_REGULAR_ID_in_oradata_key4596_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_constructor_key4619_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_constructor_key4619( FOLLOW_REGULAR_ID_in_constructor_key4619_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sqldata_key4642_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sqldata_key4642( FOLLOW_REGULAR_ID_in_sqldata_key4642_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_member_key4665_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_member_key4665( FOLLOW_REGULAR_ID_in_member_key4665_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_self_key4688_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_self_key4688( FOLLOW_REGULAR_ID_in_self_key4688_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_object_key4711_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_object_key4711( FOLLOW_REGULAR_ID_in_object_key4711_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_variable_key4734_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_variable_key4734( FOLLOW_REGULAR_ID_in_variable_key4734_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_instantiable_key4757_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_instantiable_key4757( FOLLOW_REGULAR_ID_in_instantiable_key4757_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_final_key4780_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_final_key4780( FOLLOW_REGULAR_ID_in_final_key4780_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_static_key4803_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_static_key4803( FOLLOW_REGULAR_ID_in_static_key4803_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_oid_key4826_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_oid_key4826( FOLLOW_REGULAR_ID_in_oid_key4826_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_result_key4849_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_result_key4849( FOLLOW_REGULAR_ID_in_result_key4849_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_under_key4872_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_under_key4872( FOLLOW_REGULAR_ID_in_under_key4872_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_map_key4895_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_map_key4895( FOLLOW_REGULAR_ID_in_map_key4895_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_overriding_key4918_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_overriding_key4918( FOLLOW_REGULAR_ID_in_overriding_key4918_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_add_key4941_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_add_key4941( FOLLOW_REGULAR_ID_in_add_key4941_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_modify_key4964_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_modify_key4964( FOLLOW_REGULAR_ID_in_modify_key4964_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_including_key4987_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_including_key4987( FOLLOW_REGULAR_ID_in_including_key4987_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_substitutable_key5010_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_substitutable_key5010( FOLLOW_REGULAR_ID_in_substitutable_key5010_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_attribute_key5033_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_attribute_key5033( FOLLOW_REGULAR_ID_in_attribute_key5033_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cascade_key5056_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cascade_key5056( FOLLOW_REGULAR_ID_in_cascade_key5056_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_data_key5080_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_data_key5080( FOLLOW_REGULAR_ID_in_data_key5080_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_invalidate_key5102_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_invalidate_key5102( FOLLOW_REGULAR_ID_in_invalidate_key5102_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_element_key5125_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_element_key5125( FOLLOW_REGULAR_ID_in_element_key5125_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_first_key5148_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_first_key5148( FOLLOW_REGULAR_ID_in_first_key5148_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_CHECK_in_check_key5168_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_CHECK_in_check_key5168( FOLLOW_SQL92_RESERVED_CHECK_in_check_key5168_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_OPTION_in_option_key5188_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_OPTION_in_option_key5188( FOLLOW_SQL92_RESERVED_OPTION_in_option_key5188_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nocycle_key5211_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nocycle_key5211( FOLLOW_REGULAR_ID_in_nocycle_key5211_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_locked_key5234_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_locked_key5234( FOLLOW_REGULAR_ID_in_locked_key5234_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_block_key5257_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_block_key5257( FOLLOW_REGULAR_ID_in_block_key5257_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xml_key5280_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xml_key5280( FOLLOW_REGULAR_ID_in_xml_key5280_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_PIVOT_in_pivot_key5301_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_PIVOT_in_pivot_key5301( FOLLOW_PLSQL_NON_RESERVED_PIVOT_in_pivot_key5301_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_PRIOR_in_prior_key5321_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_PRIOR_in_prior_key5321( FOLLOW_SQL92_RESERVED_PRIOR_in_prior_key5321_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sequential_key5344_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sequential_key5344( FOLLOW_REGULAR_ID_in_sequential_key5344_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_single_key5367_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_single_key5367( FOLLOW_REGULAR_ID_in_single_key5367_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_skip_key5390_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_skip_key5390( FOLLOW_REGULAR_ID_in_skip_key5390_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_MODEL_in_model_key5419_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_MODEL_in_model_key5419( FOLLOW_PLSQL_NON_RESERVED_MODEL_in_model_key5419_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_updated_key5442_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_updated_key5442( FOLLOW_REGULAR_ID_in_updated_key5442_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_increment_key5465_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_increment_key5465( FOLLOW_REGULAR_ID_in_increment_key5465_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_exclude_key5488_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_exclude_key5488( FOLLOW_REGULAR_ID_in_exclude_key5488_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_reference_key5511_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_reference_key5511( FOLLOW_REGULAR_ID_in_reference_key5511_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sets_key5534_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sets_key5534( FOLLOW_REGULAR_ID_in_sets_key5534_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_until_key5557_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_until_key5557( FOLLOW_REGULAR_ID_in_until_key5557_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_seed_key5580_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_seed_key5580( FOLLOW_REGULAR_ID_in_seed_key5580_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_maxvalue_key5603_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_maxvalue_key5603( FOLLOW_REGULAR_ID_in_maxvalue_key5603_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_siblings_key5626_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_siblings_key5626( FOLLOW_REGULAR_ID_in_siblings_key5626_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cube_key5649_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cube_key5649( FOLLOW_REGULAR_ID_in_cube_key5649_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nulls_key5672_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nulls_key5672( FOLLOW_REGULAR_ID_in_nulls_key5672_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dimension_key5695_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dimension_key5695( FOLLOW_REGULAR_ID_in_dimension_key5695_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_scn_key5718_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_scn_key5718( FOLLOW_REGULAR_ID_in_scn_key5718_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_snapshot_key5741_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_snapshot_key5741( FOLLOW_REGULAR_ID_in_snapshot_key5741_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_decrement_key5764_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_decrement_key5764( FOLLOW_REGULAR_ID_in_decrement_key5764_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_UNPIVOT_in_unpivot_key5784_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_UNPIVOT_in_unpivot_key5784( FOLLOW_PLSQL_NON_RESERVED_UNPIVOT_in_unpivot_key5784_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_keep_key5807_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_keep_key5807( FOLLOW_REGULAR_ID_in_keep_key5807_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_measures_key5830_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_measures_key5830( FOLLOW_REGULAR_ID_in_measures_key5830_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rows_key5853_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rows_key5853( FOLLOW_REGULAR_ID_in_rows_key5853_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sample_key5876_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sample_key5876( FOLLOW_REGULAR_ID_in_sample_key5876_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_upsert_key5899_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_upsert_key5899( FOLLOW_REGULAR_ID_in_upsert_key5899_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_versions_key5922_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_versions_key5922( FOLLOW_REGULAR_ID_in_versions_key5922_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rules_key5945_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rules_key5945( FOLLOW_REGULAR_ID_in_rules_key5945_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_iterate_key5968_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_iterate_key5968( FOLLOW_REGULAR_ID_in_iterate_key5968_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_minvalue_key5991_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_minvalue_key5991( FOLLOW_REGULAR_ID_in_minvalue_key5991_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rollup_key6014_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rollup_key6014( FOLLOW_REGULAR_ID_in_rollup_key6014_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nav_key6037_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nav_key6037( FOLLOW_REGULAR_ID_in_nav_key6037_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_automatic_key6060_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_automatic_key6060( FOLLOW_REGULAR_ID_in_automatic_key6060_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_last_key6083_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_last_key6083( FOLLOW_REGULAR_ID_in_last_key6083_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_main_key6106_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_main_key6106( FOLLOW_REGULAR_ID_in_main_key6106_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_grouping_key6129_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_grouping_key6129( FOLLOW_REGULAR_ID_in_grouping_key6129_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_include_key6152_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_include_key6152( FOLLOW_REGULAR_ID_in_include_key6152_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ignore_key6175_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ignore_key6175( FOLLOW_REGULAR_ID_in_ignore_key6175_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_respect_key6198_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_respect_key6198( FOLLOW_REGULAR_ID_in_respect_key6198_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_UNIQUE_in_unique_key6218_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_UNIQUE_in_unique_key6218( FOLLOW_SQL92_RESERVED_UNIQUE_in_unique_key6218_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_submultiset_key6241_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_submultiset_key6241( FOLLOW_REGULAR_ID_in_submultiset_key6241_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_at_key6264_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_at_key6264( FOLLOW_REGULAR_ID_in_at_key6264_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_a_key6288_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_a_key6288( FOLLOW_REGULAR_ID_in_a_key6288_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_empty_key6311_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_empty_key6311( FOLLOW_REGULAR_ID_in_empty_key6311_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_likec_key6334_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_likec_key6334( FOLLOW_REGULAR_ID_in_likec_key6334_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nan_key6357_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nan_key6357( FOLLOW_REGULAR_ID_in_nan_key6357_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_infinite_key6380_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_infinite_key6380( FOLLOW_REGULAR_ID_in_infinite_key6380_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_like2_key6403_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_like2_key6403( FOLLOW_REGULAR_ID_in_like2_key6403_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_like4_key6426_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_like4_key6426( FOLLOW_REGULAR_ID_in_like4_key6426_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_present_key6449_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_present_key6449( FOLLOW_REGULAR_ID_in_present_key6449_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dbtimezone_key6472_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dbtimezone_key6472( FOLLOW_REGULAR_ID_in_dbtimezone_key6472_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sessiontimezone_key6495_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sessiontimezone_key6495( FOLLOW_REGULAR_ID_in_sessiontimezone_key6495_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nchar_cs_key6518_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nchar_cs_key6518( FOLLOW_REGULAR_ID_in_nchar_cs_key6518_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_decompose_key6541_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_decompose_key6541( FOLLOW_REGULAR_ID_in_decompose_key6541_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_following_key6564_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_following_key6564( FOLLOW_REGULAR_ID_in_following_key6564_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_first_value_key6587_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_first_value_key6587( FOLLOW_REGULAR_ID_in_first_value_key6587_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_preceding_key6610_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_preceding_key6610( FOLLOW_REGULAR_ID_in_preceding_key6610_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_within_key6633_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_within_key6633( FOLLOW_REGULAR_ID_in_within_key6633_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_canonical_key6656_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_canonical_key6656( FOLLOW_REGULAR_ID_in_canonical_key6656_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_compatibility_key6679_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_compatibility_key6679( FOLLOW_REGULAR_ID_in_compatibility_key6679_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_over_key6702_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_over_key6702( FOLLOW_REGULAR_ID_in_over_key6702_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_multiset_key6725_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_multiset_key6725( FOLLOW_REGULAR_ID_in_multiset_key6725_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_CONNECT_BY_ROOT_in_connect_by_root_key6745_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_CONNECT_BY_ROOT_in_connect_by_root_key6745( FOLLOW_PLSQL_NON_RESERVED_CONNECT_BY_ROOT_in_connect_by_root_key6745_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_last_value_key6768_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_last_value_key6768( FOLLOW_REGULAR_ID_in_last_value_key6768_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_CURRENT_in_current_key6788_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_CURRENT_in_current_key6788( FOLLOW_SQL92_RESERVED_CURRENT_in_current_key6788_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_unbounded_key6811_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_unbounded_key6811( FOLLOW_REGULAR_ID_in_unbounded_key6811_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dense_rank_key6834_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dense_rank_key6834( FOLLOW_REGULAR_ID_in_dense_rank_key6834_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cost_key6857_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cost_key6857( FOLLOW_REGULAR_ID_in_cost_key6857_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_char_cs_key6880_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_char_cs_key6880( FOLLOW_REGULAR_ID_in_char_cs_key6880_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_auto_key6903_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_auto_key6903( FOLLOW_REGULAR_ID_in_auto_key6903_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_treat_key6926_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_treat_key6926( FOLLOW_REGULAR_ID_in_treat_key6926_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_content_key6949_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_content_key6949( FOLLOW_REGULAR_ID_in_content_key6949_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlparse_key6972_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlparse_key6972( FOLLOW_REGULAR_ID_in_xmlparse_key6972_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlelement_key6995_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlelement_key6995( FOLLOW_REGULAR_ID_in_xmlelement_key6995_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_entityescaping_key7018_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_entityescaping_key7018( FOLLOW_REGULAR_ID_in_entityescaping_key7018_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_standalone_key7041_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_standalone_key7041( FOLLOW_REGULAR_ID_in_standalone_key7041_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_wellformed_key7064_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_wellformed_key7064( FOLLOW_REGULAR_ID_in_wellformed_key7064_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlexists_key7087_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlexists_key7087( FOLLOW_REGULAR_ID_in_xmlexists_key7087_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_version_key7110_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_version_key7110( FOLLOW_REGULAR_ID_in_version_key7110_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlcast_key7133_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlcast_key7133( FOLLOW_REGULAR_ID_in_xmlcast_key7133_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_yes_key7156_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_yes_key7156( FOLLOW_REGULAR_ID_in_yes_key7156_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_no_key7179_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_no_key7179( FOLLOW_REGULAR_ID_in_no_key7179_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_evalname_key7202_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_evalname_key7202( FOLLOW_REGULAR_ID_in_evalname_key7202_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlpi_key7225_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlpi_key7225( FOLLOW_REGULAR_ID_in_xmlpi_key7225_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlcolattval_key7248_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlcolattval_key7248( FOLLOW_REGULAR_ID_in_xmlcolattval_key7248_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_document_key7271_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_document_key7271( FOLLOW_REGULAR_ID_in_document_key7271_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlforest_key7294_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlforest_key7294( FOLLOW_REGULAR_ID_in_xmlforest_key7294_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_passing_key7317_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_passing_key7317( FOLLOW_REGULAR_ID_in_passing_key7317_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_columns_key7341_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_columns_key7341( FOLLOW_REGULAR_ID_in_columns_key7341_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_indent_key7364_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_indent_key7364( FOLLOW_REGULAR_ID_in_indent_key7364_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_hide_key7387_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_hide_key7387( FOLLOW_REGULAR_ID_in_hide_key7387_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlagg_key7410_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlagg_key7410( FOLLOW_REGULAR_ID_in_xmlagg_key7410_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_path_key7433_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_path_key7433( FOLLOW_REGULAR_ID_in_path_key7433_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlnamespaces_key7456_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlnamespaces_key7456( FOLLOW_REGULAR_ID_in_xmlnamespaces_key7456_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_SIZE_in_size_key7476_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_SIZE_in_size_key7476( FOLLOW_SQL92_RESERVED_SIZE_in_size_key7476_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_noschemacheck_key7499_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_noschemacheck_key7499( FOLLOW_REGULAR_ID_in_noschemacheck_key7499_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_noentityescaping_key7522_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_noentityescaping_key7522( FOLLOW_REGULAR_ID_in_noentityescaping_key7522_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlquery_key7545_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlquery_key7545( FOLLOW_REGULAR_ID_in_xmlquery_key7545_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmltable_key7568_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmltable_key7568( FOLLOW_REGULAR_ID_in_xmltable_key7568_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlroot_key7591_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlroot_key7591( FOLLOW_REGULAR_ID_in_xmlroot_key7591_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_schemacheck_key7614_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_schemacheck_key7614( FOLLOW_REGULAR_ID_in_schemacheck_key7614_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlattributes_key7637_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlattributes_key7637( FOLLOW_REGULAR_ID_in_xmlattributes_key7637_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_encoding_key7660_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_encoding_key7660( FOLLOW_REGULAR_ID_in_encoding_key7660_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_show_key7683_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_show_key7683( FOLLOW_REGULAR_ID_in_show_key7683_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_xmlserialize_key7706_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_xmlserialize_key7706( FOLLOW_REGULAR_ID_in_xmlserialize_key7706_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ordinality_key7729_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ordinality_key7729( FOLLOW_REGULAR_ID_in_ordinality_key7729_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_defaults_key7752_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_defaults_key7752( FOLLOW_REGULAR_ID_in_defaults_key7752_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sqlerror_key7774_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sqlerror_key7774( FOLLOW_REGULAR_ID_in_sqlerror_key7774_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_oserror_key7798_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_oserror_key7798( FOLLOW_REGULAR_ID_in_oserror_key7798_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_success_key7821_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_success_key7821( FOLLOW_REGULAR_ID_in_success_key7821_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_warning_key7844_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_warning_key7844( FOLLOW_REGULAR_ID_in_warning_key7844_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_failure_key7867_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_failure_key7867( FOLLOW_REGULAR_ID_in_failure_key7867_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_INSERT_in_insert_key7888_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_INSERT_in_insert_key7888( FOLLOW_SQL92_RESERVED_INSERT_in_insert_key7888_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ORDER_in_order_key7908_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ORDER_in_order_key7908( FOLLOW_SQL92_RESERVED_ORDER_in_order_key7908_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_MINUS_in_minus_key7928_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_MINUS_in_minus_key7928( FOLLOW_PLSQL_RESERVED_MINUS_in_minus_key7928_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_row_key7950_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_row_key7950( FOLLOW_REGULAR_ID_in_row_key7950_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_mod_key7972_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_mod_key7972( FOLLOW_REGULAR_ID_in_mod_key7972_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_raw_key7995_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_raw_key7995( FOLLOW_REGULAR_ID_in_raw_key7995_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_power_key8017_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_power_key8017( FOLLOW_REGULAR_ID_in_power_key8017_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_LOCK_in_lock_key8037_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_LOCK_in_lock_key8037( FOLLOW_PLSQL_RESERVED_LOCK_in_lock_key8037_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_EXISTS_in_exists_key8057_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_EXISTS_in_exists_key8057( FOLLOW_SQL92_RESERVED_EXISTS_in_exists_key8057_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_HAVING_in_having_key8077_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_HAVING_in_having_key8077( FOLLOW_SQL92_RESERVED_HAVING_in_having_key8077_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ANY_in_any_key8097_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ANY_in_any_key8097( FOLLOW_SQL92_RESERVED_ANY_in_any_key8097_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_WITH_in_with_key8117_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_WITH_in_with_key8117( FOLLOW_SQL92_RESERVED_WITH_in_with_key8117_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_transaction_key8140_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_transaction_key8140( FOLLOW_REGULAR_ID_in_transaction_key8140_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rawtohex_key8162_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rawtohex_key8162( FOLLOW_REGULAR_ID_in_rawtohex_key8162_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_number_key8185_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_number_key8185( FOLLOW_REGULAR_ID_in_number_key8185_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nocopy_key8208_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nocopy_key8208( FOLLOW_REGULAR_ID_in_nocopy_key8208_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_TO_in_to_key8228_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_TO_in_to_key8228( FOLLOW_SQL92_RESERVED_TO_in_to_key8228_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_abs_key8250_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_abs_key8250( FOLLOW_REGULAR_ID_in_abs_key8250_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rollback_key8273_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rollback_key8273( FOLLOW_REGULAR_ID_in_rollback_key8273_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_SHARE_in_share_key8293_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_SHARE_in_share_key8293( FOLLOW_PLSQL_RESERVED_SHARE_in_share_key8293_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_greatest_key8315_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_greatest_key8315( FOLLOW_REGULAR_ID_in_greatest_key8315_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_vsize_key8337_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_vsize_key8337( FOLLOW_REGULAR_ID_in_vsize_key8337_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_EXCLUSIVE_in_exclusive_key8357_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_EXCLUSIVE_in_exclusive_key8357( FOLLOW_PLSQL_RESERVED_EXCLUSIVE_in_exclusive_key8357_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_varchar2_key8380_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_varchar2_key8380( FOLLOW_REGULAR_ID_in_varchar2_key8380_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rowidtochar_key8402_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rowidtochar_key8402( FOLLOW_REGULAR_ID_in_rowidtochar_key8402_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_open_key8425_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_open_key8425( FOLLOW_REGULAR_ID_in_open_key8425_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_comment_key8448_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_comment_key8448( FOLLOW_REGULAR_ID_in_comment_key8448_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sqrt_key8470_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sqrt_key8470( FOLLOW_REGULAR_ID_in_sqrt_key8470_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_instr_key8492_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_instr_key8492( FOLLOW_REGULAR_ID_in_instr_key8492_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_NOWAIT_in_nowait_key8512_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_NOWAIT_in_nowait_key8512( FOLLOW_PLSQL_RESERVED_NOWAIT_in_nowait_key8512_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_lpad_key8534_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_lpad_key8534( FOLLOW_REGULAR_ID_in_lpad_key8534_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_boolean_key8557_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_boolean_key8557( FOLLOW_REGULAR_ID_in_boolean_key8557_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rpad_key8579_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rpad_key8579( FOLLOW_REGULAR_ID_in_rpad_key8579_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_savepoint_key8602_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_savepoint_key8602( FOLLOW_REGULAR_ID_in_savepoint_key8602_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_decode_key8624_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_decode_key8624( FOLLOW_REGULAR_ID_in_decode_key8624_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_reverse_key8646_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_reverse_key8646( FOLLOW_REGULAR_ID_in_reverse_key8646_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_least_key8668_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_least_key8668( FOLLOW_REGULAR_ID_in_least_key8668_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nvl_key8690_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nvl_key8690( FOLLOW_REGULAR_ID_in_nvl_key8690_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_variance_key8712_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_variance_key8712( FOLLOW_REGULAR_ID_in_variance_key8712_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_START_in_start_key8732_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_START_in_start_key8732( FOLLOW_PLSQL_RESERVED_START_in_start_key8732_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DESC_in_desc_key8752_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DESC_in_desc_key8752( FOLLOW_SQL92_RESERVED_DESC_in_desc_key8752_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_concat_key8774_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_concat_key8774( FOLLOW_REGULAR_ID_in_concat_key8774_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dump_key8796_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dump_key8796( FOLLOW_REGULAR_ID_in_dump_key8796_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_soundex_key8818_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_soundex_key8818( FOLLOW_REGULAR_ID_in_soundex_key8818_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_positive_key8841_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_positive_key8841( FOLLOW_REGULAR_ID_in_positive_key8841_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_UNION_in_union_key8861_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_UNION_in_union_key8861( FOLLOW_SQL92_RESERVED_UNION_in_union_key8861_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ascii_key8883_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ascii_key8883( FOLLOW_REGULAR_ID_in_ascii_key8883_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_CONNECT_in_connect_key8903_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_CONNECT_in_connect_key8903( FOLLOW_SQL92_RESERVED_CONNECT_in_connect_key8903_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ASC_in_asc_key8923_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ASC_in_asc_key8923( FOLLOW_SQL92_RESERVED_ASC_in_asc_key8923_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_hextoraw_key8945_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_hextoraw_key8945( FOLLOW_REGULAR_ID_in_hextoraw_key8945_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_to_date_key8967_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_to_date_key8967( FOLLOW_REGULAR_ID_in_to_date_key8967_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_floor_key8989_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_floor_key8989( FOLLOW_REGULAR_ID_in_floor_key8989_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sign_key9011_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sign_key9011( FOLLOW_REGULAR_ID_in_sign_key9011_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_UPDATE_in_update_key9031_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_UPDATE_in_update_key9031( FOLLOW_SQL92_RESERVED_UPDATE_in_update_key9031_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_trunc_key9053_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_trunc_key9053( FOLLOW_REGULAR_ID_in_trunc_key9053_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_rtrim_key9075_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_rtrim_key9075( FOLLOW_REGULAR_ID_in_rtrim_key9075_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_close_key9098_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_close_key9098( FOLLOW_REGULAR_ID_in_close_key9098_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_to_char_key9120_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_to_char_key9120( FOLLOW_REGULAR_ID_in_to_char_key9120_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ltrim_key9142_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ltrim_key9142( FOLLOW_REGULAR_ID_in_ltrim_key9142_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_RESERVED_MODE_in_mode_key9162_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_RESERVED_MODE_in_mode_key9162( FOLLOW_PLSQL_RESERVED_MODE_in_mode_key9162_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_uid_key9184_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_uid_key9184( FOLLOW_REGULAR_ID_in_uid_key9184_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_chr_key9206_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_chr_key9206( FOLLOW_REGULAR_ID_in_chr_key9206_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_INTERSECT_in_intersect_key9226_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_INTERSECT_in_intersect_key9226( FOLLOW_SQL92_RESERVED_INTERSECT_in_intersect_key9226_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_chartorowid_key9248_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_chartorowid_key9248( FOLLOW_REGULAR_ID_in_chartorowid_key9248_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_mlslabel_key9271_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_mlslabel_key9271( FOLLOW_REGULAR_ID_in_mlslabel_key9271_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_userenv_key9293_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_userenv_key9293( FOLLOW_REGULAR_ID_in_userenv_key9293_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_stddev_key9315_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_stddev_key9315( FOLLOW_REGULAR_ID_in_stddev_key9315_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_length_key9337_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_length_key9337( FOLLOW_REGULAR_ID_in_length_key9337_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_FETCH_in_fetch_key9357_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_FETCH_in_fetch_key9357( FOLLOW_SQL92_RESERVED_FETCH_in_fetch_key9357_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_GROUP_in_group_key9377_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_GROUP_in_group_key9377( FOLLOW_SQL92_RESERVED_GROUP_in_group_key9377_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sysdate_key9399_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sysdate_key9399( FOLLOW_REGULAR_ID_in_sysdate_key9399_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_binary_integer_key9422_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_binary_integer_key9422( FOLLOW_REGULAR_ID_in_binary_integer_key9422_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_to_number_key9444_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_to_number_key9444( FOLLOW_REGULAR_ID_in_to_number_key9444_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_substr_key9466_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_substr_key9466( FOLLOW_REGULAR_ID_in_substr_key9466_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_ceil_key9488_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_ceil_key9488( FOLLOW_REGULAR_ID_in_ceil_key9488_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_initcap_key9510_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_initcap_key9510( FOLLOW_REGULAR_ID_in_initcap_key9510_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_round_key9532_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_round_key9532( FOLLOW_REGULAR_ID_in_round_key9532_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_long_key9555_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_long_key9555( FOLLOW_REGULAR_ID_in_long_key9555_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_read_key9578_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_read_key9578( FOLLOW_REGULAR_ID_in_read_key9578_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_only_key9600_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_only_key9600( FOLLOW_REGULAR_ID_in_only_key9600_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_set_key9623_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_set_key9623( FOLLOW_REGULAR_ID_in_set_key9623_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nullif_key9645_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nullif_key9645( FOLLOW_REGULAR_ID_in_nullif_key9645_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_coalesce_key9667_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_coalesce_key9667( FOLLOW_REGULAR_ID_in_coalesce_key9667_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_count_key9689_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_count_key9689( FOLLOW_REGULAR_ID_in_count_key9689_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_avg_key9710_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_avg_key9710( FOLLOW_REGULAR_ID_in_avg_key9710_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_max_key9731_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_max_key9731( FOLLOW_REGULAR_ID_in_max_key9731_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_min_key9752_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_min_key9752( FOLLOW_REGULAR_ID_in_min_key9752_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sum_key9773_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sum_key9773( FOLLOW_REGULAR_ID_in_sum_key9773_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_unknown_key9795_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_unknown_key9795( FOLLOW_REGULAR_ID_in_unknown_key9795_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_escape_key9817_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_escape_key9817( FOLLOW_REGULAR_ID_in_escape_key9817_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_some_key9839_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_some_key9839( FOLLOW_REGULAR_ID_in_some_key9839_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_match_key9861_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_match_key9861( FOLLOW_REGULAR_ID_in_match_key9861_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cast_key9883_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cast_key9883( FOLLOW_REGULAR_ID_in_cast_key9883_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_full_key9906_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_full_key9906( FOLLOW_REGULAR_ID_in_full_key9906_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_partial_key9928_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_partial_key9928( FOLLOW_REGULAR_ID_in_partial_key9928_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_character_key9951_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_character_key9951( FOLLOW_REGULAR_ID_in_character_key9951_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_except_key9973_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_except_key9973( FOLLOW_REGULAR_ID_in_except_key9973_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_char_key9996_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_char_key9996( FOLLOW_REGULAR_ID_in_char_key9996_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_varying_key10019_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_varying_key10019( FOLLOW_REGULAR_ID_in_varying_key10019_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_varchar_key10042_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_varchar_key10042( FOLLOW_REGULAR_ID_in_varchar_key10042_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_national_key10064_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_national_key10064( FOLLOW_REGULAR_ID_in_national_key10064_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nchar_key10086_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nchar_key10086( FOLLOW_REGULAR_ID_in_nchar_key10086_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_bit_key10107_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_bit_key10107( FOLLOW_REGULAR_ID_in_bit_key10107_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_float_key10129_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_float_key10129( FOLLOW_REGULAR_ID_in_float_key10129_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_real_key10156_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_real_key10156( FOLLOW_REGULAR_ID_in_real_key10156_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_double_key10179_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_double_key10179( FOLLOW_REGULAR_ID_in_double_key10179_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_precision_key10201_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_precision_key10201( FOLLOW_REGULAR_ID_in_precision_key10201_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_interval_key10224_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_interval_key10224( FOLLOW_REGULAR_ID_in_interval_key10224_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_time_key10246_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_time_key10246( FOLLOW_REGULAR_ID_in_time_key10246_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_zone_key10269_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_zone_key10269( FOLLOW_REGULAR_ID_in_zone_key10269_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timestamp_key10291_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timestamp_key10291( FOLLOW_REGULAR_ID_in_timestamp_key10291_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DATE_in_date_key10311_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DATE_in_date_key10311( FOLLOW_SQL92_RESERVED_DATE_in_date_key10311_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_numeric_key10334_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_numeric_key10334( FOLLOW_REGULAR_ID_in_numeric_key10334_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_decimal_key10357_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_decimal_key10357( FOLLOW_REGULAR_ID_in_decimal_key10357_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_dec_key10380_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_dec_key10380( FOLLOW_REGULAR_ID_in_dec_key10380_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_integer_key10403_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_integer_key10403( FOLLOW_REGULAR_ID_in_integer_key10403_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_int_key10426_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_int_key10426( FOLLOW_REGULAR_ID_in_int_key10426_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_smallint_key10449_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_smallint_key10449( FOLLOW_REGULAR_ID_in_smallint_key10449_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_corresponding_key10471_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_corresponding_key10471( FOLLOW_REGULAR_ID_in_corresponding_key10471_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cross_key10494_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cross_key10494( FOLLOW_REGULAR_ID_in_cross_key10494_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_join_key10517_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_join_key10517( FOLLOW_REGULAR_ID_in_join_key10517_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_left_key10540_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_left_key10540( FOLLOW_REGULAR_ID_in_left_key10540_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_right_key10563_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_right_key10563( FOLLOW_REGULAR_ID_in_right_key10563_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_inner_key10586_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_inner_key10586( FOLLOW_REGULAR_ID_in_inner_key10586_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_natural_key10609_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_natural_key10609( FOLLOW_REGULAR_ID_in_natural_key10609_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_outer_key10632_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_outer_key10632( FOLLOW_REGULAR_ID_in_outer_key10632_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_PLSQL_NON_RESERVED_USING_in_using_key10652_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_PLSQL_NON_RESERVED_USING_in_using_key10652( FOLLOW_PLSQL_NON_RESERVED_USING_in_using_key10652_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_indicator_key10674_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_indicator_key10674( FOLLOW_REGULAR_ID_in_indicator_key10674_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_user_key10696_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_user_key10696( FOLLOW_REGULAR_ID_in_user_key10696_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_current_user_key10718_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_current_user_key10718( FOLLOW_REGULAR_ID_in_current_user_key10718_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_session_user_key10740_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_session_user_key10740( FOLLOW_REGULAR_ID_in_session_user_key10740_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_system_user_key10762_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_system_user_key10762( FOLLOW_REGULAR_ID_in_system_user_key10762_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_value_key10784_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_value_key10784( FOLLOW_REGULAR_ID_in_value_key10784_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_substring_key10807_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_substring_key10807( FOLLOW_REGULAR_ID_in_substring_key10807_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_upper_key10829_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_upper_key10829( FOLLOW_REGULAR_ID_in_upper_key10829_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_lower_key10851_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_lower_key10851( FOLLOW_REGULAR_ID_in_lower_key10851_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_convert_key10873_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_convert_key10873( FOLLOW_REGULAR_ID_in_convert_key10873_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_translate_key10895_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_translate_key10895( FOLLOW_REGULAR_ID_in_translate_key10895_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_trim_key10917_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_trim_key10917( FOLLOW_REGULAR_ID_in_trim_key10917_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_leading_key10939_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_leading_key10939( FOLLOW_REGULAR_ID_in_leading_key10939_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_trailing_key10961_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_trailing_key10961( FOLLOW_REGULAR_ID_in_trailing_key10961_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_both_key10983_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_both_key10983( FOLLOW_REGULAR_ID_in_both_key10983_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_collate_key11005_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_collate_key11005( FOLLOW_REGULAR_ID_in_collate_key11005_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_position_key11027_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_position_key11027( FOLLOW_REGULAR_ID_in_position_key11027_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_extract_key11049_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_extract_key11049( FOLLOW_REGULAR_ID_in_extract_key11049_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_second_key11071_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_second_key11071( FOLLOW_REGULAR_ID_in_second_key11071_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timezone_hour_key11093_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timezone_hour_key11093( FOLLOW_REGULAR_ID_in_timezone_hour_key11093_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_timezone_minute_key11115_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_timezone_minute_key11115( FOLLOW_REGULAR_ID_in_timezone_minute_key11115_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_char_length_key11137_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_char_length_key11137( FOLLOW_REGULAR_ID_in_char_length_key11137_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_octet_length_key11159_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_octet_length_key11159( FOLLOW_REGULAR_ID_in_octet_length_key11159_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_character_length_key11181_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_character_length_key11181( FOLLOW_REGULAR_ID_in_character_length_key11181_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_bit_length_key11203_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_bit_length_key11203( FOLLOW_REGULAR_ID_in_bit_length_key11203_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_local_key11225_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_local_key11225( FOLLOW_REGULAR_ID_in_local_key11225_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_current_timestamp_key11247_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_current_timestamp_key11247( FOLLOW_REGULAR_ID_in_current_timestamp_key11247_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_current_date_key11269_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_current_date_key11269( FOLLOW_REGULAR_ID_in_current_date_key11269_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_current_time_key11291_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_current_time_key11291( FOLLOW_REGULAR_ID_in_current_time_key11291_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_module_key11313_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_module_key11313( FOLLOW_REGULAR_ID_in_module_key11313_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_global_key11335_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_global_key11335( FOLLOW_REGULAR_ID_in_global_key11335_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_year_key11358_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_year_key11358( FOLLOW_REGULAR_ID_in_year_key11358_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_month_key11380_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_month_key11380( FOLLOW_REGULAR_ID_in_month_key11380_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_day_key11403_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_day_key11403( FOLLOW_REGULAR_ID_in_day_key11403_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_hour_key11425_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_hour_key11425( FOLLOW_REGULAR_ID_in_hour_key11425_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_minute_key11447_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_minute_key11447( FOLLOW_REGULAR_ID_in_minute_key11447_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_whenever_key11469_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_whenever_key11469( FOLLOW_REGULAR_ID_in_whenever_key11469_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_IS_in_is_key11489_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_IS_in_is_key11489( FOLLOW_SQL92_RESERVED_IS_in_is_key11489_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ELSE_in_else_key11509_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ELSE_in_else_key11509( FOLLOW_SQL92_RESERVED_ELSE_in_else_key11509_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_TABLE_in_table_key11529_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_TABLE_in_table_key11529( FOLLOW_SQL92_RESERVED_TABLE_in_table_key11529_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_THE_in_the_key11549_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_THE_in_the_key11549( FOLLOW_SQL92_RESERVED_THE_in_the_key11549_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_THEN_in_then_key11569_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_THEN_in_then_key11569( FOLLOW_SQL92_RESERVED_THEN_in_then_key11569_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_END_in_end_key11589_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_END_in_end_key11589( FOLLOW_SQL92_RESERVED_END_in_end_key11589_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ALL_in_all_key11609_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ALL_in_all_key11609( FOLLOW_SQL92_RESERVED_ALL_in_all_key11609_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_ON_in_on_key11629_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_ON_in_on_key11629( FOLLOW_SQL92_RESERVED_ON_in_on_key11629_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_OR_in_or_key11649_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_OR_in_or_key11649( FOLLOW_SQL92_RESERVED_OR_in_or_key11649_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_AND_in_and_key11669_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_AND_in_and_key11669( FOLLOW_SQL92_RESERVED_AND_in_and_key11669_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_NOT_in_not_key11689_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_NOT_in_not_key11689( FOLLOW_SQL92_RESERVED_NOT_in_not_key11689_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_TRUE_in_true_key11709_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_TRUE_in_true_key11709( FOLLOW_SQL92_RESERVED_TRUE_in_true_key11709_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_FALSE_in_false_key11729_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_FALSE_in_false_key11729( FOLLOW_SQL92_RESERVED_FALSE_in_false_key11729_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DEFAULT_in_default_key11749_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DEFAULT_in_default_key11749( FOLLOW_SQL92_RESERVED_DEFAULT_in_default_key11749_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DISTINCT_in_distinct_key11769_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DISTINCT_in_distinct_key11769( FOLLOW_SQL92_RESERVED_DISTINCT_in_distinct_key11769_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_INTO_in_into_key11789_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_INTO_in_into_key11789( FOLLOW_SQL92_RESERVED_INTO_in_into_key11789_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_BY_in_by_key11809_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_BY_in_by_key11809( FOLLOW_SQL92_RESERVED_BY_in_by_key11809_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_AS_in_as_key11829_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_AS_in_as_key11829( FOLLOW_SQL92_RESERVED_AS_in_as_key11829_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_IN_in_in_key11849_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_IN_in_in_key11849( FOLLOW_SQL92_RESERVED_IN_in_in_key11849_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_OF_in_of_key11869_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_OF_in_of_key11869( FOLLOW_SQL92_RESERVED_OF_in_of_key11869_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_NULL_in_null_key11889_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_NULL_in_null_key11889( FOLLOW_SQL92_RESERVED_NULL_in_null_key11889_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_FOR_in_for_key11909_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_FOR_in_for_key11909( FOLLOW_SQL92_RESERVED_FOR_in_for_key11909_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_SELECT_in_select_key11929_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_SELECT_in_select_key11929( FOLLOW_SQL92_RESERVED_SELECT_in_select_key11929_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_WHEN_in_when_key11949_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_WHEN_in_when_key11949( FOLLOW_SQL92_RESERVED_WHEN_in_when_key11949_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_DELETE_in_delete_key11969_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_DELETE_in_delete_key11969( FOLLOW_SQL92_RESERVED_DELETE_in_delete_key11969_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_BETWEEN_in_between_key11989_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_BETWEEN_in_between_key11989( FOLLOW_SQL92_RESERVED_BETWEEN_in_between_key11989_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_LIKE_in_like_key12009_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_LIKE_in_like_key12009( FOLLOW_SQL92_RESERVED_LIKE_in_like_key12009_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_FROM_in_from_key12029_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_FROM_in_from_key12029( FOLLOW_SQL92_RESERVED_FROM_in_from_key12029_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_SQL92_RESERVED_WHERE_in_where_key12049_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_SQL92_RESERVED_WHERE_in_where_key12049( FOLLOW_SQL92_RESERVED_WHERE_in_where_key12049_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_sequence_key12071_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_sequence_key12071( FOLLOW_REGULAR_ID_in_sequence_key12071_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_noorder_key12093_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_noorder_key12093( FOLLOW_REGULAR_ID_in_noorder_key12093_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cycle_key12115_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cycle_key12115( FOLLOW_REGULAR_ID_in_cycle_key12115_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_cache_key12137_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_cache_key12137( FOLLOW_REGULAR_ID_in_cache_key12137_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nocache_key12159_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nocache_key12159( FOLLOW_REGULAR_ID_in_nocache_key12159_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nomaxvalue_key12181_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nomaxvalue_key12181( FOLLOW_REGULAR_ID_in_nomaxvalue_key12181_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_nominvalue_key12203_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_nominvalue_key12203( FOLLOW_REGULAR_ID_in_nominvalue_key12203_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_search_key12225_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_search_key12225( FOLLOW_REGULAR_ID_in_search_key12225_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_depth_key12247_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_depth_key12247( FOLLOW_REGULAR_ID_in_depth_key12247_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQLKeys  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_breadth_key12269_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQLKeysImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_breadth_key12269( FOLLOW_REGULAR_ID_in_breadth_key12269_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start create_key
 * PLSQLKeys.g:35:1: create_key : SQL92_RESERVED_CREATE ;
 */
void
PLSQLParser_PLSQLKeys::create_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:36:5: ( SQL92_RESERVED_CREATE )
        // PLSQLKeys.g:36:10: SQL92_RESERVED_CREATE
        {
             this->matchToken(SQL92_RESERVED_CREATE, &FOLLOW_SQL92_RESERVED_CREATE_in_create_key47);
            if  (this->hasException())
            {
                goto rulecreate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecreate_keyEx; /* Prevent compiler warnings */
    rulecreate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end create_key */

/**
 * $ANTLR start replace_key
 * PLSQLKeys.g:39:1: replace_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::replace_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:41:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:41:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "REPLACE" ))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"REPLACE\" )" );
                    ex->set_ruleName( "replace_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_replace_key77);
            if  (this->hasException())
            {
                goto rulereplace_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereplace_keyEx; /* Prevent compiler warnings */
    rulereplace_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end replace_key */

/**
 * $ANTLR start package_key
 * PLSQLKeys.g:44:1: package_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::package_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:45:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:45:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PACKAGE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PACKAGE\")" );
                    ex->set_ruleName( "package_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_package_key100);
            if  (this->hasException())
            {
                goto rulepackage_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepackage_keyEx; /* Prevent compiler warnings */
    rulepackage_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end package_key */

/**
 * $ANTLR start body_key
 * PLSQLKeys.g:48:1: body_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::body_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:49:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:49:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BODY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BODY\")" );
                    ex->set_ruleName( "body_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_body_key122);
            if  (this->hasException())
            {
                goto rulebody_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebody_keyEx; /* Prevent compiler warnings */
    rulebody_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end body_key */

/**
 * $ANTLR start begin_key
 * PLSQLKeys.g:52:1: begin_key : SQL92_RESERVED_BEGIN ;
 */
void
PLSQLParser_PLSQLKeys::begin_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:53:5: ( SQL92_RESERVED_BEGIN )
        // PLSQLKeys.g:53:10: SQL92_RESERVED_BEGIN
        {
             this->matchToken(SQL92_RESERVED_BEGIN, &FOLLOW_SQL92_RESERVED_BEGIN_in_begin_key142);
            if  (this->hasException())
            {
                goto rulebegin_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebegin_keyEx; /* Prevent compiler warnings */
    rulebegin_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end begin_key */

/**
 * $ANTLR start exit_key
 * PLSQLKeys.g:56:1: exit_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::exit_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:57:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:57:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXIT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXIT\")" );
                    ex->set_ruleName( "exit_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_exit_key164);
            if  (this->hasException())
            {
                goto ruleexit_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexit_keyEx; /* Prevent compiler warnings */
    ruleexit_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exit_key */

/**
 * $ANTLR start declare_key
 * PLSQLKeys.g:60:1: declare_key : SQL92_RESERVED_DECLARE ;
 */
void
PLSQLParser_PLSQLKeys::declare_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:61:5: ( SQL92_RESERVED_DECLARE )
        // PLSQLKeys.g:61:10: SQL92_RESERVED_DECLARE
        {
             this->matchToken(SQL92_RESERVED_DECLARE, &FOLLOW_SQL92_RESERVED_DECLARE_in_declare_key184);
            if  (this->hasException())
            {
                goto ruledeclare_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledeclare_keyEx; /* Prevent compiler warnings */
    ruledeclare_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end declare_key */

/**
 * $ANTLR start exception_key
 * PLSQLKeys.g:64:1: exception_key : SQL92_RESERVED_EXCEPTION ;
 */
void
PLSQLParser_PLSQLKeys::exception_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:65:5: ( SQL92_RESERVED_EXCEPTION )
        // PLSQLKeys.g:65:10: SQL92_RESERVED_EXCEPTION
        {
             this->matchToken(SQL92_RESERVED_EXCEPTION, &FOLLOW_SQL92_RESERVED_EXCEPTION_in_exception_key204);
            if  (this->hasException())
            {
                goto ruleexception_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexception_keyEx; /* Prevent compiler warnings */
    ruleexception_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exception_key */

/**
 * $ANTLR start serveroutput_key
 * PLSQLKeys.g:68:1: serveroutput_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::serveroutput_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:69:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:69:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SERVEROUTPUT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SERVEROUTPUT\")" );
                    ex->set_ruleName( "serveroutput_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_serveroutput_key226);
            if  (this->hasException())
            {
                goto ruleserveroutput_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleserveroutput_keyEx; /* Prevent compiler warnings */
    ruleserveroutput_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end serveroutput_key */

/**
 * $ANTLR start off_key
 * PLSQLKeys.g:72:1: off_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::off_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:73:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:73:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OFF"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OFF\")" );
                    ex->set_ruleName( "off_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_off_key248);
            if  (this->hasException())
            {
                goto ruleoff_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleoff_keyEx; /* Prevent compiler warnings */
    ruleoff_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end off_key */

/**
 * $ANTLR start constant_key
 * PLSQLKeys.g:76:1: constant_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::constant_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:77:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:77:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CONSTANT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CONSTANT\")" );
                    ex->set_ruleName( "constant_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_constant_key270);
            if  (this->hasException())
            {
                goto ruleconstant_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconstant_keyEx; /* Prevent compiler warnings */
    ruleconstant_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end constant_key */

/**
 * $ANTLR start subtype_key
 * PLSQLKeys.g:80:1: subtype_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::subtype_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:81:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:81:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SUBTYPE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SUBTYPE\")" );
                    ex->set_ruleName( "subtype_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_subtype_key292);
            if  (this->hasException())
            {
                goto rulesubtype_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubtype_keyEx; /* Prevent compiler warnings */
    rulesubtype_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end subtype_key */

/**
 * $ANTLR start cursor_key
 * PLSQLKeys.g:84:1: cursor_key : SQL92_RESERVED_CURSOR ;
 */
void
PLSQLParser_PLSQLKeys::cursor_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:85:5: ( SQL92_RESERVED_CURSOR )
        // PLSQLKeys.g:85:10: SQL92_RESERVED_CURSOR
        {
             this->matchToken(SQL92_RESERVED_CURSOR, &FOLLOW_SQL92_RESERVED_CURSOR_in_cursor_key312);
            if  (this->hasException())
            {
                goto rulecursor_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecursor_keyEx; /* Prevent compiler warnings */
    rulecursor_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cursor_key */

/**
 * $ANTLR start nextval_key
 * PLSQLKeys.g:88:1: nextval_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nextval_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:89:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:89:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NEXTVAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NEXTVAL\")" );
                    ex->set_ruleName( "nextval_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nextval_key335);
            if  (this->hasException())
            {
                goto rulenextval_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenextval_keyEx; /* Prevent compiler warnings */
    rulenextval_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nextval_key */

/**
 * $ANTLR start goto_key
 * PLSQLKeys.g:92:1: goto_key : SQL92_RESERVED_GOTO ;
 */
void
PLSQLParser_PLSQLKeys::goto_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:93:5: ( SQL92_RESERVED_GOTO )
        // PLSQLKeys.g:93:10: SQL92_RESERVED_GOTO
        {
             this->matchToken(SQL92_RESERVED_GOTO, &FOLLOW_SQL92_RESERVED_GOTO_in_goto_key355);
            if  (this->hasException())
            {
                goto rulegoto_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulegoto_keyEx; /* Prevent compiler warnings */
    rulegoto_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end goto_key */

/**
 * $ANTLR start execute_key
 * PLSQLKeys.g:96:1: execute_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::execute_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:97:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:97:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXECUTE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXECUTE\")" );
                    ex->set_ruleName( "execute_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_execute_key377);
            if  (this->hasException())
            {
                goto ruleexecute_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexecute_keyEx; /* Prevent compiler warnings */
    ruleexecute_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end execute_key */

/**
 * $ANTLR start immediate_key
 * PLSQLKeys.g:100:1: immediate_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::immediate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:101:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:101:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "IMMEDIATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"IMMEDIATE\")" );
                    ex->set_ruleName( "immediate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_immediate_key400);
            if  (this->hasException())
            {
                goto ruleimmediate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleimmediate_keyEx; /* Prevent compiler warnings */
    ruleimmediate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end immediate_key */

/**
 * $ANTLR start return_key
 * PLSQLKeys.g:104:1: return_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::return_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:105:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:105:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RETURN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RETURN\")" );
                    ex->set_ruleName( "return_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_return_key422);
            if  (this->hasException())
            {
                goto rulereturn_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereturn_keyEx; /* Prevent compiler warnings */
    rulereturn_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end return_key */

/**
 * $ANTLR start procedure_key
 * PLSQLKeys.g:108:1: procedure_key : SQL92_RESERVED_PROCEDURE ;
 */
void
PLSQLParser_PLSQLKeys::procedure_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:109:5: ( SQL92_RESERVED_PROCEDURE )
        // PLSQLKeys.g:109:10: SQL92_RESERVED_PROCEDURE
        {
             this->matchToken(SQL92_RESERVED_PROCEDURE, &FOLLOW_SQL92_RESERVED_PROCEDURE_in_procedure_key442);
            if  (this->hasException())
            {
                goto ruleprocedure_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprocedure_keyEx; /* Prevent compiler warnings */
    ruleprocedure_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end procedure_key */

/**
 * $ANTLR start function_key
 * PLSQLKeys.g:112:1: function_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::function_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:113:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:113:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FUNCTION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FUNCTION\")" );
                    ex->set_ruleName( "function_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_function_key465);
            if  (this->hasException())
            {
                goto rulefunction_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunction_keyEx; /* Prevent compiler warnings */
    rulefunction_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end function_key */

/**
 * $ANTLR start pragma_key
 * PLSQLKeys.g:116:1: pragma_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::pragma_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:117:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:117:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PRAGMA"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PRAGMA\")" );
                    ex->set_ruleName( "pragma_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_pragma_key487);
            if  (this->hasException())
            {
                goto rulepragma_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepragma_keyEx; /* Prevent compiler warnings */
    rulepragma_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pragma_key */

/**
 * $ANTLR start exception_init_key
 * PLSQLKeys.g:120:1: exception_init_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::exception_init_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:121:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:121:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXCEPTION_INIT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXCEPTION_INIT\")" );
                    ex->set_ruleName( "exception_init_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_exception_init_key509);
            if  (this->hasException())
            {
                goto ruleexception_init_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexception_init_keyEx; /* Prevent compiler warnings */
    ruleexception_init_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exception_init_key */

/**
 * $ANTLR start type_key
 * PLSQLKeys.g:124:1: type_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::type_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:125:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:125:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TYPE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TYPE\")" );
                    ex->set_ruleName( "type_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_type_key532);
            if  (this->hasException())
            {
                goto ruletype_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletype_keyEx; /* Prevent compiler warnings */
    ruletype_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end type_key */

/**
 * $ANTLR start record_key
 * PLSQLKeys.g:128:1: record_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::record_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:129:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:129:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RECORD"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RECORD\")" );
                    ex->set_ruleName( "record_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_record_key555);
            if  (this->hasException())
            {
                goto rulerecord_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerecord_keyEx; /* Prevent compiler warnings */
    rulerecord_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end record_key */

/**
 * $ANTLR start indexed_key
 * PLSQLKeys.g:132:1: indexed_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::indexed_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:133:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:133:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INDEXED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INDEXED\")" );
                    ex->set_ruleName( "indexed_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_indexed_key577);
            if  (this->hasException())
            {
                goto ruleindexed_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleindexed_keyEx; /* Prevent compiler warnings */
    ruleindexed_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end indexed_key */

/**
 * $ANTLR start index_key
 * PLSQLKeys.g:136:1: index_key : PLSQL_RESERVED_INDEX ;
 */
void
PLSQLParser_PLSQLKeys::index_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:137:5: ( PLSQL_RESERVED_INDEX )
        // PLSQLKeys.g:137:10: PLSQL_RESERVED_INDEX
        {
             this->matchToken(PLSQL_RESERVED_INDEX, &FOLLOW_PLSQL_RESERVED_INDEX_in_index_key597);
            if  (this->hasException())
            {
                goto ruleindex_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleindex_keyEx; /* Prevent compiler warnings */
    ruleindex_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end index_key */

/**
 * $ANTLR start percent_notfound_key
 * PLSQLKeys.g:140:1: percent_notfound_key :{...}? => PERCENT REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::percent_notfound_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:141:5: ({...}? => PERCENT REGULAR_ID )
        // PLSQLKeys.g:141:10: {...}? => PERCENT REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(2)->getText(), "NOTFOUND"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(2)->getText(), \"NOTFOUND\")" );
                    ex->set_ruleName( "percent_notfound_key" );


            }

             this->matchToken(PERCENT, &FOLLOW_PERCENT_in_percent_notfound_key620);
            if  (this->hasException())
            {
                goto rulepercent_notfound_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_percent_notfound_key622);
            if  (this->hasException())
            {
                goto rulepercent_notfound_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepercent_notfound_keyEx; /* Prevent compiler warnings */
    rulepercent_notfound_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end percent_notfound_key */

/**
 * $ANTLR start percent_found_key
 * PLSQLKeys.g:144:1: percent_found_key :{...}? => PERCENT REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::percent_found_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:145:5: ({...}? => PERCENT REGULAR_ID )
        // PLSQLKeys.g:145:10: {...}? => PERCENT REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(2)->getText(), "FOUND"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(2)->getText(), \"FOUND\")" );
                    ex->set_ruleName( "percent_found_key" );


            }

             this->matchToken(PERCENT, &FOLLOW_PERCENT_in_percent_found_key645);
            if  (this->hasException())
            {
                goto rulepercent_found_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_percent_found_key647);
            if  (this->hasException())
            {
                goto rulepercent_found_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepercent_found_keyEx; /* Prevent compiler warnings */
    rulepercent_found_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end percent_found_key */

/**
 * $ANTLR start percent_isopen_key
 * PLSQLKeys.g:148:1: percent_isopen_key :{...}? => PERCENT REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::percent_isopen_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:149:5: ({...}? => PERCENT REGULAR_ID )
        // PLSQLKeys.g:149:10: {...}? => PERCENT REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(2)->getText(), "ISOPEN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(2)->getText(), \"ISOPEN\")" );
                    ex->set_ruleName( "percent_isopen_key" );


            }

             this->matchToken(PERCENT, &FOLLOW_PERCENT_in_percent_isopen_key670);
            if  (this->hasException())
            {
                goto rulepercent_isopen_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_percent_isopen_key672);
            if  (this->hasException())
            {
                goto rulepercent_isopen_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepercent_isopen_keyEx; /* Prevent compiler warnings */
    rulepercent_isopen_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end percent_isopen_key */

/**
 * $ANTLR start percent_rowcount_key
 * PLSQLKeys.g:152:1: percent_rowcount_key :{...}? => PERCENT REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::percent_rowcount_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:153:5: ({...}? => PERCENT REGULAR_ID )
        // PLSQLKeys.g:153:10: {...}? => PERCENT REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(2)->getText(), "ROWCOUNT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(2)->getText(), \"ROWCOUNT\")" );
                    ex->set_ruleName( "percent_rowcount_key" );


            }

             this->matchToken(PERCENT, &FOLLOW_PERCENT_in_percent_rowcount_key695);
            if  (this->hasException())
            {
                goto rulepercent_rowcount_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_percent_rowcount_key697);
            if  (this->hasException())
            {
                goto rulepercent_rowcount_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepercent_rowcount_keyEx; /* Prevent compiler warnings */
    rulepercent_rowcount_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end percent_rowcount_key */

/**
 * $ANTLR start percent_rowtype_key
 * PLSQLKeys.g:156:1: percent_rowtype_key :{...}? => PERCENT REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::percent_rowtype_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:157:5: ({...}? => PERCENT REGULAR_ID )
        // PLSQLKeys.g:157:10: {...}? => PERCENT REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(2)->getText(), "ROWTYPE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(2)->getText(), \"ROWTYPE\")" );
                    ex->set_ruleName( "percent_rowtype_key" );


            }

             this->matchToken(PERCENT, &FOLLOW_PERCENT_in_percent_rowtype_key720);
            if  (this->hasException())
            {
                goto rulepercent_rowtype_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_percent_rowtype_key722);
            if  (this->hasException())
            {
                goto rulepercent_rowtype_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepercent_rowtype_keyEx; /* Prevent compiler warnings */
    rulepercent_rowtype_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end percent_rowtype_key */

/**
 * $ANTLR start percent_type_key
 * PLSQLKeys.g:160:1: percent_type_key :{...}? => PERCENT REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::percent_type_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:161:5: ({...}? => PERCENT REGULAR_ID )
        // PLSQLKeys.g:161:10: {...}? => PERCENT REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(2)->getText(), "TYPE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(2)->getText(), \"TYPE\")" );
                    ex->set_ruleName( "percent_type_key" );


            }

             this->matchToken(PERCENT, &FOLLOW_PERCENT_in_percent_type_key746);
            if  (this->hasException())
            {
                goto rulepercent_type_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_percent_type_key748);
            if  (this->hasException())
            {
                goto rulepercent_type_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepercent_type_keyEx; /* Prevent compiler warnings */
    rulepercent_type_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end percent_type_key */

/**
 * $ANTLR start out_key
 * PLSQLKeys.g:164:1: out_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::out_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:165:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:165:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OUT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OUT\")" );
                    ex->set_ruleName( "out_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_out_key771);
            if  (this->hasException())
            {
                goto ruleout_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleout_keyEx; /* Prevent compiler warnings */
    ruleout_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end out_key */

/**
 * $ANTLR start inout_key
 * PLSQLKeys.g:168:1: inout_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::inout_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:169:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:169:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INOUT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INOUT\")" );
                    ex->set_ruleName( "inout_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_inout_key793);
            if  (this->hasException())
            {
                goto ruleinout_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinout_keyEx; /* Prevent compiler warnings */
    ruleinout_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end inout_key */

/**
 * $ANTLR start extend_key
 * PLSQLKeys.g:172:1: extend_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::extend_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:173:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:173:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXTEND"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXTEND\")" );
                    ex->set_ruleName( "extend_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_extend_key816);
            if  (this->hasException())
            {
                goto ruleextend_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleextend_keyEx; /* Prevent compiler warnings */
    ruleextend_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end extend_key */

/**
 * $ANTLR start raise_key
 * PLSQLKeys.g:176:1: raise_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::raise_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:177:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:177:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RAISE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RAISE\")" );
                    ex->set_ruleName( "raise_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_raise_key838);
            if  (this->hasException())
            {
                goto ruleraise_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleraise_keyEx; /* Prevent compiler warnings */
    ruleraise_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end raise_key */

/**
 * $ANTLR start while_key
 * PLSQLKeys.g:180:1: while_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::while_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:181:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:181:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "WHILE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"WHILE\")" );
                    ex->set_ruleName( "while_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_while_key860);
            if  (this->hasException())
            {
                goto rulewhile_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewhile_keyEx; /* Prevent compiler warnings */
    rulewhile_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end while_key */

/**
 * $ANTLR start loop_key
 * PLSQLKeys.g:184:1: loop_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::loop_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:185:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:185:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LOOP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LOOP\")" );
                    ex->set_ruleName( "loop_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_loop_key882);
            if  (this->hasException())
            {
                goto ruleloop_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleloop_keyEx; /* Prevent compiler warnings */
    ruleloop_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end loop_key */

/**
 * $ANTLR start commit_key
 * PLSQLKeys.g:188:1: commit_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::commit_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:189:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:189:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COMMIT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COMMIT\")" );
                    ex->set_ruleName( "commit_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_commit_key905);
            if  (this->hasException())
            {
                goto rulecommit_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecommit_keyEx; /* Prevent compiler warnings */
    rulecommit_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end commit_key */

/**
 * $ANTLR start work_key
 * PLSQLKeys.g:192:1: work_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::work_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:193:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:193:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "WORK"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"WORK\")" );
                    ex->set_ruleName( "work_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_work_key927);
            if  (this->hasException())
            {
                goto rulework_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulework_keyEx; /* Prevent compiler warnings */
    rulework_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end work_key */

/**
 * $ANTLR start if_key
 * PLSQLKeys.g:196:1: if_key : PLSQL_RESERVED_IF ;
 */
void
PLSQLParser_PLSQLKeys::if_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:197:5: ( PLSQL_RESERVED_IF )
        // PLSQLKeys.g:197:10: PLSQL_RESERVED_IF
        {
             this->matchToken(PLSQL_RESERVED_IF, &FOLLOW_PLSQL_RESERVED_IF_in_if_key947);
            if  (this->hasException())
            {
                goto ruleif_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleif_keyEx; /* Prevent compiler warnings */
    ruleif_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end if_key */

/**
 * $ANTLR start elsif_key
 * PLSQLKeys.g:200:1: elsif_key : PLSQL_NON_RESERVED_ELSIF ;
 */
void
PLSQLParser_PLSQLKeys::elsif_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:201:5: ( PLSQL_NON_RESERVED_ELSIF )
        // PLSQLKeys.g:201:10: PLSQL_NON_RESERVED_ELSIF
        {
             this->matchToken(PLSQL_NON_RESERVED_ELSIF, &FOLLOW_PLSQL_NON_RESERVED_ELSIF_in_elsif_key967);
            if  (this->hasException())
            {
                goto ruleelsif_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleelsif_keyEx; /* Prevent compiler warnings */
    ruleelsif_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end elsif_key */

/**
 * $ANTLR start authid_key
 * PLSQLKeys.g:204:1: authid_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::authid_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:205:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:205:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AUTHID"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AUTHID\")" );
                    ex->set_ruleName( "authid_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_authid_key990);
            if  (this->hasException())
            {
                goto ruleauthid_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleauthid_keyEx; /* Prevent compiler warnings */
    ruleauthid_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end authid_key */

/**
 * $ANTLR start definer_key
 * PLSQLKeys.g:208:1: definer_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::definer_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:209:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:209:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DEFINER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DEFINER\")" );
                    ex->set_ruleName( "definer_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_definer_key1012);
            if  (this->hasException())
            {
                goto ruledefiner_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledefiner_keyEx; /* Prevent compiler warnings */
    ruledefiner_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end definer_key */

/**
 * $ANTLR start external_key
 * PLSQLKeys.g:212:1: external_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::external_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:213:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:213:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXTERNAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXTERNAL\")" );
                    ex->set_ruleName( "external_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_external_key1034);
            if  (this->hasException())
            {
                goto ruleexternal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexternal_keyEx; /* Prevent compiler warnings */
    ruleexternal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end external_key */

/**
 * $ANTLR start language_key
 * PLSQLKeys.g:216:1: language_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::language_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:217:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:217:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LANGUAGE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LANGUAGE\")" );
                    ex->set_ruleName( "language_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_language_key1056);
            if  (this->hasException())
            {
                goto rulelanguage_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelanguage_keyEx; /* Prevent compiler warnings */
    rulelanguage_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end language_key */

/**
 * $ANTLR start java_key
 * PLSQLKeys.g:220:1: java_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::java_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:221:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:221:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "JAVA"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"JAVA\")" );
                    ex->set_ruleName( "java_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_java_key1078);
            if  (this->hasException())
            {
                goto rulejava_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulejava_keyEx; /* Prevent compiler warnings */
    rulejava_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end java_key */

/**
 * $ANTLR start name_key
 * PLSQLKeys.g:224:1: name_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::name_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:225:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:225:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NAME"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NAME\")" );
                    ex->set_ruleName( "name_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_name_key1101);
            if  (this->hasException())
            {
                goto rulename_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulename_keyEx; /* Prevent compiler warnings */
    rulename_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end name_key */

/**
 * $ANTLR start deterministic_key
 * PLSQLKeys.g:228:1: deterministic_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::deterministic_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:229:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:229:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DETERMINISTIC"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DETERMINISTIC\")" );
                    ex->set_ruleName( "deterministic_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_deterministic_key1124);
            if  (this->hasException())
            {
                goto ruledeterministic_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledeterministic_keyEx; /* Prevent compiler warnings */
    ruledeterministic_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end deterministic_key */

/**
 * $ANTLR start parallel_enable_key
 * PLSQLKeys.g:232:1: parallel_enable_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::parallel_enable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:233:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:233:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PARALLEL_ENABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PARALLEL_ENABLE\")" );
                    ex->set_ruleName( "parallel_enable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_parallel_enable_key1147);
            if  (this->hasException())
            {
                goto ruleparallel_enable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleparallel_enable_keyEx; /* Prevent compiler warnings */
    ruleparallel_enable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end parallel_enable_key */

/**
 * $ANTLR start result_cache_key
 * PLSQLKeys.g:236:1: result_cache_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::result_cache_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:237:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:237:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RESULT_CACHE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RESULT_CACHE\")" );
                    ex->set_ruleName( "result_cache_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_result_cache_key1170);
            if  (this->hasException())
            {
                goto ruleresult_cache_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleresult_cache_keyEx; /* Prevent compiler warnings */
    ruleresult_cache_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end result_cache_key */

/**
 * $ANTLR start pipelined_key
 * PLSQLKeys.g:240:1: pipelined_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::pipelined_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:241:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:241:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PIPELINED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PIPELINED\")" );
                    ex->set_ruleName( "pipelined_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_pipelined_key1193);
            if  (this->hasException())
            {
                goto rulepipelined_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepipelined_keyEx; /* Prevent compiler warnings */
    rulepipelined_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pipelined_key */

/**
 * $ANTLR start aggregate_key
 * PLSQLKeys.g:244:1: aggregate_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::aggregate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:245:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:245:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AGGREGATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AGGREGATE\")" );
                    ex->set_ruleName( "aggregate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_aggregate_key1215);
            if  (this->hasException())
            {
                goto ruleaggregate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleaggregate_keyEx; /* Prevent compiler warnings */
    ruleaggregate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end aggregate_key */

/**
 * $ANTLR start alter_key
 * PLSQLKeys.g:248:1: alter_key : SQL92_RESERVED_ALTER ;
 */
void
PLSQLParser_PLSQLKeys::alter_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:249:5: ( SQL92_RESERVED_ALTER )
        // PLSQLKeys.g:249:10: SQL92_RESERVED_ALTER
        {
             this->matchToken(SQL92_RESERVED_ALTER, &FOLLOW_SQL92_RESERVED_ALTER_in_alter_key1235);
            if  (this->hasException())
            {
                goto rulealter_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealter_keyEx; /* Prevent compiler warnings */
    rulealter_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end alter_key */

/**
 * $ANTLR start compile_key
 * PLSQLKeys.g:252:1: compile_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::compile_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:253:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:253:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COMPILE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COMPILE\")" );
                    ex->set_ruleName( "compile_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_compile_key1257);
            if  (this->hasException())
            {
                goto rulecompile_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecompile_keyEx; /* Prevent compiler warnings */
    rulecompile_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end compile_key */

/**
 * $ANTLR start debug_key
 * PLSQLKeys.g:256:1: debug_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::debug_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:257:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:257:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DEBUG"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DEBUG\")" );
                    ex->set_ruleName( "debug_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_debug_key1280);
            if  (this->hasException())
            {
                goto ruledebug_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledebug_keyEx; /* Prevent compiler warnings */
    ruledebug_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end debug_key */

/**
 * $ANTLR start reuse_key
 * PLSQLKeys.g:260:1: reuse_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::reuse_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:261:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:261:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "REUSE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"REUSE\")" );
                    ex->set_ruleName( "reuse_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_reuse_key1302);
            if  (this->hasException())
            {
                goto rulereuse_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereuse_keyEx; /* Prevent compiler warnings */
    rulereuse_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end reuse_key */

/**
 * $ANTLR start settings_key
 * PLSQLKeys.g:264:1: settings_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::settings_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:265:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:265:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SETTINGS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SETTINGS\")" );
                    ex->set_ruleName( "settings_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_settings_key1324);
            if  (this->hasException())
            {
                goto rulesettings_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesettings_keyEx; /* Prevent compiler warnings */
    rulesettings_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end settings_key */

/**
 * $ANTLR start specification_key
 * PLSQLKeys.g:268:1: specification_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::specification_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:269:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:269:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SPECIFICATION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SPECIFICATION\")" );
                    ex->set_ruleName( "specification_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_specification_key1346);
            if  (this->hasException())
            {
                goto rulespecification_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulespecification_keyEx; /* Prevent compiler warnings */
    rulespecification_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end specification_key */

/**
 * $ANTLR start drop_key
 * PLSQLKeys.g:272:1: drop_key : SQL92_RESERVED_DROP ;
 */
void
PLSQLParser_PLSQLKeys::drop_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:273:5: ( SQL92_RESERVED_DROP )
        // PLSQLKeys.g:273:10: SQL92_RESERVED_DROP
        {
             this->matchToken(SQL92_RESERVED_DROP, &FOLLOW_SQL92_RESERVED_DROP_in_drop_key1366);
            if  (this->hasException())
            {
                goto ruledrop_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledrop_keyEx; /* Prevent compiler warnings */
    ruledrop_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end drop_key */

/**
 * $ANTLR start trigger_key
 * PLSQLKeys.g:276:1: trigger_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::trigger_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:277:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:277:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TRIGGER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TRIGGER\")" );
                    ex->set_ruleName( "trigger_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_trigger_key1389);
            if  (this->hasException())
            {
                goto ruletrigger_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletrigger_keyEx; /* Prevent compiler warnings */
    ruletrigger_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end trigger_key */

/**
 * $ANTLR start force_key
 * PLSQLKeys.g:280:1: force_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::force_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:281:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:281:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FORCE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FORCE\")" );
                    ex->set_ruleName( "force_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_force_key1412);
            if  (this->hasException())
            {
                goto ruleforce_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleforce_keyEx; /* Prevent compiler warnings */
    ruleforce_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end force_key */

/**
 * $ANTLR start validate_key
 * PLSQLKeys.g:284:1: validate_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::validate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:285:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:285:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VALIDATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VALIDATE\")" );
                    ex->set_ruleName( "validate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_validate_key1434);
            if  (this->hasException())
            {
                goto rulevalidate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevalidate_keyEx; /* Prevent compiler warnings */
    rulevalidate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end validate_key */

/**
 * $ANTLR start ref_key
 * PLSQLKeys.g:288:1: ref_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::ref_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:289:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:289:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "REF"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"REF\")" );
                    ex->set_ruleName( "ref_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ref_key1457);
            if  (this->hasException())
            {
                goto ruleref_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleref_keyEx; /* Prevent compiler warnings */
    ruleref_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end ref_key */

/**
 * $ANTLR start array_key
 * PLSQLKeys.g:292:1: array_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::array_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:293:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:293:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ARRAY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ARRAY\")" );
                    ex->set_ruleName( "array_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_array_key1480);
            if  (this->hasException())
            {
                goto rulearray_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulearray_keyEx; /* Prevent compiler warnings */
    rulearray_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end array_key */

/**
 * $ANTLR start varray_key
 * PLSQLKeys.g:296:1: varray_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::varray_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:297:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:297:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VARRAY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VARRAY\")" );
                    ex->set_ruleName( "varray_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_varray_key1503);
            if  (this->hasException())
            {
                goto rulevarray_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevarray_keyEx; /* Prevent compiler warnings */
    rulevarray_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end varray_key */

/**
 * $ANTLR start pls_integer_key
 * PLSQLKeys.g:300:1: pls_integer_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::pls_integer_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:301:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:301:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PLS_INTEGER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PLS_INTEGER\")" );
                    ex->set_ruleName( "pls_integer_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_pls_integer_key1526);
            if  (this->hasException())
            {
                goto rulepls_integer_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepls_integer_keyEx; /* Prevent compiler warnings */
    rulepls_integer_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pls_integer_key */

/**
 * $ANTLR start serially_reusable_key
 * PLSQLKeys.g:304:1: serially_reusable_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::serially_reusable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:305:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:305:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SERIALLY_REUSABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SERIALLY_REUSABLE\")" );
                    ex->set_ruleName( "serially_reusable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_serially_reusable_key1549);
            if  (this->hasException())
            {
                goto ruleserially_reusable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleserially_reusable_keyEx; /* Prevent compiler warnings */
    ruleserially_reusable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end serially_reusable_key */

/**
 * $ANTLR start autonomous_transaction_key
 * PLSQLKeys.g:308:1: autonomous_transaction_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::autonomous_transaction_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:309:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:309:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AUTONOMOUS_TRANSACTION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AUTONOMOUS_TRANSACTION\")" );
                    ex->set_ruleName( "autonomous_transaction_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_autonomous_transaction_key1572);
            if  (this->hasException())
            {
                goto ruleautonomous_transaction_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleautonomous_transaction_keyEx; /* Prevent compiler warnings */
    ruleautonomous_transaction_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end autonomous_transaction_key */

/**
 * $ANTLR start inline_key
 * PLSQLKeys.g:312:1: inline_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::inline_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:313:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:313:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INLINE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INLINE\")" );
                    ex->set_ruleName( "inline_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_inline_key1595);
            if  (this->hasException())
            {
                goto ruleinline_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinline_keyEx; /* Prevent compiler warnings */
    ruleinline_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end inline_key */

/**
 * $ANTLR start restrict_references_key
 * PLSQLKeys.g:316:1: restrict_references_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::restrict_references_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:317:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:317:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RESTRICT_REFERENCES"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RESTRICT_REFERENCES\")" );
                    ex->set_ruleName( "restrict_references_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_restrict_references_key1618);
            if  (this->hasException())
            {
                goto rulerestrict_references_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerestrict_references_keyEx; /* Prevent compiler warnings */
    rulerestrict_references_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end restrict_references_key */

/**
 * $ANTLR start exceptions_key
 * PLSQLKeys.g:320:1: exceptions_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::exceptions_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:321:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:321:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXCEPTIONS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXCEPTIONS\")" );
                    ex->set_ruleName( "exceptions_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_exceptions_key1641);
            if  (this->hasException())
            {
                goto ruleexceptions_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexceptions_keyEx; /* Prevent compiler warnings */
    ruleexceptions_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exceptions_key */

/**
 * $ANTLR start save_key
 * PLSQLKeys.g:324:1: save_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::save_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:325:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:325:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SAVE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SAVE\")" );
                    ex->set_ruleName( "save_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_save_key1665);
            if  (this->hasException())
            {
                goto rulesave_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesave_keyEx; /* Prevent compiler warnings */
    rulesave_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end save_key */

/**
 * $ANTLR start forall_key
 * PLSQLKeys.g:328:1: forall_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::forall_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:329:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:329:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FORALL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FORALL\")" );
                    ex->set_ruleName( "forall_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_forall_key1688);
            if  (this->hasException())
            {
                goto ruleforall_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleforall_keyEx; /* Prevent compiler warnings */
    ruleforall_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end forall_key */

/**
 * $ANTLR start continue_key
 * PLSQLKeys.g:332:1: continue_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::continue_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:333:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:333:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CONTINUE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CONTINUE\")" );
                    ex->set_ruleName( "continue_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_continue_key1711);
            if  (this->hasException())
            {
                goto rulecontinue_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecontinue_keyEx; /* Prevent compiler warnings */
    rulecontinue_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end continue_key */

/**
 * $ANTLR start indices_key
 * PLSQLKeys.g:336:1: indices_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::indices_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:337:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:337:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INDICES"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INDICES\")" );
                    ex->set_ruleName( "indices_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_indices_key1734);
            if  (this->hasException())
            {
                goto ruleindices_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleindices_keyEx; /* Prevent compiler warnings */
    ruleindices_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end indices_key */

/**
 * $ANTLR start values_key
 * PLSQLKeys.g:340:1: values_key : SQL92_RESERVED_VALUES ;
 */
void
PLSQLParser_PLSQLKeys::values_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:341:5: ( SQL92_RESERVED_VALUES )
        // PLSQLKeys.g:341:10: SQL92_RESERVED_VALUES
        {
             this->matchToken(SQL92_RESERVED_VALUES, &FOLLOW_SQL92_RESERVED_VALUES_in_values_key1754);
            if  (this->hasException())
            {
                goto rulevalues_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevalues_keyEx; /* Prevent compiler warnings */
    rulevalues_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end values_key */

/**
 * $ANTLR start case_key
 * PLSQLKeys.g:344:1: case_key : SQL92_RESERVED_CASE ;
 */
void
PLSQLParser_PLSQLKeys::case_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:345:5: ( SQL92_RESERVED_CASE )
        // PLSQLKeys.g:345:10: SQL92_RESERVED_CASE
        {
             this->matchToken(SQL92_RESERVED_CASE, &FOLLOW_SQL92_RESERVED_CASE_in_case_key1774);
            if  (this->hasException())
            {
                goto rulecase_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecase_keyEx; /* Prevent compiler warnings */
    rulecase_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end case_key */

/**
 * $ANTLR start bulk_key
 * PLSQLKeys.g:348:1: bulk_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::bulk_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:349:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:349:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BULK"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BULK\")" );
                    ex->set_ruleName( "bulk_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_bulk_key1797);
            if  (this->hasException())
            {
                goto rulebulk_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebulk_keyEx; /* Prevent compiler warnings */
    rulebulk_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end bulk_key */

/**
 * $ANTLR start collect_key
 * PLSQLKeys.g:352:1: collect_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::collect_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:353:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:353:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COLLECT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COLLECT\")" );
                    ex->set_ruleName( "collect_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_collect_key1820);
            if  (this->hasException())
            {
                goto rulecollect_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecollect_keyEx; /* Prevent compiler warnings */
    rulecollect_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end collect_key */

/**
 * $ANTLR start committed_key
 * PLSQLKeys.g:356:1: committed_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::committed_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:357:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:357:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COMMITTED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COMMITTED\")" );
                    ex->set_ruleName( "committed_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_committed_key1842);
            if  (this->hasException())
            {
                goto rulecommitted_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecommitted_keyEx; /* Prevent compiler warnings */
    rulecommitted_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end committed_key */

/**
 * $ANTLR start use_key
 * PLSQLKeys.g:360:1: use_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::use_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:361:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:361:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "USE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"USE\")" );
                    ex->set_ruleName( "use_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_use_key1865);
            if  (this->hasException())
            {
                goto ruleuse_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleuse_keyEx; /* Prevent compiler warnings */
    ruleuse_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end use_key */

/**
 * $ANTLR start level_key
 * PLSQLKeys.g:364:1: level_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::level_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:365:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:365:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LEVEL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LEVEL\")" );
                    ex->set_ruleName( "level_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_level_key1887);
            if  (this->hasException())
            {
                goto rulelevel_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelevel_keyEx; /* Prevent compiler warnings */
    rulelevel_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end level_key */

/**
 * $ANTLR start isolation_key
 * PLSQLKeys.g:368:1: isolation_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::isolation_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:369:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:369:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ISOLATION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ISOLATION\")" );
                    ex->set_ruleName( "isolation_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_isolation_key1910);
            if  (this->hasException())
            {
                goto ruleisolation_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleisolation_keyEx; /* Prevent compiler warnings */
    ruleisolation_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end isolation_key */

/**
 * $ANTLR start serializable_key
 * PLSQLKeys.g:372:1: serializable_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::serializable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:373:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:373:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SERIALIZABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SERIALIZABLE\")" );
                    ex->set_ruleName( "serializable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_serializable_key1932);
            if  (this->hasException())
            {
                goto ruleserializable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleserializable_keyEx; /* Prevent compiler warnings */
    ruleserializable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end serializable_key */

/**
 * $ANTLR start segment_key
 * PLSQLKeys.g:376:1: segment_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::segment_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:377:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:377:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SEGMENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SEGMENT\")" );
                    ex->set_ruleName( "segment_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_segment_key1954);
            if  (this->hasException())
            {
                goto rulesegment_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesegment_keyEx; /* Prevent compiler warnings */
    rulesegment_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end segment_key */

/**
 * $ANTLR start write_key
 * PLSQLKeys.g:380:1: write_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::write_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:381:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:381:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "WRITE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"WRITE\")" );
                    ex->set_ruleName( "write_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_write_key1977);
            if  (this->hasException())
            {
                goto rulewrite_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewrite_keyEx; /* Prevent compiler warnings */
    rulewrite_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end write_key */

/**
 * $ANTLR start wait_key
 * PLSQLKeys.g:384:1: wait_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::wait_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:385:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:385:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "WAIT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"WAIT\")" );
                    ex->set_ruleName( "wait_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_wait_key2000);
            if  (this->hasException())
            {
                goto rulewait_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewait_keyEx; /* Prevent compiler warnings */
    rulewait_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end wait_key */

/**
 * $ANTLR start corrupt_xid_all_key
 * PLSQLKeys.g:388:1: corrupt_xid_all_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::corrupt_xid_all_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:389:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:389:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CORRUPT_XID_ALL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CORRUPT_XID_ALL\")" );
                    ex->set_ruleName( "corrupt_xid_all_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_corrupt_xid_all_key2023);
            if  (this->hasException())
            {
                goto rulecorrupt_xid_all_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecorrupt_xid_all_keyEx; /* Prevent compiler warnings */
    rulecorrupt_xid_all_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end corrupt_xid_all_key */

/**
 * $ANTLR start corrupt_xid_key
 * PLSQLKeys.g:392:1: corrupt_xid_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::corrupt_xid_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:393:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:393:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CORRUPT_XID"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CORRUPT_XID\")" );
                    ex->set_ruleName( "corrupt_xid_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_corrupt_xid_key2046);
            if  (this->hasException())
            {
                goto rulecorrupt_xid_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecorrupt_xid_keyEx; /* Prevent compiler warnings */
    rulecorrupt_xid_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end corrupt_xid_key */

/**
 * $ANTLR start batch_key
 * PLSQLKeys.g:396:1: batch_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::batch_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:397:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:397:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BATCH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BATCH\")" );
                    ex->set_ruleName( "batch_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_batch_key2069);
            if  (this->hasException())
            {
                goto rulebatch_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebatch_keyEx; /* Prevent compiler warnings */
    rulebatch_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end batch_key */

/**
 * $ANTLR start session_key
 * PLSQLKeys.g:400:1: session_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::session_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:401:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:401:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SESSION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SESSION\")" );
                    ex->set_ruleName( "session_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_session_key2092);
            if  (this->hasException())
            {
                goto rulesession_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesession_keyEx; /* Prevent compiler warnings */
    rulesession_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end session_key */

/**
 * $ANTLR start role_key
 * PLSQLKeys.g:404:1: role_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::role_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:405:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:405:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ROLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ROLE\")" );
                    ex->set_ruleName( "role_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_role_key2115);
            if  (this->hasException())
            {
                goto rulerole_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerole_keyEx; /* Prevent compiler warnings */
    rulerole_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end role_key */

/**
 * $ANTLR start constraint_key
 * PLSQLKeys.g:408:1: constraint_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::constraint_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:409:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:409:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CONSTRAINT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CONSTRAINT\")" );
                    ex->set_ruleName( "constraint_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_constraint_key2138);
            if  (this->hasException())
            {
                goto ruleconstraint_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconstraint_keyEx; /* Prevent compiler warnings */
    ruleconstraint_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end constraint_key */

/**
 * $ANTLR start constraints_key
 * PLSQLKeys.g:412:1: constraints_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::constraints_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:413:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:413:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CONSTRAINTS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CONSTRAINTS\")" );
                    ex->set_ruleName( "constraints_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_constraints_key2161);
            if  (this->hasException())
            {
                goto ruleconstraints_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconstraints_keyEx; /* Prevent compiler warnings */
    ruleconstraints_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end constraints_key */

/**
 * $ANTLR start call_key
 * PLSQLKeys.g:416:1: call_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::call_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:417:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:417:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CALL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CALL\")" );
                    ex->set_ruleName( "call_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_call_key2184);
            if  (this->hasException())
            {
                goto rulecall_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecall_keyEx; /* Prevent compiler warnings */
    rulecall_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end call_key */

/**
 * $ANTLR start explain_key
 * PLSQLKeys.g:420:1: explain_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::explain_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:421:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:421:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXPLAIN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXPLAIN\")" );
                    ex->set_ruleName( "explain_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_explain_key2207);
            if  (this->hasException())
            {
                goto ruleexplain_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexplain_keyEx; /* Prevent compiler warnings */
    ruleexplain_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end explain_key */

/**
 * $ANTLR start merge_key
 * PLSQLKeys.g:424:1: merge_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::merge_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:425:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:425:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MERGE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MERGE\")" );
                    ex->set_ruleName( "merge_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_merge_key2230);
            if  (this->hasException())
            {
                goto rulemerge_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemerge_keyEx; /* Prevent compiler warnings */
    rulemerge_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end merge_key */

/**
 * $ANTLR start plan_key
 * PLSQLKeys.g:428:1: plan_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::plan_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:429:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:429:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PLAN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PLAN\")" );
                    ex->set_ruleName( "plan_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_plan_key2253);
            if  (this->hasException())
            {
                goto ruleplan_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleplan_keyEx; /* Prevent compiler warnings */
    ruleplan_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end plan_key */

/**
 * $ANTLR start system_key
 * PLSQLKeys.g:432:1: system_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::system_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:433:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:433:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SYSTEM"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SYSTEM\")" );
                    ex->set_ruleName( "system_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_system_key2276);
            if  (this->hasException())
            {
                goto rulesystem_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesystem_keyEx; /* Prevent compiler warnings */
    rulesystem_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end system_key */

/**
 * $ANTLR start subpartition_key
 * PLSQLKeys.g:436:1: subpartition_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::subpartition_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:437:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:437:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SUBPARTITION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SUBPARTITION\")" );
                    ex->set_ruleName( "subpartition_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_subpartition_key2299);
            if  (this->hasException())
            {
                goto rulesubpartition_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubpartition_keyEx; /* Prevent compiler warnings */
    rulesubpartition_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end subpartition_key */

/**
 * $ANTLR start partition_key
 * PLSQLKeys.g:440:1: partition_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::partition_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:441:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:441:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PARTITION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PARTITION\")" );
                    ex->set_ruleName( "partition_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_partition_key2322);
            if  (this->hasException())
            {
                goto rulepartition_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepartition_keyEx; /* Prevent compiler warnings */
    rulepartition_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end partition_key */

/**
 * $ANTLR start matched_key
 * PLSQLKeys.g:444:1: matched_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::matched_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:445:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:445:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MATCHED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MATCHED\")" );
                    ex->set_ruleName( "matched_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_matched_key2345);
            if  (this->hasException())
            {
                goto rulematched_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulematched_keyEx; /* Prevent compiler warnings */
    rulematched_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end matched_key */

/**
 * $ANTLR start reject_key
 * PLSQLKeys.g:448:1: reject_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::reject_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:449:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:449:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "REJECT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"REJECT\")" );
                    ex->set_ruleName( "reject_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_reject_key2368);
            if  (this->hasException())
            {
                goto rulereject_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereject_keyEx; /* Prevent compiler warnings */
    rulereject_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end reject_key */

/**
 * $ANTLR start log_key
 * PLSQLKeys.g:452:1: log_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::log_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:453:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:453:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LOG"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LOG\")" );
                    ex->set_ruleName( "log_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_log_key2391);
            if  (this->hasException())
            {
                goto rulelog_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelog_keyEx; /* Prevent compiler warnings */
    rulelog_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end log_key */

/**
 * $ANTLR start unlimited_key
 * PLSQLKeys.g:456:1: unlimited_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::unlimited_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:457:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:457:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UNLIMITED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UNLIMITED\")" );
                    ex->set_ruleName( "unlimited_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_unlimited_key2414);
            if  (this->hasException())
            {
                goto ruleunlimited_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunlimited_keyEx; /* Prevent compiler warnings */
    ruleunlimited_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unlimited_key */

/**
 * $ANTLR start limit_key
 * PLSQLKeys.g:460:1: limit_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::limit_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:461:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:461:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LIMIT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LIMIT\")" );
                    ex->set_ruleName( "limit_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_limit_key2437);
            if  (this->hasException())
            {
                goto rulelimit_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelimit_keyEx; /* Prevent compiler warnings */
    rulelimit_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end limit_key */

/**
 * $ANTLR start errors_key
 * PLSQLKeys.g:464:1: errors_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::errors_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:465:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:465:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ERRORS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ERRORS\")" );
                    ex->set_ruleName( "errors_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_errors_key2460);
            if  (this->hasException())
            {
                goto ruleerrors_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleerrors_keyEx; /* Prevent compiler warnings */
    ruleerrors_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end errors_key */

/**
 * $ANTLR start timestamp_tz_unconstrained_key
 * PLSQLKeys.g:468:1: timestamp_tz_unconstrained_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::timestamp_tz_unconstrained_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:469:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:469:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_TZ_UNCONSTRAINED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIMESTAMP_TZ_UNCONSTRAINED\")" );
                    ex->set_ruleName( "timestamp_tz_unconstrained_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timestamp_tz_unconstrained_key2483);
            if  (this->hasException())
            {
                goto ruletimestamp_tz_unconstrained_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletimestamp_tz_unconstrained_keyEx; /* Prevent compiler warnings */
    ruletimestamp_tz_unconstrained_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timestamp_tz_unconstrained_key */

/**
 * $ANTLR start urowid_key
 * PLSQLKeys.g:472:1: urowid_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::urowid_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:473:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:473:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UROWID"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UROWID\")" );
                    ex->set_ruleName( "urowid_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_urowid_key2506);
            if  (this->hasException())
            {
                goto ruleurowid_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleurowid_keyEx; /* Prevent compiler warnings */
    ruleurowid_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end urowid_key */

/**
 * $ANTLR start binary_float_min_subnormal_key
 * PLSQLKeys.g:476:1: binary_float_min_subnormal_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_float_min_subnormal_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:477:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:477:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT_MIN_SUBNORMAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_FLOAT_MIN_SUBNORMAL\")" );
                    ex->set_ruleName( "binary_float_min_subnormal_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_min_subnormal_key2529);
            if  (this->hasException())
            {
                goto rulebinary_float_min_subnormal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_float_min_subnormal_keyEx; /* Prevent compiler warnings */
    rulebinary_float_min_subnormal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_float_min_subnormal_key */

/**
 * $ANTLR start binary_double_min_normal_key
 * PLSQLKeys.g:480:1: binary_double_min_normal_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_double_min_normal_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:481:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:481:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE_MIN_NORMAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_DOUBLE_MIN_NORMAL\")" );
                    ex->set_ruleName( "binary_double_min_normal_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_min_normal_key2552);
            if  (this->hasException())
            {
                goto rulebinary_double_min_normal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_double_min_normal_keyEx; /* Prevent compiler warnings */
    rulebinary_double_min_normal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_double_min_normal_key */

/**
 * $ANTLR start binary_float_max_normal_key
 * PLSQLKeys.g:484:1: binary_float_max_normal_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_float_max_normal_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:485:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:485:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT_MAX_NORMAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_FLOAT_MAX_NORMAL\")" );
                    ex->set_ruleName( "binary_float_max_normal_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_max_normal_key2575);
            if  (this->hasException())
            {
                goto rulebinary_float_max_normal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_float_max_normal_keyEx; /* Prevent compiler warnings */
    rulebinary_float_max_normal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_float_max_normal_key */

/**
 * $ANTLR start positiven_key
 * PLSQLKeys.g:488:1: positiven_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::positiven_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:489:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:489:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "POSITIVEN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"POSITIVEN\")" );
                    ex->set_ruleName( "positiven_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_positiven_key2598);
            if  (this->hasException())
            {
                goto rulepositiven_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepositiven_keyEx; /* Prevent compiler warnings */
    rulepositiven_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end positiven_key */

/**
 * $ANTLR start timezone_abbr_key
 * PLSQLKeys.g:492:1: timezone_abbr_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::timezone_abbr_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:493:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:493:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_ABBR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIMEZONE_ABBR\")" );
                    ex->set_ruleName( "timezone_abbr_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timezone_abbr_key2621);
            if  (this->hasException())
            {
                goto ruletimezone_abbr_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletimezone_abbr_keyEx; /* Prevent compiler warnings */
    ruletimezone_abbr_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timezone_abbr_key */

/**
 * $ANTLR start binary_double_min_subnormal_key
 * PLSQLKeys.g:496:1: binary_double_min_subnormal_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_double_min_subnormal_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:497:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:497:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE_MIN_SUBNORMAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_DOUBLE_MIN_SUBNORMAL\")" );
                    ex->set_ruleName( "binary_double_min_subnormal_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_min_subnormal_key2644);
            if  (this->hasException())
            {
                goto rulebinary_double_min_subnormal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_double_min_subnormal_keyEx; /* Prevent compiler warnings */
    rulebinary_double_min_subnormal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_double_min_subnormal_key */

/**
 * $ANTLR start binary_float_max_subnormal_key
 * PLSQLKeys.g:500:1: binary_float_max_subnormal_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_float_max_subnormal_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:501:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:501:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT_MAX_SUBNORMAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_FLOAT_MAX_SUBNORMAL\")" );
                    ex->set_ruleName( "binary_float_max_subnormal_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_max_subnormal_key2667);
            if  (this->hasException())
            {
                goto rulebinary_float_max_subnormal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_float_max_subnormal_keyEx; /* Prevent compiler warnings */
    rulebinary_float_max_subnormal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_float_max_subnormal_key */

/**
 * $ANTLR start binary_double_key
 * PLSQLKeys.g:504:1: binary_double_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_double_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:505:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:505:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_DOUBLE\")" );
                    ex->set_ruleName( "binary_double_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_key2690);
            if  (this->hasException())
            {
                goto rulebinary_double_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_double_keyEx; /* Prevent compiler warnings */
    rulebinary_double_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_double_key */

/**
 * $ANTLR start bfile_key
 * PLSQLKeys.g:508:1: bfile_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::bfile_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:509:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:509:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BFILE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BFILE\")" );
                    ex->set_ruleName( "bfile_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_bfile_key2713);
            if  (this->hasException())
            {
                goto rulebfile_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebfile_keyEx; /* Prevent compiler warnings */
    rulebfile_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end bfile_key */

/**
 * $ANTLR start binary_double_infinity_key
 * PLSQLKeys.g:512:1: binary_double_infinity_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_double_infinity_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:513:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:513:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE_INFINITY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_DOUBLE_INFINITY\")" );
                    ex->set_ruleName( "binary_double_infinity_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_infinity_key2736);
            if  (this->hasException())
            {
                goto rulebinary_double_infinity_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_double_infinity_keyEx; /* Prevent compiler warnings */
    rulebinary_double_infinity_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_double_infinity_key */

/**
 * $ANTLR start timezone_region_key
 * PLSQLKeys.g:516:1: timezone_region_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::timezone_region_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:517:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:517:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_REGION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIMEZONE_REGION\")" );
                    ex->set_ruleName( "timezone_region_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timezone_region_key2759);
            if  (this->hasException())
            {
                goto ruletimezone_region_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletimezone_region_keyEx; /* Prevent compiler warnings */
    ruletimezone_region_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timezone_region_key */

/**
 * $ANTLR start timestamp_ltz_unconstrained_key
 * PLSQLKeys.g:520:1: timestamp_ltz_unconstrained_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::timestamp_ltz_unconstrained_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:521:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:521:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_LTZ_UNCONSTRAINED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIMESTAMP_LTZ_UNCONSTRAINED\")" );
                    ex->set_ruleName( "timestamp_ltz_unconstrained_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timestamp_ltz_unconstrained_key2782);
            if  (this->hasException())
            {
                goto ruletimestamp_ltz_unconstrained_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletimestamp_ltz_unconstrained_keyEx; /* Prevent compiler warnings */
    ruletimestamp_ltz_unconstrained_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timestamp_ltz_unconstrained_key */

/**
 * $ANTLR start naturaln_key
 * PLSQLKeys.g:524:1: naturaln_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::naturaln_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:525:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:525:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NATURALN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NATURALN\")" );
                    ex->set_ruleName( "naturaln_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_naturaln_key2805);
            if  (this->hasException())
            {
                goto rulenaturaln_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenaturaln_keyEx; /* Prevent compiler warnings */
    rulenaturaln_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end naturaln_key */

/**
 * $ANTLR start simple_integer_key
 * PLSQLKeys.g:528:1: simple_integer_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::simple_integer_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:529:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:529:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SIMPLE_INTEGER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SIMPLE_INTEGER\")" );
                    ex->set_ruleName( "simple_integer_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_simple_integer_key2828);
            if  (this->hasException())
            {
                goto rulesimple_integer_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesimple_integer_keyEx; /* Prevent compiler warnings */
    rulesimple_integer_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end simple_integer_key */

/**
 * $ANTLR start binary_double_max_subnormal_key
 * PLSQLKeys.g:532:1: binary_double_max_subnormal_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_double_max_subnormal_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:533:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:533:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE_MAX_SUBNORMAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_DOUBLE_MAX_SUBNORMAL\")" );
                    ex->set_ruleName( "binary_double_max_subnormal_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_max_subnormal_key2851);
            if  (this->hasException())
            {
                goto rulebinary_double_max_subnormal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_double_max_subnormal_keyEx; /* Prevent compiler warnings */
    rulebinary_double_max_subnormal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_double_max_subnormal_key */

/**
 * $ANTLR start byte_key
 * PLSQLKeys.g:536:1: byte_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::byte_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:537:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:537:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BYTE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BYTE\")" );
                    ex->set_ruleName( "byte_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_byte_key2874);
            if  (this->hasException())
            {
                goto rulebyte_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebyte_keyEx; /* Prevent compiler warnings */
    rulebyte_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end byte_key */

/**
 * $ANTLR start binary_float_infinity_key
 * PLSQLKeys.g:540:1: binary_float_infinity_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_float_infinity_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:541:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:541:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT_INFINITY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_FLOAT_INFINITY\")" );
                    ex->set_ruleName( "binary_float_infinity_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_infinity_key2897);
            if  (this->hasException())
            {
                goto rulebinary_float_infinity_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_float_infinity_keyEx; /* Prevent compiler warnings */
    rulebinary_float_infinity_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_float_infinity_key */

/**
 * $ANTLR start binary_float_key
 * PLSQLKeys.g:544:1: binary_float_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_float_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:545:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:545:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_FLOAT\")" );
                    ex->set_ruleName( "binary_float_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_key2920);
            if  (this->hasException())
            {
                goto rulebinary_float_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_float_keyEx; /* Prevent compiler warnings */
    rulebinary_float_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_float_key */

/**
 * $ANTLR start range_key
 * PLSQLKeys.g:548:1: range_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::range_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:549:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:549:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RANGE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RANGE\")" );
                    ex->set_ruleName( "range_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_range_key2943);
            if  (this->hasException())
            {
                goto rulerange_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerange_keyEx; /* Prevent compiler warnings */
    rulerange_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end range_key */

/**
 * $ANTLR start nclob_key
 * PLSQLKeys.g:552:1: nclob_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nclob_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:553:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:553:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NCLOB"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NCLOB\")" );
                    ex->set_ruleName( "nclob_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nclob_key2966);
            if  (this->hasException())
            {
                goto rulenclob_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenclob_keyEx; /* Prevent compiler warnings */
    rulenclob_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nclob_key */

/**
 * $ANTLR start clob_key
 * PLSQLKeys.g:556:1: clob_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::clob_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:557:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:557:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CLOB"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CLOB\")" );
                    ex->set_ruleName( "clob_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_clob_key2989);
            if  (this->hasException())
            {
                goto ruleclob_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleclob_keyEx; /* Prevent compiler warnings */
    ruleclob_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end clob_key */

/**
 * $ANTLR start dsinterval_unconstrained_key
 * PLSQLKeys.g:560:1: dsinterval_unconstrained_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::dsinterval_unconstrained_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:561:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:561:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DSINTERVAL_UNCONSTRAINED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DSINTERVAL_UNCONSTRAINED\")" );
                    ex->set_ruleName( "dsinterval_unconstrained_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dsinterval_unconstrained_key3012);
            if  (this->hasException())
            {
                goto ruledsinterval_unconstrained_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledsinterval_unconstrained_keyEx; /* Prevent compiler warnings */
    ruledsinterval_unconstrained_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dsinterval_unconstrained_key */

/**
 * $ANTLR start yminterval_unconstrained_key
 * PLSQLKeys.g:564:1: yminterval_unconstrained_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::yminterval_unconstrained_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:565:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:565:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "YMINTERVAL_UNCONSTRAINED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"YMINTERVAL_UNCONSTRAINED\")" );
                    ex->set_ruleName( "yminterval_unconstrained_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_yminterval_unconstrained_key3035);
            if  (this->hasException())
            {
                goto ruleyminterval_unconstrained_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleyminterval_unconstrained_keyEx; /* Prevent compiler warnings */
    ruleyminterval_unconstrained_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end yminterval_unconstrained_key */

/**
 * $ANTLR start rowid_key
 * PLSQLKeys.g:568:1: rowid_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rowid_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:569:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:569:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ROWID"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ROWID\")" );
                    ex->set_ruleName( "rowid_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rowid_key3058);
            if  (this->hasException())
            {
                goto rulerowid_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerowid_keyEx; /* Prevent compiler warnings */
    rulerowid_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rowid_key */

/**
 * $ANTLR start binary_double_nan_key
 * PLSQLKeys.g:572:1: binary_double_nan_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_double_nan_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:573:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:573:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE_NAN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_DOUBLE_NAN\")" );
                    ex->set_ruleName( "binary_double_nan_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_nan_key3081);
            if  (this->hasException())
            {
                goto rulebinary_double_nan_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_double_nan_keyEx; /* Prevent compiler warnings */
    rulebinary_double_nan_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_double_nan_key */

/**
 * $ANTLR start timestamp_unconstrained_key
 * PLSQLKeys.g:576:1: timestamp_unconstrained_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::timestamp_unconstrained_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:577:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:577:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP_UNCONSTRAINED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIMESTAMP_UNCONSTRAINED\")" );
                    ex->set_ruleName( "timestamp_unconstrained_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timestamp_unconstrained_key3104);
            if  (this->hasException())
            {
                goto ruletimestamp_unconstrained_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletimestamp_unconstrained_keyEx; /* Prevent compiler warnings */
    ruletimestamp_unconstrained_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timestamp_unconstrained_key */

/**
 * $ANTLR start binary_float_min_normal_key
 * PLSQLKeys.g:580:1: binary_float_min_normal_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_float_min_normal_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:581:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:581:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT_MIN_NORMAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_FLOAT_MIN_NORMAL\")" );
                    ex->set_ruleName( "binary_float_min_normal_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_min_normal_key3127);
            if  (this->hasException())
            {
                goto rulebinary_float_min_normal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_float_min_normal_keyEx; /* Prevent compiler warnings */
    rulebinary_float_min_normal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_float_min_normal_key */

/**
 * $ANTLR start signtype_key
 * PLSQLKeys.g:584:1: signtype_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::signtype_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:585:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:585:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SIGNTYPE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SIGNTYPE\")" );
                    ex->set_ruleName( "signtype_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_signtype_key3150);
            if  (this->hasException())
            {
                goto rulesigntype_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesigntype_keyEx; /* Prevent compiler warnings */
    rulesigntype_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end signtype_key */

/**
 * $ANTLR start blob_key
 * PLSQLKeys.g:588:1: blob_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::blob_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:589:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:589:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BLOB"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BLOB\")" );
                    ex->set_ruleName( "blob_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_blob_key3173);
            if  (this->hasException())
            {
                goto ruleblob_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleblob_keyEx; /* Prevent compiler warnings */
    ruleblob_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end blob_key */

/**
 * $ANTLR start nvarchar2_key
 * PLSQLKeys.g:592:1: nvarchar2_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nvarchar2_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:593:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:593:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NVARCHAR2"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NVARCHAR2\")" );
                    ex->set_ruleName( "nvarchar2_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nvarchar2_key3196);
            if  (this->hasException())
            {
                goto rulenvarchar2_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenvarchar2_keyEx; /* Prevent compiler warnings */
    rulenvarchar2_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nvarchar2_key */

/**
 * $ANTLR start binary_double_max_normal_key
 * PLSQLKeys.g:596:1: binary_double_max_normal_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_double_max_normal_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:597:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:597:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_DOUBLE_MAX_NORMAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_DOUBLE_MAX_NORMAL\")" );
                    ex->set_ruleName( "binary_double_max_normal_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_double_max_normal_key3219);
            if  (this->hasException())
            {
                goto rulebinary_double_max_normal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_double_max_normal_keyEx; /* Prevent compiler warnings */
    rulebinary_double_max_normal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_double_max_normal_key */

/**
 * $ANTLR start binary_float_nan_key
 * PLSQLKeys.g:600:1: binary_float_nan_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_float_nan_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:601:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:601:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_FLOAT_NAN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_FLOAT_NAN\")" );
                    ex->set_ruleName( "binary_float_nan_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_float_nan_key3242);
            if  (this->hasException())
            {
                goto rulebinary_float_nan_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_float_nan_keyEx; /* Prevent compiler warnings */
    rulebinary_float_nan_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_float_nan_key */

/**
 * $ANTLR start string_key
 * PLSQLKeys.g:604:1: string_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::string_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:605:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:605:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "STRING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"STRING\")" );
                    ex->set_ruleName( "string_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_string_key3265);
            if  (this->hasException())
            {
                goto rulestring_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestring_keyEx; /* Prevent compiler warnings */
    rulestring_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end string_key */

/**
 * $ANTLR start c_key
 * PLSQLKeys.g:608:1: c_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::c_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:609:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:609:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "C"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"C\")" );
                    ex->set_ruleName( "c_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_c_key3288);
            if  (this->hasException())
            {
                goto rulec_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulec_keyEx; /* Prevent compiler warnings */
    rulec_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end c_key */

/**
 * $ANTLR start library_key
 * PLSQLKeys.g:612:1: library_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::library_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:613:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:613:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LIBRARY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LIBRARY\")" );
                    ex->set_ruleName( "library_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_library_key3311);
            if  (this->hasException())
            {
                goto rulelibrary_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelibrary_keyEx; /* Prevent compiler warnings */
    rulelibrary_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end library_key */

/**
 * $ANTLR start context_key
 * PLSQLKeys.g:616:1: context_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::context_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:617:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:617:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CONTEXT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CONTEXT\")" );
                    ex->set_ruleName( "context_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_context_key3334);
            if  (this->hasException())
            {
                goto rulecontext_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecontext_keyEx; /* Prevent compiler warnings */
    rulecontext_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end context_key */

/**
 * $ANTLR start parameters_key
 * PLSQLKeys.g:620:1: parameters_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::parameters_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:621:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:621:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PARAMETERS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PARAMETERS\")" );
                    ex->set_ruleName( "parameters_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_parameters_key3357);
            if  (this->hasException())
            {
                goto ruleparameters_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleparameters_keyEx; /* Prevent compiler warnings */
    ruleparameters_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end parameters_key */

/**
 * $ANTLR start agent_key
 * PLSQLKeys.g:624:1: agent_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::agent_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:625:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:625:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AGENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AGENT\")" );
                    ex->set_ruleName( "agent_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_agent_key3380);
            if  (this->hasException())
            {
                goto ruleagent_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleagent_keyEx; /* Prevent compiler warnings */
    ruleagent_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end agent_key */

/**
 * $ANTLR start cluster_key
 * PLSQLKeys.g:628:1: cluster_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::cluster_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:629:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:629:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CLUSTER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CLUSTER\")" );
                    ex->set_ruleName( "cluster_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cluster_key3403);
            if  (this->hasException())
            {
                goto rulecluster_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecluster_keyEx; /* Prevent compiler warnings */
    rulecluster_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cluster_key */

/**
 * $ANTLR start hash_key
 * PLSQLKeys.g:632:1: hash_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::hash_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:633:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:633:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "HASH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"HASH\")" );
                    ex->set_ruleName( "hash_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_hash_key3426);
            if  (this->hasException())
            {
                goto rulehash_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulehash_keyEx; /* Prevent compiler warnings */
    rulehash_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end hash_key */

/**
 * $ANTLR start relies_on_key
 * PLSQLKeys.g:636:1: relies_on_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::relies_on_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:637:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:637:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RELIES_ON"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RELIES_ON\")" );
                    ex->set_ruleName( "relies_on_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_relies_on_key3449);
            if  (this->hasException())
            {
                goto rulerelies_on_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerelies_on_keyEx; /* Prevent compiler warnings */
    rulerelies_on_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end relies_on_key */

/**
 * $ANTLR start returning_key
 * PLSQLKeys.g:640:1: returning_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::returning_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:641:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:641:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RETURNING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RETURNING\")" );
                    ex->set_ruleName( "returning_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_returning_key3472);
            if  (this->hasException())
            {
                goto rulereturning_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereturning_keyEx; /* Prevent compiler warnings */
    rulereturning_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end returning_key */

/**
 * $ANTLR start statement_id_key
 * PLSQLKeys.g:644:1: statement_id_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::statement_id_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:645:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:645:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "STATEMENT_ID"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"STATEMENT_ID\")" );
                    ex->set_ruleName( "statement_id_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_statement_id_key3499);
            if  (this->hasException())
            {
                goto rulestatement_id_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestatement_id_keyEx; /* Prevent compiler warnings */
    rulestatement_id_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end statement_id_key */

/**
 * $ANTLR start deferred_key
 * PLSQLKeys.g:648:1: deferred_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::deferred_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:649:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:649:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DEFERRED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DEFERRED\")" );
                    ex->set_ruleName( "deferred_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_deferred_key3522);
            if  (this->hasException())
            {
                goto ruledeferred_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledeferred_keyEx; /* Prevent compiler warnings */
    ruledeferred_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end deferred_key */

/**
 * $ANTLR start advise_key
 * PLSQLKeys.g:652:1: advise_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::advise_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:653:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:653:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ADVISE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ADVISE\")" );
                    ex->set_ruleName( "advise_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_advise_key3545);
            if  (this->hasException())
            {
                goto ruleadvise_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleadvise_keyEx; /* Prevent compiler warnings */
    ruleadvise_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end advise_key */

/**
 * $ANTLR start resumable_key
 * PLSQLKeys.g:656:1: resumable_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::resumable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:657:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:657:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RESUMABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RESUMABLE\")" );
                    ex->set_ruleName( "resumable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_resumable_key3568);
            if  (this->hasException())
            {
                goto ruleresumable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleresumable_keyEx; /* Prevent compiler warnings */
    ruleresumable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end resumable_key */

/**
 * $ANTLR start timeout_key
 * PLSQLKeys.g:660:1: timeout_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::timeout_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:661:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:661:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIMEOUT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIMEOUT\")" );
                    ex->set_ruleName( "timeout_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timeout_key3591);
            if  (this->hasException())
            {
                goto ruletimeout_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletimeout_keyEx; /* Prevent compiler warnings */
    ruletimeout_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timeout_key */

/**
 * $ANTLR start parallel_key
 * PLSQLKeys.g:664:1: parallel_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::parallel_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:665:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:665:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PARALLEL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PARALLEL\")" );
                    ex->set_ruleName( "parallel_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_parallel_key3614);
            if  (this->hasException())
            {
                goto ruleparallel_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleparallel_keyEx; /* Prevent compiler warnings */
    ruleparallel_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end parallel_key */

/**
 * $ANTLR start ddl_key
 * PLSQLKeys.g:668:1: ddl_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::ddl_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:669:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:669:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DDL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DDL\")" );
                    ex->set_ruleName( "ddl_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ddl_key3637);
            if  (this->hasException())
            {
                goto ruleddl_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleddl_keyEx; /* Prevent compiler warnings */
    ruleddl_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end ddl_key */

/**
 * $ANTLR start query_key
 * PLSQLKeys.g:672:1: query_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::query_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:673:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:673:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "QUERY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"QUERY\")" );
                    ex->set_ruleName( "query_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_query_key3660);
            if  (this->hasException())
            {
                goto rulequery_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulequery_keyEx; /* Prevent compiler warnings */
    rulequery_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end query_key */

/**
 * $ANTLR start dml_key
 * PLSQLKeys.g:676:1: dml_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::dml_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:677:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:677:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DML"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DML\")" );
                    ex->set_ruleName( "dml_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dml_key3683);
            if  (this->hasException())
            {
                goto ruledml_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledml_keyEx; /* Prevent compiler warnings */
    ruledml_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dml_key */

/**
 * $ANTLR start guard_key
 * PLSQLKeys.g:680:1: guard_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::guard_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:681:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:681:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "GUARD"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"GUARD\")" );
                    ex->set_ruleName( "guard_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_guard_key3706);
            if  (this->hasException())
            {
                goto ruleguard_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleguard_keyEx; /* Prevent compiler warnings */
    ruleguard_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end guard_key */

/**
 * $ANTLR start nothing_key
 * PLSQLKeys.g:684:1: nothing_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nothing_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:685:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:685:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOTHING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOTHING\")" );
                    ex->set_ruleName( "nothing_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nothing_key3729);
            if  (this->hasException())
            {
                goto rulenothing_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenothing_keyEx; /* Prevent compiler warnings */
    rulenothing_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nothing_key */

/**
 * $ANTLR start enable_key
 * PLSQLKeys.g:688:1: enable_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::enable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:689:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:689:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ENABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ENABLE\")" );
                    ex->set_ruleName( "enable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_enable_key3752);
            if  (this->hasException())
            {
                goto ruleenable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleenable_keyEx; /* Prevent compiler warnings */
    ruleenable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end enable_key */

/**
 * $ANTLR start database_key
 * PLSQLKeys.g:692:1: database_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::database_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:693:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:693:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DATABASE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DATABASE\")" );
                    ex->set_ruleName( "database_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_database_key3775);
            if  (this->hasException())
            {
                goto ruledatabase_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledatabase_keyEx; /* Prevent compiler warnings */
    ruledatabase_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end database_key */

/**
 * $ANTLR start disable_key
 * PLSQLKeys.g:696:1: disable_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::disable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:697:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:697:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DISABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DISABLE\")" );
                    ex->set_ruleName( "disable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_disable_key3798);
            if  (this->hasException())
            {
                goto ruledisable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledisable_keyEx; /* Prevent compiler warnings */
    ruledisable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end disable_key */

/**
 * $ANTLR start link_key
 * PLSQLKeys.g:700:1: link_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::link_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:701:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:701:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LINK"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LINK\")" );
                    ex->set_ruleName( "link_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_link_key3821);
            if  (this->hasException())
            {
                goto rulelink_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelink_keyEx; /* Prevent compiler warnings */
    rulelink_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end link_key */

/**
 * $ANTLR start identified_key
 * PLSQLKeys.g:704:1: identified_key : PLSQL_RESERVED_IDENTIFIED ;
 */
void
PLSQLParser_PLSQLKeys::identified_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:705:5: ( PLSQL_RESERVED_IDENTIFIED )
        // PLSQLKeys.g:705:10: PLSQL_RESERVED_IDENTIFIED
        {
             this->matchToken(PLSQL_RESERVED_IDENTIFIED, &FOLLOW_PLSQL_RESERVED_IDENTIFIED_in_identified_key3841);
            if  (this->hasException())
            {
                goto ruleidentified_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleidentified_keyEx; /* Prevent compiler warnings */
    ruleidentified_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end identified_key */

/**
 * $ANTLR start none_key
 * PLSQLKeys.g:708:1: none_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::none_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:709:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:709:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NONE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NONE\")" );
                    ex->set_ruleName( "none_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_none_key3864);
            if  (this->hasException())
            {
                goto rulenone_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenone_keyEx; /* Prevent compiler warnings */
    rulenone_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end none_key */

/**
 * $ANTLR start before_key
 * PLSQLKeys.g:712:1: before_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::before_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:713:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:713:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BEFORE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BEFORE\")" );
                    ex->set_ruleName( "before_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_before_key3887);
            if  (this->hasException())
            {
                goto rulebefore_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebefore_keyEx; /* Prevent compiler warnings */
    rulebefore_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end before_key */

/**
 * $ANTLR start referencing_key
 * PLSQLKeys.g:716:1: referencing_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::referencing_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:717:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:717:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "REFERENCING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"REFERENCING\")" );
                    ex->set_ruleName( "referencing_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_referencing_key3911);
            if  (this->hasException())
            {
                goto rulereferencing_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereferencing_keyEx; /* Prevent compiler warnings */
    rulereferencing_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end referencing_key */

/**
 * $ANTLR start logon_key
 * PLSQLKeys.g:720:1: logon_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::logon_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:721:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:721:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LOGON"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LOGON\")" );
                    ex->set_ruleName( "logon_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_logon_key3934);
            if  (this->hasException())
            {
                goto rulelogon_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelogon_keyEx; /* Prevent compiler warnings */
    rulelogon_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end logon_key */

/**
 * $ANTLR start after_key
 * PLSQLKeys.g:724:1: after_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::after_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:725:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:725:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AFTER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AFTER\")" );
                    ex->set_ruleName( "after_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_after_key3956);
            if  (this->hasException())
            {
                goto ruleafter_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleafter_keyEx; /* Prevent compiler warnings */
    ruleafter_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end after_key */

/**
 * $ANTLR start schema_key
 * PLSQLKeys.g:728:1: schema_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::schema_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:729:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:729:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SCHEMA"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SCHEMA\")" );
                    ex->set_ruleName( "schema_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_schema_key3979);
            if  (this->hasException())
            {
                goto ruleschema_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleschema_keyEx; /* Prevent compiler warnings */
    ruleschema_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end schema_key */

/**
 * $ANTLR start grant_key
 * PLSQLKeys.g:732:1: grant_key : SQL92_RESERVED_GRANT ;
 */
void
PLSQLParser_PLSQLKeys::grant_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:733:5: ( SQL92_RESERVED_GRANT )
        // PLSQLKeys.g:733:10: SQL92_RESERVED_GRANT
        {
             this->matchToken(SQL92_RESERVED_GRANT, &FOLLOW_SQL92_RESERVED_GRANT_in_grant_key3999);
            if  (this->hasException())
            {
                goto rulegrant_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulegrant_keyEx; /* Prevent compiler warnings */
    rulegrant_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end grant_key */

/**
 * $ANTLR start truncate_key
 * PLSQLKeys.g:736:1: truncate_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::truncate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:737:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:737:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TRUNCATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TRUNCATE\")" );
                    ex->set_ruleName( "truncate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_truncate_key4022);
            if  (this->hasException())
            {
                goto ruletruncate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletruncate_keyEx; /* Prevent compiler warnings */
    ruletruncate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end truncate_key */

/**
 * $ANTLR start startup_key
 * PLSQLKeys.g:740:1: startup_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::startup_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:741:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:741:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "STARTUP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"STARTUP\")" );
                    ex->set_ruleName( "startup_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_startup_key4045);
            if  (this->hasException())
            {
                goto rulestartup_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestartup_keyEx; /* Prevent compiler warnings */
    rulestartup_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end startup_key */

/**
 * $ANTLR start statistics_key
 * PLSQLKeys.g:744:1: statistics_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::statistics_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:745:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:745:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "STATISTICS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"STATISTICS\")" );
                    ex->set_ruleName( "statistics_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_statistics_key4068);
            if  (this->hasException())
            {
                goto rulestatistics_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestatistics_keyEx; /* Prevent compiler warnings */
    rulestatistics_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end statistics_key */

/**
 * $ANTLR start noaudit_key
 * PLSQLKeys.g:748:1: noaudit_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::noaudit_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:749:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:749:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOAUDIT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOAUDIT\")" );
                    ex->set_ruleName( "noaudit_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_noaudit_key4091);
            if  (this->hasException())
            {
                goto rulenoaudit_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenoaudit_keyEx; /* Prevent compiler warnings */
    rulenoaudit_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end noaudit_key */

/**
 * $ANTLR start suspend_key
 * PLSQLKeys.g:752:1: suspend_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::suspend_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:753:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:753:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SUSPEND"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SUSPEND\")" );
                    ex->set_ruleName( "suspend_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_suspend_key4114);
            if  (this->hasException())
            {
                goto rulesuspend_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesuspend_keyEx; /* Prevent compiler warnings */
    rulesuspend_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end suspend_key */

/**
 * $ANTLR start audit_key
 * PLSQLKeys.g:756:1: audit_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::audit_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:757:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:757:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AUDIT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AUDIT\")" );
                    ex->set_ruleName( "audit_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_audit_key4137);
            if  (this->hasException())
            {
                goto ruleaudit_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleaudit_keyEx; /* Prevent compiler warnings */
    ruleaudit_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end audit_key */

/**
 * $ANTLR start disassociate_key
 * PLSQLKeys.g:760:1: disassociate_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::disassociate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:761:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:761:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DISASSOCIATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DISASSOCIATE\")" );
                    ex->set_ruleName( "disassociate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_disassociate_key4160);
            if  (this->hasException())
            {
                goto ruledisassociate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledisassociate_keyEx; /* Prevent compiler warnings */
    ruledisassociate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end disassociate_key */

/**
 * $ANTLR start shutdown_key
 * PLSQLKeys.g:764:1: shutdown_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::shutdown_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:765:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:765:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SHUTDOWN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SHUTDOWN\")" );
                    ex->set_ruleName( "shutdown_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_shutdown_key4184);
            if  (this->hasException())
            {
                goto ruleshutdown_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleshutdown_keyEx; /* Prevent compiler warnings */
    ruleshutdown_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end shutdown_key */

/**
 * $ANTLR start compound_key
 * PLSQLKeys.g:768:1: compound_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::compound_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:769:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:769:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COMPOUND"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COMPOUND\")" );
                    ex->set_ruleName( "compound_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_compound_key4207);
            if  (this->hasException())
            {
                goto rulecompound_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecompound_keyEx; /* Prevent compiler warnings */
    rulecompound_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end compound_key */

/**
 * $ANTLR start servererror_key
 * PLSQLKeys.g:772:1: servererror_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::servererror_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:773:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:773:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SERVERERROR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SERVERERROR\")" );
                    ex->set_ruleName( "servererror_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_servererror_key4230);
            if  (this->hasException())
            {
                goto ruleservererror_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleservererror_keyEx; /* Prevent compiler warnings */
    ruleservererror_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end servererror_key */

/**
 * $ANTLR start parent_key
 * PLSQLKeys.g:776:1: parent_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::parent_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:777:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:777:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PARENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PARENT\")" );
                    ex->set_ruleName( "parent_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_parent_key4253);
            if  (this->hasException())
            {
                goto ruleparent_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleparent_keyEx; /* Prevent compiler warnings */
    ruleparent_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end parent_key */

/**
 * $ANTLR start follows_key
 * PLSQLKeys.g:780:1: follows_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::follows_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:781:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:781:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FOLLOWS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FOLLOWS\")" );
                    ex->set_ruleName( "follows_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_follows_key4276);
            if  (this->hasException())
            {
                goto rulefollows_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefollows_keyEx; /* Prevent compiler warnings */
    rulefollows_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end follows_key */

/**
 * $ANTLR start nested_key
 * PLSQLKeys.g:784:1: nested_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nested_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:785:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:785:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NESTED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NESTED\")" );
                    ex->set_ruleName( "nested_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nested_key4299);
            if  (this->hasException())
            {
                goto rulenested_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenested_keyEx; /* Prevent compiler warnings */
    rulenested_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nested_key */

/**
 * $ANTLR start old_key
 * PLSQLKeys.g:788:1: old_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::old_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:789:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:789:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OLD"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OLD\")" );
                    ex->set_ruleName( "old_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_old_key4322);
            if  (this->hasException())
            {
                goto ruleold_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleold_keyEx; /* Prevent compiler warnings */
    ruleold_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end old_key */

/**
 * $ANTLR start statement_key
 * PLSQLKeys.g:792:1: statement_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::statement_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:793:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:793:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "STATEMENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"STATEMENT\")" );
                    ex->set_ruleName( "statement_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_statement_key4345);
            if  (this->hasException())
            {
                goto rulestatement_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestatement_keyEx; /* Prevent compiler warnings */
    rulestatement_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end statement_key */

/**
 * $ANTLR start db_role_change_key
 * PLSQLKeys.g:796:1: db_role_change_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::db_role_change_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:797:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:797:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DB_ROLE_CHANGE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DB_ROLE_CHANGE\")" );
                    ex->set_ruleName( "db_role_change_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_db_role_change_key4368);
            if  (this->hasException())
            {
                goto ruledb_role_change_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledb_role_change_keyEx; /* Prevent compiler warnings */
    ruledb_role_change_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end db_role_change_key */

/**
 * $ANTLR start each_key
 * PLSQLKeys.g:800:1: each_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::each_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:801:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:801:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EACH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EACH\")" );
                    ex->set_ruleName( "each_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_each_key4391);
            if  (this->hasException())
            {
                goto ruleeach_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleeach_keyEx; /* Prevent compiler warnings */
    ruleeach_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end each_key */

/**
 * $ANTLR start logoff_key
 * PLSQLKeys.g:804:1: logoff_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::logoff_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:805:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:805:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LOGOFF"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LOGOFF\")" );
                    ex->set_ruleName( "logoff_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_logoff_key4414);
            if  (this->hasException())
            {
                goto rulelogoff_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelogoff_keyEx; /* Prevent compiler warnings */
    rulelogoff_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end logoff_key */

/**
 * $ANTLR start analyze_key
 * PLSQLKeys.g:808:1: analyze_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::analyze_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:809:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:809:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ANALYZE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ANALYZE\")" );
                    ex->set_ruleName( "analyze_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_analyze_key4437);
            if  (this->hasException())
            {
                goto ruleanalyze_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleanalyze_keyEx; /* Prevent compiler warnings */
    ruleanalyze_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end analyze_key */

/**
 * $ANTLR start instead_key
 * PLSQLKeys.g:812:1: instead_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::instead_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:813:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:813:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INSTEAD"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INSTEAD\")" );
                    ex->set_ruleName( "instead_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_instead_key4460);
            if  (this->hasException())
            {
                goto ruleinstead_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinstead_keyEx; /* Prevent compiler warnings */
    ruleinstead_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end instead_key */

/**
 * $ANTLR start associate_key
 * PLSQLKeys.g:816:1: associate_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::associate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:817:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:817:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ASSOCIATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ASSOCIATE\")" );
                    ex->set_ruleName( "associate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_associate_key4483);
            if  (this->hasException())
            {
                goto ruleassociate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleassociate_keyEx; /* Prevent compiler warnings */
    ruleassociate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end associate_key */

/**
 * $ANTLR start new_key
 * PLSQLKeys.g:820:1: new_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::new_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:821:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:821:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NEW"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NEW\")" );
                    ex->set_ruleName( "new_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_new_key4506);
            if  (this->hasException())
            {
                goto rulenew_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenew_keyEx; /* Prevent compiler warnings */
    rulenew_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end new_key */

/**
 * $ANTLR start revoke_key
 * PLSQLKeys.g:824:1: revoke_key : SQL92_RESERVED_REVOKE ;
 */
void
PLSQLParser_PLSQLKeys::revoke_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:825:5: ( SQL92_RESERVED_REVOKE )
        // PLSQLKeys.g:825:10: SQL92_RESERVED_REVOKE
        {
             this->matchToken(SQL92_RESERVED_REVOKE, &FOLLOW_SQL92_RESERVED_REVOKE_in_revoke_key4526);
            if  (this->hasException())
            {
                goto rulerevoke_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerevoke_keyEx; /* Prevent compiler warnings */
    rulerevoke_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end revoke_key */

/**
 * $ANTLR start rename_key
 * PLSQLKeys.g:828:1: rename_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rename_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:829:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:829:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RENAME"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RENAME\")" );
                    ex->set_ruleName( "rename_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rename_key4549);
            if  (this->hasException())
            {
                goto rulerename_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerename_keyEx; /* Prevent compiler warnings */
    rulerename_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rename_key */

/**
 * $ANTLR start customdatum_key
 * PLSQLKeys.g:832:1: customdatum_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::customdatum_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:833:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:833:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CUSTOMDATUM"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CUSTOMDATUM\")" );
                    ex->set_ruleName( "customdatum_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_customdatum_key4573);
            if  (this->hasException())
            {
                goto rulecustomdatum_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecustomdatum_keyEx; /* Prevent compiler warnings */
    rulecustomdatum_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end customdatum_key */

/**
 * $ANTLR start oradata_key
 * PLSQLKeys.g:836:1: oradata_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::oradata_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:837:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:837:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ORADATA"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ORADATA\")" );
                    ex->set_ruleName( "oradata_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_oradata_key4596);
            if  (this->hasException())
            {
                goto ruleoradata_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleoradata_keyEx; /* Prevent compiler warnings */
    ruleoradata_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end oradata_key */

/**
 * $ANTLR start constructor_key
 * PLSQLKeys.g:840:1: constructor_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::constructor_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:841:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:841:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CONSTRUCTOR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CONSTRUCTOR\")" );
                    ex->set_ruleName( "constructor_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_constructor_key4619);
            if  (this->hasException())
            {
                goto ruleconstructor_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconstructor_keyEx; /* Prevent compiler warnings */
    ruleconstructor_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end constructor_key */

/**
 * $ANTLR start sqldata_key
 * PLSQLKeys.g:844:1: sqldata_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sqldata_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:845:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:845:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SQLDATA"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SQLDATA\")" );
                    ex->set_ruleName( "sqldata_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sqldata_key4642);
            if  (this->hasException())
            {
                goto rulesqldata_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesqldata_keyEx; /* Prevent compiler warnings */
    rulesqldata_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sqldata_key */

/**
 * $ANTLR start member_key
 * PLSQLKeys.g:848:1: member_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::member_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:849:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:849:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MEMBER\")" );
                    ex->set_ruleName( "member_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_member_key4665);
            if  (this->hasException())
            {
                goto rulemember_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemember_keyEx; /* Prevent compiler warnings */
    rulemember_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end member_key */

/**
 * $ANTLR start self_key
 * PLSQLKeys.g:852:1: self_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::self_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:853:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:853:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SELF"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SELF\")" );
                    ex->set_ruleName( "self_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_self_key4688);
            if  (this->hasException())
            {
                goto ruleself_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleself_keyEx; /* Prevent compiler warnings */
    ruleself_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end self_key */

/**
 * $ANTLR start object_key
 * PLSQLKeys.g:856:1: object_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::object_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:857:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:857:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OBJECT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OBJECT\")" );
                    ex->set_ruleName( "object_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_object_key4711);
            if  (this->hasException())
            {
                goto ruleobject_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleobject_keyEx; /* Prevent compiler warnings */
    ruleobject_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end object_key */

/**
 * $ANTLR start variable_key
 * PLSQLKeys.g:860:1: variable_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::variable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:861:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:861:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VARIABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VARIABLE\")" );
                    ex->set_ruleName( "variable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_variable_key4734);
            if  (this->hasException())
            {
                goto rulevariable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevariable_keyEx; /* Prevent compiler warnings */
    rulevariable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end variable_key */

/**
 * $ANTLR start instantiable_key
 * PLSQLKeys.g:864:1: instantiable_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::instantiable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:865:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:865:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INSTANTIABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INSTANTIABLE\")" );
                    ex->set_ruleName( "instantiable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_instantiable_key4757);
            if  (this->hasException())
            {
                goto ruleinstantiable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinstantiable_keyEx; /* Prevent compiler warnings */
    ruleinstantiable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end instantiable_key */

/**
 * $ANTLR start final_key
 * PLSQLKeys.g:868:1: final_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::final_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:869:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:869:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FINAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FINAL\")" );
                    ex->set_ruleName( "final_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_final_key4780);
            if  (this->hasException())
            {
                goto rulefinal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefinal_keyEx; /* Prevent compiler warnings */
    rulefinal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end final_key */

/**
 * $ANTLR start static_key
 * PLSQLKeys.g:872:1: static_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::static_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:873:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:873:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "STATIC"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"STATIC\")" );
                    ex->set_ruleName( "static_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_static_key4803);
            if  (this->hasException())
            {
                goto rulestatic_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestatic_keyEx; /* Prevent compiler warnings */
    rulestatic_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end static_key */

/**
 * $ANTLR start oid_key
 * PLSQLKeys.g:876:1: oid_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::oid_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:877:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:877:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OID"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OID\")" );
                    ex->set_ruleName( "oid_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_oid_key4826);
            if  (this->hasException())
            {
                goto ruleoid_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleoid_keyEx; /* Prevent compiler warnings */
    ruleoid_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end oid_key */

/**
 * $ANTLR start result_key
 * PLSQLKeys.g:880:1: result_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::result_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:881:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:881:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RESULT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RESULT\")" );
                    ex->set_ruleName( "result_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_result_key4849);
            if  (this->hasException())
            {
                goto ruleresult_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleresult_keyEx; /* Prevent compiler warnings */
    ruleresult_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end result_key */

/**
 * $ANTLR start under_key
 * PLSQLKeys.g:884:1: under_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::under_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:885:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:885:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UNDER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UNDER\")" );
                    ex->set_ruleName( "under_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_under_key4872);
            if  (this->hasException())
            {
                goto ruleunder_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunder_keyEx; /* Prevent compiler warnings */
    ruleunder_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end under_key */

/**
 * $ANTLR start map_key
 * PLSQLKeys.g:888:1: map_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::map_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:889:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:889:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MAP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MAP\")" );
                    ex->set_ruleName( "map_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_map_key4895);
            if  (this->hasException())
            {
                goto rulemap_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemap_keyEx; /* Prevent compiler warnings */
    rulemap_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end map_key */

/**
 * $ANTLR start overriding_key
 * PLSQLKeys.g:892:1: overriding_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::overriding_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:893:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:893:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OVERRIDING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OVERRIDING\")" );
                    ex->set_ruleName( "overriding_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_overriding_key4918);
            if  (this->hasException())
            {
                goto ruleoverriding_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleoverriding_keyEx; /* Prevent compiler warnings */
    ruleoverriding_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end overriding_key */

/**
 * $ANTLR start add_key
 * PLSQLKeys.g:896:1: add_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::add_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:897:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:897:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ADD"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ADD\")" );
                    ex->set_ruleName( "add_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_add_key4941);
            if  (this->hasException())
            {
                goto ruleadd_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleadd_keyEx; /* Prevent compiler warnings */
    ruleadd_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end add_key */

/**
 * $ANTLR start modify_key
 * PLSQLKeys.g:900:1: modify_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::modify_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:901:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:901:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MODIFY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MODIFY\")" );
                    ex->set_ruleName( "modify_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_modify_key4964);
            if  (this->hasException())
            {
                goto rulemodify_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodify_keyEx; /* Prevent compiler warnings */
    rulemodify_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end modify_key */

/**
 * $ANTLR start including_key
 * PLSQLKeys.g:904:1: including_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::including_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:905:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:905:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INCLUDING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INCLUDING\")" );
                    ex->set_ruleName( "including_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_including_key4987);
            if  (this->hasException())
            {
                goto ruleincluding_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleincluding_keyEx; /* Prevent compiler warnings */
    ruleincluding_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end including_key */

/**
 * $ANTLR start substitutable_key
 * PLSQLKeys.g:908:1: substitutable_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::substitutable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:909:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:909:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SUBSTITUTABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SUBSTITUTABLE\")" );
                    ex->set_ruleName( "substitutable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_substitutable_key5010);
            if  (this->hasException())
            {
                goto rulesubstitutable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubstitutable_keyEx; /* Prevent compiler warnings */
    rulesubstitutable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end substitutable_key */

/**
 * $ANTLR start attribute_key
 * PLSQLKeys.g:912:1: attribute_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::attribute_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:913:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:913:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ATTRIBUTE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ATTRIBUTE\")" );
                    ex->set_ruleName( "attribute_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_attribute_key5033);
            if  (this->hasException())
            {
                goto ruleattribute_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleattribute_keyEx; /* Prevent compiler warnings */
    ruleattribute_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end attribute_key */

/**
 * $ANTLR start cascade_key
 * PLSQLKeys.g:916:1: cascade_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::cascade_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:917:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:917:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CASCADE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CASCADE\")" );
                    ex->set_ruleName( "cascade_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cascade_key5056);
            if  (this->hasException())
            {
                goto rulecascade_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecascade_keyEx; /* Prevent compiler warnings */
    rulecascade_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cascade_key */

/**
 * $ANTLR start data_key
 * PLSQLKeys.g:920:1: data_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::data_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:921:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:921:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DATA"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DATA\")" );
                    ex->set_ruleName( "data_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_data_key5080);
            if  (this->hasException())
            {
                goto ruledata_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledata_keyEx; /* Prevent compiler warnings */
    ruledata_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end data_key */

/**
 * $ANTLR start invalidate_key
 * PLSQLKeys.g:924:1: invalidate_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::invalidate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:925:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:925:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INVALIDATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INVALIDATE\")" );
                    ex->set_ruleName( "invalidate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_invalidate_key5102);
            if  (this->hasException())
            {
                goto ruleinvalidate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinvalidate_keyEx; /* Prevent compiler warnings */
    ruleinvalidate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end invalidate_key */

/**
 * $ANTLR start element_key
 * PLSQLKeys.g:928:1: element_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::element_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:929:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:929:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ELEMENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ELEMENT\")" );
                    ex->set_ruleName( "element_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_element_key5125);
            if  (this->hasException())
            {
                goto ruleelement_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleelement_keyEx; /* Prevent compiler warnings */
    ruleelement_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end element_key */

/**
 * $ANTLR start first_key
 * PLSQLKeys.g:932:1: first_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::first_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:933:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:933:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FIRST"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FIRST\")" );
                    ex->set_ruleName( "first_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_first_key5148);
            if  (this->hasException())
            {
                goto rulefirst_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefirst_keyEx; /* Prevent compiler warnings */
    rulefirst_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end first_key */

/**
 * $ANTLR start check_key
 * PLSQLKeys.g:936:1: check_key : SQL92_RESERVED_CHECK ;
 */
void
PLSQLParser_PLSQLKeys::check_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:937:5: ( SQL92_RESERVED_CHECK )
        // PLSQLKeys.g:937:10: SQL92_RESERVED_CHECK
        {
             this->matchToken(SQL92_RESERVED_CHECK, &FOLLOW_SQL92_RESERVED_CHECK_in_check_key5168);
            if  (this->hasException())
            {
                goto rulecheck_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecheck_keyEx; /* Prevent compiler warnings */
    rulecheck_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end check_key */

/**
 * $ANTLR start option_key
 * PLSQLKeys.g:940:1: option_key : SQL92_RESERVED_OPTION ;
 */
void
PLSQLParser_PLSQLKeys::option_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:941:5: ( SQL92_RESERVED_OPTION )
        // PLSQLKeys.g:941:10: SQL92_RESERVED_OPTION
        {
             this->matchToken(SQL92_RESERVED_OPTION, &FOLLOW_SQL92_RESERVED_OPTION_in_option_key5188);
            if  (this->hasException())
            {
                goto ruleoption_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleoption_keyEx; /* Prevent compiler warnings */
    ruleoption_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end option_key */

/**
 * $ANTLR start nocycle_key
 * PLSQLKeys.g:944:1: nocycle_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nocycle_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:945:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:945:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOCYCLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOCYCLE\")" );
                    ex->set_ruleName( "nocycle_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nocycle_key5211);
            if  (this->hasException())
            {
                goto rulenocycle_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenocycle_keyEx; /* Prevent compiler warnings */
    rulenocycle_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nocycle_key */

/**
 * $ANTLR start locked_key
 * PLSQLKeys.g:948:1: locked_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::locked_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:949:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:949:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LOCKED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LOCKED\")" );
                    ex->set_ruleName( "locked_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_locked_key5234);
            if  (this->hasException())
            {
                goto rulelocked_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelocked_keyEx; /* Prevent compiler warnings */
    rulelocked_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end locked_key */

/**
 * $ANTLR start block_key
 * PLSQLKeys.g:952:1: block_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::block_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:953:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:953:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BLOCK"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BLOCK\")" );
                    ex->set_ruleName( "block_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_block_key5257);
            if  (this->hasException())
            {
                goto ruleblock_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleblock_keyEx; /* Prevent compiler warnings */
    ruleblock_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end block_key */

/**
 * $ANTLR start xml_key
 * PLSQLKeys.g:956:1: xml_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xml_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:957:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:957:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XML"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XML\")" );
                    ex->set_ruleName( "xml_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xml_key5280);
            if  (this->hasException())
            {
                goto rulexml_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexml_keyEx; /* Prevent compiler warnings */
    rulexml_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xml_key */

/**
 * $ANTLR start pivot_key
 * PLSQLKeys.g:960:1: pivot_key : PLSQL_NON_RESERVED_PIVOT ;
 */
void
PLSQLParser_PLSQLKeys::pivot_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:961:5: ( PLSQL_NON_RESERVED_PIVOT )
        // PLSQLKeys.g:961:11: PLSQL_NON_RESERVED_PIVOT
        {
             this->matchToken(PLSQL_NON_RESERVED_PIVOT, &FOLLOW_PLSQL_NON_RESERVED_PIVOT_in_pivot_key5301);
            if  (this->hasException())
            {
                goto rulepivot_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepivot_keyEx; /* Prevent compiler warnings */
    rulepivot_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pivot_key */

/**
 * $ANTLR start prior_key
 * PLSQLKeys.g:964:1: prior_key : SQL92_RESERVED_PRIOR ;
 */
void
PLSQLParser_PLSQLKeys::prior_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:965:5: ( SQL92_RESERVED_PRIOR )
        // PLSQLKeys.g:965:10: SQL92_RESERVED_PRIOR
        {
             this->matchToken(SQL92_RESERVED_PRIOR, &FOLLOW_SQL92_RESERVED_PRIOR_in_prior_key5321);
            if  (this->hasException())
            {
                goto ruleprior_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprior_keyEx; /* Prevent compiler warnings */
    ruleprior_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prior_key */

/**
 * $ANTLR start sequential_key
 * PLSQLKeys.g:968:1: sequential_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sequential_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:969:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:969:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SEQUENTIAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SEQUENTIAL\")" );
                    ex->set_ruleName( "sequential_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sequential_key5344);
            if  (this->hasException())
            {
                goto rulesequential_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesequential_keyEx; /* Prevent compiler warnings */
    rulesequential_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sequential_key */

/**
 * $ANTLR start single_key
 * PLSQLKeys.g:972:1: single_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::single_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:973:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:973:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SINGLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SINGLE\")" );
                    ex->set_ruleName( "single_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_single_key5367);
            if  (this->hasException())
            {
                goto rulesingle_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesingle_keyEx; /* Prevent compiler warnings */
    rulesingle_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end single_key */

/**
 * $ANTLR start skip_key
 * PLSQLKeys.g:976:1: skip_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::skip_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:977:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:977:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SKIP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SKIP\")" );
                    ex->set_ruleName( "skip_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_skip_key5390);
            if  (this->hasException())
            {
                goto ruleskip_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleskip_keyEx; /* Prevent compiler warnings */
    ruleskip_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end skip_key */

/**
 * $ANTLR start model_key
 * PLSQLKeys.g:980:1: model_key : PLSQL_NON_RESERVED_MODEL ;
 */
void
PLSQLParser_PLSQLKeys::model_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:981:5: ( PLSQL_NON_RESERVED_MODEL )
        // PLSQLKeys.g:982:9: PLSQL_NON_RESERVED_MODEL
        {
             this->matchToken(PLSQL_NON_RESERVED_MODEL, &FOLLOW_PLSQL_NON_RESERVED_MODEL_in_model_key5419);
            if  (this->hasException())
            {
                goto rulemodel_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_keyEx; /* Prevent compiler warnings */
    rulemodel_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_key */

/**
 * $ANTLR start updated_key
 * PLSQLKeys.g:985:1: updated_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::updated_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:986:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:986:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UPDATED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UPDATED\")" );
                    ex->set_ruleName( "updated_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_updated_key5442);
            if  (this->hasException())
            {
                goto ruleupdated_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleupdated_keyEx; /* Prevent compiler warnings */
    ruleupdated_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end updated_key */

/**
 * $ANTLR start increment_key
 * PLSQLKeys.g:989:1: increment_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::increment_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:990:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:990:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INCREMENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INCREMENT\")" );
                    ex->set_ruleName( "increment_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_increment_key5465);
            if  (this->hasException())
            {
                goto ruleincrement_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleincrement_keyEx; /* Prevent compiler warnings */
    ruleincrement_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end increment_key */

/**
 * $ANTLR start exclude_key
 * PLSQLKeys.g:993:1: exclude_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::exclude_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:994:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:994:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXCLUDE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXCLUDE\")" );
                    ex->set_ruleName( "exclude_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_exclude_key5488);
            if  (this->hasException())
            {
                goto ruleexclude_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexclude_keyEx; /* Prevent compiler warnings */
    ruleexclude_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exclude_key */

/**
 * $ANTLR start reference_key
 * PLSQLKeys.g:997:1: reference_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::reference_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:998:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:998:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "REFERENCE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"REFERENCE\")" );
                    ex->set_ruleName( "reference_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_reference_key5511);
            if  (this->hasException())
            {
                goto rulereference_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereference_keyEx; /* Prevent compiler warnings */
    rulereference_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end reference_key */

/**
 * $ANTLR start sets_key
 * PLSQLKeys.g:1001:1: sets_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sets_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1002:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1002:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SETS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SETS\")" );
                    ex->set_ruleName( "sets_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sets_key5534);
            if  (this->hasException())
            {
                goto rulesets_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesets_keyEx; /* Prevent compiler warnings */
    rulesets_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sets_key */

/**
 * $ANTLR start until_key
 * PLSQLKeys.g:1005:1: until_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::until_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1006:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1006:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UNTIL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UNTIL\")" );
                    ex->set_ruleName( "until_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_until_key5557);
            if  (this->hasException())
            {
                goto ruleuntil_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleuntil_keyEx; /* Prevent compiler warnings */
    ruleuntil_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end until_key */

/**
 * $ANTLR start seed_key
 * PLSQLKeys.g:1009:1: seed_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::seed_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1010:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1010:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SEED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SEED\")" );
                    ex->set_ruleName( "seed_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_seed_key5580);
            if  (this->hasException())
            {
                goto ruleseed_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleseed_keyEx; /* Prevent compiler warnings */
    ruleseed_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end seed_key */

/**
 * $ANTLR start maxvalue_key
 * PLSQLKeys.g:1013:1: maxvalue_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::maxvalue_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1014:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1014:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MAXVALUE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MAXVALUE\")" );
                    ex->set_ruleName( "maxvalue_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_maxvalue_key5603);
            if  (this->hasException())
            {
                goto rulemaxvalue_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemaxvalue_keyEx; /* Prevent compiler warnings */
    rulemaxvalue_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end maxvalue_key */

/**
 * $ANTLR start siblings_key
 * PLSQLKeys.g:1017:1: siblings_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::siblings_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1018:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1018:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SIBLINGS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SIBLINGS\")" );
                    ex->set_ruleName( "siblings_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_siblings_key5626);
            if  (this->hasException())
            {
                goto rulesiblings_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesiblings_keyEx; /* Prevent compiler warnings */
    rulesiblings_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end siblings_key */

/**
 * $ANTLR start cube_key
 * PLSQLKeys.g:1021:1: cube_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::cube_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1022:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1022:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CUBE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CUBE\")" );
                    ex->set_ruleName( "cube_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cube_key5649);
            if  (this->hasException())
            {
                goto rulecube_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecube_keyEx; /* Prevent compiler warnings */
    rulecube_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cube_key */

/**
 * $ANTLR start nulls_key
 * PLSQLKeys.g:1025:1: nulls_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nulls_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1026:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1026:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NULLS\")" );
                    ex->set_ruleName( "nulls_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nulls_key5672);
            if  (this->hasException())
            {
                goto rulenulls_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenulls_keyEx; /* Prevent compiler warnings */
    rulenulls_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nulls_key */

/**
 * $ANTLR start dimension_key
 * PLSQLKeys.g:1029:1: dimension_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::dimension_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1030:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1030:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DIMENSION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DIMENSION\")" );
                    ex->set_ruleName( "dimension_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dimension_key5695);
            if  (this->hasException())
            {
                goto ruledimension_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledimension_keyEx; /* Prevent compiler warnings */
    ruledimension_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dimension_key */

/**
 * $ANTLR start scn_key
 * PLSQLKeys.g:1033:1: scn_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::scn_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1034:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1034:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SCN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SCN\")" );
                    ex->set_ruleName( "scn_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_scn_key5718);
            if  (this->hasException())
            {
                goto rulescn_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulescn_keyEx; /* Prevent compiler warnings */
    rulescn_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end scn_key */

/**
 * $ANTLR start snapshot_key
 * PLSQLKeys.g:1037:1: snapshot_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::snapshot_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1038:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1038:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SNAPSHOT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SNAPSHOT\")" );
                    ex->set_ruleName( "snapshot_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_snapshot_key5741);
            if  (this->hasException())
            {
                goto rulesnapshot_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesnapshot_keyEx; /* Prevent compiler warnings */
    rulesnapshot_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end snapshot_key */

/**
 * $ANTLR start decrement_key
 * PLSQLKeys.g:1041:1: decrement_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::decrement_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1042:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1042:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DECREMENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DECREMENT\")" );
                    ex->set_ruleName( "decrement_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_decrement_key5764);
            if  (this->hasException())
            {
                goto ruledecrement_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledecrement_keyEx; /* Prevent compiler warnings */
    ruledecrement_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end decrement_key */

/**
 * $ANTLR start unpivot_key
 * PLSQLKeys.g:1045:1: unpivot_key : PLSQL_NON_RESERVED_UNPIVOT ;
 */
void
PLSQLParser_PLSQLKeys::unpivot_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1046:5: ( PLSQL_NON_RESERVED_UNPIVOT )
        // PLSQLKeys.g:1046:10: PLSQL_NON_RESERVED_UNPIVOT
        {
             this->matchToken(PLSQL_NON_RESERVED_UNPIVOT, &FOLLOW_PLSQL_NON_RESERVED_UNPIVOT_in_unpivot_key5784);
            if  (this->hasException())
            {
                goto ruleunpivot_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunpivot_keyEx; /* Prevent compiler warnings */
    ruleunpivot_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unpivot_key */

/**
 * $ANTLR start keep_key
 * PLSQLKeys.g:1049:1: keep_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::keep_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1050:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1050:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "KEEP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"KEEP\")" );
                    ex->set_ruleName( "keep_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_keep_key5807);
            if  (this->hasException())
            {
                goto rulekeep_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulekeep_keyEx; /* Prevent compiler warnings */
    rulekeep_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end keep_key */

/**
 * $ANTLR start measures_key
 * PLSQLKeys.g:1053:1: measures_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::measures_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1054:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1054:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MEASURES"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MEASURES\")" );
                    ex->set_ruleName( "measures_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_measures_key5830);
            if  (this->hasException())
            {
                goto rulemeasures_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemeasures_keyEx; /* Prevent compiler warnings */
    rulemeasures_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end measures_key */

/**
 * $ANTLR start rows_key
 * PLSQLKeys.g:1057:1: rows_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rows_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1058:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1058:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ROWS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ROWS\")" );
                    ex->set_ruleName( "rows_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rows_key5853);
            if  (this->hasException())
            {
                goto rulerows_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerows_keyEx; /* Prevent compiler warnings */
    rulerows_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rows_key */

/**
 * $ANTLR start sample_key
 * PLSQLKeys.g:1061:1: sample_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sample_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1062:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1062:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SAMPLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SAMPLE\")" );
                    ex->set_ruleName( "sample_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sample_key5876);
            if  (this->hasException())
            {
                goto rulesample_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesample_keyEx; /* Prevent compiler warnings */
    rulesample_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sample_key */

/**
 * $ANTLR start upsert_key
 * PLSQLKeys.g:1065:1: upsert_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::upsert_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1066:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1066:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UPSERT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UPSERT\")" );
                    ex->set_ruleName( "upsert_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_upsert_key5899);
            if  (this->hasException())
            {
                goto ruleupsert_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleupsert_keyEx; /* Prevent compiler warnings */
    ruleupsert_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end upsert_key */

/**
 * $ANTLR start versions_key
 * PLSQLKeys.g:1069:1: versions_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::versions_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1070:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1070:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VERSIONS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VERSIONS\")" );
                    ex->set_ruleName( "versions_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_versions_key5922);
            if  (this->hasException())
            {
                goto ruleversions_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleversions_keyEx; /* Prevent compiler warnings */
    ruleversions_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end versions_key */

/**
 * $ANTLR start rules_key
 * PLSQLKeys.g:1073:1: rules_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rules_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1074:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1074:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RULES"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RULES\")" );
                    ex->set_ruleName( "rules_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rules_key5945);
            if  (this->hasException())
            {
                goto rulerules_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerules_keyEx; /* Prevent compiler warnings */
    rulerules_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rules_key */

/**
 * $ANTLR start iterate_key
 * PLSQLKeys.g:1077:1: iterate_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::iterate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1078:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1078:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ITERATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ITERATE\")" );
                    ex->set_ruleName( "iterate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_iterate_key5968);
            if  (this->hasException())
            {
                goto ruleiterate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleiterate_keyEx; /* Prevent compiler warnings */
    ruleiterate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end iterate_key */

/**
 * $ANTLR start minvalue_key
 * PLSQLKeys.g:1081:1: minvalue_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::minvalue_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1082:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1082:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MINVALUE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MINVALUE\")" );
                    ex->set_ruleName( "minvalue_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_minvalue_key5991);
            if  (this->hasException())
            {
                goto ruleminvalue_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleminvalue_keyEx; /* Prevent compiler warnings */
    ruleminvalue_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end minvalue_key */

/**
 * $ANTLR start rollup_key
 * PLSQLKeys.g:1085:1: rollup_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rollup_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1086:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1086:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ROLLUP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ROLLUP\")" );
                    ex->set_ruleName( "rollup_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rollup_key6014);
            if  (this->hasException())
            {
                goto rulerollup_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerollup_keyEx; /* Prevent compiler warnings */
    rulerollup_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rollup_key */

/**
 * $ANTLR start nav_key
 * PLSQLKeys.g:1089:1: nav_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nav_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1090:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1090:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NAV"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NAV\")" );
                    ex->set_ruleName( "nav_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nav_key6037);
            if  (this->hasException())
            {
                goto rulenav_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenav_keyEx; /* Prevent compiler warnings */
    rulenav_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nav_key */

/**
 * $ANTLR start automatic_key
 * PLSQLKeys.g:1093:1: automatic_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::automatic_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1094:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1094:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AUTOMATIC"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AUTOMATIC\")" );
                    ex->set_ruleName( "automatic_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_automatic_key6060);
            if  (this->hasException())
            {
                goto ruleautomatic_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleautomatic_keyEx; /* Prevent compiler warnings */
    ruleautomatic_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end automatic_key */

/**
 * $ANTLR start last_key
 * PLSQLKeys.g:1097:1: last_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::last_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1098:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1098:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LAST"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LAST\")" );
                    ex->set_ruleName( "last_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_last_key6083);
            if  (this->hasException())
            {
                goto rulelast_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelast_keyEx; /* Prevent compiler warnings */
    rulelast_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end last_key */

/**
 * $ANTLR start main_key
 * PLSQLKeys.g:1101:1: main_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::main_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1102:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1102:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MAIN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MAIN\")" );
                    ex->set_ruleName( "main_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_main_key6106);
            if  (this->hasException())
            {
                goto rulemain_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemain_keyEx; /* Prevent compiler warnings */
    rulemain_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end main_key */

/**
 * $ANTLR start grouping_key
 * PLSQLKeys.g:1105:1: grouping_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::grouping_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1106:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1106:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "GROUPING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"GROUPING\")" );
                    ex->set_ruleName( "grouping_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_grouping_key6129);
            if  (this->hasException())
            {
                goto rulegrouping_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulegrouping_keyEx; /* Prevent compiler warnings */
    rulegrouping_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end grouping_key */

/**
 * $ANTLR start include_key
 * PLSQLKeys.g:1109:1: include_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::include_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1110:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1110:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INCLUDE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INCLUDE\")" );
                    ex->set_ruleName( "include_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_include_key6152);
            if  (this->hasException())
            {
                goto ruleinclude_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinclude_keyEx; /* Prevent compiler warnings */
    ruleinclude_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end include_key */

/**
 * $ANTLR start ignore_key
 * PLSQLKeys.g:1113:1: ignore_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::ignore_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1114:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1114:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "IGNORE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"IGNORE\")" );
                    ex->set_ruleName( "ignore_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ignore_key6175);
            if  (this->hasException())
            {
                goto ruleignore_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleignore_keyEx; /* Prevent compiler warnings */
    ruleignore_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end ignore_key */

/**
 * $ANTLR start respect_key
 * PLSQLKeys.g:1117:1: respect_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::respect_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1118:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1118:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RESPECT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RESPECT\")" );
                    ex->set_ruleName( "respect_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_respect_key6198);
            if  (this->hasException())
            {
                goto rulerespect_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerespect_keyEx; /* Prevent compiler warnings */
    rulerespect_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end respect_key */

/**
 * $ANTLR start unique_key
 * PLSQLKeys.g:1121:1: unique_key : SQL92_RESERVED_UNIQUE ;
 */
void
PLSQLParser_PLSQLKeys::unique_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1122:5: ( SQL92_RESERVED_UNIQUE )
        // PLSQLKeys.g:1122:10: SQL92_RESERVED_UNIQUE
        {
             this->matchToken(SQL92_RESERVED_UNIQUE, &FOLLOW_SQL92_RESERVED_UNIQUE_in_unique_key6218);
            if  (this->hasException())
            {
                goto ruleunique_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunique_keyEx; /* Prevent compiler warnings */
    ruleunique_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unique_key */

/**
 * $ANTLR start submultiset_key
 * PLSQLKeys.g:1125:1: submultiset_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::submultiset_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1126:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1126:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SUBMULTISET"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SUBMULTISET\")" );
                    ex->set_ruleName( "submultiset_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_submultiset_key6241);
            if  (this->hasException())
            {
                goto rulesubmultiset_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubmultiset_keyEx; /* Prevent compiler warnings */
    rulesubmultiset_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end submultiset_key */

/**
 * $ANTLR start at_key
 * PLSQLKeys.g:1129:1: at_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::at_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1130:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1130:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AT\")" );
                    ex->set_ruleName( "at_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_at_key6264);
            if  (this->hasException())
            {
                goto ruleat_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleat_keyEx; /* Prevent compiler warnings */
    ruleat_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end at_key */

/**
 * $ANTLR start a_key
 * PLSQLKeys.g:1134:1: a_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::a_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1135:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1135:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "A"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"A\")" );
                    ex->set_ruleName( "a_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_a_key6288);
            if  (this->hasException())
            {
                goto rulea_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulea_keyEx; /* Prevent compiler warnings */
    rulea_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end a_key */

/**
 * $ANTLR start empty_key
 * PLSQLKeys.g:1138:1: empty_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::empty_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1139:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1139:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EMPTY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EMPTY\")" );
                    ex->set_ruleName( "empty_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_empty_key6311);
            if  (this->hasException())
            {
                goto ruleempty_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleempty_keyEx; /* Prevent compiler warnings */
    ruleempty_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end empty_key */

/**
 * $ANTLR start likec_key
 * PLSQLKeys.g:1142:1: likec_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::likec_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1143:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1143:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LIKEC"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LIKEC\")" );
                    ex->set_ruleName( "likec_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_likec_key6334);
            if  (this->hasException())
            {
                goto rulelikec_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelikec_keyEx; /* Prevent compiler warnings */
    rulelikec_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end likec_key */

/**
 * $ANTLR start nan_key
 * PLSQLKeys.g:1146:1: nan_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nan_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1147:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1147:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NAN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NAN\")" );
                    ex->set_ruleName( "nan_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nan_key6357);
            if  (this->hasException())
            {
                goto rulenan_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenan_keyEx; /* Prevent compiler warnings */
    rulenan_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nan_key */

/**
 * $ANTLR start infinite_key
 * PLSQLKeys.g:1150:1: infinite_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::infinite_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1151:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1151:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INFINITE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INFINITE\")" );
                    ex->set_ruleName( "infinite_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_infinite_key6380);
            if  (this->hasException())
            {
                goto ruleinfinite_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinfinite_keyEx; /* Prevent compiler warnings */
    ruleinfinite_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end infinite_key */

/**
 * $ANTLR start like2_key
 * PLSQLKeys.g:1154:1: like2_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::like2_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1155:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1155:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LIKE2"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LIKE2\")" );
                    ex->set_ruleName( "like2_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_like2_key6403);
            if  (this->hasException())
            {
                goto rulelike2_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelike2_keyEx; /* Prevent compiler warnings */
    rulelike2_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end like2_key */

/**
 * $ANTLR start like4_key
 * PLSQLKeys.g:1158:1: like4_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::like4_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1159:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1159:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LIKE4"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LIKE4\")" );
                    ex->set_ruleName( "like4_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_like4_key6426);
            if  (this->hasException())
            {
                goto rulelike4_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelike4_keyEx; /* Prevent compiler warnings */
    rulelike4_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end like4_key */

/**
 * $ANTLR start present_key
 * PLSQLKeys.g:1162:1: present_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::present_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1163:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1163:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PRESENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PRESENT\")" );
                    ex->set_ruleName( "present_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_present_key6449);
            if  (this->hasException())
            {
                goto rulepresent_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepresent_keyEx; /* Prevent compiler warnings */
    rulepresent_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end present_key */

/**
 * $ANTLR start dbtimezone_key
 * PLSQLKeys.g:1166:1: dbtimezone_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::dbtimezone_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1167:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1167:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DBTIMEZONE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DBTIMEZONE\")" );
                    ex->set_ruleName( "dbtimezone_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dbtimezone_key6472);
            if  (this->hasException())
            {
                goto ruledbtimezone_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledbtimezone_keyEx; /* Prevent compiler warnings */
    ruledbtimezone_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dbtimezone_key */

/**
 * $ANTLR start sessiontimezone_key
 * PLSQLKeys.g:1170:1: sessiontimezone_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sessiontimezone_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1171:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1171:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SESSIONTIMEZONE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SESSIONTIMEZONE\")" );
                    ex->set_ruleName( "sessiontimezone_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sessiontimezone_key6495);
            if  (this->hasException())
            {
                goto rulesessiontimezone_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesessiontimezone_keyEx; /* Prevent compiler warnings */
    rulesessiontimezone_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sessiontimezone_key */

/**
 * $ANTLR start nchar_cs_key
 * PLSQLKeys.g:1174:1: nchar_cs_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nchar_cs_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1175:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1175:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NCHAR_CS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NCHAR_CS\")" );
                    ex->set_ruleName( "nchar_cs_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nchar_cs_key6518);
            if  (this->hasException())
            {
                goto rulenchar_cs_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenchar_cs_keyEx; /* Prevent compiler warnings */
    rulenchar_cs_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nchar_cs_key */

/**
 * $ANTLR start decompose_key
 * PLSQLKeys.g:1178:1: decompose_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::decompose_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1179:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1179:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DECOMPOSE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DECOMPOSE\")" );
                    ex->set_ruleName( "decompose_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_decompose_key6541);
            if  (this->hasException())
            {
                goto ruledecompose_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledecompose_keyEx; /* Prevent compiler warnings */
    ruledecompose_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end decompose_key */

/**
 * $ANTLR start following_key
 * PLSQLKeys.g:1182:1: following_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::following_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1183:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1183:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FOLLOWING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FOLLOWING\")" );
                    ex->set_ruleName( "following_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_following_key6564);
            if  (this->hasException())
            {
                goto rulefollowing_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefollowing_keyEx; /* Prevent compiler warnings */
    rulefollowing_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end following_key */

/**
 * $ANTLR start first_value_key
 * PLSQLKeys.g:1186:1: first_value_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::first_value_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1187:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1187:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FIRST_VALUE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FIRST_VALUE\")" );
                    ex->set_ruleName( "first_value_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_first_value_key6587);
            if  (this->hasException())
            {
                goto rulefirst_value_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefirst_value_keyEx; /* Prevent compiler warnings */
    rulefirst_value_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end first_value_key */

/**
 * $ANTLR start preceding_key
 * PLSQLKeys.g:1190:1: preceding_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::preceding_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1191:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1191:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PRECEDING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PRECEDING\")" );
                    ex->set_ruleName( "preceding_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_preceding_key6610);
            if  (this->hasException())
            {
                goto rulepreceding_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepreceding_keyEx; /* Prevent compiler warnings */
    rulepreceding_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end preceding_key */

/**
 * $ANTLR start within_key
 * PLSQLKeys.g:1194:1: within_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::within_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1195:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1195:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "WITHIN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"WITHIN\")" );
                    ex->set_ruleName( "within_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_within_key6633);
            if  (this->hasException())
            {
                goto rulewithin_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewithin_keyEx; /* Prevent compiler warnings */
    rulewithin_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end within_key */

/**
 * $ANTLR start canonical_key
 * PLSQLKeys.g:1198:1: canonical_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::canonical_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1199:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1199:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CANONICAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CANONICAL\")" );
                    ex->set_ruleName( "canonical_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_canonical_key6656);
            if  (this->hasException())
            {
                goto rulecanonical_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecanonical_keyEx; /* Prevent compiler warnings */
    rulecanonical_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end canonical_key */

/**
 * $ANTLR start compatibility_key
 * PLSQLKeys.g:1202:1: compatibility_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::compatibility_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1203:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1203:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COMPATIBILITY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COMPATIBILITY\")" );
                    ex->set_ruleName( "compatibility_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_compatibility_key6679);
            if  (this->hasException())
            {
                goto rulecompatibility_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecompatibility_keyEx; /* Prevent compiler warnings */
    rulecompatibility_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end compatibility_key */

/**
 * $ANTLR start over_key
 * PLSQLKeys.g:1206:1: over_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::over_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1207:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1207:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OVER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OVER\")" );
                    ex->set_ruleName( "over_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_over_key6702);
            if  (this->hasException())
            {
                goto ruleover_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleover_keyEx; /* Prevent compiler warnings */
    ruleover_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end over_key */

/**
 * $ANTLR start multiset_key
 * PLSQLKeys.g:1210:1: multiset_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::multiset_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1211:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1211:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MULTISET"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MULTISET\")" );
                    ex->set_ruleName( "multiset_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_multiset_key6725);
            if  (this->hasException())
            {
                goto rulemultiset_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemultiset_keyEx; /* Prevent compiler warnings */
    rulemultiset_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multiset_key */

/**
 * $ANTLR start connect_by_root_key
 * PLSQLKeys.g:1214:1: connect_by_root_key : PLSQL_NON_RESERVED_CONNECT_BY_ROOT ;
 */
void
PLSQLParser_PLSQLKeys::connect_by_root_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1215:5: ( PLSQL_NON_RESERVED_CONNECT_BY_ROOT )
        // PLSQLKeys.g:1215:10: PLSQL_NON_RESERVED_CONNECT_BY_ROOT
        {
             this->matchToken(PLSQL_NON_RESERVED_CONNECT_BY_ROOT, &FOLLOW_PLSQL_NON_RESERVED_CONNECT_BY_ROOT_in_connect_by_root_key6745);
            if  (this->hasException())
            {
                goto ruleconnect_by_root_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconnect_by_root_keyEx; /* Prevent compiler warnings */
    ruleconnect_by_root_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end connect_by_root_key */

/**
 * $ANTLR start last_value_key
 * PLSQLKeys.g:1218:1: last_value_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::last_value_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1219:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1219:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LAST_VALUE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LAST_VALUE\")" );
                    ex->set_ruleName( "last_value_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_last_value_key6768);
            if  (this->hasException())
            {
                goto rulelast_value_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelast_value_keyEx; /* Prevent compiler warnings */
    rulelast_value_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end last_value_key */

/**
 * $ANTLR start current_key
 * PLSQLKeys.g:1222:1: current_key : SQL92_RESERVED_CURRENT ;
 */
void
PLSQLParser_PLSQLKeys::current_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1223:5: ( SQL92_RESERVED_CURRENT )
        // PLSQLKeys.g:1223:10: SQL92_RESERVED_CURRENT
        {
             this->matchToken(SQL92_RESERVED_CURRENT, &FOLLOW_SQL92_RESERVED_CURRENT_in_current_key6788);
            if  (this->hasException())
            {
                goto rulecurrent_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecurrent_keyEx; /* Prevent compiler warnings */
    rulecurrent_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end current_key */

/**
 * $ANTLR start unbounded_key
 * PLSQLKeys.g:1226:1: unbounded_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::unbounded_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1227:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1227:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UNBOUNDED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UNBOUNDED\")" );
                    ex->set_ruleName( "unbounded_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_unbounded_key6811);
            if  (this->hasException())
            {
                goto ruleunbounded_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunbounded_keyEx; /* Prevent compiler warnings */
    ruleunbounded_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unbounded_key */

/**
 * $ANTLR start dense_rank_key
 * PLSQLKeys.g:1230:1: dense_rank_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::dense_rank_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1231:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1231:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DENSE_RANK"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DENSE_RANK\")" );
                    ex->set_ruleName( "dense_rank_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dense_rank_key6834);
            if  (this->hasException())
            {
                goto ruledense_rank_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledense_rank_keyEx; /* Prevent compiler warnings */
    ruledense_rank_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dense_rank_key */

/**
 * $ANTLR start cost_key
 * PLSQLKeys.g:1234:1: cost_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::cost_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1235:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1235:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COST"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COST\")" );
                    ex->set_ruleName( "cost_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cost_key6857);
            if  (this->hasException())
            {
                goto rulecost_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecost_keyEx; /* Prevent compiler warnings */
    rulecost_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cost_key */

/**
 * $ANTLR start char_cs_key
 * PLSQLKeys.g:1238:1: char_cs_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::char_cs_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1239:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1239:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CHAR_CS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CHAR_CS\")" );
                    ex->set_ruleName( "char_cs_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_char_cs_key6880);
            if  (this->hasException())
            {
                goto rulechar_cs_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulechar_cs_keyEx; /* Prevent compiler warnings */
    rulechar_cs_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end char_cs_key */

/**
 * $ANTLR start auto_key
 * PLSQLKeys.g:1242:1: auto_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::auto_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1243:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1243:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AUTO"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AUTO\")" );
                    ex->set_ruleName( "auto_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_auto_key6903);
            if  (this->hasException())
            {
                goto ruleauto_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleauto_keyEx; /* Prevent compiler warnings */
    ruleauto_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end auto_key */

/**
 * $ANTLR start treat_key
 * PLSQLKeys.g:1246:1: treat_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::treat_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1247:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1247:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TREAT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TREAT\")" );
                    ex->set_ruleName( "treat_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_treat_key6926);
            if  (this->hasException())
            {
                goto ruletreat_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletreat_keyEx; /* Prevent compiler warnings */
    ruletreat_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end treat_key */

/**
 * $ANTLR start content_key
 * PLSQLKeys.g:1250:1: content_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::content_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1251:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1251:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CONTENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CONTENT\")" );
                    ex->set_ruleName( "content_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_content_key6949);
            if  (this->hasException())
            {
                goto rulecontent_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecontent_keyEx; /* Prevent compiler warnings */
    rulecontent_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end content_key */

/**
 * $ANTLR start xmlparse_key
 * PLSQLKeys.g:1254:1: xmlparse_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlparse_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1255:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1255:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLPARSE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLPARSE\")" );
                    ex->set_ruleName( "xmlparse_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlparse_key6972);
            if  (this->hasException())
            {
                goto rulexmlparse_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlparse_keyEx; /* Prevent compiler warnings */
    rulexmlparse_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlparse_key */

/**
 * $ANTLR start xmlelement_key
 * PLSQLKeys.g:1258:1: xmlelement_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlelement_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1259:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1259:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLELEMENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLELEMENT\")" );
                    ex->set_ruleName( "xmlelement_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlelement_key6995);
            if  (this->hasException())
            {
                goto rulexmlelement_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlelement_keyEx; /* Prevent compiler warnings */
    rulexmlelement_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlelement_key */

/**
 * $ANTLR start entityescaping_key
 * PLSQLKeys.g:1262:1: entityescaping_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::entityescaping_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1263:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1263:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ENTITYESCAPING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ENTITYESCAPING\")" );
                    ex->set_ruleName( "entityescaping_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_entityescaping_key7018);
            if  (this->hasException())
            {
                goto ruleentityescaping_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleentityescaping_keyEx; /* Prevent compiler warnings */
    ruleentityescaping_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end entityescaping_key */

/**
 * $ANTLR start standalone_key
 * PLSQLKeys.g:1266:1: standalone_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::standalone_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1267:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1267:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "STANDALONE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"STANDALONE\")" );
                    ex->set_ruleName( "standalone_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_standalone_key7041);
            if  (this->hasException())
            {
                goto rulestandalone_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestandalone_keyEx; /* Prevent compiler warnings */
    rulestandalone_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end standalone_key */

/**
 * $ANTLR start wellformed_key
 * PLSQLKeys.g:1270:1: wellformed_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::wellformed_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1271:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1271:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "WELLFORMED"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"WELLFORMED\")" );
                    ex->set_ruleName( "wellformed_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_wellformed_key7064);
            if  (this->hasException())
            {
                goto rulewellformed_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewellformed_keyEx; /* Prevent compiler warnings */
    rulewellformed_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end wellformed_key */

/**
 * $ANTLR start xmlexists_key
 * PLSQLKeys.g:1274:1: xmlexists_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlexists_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1275:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1275:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLEXISTS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLEXISTS\")" );
                    ex->set_ruleName( "xmlexists_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlexists_key7087);
            if  (this->hasException())
            {
                goto rulexmlexists_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlexists_keyEx; /* Prevent compiler warnings */
    rulexmlexists_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlexists_key */

/**
 * $ANTLR start version_key
 * PLSQLKeys.g:1278:1: version_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::version_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1279:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1279:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VERSION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VERSION\")" );
                    ex->set_ruleName( "version_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_version_key7110);
            if  (this->hasException())
            {
                goto ruleversion_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleversion_keyEx; /* Prevent compiler warnings */
    ruleversion_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end version_key */

/**
 * $ANTLR start xmlcast_key
 * PLSQLKeys.g:1282:1: xmlcast_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlcast_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1283:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1283:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLCAST"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLCAST\")" );
                    ex->set_ruleName( "xmlcast_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlcast_key7133);
            if  (this->hasException())
            {
                goto rulexmlcast_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlcast_keyEx; /* Prevent compiler warnings */
    rulexmlcast_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlcast_key */

/**
 * $ANTLR start yes_key
 * PLSQLKeys.g:1286:1: yes_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::yes_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1287:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1287:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "YES"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"YES\")" );
                    ex->set_ruleName( "yes_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_yes_key7156);
            if  (this->hasException())
            {
                goto ruleyes_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleyes_keyEx; /* Prevent compiler warnings */
    ruleyes_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end yes_key */

/**
 * $ANTLR start no_key
 * PLSQLKeys.g:1290:1: no_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::no_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1291:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1291:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NO"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NO\")" );
                    ex->set_ruleName( "no_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_no_key7179);
            if  (this->hasException())
            {
                goto ruleno_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleno_keyEx; /* Prevent compiler warnings */
    ruleno_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end no_key */

/**
 * $ANTLR start evalname_key
 * PLSQLKeys.g:1294:1: evalname_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::evalname_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1295:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1295:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EVALNAME"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EVALNAME\")" );
                    ex->set_ruleName( "evalname_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_evalname_key7202);
            if  (this->hasException())
            {
                goto ruleevalname_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleevalname_keyEx; /* Prevent compiler warnings */
    ruleevalname_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end evalname_key */

/**
 * $ANTLR start xmlpi_key
 * PLSQLKeys.g:1298:1: xmlpi_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlpi_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1299:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1299:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLPI"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLPI\")" );
                    ex->set_ruleName( "xmlpi_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlpi_key7225);
            if  (this->hasException())
            {
                goto rulexmlpi_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlpi_keyEx; /* Prevent compiler warnings */
    rulexmlpi_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlpi_key */

/**
 * $ANTLR start xmlcolattval_key
 * PLSQLKeys.g:1302:1: xmlcolattval_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlcolattval_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1303:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1303:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLCOLATTVAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLCOLATTVAL\")" );
                    ex->set_ruleName( "xmlcolattval_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlcolattval_key7248);
            if  (this->hasException())
            {
                goto rulexmlcolattval_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlcolattval_keyEx; /* Prevent compiler warnings */
    rulexmlcolattval_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlcolattval_key */

/**
 * $ANTLR start document_key
 * PLSQLKeys.g:1306:1: document_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::document_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1307:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1307:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DOCUMENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DOCUMENT\")" );
                    ex->set_ruleName( "document_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_document_key7271);
            if  (this->hasException())
            {
                goto ruledocument_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledocument_keyEx; /* Prevent compiler warnings */
    ruledocument_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end document_key */

/**
 * $ANTLR start xmlforest_key
 * PLSQLKeys.g:1310:1: xmlforest_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlforest_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1311:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1311:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLFOREST"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLFOREST\")" );
                    ex->set_ruleName( "xmlforest_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlforest_key7294);
            if  (this->hasException())
            {
                goto rulexmlforest_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlforest_keyEx; /* Prevent compiler warnings */
    rulexmlforest_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlforest_key */

/**
 * $ANTLR start passing_key
 * PLSQLKeys.g:1314:1: passing_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::passing_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1315:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1315:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PASSING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PASSING\")" );
                    ex->set_ruleName( "passing_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_passing_key7317);
            if  (this->hasException())
            {
                goto rulepassing_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepassing_keyEx; /* Prevent compiler warnings */
    rulepassing_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end passing_key */

/**
 * $ANTLR start columns_key
 * PLSQLKeys.g:1318:1: columns_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::columns_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1319:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1319:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COLUMNS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COLUMNS\")" );
                    ex->set_ruleName( "columns_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_columns_key7341);
            if  (this->hasException())
            {
                goto rulecolumns_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecolumns_keyEx; /* Prevent compiler warnings */
    rulecolumns_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end columns_key */

/**
 * $ANTLR start indent_key
 * PLSQLKeys.g:1322:1: indent_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::indent_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1323:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1323:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INDENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INDENT\")" );
                    ex->set_ruleName( "indent_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_indent_key7364);
            if  (this->hasException())
            {
                goto ruleindent_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleindent_keyEx; /* Prevent compiler warnings */
    ruleindent_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end indent_key */

/**
 * $ANTLR start hide_key
 * PLSQLKeys.g:1326:1: hide_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::hide_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1327:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1327:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "HIDE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"HIDE\")" );
                    ex->set_ruleName( "hide_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_hide_key7387);
            if  (this->hasException())
            {
                goto rulehide_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulehide_keyEx; /* Prevent compiler warnings */
    rulehide_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end hide_key */

/**
 * $ANTLR start xmlagg_key
 * PLSQLKeys.g:1330:1: xmlagg_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlagg_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1331:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1331:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLAGG"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLAGG\")" );
                    ex->set_ruleName( "xmlagg_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlagg_key7410);
            if  (this->hasException())
            {
                goto rulexmlagg_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlagg_keyEx; /* Prevent compiler warnings */
    rulexmlagg_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlagg_key */

/**
 * $ANTLR start path_key
 * PLSQLKeys.g:1334:1: path_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::path_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1335:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1335:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PATH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PATH\")" );
                    ex->set_ruleName( "path_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_path_key7433);
            if  (this->hasException())
            {
                goto rulepath_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepath_keyEx; /* Prevent compiler warnings */
    rulepath_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end path_key */

/**
 * $ANTLR start xmlnamespaces_key
 * PLSQLKeys.g:1338:1: xmlnamespaces_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlnamespaces_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1339:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1339:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLNAMESPACES"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLNAMESPACES\")" );
                    ex->set_ruleName( "xmlnamespaces_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlnamespaces_key7456);
            if  (this->hasException())
            {
                goto rulexmlnamespaces_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlnamespaces_keyEx; /* Prevent compiler warnings */
    rulexmlnamespaces_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlnamespaces_key */

/**
 * $ANTLR start size_key
 * PLSQLKeys.g:1342:1: size_key : SQL92_RESERVED_SIZE ;
 */
void
PLSQLParser_PLSQLKeys::size_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1343:5: ( SQL92_RESERVED_SIZE )
        // PLSQLKeys.g:1343:10: SQL92_RESERVED_SIZE
        {
             this->matchToken(SQL92_RESERVED_SIZE, &FOLLOW_SQL92_RESERVED_SIZE_in_size_key7476);
            if  (this->hasException())
            {
                goto rulesize_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesize_keyEx; /* Prevent compiler warnings */
    rulesize_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end size_key */

/**
 * $ANTLR start noschemacheck_key
 * PLSQLKeys.g:1346:1: noschemacheck_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::noschemacheck_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1347:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1347:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOSCHEMACHECK"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOSCHEMACHECK\")" );
                    ex->set_ruleName( "noschemacheck_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_noschemacheck_key7499);
            if  (this->hasException())
            {
                goto rulenoschemacheck_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenoschemacheck_keyEx; /* Prevent compiler warnings */
    rulenoschemacheck_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end noschemacheck_key */

/**
 * $ANTLR start noentityescaping_key
 * PLSQLKeys.g:1350:1: noentityescaping_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::noentityescaping_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1351:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1351:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOENTITYESCAPING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOENTITYESCAPING\")" );
                    ex->set_ruleName( "noentityescaping_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_noentityescaping_key7522);
            if  (this->hasException())
            {
                goto rulenoentityescaping_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenoentityescaping_keyEx; /* Prevent compiler warnings */
    rulenoentityescaping_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end noentityescaping_key */

/**
 * $ANTLR start xmlquery_key
 * PLSQLKeys.g:1354:1: xmlquery_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlquery_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1355:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1355:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLQUERY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLQUERY\")" );
                    ex->set_ruleName( "xmlquery_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlquery_key7545);
            if  (this->hasException())
            {
                goto rulexmlquery_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlquery_keyEx; /* Prevent compiler warnings */
    rulexmlquery_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlquery_key */

/**
 * $ANTLR start xmltable_key
 * PLSQLKeys.g:1358:1: xmltable_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmltable_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1359:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1359:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLTABLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLTABLE\")" );
                    ex->set_ruleName( "xmltable_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmltable_key7568);
            if  (this->hasException())
            {
                goto rulexmltable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmltable_keyEx; /* Prevent compiler warnings */
    rulexmltable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmltable_key */

/**
 * $ANTLR start xmlroot_key
 * PLSQLKeys.g:1362:1: xmlroot_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlroot_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1363:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1363:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLROOT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLROOT\")" );
                    ex->set_ruleName( "xmlroot_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlroot_key7591);
            if  (this->hasException())
            {
                goto rulexmlroot_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlroot_keyEx; /* Prevent compiler warnings */
    rulexmlroot_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlroot_key */

/**
 * $ANTLR start schemacheck_key
 * PLSQLKeys.g:1366:1: schemacheck_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::schemacheck_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1367:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1367:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SCHEMACHECK"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SCHEMACHECK\")" );
                    ex->set_ruleName( "schemacheck_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_schemacheck_key7614);
            if  (this->hasException())
            {
                goto ruleschemacheck_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleschemacheck_keyEx; /* Prevent compiler warnings */
    ruleschemacheck_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end schemacheck_key */

/**
 * $ANTLR start xmlattributes_key
 * PLSQLKeys.g:1370:1: xmlattributes_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlattributes_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1371:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1371:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLATTRIBUTES"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLATTRIBUTES\")" );
                    ex->set_ruleName( "xmlattributes_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlattributes_key7637);
            if  (this->hasException())
            {
                goto rulexmlattributes_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlattributes_keyEx; /* Prevent compiler warnings */
    rulexmlattributes_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlattributes_key */

/**
 * $ANTLR start encoding_key
 * PLSQLKeys.g:1374:1: encoding_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::encoding_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1375:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1375:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ENCODING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ENCODING\")" );
                    ex->set_ruleName( "encoding_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_encoding_key7660);
            if  (this->hasException())
            {
                goto ruleencoding_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleencoding_keyEx; /* Prevent compiler warnings */
    ruleencoding_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end encoding_key */

/**
 * $ANTLR start show_key
 * PLSQLKeys.g:1378:1: show_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::show_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1379:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1379:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SHOW"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SHOW\")" );
                    ex->set_ruleName( "show_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_show_key7683);
            if  (this->hasException())
            {
                goto ruleshow_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleshow_keyEx; /* Prevent compiler warnings */
    ruleshow_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end show_key */

/**
 * $ANTLR start xmlserialize_key
 * PLSQLKeys.g:1382:1: xmlserialize_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::xmlserialize_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1383:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1383:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "XMLSERIALIZE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"XMLSERIALIZE\")" );
                    ex->set_ruleName( "xmlserialize_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_xmlserialize_key7706);
            if  (this->hasException())
            {
                goto rulexmlserialize_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlserialize_keyEx; /* Prevent compiler warnings */
    rulexmlserialize_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlserialize_key */

/**
 * $ANTLR start ordinality_key
 * PLSQLKeys.g:1386:1: ordinality_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::ordinality_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1387:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1387:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ORDINALITY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ORDINALITY\")" );
                    ex->set_ruleName( "ordinality_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ordinality_key7729);
            if  (this->hasException())
            {
                goto ruleordinality_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleordinality_keyEx; /* Prevent compiler warnings */
    ruleordinality_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end ordinality_key */

/**
 * $ANTLR start defaults_key
 * PLSQLKeys.g:1390:1: defaults_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::defaults_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1391:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1391:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DEFAULTS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DEFAULTS\")" );
                    ex->set_ruleName( "defaults_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_defaults_key7752);
            if  (this->hasException())
            {
                goto ruledefaults_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledefaults_keyEx; /* Prevent compiler warnings */
    ruledefaults_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end defaults_key */

/**
 * $ANTLR start sqlerror_key
 * PLSQLKeys.g:1394:1: sqlerror_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sqlerror_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1395:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1395:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SQLERROR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SQLERROR\")" );
                    ex->set_ruleName( "sqlerror_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sqlerror_key7774);
            if  (this->hasException())
            {
                goto rulesqlerror_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesqlerror_keyEx; /* Prevent compiler warnings */
    rulesqlerror_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sqlerror_key */

/**
 * $ANTLR start oserror_key
 * PLSQLKeys.g:1398:1: oserror_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::oserror_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1399:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1399:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OSERROR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OSERROR\")" );
                    ex->set_ruleName( "oserror_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_oserror_key7798);
            if  (this->hasException())
            {
                goto ruleoserror_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleoserror_keyEx; /* Prevent compiler warnings */
    ruleoserror_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end oserror_key */

/**
 * $ANTLR start success_key
 * PLSQLKeys.g:1402:1: success_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::success_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1403:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1403:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SUCCESS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SUCCESS\")" );
                    ex->set_ruleName( "success_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_success_key7821);
            if  (this->hasException())
            {
                goto rulesuccess_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesuccess_keyEx; /* Prevent compiler warnings */
    rulesuccess_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end success_key */

/**
 * $ANTLR start warning_key
 * PLSQLKeys.g:1406:1: warning_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::warning_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1407:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1407:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "WARNING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"WARNING\")" );
                    ex->set_ruleName( "warning_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_warning_key7844);
            if  (this->hasException())
            {
                goto rulewarning_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewarning_keyEx; /* Prevent compiler warnings */
    rulewarning_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end warning_key */

/**
 * $ANTLR start failure_key
 * PLSQLKeys.g:1410:1: failure_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::failure_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1411:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1411:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FAILURE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FAILURE\")" );
                    ex->set_ruleName( "failure_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_failure_key7867);
            if  (this->hasException())
            {
                goto rulefailure_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefailure_keyEx; /* Prevent compiler warnings */
    rulefailure_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end failure_key */

/**
 * $ANTLR start insert_key
 * PLSQLKeys.g:1414:1: insert_key : SQL92_RESERVED_INSERT ;
 */
void
PLSQLParser_PLSQLKeys::insert_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1415:5: ( SQL92_RESERVED_INSERT )
        // PLSQLKeys.g:1415:10: SQL92_RESERVED_INSERT
        {
             this->matchToken(SQL92_RESERVED_INSERT, &FOLLOW_SQL92_RESERVED_INSERT_in_insert_key7888);
            if  (this->hasException())
            {
                goto ruleinsert_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinsert_keyEx; /* Prevent compiler warnings */
    ruleinsert_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end insert_key */

/**
 * $ANTLR start order_key
 * PLSQLKeys.g:1418:1: order_key : SQL92_RESERVED_ORDER ;
 */
void
PLSQLParser_PLSQLKeys::order_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1419:5: ( SQL92_RESERVED_ORDER )
        // PLSQLKeys.g:1419:10: SQL92_RESERVED_ORDER
        {
             this->matchToken(SQL92_RESERVED_ORDER, &FOLLOW_SQL92_RESERVED_ORDER_in_order_key7908);
            if  (this->hasException())
            {
                goto ruleorder_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleorder_keyEx; /* Prevent compiler warnings */
    ruleorder_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end order_key */

/**
 * $ANTLR start minus_key
 * PLSQLKeys.g:1422:1: minus_key : PLSQL_RESERVED_MINUS ;
 */
void
PLSQLParser_PLSQLKeys::minus_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1423:5: ( PLSQL_RESERVED_MINUS )
        // PLSQLKeys.g:1423:10: PLSQL_RESERVED_MINUS
        {
             this->matchToken(PLSQL_RESERVED_MINUS, &FOLLOW_PLSQL_RESERVED_MINUS_in_minus_key7928);
            if  (this->hasException())
            {
                goto ruleminus_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleminus_keyEx; /* Prevent compiler warnings */
    ruleminus_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end minus_key */

/**
 * $ANTLR start row_key
 * PLSQLKeys.g:1426:1: row_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::row_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1427:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1427:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ROW"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ROW\")" );
                    ex->set_ruleName( "row_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_row_key7950);
            if  (this->hasException())
            {
                goto rulerow_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerow_keyEx; /* Prevent compiler warnings */
    rulerow_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end row_key */

/**
 * $ANTLR start mod_key
 * PLSQLKeys.g:1430:1: mod_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::mod_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1431:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1431:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MOD"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MOD\")" );
                    ex->set_ruleName( "mod_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_mod_key7972);
            if  (this->hasException())
            {
                goto rulemod_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemod_keyEx; /* Prevent compiler warnings */
    rulemod_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end mod_key */

/**
 * $ANTLR start raw_key
 * PLSQLKeys.g:1434:1: raw_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::raw_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1435:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1435:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RAW"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RAW\")" );
                    ex->set_ruleName( "raw_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_raw_key7995);
            if  (this->hasException())
            {
                goto ruleraw_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleraw_keyEx; /* Prevent compiler warnings */
    ruleraw_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end raw_key */

/**
 * $ANTLR start power_key
 * PLSQLKeys.g:1438:1: power_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::power_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1439:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1439:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "POWER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"POWER\")" );
                    ex->set_ruleName( "power_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_power_key8017);
            if  (this->hasException())
            {
                goto rulepower_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepower_keyEx; /* Prevent compiler warnings */
    rulepower_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end power_key */

/**
 * $ANTLR start lock_key
 * PLSQLKeys.g:1442:1: lock_key : PLSQL_RESERVED_LOCK ;
 */
void
PLSQLParser_PLSQLKeys::lock_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1443:5: ( PLSQL_RESERVED_LOCK )
        // PLSQLKeys.g:1443:10: PLSQL_RESERVED_LOCK
        {
             this->matchToken(PLSQL_RESERVED_LOCK, &FOLLOW_PLSQL_RESERVED_LOCK_in_lock_key8037);
            if  (this->hasException())
            {
                goto rulelock_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelock_keyEx; /* Prevent compiler warnings */
    rulelock_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end lock_key */

/**
 * $ANTLR start exists_key
 * PLSQLKeys.g:1446:1: exists_key : SQL92_RESERVED_EXISTS ;
 */
void
PLSQLParser_PLSQLKeys::exists_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1447:5: ( SQL92_RESERVED_EXISTS )
        // PLSQLKeys.g:1447:10: SQL92_RESERVED_EXISTS
        {
             this->matchToken(SQL92_RESERVED_EXISTS, &FOLLOW_SQL92_RESERVED_EXISTS_in_exists_key8057);
            if  (this->hasException())
            {
                goto ruleexists_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexists_keyEx; /* Prevent compiler warnings */
    ruleexists_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exists_key */

/**
 * $ANTLR start having_key
 * PLSQLKeys.g:1450:1: having_key : SQL92_RESERVED_HAVING ;
 */
void
PLSQLParser_PLSQLKeys::having_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1451:5: ( SQL92_RESERVED_HAVING )
        // PLSQLKeys.g:1451:10: SQL92_RESERVED_HAVING
        {
             this->matchToken(SQL92_RESERVED_HAVING, &FOLLOW_SQL92_RESERVED_HAVING_in_having_key8077);
            if  (this->hasException())
            {
                goto rulehaving_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulehaving_keyEx; /* Prevent compiler warnings */
    rulehaving_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end having_key */

/**
 * $ANTLR start any_key
 * PLSQLKeys.g:1454:1: any_key : SQL92_RESERVED_ANY ;
 */
void
PLSQLParser_PLSQLKeys::any_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1455:5: ( SQL92_RESERVED_ANY )
        // PLSQLKeys.g:1455:10: SQL92_RESERVED_ANY
        {
             this->matchToken(SQL92_RESERVED_ANY, &FOLLOW_SQL92_RESERVED_ANY_in_any_key8097);
            if  (this->hasException())
            {
                goto ruleany_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleany_keyEx; /* Prevent compiler warnings */
    ruleany_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end any_key */

/**
 * $ANTLR start with_key
 * PLSQLKeys.g:1458:1: with_key : SQL92_RESERVED_WITH ;
 */
void
PLSQLParser_PLSQLKeys::with_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1459:5: ( SQL92_RESERVED_WITH )
        // PLSQLKeys.g:1459:10: SQL92_RESERVED_WITH
        {
             this->matchToken(SQL92_RESERVED_WITH, &FOLLOW_SQL92_RESERVED_WITH_in_with_key8117);
            if  (this->hasException())
            {
                goto rulewith_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewith_keyEx; /* Prevent compiler warnings */
    rulewith_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end with_key */

/**
 * $ANTLR start transaction_key
 * PLSQLKeys.g:1462:1: transaction_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::transaction_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1463:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1463:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TRANSACTION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TRANSACTION\")" );
                    ex->set_ruleName( "transaction_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_transaction_key8140);
            if  (this->hasException())
            {
                goto ruletransaction_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletransaction_keyEx; /* Prevent compiler warnings */
    ruletransaction_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end transaction_key */

/**
 * $ANTLR start rawtohex_key
 * PLSQLKeys.g:1466:1: rawtohex_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rawtohex_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1467:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1467:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RAWTOHEX"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RAWTOHEX\")" );
                    ex->set_ruleName( "rawtohex_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rawtohex_key8162);
            if  (this->hasException())
            {
                goto rulerawtohex_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerawtohex_keyEx; /* Prevent compiler warnings */
    rulerawtohex_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rawtohex_key */

/**
 * $ANTLR start number_key
 * PLSQLKeys.g:1470:1: number_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::number_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1471:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1471:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NUMBER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NUMBER\")" );
                    ex->set_ruleName( "number_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_number_key8185);
            if  (this->hasException())
            {
                goto rulenumber_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenumber_keyEx; /* Prevent compiler warnings */
    rulenumber_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end number_key */

/**
 * $ANTLR start nocopy_key
 * PLSQLKeys.g:1474:1: nocopy_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nocopy_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1475:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1475:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOCOPY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOCOPY\")" );
                    ex->set_ruleName( "nocopy_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nocopy_key8208);
            if  (this->hasException())
            {
                goto rulenocopy_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenocopy_keyEx; /* Prevent compiler warnings */
    rulenocopy_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nocopy_key */

/**
 * $ANTLR start to_key
 * PLSQLKeys.g:1478:1: to_key : SQL92_RESERVED_TO ;
 */
void
PLSQLParser_PLSQLKeys::to_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1479:5: ( SQL92_RESERVED_TO )
        // PLSQLKeys.g:1479:10: SQL92_RESERVED_TO
        {
             this->matchToken(SQL92_RESERVED_TO, &FOLLOW_SQL92_RESERVED_TO_in_to_key8228);
            if  (this->hasException())
            {
                goto ruleto_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleto_keyEx; /* Prevent compiler warnings */
    ruleto_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end to_key */

/**
 * $ANTLR start abs_key
 * PLSQLKeys.g:1482:1: abs_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::abs_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1483:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1483:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ABS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ABS\")" );
                    ex->set_ruleName( "abs_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_abs_key8250);
            if  (this->hasException())
            {
                goto ruleabs_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleabs_keyEx; /* Prevent compiler warnings */
    ruleabs_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end abs_key */

/**
 * $ANTLR start rollback_key
 * PLSQLKeys.g:1486:1: rollback_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rollback_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1487:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1487:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ROLLBACK"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ROLLBACK\")" );
                    ex->set_ruleName( "rollback_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rollback_key8273);
            if  (this->hasException())
            {
                goto rulerollback_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerollback_keyEx; /* Prevent compiler warnings */
    rulerollback_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rollback_key */

/**
 * $ANTLR start share_key
 * PLSQLKeys.g:1490:1: share_key : PLSQL_RESERVED_SHARE ;
 */
void
PLSQLParser_PLSQLKeys::share_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1491:5: ( PLSQL_RESERVED_SHARE )
        // PLSQLKeys.g:1491:10: PLSQL_RESERVED_SHARE
        {
             this->matchToken(PLSQL_RESERVED_SHARE, &FOLLOW_PLSQL_RESERVED_SHARE_in_share_key8293);
            if  (this->hasException())
            {
                goto ruleshare_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleshare_keyEx; /* Prevent compiler warnings */
    ruleshare_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end share_key */

/**
 * $ANTLR start greatest_key
 * PLSQLKeys.g:1494:1: greatest_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::greatest_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1495:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1495:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "GREATEST"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"GREATEST\")" );
                    ex->set_ruleName( "greatest_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_greatest_key8315);
            if  (this->hasException())
            {
                goto rulegreatest_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulegreatest_keyEx; /* Prevent compiler warnings */
    rulegreatest_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end greatest_key */

/**
 * $ANTLR start vsize_key
 * PLSQLKeys.g:1498:1: vsize_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::vsize_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1499:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1499:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VSIZE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VSIZE\")" );
                    ex->set_ruleName( "vsize_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_vsize_key8337);
            if  (this->hasException())
            {
                goto rulevsize_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevsize_keyEx; /* Prevent compiler warnings */
    rulevsize_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end vsize_key */

/**
 * $ANTLR start exclusive_key
 * PLSQLKeys.g:1502:1: exclusive_key : PLSQL_RESERVED_EXCLUSIVE ;
 */
void
PLSQLParser_PLSQLKeys::exclusive_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1503:5: ( PLSQL_RESERVED_EXCLUSIVE )
        // PLSQLKeys.g:1503:10: PLSQL_RESERVED_EXCLUSIVE
        {
             this->matchToken(PLSQL_RESERVED_EXCLUSIVE, &FOLLOW_PLSQL_RESERVED_EXCLUSIVE_in_exclusive_key8357);
            if  (this->hasException())
            {
                goto ruleexclusive_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexclusive_keyEx; /* Prevent compiler warnings */
    ruleexclusive_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end exclusive_key */

/**
 * $ANTLR start varchar2_key
 * PLSQLKeys.g:1506:1: varchar2_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::varchar2_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1507:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1507:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VARCHAR2"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VARCHAR2\")" );
                    ex->set_ruleName( "varchar2_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_varchar2_key8380);
            if  (this->hasException())
            {
                goto rulevarchar2_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevarchar2_keyEx; /* Prevent compiler warnings */
    rulevarchar2_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end varchar2_key */

/**
 * $ANTLR start rowidtochar_key
 * PLSQLKeys.g:1510:1: rowidtochar_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rowidtochar_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1511:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1511:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ROWIDTOCHAR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ROWIDTOCHAR\")" );
                    ex->set_ruleName( "rowidtochar_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rowidtochar_key8402);
            if  (this->hasException())
            {
                goto rulerowidtochar_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerowidtochar_keyEx; /* Prevent compiler warnings */
    rulerowidtochar_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rowidtochar_key */

/**
 * $ANTLR start open_key
 * PLSQLKeys.g:1514:1: open_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::open_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1515:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1515:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OPEN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OPEN\")" );
                    ex->set_ruleName( "open_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_open_key8425);
            if  (this->hasException())
            {
                goto ruleopen_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleopen_keyEx; /* Prevent compiler warnings */
    ruleopen_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end open_key */

/**
 * $ANTLR start comment_key
 * PLSQLKeys.g:1518:1: comment_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::comment_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1519:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1519:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COMMENT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COMMENT\")" );
                    ex->set_ruleName( "comment_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_comment_key8448);
            if  (this->hasException())
            {
                goto rulecomment_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecomment_keyEx; /* Prevent compiler warnings */
    rulecomment_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end comment_key */

/**
 * $ANTLR start sqrt_key
 * PLSQLKeys.g:1522:1: sqrt_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sqrt_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1523:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1523:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SQRT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SQRT\")" );
                    ex->set_ruleName( "sqrt_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sqrt_key8470);
            if  (this->hasException())
            {
                goto rulesqrt_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesqrt_keyEx; /* Prevent compiler warnings */
    rulesqrt_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sqrt_key */

/**
 * $ANTLR start instr_key
 * PLSQLKeys.g:1526:1: instr_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::instr_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1527:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1527:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INSTR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INSTR\")" );
                    ex->set_ruleName( "instr_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_instr_key8492);
            if  (this->hasException())
            {
                goto ruleinstr_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinstr_keyEx; /* Prevent compiler warnings */
    ruleinstr_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end instr_key */

/**
 * $ANTLR start nowait_key
 * PLSQLKeys.g:1530:1: nowait_key : PLSQL_RESERVED_NOWAIT ;
 */
void
PLSQLParser_PLSQLKeys::nowait_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1531:5: ( PLSQL_RESERVED_NOWAIT )
        // PLSQLKeys.g:1531:10: PLSQL_RESERVED_NOWAIT
        {
             this->matchToken(PLSQL_RESERVED_NOWAIT, &FOLLOW_PLSQL_RESERVED_NOWAIT_in_nowait_key8512);
            if  (this->hasException())
            {
                goto rulenowait_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenowait_keyEx; /* Prevent compiler warnings */
    rulenowait_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nowait_key */

/**
 * $ANTLR start lpad_key
 * PLSQLKeys.g:1534:1: lpad_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::lpad_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1535:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1535:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LPAD"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LPAD\")" );
                    ex->set_ruleName( "lpad_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_lpad_key8534);
            if  (this->hasException())
            {
                goto rulelpad_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelpad_keyEx; /* Prevent compiler warnings */
    rulelpad_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end lpad_key */

/**
 * $ANTLR start boolean_key
 * PLSQLKeys.g:1538:1: boolean_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::boolean_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1539:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1539:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BOOLEAN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BOOLEAN\")" );
                    ex->set_ruleName( "boolean_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_boolean_key8557);
            if  (this->hasException())
            {
                goto ruleboolean_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleboolean_keyEx; /* Prevent compiler warnings */
    ruleboolean_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end boolean_key */

/**
 * $ANTLR start rpad_key
 * PLSQLKeys.g:1542:1: rpad_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rpad_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1543:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1543:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RPAD"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RPAD\")" );
                    ex->set_ruleName( "rpad_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rpad_key8579);
            if  (this->hasException())
            {
                goto rulerpad_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerpad_keyEx; /* Prevent compiler warnings */
    rulerpad_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rpad_key */

/**
 * $ANTLR start savepoint_key
 * PLSQLKeys.g:1546:1: savepoint_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::savepoint_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1547:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1547:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SAVEPOINT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SAVEPOINT\")" );
                    ex->set_ruleName( "savepoint_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_savepoint_key8602);
            if  (this->hasException())
            {
                goto rulesavepoint_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesavepoint_keyEx; /* Prevent compiler warnings */
    rulesavepoint_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end savepoint_key */

/**
 * $ANTLR start decode_key
 * PLSQLKeys.g:1550:1: decode_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::decode_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1551:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1551:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DECODE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DECODE\")" );
                    ex->set_ruleName( "decode_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_decode_key8624);
            if  (this->hasException())
            {
                goto ruledecode_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledecode_keyEx; /* Prevent compiler warnings */
    ruledecode_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end decode_key */

/**
 * $ANTLR start reverse_key
 * PLSQLKeys.g:1554:1: reverse_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::reverse_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1555:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1555:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "REVERSE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"REVERSE\")" );
                    ex->set_ruleName( "reverse_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_reverse_key8646);
            if  (this->hasException())
            {
                goto rulereverse_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereverse_keyEx; /* Prevent compiler warnings */
    rulereverse_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end reverse_key */

/**
 * $ANTLR start least_key
 * PLSQLKeys.g:1558:1: least_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::least_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1559:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1559:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LEAST"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LEAST\")" );
                    ex->set_ruleName( "least_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_least_key8668);
            if  (this->hasException())
            {
                goto ruleleast_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleleast_keyEx; /* Prevent compiler warnings */
    ruleleast_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end least_key */

/**
 * $ANTLR start nvl_key
 * PLSQLKeys.g:1562:1: nvl_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nvl_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1563:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1563:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NVL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NVL\")" );
                    ex->set_ruleName( "nvl_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nvl_key8690);
            if  (this->hasException())
            {
                goto rulenvl_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenvl_keyEx; /* Prevent compiler warnings */
    rulenvl_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nvl_key */

/**
 * $ANTLR start variance_key
 * PLSQLKeys.g:1566:1: variance_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::variance_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1567:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1567:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VARIANCE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VARIANCE\")" );
                    ex->set_ruleName( "variance_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_variance_key8712);
            if  (this->hasException())
            {
                goto rulevariance_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevariance_keyEx; /* Prevent compiler warnings */
    rulevariance_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end variance_key */

/**
 * $ANTLR start start_key
 * PLSQLKeys.g:1570:1: start_key : PLSQL_RESERVED_START ;
 */
void
PLSQLParser_PLSQLKeys::start_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1571:5: ( PLSQL_RESERVED_START )
        // PLSQLKeys.g:1571:10: PLSQL_RESERVED_START
        {
             this->matchToken(PLSQL_RESERVED_START, &FOLLOW_PLSQL_RESERVED_START_in_start_key8732);
            if  (this->hasException())
            {
                goto rulestart_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestart_keyEx; /* Prevent compiler warnings */
    rulestart_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end start_key */

/**
 * $ANTLR start desc_key
 * PLSQLKeys.g:1574:1: desc_key : SQL92_RESERVED_DESC ;
 */
void
PLSQLParser_PLSQLKeys::desc_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1575:5: ( SQL92_RESERVED_DESC )
        // PLSQLKeys.g:1575:10: SQL92_RESERVED_DESC
        {
             this->matchToken(SQL92_RESERVED_DESC, &FOLLOW_SQL92_RESERVED_DESC_in_desc_key8752);
            if  (this->hasException())
            {
                goto ruledesc_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledesc_keyEx; /* Prevent compiler warnings */
    ruledesc_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end desc_key */

/**
 * $ANTLR start concat_key
 * PLSQLKeys.g:1578:1: concat_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::concat_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1579:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1579:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CONCAT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CONCAT\")" );
                    ex->set_ruleName( "concat_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_concat_key8774);
            if  (this->hasException())
            {
                goto ruleconcat_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconcat_keyEx; /* Prevent compiler warnings */
    ruleconcat_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end concat_key */

/**
 * $ANTLR start dump_key
 * PLSQLKeys.g:1582:1: dump_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::dump_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1583:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1583:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DUMP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DUMP\")" );
                    ex->set_ruleName( "dump_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dump_key8796);
            if  (this->hasException())
            {
                goto ruledump_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledump_keyEx; /* Prevent compiler warnings */
    ruledump_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dump_key */

/**
 * $ANTLR start soundex_key
 * PLSQLKeys.g:1586:1: soundex_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::soundex_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1587:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1587:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SOUNDEX"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SOUNDEX\")" );
                    ex->set_ruleName( "soundex_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_soundex_key8818);
            if  (this->hasException())
            {
                goto rulesoundex_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesoundex_keyEx; /* Prevent compiler warnings */
    rulesoundex_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end soundex_key */

/**
 * $ANTLR start positive_key
 * PLSQLKeys.g:1590:1: positive_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::positive_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1591:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1591:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "POSITIVE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"POSITIVE\")" );
                    ex->set_ruleName( "positive_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_positive_key8841);
            if  (this->hasException())
            {
                goto rulepositive_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepositive_keyEx; /* Prevent compiler warnings */
    rulepositive_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end positive_key */

/**
 * $ANTLR start union_key
 * PLSQLKeys.g:1594:1: union_key : SQL92_RESERVED_UNION ;
 */
void
PLSQLParser_PLSQLKeys::union_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1595:5: ( SQL92_RESERVED_UNION )
        // PLSQLKeys.g:1595:10: SQL92_RESERVED_UNION
        {
             this->matchToken(SQL92_RESERVED_UNION, &FOLLOW_SQL92_RESERVED_UNION_in_union_key8861);
            if  (this->hasException())
            {
                goto ruleunion_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunion_keyEx; /* Prevent compiler warnings */
    ruleunion_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end union_key */

/**
 * $ANTLR start ascii_key
 * PLSQLKeys.g:1598:1: ascii_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::ascii_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1599:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1599:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ASCII"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ASCII\")" );
                    ex->set_ruleName( "ascii_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ascii_key8883);
            if  (this->hasException())
            {
                goto ruleascii_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleascii_keyEx; /* Prevent compiler warnings */
    ruleascii_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end ascii_key */

/**
 * $ANTLR start connect_key
 * PLSQLKeys.g:1602:1: connect_key : SQL92_RESERVED_CONNECT ;
 */
void
PLSQLParser_PLSQLKeys::connect_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1603:5: ( SQL92_RESERVED_CONNECT )
        // PLSQLKeys.g:1603:10: SQL92_RESERVED_CONNECT
        {
             this->matchToken(SQL92_RESERVED_CONNECT, &FOLLOW_SQL92_RESERVED_CONNECT_in_connect_key8903);
            if  (this->hasException())
            {
                goto ruleconnect_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconnect_keyEx; /* Prevent compiler warnings */
    ruleconnect_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end connect_key */

/**
 * $ANTLR start asc_key
 * PLSQLKeys.g:1606:1: asc_key : SQL92_RESERVED_ASC ;
 */
void
PLSQLParser_PLSQLKeys::asc_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1607:5: ( SQL92_RESERVED_ASC )
        // PLSQLKeys.g:1607:10: SQL92_RESERVED_ASC
        {
             this->matchToken(SQL92_RESERVED_ASC, &FOLLOW_SQL92_RESERVED_ASC_in_asc_key8923);
            if  (this->hasException())
            {
                goto ruleasc_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleasc_keyEx; /* Prevent compiler warnings */
    ruleasc_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end asc_key */

/**
 * $ANTLR start hextoraw_key
 * PLSQLKeys.g:1610:1: hextoraw_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::hextoraw_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1611:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1611:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "HEXTORAW"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"HEXTORAW\")" );
                    ex->set_ruleName( "hextoraw_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_hextoraw_key8945);
            if  (this->hasException())
            {
                goto rulehextoraw_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulehextoraw_keyEx; /* Prevent compiler warnings */
    rulehextoraw_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end hextoraw_key */

/**
 * $ANTLR start to_date_key
 * PLSQLKeys.g:1614:1: to_date_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::to_date_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1615:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1615:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TO_DATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TO_DATE\")" );
                    ex->set_ruleName( "to_date_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_to_date_key8967);
            if  (this->hasException())
            {
                goto ruleto_date_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleto_date_keyEx; /* Prevent compiler warnings */
    ruleto_date_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end to_date_key */

/**
 * $ANTLR start floor_key
 * PLSQLKeys.g:1618:1: floor_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::floor_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1619:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1619:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FLOOR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FLOOR\")" );
                    ex->set_ruleName( "floor_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_floor_key8989);
            if  (this->hasException())
            {
                goto rulefloor_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefloor_keyEx; /* Prevent compiler warnings */
    rulefloor_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end floor_key */

/**
 * $ANTLR start sign_key
 * PLSQLKeys.g:1622:1: sign_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sign_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1623:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1623:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SIGN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SIGN\")" );
                    ex->set_ruleName( "sign_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sign_key9011);
            if  (this->hasException())
            {
                goto rulesign_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesign_keyEx; /* Prevent compiler warnings */
    rulesign_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sign_key */

/**
 * $ANTLR start update_key
 * PLSQLKeys.g:1626:1: update_key : SQL92_RESERVED_UPDATE ;
 */
void
PLSQLParser_PLSQLKeys::update_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1627:5: ( SQL92_RESERVED_UPDATE )
        // PLSQLKeys.g:1627:10: SQL92_RESERVED_UPDATE
        {
             this->matchToken(SQL92_RESERVED_UPDATE, &FOLLOW_SQL92_RESERVED_UPDATE_in_update_key9031);
            if  (this->hasException())
            {
                goto ruleupdate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleupdate_keyEx; /* Prevent compiler warnings */
    ruleupdate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end update_key */

/**
 * $ANTLR start trunc_key
 * PLSQLKeys.g:1630:1: trunc_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::trunc_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1631:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1631:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TRUNC"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TRUNC\")" );
                    ex->set_ruleName( "trunc_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_trunc_key9053);
            if  (this->hasException())
            {
                goto ruletrunc_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletrunc_keyEx; /* Prevent compiler warnings */
    ruletrunc_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end trunc_key */

/**
 * $ANTLR start rtrim_key
 * PLSQLKeys.g:1634:1: rtrim_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::rtrim_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1635:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1635:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RTRIM"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RTRIM\")" );
                    ex->set_ruleName( "rtrim_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_rtrim_key9075);
            if  (this->hasException())
            {
                goto rulertrim_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulertrim_keyEx; /* Prevent compiler warnings */
    rulertrim_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rtrim_key */

/**
 * $ANTLR start close_key
 * PLSQLKeys.g:1638:1: close_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::close_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1639:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1639:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CLOSE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CLOSE\")" );
                    ex->set_ruleName( "close_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_close_key9098);
            if  (this->hasException())
            {
                goto ruleclose_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleclose_keyEx; /* Prevent compiler warnings */
    ruleclose_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end close_key */

/**
 * $ANTLR start to_char_key
 * PLSQLKeys.g:1642:1: to_char_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::to_char_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1643:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1643:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TO_CHAR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TO_CHAR\")" );
                    ex->set_ruleName( "to_char_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_to_char_key9120);
            if  (this->hasException())
            {
                goto ruleto_char_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleto_char_keyEx; /* Prevent compiler warnings */
    ruleto_char_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end to_char_key */

/**
 * $ANTLR start ltrim_key
 * PLSQLKeys.g:1646:1: ltrim_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::ltrim_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1647:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1647:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LTRIM"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LTRIM\")" );
                    ex->set_ruleName( "ltrim_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ltrim_key9142);
            if  (this->hasException())
            {
                goto ruleltrim_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleltrim_keyEx; /* Prevent compiler warnings */
    ruleltrim_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end ltrim_key */

/**
 * $ANTLR start mode_key
 * PLSQLKeys.g:1650:1: mode_key : PLSQL_RESERVED_MODE ;
 */
void
PLSQLParser_PLSQLKeys::mode_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1651:5: ( PLSQL_RESERVED_MODE )
        // PLSQLKeys.g:1651:10: PLSQL_RESERVED_MODE
        {
             this->matchToken(PLSQL_RESERVED_MODE, &FOLLOW_PLSQL_RESERVED_MODE_in_mode_key9162);
            if  (this->hasException())
            {
                goto rulemode_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemode_keyEx; /* Prevent compiler warnings */
    rulemode_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end mode_key */

/**
 * $ANTLR start uid_key
 * PLSQLKeys.g:1654:1: uid_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::uid_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1655:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1655:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UID"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UID\")" );
                    ex->set_ruleName( "uid_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_uid_key9184);
            if  (this->hasException())
            {
                goto ruleuid_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleuid_keyEx; /* Prevent compiler warnings */
    ruleuid_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end uid_key */

/**
 * $ANTLR start chr_key
 * PLSQLKeys.g:1658:1: chr_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::chr_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1659:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1659:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CHR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CHR\")" );
                    ex->set_ruleName( "chr_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_chr_key9206);
            if  (this->hasException())
            {
                goto rulechr_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulechr_keyEx; /* Prevent compiler warnings */
    rulechr_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end chr_key */

/**
 * $ANTLR start intersect_key
 * PLSQLKeys.g:1662:1: intersect_key : SQL92_RESERVED_INTERSECT ;
 */
void
PLSQLParser_PLSQLKeys::intersect_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1663:5: ( SQL92_RESERVED_INTERSECT )
        // PLSQLKeys.g:1663:10: SQL92_RESERVED_INTERSECT
        {
             this->matchToken(SQL92_RESERVED_INTERSECT, &FOLLOW_SQL92_RESERVED_INTERSECT_in_intersect_key9226);
            if  (this->hasException())
            {
                goto ruleintersect_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintersect_keyEx; /* Prevent compiler warnings */
    ruleintersect_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end intersect_key */

/**
 * $ANTLR start chartorowid_key
 * PLSQLKeys.g:1666:1: chartorowid_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::chartorowid_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1667:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1667:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CHARTOROWID"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CHARTOROWID\")" );
                    ex->set_ruleName( "chartorowid_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_chartorowid_key9248);
            if  (this->hasException())
            {
                goto rulechartorowid_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulechartorowid_keyEx; /* Prevent compiler warnings */
    rulechartorowid_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end chartorowid_key */

/**
 * $ANTLR start mlslabel_key
 * PLSQLKeys.g:1670:1: mlslabel_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::mlslabel_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1671:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1671:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MLSLABEL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MLSLABEL\")" );
                    ex->set_ruleName( "mlslabel_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_mlslabel_key9271);
            if  (this->hasException())
            {
                goto rulemlslabel_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemlslabel_keyEx; /* Prevent compiler warnings */
    rulemlslabel_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end mlslabel_key */

/**
 * $ANTLR start userenv_key
 * PLSQLKeys.g:1674:1: userenv_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::userenv_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1675:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1675:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "USERENV"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"USERENV\")" );
                    ex->set_ruleName( "userenv_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_userenv_key9293);
            if  (this->hasException())
            {
                goto ruleuserenv_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleuserenv_keyEx; /* Prevent compiler warnings */
    ruleuserenv_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end userenv_key */

/**
 * $ANTLR start stddev_key
 * PLSQLKeys.g:1678:1: stddev_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::stddev_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1679:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1679:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "STDDEV"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"STDDEV\")" );
                    ex->set_ruleName( "stddev_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_stddev_key9315);
            if  (this->hasException())
            {
                goto rulestddev_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestddev_keyEx; /* Prevent compiler warnings */
    rulestddev_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end stddev_key */

/**
 * $ANTLR start length_key
 * PLSQLKeys.g:1682:1: length_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::length_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1683:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1683:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LENGTH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LENGTH\")" );
                    ex->set_ruleName( "length_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_length_key9337);
            if  (this->hasException())
            {
                goto rulelength_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelength_keyEx; /* Prevent compiler warnings */
    rulelength_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end length_key */

/**
 * $ANTLR start fetch_key
 * PLSQLKeys.g:1686:1: fetch_key : SQL92_RESERVED_FETCH ;
 */
void
PLSQLParser_PLSQLKeys::fetch_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1687:5: ( SQL92_RESERVED_FETCH )
        // PLSQLKeys.g:1687:10: SQL92_RESERVED_FETCH
        {
             this->matchToken(SQL92_RESERVED_FETCH, &FOLLOW_SQL92_RESERVED_FETCH_in_fetch_key9357);
            if  (this->hasException())
            {
                goto rulefetch_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefetch_keyEx; /* Prevent compiler warnings */
    rulefetch_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end fetch_key */

/**
 * $ANTLR start group_key
 * PLSQLKeys.g:1690:1: group_key : SQL92_RESERVED_GROUP ;
 */
void
PLSQLParser_PLSQLKeys::group_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1691:5: ( SQL92_RESERVED_GROUP )
        // PLSQLKeys.g:1691:10: SQL92_RESERVED_GROUP
        {
             this->matchToken(SQL92_RESERVED_GROUP, &FOLLOW_SQL92_RESERVED_GROUP_in_group_key9377);
            if  (this->hasException())
            {
                goto rulegroup_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulegroup_keyEx; /* Prevent compiler warnings */
    rulegroup_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end group_key */

/**
 * $ANTLR start sysdate_key
 * PLSQLKeys.g:1694:1: sysdate_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sysdate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1695:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1695:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SYSDATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SYSDATE\")" );
                    ex->set_ruleName( "sysdate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sysdate_key9399);
            if  (this->hasException())
            {
                goto rulesysdate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesysdate_keyEx; /* Prevent compiler warnings */
    rulesysdate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sysdate_key */

/**
 * $ANTLR start binary_integer_key
 * PLSQLKeys.g:1698:1: binary_integer_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::binary_integer_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1699:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1699:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BINARY_INTEGER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BINARY_INTEGER\")" );
                    ex->set_ruleName( "binary_integer_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_binary_integer_key9422);
            if  (this->hasException())
            {
                goto rulebinary_integer_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebinary_integer_keyEx; /* Prevent compiler warnings */
    rulebinary_integer_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end binary_integer_key */

/**
 * $ANTLR start to_number_key
 * PLSQLKeys.g:1702:1: to_number_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::to_number_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1703:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1703:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TO_NUMBER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TO_NUMBER\")" );
                    ex->set_ruleName( "to_number_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_to_number_key9444);
            if  (this->hasException())
            {
                goto ruleto_number_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleto_number_keyEx; /* Prevent compiler warnings */
    ruleto_number_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end to_number_key */

/**
 * $ANTLR start substr_key
 * PLSQLKeys.g:1706:1: substr_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::substr_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1707:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1707:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SUBSTR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SUBSTR\")" );
                    ex->set_ruleName( "substr_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_substr_key9466);
            if  (this->hasException())
            {
                goto rulesubstr_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubstr_keyEx; /* Prevent compiler warnings */
    rulesubstr_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end substr_key */

/**
 * $ANTLR start ceil_key
 * PLSQLKeys.g:1710:1: ceil_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::ceil_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1711:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1711:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CEIL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CEIL\")" );
                    ex->set_ruleName( "ceil_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_ceil_key9488);
            if  (this->hasException())
            {
                goto ruleceil_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleceil_keyEx; /* Prevent compiler warnings */
    ruleceil_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end ceil_key */

/**
 * $ANTLR start initcap_key
 * PLSQLKeys.g:1714:1: initcap_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::initcap_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1715:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1715:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INITCAP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INITCAP\")" );
                    ex->set_ruleName( "initcap_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_initcap_key9510);
            if  (this->hasException())
            {
                goto ruleinitcap_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinitcap_keyEx; /* Prevent compiler warnings */
    ruleinitcap_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end initcap_key */

/**
 * $ANTLR start round_key
 * PLSQLKeys.g:1718:1: round_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::round_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1719:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1719:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ROUND"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ROUND\")" );
                    ex->set_ruleName( "round_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_round_key9532);
            if  (this->hasException())
            {
                goto ruleround_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleround_keyEx; /* Prevent compiler warnings */
    ruleround_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end round_key */

/**
 * $ANTLR start long_key
 * PLSQLKeys.g:1722:1: long_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::long_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1723:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1723:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LONG"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LONG\")" );
                    ex->set_ruleName( "long_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_long_key9555);
            if  (this->hasException())
            {
                goto rulelong_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelong_keyEx; /* Prevent compiler warnings */
    rulelong_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end long_key */

/**
 * $ANTLR start read_key
 * PLSQLKeys.g:1726:1: read_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::read_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1727:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1727:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "READ"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"READ\")" );
                    ex->set_ruleName( "read_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_read_key9578);
            if  (this->hasException())
            {
                goto ruleread_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleread_keyEx; /* Prevent compiler warnings */
    ruleread_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end read_key */

/**
 * $ANTLR start only_key
 * PLSQLKeys.g:1730:1: only_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::only_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1731:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1731:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ONLY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ONLY\")" );
                    ex->set_ruleName( "only_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_only_key9600);
            if  (this->hasException())
            {
                goto ruleonly_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleonly_keyEx; /* Prevent compiler warnings */
    ruleonly_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end only_key */

/**
 * $ANTLR start set_key
 * PLSQLKeys.g:1734:1: set_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::set_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1735:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1735:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SET"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SET\")" );
                    ex->set_ruleName( "set_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_set_key9623);
            if  (this->hasException())
            {
                goto ruleset_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleset_keyEx; /* Prevent compiler warnings */
    ruleset_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end set_key */

/**
 * $ANTLR start nullif_key
 * PLSQLKeys.g:1738:1: nullif_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nullif_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1739:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1739:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NULLIF"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NULLIF\")" );
                    ex->set_ruleName( "nullif_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nullif_key9645);
            if  (this->hasException())
            {
                goto rulenullif_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenullif_keyEx; /* Prevent compiler warnings */
    rulenullif_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nullif_key */

/**
 * $ANTLR start coalesce_key
 * PLSQLKeys.g:1742:1: coalesce_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::coalesce_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1743:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1743:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COALESCE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COALESCE\")" );
                    ex->set_ruleName( "coalesce_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_coalesce_key9667);
            if  (this->hasException())
            {
                goto rulecoalesce_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecoalesce_keyEx; /* Prevent compiler warnings */
    rulecoalesce_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end coalesce_key */

/**
 * $ANTLR start count_key
 * PLSQLKeys.g:1746:1: count_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::count_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1747:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1747:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COUNT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COUNT\")" );
                    ex->set_ruleName( "count_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_count_key9689);
            if  (this->hasException())
            {
                goto rulecount_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecount_keyEx; /* Prevent compiler warnings */
    rulecount_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end count_key */

/**
 * $ANTLR start avg_key
 * PLSQLKeys.g:1750:1: avg_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::avg_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1750:12: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1750:17: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "AVG"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"AVG\")" );
                    ex->set_ruleName( "avg_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_avg_key9710);
            if  (this->hasException())
            {
                goto ruleavg_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleavg_keyEx; /* Prevent compiler warnings */
    ruleavg_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end avg_key */

/**
 * $ANTLR start max_key
 * PLSQLKeys.g:1753:1: max_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::max_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1753:12: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1753:17: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MAX"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MAX\")" );
                    ex->set_ruleName( "max_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_max_key9731);
            if  (this->hasException())
            {
                goto rulemax_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemax_keyEx; /* Prevent compiler warnings */
    rulemax_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end max_key */

/**
 * $ANTLR start min_key
 * PLSQLKeys.g:1756:1: min_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::min_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1756:12: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1756:17: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MIN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MIN\")" );
                    ex->set_ruleName( "min_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_min_key9752);
            if  (this->hasException())
            {
                goto rulemin_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemin_keyEx; /* Prevent compiler warnings */
    rulemin_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end min_key */

/**
 * $ANTLR start sum_key
 * PLSQLKeys.g:1759:1: sum_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sum_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1759:12: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1759:17: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SUM"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SUM\")" );
                    ex->set_ruleName( "sum_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sum_key9773);
            if  (this->hasException())
            {
                goto rulesum_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesum_keyEx; /* Prevent compiler warnings */
    rulesum_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sum_key */

/**
 * $ANTLR start unknown_key
 * PLSQLKeys.g:1762:1: unknown_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::unknown_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1763:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1763:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UNKNOWN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UNKNOWN\")" );
                    ex->set_ruleName( "unknown_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_unknown_key9795);
            if  (this->hasException())
            {
                goto ruleunknown_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunknown_keyEx; /* Prevent compiler warnings */
    ruleunknown_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unknown_key */

/**
 * $ANTLR start escape_key
 * PLSQLKeys.g:1766:1: escape_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::escape_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1767:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1767:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ESCAPE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ESCAPE\")" );
                    ex->set_ruleName( "escape_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_escape_key9817);
            if  (this->hasException())
            {
                goto ruleescape_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleescape_keyEx; /* Prevent compiler warnings */
    ruleescape_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end escape_key */

/**
 * $ANTLR start some_key
 * PLSQLKeys.g:1770:1: some_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::some_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1771:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1771:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SOME"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SOME\")" );
                    ex->set_ruleName( "some_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_some_key9839);
            if  (this->hasException())
            {
                goto rulesome_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesome_keyEx; /* Prevent compiler warnings */
    rulesome_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end some_key */

/**
 * $ANTLR start match_key
 * PLSQLKeys.g:1774:1: match_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::match_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1775:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1775:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MATCH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MATCH\")" );
                    ex->set_ruleName( "match_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_match_key9861);
            if  (this->hasException())
            {
                goto rulematch_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulematch_keyEx; /* Prevent compiler warnings */
    rulematch_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end match_key */

/**
 * $ANTLR start cast_key
 * PLSQLKeys.g:1778:1: cast_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::cast_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1779:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1779:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CAST"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CAST\")" );
                    ex->set_ruleName( "cast_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cast_key9883);
            if  (this->hasException())
            {
                goto rulecast_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecast_keyEx; /* Prevent compiler warnings */
    rulecast_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cast_key */

/**
 * $ANTLR start full_key
 * PLSQLKeys.g:1782:1: full_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::full_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1783:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1783:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FULL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FULL\")" );
                    ex->set_ruleName( "full_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_full_key9906);
            if  (this->hasException())
            {
                goto rulefull_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefull_keyEx; /* Prevent compiler warnings */
    rulefull_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end full_key */

/**
 * $ANTLR start partial_key
 * PLSQLKeys.g:1786:1: partial_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::partial_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1787:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1787:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PARTIAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PARTIAL\")" );
                    ex->set_ruleName( "partial_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_partial_key9928);
            if  (this->hasException())
            {
                goto rulepartial_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepartial_keyEx; /* Prevent compiler warnings */
    rulepartial_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end partial_key */

/**
 * $ANTLR start character_key
 * PLSQLKeys.g:1790:1: character_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::character_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1791:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1791:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CHARACTER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CHARACTER\")" );
                    ex->set_ruleName( "character_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_character_key9951);
            if  (this->hasException())
            {
                goto rulecharacter_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecharacter_keyEx; /* Prevent compiler warnings */
    rulecharacter_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end character_key */

/**
 * $ANTLR start except_key
 * PLSQLKeys.g:1794:1: except_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::except_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1795:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1795:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXCEPT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXCEPT\")" );
                    ex->set_ruleName( "except_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_except_key9973);
            if  (this->hasException())
            {
                goto ruleexcept_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexcept_keyEx; /* Prevent compiler warnings */
    ruleexcept_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end except_key */

/**
 * $ANTLR start char_key
 * PLSQLKeys.g:1798:1: char_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::char_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1799:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1799:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CHAR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CHAR\")" );
                    ex->set_ruleName( "char_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_char_key9996);
            if  (this->hasException())
            {
                goto rulechar_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulechar_keyEx; /* Prevent compiler warnings */
    rulechar_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end char_key */

/**
 * $ANTLR start varying_key
 * PLSQLKeys.g:1802:1: varying_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::varying_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1803:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1803:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VARYING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VARYING\")" );
                    ex->set_ruleName( "varying_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_varying_key10019);
            if  (this->hasException())
            {
                goto rulevarying_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevarying_keyEx; /* Prevent compiler warnings */
    rulevarying_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end varying_key */

/**
 * $ANTLR start varchar_key
 * PLSQLKeys.g:1806:1: varchar_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::varchar_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1807:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1807:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VARCHAR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VARCHAR\")" );
                    ex->set_ruleName( "varchar_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_varchar_key10042);
            if  (this->hasException())
            {
                goto rulevarchar_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevarchar_keyEx; /* Prevent compiler warnings */
    rulevarchar_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end varchar_key */

/**
 * $ANTLR start national_key
 * PLSQLKeys.g:1810:1: national_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::national_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1811:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1811:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NATIONAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NATIONAL\")" );
                    ex->set_ruleName( "national_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_national_key10064);
            if  (this->hasException())
            {
                goto rulenational_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenational_keyEx; /* Prevent compiler warnings */
    rulenational_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end national_key */

/**
 * $ANTLR start nchar_key
 * PLSQLKeys.g:1814:1: nchar_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nchar_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1815:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1815:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NCHAR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NCHAR\")" );
                    ex->set_ruleName( "nchar_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nchar_key10086);
            if  (this->hasException())
            {
                goto rulenchar_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenchar_keyEx; /* Prevent compiler warnings */
    rulenchar_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nchar_key */

/**
 * $ANTLR start bit_key
 * PLSQLKeys.g:1818:1: bit_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::bit_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1818:12: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1818:17: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BIT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BIT\")" );
                    ex->set_ruleName( "bit_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_bit_key10107);
            if  (this->hasException())
            {
                goto rulebit_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebit_keyEx; /* Prevent compiler warnings */
    rulebit_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end bit_key */

/**
 * $ANTLR start float_key
 * PLSQLKeys.g:1821:1: float_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::float_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1822:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1822:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "FLOAT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"FLOAT\")" );
                    ex->set_ruleName( "float_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_float_key10129);
            if  (this->hasException())
            {
                goto rulefloat_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefloat_keyEx; /* Prevent compiler warnings */
    rulefloat_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end float_key */

/**
 * $ANTLR start real_key
 * PLSQLKeys.g:1825:1: real_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::real_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1826:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1826:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "REAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"REAL\")" );
                    ex->set_ruleName( "real_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_real_key10156);
            if  (this->hasException())
            {
                goto rulereal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereal_keyEx; /* Prevent compiler warnings */
    rulereal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end real_key */

/**
 * $ANTLR start double_key
 * PLSQLKeys.g:1829:1: double_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::double_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1830:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1830:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DOUBLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DOUBLE\")" );
                    ex->set_ruleName( "double_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_double_key10179);
            if  (this->hasException())
            {
                goto ruledouble_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledouble_keyEx; /* Prevent compiler warnings */
    ruledouble_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end double_key */

/**
 * $ANTLR start precision_key
 * PLSQLKeys.g:1833:1: precision_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::precision_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1834:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1834:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "PRECISION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"PRECISION\")" );
                    ex->set_ruleName( "precision_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_precision_key10201);
            if  (this->hasException())
            {
                goto ruleprecision_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprecision_keyEx; /* Prevent compiler warnings */
    ruleprecision_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end precision_key */

/**
 * $ANTLR start interval_key
 * PLSQLKeys.g:1837:1: interval_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::interval_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1838:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1838:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INTERVAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INTERVAL\")" );
                    ex->set_ruleName( "interval_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_interval_key10224);
            if  (this->hasException())
            {
                goto ruleinterval_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinterval_keyEx; /* Prevent compiler warnings */
    ruleinterval_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end interval_key */

/**
 * $ANTLR start time_key
 * PLSQLKeys.g:1841:1: time_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::time_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1842:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1842:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIME"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIME\")" );
                    ex->set_ruleName( "time_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_time_key10246);
            if  (this->hasException())
            {
                goto ruletime_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletime_keyEx; /* Prevent compiler warnings */
    ruletime_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end time_key */

/**
 * $ANTLR start zone_key
 * PLSQLKeys.g:1845:1: zone_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::zone_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1846:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1846:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "ZONE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"ZONE\")" );
                    ex->set_ruleName( "zone_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_zone_key10269);
            if  (this->hasException())
            {
                goto rulezone_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulezone_keyEx; /* Prevent compiler warnings */
    rulezone_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end zone_key */

/**
 * $ANTLR start timestamp_key
 * PLSQLKeys.g:1849:1: timestamp_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::timestamp_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1850:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1850:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIMESTAMP\")" );
                    ex->set_ruleName( "timestamp_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timestamp_key10291);
            if  (this->hasException())
            {
                goto ruletimestamp_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletimestamp_keyEx; /* Prevent compiler warnings */
    ruletimestamp_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timestamp_key */

/**
 * $ANTLR start date_key
 * PLSQLKeys.g:1853:1: date_key : SQL92_RESERVED_DATE ;
 */
void
PLSQLParser_PLSQLKeys::date_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1854:5: ( SQL92_RESERVED_DATE )
        // PLSQLKeys.g:1854:10: SQL92_RESERVED_DATE
        {
             this->matchToken(SQL92_RESERVED_DATE, &FOLLOW_SQL92_RESERVED_DATE_in_date_key10311);
            if  (this->hasException())
            {
                goto ruledate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledate_keyEx; /* Prevent compiler warnings */
    ruledate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end date_key */

/**
 * $ANTLR start numeric_key
 * PLSQLKeys.g:1857:1: numeric_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::numeric_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1858:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1858:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NUMERIC"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NUMERIC\")" );
                    ex->set_ruleName( "numeric_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_numeric_key10334);
            if  (this->hasException())
            {
                goto rulenumeric_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenumeric_keyEx; /* Prevent compiler warnings */
    rulenumeric_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end numeric_key */

/**
 * $ANTLR start decimal_key
 * PLSQLKeys.g:1861:1: decimal_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::decimal_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1862:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1862:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DECIMAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DECIMAL\")" );
                    ex->set_ruleName( "decimal_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_decimal_key10357);
            if  (this->hasException())
            {
                goto ruledecimal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledecimal_keyEx; /* Prevent compiler warnings */
    ruledecimal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end decimal_key */

/**
 * $ANTLR start dec_key
 * PLSQLKeys.g:1865:1: dec_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::dec_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1866:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1866:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DEC"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DEC\")" );
                    ex->set_ruleName( "dec_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_dec_key10380);
            if  (this->hasException())
            {
                goto ruledec_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledec_keyEx; /* Prevent compiler warnings */
    ruledec_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dec_key */

/**
 * $ANTLR start integer_key
 * PLSQLKeys.g:1869:1: integer_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::integer_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1870:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1870:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INTEGER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INTEGER\")" );
                    ex->set_ruleName( "integer_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_integer_key10403);
            if  (this->hasException())
            {
                goto ruleinteger_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinteger_keyEx; /* Prevent compiler warnings */
    ruleinteger_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end integer_key */

/**
 * $ANTLR start int_key
 * PLSQLKeys.g:1873:1: int_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::int_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1874:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1874:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INT\")" );
                    ex->set_ruleName( "int_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_int_key10426);
            if  (this->hasException())
            {
                goto ruleint_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleint_keyEx; /* Prevent compiler warnings */
    ruleint_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end int_key */

/**
 * $ANTLR start smallint_key
 * PLSQLKeys.g:1877:1: smallint_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::smallint_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1878:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1878:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SMALLINT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SMALLINT\")" );
                    ex->set_ruleName( "smallint_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_smallint_key10449);
            if  (this->hasException())
            {
                goto rulesmallint_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesmallint_keyEx; /* Prevent compiler warnings */
    rulesmallint_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end smallint_key */

/**
 * $ANTLR start corresponding_key
 * PLSQLKeys.g:1881:1: corresponding_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::corresponding_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1882:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1882:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CORRESPONDING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CORRESPONDING\")" );
                    ex->set_ruleName( "corresponding_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_corresponding_key10471);
            if  (this->hasException())
            {
                goto rulecorresponding_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecorresponding_keyEx; /* Prevent compiler warnings */
    rulecorresponding_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end corresponding_key */

/**
 * $ANTLR start cross_key
 * PLSQLKeys.g:1885:1: cross_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::cross_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1886:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1886:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CROSS"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CROSS\")" );
                    ex->set_ruleName( "cross_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cross_key10494);
            if  (this->hasException())
            {
                goto rulecross_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecross_keyEx; /* Prevent compiler warnings */
    rulecross_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cross_key */

/**
 * $ANTLR start join_key
 * PLSQLKeys.g:1889:1: join_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::join_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1890:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1890:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "JOIN"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"JOIN\")" );
                    ex->set_ruleName( "join_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_join_key10517);
            if  (this->hasException())
            {
                goto rulejoin_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulejoin_keyEx; /* Prevent compiler warnings */
    rulejoin_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end join_key */

/**
 * $ANTLR start left_key
 * PLSQLKeys.g:1893:1: left_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::left_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1894:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1894:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LEFT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LEFT\")" );
                    ex->set_ruleName( "left_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_left_key10540);
            if  (this->hasException())
            {
                goto ruleleft_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleleft_keyEx; /* Prevent compiler warnings */
    ruleleft_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end left_key */

/**
 * $ANTLR start right_key
 * PLSQLKeys.g:1897:1: right_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::right_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1898:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1898:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "RIGHT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"RIGHT\")" );
                    ex->set_ruleName( "right_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_right_key10563);
            if  (this->hasException())
            {
                goto ruleright_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleright_keyEx; /* Prevent compiler warnings */
    ruleright_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end right_key */

/**
 * $ANTLR start inner_key
 * PLSQLKeys.g:1901:1: inner_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::inner_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1902:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1902:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INNER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INNER\")" );
                    ex->set_ruleName( "inner_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_inner_key10586);
            if  (this->hasException())
            {
                goto ruleinner_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinner_keyEx; /* Prevent compiler warnings */
    ruleinner_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end inner_key */

/**
 * $ANTLR start natural_key
 * PLSQLKeys.g:1905:1: natural_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::natural_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1906:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1906:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NATURAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NATURAL\")" );
                    ex->set_ruleName( "natural_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_natural_key10609);
            if  (this->hasException())
            {
                goto rulenatural_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenatural_keyEx; /* Prevent compiler warnings */
    rulenatural_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end natural_key */

/**
 * $ANTLR start outer_key
 * PLSQLKeys.g:1909:1: outer_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::outer_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1910:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1910:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OUTER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OUTER\")" );
                    ex->set_ruleName( "outer_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_outer_key10632);
            if  (this->hasException())
            {
                goto ruleouter_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleouter_keyEx; /* Prevent compiler warnings */
    ruleouter_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end outer_key */

/**
 * $ANTLR start using_key
 * PLSQLKeys.g:1913:1: using_key : PLSQL_NON_RESERVED_USING ;
 */
void
PLSQLParser_PLSQLKeys::using_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1914:5: ( PLSQL_NON_RESERVED_USING )
        // PLSQLKeys.g:1914:10: PLSQL_NON_RESERVED_USING
        {
             this->matchToken(PLSQL_NON_RESERVED_USING, &FOLLOW_PLSQL_NON_RESERVED_USING_in_using_key10652);
            if  (this->hasException())
            {
                goto ruleusing_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleusing_keyEx; /* Prevent compiler warnings */
    ruleusing_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end using_key */

/**
 * $ANTLR start indicator_key
 * PLSQLKeys.g:1917:1: indicator_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::indicator_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1918:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1918:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "INDICATOR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"INDICATOR\")" );
                    ex->set_ruleName( "indicator_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_indicator_key10674);
            if  (this->hasException())
            {
                goto ruleindicator_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleindicator_keyEx; /* Prevent compiler warnings */
    ruleindicator_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end indicator_key */

/**
 * $ANTLR start user_key
 * PLSQLKeys.g:1921:1: user_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::user_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1922:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1922:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "USER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"USER\")" );
                    ex->set_ruleName( "user_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_user_key10696);
            if  (this->hasException())
            {
                goto ruleuser_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleuser_keyEx; /* Prevent compiler warnings */
    ruleuser_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end user_key */

/**
 * $ANTLR start current_user_key
 * PLSQLKeys.g:1925:1: current_user_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::current_user_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1926:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1926:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CURRENT_USER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CURRENT_USER\")" );
                    ex->set_ruleName( "current_user_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_current_user_key10718);
            if  (this->hasException())
            {
                goto rulecurrent_user_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecurrent_user_keyEx; /* Prevent compiler warnings */
    rulecurrent_user_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end current_user_key */

/**
 * $ANTLR start session_user_key
 * PLSQLKeys.g:1929:1: session_user_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::session_user_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1930:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1930:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SESSION_USER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SESSION_USER\")" );
                    ex->set_ruleName( "session_user_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_session_user_key10740);
            if  (this->hasException())
            {
                goto rulesession_user_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesession_user_keyEx; /* Prevent compiler warnings */
    rulesession_user_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end session_user_key */

/**
 * $ANTLR start system_user_key
 * PLSQLKeys.g:1933:1: system_user_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::system_user_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1934:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1934:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SYSTEM_USER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SYSTEM_USER\")" );
                    ex->set_ruleName( "system_user_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_system_user_key10762);
            if  (this->hasException())
            {
                goto rulesystem_user_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesystem_user_keyEx; /* Prevent compiler warnings */
    rulesystem_user_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end system_user_key */

/**
 * $ANTLR start value_key
 * PLSQLKeys.g:1937:1: value_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::value_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1938:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1938:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "VALUE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"VALUE\")" );
                    ex->set_ruleName( "value_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_value_key10784);
            if  (this->hasException())
            {
                goto rulevalue_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevalue_keyEx; /* Prevent compiler warnings */
    rulevalue_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end value_key */

/**
 * $ANTLR start substring_key
 * PLSQLKeys.g:1941:1: substring_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::substring_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1942:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:1942:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SUBSTRING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SUBSTRING\")" );
                    ex->set_ruleName( "substring_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_substring_key10807);
            if  (this->hasException())
            {
                goto rulesubstring_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubstring_keyEx; /* Prevent compiler warnings */
    rulesubstring_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end substring_key */

/**
 * $ANTLR start upper_key
 * PLSQLKeys.g:1945:1: upper_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::upper_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1946:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1946:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "UPPER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"UPPER\")" );
                    ex->set_ruleName( "upper_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_upper_key10829);
            if  (this->hasException())
            {
                goto ruleupper_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleupper_keyEx; /* Prevent compiler warnings */
    ruleupper_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end upper_key */

/**
 * $ANTLR start lower_key
 * PLSQLKeys.g:1949:1: lower_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::lower_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1950:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1950:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LOWER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LOWER\")" );
                    ex->set_ruleName( "lower_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_lower_key10851);
            if  (this->hasException())
            {
                goto rulelower_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelower_keyEx; /* Prevent compiler warnings */
    rulelower_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end lower_key */

/**
 * $ANTLR start convert_key
 * PLSQLKeys.g:1953:1: convert_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::convert_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1954:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1954:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CONVERT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CONVERT\")" );
                    ex->set_ruleName( "convert_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_convert_key10873);
            if  (this->hasException())
            {
                goto ruleconvert_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconvert_keyEx; /* Prevent compiler warnings */
    ruleconvert_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end convert_key */

/**
 * $ANTLR start translate_key
 * PLSQLKeys.g:1957:1: translate_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::translate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1958:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1958:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TRANSLATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TRANSLATE\")" );
                    ex->set_ruleName( "translate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_translate_key10895);
            if  (this->hasException())
            {
                goto ruletranslate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletranslate_keyEx; /* Prevent compiler warnings */
    ruletranslate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end translate_key */

/**
 * $ANTLR start trim_key
 * PLSQLKeys.g:1961:1: trim_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::trim_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1962:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1962:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TRIM"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TRIM\")" );
                    ex->set_ruleName( "trim_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_trim_key10917);
            if  (this->hasException())
            {
                goto ruletrim_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletrim_keyEx; /* Prevent compiler warnings */
    ruletrim_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end trim_key */

/**
 * $ANTLR start leading_key
 * PLSQLKeys.g:1965:1: leading_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::leading_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1966:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1966:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LEADING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LEADING\")" );
                    ex->set_ruleName( "leading_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_leading_key10939);
            if  (this->hasException())
            {
                goto ruleleading_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleleading_keyEx; /* Prevent compiler warnings */
    ruleleading_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end leading_key */

/**
 * $ANTLR start trailing_key
 * PLSQLKeys.g:1969:1: trailing_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::trailing_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1970:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1970:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TRAILING"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TRAILING\")" );
                    ex->set_ruleName( "trailing_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_trailing_key10961);
            if  (this->hasException())
            {
                goto ruletrailing_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletrailing_keyEx; /* Prevent compiler warnings */
    ruletrailing_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end trailing_key */

/**
 * $ANTLR start both_key
 * PLSQLKeys.g:1973:1: both_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::both_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1974:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1974:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BOTH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BOTH\")" );
                    ex->set_ruleName( "both_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_both_key10983);
            if  (this->hasException())
            {
                goto ruleboth_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleboth_keyEx; /* Prevent compiler warnings */
    ruleboth_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end both_key */

/**
 * $ANTLR start collate_key
 * PLSQLKeys.g:1977:1: collate_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::collate_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1978:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1978:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "COLLATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"COLLATE\")" );
                    ex->set_ruleName( "collate_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_collate_key11005);
            if  (this->hasException())
            {
                goto rulecollate_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecollate_keyEx; /* Prevent compiler warnings */
    rulecollate_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end collate_key */

/**
 * $ANTLR start position_key
 * PLSQLKeys.g:1981:1: position_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::position_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1982:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1982:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "POSITION"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"POSITION\")" );
                    ex->set_ruleName( "position_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_position_key11027);
            if  (this->hasException())
            {
                goto ruleposition_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleposition_keyEx; /* Prevent compiler warnings */
    ruleposition_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end position_key */

/**
 * $ANTLR start extract_key
 * PLSQLKeys.g:1985:1: extract_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::extract_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1986:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1986:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "EXTRACT"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"EXTRACT\")" );
                    ex->set_ruleName( "extract_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_extract_key11049);
            if  (this->hasException())
            {
                goto ruleextract_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleextract_keyEx; /* Prevent compiler warnings */
    ruleextract_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end extract_key */

/**
 * $ANTLR start second_key
 * PLSQLKeys.g:1989:1: second_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::second_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1990:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1990:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SECOND"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SECOND\")" );
                    ex->set_ruleName( "second_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_second_key11071);
            if  (this->hasException())
            {
                goto rulesecond_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesecond_keyEx; /* Prevent compiler warnings */
    rulesecond_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end second_key */

/**
 * $ANTLR start timezone_hour_key
 * PLSQLKeys.g:1993:1: timezone_hour_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::timezone_hour_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1994:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1994:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_HOUR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIMEZONE_HOUR\")" );
                    ex->set_ruleName( "timezone_hour_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timezone_hour_key11093);
            if  (this->hasException())
            {
                goto ruletimezone_hour_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletimezone_hour_keyEx; /* Prevent compiler warnings */
    ruletimezone_hour_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timezone_hour_key */

/**
 * $ANTLR start timezone_minute_key
 * PLSQLKeys.g:1997:1: timezone_minute_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::timezone_minute_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:1998:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:1998:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "TIMEZONE_MINUTE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"TIMEZONE_MINUTE\")" );
                    ex->set_ruleName( "timezone_minute_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_timezone_minute_key11115);
            if  (this->hasException())
            {
                goto ruletimezone_minute_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletimezone_minute_keyEx; /* Prevent compiler warnings */
    ruletimezone_minute_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end timezone_minute_key */

/**
 * $ANTLR start char_length_key
 * PLSQLKeys.g:2001:1: char_length_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::char_length_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2002:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2002:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CHAR_LENGTH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CHAR_LENGTH\")" );
                    ex->set_ruleName( "char_length_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_char_length_key11137);
            if  (this->hasException())
            {
                goto rulechar_length_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulechar_length_keyEx; /* Prevent compiler warnings */
    rulechar_length_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end char_length_key */

/**
 * $ANTLR start octet_length_key
 * PLSQLKeys.g:2005:1: octet_length_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::octet_length_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2006:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2006:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "OCTET_LENGTH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"OCTET_LENGTH\")" );
                    ex->set_ruleName( "octet_length_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_octet_length_key11159);
            if  (this->hasException())
            {
                goto ruleoctet_length_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleoctet_length_keyEx; /* Prevent compiler warnings */
    ruleoctet_length_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end octet_length_key */

/**
 * $ANTLR start character_length_key
 * PLSQLKeys.g:2009:1: character_length_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::character_length_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2010:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2010:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CHARACTER_LENGTH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CHARACTER_LENGTH\")" );
                    ex->set_ruleName( "character_length_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_character_length_key11181);
            if  (this->hasException())
            {
                goto rulecharacter_length_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecharacter_length_keyEx; /* Prevent compiler warnings */
    rulecharacter_length_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end character_length_key */

/**
 * $ANTLR start bit_length_key
 * PLSQLKeys.g:2013:1: bit_length_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::bit_length_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2014:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2014:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BIT_LENGTH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BIT_LENGTH\")" );
                    ex->set_ruleName( "bit_length_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_bit_length_key11203);
            if  (this->hasException())
            {
                goto rulebit_length_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebit_length_keyEx; /* Prevent compiler warnings */
    rulebit_length_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end bit_length_key */

/**
 * $ANTLR start local_key
 * PLSQLKeys.g:2017:1: local_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::local_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2018:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2018:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "LOCAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"LOCAL\")" );
                    ex->set_ruleName( "local_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_local_key11225);
            if  (this->hasException())
            {
                goto rulelocal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelocal_keyEx; /* Prevent compiler warnings */
    rulelocal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end local_key */

/**
 * $ANTLR start current_timestamp_key
 * PLSQLKeys.g:2021:1: current_timestamp_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::current_timestamp_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2022:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2022:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CURRENT_TIMESTAMP"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CURRENT_TIMESTAMP\")" );
                    ex->set_ruleName( "current_timestamp_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_current_timestamp_key11247);
            if  (this->hasException())
            {
                goto rulecurrent_timestamp_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecurrent_timestamp_keyEx; /* Prevent compiler warnings */
    rulecurrent_timestamp_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end current_timestamp_key */

/**
 * $ANTLR start current_date_key
 * PLSQLKeys.g:2025:1: current_date_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::current_date_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2026:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2026:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CURRENT_DATE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CURRENT_DATE\")" );
                    ex->set_ruleName( "current_date_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_current_date_key11269);
            if  (this->hasException())
            {
                goto rulecurrent_date_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecurrent_date_keyEx; /* Prevent compiler warnings */
    rulecurrent_date_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end current_date_key */

/**
 * $ANTLR start current_time_key
 * PLSQLKeys.g:2029:1: current_time_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::current_time_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2030:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2030:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CURRENT_TIME"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CURRENT_TIME\")" );
                    ex->set_ruleName( "current_time_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_current_time_key11291);
            if  (this->hasException())
            {
                goto rulecurrent_time_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecurrent_time_keyEx; /* Prevent compiler warnings */
    rulecurrent_time_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end current_time_key */

/**
 * $ANTLR start module_key
 * PLSQLKeys.g:2033:1: module_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::module_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2034:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2034:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MODULE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MODULE\")" );
                    ex->set_ruleName( "module_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_module_key11313);
            if  (this->hasException())
            {
                goto rulemodule_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodule_keyEx; /* Prevent compiler warnings */
    rulemodule_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end module_key */

/**
 * $ANTLR start global_key
 * PLSQLKeys.g:2037:1: global_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::global_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2038:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2038:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "GLOBAL"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"GLOBAL\")" );
                    ex->set_ruleName( "global_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_global_key11335);
            if  (this->hasException())
            {
                goto ruleglobal_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleglobal_keyEx; /* Prevent compiler warnings */
    ruleglobal_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end global_key */

/**
 * $ANTLR start year_key
 * PLSQLKeys.g:2041:1: year_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::year_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2042:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:2042:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "YEAR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"YEAR\")" );
                    ex->set_ruleName( "year_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_year_key11358);
            if  (this->hasException())
            {
                goto ruleyear_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleyear_keyEx; /* Prevent compiler warnings */
    ruleyear_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end year_key */

/**
 * $ANTLR start month_key
 * PLSQLKeys.g:2045:1: month_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::month_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2046:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2046:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MONTH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MONTH\")" );
                    ex->set_ruleName( "month_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_month_key11380);
            if  (this->hasException())
            {
                goto rulemonth_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemonth_keyEx; /* Prevent compiler warnings */
    rulemonth_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end month_key */

/**
 * $ANTLR start day_key
 * PLSQLKeys.g:2049:1: day_key :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::day_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2050:5: ({...}? => REGULAR_ID )
        // PLSQLKeys.g:2050:10: {...}? => REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DAY"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DAY\")" );
                    ex->set_ruleName( "day_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_day_key11403);
            if  (this->hasException())
            {
                goto ruleday_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleday_keyEx; /* Prevent compiler warnings */
    ruleday_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end day_key */

/**
 * $ANTLR start hour_key
 * PLSQLKeys.g:2053:1: hour_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::hour_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2054:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2054:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "HOUR"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"HOUR\")" );
                    ex->set_ruleName( "hour_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_hour_key11425);
            if  (this->hasException())
            {
                goto rulehour_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulehour_keyEx; /* Prevent compiler warnings */
    rulehour_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end hour_key */

/**
 * $ANTLR start minute_key
 * PLSQLKeys.g:2057:1: minute_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::minute_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2058:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2058:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "MINUTE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"MINUTE\")" );
                    ex->set_ruleName( "minute_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_minute_key11447);
            if  (this->hasException())
            {
                goto ruleminute_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleminute_keyEx; /* Prevent compiler warnings */
    ruleminute_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end minute_key */

/**
 * $ANTLR start whenever_key
 * PLSQLKeys.g:2061:1: whenever_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::whenever_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2062:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2062:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "WHENEVER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"WHENEVER\")" );
                    ex->set_ruleName( "whenever_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_whenever_key11469);
            if  (this->hasException())
            {
                goto rulewhenever_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewhenever_keyEx; /* Prevent compiler warnings */
    rulewhenever_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end whenever_key */

/**
 * $ANTLR start is_key
 * PLSQLKeys.g:2065:1: is_key : SQL92_RESERVED_IS ;
 */
void
PLSQLParser_PLSQLKeys::is_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2066:5: ( SQL92_RESERVED_IS )
        // PLSQLKeys.g:2066:10: SQL92_RESERVED_IS
        {
             this->matchToken(SQL92_RESERVED_IS, &FOLLOW_SQL92_RESERVED_IS_in_is_key11489);
            if  (this->hasException())
            {
                goto ruleis_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleis_keyEx; /* Prevent compiler warnings */
    ruleis_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end is_key */

/**
 * $ANTLR start else_key
 * PLSQLKeys.g:2069:1: else_key : SQL92_RESERVED_ELSE ;
 */
void
PLSQLParser_PLSQLKeys::else_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2070:5: ( SQL92_RESERVED_ELSE )
        // PLSQLKeys.g:2070:10: SQL92_RESERVED_ELSE
        {
             this->matchToken(SQL92_RESERVED_ELSE, &FOLLOW_SQL92_RESERVED_ELSE_in_else_key11509);
            if  (this->hasException())
            {
                goto ruleelse_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleelse_keyEx; /* Prevent compiler warnings */
    ruleelse_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end else_key */

/**
 * $ANTLR start table_key
 * PLSQLKeys.g:2073:1: table_key : SQL92_RESERVED_TABLE ;
 */
void
PLSQLParser_PLSQLKeys::table_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2074:5: ( SQL92_RESERVED_TABLE )
        // PLSQLKeys.g:2074:10: SQL92_RESERVED_TABLE
        {
             this->matchToken(SQL92_RESERVED_TABLE, &FOLLOW_SQL92_RESERVED_TABLE_in_table_key11529);
            if  (this->hasException())
            {
                goto ruletable_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_keyEx; /* Prevent compiler warnings */
    ruletable_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_key */

/**
 * $ANTLR start the_key
 * PLSQLKeys.g:2077:1: the_key : SQL92_RESERVED_THE ;
 */
void
PLSQLParser_PLSQLKeys::the_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2078:5: ( SQL92_RESERVED_THE )
        // PLSQLKeys.g:2078:10: SQL92_RESERVED_THE
        {
             this->matchToken(SQL92_RESERVED_THE, &FOLLOW_SQL92_RESERVED_THE_in_the_key11549);
            if  (this->hasException())
            {
                goto rulethe_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulethe_keyEx; /* Prevent compiler warnings */
    rulethe_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end the_key */

/**
 * $ANTLR start then_key
 * PLSQLKeys.g:2081:1: then_key : SQL92_RESERVED_THEN ;
 */
void
PLSQLParser_PLSQLKeys::then_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2082:5: ( SQL92_RESERVED_THEN )
        // PLSQLKeys.g:2082:10: SQL92_RESERVED_THEN
        {
             this->matchToken(SQL92_RESERVED_THEN, &FOLLOW_SQL92_RESERVED_THEN_in_then_key11569);
            if  (this->hasException())
            {
                goto rulethen_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulethen_keyEx; /* Prevent compiler warnings */
    rulethen_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end then_key */

/**
 * $ANTLR start end_key
 * PLSQLKeys.g:2085:1: end_key : SQL92_RESERVED_END ;
 */
void
PLSQLParser_PLSQLKeys::end_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2086:5: ( SQL92_RESERVED_END )
        // PLSQLKeys.g:2086:10: SQL92_RESERVED_END
        {
             this->matchToken(SQL92_RESERVED_END, &FOLLOW_SQL92_RESERVED_END_in_end_key11589);
            if  (this->hasException())
            {
                goto ruleend_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleend_keyEx; /* Prevent compiler warnings */
    ruleend_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end end_key */

/**
 * $ANTLR start all_key
 * PLSQLKeys.g:2089:1: all_key : SQL92_RESERVED_ALL ;
 */
void
PLSQLParser_PLSQLKeys::all_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2090:5: ( SQL92_RESERVED_ALL )
        // PLSQLKeys.g:2090:10: SQL92_RESERVED_ALL
        {
             this->matchToken(SQL92_RESERVED_ALL, &FOLLOW_SQL92_RESERVED_ALL_in_all_key11609);
            if  (this->hasException())
            {
                goto ruleall_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleall_keyEx; /* Prevent compiler warnings */
    ruleall_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end all_key */

/**
 * $ANTLR start on_key
 * PLSQLKeys.g:2093:1: on_key : SQL92_RESERVED_ON ;
 */
void
PLSQLParser_PLSQLKeys::on_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2094:5: ( SQL92_RESERVED_ON )
        // PLSQLKeys.g:2094:10: SQL92_RESERVED_ON
        {
             this->matchToken(SQL92_RESERVED_ON, &FOLLOW_SQL92_RESERVED_ON_in_on_key11629);
            if  (this->hasException())
            {
                goto ruleon_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleon_keyEx; /* Prevent compiler warnings */
    ruleon_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end on_key */

/**
 * $ANTLR start or_key
 * PLSQLKeys.g:2097:1: or_key : SQL92_RESERVED_OR ;
 */
void
PLSQLParser_PLSQLKeys::or_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2098:5: ( SQL92_RESERVED_OR )
        // PLSQLKeys.g:2098:10: SQL92_RESERVED_OR
        {
             this->matchToken(SQL92_RESERVED_OR, &FOLLOW_SQL92_RESERVED_OR_in_or_key11649);
            if  (this->hasException())
            {
                goto ruleor_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleor_keyEx; /* Prevent compiler warnings */
    ruleor_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end or_key */

/**
 * $ANTLR start and_key
 * PLSQLKeys.g:2101:1: and_key : SQL92_RESERVED_AND ;
 */
void
PLSQLParser_PLSQLKeys::and_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2102:5: ( SQL92_RESERVED_AND )
        // PLSQLKeys.g:2102:10: SQL92_RESERVED_AND
        {
             this->matchToken(SQL92_RESERVED_AND, &FOLLOW_SQL92_RESERVED_AND_in_and_key11669);
            if  (this->hasException())
            {
                goto ruleand_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleand_keyEx; /* Prevent compiler warnings */
    ruleand_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end and_key */

/**
 * $ANTLR start not_key
 * PLSQLKeys.g:2105:1: not_key : SQL92_RESERVED_NOT ;
 */
void
PLSQLParser_PLSQLKeys::not_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2106:5: ( SQL92_RESERVED_NOT )
        // PLSQLKeys.g:2106:10: SQL92_RESERVED_NOT
        {
             this->matchToken(SQL92_RESERVED_NOT, &FOLLOW_SQL92_RESERVED_NOT_in_not_key11689);
            if  (this->hasException())
            {
                goto rulenot_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenot_keyEx; /* Prevent compiler warnings */
    rulenot_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end not_key */

/**
 * $ANTLR start true_key
 * PLSQLKeys.g:2109:1: true_key : SQL92_RESERVED_TRUE ;
 */
void
PLSQLParser_PLSQLKeys::true_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2110:5: ( SQL92_RESERVED_TRUE )
        // PLSQLKeys.g:2110:10: SQL92_RESERVED_TRUE
        {
             this->matchToken(SQL92_RESERVED_TRUE, &FOLLOW_SQL92_RESERVED_TRUE_in_true_key11709);
            if  (this->hasException())
            {
                goto ruletrue_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletrue_keyEx; /* Prevent compiler warnings */
    ruletrue_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end true_key */

/**
 * $ANTLR start false_key
 * PLSQLKeys.g:2113:1: false_key : SQL92_RESERVED_FALSE ;
 */
void
PLSQLParser_PLSQLKeys::false_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2114:5: ( SQL92_RESERVED_FALSE )
        // PLSQLKeys.g:2114:10: SQL92_RESERVED_FALSE
        {
             this->matchToken(SQL92_RESERVED_FALSE, &FOLLOW_SQL92_RESERVED_FALSE_in_false_key11729);
            if  (this->hasException())
            {
                goto rulefalse_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefalse_keyEx; /* Prevent compiler warnings */
    rulefalse_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end false_key */

/**
 * $ANTLR start default_key
 * PLSQLKeys.g:2117:1: default_key : SQL92_RESERVED_DEFAULT ;
 */
void
PLSQLParser_PLSQLKeys::default_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2118:5: ( SQL92_RESERVED_DEFAULT )
        // PLSQLKeys.g:2118:10: SQL92_RESERVED_DEFAULT
        {
             this->matchToken(SQL92_RESERVED_DEFAULT, &FOLLOW_SQL92_RESERVED_DEFAULT_in_default_key11749);
            if  (this->hasException())
            {
                goto ruledefault_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledefault_keyEx; /* Prevent compiler warnings */
    ruledefault_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end default_key */

/**
 * $ANTLR start distinct_key
 * PLSQLKeys.g:2121:1: distinct_key : SQL92_RESERVED_DISTINCT ;
 */
void
PLSQLParser_PLSQLKeys::distinct_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2122:5: ( SQL92_RESERVED_DISTINCT )
        // PLSQLKeys.g:2122:10: SQL92_RESERVED_DISTINCT
        {
             this->matchToken(SQL92_RESERVED_DISTINCT, &FOLLOW_SQL92_RESERVED_DISTINCT_in_distinct_key11769);
            if  (this->hasException())
            {
                goto ruledistinct_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledistinct_keyEx; /* Prevent compiler warnings */
    ruledistinct_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end distinct_key */

/**
 * $ANTLR start into_key
 * PLSQLKeys.g:2125:1: into_key : SQL92_RESERVED_INTO ;
 */
void
PLSQLParser_PLSQLKeys::into_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2126:5: ( SQL92_RESERVED_INTO )
        // PLSQLKeys.g:2126:10: SQL92_RESERVED_INTO
        {
             this->matchToken(SQL92_RESERVED_INTO, &FOLLOW_SQL92_RESERVED_INTO_in_into_key11789);
            if  (this->hasException())
            {
                goto ruleinto_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinto_keyEx; /* Prevent compiler warnings */
    ruleinto_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end into_key */

/**
 * $ANTLR start by_key
 * PLSQLKeys.g:2129:1: by_key : SQL92_RESERVED_BY ;
 */
void
PLSQLParser_PLSQLKeys::by_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2130:5: ( SQL92_RESERVED_BY )
        // PLSQLKeys.g:2130:10: SQL92_RESERVED_BY
        {
             this->matchToken(SQL92_RESERVED_BY, &FOLLOW_SQL92_RESERVED_BY_in_by_key11809);
            if  (this->hasException())
            {
                goto ruleby_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleby_keyEx; /* Prevent compiler warnings */
    ruleby_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end by_key */

/**
 * $ANTLR start as_key
 * PLSQLKeys.g:2133:1: as_key : SQL92_RESERVED_AS ;
 */
void
PLSQLParser_PLSQLKeys::as_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2134:5: ( SQL92_RESERVED_AS )
        // PLSQLKeys.g:2134:10: SQL92_RESERVED_AS
        {
             this->matchToken(SQL92_RESERVED_AS, &FOLLOW_SQL92_RESERVED_AS_in_as_key11829);
            if  (this->hasException())
            {
                goto ruleas_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleas_keyEx; /* Prevent compiler warnings */
    ruleas_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end as_key */

/**
 * $ANTLR start in_key
 * PLSQLKeys.g:2137:1: in_key : SQL92_RESERVED_IN ;
 */
void
PLSQLParser_PLSQLKeys::in_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2138:5: ( SQL92_RESERVED_IN )
        // PLSQLKeys.g:2138:10: SQL92_RESERVED_IN
        {
             this->matchToken(SQL92_RESERVED_IN, &FOLLOW_SQL92_RESERVED_IN_in_in_key11849);
            if  (this->hasException())
            {
                goto rulein_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulein_keyEx; /* Prevent compiler warnings */
    rulein_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end in_key */

/**
 * $ANTLR start of_key
 * PLSQLKeys.g:2141:1: of_key : SQL92_RESERVED_OF ;
 */
void
PLSQLParser_PLSQLKeys::of_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2142:5: ( SQL92_RESERVED_OF )
        // PLSQLKeys.g:2142:10: SQL92_RESERVED_OF
        {
             this->matchToken(SQL92_RESERVED_OF, &FOLLOW_SQL92_RESERVED_OF_in_of_key11869);
            if  (this->hasException())
            {
                goto ruleof_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleof_keyEx; /* Prevent compiler warnings */
    ruleof_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end of_key */

/**
 * $ANTLR start null_key
 * PLSQLKeys.g:2145:1: null_key : SQL92_RESERVED_NULL ;
 */
void
PLSQLParser_PLSQLKeys::null_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2146:5: ( SQL92_RESERVED_NULL )
        // PLSQLKeys.g:2146:10: SQL92_RESERVED_NULL
        {
             this->matchToken(SQL92_RESERVED_NULL, &FOLLOW_SQL92_RESERVED_NULL_in_null_key11889);
            if  (this->hasException())
            {
                goto rulenull_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenull_keyEx; /* Prevent compiler warnings */
    rulenull_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end null_key */

/**
 * $ANTLR start for_key
 * PLSQLKeys.g:2149:1: for_key : SQL92_RESERVED_FOR ;
 */
void
PLSQLParser_PLSQLKeys::for_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2150:5: ( SQL92_RESERVED_FOR )
        // PLSQLKeys.g:2150:10: SQL92_RESERVED_FOR
        {
             this->matchToken(SQL92_RESERVED_FOR, &FOLLOW_SQL92_RESERVED_FOR_in_for_key11909);
            if  (this->hasException())
            {
                goto rulefor_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefor_keyEx; /* Prevent compiler warnings */
    rulefor_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end for_key */

/**
 * $ANTLR start select_key
 * PLSQLKeys.g:2153:1: select_key : SQL92_RESERVED_SELECT ;
 */
void
PLSQLParser_PLSQLKeys::select_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2154:5: ( SQL92_RESERVED_SELECT )
        // PLSQLKeys.g:2154:10: SQL92_RESERVED_SELECT
        {
             this->matchToken(SQL92_RESERVED_SELECT, &FOLLOW_SQL92_RESERVED_SELECT_in_select_key11929);
            if  (this->hasException())
            {
                goto ruleselect_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleselect_keyEx; /* Prevent compiler warnings */
    ruleselect_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end select_key */

/**
 * $ANTLR start when_key
 * PLSQLKeys.g:2157:1: when_key : SQL92_RESERVED_WHEN ;
 */
void
PLSQLParser_PLSQLKeys::when_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2158:5: ( SQL92_RESERVED_WHEN )
        // PLSQLKeys.g:2158:10: SQL92_RESERVED_WHEN
        {
             this->matchToken(SQL92_RESERVED_WHEN, &FOLLOW_SQL92_RESERVED_WHEN_in_when_key11949);
            if  (this->hasException())
            {
                goto rulewhen_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewhen_keyEx; /* Prevent compiler warnings */
    rulewhen_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end when_key */

/**
 * $ANTLR start delete_key
 * PLSQLKeys.g:2161:1: delete_key : SQL92_RESERVED_DELETE ;
 */
void
PLSQLParser_PLSQLKeys::delete_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2162:5: ( SQL92_RESERVED_DELETE )
        // PLSQLKeys.g:2162:10: SQL92_RESERVED_DELETE
        {
             this->matchToken(SQL92_RESERVED_DELETE, &FOLLOW_SQL92_RESERVED_DELETE_in_delete_key11969);
            if  (this->hasException())
            {
                goto ruledelete_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledelete_keyEx; /* Prevent compiler warnings */
    ruledelete_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end delete_key */

/**
 * $ANTLR start between_key
 * PLSQLKeys.g:2165:1: between_key : SQL92_RESERVED_BETWEEN ;
 */
void
PLSQLParser_PLSQLKeys::between_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2166:5: ( SQL92_RESERVED_BETWEEN )
        // PLSQLKeys.g:2166:10: SQL92_RESERVED_BETWEEN
        {
             this->matchToken(SQL92_RESERVED_BETWEEN, &FOLLOW_SQL92_RESERVED_BETWEEN_in_between_key11989);
            if  (this->hasException())
            {
                goto rulebetween_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebetween_keyEx; /* Prevent compiler warnings */
    rulebetween_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end between_key */

/**
 * $ANTLR start like_key
 * PLSQLKeys.g:2169:1: like_key : SQL92_RESERVED_LIKE ;
 */
void
PLSQLParser_PLSQLKeys::like_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2170:5: ( SQL92_RESERVED_LIKE )
        // PLSQLKeys.g:2170:10: SQL92_RESERVED_LIKE
        {
             this->matchToken(SQL92_RESERVED_LIKE, &FOLLOW_SQL92_RESERVED_LIKE_in_like_key12009);
            if  (this->hasException())
            {
                goto rulelike_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelike_keyEx; /* Prevent compiler warnings */
    rulelike_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end like_key */

/**
 * $ANTLR start from_key
 * PLSQLKeys.g:2173:1: from_key : SQL92_RESERVED_FROM ;
 */
void
PLSQLParser_PLSQLKeys::from_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2174:5: ( SQL92_RESERVED_FROM )
        // PLSQLKeys.g:2174:10: SQL92_RESERVED_FROM
        {
             this->matchToken(SQL92_RESERVED_FROM, &FOLLOW_SQL92_RESERVED_FROM_in_from_key12029);
            if  (this->hasException())
            {
                goto rulefrom_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefrom_keyEx; /* Prevent compiler warnings */
    rulefrom_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end from_key */

/**
 * $ANTLR start where_key
 * PLSQLKeys.g:2177:1: where_key : SQL92_RESERVED_WHERE ;
 */
void
PLSQLParser_PLSQLKeys::where_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2178:5: ( SQL92_RESERVED_WHERE )
        // PLSQLKeys.g:2178:10: SQL92_RESERVED_WHERE
        {
             this->matchToken(SQL92_RESERVED_WHERE, &FOLLOW_SQL92_RESERVED_WHERE_in_where_key12049);
            if  (this->hasException())
            {
                goto rulewhere_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewhere_keyEx; /* Prevent compiler warnings */
    rulewhere_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end where_key */

/**
 * $ANTLR start sequence_key
 * PLSQLKeys.g:2181:1: sequence_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::sequence_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2182:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2182:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SEQUENCE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SEQUENCE\")" );
                    ex->set_ruleName( "sequence_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_sequence_key12071);
            if  (this->hasException())
            {
                goto rulesequence_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesequence_keyEx; /* Prevent compiler warnings */
    rulesequence_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sequence_key */

/**
 * $ANTLR start noorder_key
 * PLSQLKeys.g:2185:1: noorder_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::noorder_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2186:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2186:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOORDER"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOORDER\")" );
                    ex->set_ruleName( "noorder_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_noorder_key12093);
            if  (this->hasException())
            {
                goto rulenoorder_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenoorder_keyEx; /* Prevent compiler warnings */
    rulenoorder_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end noorder_key */

/**
 * $ANTLR start cycle_key
 * PLSQLKeys.g:2189:1: cycle_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::cycle_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2190:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2190:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CYCLE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CYCLE\")" );
                    ex->set_ruleName( "cycle_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cycle_key12115);
            if  (this->hasException())
            {
                goto rulecycle_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecycle_keyEx; /* Prevent compiler warnings */
    rulecycle_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cycle_key */

/**
 * $ANTLR start cache_key
 * PLSQLKeys.g:2193:1: cache_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::cache_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2194:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2194:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "CACHE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"CACHE\")" );
                    ex->set_ruleName( "cache_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_cache_key12137);
            if  (this->hasException())
            {
                goto rulecache_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecache_keyEx; /* Prevent compiler warnings */
    rulecache_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cache_key */

/**
 * $ANTLR start nocache_key
 * PLSQLKeys.g:2197:1: nocache_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nocache_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2198:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2198:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOCACHE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOCACHE\")" );
                    ex->set_ruleName( "nocache_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nocache_key12159);
            if  (this->hasException())
            {
                goto rulenocache_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenocache_keyEx; /* Prevent compiler warnings */
    rulenocache_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nocache_key */

/**
 * $ANTLR start nomaxvalue_key
 * PLSQLKeys.g:2201:1: nomaxvalue_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nomaxvalue_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2202:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2202:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOMAXVALUE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOMAXVALUE\")" );
                    ex->set_ruleName( "nomaxvalue_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nomaxvalue_key12181);
            if  (this->hasException())
            {
                goto rulenomaxvalue_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenomaxvalue_keyEx; /* Prevent compiler warnings */
    rulenomaxvalue_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nomaxvalue_key */

/**
 * $ANTLR start nominvalue_key
 * PLSQLKeys.g:2205:1: nominvalue_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::nominvalue_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2206:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2206:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "NOMINVALUE"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"NOMINVALUE\")" );
                    ex->set_ruleName( "nominvalue_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_nominvalue_key12203);
            if  (this->hasException())
            {
                goto rulenominvalue_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulenominvalue_keyEx; /* Prevent compiler warnings */
    rulenominvalue_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end nominvalue_key */

/**
 * $ANTLR start search_key
 * PLSQLKeys.g:2209:1: search_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::search_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2210:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2210:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "SEARCH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"SEARCH\")" );
                    ex->set_ruleName( "search_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_search_key12225);
            if  (this->hasException())
            {
                goto rulesearch_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesearch_keyEx; /* Prevent compiler warnings */
    rulesearch_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end search_key */

/**
 * $ANTLR start depth_key
 * PLSQLKeys.g:2213:1: depth_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::depth_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2214:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2214:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "DEPTH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"DEPTH\")" );
                    ex->set_ruleName( "depth_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_depth_key12247);
            if  (this->hasException())
            {
                goto ruledepth_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruledepth_keyEx; /* Prevent compiler warnings */
    ruledepth_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end depth_key */

/**
 * $ANTLR start breadth_key
 * PLSQLKeys.g:2217:1: breadth_key :{...}? REGULAR_ID ;
 */
void
PLSQLParser_PLSQLKeys::breadth_key()
{
        PLSQLParser_PLSQLKeysImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQLKeys.g:2218:5: ({...}? REGULAR_ID )
        // PLSQLKeys.g:2218:10: {...}? REGULAR_ID
        {
            if ( !((equalsIgnoreCase(LT(1)->getText(), "BREADTH"))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQLKeysImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(1)->getText(), \"BREADTH\")" );
                    ex->set_ruleName( "breadth_key" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_breadth_key12269);
            if  (this->hasException())
            {
                goto rulebreadth_keyEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebreadth_keyEx; /* Prevent compiler warnings */
    rulebreadth_keyEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end breadth_key */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

}

/* End of code
 * =============================================================================
 */
