/** \file
 *  This C++ source file was generated by $ANTLR version 3.5.2-SNAPSHOT
 *
 *     -  From the grammar source file : PLSQL_DMLParser.g
 *     -                            On : 2013-10-27 10:36:00
 *     -                for the parser : PLSQLParser_PLSQL_DMLParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "PLSQLParser_PLSQL_DMLParser.hpp"
// Include delegator definition header files
//
#include "PLSQLParser.hpp" 

/* ----------------------------------------- */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

namespace  Antlr3BackendImpl  {
using namespace antlr3;

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "PLSQL_DMLParser.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* PLSQLParser_PLSQL_DMLParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new PLSQLParser_PLSQL_DMLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PLSQLParser_PLSQL_DMLParser::PLSQLParser_PLSQL_DMLParser( StreamType* instream, PLSQLParser* gPLSQLParser)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream, gPLSQLParser);
}

/** \brief Create a new PLSQLParser_PLSQL_DMLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PLSQLParser_PLSQL_DMLParser::PLSQLParser_PLSQL_DMLParser( StreamType* instream, RecognizerSharedStateType* state, PLSQLParser* gPLSQLParser)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream , gPLSQLParser);
}

void PLSQLParser_PLSQL_DMLParser::init(StreamType* instream, PLSQLParser* gPLSQLParser)
{
     	// Install the pointers back to lexers that will delegate us to perform certain functions
     	// for them.
     	//
     		m_gPLSQLParser = gPLSQLParser;
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( PLSQLParserTokenNames );


}

void
PLSQLParser_PLSQL_DMLParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
PLSQLParser_PLSQL_DMLParser::~PLSQLParser_PLSQL_DMLParser()
 {
}

/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return PLSQLParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_explain_key_in_explain_statement186_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_explain_key_in_explain_statement186( FOLLOW_explain_key_in_explain_statement186_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_plan_key_in_explain_statement188_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080400000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_plan_key_in_explain_statement188( FOLLOW_plan_key_in_explain_statement188_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_set_key_in_explain_statement200_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_set_key_in_explain_statement200( FOLLOW_set_key_in_explain_statement200_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_statement_id_key_in_explain_statement202_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_statement_id_key_in_explain_statement202( FOLLOW_statement_id_key_in_explain_statement202_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_explain_statement204_bits[]	= { ANTLR_UINT64_LIT(0x0000000400003000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_explain_statement204( FOLLOW_EQUALS_OP_in_explain_statement204_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_explain_statement206_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080400000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_quoted_string_in_explain_statement206( FOLLOW_quoted_string_in_explain_statement206_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_into_key_in_explain_statement220_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_into_key_in_explain_statement220( FOLLOW_into_key_in_explain_statement220_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_explain_statement222_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_explain_statement222( FOLLOW_tableview_name_in_explain_statement222_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_key_in_explain_statement235_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0020001000000400), ANTLR_UINT64_LIT(0x0000000000108040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_key_in_explain_statement235( FOLLOW_for_key_in_explain_statement235_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_explain_statement248_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_statement_in_explain_statement248( FOLLOW_select_statement_in_explain_statement248_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_update_statement_in_explain_statement261_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_update_statement_in_explain_statement261( FOLLOW_update_statement_in_explain_statement261_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_delete_statement_in_explain_statement274_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_delete_statement_in_explain_statement274( FOLLOW_delete_statement_in_explain_statement274_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_insert_statement_in_explain_statement287_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_insert_statement_in_explain_statement287( FOLLOW_insert_statement_in_explain_statement287_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_merge_statement_in_explain_statement300_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_merge_statement_in_explain_statement300( FOLLOW_merge_statement_in_explain_statement300_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_factoring_clause_in_select_statement331_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_factoring_clause_in_select_statement331( FOLLOW_subquery_factoring_clause_in_select_statement331_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_select_statement342_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000400000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_select_statement342( FOLLOW_subquery_in_select_statement342_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_update_clause_in_select_statement353_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000400000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_update_clause_in_select_statement353( FOLLOW_for_update_clause_in_select_statement353_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_select_statement365_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000400000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_by_clause_in_select_statement365( FOLLOW_order_by_clause_in_select_statement365_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_subquery_factoring_clause388_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_subquery_factoring_clause388( FOLLOW_with_key_in_subquery_factoring_clause388_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_factoring_element_in_subquery_factoring_clause390_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_factoring_element_in_subquery_factoring_clause390( FOLLOW_factoring_element_in_subquery_factoring_clause390_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_subquery_factoring_clause393_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_subquery_factoring_clause393( FOLLOW_COMMA_in_subquery_factoring_clause393_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_factoring_element_in_subquery_factoring_clause395_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_factoring_element_in_subquery_factoring_clause395( FOLLOW_factoring_element_in_subquery_factoring_clause395_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_query_name_in_factoring_element417_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000400000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_query_name_in_factoring_element417( FOLLOW_query_name_in_factoring_element417_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_factoring_element420_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_factoring_element420( FOLLOW_LEFT_PAREN_in_factoring_element420_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_factoring_element422_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_factoring_element422( FOLLOW_column_name_in_factoring_element422_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_factoring_element425_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_factoring_element425( FOLLOW_COMMA_in_factoring_element425_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_factoring_element427_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_factoring_element427( FOLLOW_column_name_in_factoring_element427_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_factoring_element431_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000400000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_factoring_element431( FOLLOW_RIGHT_PAREN_in_factoring_element431_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_factoring_element435_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_as_key_in_factoring_element435( FOLLOW_as_key_in_factoring_element435_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_factoring_element437_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_factoring_element437( FOLLOW_LEFT_PAREN_in_factoring_element437_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_factoring_element439_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_factoring_element439( FOLLOW_subquery_in_factoring_element439_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_factoring_element441_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_by_clause_in_factoring_element441( FOLLOW_order_by_clause_in_factoring_element441_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_factoring_element444_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_factoring_element444( FOLLOW_RIGHT_PAREN_in_factoring_element444_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_search_clause_in_factoring_element455_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_search_clause_in_factoring_element455( FOLLOW_search_clause_in_factoring_element455_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cycle_clause_in_factoring_element467_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cycle_clause_in_factoring_element467( FOLLOW_cycle_clause_in_factoring_element467_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_search_key_in_search_clause488_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_search_key_in_search_clause488( FOLLOW_search_key_in_search_clause488_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_depth_key_in_search_clause492_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_depth_key_in_search_clause492( FOLLOW_depth_key_in_search_clause492_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_breadth_key_in_search_clause496_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_breadth_key_in_search_clause496( FOLLOW_breadth_key_in_search_clause496_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_first_key_in_search_clause500_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_first_key_in_search_clause500( FOLLOW_first_key_in_search_clause500_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_search_clause502_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_search_clause502( FOLLOW_by_key_in_search_clause502_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_search_clause517_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000002000800400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_search_clause517( FOLLOW_column_name_in_search_clause517_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_asc_key_in_search_clause519_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000002000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_asc_key_in_search_clause519( FOLLOW_asc_key_in_search_clause519_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_desc_key_in_search_clause523_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_desc_key_in_search_clause523( FOLLOW_desc_key_in_search_clause523_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_search_clause528_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nulls_key_in_search_clause528( FOLLOW_nulls_key_in_search_clause528_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_first_key_in_search_clause530_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_first_key_in_search_clause530( FOLLOW_first_key_in_search_clause530_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_search_clause535_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nulls_key_in_search_clause535( FOLLOW_nulls_key_in_search_clause535_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_last_key_in_search_clause537_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_last_key_in_search_clause537( FOLLOW_last_key_in_search_clause537_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_search_clause555_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_search_clause555( FOLLOW_COMMA_in_search_clause555_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_search_clause557_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000002000800400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_search_clause557( FOLLOW_column_name_in_search_clause557_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_asc_key_in_search_clause559_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000002000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_asc_key_in_search_clause559( FOLLOW_asc_key_in_search_clause559_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_desc_key_in_search_clause563_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_desc_key_in_search_clause563( FOLLOW_desc_key_in_search_clause563_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_search_clause568_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nulls_key_in_search_clause568( FOLLOW_nulls_key_in_search_clause568_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_first_key_in_search_clause570_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_first_key_in_search_clause570( FOLLOW_first_key_in_search_clause570_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_search_clause575_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nulls_key_in_search_clause575( FOLLOW_nulls_key_in_search_clause575_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_last_key_in_search_clause577_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_last_key_in_search_clause577( FOLLOW_last_key_in_search_clause577_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_set_key_in_search_clause597_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_set_key_in_search_clause597( FOLLOW_set_key_in_search_clause597_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_search_clause599_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_search_clause599( FOLLOW_column_name_in_search_clause599_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cycle_key_in_cycle_clause619_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cycle_key_in_cycle_clause619( FOLLOW_cycle_key_in_cycle_clause619_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_cycle_clause621_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_cycle_clause621( FOLLOW_column_name_in_cycle_clause621_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_cycle_clause625_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_cycle_clause625( FOLLOW_COMMA_in_cycle_clause625_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_cycle_clause627_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_cycle_clause627( FOLLOW_column_name_in_cycle_clause627_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_set_key_in_cycle_clause631_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_set_key_in_cycle_clause631( FOLLOW_set_key_in_cycle_clause631_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_cycle_clause633_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_cycle_clause633( FOLLOW_column_name_in_cycle_clause633_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_to_key_in_cycle_clause635_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_to_key_in_cycle_clause635( FOLLOW_to_key_in_cycle_clause635_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_cycle_clause637_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000800000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_cycle_clause637( FOLLOW_expression_in_cycle_clause637_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_default_key_in_cycle_clause639_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_default_key_in_cycle_clause639( FOLLOW_default_key_in_cycle_clause639_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_cycle_clause641_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_cycle_clause641( FOLLOW_expression_in_cycle_clause641_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_basic_elements_in_subquery661_bits[]	= { ANTLR_UINT64_LIT(0x0080000000000002), ANTLR_UINT64_LIT(0x0040000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_basic_elements_in_subquery661( FOLLOW_subquery_basic_elements_in_subquery661_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_operation_part_in_subquery663_bits[]	= { ANTLR_UINT64_LIT(0x0080000000000002), ANTLR_UINT64_LIT(0x0040000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_operation_part_in_subquery663( FOLLOW_subquery_operation_part_in_subquery663_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_union_key_in_subquery_operation_part685_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_union_key_in_subquery_operation_part685( FOLLOW_union_key_in_subquery_operation_part685_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_subquery_operation_part687_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_subquery_operation_part687( FOLLOW_all_key_in_subquery_operation_part687_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_intersect_key_in_subquery_operation_part690_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_intersect_key_in_subquery_operation_part690( FOLLOW_intersect_key_in_subquery_operation_part690_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_minus_key_in_subquery_operation_part692_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_minus_key_in_subquery_operation_part692( FOLLOW_minus_key_in_subquery_operation_part692_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_basic_elements_in_subquery_operation_part695_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_basic_elements_in_subquery_operation_part695( FOLLOW_subquery_basic_elements_in_subquery_operation_part695_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_query_block_in_subquery_basic_elements715_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_query_block_in_subquery_basic_elements715( FOLLOW_query_block_in_subquery_basic_elements715_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_subquery_basic_elements726_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_subquery_basic_elements726( FOLLOW_LEFT_PAREN_in_subquery_basic_elements726_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_subquery_basic_elements728_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_subquery_basic_elements728( FOLLOW_subquery_in_subquery_basic_elements728_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_subquery_basic_elements730_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_subquery_basic_elements730( FOLLOW_RIGHT_PAREN_in_subquery_basic_elements730_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_query_block750_bits[]	= { ANTLR_UINT64_LIT(0x00000086504472A0), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000805004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_query_block750( FOLLOW_select_key_in_query_block750_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_distinct_key_in_query_block771_bits[]	= { ANTLR_UINT64_LIT(0x00000086504472A0), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_distinct_key_in_query_block771( FOLLOW_distinct_key_in_query_block771_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unique_key_in_query_block773_bits[]	= { ANTLR_UINT64_LIT(0x00000086504472A0), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unique_key_in_query_block773( FOLLOW_unique_key_in_query_block773_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_query_block775_bits[]	= { ANTLR_UINT64_LIT(0x00000086504472A0), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_query_block775( FOLLOW_all_key_in_query_block775_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_query_block789_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080800000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_ASTERISK_in_query_block789( FOLLOW_ASTERISK_in_query_block789_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_selected_element_in_query_block793_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0080800000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_selected_element_in_query_block793( FOLLOW_selected_element_in_query_block793_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_query_block796_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_query_block796( FOLLOW_COMMA_in_query_block796_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_selected_element_in_query_block798_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0080800000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_selected_element_in_query_block798( FOLLOW_selected_element_in_query_block798_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_into_clause_in_query_block811_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_into_clause_in_query_block811( FOLLOW_into_clause_in_query_block811_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_from_clause_in_query_block822_bits[]	= { ANTLR_UINT64_LIT(0x2000020000000002), ANTLR_UINT64_LIT(0x000C000020000000), ANTLR_UINT64_LIT(0x0000000000080000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_from_clause_in_query_block822( FOLLOW_from_clause_in_query_block822_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_where_clause_in_query_block833_bits[]	= { ANTLR_UINT64_LIT(0x2000020000000002), ANTLR_UINT64_LIT(0x000C000020000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_where_clause_in_query_block833( FOLLOW_where_clause_in_query_block833_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_hierarchical_query_clause_in_query_block845_bits[]	= { ANTLR_UINT64_LIT(0x0000020000000002), ANTLR_UINT64_LIT(0x000C000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_hierarchical_query_clause_in_query_block845( FOLLOW_hierarchical_query_clause_in_query_block845_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_by_clause_in_query_block857_bits[]	= { ANTLR_UINT64_LIT(0x0000020000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_by_clause_in_query_block857( FOLLOW_group_by_clause_in_query_block857_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_clause_in_query_block868_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_clause_in_query_block868( FOLLOW_model_clause_in_query_block868_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_list_elements_in_selected_element889_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_list_elements_in_selected_element889( FOLLOW_select_list_elements_in_selected_element889_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_selected_element891_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_alias_in_selected_element891( FOLLOW_column_alias_in_selected_element891_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_from_key_in_from_clause912_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_from_key_in_from_clause912( FOLLOW_from_key_in_from_clause912_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_ref_list_in_from_clause914_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_ref_list_in_from_clause914( FOLLOW_table_ref_list_in_from_clause914_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_select_list_elements943_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_select_list_elements943( FOLLOW_tableview_name_in_select_list_elements943_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_select_list_elements945_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_select_list_elements945( FOLLOW_PERIOD_in_select_list_elements945_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_select_list_elements947_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_ASTERISK_in_select_list_elements947( FOLLOW_ASTERISK_in_select_list_elements947_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_select_list_elements958_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_select_list_elements958( FOLLOW_expression_in_select_list_elements958_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_ref_in_table_ref_list978_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_ref_in_table_ref_list978( FOLLOW_table_ref_in_table_ref_list978_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_table_ref_list981_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_table_ref_list981( FOLLOW_COMMA_in_table_ref_list981_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_ref_in_table_ref_list983_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_ref_in_table_ref_list983( FOLLOW_table_ref_in_table_ref_list983_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_ref_aux_in_table_ref1009_bits[]	= { ANTLR_UINT64_LIT(0x00000C0000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_ref_aux_in_table_ref1009( FOLLOW_table_ref_aux_in_table_ref1009_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_join_clause_in_table_ref1011_bits[]	= { ANTLR_UINT64_LIT(0x00000C0000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_join_clause_in_table_ref1011( FOLLOW_join_clause_in_table_ref1011_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_clause_in_table_ref1015_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_clause_in_table_ref1015( FOLLOW_pivot_clause_in_table_ref1015_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unpivot_clause_in_table_ref1017_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unpivot_clause_in_table_ref1017( FOLLOW_unpivot_clause_in_table_ref1017_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_dml_table_expression_clause_in_table_ref_aux1057_bits[]	= { ANTLR_UINT64_LIT(0x00000C0410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_dml_table_expression_clause_in_table_ref_aux1057( FOLLOW_dml_table_expression_clause_in_table_ref_aux1057_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_clause_in_table_ref_aux1060_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_clause_in_table_ref_aux1060( FOLLOW_pivot_clause_in_table_ref_aux1060_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unpivot_clause_in_table_ref_aux1062_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unpivot_clause_in_table_ref_aux1062( FOLLOW_unpivot_clause_in_table_ref_aux1062_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_table_ref_aux1081_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_table_ref_aux1081( FOLLOW_LEFT_PAREN_in_table_ref_aux1081_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_ref_in_table_ref_aux1083_bits[]	= { ANTLR_UINT64_LIT(0x0080000000000000), ANTLR_UINT64_LIT(0x0040000000001000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_ref_in_table_ref_aux1083( FOLLOW_table_ref_in_table_ref_aux1083_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_operation_part_in_table_ref_aux1085_bits[]	= { ANTLR_UINT64_LIT(0x0080000000000000), ANTLR_UINT64_LIT(0x0040000000001000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_operation_part_in_table_ref_aux1085( FOLLOW_subquery_operation_part_in_table_ref_aux1085_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_table_ref_aux1088_bits[]	= { ANTLR_UINT64_LIT(0x00000C0410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_table_ref_aux1088( FOLLOW_RIGHT_PAREN_in_table_ref_aux1088_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_clause_in_table_ref_aux1091_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_clause_in_table_ref_aux1091( FOLLOW_pivot_clause_in_table_ref_aux1091_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unpivot_clause_in_table_ref_aux1093_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unpivot_clause_in_table_ref_aux1093( FOLLOW_unpivot_clause_in_table_ref_aux1093_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_only_key_in_table_ref_aux1114_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_only_key_in_table_ref_aux1114( FOLLOW_only_key_in_table_ref_aux1114_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_table_ref_aux1116_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_table_ref_aux1116( FOLLOW_LEFT_PAREN_in_table_ref_aux1116_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_dml_table_expression_clause_in_table_ref_aux1118_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_dml_table_expression_clause_in_table_ref_aux1118( FOLLOW_dml_table_expression_clause_in_table_ref_aux1118_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_table_ref_aux1120_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_table_ref_aux1120( FOLLOW_RIGHT_PAREN_in_table_ref_aux1120_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_dml_table_expression_clause_in_table_ref_aux1131_bits[]	= { ANTLR_UINT64_LIT(0x00000C0410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_dml_table_expression_clause_in_table_ref_aux1131( FOLLOW_dml_table_expression_clause_in_table_ref_aux1131_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_clause_in_table_ref_aux1134_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_clause_in_table_ref_aux1134( FOLLOW_pivot_clause_in_table_ref_aux1134_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unpivot_clause_in_table_ref_aux1136_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unpivot_clause_in_table_ref_aux1136( FOLLOW_unpivot_clause_in_table_ref_aux1136_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_flashback_query_clause_in_table_ref_aux1154_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_flashback_query_clause_in_table_ref_aux1154( FOLLOW_flashback_query_clause_in_table_ref_aux1154_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_alias_in_table_ref_aux1168_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_alias_in_table_ref_aux1168( FOLLOW_table_alias_in_table_ref_aux1168_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_query_partition_clause_in_join_clause1190_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_query_partition_clause_in_join_clause1190( FOLLOW_query_partition_clause_in_join_clause1190_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cross_key_in_join_clause1202_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cross_key_in_join_clause1202( FOLLOW_cross_key_in_join_clause1202_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_natural_key_in_join_clause1204_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_natural_key_in_join_clause1204( FOLLOW_natural_key_in_join_clause1204_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_inner_key_in_join_clause1209_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_inner_key_in_join_clause1209( FOLLOW_inner_key_in_join_clause1209_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_outer_join_type_in_join_clause1211_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_outer_join_type_in_join_clause1211( FOLLOW_outer_join_type_in_join_clause1211_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_join_key_in_join_clause1215_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_join_key_in_join_clause1215( FOLLOW_join_key_in_join_clause1215_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_ref_aux_in_join_clause1225_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000002), ANTLR_UINT64_LIT(0x2000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_ref_aux_in_join_clause1225( FOLLOW_table_ref_aux_in_join_clause1225_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_query_partition_clause_in_join_clause1235_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000002), ANTLR_UINT64_LIT(0x2000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_query_partition_clause_in_join_clause1235( FOLLOW_query_partition_clause_in_join_clause1235_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_join_on_part_in_join_clause1247_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000002), ANTLR_UINT64_LIT(0x2000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_join_on_part_in_join_clause1247( FOLLOW_join_on_part_in_join_clause1247_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_join_using_part_in_join_clause1258_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000002), ANTLR_UINT64_LIT(0x2000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_join_using_part_in_join_clause1258( FOLLOW_join_using_part_in_join_clause1258_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_on_key_in_join_on_part1285_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_on_key_in_join_on_part1285( FOLLOW_on_key_in_join_on_part1285_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_join_on_part1287_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_in_join_on_part1287( FOLLOW_condition_in_join_on_part1287_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_using_key_in_join_using_part1307_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_using_key_in_join_using_part1307( FOLLOW_using_key_in_join_using_part1307_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_join_using_part1309_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_join_using_part1309( FOLLOW_LEFT_PAREN_in_join_using_part1309_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_join_using_part1311_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_join_using_part1311( FOLLOW_column_name_in_join_using_part1311_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_join_using_part1314_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_join_using_part1314( FOLLOW_COMMA_in_join_using_part1314_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_join_using_part1316_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_join_using_part1316( FOLLOW_column_name_in_join_using_part1316_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_join_using_part1320_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_join_using_part1320( FOLLOW_RIGHT_PAREN_in_join_using_part1320_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_full_key_in_outer_join_type1350_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_full_key_in_outer_join_type1350( FOLLOW_full_key_in_outer_join_type1350_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_left_key_in_outer_join_type1361_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_left_key_in_outer_join_type1361( FOLLOW_left_key_in_outer_join_type1361_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_right_key_in_outer_join_type1372_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_right_key_in_outer_join_type1372( FOLLOW_right_key_in_outer_join_type1372_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_outer_key_in_outer_join_type1388_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_outer_key_in_outer_join_type1388( FOLLOW_outer_key_in_outer_join_type1388_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_partition_key_in_query_partition_clause1409_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_partition_key_in_query_partition_clause1409( FOLLOW_partition_key_in_query_partition_clause1409_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_query_partition_clause1411_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_query_partition_clause1411( FOLLOW_by_key_in_query_partition_clause1411_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_query_partition_clause1434_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_query_partition_clause1434( FOLLOW_LEFT_PAREN_in_query_partition_clause1434_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_query_partition_clause1436_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_query_partition_clause1436( FOLLOW_subquery_in_query_partition_clause1436_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_query_partition_clause1438_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_query_partition_clause1438( FOLLOW_RIGHT_PAREN_in_query_partition_clause1438_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_query_partition_clause1454_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_list_in_query_partition_clause1454( FOLLOW_expression_list_in_query_partition_clause1454_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_query_partition_clause1465_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_query_partition_clause1465( FOLLOW_expression_in_query_partition_clause1465_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_query_partition_clause1468_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_query_partition_clause1468( FOLLOW_COMMA_in_query_partition_clause1468_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_query_partition_clause1470_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_query_partition_clause1470( FOLLOW_expression_in_query_partition_clause1470_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_versions_key_in_flashback_query_clause1498_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000002000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_versions_key_in_flashback_query_clause1498( FOLLOW_versions_key_in_flashback_query_clause1498_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_between_key_in_flashback_query_clause1500_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_between_key_in_flashback_query_clause1500( FOLLOW_between_key_in_flashback_query_clause1500_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_scn_key_in_flashback_query_clause1503_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_scn_key_in_flashback_query_clause1503( FOLLOW_scn_key_in_flashback_query_clause1503_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_timestamp_key_in_flashback_query_clause1505_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_timestamp_key_in_flashback_query_clause1505( FOLLOW_timestamp_key_in_flashback_query_clause1505_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_flashback_query_clause1508_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_flashback_query_clause1508( FOLLOW_expression_in_flashback_query_clause1508_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_flashback_query_clause1519_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_as_key_in_flashback_query_clause1519( FOLLOW_as_key_in_flashback_query_clause1519_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_of_key_in_flashback_query_clause1521_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_of_key_in_flashback_query_clause1521( FOLLOW_of_key_in_flashback_query_clause1521_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_scn_key_in_flashback_query_clause1524_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_scn_key_in_flashback_query_clause1524( FOLLOW_scn_key_in_flashback_query_clause1524_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_timestamp_key_in_flashback_query_clause1526_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_timestamp_key_in_flashback_query_clause1526( FOLLOW_timestamp_key_in_flashback_query_clause1526_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_snapshot_key_in_flashback_query_clause1528_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_snapshot_key_in_flashback_query_clause1528( FOLLOW_snapshot_key_in_flashback_query_clause1528_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_flashback_query_clause1531_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_flashback_query_clause1531( FOLLOW_expression_in_flashback_query_clause1531_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_key_in_pivot_clause1551_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_key_in_pivot_clause1551( FOLLOW_pivot_key_in_pivot_clause1551_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_key_in_pivot_clause1553_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_key_in_pivot_clause1553( FOLLOW_xml_key_in_pivot_clause1553_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_pivot_clause1564_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_pivot_clause1564( FOLLOW_LEFT_PAREN_in_pivot_clause1564_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_element_in_pivot_clause1578_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_element_in_pivot_clause1578( FOLLOW_pivot_element_in_pivot_clause1578_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_pivot_clause1581_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_pivot_clause1581( FOLLOW_COMMA_in_pivot_clause1581_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_element_in_pivot_clause1583_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_element_in_pivot_clause1583( FOLLOW_pivot_element_in_pivot_clause1583_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_for_clause_in_pivot_clause1599_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0010000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_for_clause_in_pivot_clause1599( FOLLOW_pivot_for_clause_in_pivot_clause1599_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_in_clause_in_pivot_clause1613_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_in_clause_in_pivot_clause1613( FOLLOW_pivot_in_clause_in_pivot_clause1613_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_pivot_clause1625_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_pivot_clause1625( FOLLOW_RIGHT_PAREN_in_pivot_clause1625_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_aggregate_function_name_in_pivot_element1645_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_aggregate_function_name_in_pivot_element1645( FOLLOW_aggregate_function_name_in_pivot_element1645_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_pivot_element1647_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_pivot_element1647( FOLLOW_LEFT_PAREN_in_pivot_element1647_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_pivot_element1649_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_pivot_element1649( FOLLOW_expression_in_pivot_element1649_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_pivot_element1651_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_pivot_element1651( FOLLOW_RIGHT_PAREN_in_pivot_element1651_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_pivot_element1653_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_alias_in_pivot_element1653( FOLLOW_column_alias_in_pivot_element1653_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_key_in_pivot_for_clause1674_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_key_in_pivot_for_clause1674( FOLLOW_for_key_in_pivot_for_clause1674_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_pivot_for_clause1686_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_pivot_for_clause1686( FOLLOW_column_name_in_pivot_for_clause1686_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_pivot_for_clause1697_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_pivot_for_clause1697( FOLLOW_LEFT_PAREN_in_pivot_for_clause1697_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_pivot_for_clause1699_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_pivot_for_clause1699( FOLLOW_column_name_in_pivot_for_clause1699_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_pivot_for_clause1702_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_pivot_for_clause1702( FOLLOW_COMMA_in_pivot_for_clause1702_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_pivot_for_clause1704_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_pivot_for_clause1704( FOLLOW_column_name_in_pivot_for_clause1704_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_pivot_for_clause1708_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_pivot_for_clause1708( FOLLOW_RIGHT_PAREN_in_pivot_for_clause1708_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_pivot_in_clause1734_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_in_key_in_pivot_in_clause1734( FOLLOW_in_key_in_pivot_in_clause1734_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_pivot_in_clause1744_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801044) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_pivot_in_clause1744( FOLLOW_LEFT_PAREN_in_pivot_in_clause1744_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_pivot_in_clause1768_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_pivot_in_clause1768( FOLLOW_subquery_in_pivot_in_clause1768_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_any_key_in_pivot_in_clause1793_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_any_key_in_pivot_in_clause1793( FOLLOW_any_key_in_pivot_in_clause1793_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_pivot_in_clause1796_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_pivot_in_clause1796( FOLLOW_COMMA_in_pivot_in_clause1796_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_any_key_in_pivot_in_clause1798_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_any_key_in_pivot_in_clause1798( FOLLOW_any_key_in_pivot_in_clause1798_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_in_clause_element_in_pivot_in_clause1819_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_in_clause_element_in_pivot_in_clause1819( FOLLOW_pivot_in_clause_element_in_pivot_in_clause1819_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_pivot_in_clause1822_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_pivot_in_clause1822( FOLLOW_COMMA_in_pivot_in_clause1822_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_in_clause_element_in_pivot_in_clause1824_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_in_clause_element_in_pivot_in_clause1824( FOLLOW_pivot_in_clause_element_in_pivot_in_clause1824_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_pivot_in_clause1850_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_pivot_in_clause1850( FOLLOW_RIGHT_PAREN_in_pivot_in_clause1850_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_in_clause_elements_in_pivot_in_clause_element1870_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_in_clause_elements_in_pivot_in_clause_element1870( FOLLOW_pivot_in_clause_elements_in_pivot_in_clause_element1870_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_pivot_in_clause_element1872_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_alias_in_pivot_in_clause_element1872( FOLLOW_column_alias_in_pivot_in_clause_element1872_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_pivot_in_clause_elements1893_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_pivot_in_clause_elements1893( FOLLOW_expression_in_pivot_in_clause_elements1893_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_pivot_in_clause_elements1909_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_list_in_pivot_in_clause_elements1909( FOLLOW_expression_list_in_pivot_in_clause_elements1909_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unpivot_key_in_unpivot_clause1929_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unpivot_key_in_unpivot_clause1929( FOLLOW_unpivot_key_in_unpivot_clause1929_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_include_key_in_unpivot_clause1942_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_include_key_in_unpivot_clause1942( FOLLOW_include_key_in_unpivot_clause1942_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_exclude_key_in_unpivot_clause1944_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_exclude_key_in_unpivot_clause1944( FOLLOW_exclude_key_in_unpivot_clause1944_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_unpivot_clause1947_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nulls_key_in_unpivot_clause1947( FOLLOW_nulls_key_in_unpivot_clause1947_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_unpivot_clause1959_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_unpivot_clause1959( FOLLOW_LEFT_PAREN_in_unpivot_clause1959_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_unpivot_clause1978_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_unpivot_clause1978( FOLLOW_column_name_in_unpivot_clause1978_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_unpivot_clause1997_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_unpivot_clause1997( FOLLOW_LEFT_PAREN_in_unpivot_clause1997_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_unpivot_clause1999_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_unpivot_clause1999( FOLLOW_column_name_in_unpivot_clause1999_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_unpivot_clause2002_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_unpivot_clause2002( FOLLOW_COMMA_in_unpivot_clause2002_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_unpivot_clause2004_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_unpivot_clause2004( FOLLOW_column_name_in_unpivot_clause2004_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_unpivot_clause2008_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_unpivot_clause2008( FOLLOW_RIGHT_PAREN_in_unpivot_clause2008_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_for_clause_in_unpivot_clause2036_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0010000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_for_clause_in_unpivot_clause2036( FOLLOW_pivot_for_clause_in_unpivot_clause2036_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unpivot_in_clause_in_unpivot_clause2050_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unpivot_in_clause_in_unpivot_clause2050( FOLLOW_unpivot_in_clause_in_unpivot_clause2050_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_unpivot_clause2060_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_unpivot_clause2060( FOLLOW_RIGHT_PAREN_in_unpivot_clause2060_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_unpivot_in_clause2080_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_in_key_in_unpivot_in_clause2080( FOLLOW_in_key_in_unpivot_in_clause2080_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_unpivot_in_clause2090_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_unpivot_in_clause2090( FOLLOW_LEFT_PAREN_in_unpivot_in_clause2090_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unpivot_in_elements_in_unpivot_in_clause2104_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unpivot_in_elements_in_unpivot_in_clause2104( FOLLOW_unpivot_in_elements_in_unpivot_in_clause2104_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_unpivot_in_clause2107_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_unpivot_in_clause2107( FOLLOW_COMMA_in_unpivot_in_clause2107_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unpivot_in_elements_in_unpivot_in_clause2109_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unpivot_in_elements_in_unpivot_in_clause2109( FOLLOW_unpivot_in_elements_in_unpivot_in_clause2109_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_unpivot_in_clause2121_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_unpivot_in_clause2121( FOLLOW_RIGHT_PAREN_in_unpivot_in_clause2121_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_unpivot_in_elements2145_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000400000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_unpivot_in_elements2145( FOLLOW_column_name_in_unpivot_in_elements2145_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_unpivot_in_elements2160_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_unpivot_in_elements2160( FOLLOW_LEFT_PAREN_in_unpivot_in_elements2160_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_unpivot_in_elements2162_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_unpivot_in_elements2162( FOLLOW_column_name_in_unpivot_in_elements2162_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_unpivot_in_elements2165_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_unpivot_in_elements2165( FOLLOW_COMMA_in_unpivot_in_elements2165_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_unpivot_in_elements2167_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_unpivot_in_elements2167( FOLLOW_column_name_in_unpivot_in_elements2167_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_unpivot_in_elements2171_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000400000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_unpivot_in_elements2171( FOLLOW_RIGHT_PAREN_in_unpivot_in_elements2171_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_unpivot_in_elements2197_bits[]	= { ANTLR_UINT64_LIT(0x0000000440403020), ANTLR_UINT64_LIT(0x0800100A00000400), ANTLR_UINT64_LIT(0x0000000000801000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_as_key_in_unpivot_in_elements2197( FOLLOW_as_key_in_unpivot_in_elements2197_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_constant_in_unpivot_in_elements2213_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_constant_in_unpivot_in_elements2213( FOLLOW_constant_in_unpivot_in_elements2213_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_unpivot_in_elements2234_bits[]	= { ANTLR_UINT64_LIT(0x0000000400403020), ANTLR_UINT64_LIT(0x0800100A00000400), ANTLR_UINT64_LIT(0x0000000000801000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_unpivot_in_elements2234( FOLLOW_LEFT_PAREN_in_unpivot_in_elements2234_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_constant_in_unpivot_in_elements2236_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_constant_in_unpivot_in_elements2236( FOLLOW_constant_in_unpivot_in_elements2236_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_unpivot_in_elements2239_bits[]	= { ANTLR_UINT64_LIT(0x0000000400403020), ANTLR_UINT64_LIT(0x0800100A00000400), ANTLR_UINT64_LIT(0x0000000000801000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_unpivot_in_elements2239( FOLLOW_COMMA_in_unpivot_in_elements2239_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_constant_in_unpivot_in_elements2241_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_constant_in_unpivot_in_elements2241( FOLLOW_constant_in_unpivot_in_elements2241_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_unpivot_in_elements2245_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_unpivot_in_elements2245( FOLLOW_RIGHT_PAREN_in_unpivot_in_elements2245_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_connect_key_in_hierarchical_query_clause2287_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_connect_key_in_hierarchical_query_clause2287( FOLLOW_connect_key_in_hierarchical_query_clause2287_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_hierarchical_query_clause2289_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_hierarchical_query_clause2289( FOLLOW_by_key_in_hierarchical_query_clause2289_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nocycle_key_in_hierarchical_query_clause2291_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nocycle_key_in_hierarchical_query_clause2291( FOLLOW_nocycle_key_in_hierarchical_query_clause2291_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_hierarchical_query_clause2294_bits[]	= { ANTLR_UINT64_LIT(0x2000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_in_hierarchical_query_clause2294( FOLLOW_condition_in_hierarchical_query_clause2294_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_start_part_in_hierarchical_query_clause2296_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_start_part_in_hierarchical_query_clause2296( FOLLOW_start_part_in_hierarchical_query_clause2296_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_start_part_in_hierarchical_query_clause2308_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000020000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_start_part_in_hierarchical_query_clause2308( FOLLOW_start_part_in_hierarchical_query_clause2308_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_connect_key_in_hierarchical_query_clause2310_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_connect_key_in_hierarchical_query_clause2310( FOLLOW_connect_key_in_hierarchical_query_clause2310_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_hierarchical_query_clause2312_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_hierarchical_query_clause2312( FOLLOW_by_key_in_hierarchical_query_clause2312_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nocycle_key_in_hierarchical_query_clause2314_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nocycle_key_in_hierarchical_query_clause2314( FOLLOW_nocycle_key_in_hierarchical_query_clause2314_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_hierarchical_query_clause2317_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_in_hierarchical_query_clause2317( FOLLOW_condition_in_hierarchical_query_clause2317_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_start_key_in_start_part2337_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_start_key_in_start_part2337( FOLLOW_start_key_in_start_part2337_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_start_part2339_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_start_part2339( FOLLOW_with_key_in_start_part2339_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_start_part2341_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_in_start_part2341( FOLLOW_condition_in_start_part2341_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_key_in_group_by_clause2366_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_key_in_group_by_clause2366( FOLLOW_group_key_in_group_by_clause2366_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_group_by_clause2368_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_group_by_clause2368( FOLLOW_by_key_in_group_by_clause2368_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_by_elements_in_group_by_clause2370_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002), ANTLR_UINT64_LIT(0x0008000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_by_elements_in_group_by_clause2370( FOLLOW_group_by_elements_in_group_by_clause2370_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_group_by_clause2392_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_group_by_clause2392( FOLLOW_COMMA_in_group_by_clause2392_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_by_elements_in_group_by_clause2394_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002), ANTLR_UINT64_LIT(0x0008000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_by_elements_in_group_by_clause2394( FOLLOW_group_by_elements_in_group_by_clause2394_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_having_clause_in_group_by_clause2410_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_having_clause_in_group_by_clause2410( FOLLOW_having_clause_in_group_by_clause2410_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_having_clause_in_group_by_clause2427_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0004000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_having_clause_in_group_by_clause2427( FOLLOW_having_clause_in_group_by_clause2427_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_key_in_group_by_clause2442_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_key_in_group_by_clause2442( FOLLOW_group_key_in_group_by_clause2442_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_group_by_clause2444_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_group_by_clause2444( FOLLOW_by_key_in_group_by_clause2444_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_by_elements_in_group_by_clause2446_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_by_elements_in_group_by_clause2446( FOLLOW_group_by_elements_in_group_by_clause2446_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_group_by_clause2468_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_group_by_clause2468( FOLLOW_COMMA_in_group_by_clause2468_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_by_elements_in_group_by_clause2470_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_by_elements_in_group_by_clause2470( FOLLOW_group_by_elements_in_group_by_clause2470_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_grouping_sets_clause_in_group_by_elements2494_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_grouping_sets_clause_in_group_by_elements2494( FOLLOW_grouping_sets_clause_in_group_by_elements2494_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_rollup_cube_clause_in_group_by_elements2505_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_rollup_cube_clause_in_group_by_elements2505( FOLLOW_rollup_cube_clause_in_group_by_elements2505_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_group_by_elements2517_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_group_by_elements2517( FOLLOW_expression_in_group_by_elements2517_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_rollup_key_in_rollup_cube_clause2538_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_rollup_key_in_rollup_cube_clause2538( FOLLOW_rollup_key_in_rollup_cube_clause2538_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cube_key_in_rollup_cube_clause2540_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cube_key_in_rollup_cube_clause2540( FOLLOW_cube_key_in_rollup_cube_clause2540_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_rollup_cube_clause2543_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_rollup_cube_clause2543( FOLLOW_LEFT_PAREN_in_rollup_cube_clause2543_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_grouping_sets_elements_in_rollup_cube_clause2545_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_grouping_sets_elements_in_rollup_cube_clause2545( FOLLOW_grouping_sets_elements_in_rollup_cube_clause2545_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_rollup_cube_clause2548_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_rollup_cube_clause2548( FOLLOW_COMMA_in_rollup_cube_clause2548_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_grouping_sets_elements_in_rollup_cube_clause2550_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_grouping_sets_elements_in_rollup_cube_clause2550( FOLLOW_grouping_sets_elements_in_rollup_cube_clause2550_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_rollup_cube_clause2554_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_rollup_cube_clause2554( FOLLOW_RIGHT_PAREN_in_rollup_cube_clause2554_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_grouping_key_in_grouping_sets_clause2575_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_grouping_key_in_grouping_sets_clause2575( FOLLOW_grouping_key_in_grouping_sets_clause2575_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_sets_key_in_grouping_sets_clause2577_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_sets_key_in_grouping_sets_clause2577( FOLLOW_sets_key_in_grouping_sets_clause2577_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_grouping_sets_clause2588_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_grouping_sets_clause2588( FOLLOW_LEFT_PAREN_in_grouping_sets_clause2588_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_grouping_sets_elements_in_grouping_sets_clause2590_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_grouping_sets_elements_in_grouping_sets_clause2590( FOLLOW_grouping_sets_elements_in_grouping_sets_clause2590_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_grouping_sets_clause2593_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_grouping_sets_clause2593( FOLLOW_COMMA_in_grouping_sets_clause2593_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_grouping_sets_elements_in_grouping_sets_clause2595_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_grouping_sets_elements_in_grouping_sets_clause2595( FOLLOW_grouping_sets_elements_in_grouping_sets_clause2595_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_grouping_sets_clause2599_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_grouping_sets_clause2599( FOLLOW_RIGHT_PAREN_in_grouping_sets_clause2599_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_rollup_cube_clause_in_grouping_sets_elements2626_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_rollup_cube_clause_in_grouping_sets_elements2626( FOLLOW_rollup_cube_clause_in_grouping_sets_elements2626_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_grouping_sets_elements2642_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_list_in_grouping_sets_elements2642( FOLLOW_expression_list_in_grouping_sets_elements2642_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_grouping_sets_elements2653_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_grouping_sets_elements2653( FOLLOW_expression_in_grouping_sets_elements2653_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_having_key_in_having_clause2673_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_having_key_in_having_clause2673( FOLLOW_having_key_in_having_clause2673_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_having_clause2675_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_in_having_clause2675( FOLLOW_condition_in_having_clause2675_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_key_in_model_clause2695_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000004000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_key_in_model_clause2695( FOLLOW_model_key_in_model_clause2695_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cell_reference_options_in_model_clause2697_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000004000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cell_reference_options_in_model_clause2697( FOLLOW_cell_reference_options_in_model_clause2697_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_return_rows_clause_in_model_clause2700_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_return_rows_clause_in_model_clause2700( FOLLOW_return_rows_clause_in_model_clause2700_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_reference_model_in_model_clause2703_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_reference_model_in_model_clause2703( FOLLOW_reference_model_in_model_clause2703_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_main_model_in_model_clause2706_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_main_model_in_model_clause2706( FOLLOW_main_model_in_model_clause2706_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_ignore_key_in_cell_reference_options2727_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_ignore_key_in_cell_reference_options2727( FOLLOW_ignore_key_in_cell_reference_options2727_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_keep_key_in_cell_reference_options2729_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_keep_key_in_cell_reference_options2729( FOLLOW_keep_key_in_cell_reference_options2729_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nav_key_in_cell_reference_options2732_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nav_key_in_cell_reference_options2732( FOLLOW_nav_key_in_cell_reference_options2732_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unique_key_in_cell_reference_options2743_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unique_key_in_cell_reference_options2743( FOLLOW_unique_key_in_cell_reference_options2743_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_dimension_key_in_cell_reference_options2746_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_dimension_key_in_cell_reference_options2746( FOLLOW_dimension_key_in_cell_reference_options2746_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_single_key_in_cell_reference_options2748_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_single_key_in_cell_reference_options2748( FOLLOW_single_key_in_cell_reference_options2748_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_reference_key_in_cell_reference_options2750_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_reference_key_in_cell_reference_options2750( FOLLOW_reference_key_in_cell_reference_options2750_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_return_key_in_return_rows_clause2772_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000040400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_return_key_in_return_rows_clause2772( FOLLOW_return_key_in_return_rows_clause2772_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_updated_key_in_return_rows_clause2775_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_updated_key_in_return_rows_clause2775( FOLLOW_updated_key_in_return_rows_clause2775_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_return_rows_clause2777_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_return_rows_clause2777( FOLLOW_all_key_in_return_rows_clause2777_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_rows_key_in_return_rows_clause2780_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_rows_key_in_return_rows_clause2780( FOLLOW_rows_key_in_return_rows_clause2780_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_reference_key_in_reference_model2800_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_reference_key_in_reference_model2800( FOLLOW_reference_key_in_reference_model2800_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_reference_model_name_in_reference_model2802_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_reference_model_name_in_reference_model2802( FOLLOW_reference_model_name_in_reference_model2802_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_on_key_in_reference_model2804_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_on_key_in_reference_model2804( FOLLOW_on_key_in_reference_model2804_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_reference_model2819_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_reference_model2819( FOLLOW_LEFT_PAREN_in_reference_model2819_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_reference_model2821_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_reference_model2821( FOLLOW_subquery_in_reference_model2821_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_reference_model2823_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_reference_model2823( FOLLOW_RIGHT_PAREN_in_reference_model2823_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_column_clauses_in_reference_model2825_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000004000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_column_clauses_in_reference_model2825( FOLLOW_model_column_clauses_in_reference_model2825_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cell_reference_options_in_reference_model2840_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000004000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cell_reference_options_in_reference_model2840( FOLLOW_cell_reference_options_in_reference_model2840_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_main_key_in_main_model2862_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_main_key_in_main_model2862( FOLLOW_main_key_in_main_model2862_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_main_model_name_in_main_model2864_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_main_model_name_in_main_model2864( FOLLOW_main_model_name_in_main_model2864_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_column_clauses_in_main_model2868_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000004000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_column_clauses_in_main_model2868( FOLLOW_model_column_clauses_in_main_model2868_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cell_reference_options_in_main_model2870_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000004000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cell_reference_options_in_main_model2870( FOLLOW_cell_reference_options_in_main_model2870_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_rules_clause_in_main_model2873_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_rules_clause_in_main_model2873( FOLLOW_model_rules_clause_in_main_model2873_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_column_partition_part_in_model_column_clauses2893_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_column_partition_part_in_model_column_clauses2893( FOLLOW_model_column_partition_part_in_model_column_clauses2893_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_dimension_key_in_model_column_clauses2904_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_dimension_key_in_model_column_clauses2904( FOLLOW_dimension_key_in_model_column_clauses2904_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_model_column_clauses2906_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_model_column_clauses2906( FOLLOW_by_key_in_model_column_clauses2906_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_column_list_in_model_column_clauses2908_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_column_list_in_model_column_clauses2908( FOLLOW_model_column_list_in_model_column_clauses2908_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_measures_key_in_model_column_clauses2910_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_measures_key_in_model_column_clauses2910( FOLLOW_measures_key_in_model_column_clauses2910_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_column_list_in_model_column_clauses2912_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_column_list_in_model_column_clauses2912( FOLLOW_model_column_list_in_model_column_clauses2912_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_partition_key_in_model_column_partition_part2932_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_partition_key_in_model_column_partition_part2932( FOLLOW_partition_key_in_model_column_partition_part2932_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_model_column_partition_part2934_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_model_column_partition_part2934( FOLLOW_by_key_in_model_column_partition_part2934_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_column_list_in_model_column_partition_part2936_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_column_list_in_model_column_partition_part2936( FOLLOW_model_column_list_in_model_column_partition_part2936_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_model_column_list2956_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_model_column_list2956( FOLLOW_LEFT_PAREN_in_model_column_list2956_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_column_in_model_column_list2958_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_column_in_model_column_list2958( FOLLOW_model_column_in_model_column_list2958_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_model_column_list2961_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_model_column_list2961( FOLLOW_COMMA_in_model_column_list2961_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_column_in_model_column_list2963_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_column_in_model_column_list2963( FOLLOW_model_column_in_model_column_list2963_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_model_column_list2968_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_model_column_list2968( FOLLOW_RIGHT_PAREN_in_model_column_list2968_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_model_column2988_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_model_column2988( FOLLOW_expression_in_model_column2988_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_alias_in_model_column2990_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_alias_in_model_column2990( FOLLOW_table_alias_in_model_column2990_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_rules_part_in_model_rules_clause3011_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_rules_part_in_model_rules_clause3011( FOLLOW_model_rules_part_in_model_rules_clause3011_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_model_rules_clause3014_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000809004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_model_rules_clause3014( FOLLOW_LEFT_PAREN_in_model_rules_clause3014_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_rules_element_in_model_rules_clause3016_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_rules_element_in_model_rules_clause3016( FOLLOW_model_rules_element_in_model_rules_clause3016_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_model_rules_clause3019_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000809004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_model_rules_clause3019( FOLLOW_COMMA_in_model_rules_clause3019_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_rules_element_in_model_rules_clause3021_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_rules_element_in_model_rules_clause3021( FOLLOW_model_rules_element_in_model_rules_clause3021_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_model_rules_clause3025_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_model_rules_clause3025( FOLLOW_RIGHT_PAREN_in_model_rules_clause3025_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_rules_key_in_model_rules_part3045_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_rules_key_in_model_rules_part3045( FOLLOW_rules_key_in_model_rules_part3045_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_update_key_in_model_rules_part3048_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_update_key_in_model_rules_part3048( FOLLOW_update_key_in_model_rules_part3048_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_upsert_key_in_model_rules_part3050_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000040400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_upsert_key_in_model_rules_part3050( FOLLOW_upsert_key_in_model_rules_part3050_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_model_rules_part3052_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_model_rules_part3052( FOLLOW_all_key_in_model_rules_part3052_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_automatic_key_in_model_rules_part3059_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_automatic_key_in_model_rules_part3059( FOLLOW_automatic_key_in_model_rules_part3059_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_sequential_key_in_model_rules_part3061_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_sequential_key_in_model_rules_part3061( FOLLOW_sequential_key_in_model_rules_part3061_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_key_in_model_rules_part3064_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_key_in_model_rules_part3064( FOLLOW_order_key_in_model_rules_part3064_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_iterate_clause_in_model_rules_part3068_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_iterate_clause_in_model_rules_part3068( FOLLOW_model_iterate_clause_in_model_rules_part3068_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_update_key_in_model_rules_element3090_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_update_key_in_model_rules_element3090( FOLLOW_update_key_in_model_rules_element3090_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_upsert_key_in_model_rules_element3092_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_upsert_key_in_model_rules_element3092( FOLLOW_upsert_key_in_model_rules_element3092_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_model_rules_element3100_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_model_rules_element3100( FOLLOW_all_key_in_model_rules_element3100_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cell_assignment_in_model_rules_element3114_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cell_assignment_in_model_rules_element3114( FOLLOW_cell_assignment_in_model_rules_element3114_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_model_rules_element3132_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_by_clause_in_model_rules_element3132( FOLLOW_order_by_clause_in_model_rules_element3132_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_model_rules_element3147_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_model_rules_element3147( FOLLOW_EQUALS_OP_in_model_rules_element3147_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_model_rules_element3149_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_model_rules_element3149( FOLLOW_expression_in_model_rules_element3149_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_expression_in_cell_assignment3169_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_expression_in_cell_assignment3169( FOLLOW_model_expression_in_cell_assignment3169_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_iterate_key_in_model_iterate_clause3189_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_iterate_key_in_model_iterate_clause3189( FOLLOW_iterate_key_in_model_iterate_clause3189_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_model_iterate_clause3191_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_model_iterate_clause3191( FOLLOW_LEFT_PAREN_in_model_iterate_clause3191_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_model_iterate_clause3193_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_model_iterate_clause3193( FOLLOW_expression_in_model_iterate_clause3193_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_model_iterate_clause3195_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_model_iterate_clause3195( FOLLOW_RIGHT_PAREN_in_model_iterate_clause3195_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_until_part_in_model_iterate_clause3197_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_until_part_in_model_iterate_clause3197( FOLLOW_until_part_in_model_iterate_clause3197_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_until_key_in_until_part3218_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_until_key_in_until_part3218( FOLLOW_until_key_in_until_part3218_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_until_part3220_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_until_part3220( FOLLOW_LEFT_PAREN_in_until_part3220_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_until_part3222_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_in_until_part3222( FOLLOW_condition_in_until_part3222_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_until_part3224_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_until_part3224( FOLLOW_RIGHT_PAREN_in_until_part3224_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_key_in_order_by_clause3244_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_key_in_order_by_clause3244( FOLLOW_order_key_in_order_by_clause3244_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_siblings_key_in_order_by_clause3246_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_siblings_key_in_order_by_clause3246( FOLLOW_siblings_key_in_order_by_clause3246_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_order_by_clause3249_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_order_by_clause3249( FOLLOW_by_key_in_order_by_clause3249_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_by_elements_in_order_by_clause3251_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_by_elements_in_order_by_clause3251( FOLLOW_order_by_elements_in_order_by_clause3251_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_order_by_clause3254_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_order_by_clause3254( FOLLOW_COMMA_in_order_by_clause3254_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_by_elements_in_order_by_clause3256_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_by_elements_in_order_by_clause3256( FOLLOW_order_by_elements_in_order_by_clause3256_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_order_by_elements3278_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000002000800400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_order_by_elements3278( FOLLOW_expression_in_order_by_elements3278_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_asc_key_in_order_by_elements3281_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_asc_key_in_order_by_elements3281( FOLLOW_asc_key_in_order_by_elements3281_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_desc_key_in_order_by_elements3283_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_desc_key_in_order_by_elements3283( FOLLOW_desc_key_in_order_by_elements3283_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_order_by_elements3288_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nulls_key_in_order_by_elements3288( FOLLOW_nulls_key_in_order_by_elements3288_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_first_key_in_order_by_elements3291_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_first_key_in_order_by_elements3291( FOLLOW_first_key_in_order_by_elements3291_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_last_key_in_order_by_elements3293_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_last_key_in_order_by_elements3293( FOLLOW_last_key_in_order_by_elements3293_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_key_in_for_update_clause3316_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_key_in_for_update_clause3316( FOLLOW_for_key_in_for_update_clause3316_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_update_key_in_for_update_clause3318_bits[]	= { ANTLR_UINT64_LIT(0x0400000000000002), ANTLR_UINT64_LIT(0x1000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_update_key_in_for_update_clause3318( FOLLOW_update_key_in_for_update_clause3318_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_update_of_part_in_for_update_clause3320_bits[]	= { ANTLR_UINT64_LIT(0x0400000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_update_of_part_in_for_update_clause3320( FOLLOW_for_update_of_part_in_for_update_clause3320_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_update_options_in_for_update_clause3323_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_update_options_in_for_update_clause3323( FOLLOW_for_update_options_in_for_update_clause3323_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_of_key_in_for_update_of_part3344_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_of_key_in_for_update_of_part3344( FOLLOW_of_key_in_for_update_of_part3344_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_for_update_of_part3346_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_for_update_of_part3346( FOLLOW_column_name_in_for_update_of_part3346_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_for_update_of_part3349_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_for_update_of_part3349( FOLLOW_COMMA_in_for_update_of_part3349_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_for_update_of_part3351_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_for_update_of_part3351( FOLLOW_column_name_in_for_update_of_part3351_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_skip_key_in_for_update_options3373_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_skip_key_in_for_update_options3373( FOLLOW_skip_key_in_for_update_options3373_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_locked_key_in_for_update_options3375_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_locked_key_in_for_update_options3375( FOLLOW_locked_key_in_for_update_options3375_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nowait_key_in_for_update_options3386_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nowait_key_in_for_update_options3386( FOLLOW_nowait_key_in_for_update_options3386_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_wait_key_in_for_update_options3397_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_wait_key_in_for_update_options3397( FOLLOW_wait_key_in_for_update_options3397_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_for_update_options3399_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_for_update_options3399( FOLLOW_expression_in_for_update_options3399_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_update_key_in_update_statement3421_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_update_key_in_update_statement3421( FOLLOW_update_key_in_update_statement3421_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_table_ref_in_update_statement3423_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_table_ref_in_update_statement3423( FOLLOW_general_table_ref_in_update_statement3423_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_update_set_clause_in_update_statement3433_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000080000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_update_set_clause_in_update_statement3433( FOLLOW_update_set_clause_in_update_statement3433_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_where_clause_in_update_statement3443_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_where_clause_in_update_statement3443( FOLLOW_where_clause_in_update_statement3443_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_static_returning_clause_in_update_statement3446_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_static_returning_clause_in_update_statement3446( FOLLOW_static_returning_clause_in_update_statement3446_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_error_logging_clause_in_update_statement3449_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_error_logging_clause_in_update_statement3449( FOLLOW_error_logging_clause_in_update_statement3449_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_set_key_in_update_set_clause3471_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_set_key_in_update_set_clause3471( FOLLOW_set_key_in_update_set_clause3471_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_based_update_set_clause_in_update_set_clause3482_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_based_update_set_clause_in_update_set_clause3482( FOLLOW_column_based_update_set_clause_in_update_set_clause3482_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_update_set_clause3485_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_update_set_clause3485( FOLLOW_COMMA_in_update_set_clause3485_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_based_update_set_clause_in_update_set_clause3487_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_based_update_set_clause_in_update_set_clause3487( FOLLOW_column_based_update_set_clause_in_update_set_clause3487_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_value_key_in_update_set_clause3500_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_value_key_in_update_set_clause3500( FOLLOW_value_key_in_update_set_clause3500_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_update_set_clause3502_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_update_set_clause3502( FOLLOW_LEFT_PAREN_in_update_set_clause3502_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_id_in_update_set_clause3504_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_id_in_update_set_clause3504( FOLLOW_id_in_update_set_clause3504_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_update_set_clause3506_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_update_set_clause3506( FOLLOW_RIGHT_PAREN_in_update_set_clause3506_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_update_set_clause3508_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_update_set_clause3508( FOLLOW_EQUALS_OP_in_update_set_clause3508_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_update_set_clause3510_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_update_set_clause3510( FOLLOW_expression_in_update_set_clause3510_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_column_based_update_set_clause3536_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_column_based_update_set_clause3536( FOLLOW_column_name_in_column_based_update_set_clause3536_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_column_based_update_set_clause3538_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_column_based_update_set_clause3538( FOLLOW_EQUALS_OP_in_column_based_update_set_clause3538_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_column_based_update_set_clause3540_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_column_based_update_set_clause3540( FOLLOW_expression_in_column_based_update_set_clause3540_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_column_based_update_set_clause3551_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_column_based_update_set_clause3551( FOLLOW_LEFT_PAREN_in_column_based_update_set_clause3551_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_column_based_update_set_clause3553_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_column_based_update_set_clause3553( FOLLOW_column_name_in_column_based_update_set_clause3553_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_column_based_update_set_clause3556_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_column_based_update_set_clause3556( FOLLOW_COMMA_in_column_based_update_set_clause3556_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_column_based_update_set_clause3558_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_column_based_update_set_clause3558( FOLLOW_column_name_in_column_based_update_set_clause3558_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_column_based_update_set_clause3562_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_column_based_update_set_clause3562( FOLLOW_RIGHT_PAREN_in_column_based_update_set_clause3562_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_column_based_update_set_clause3564_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_column_based_update_set_clause3564( FOLLOW_EQUALS_OP_in_column_based_update_set_clause3564_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_column_based_update_set_clause3566_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_column_based_update_set_clause3566( FOLLOW_subquery_in_column_based_update_set_clause3566_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_delete_key_in_delete_statement3588_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000800000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_delete_key_in_delete_statement3588( FOLLOW_delete_key_in_delete_statement3588_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_from_key_in_delete_statement3590_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_from_key_in_delete_statement3590( FOLLOW_from_key_in_delete_statement3590_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_table_ref_in_delete_statement3601_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000080000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_table_ref_in_delete_statement3601( FOLLOW_general_table_ref_in_delete_statement3601_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_where_clause_in_delete_statement3611_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_where_clause_in_delete_statement3611( FOLLOW_where_clause_in_delete_statement3611_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_static_returning_clause_in_delete_statement3614_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_static_returning_clause_in_delete_statement3614( FOLLOW_static_returning_clause_in_delete_statement3614_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_error_logging_clause_in_delete_statement3617_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_error_logging_clause_in_delete_statement3617( FOLLOW_error_logging_clause_in_delete_statement3617_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_insert_key_in_insert_statement3638_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000040400), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_insert_key_in_insert_statement3638( FOLLOW_insert_key_in_insert_statement3638_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_single_table_insert_in_insert_statement3649_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_single_table_insert_in_insert_statement3649( FOLLOW_single_table_insert_in_insert_statement3649_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multi_table_insert_in_insert_statement3660_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multi_table_insert_in_insert_statement3660( FOLLOW_multi_table_insert_in_insert_statement3660_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_insert_into_clause_in_single_table_insert3688_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000110040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_insert_into_clause_in_single_table_insert3688( FOLLOW_insert_into_clause_in_single_table_insert3688_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_values_clause_in_single_table_insert3699_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_values_clause_in_single_table_insert3699( FOLLOW_values_clause_in_single_table_insert3699_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_static_returning_clause_in_single_table_insert3701_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_static_returning_clause_in_single_table_insert3701( FOLLOW_static_returning_clause_in_single_table_insert3701_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_single_table_insert3713_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_statement_in_single_table_insert3713( FOLLOW_select_statement_in_single_table_insert3713_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_error_logging_clause_in_single_table_insert3729_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_error_logging_clause_in_single_table_insert3729( FOLLOW_error_logging_clause_in_single_table_insert3729_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_multi_table_insert3760_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_multi_table_insert3760( FOLLOW_all_key_in_multi_table_insert3760_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multi_table_element_in_multi_table_insert3762_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0080000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multi_table_element_in_multi_table_insert3762( FOLLOW_multi_table_element_in_multi_table_insert3762_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_conditional_insert_clause_in_multi_table_insert3774_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_conditional_insert_clause_in_multi_table_insert3774( FOLLOW_conditional_insert_clause_in_multi_table_insert3774_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_multi_table_insert3790_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_statement_in_multi_table_insert3790( FOLLOW_select_statement_in_multi_table_insert3790_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_insert_into_clause_in_multi_table_element3810_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000010000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_insert_into_clause_in_multi_table_element3810( FOLLOW_insert_into_clause_in_multi_table_element3810_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_values_clause_in_multi_table_element3812_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_values_clause_in_multi_table_element3812( FOLLOW_values_clause_in_multi_table_element3812_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_error_logging_clause_in_multi_table_element3815_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_error_logging_clause_in_multi_table_element3815( FOLLOW_error_logging_clause_in_multi_table_element3815_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_conditional_insert_clause3837_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_conditional_insert_clause3837( FOLLOW_all_key_in_conditional_insert_clause3837_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_first_key_in_conditional_insert_clause3839_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_first_key_in_conditional_insert_clause3839( FOLLOW_first_key_in_conditional_insert_clause3839_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_conditional_insert_when_part_in_conditional_insert_clause3851_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000010000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_conditional_insert_when_part_in_conditional_insert_clause3851( FOLLOW_conditional_insert_when_part_in_conditional_insert_clause3851_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_conditional_insert_else_part_in_conditional_insert_clause3854_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_conditional_insert_else_part_in_conditional_insert_clause3854( FOLLOW_conditional_insert_else_part_in_conditional_insert_clause3854_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_conditional_insert_when_part3875_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_when_key_in_conditional_insert_when_part3875( FOLLOW_when_key_in_conditional_insert_when_part3875_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_conditional_insert_when_part3877_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_in_conditional_insert_when_part3877( FOLLOW_condition_in_conditional_insert_when_part3877_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_then_key_in_conditional_insert_when_part3879_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_then_key_in_conditional_insert_when_part3879( FOLLOW_then_key_in_conditional_insert_when_part3879_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multi_table_element_in_conditional_insert_when_part3881_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0080000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multi_table_element_in_conditional_insert_when_part3881( FOLLOW_multi_table_element_in_conditional_insert_when_part3881_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_else_key_in_conditional_insert_else_part3902_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_else_key_in_conditional_insert_else_part3902( FOLLOW_else_key_in_conditional_insert_else_part3902_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multi_table_element_in_conditional_insert_else_part3904_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0080000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multi_table_element_in_conditional_insert_else_part3904( FOLLOW_multi_table_element_in_conditional_insert_else_part3904_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_into_key_in_insert_into_clause3925_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_into_key_in_insert_into_clause3925( FOLLOW_into_key_in_insert_into_clause3925_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_table_ref_in_insert_into_clause3927_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_table_ref_in_insert_into_clause3927( FOLLOW_general_table_ref_in_insert_into_clause3927_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_insert_into_clause3939_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_insert_into_clause3939( FOLLOW_LEFT_PAREN_in_insert_into_clause3939_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_insert_into_clause3941_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_insert_into_clause3941( FOLLOW_column_name_in_insert_into_clause3941_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_insert_into_clause3944_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_insert_into_clause3944( FOLLOW_COMMA_in_insert_into_clause3944_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_insert_into_clause3946_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_insert_into_clause3946( FOLLOW_column_name_in_insert_into_clause3946_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_insert_into_clause3950_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_insert_into_clause3950( FOLLOW_RIGHT_PAREN_in_insert_into_clause3950_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_values_key_in_values_clause3972_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_values_key_in_values_clause3972( FOLLOW_values_key_in_values_clause3972_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_values_clause3974_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_list_in_values_clause3974( FOLLOW_expression_list_in_values_clause3974_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_merge_key_in_merge_statement3995_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_merge_key_in_merge_statement3995( FOLLOW_merge_key_in_merge_statement3995_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_into_key_in_merge_statement3997_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_into_key_in_merge_statement3997( FOLLOW_into_key_in_merge_statement3997_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_merge_statement3999_bits[]	= { ANTLR_UINT64_LIT(0x0000100410043000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_merge_statement3999( FOLLOW_tableview_name_in_merge_statement3999_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_alias_in_merge_statement4001_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_alias_in_merge_statement4001( FOLLOW_table_alias_in_merge_statement4001_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_using_key_in_merge_statement4012_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_using_key_in_merge_statement4012( FOLLOW_using_key_in_merge_statement4012_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_selected_tableview_in_merge_statement4014_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_selected_tableview_in_merge_statement4014( FOLLOW_selected_tableview_in_merge_statement4014_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_on_key_in_merge_statement4016_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_on_key_in_merge_statement4016( FOLLOW_on_key_in_merge_statement4016_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_merge_statement4018_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_merge_statement4018( FOLLOW_LEFT_PAREN_in_merge_statement4018_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_merge_statement4020_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_in_merge_statement4020( FOLLOW_condition_in_merge_statement4020_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_merge_statement4022_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_merge_statement4022( FOLLOW_RIGHT_PAREN_in_merge_statement4022_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_merge_update_clause_in_merge_statement4054_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_merge_update_clause_in_merge_statement4054( FOLLOW_merge_update_clause_in_merge_statement4054_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_merge_insert_clause_in_merge_statement4056_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_merge_insert_clause_in_merge_statement4056( FOLLOW_merge_insert_clause_in_merge_statement4056_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_merge_insert_clause_in_merge_statement4091_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_merge_insert_clause_in_merge_statement4091( FOLLOW_merge_insert_clause_in_merge_statement4091_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_merge_update_clause_in_merge_statement4093_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_merge_update_clause_in_merge_statement4093( FOLLOW_merge_update_clause_in_merge_statement4093_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_error_logging_clause_in_merge_statement4115_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_error_logging_clause_in_merge_statement4115( FOLLOW_error_logging_clause_in_merge_statement4115_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_merge_update_clause4138_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_when_key_in_merge_update_clause4138( FOLLOW_when_key_in_merge_update_clause4138_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_matched_key_in_merge_update_clause4140_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_matched_key_in_merge_update_clause4140( FOLLOW_matched_key_in_merge_update_clause4140_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_then_key_in_merge_update_clause4142_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_then_key_in_merge_update_clause4142( FOLLOW_then_key_in_merge_update_clause4142_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_update_key_in_merge_update_clause4144_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_update_key_in_merge_update_clause4144( FOLLOW_update_key_in_merge_update_clause4144_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_set_key_in_merge_update_clause4146_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_set_key_in_merge_update_clause4146( FOLLOW_set_key_in_merge_update_clause4146_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_merge_element_in_merge_update_clause4157_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002), ANTLR_UINT64_LIT(0x0000001000000000), ANTLR_UINT64_LIT(0x0000000000080000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_merge_element_in_merge_update_clause4157( FOLLOW_merge_element_in_merge_update_clause4157_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_merge_update_clause4160_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_merge_update_clause4160( FOLLOW_COMMA_in_merge_update_clause4160_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_merge_element_in_merge_update_clause4162_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002), ANTLR_UINT64_LIT(0x0000001000000000), ANTLR_UINT64_LIT(0x0000000000080000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_merge_element_in_merge_update_clause4162( FOLLOW_merge_element_in_merge_update_clause4162_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_where_clause_in_merge_update_clause4174_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000001000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_where_clause_in_merge_update_clause4174( FOLLOW_where_clause_in_merge_update_clause4174_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_merge_update_delete_part_in_merge_update_clause4177_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_merge_update_delete_part_in_merge_update_clause4177( FOLLOW_merge_update_delete_part_in_merge_update_clause4177_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_merge_element4198_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_merge_element4198( FOLLOW_column_name_in_merge_element4198_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_merge_element4200_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_merge_element4200( FOLLOW_EQUALS_OP_in_merge_element4200_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_merge_element4202_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_merge_element4202( FOLLOW_expression_in_merge_element4202_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_delete_key_in_merge_update_delete_part4222_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000080000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_delete_key_in_merge_update_delete_part4222( FOLLOW_delete_key_in_merge_update_delete_part4222_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_where_clause_in_merge_update_delete_part4224_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_where_clause_in_merge_update_delete_part4224( FOLLOW_where_clause_in_merge_update_delete_part4224_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_merge_insert_clause4244_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0400000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_when_key_in_merge_insert_clause4244( FOLLOW_when_key_in_merge_insert_clause4244_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_not_key_in_merge_insert_clause4246_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_not_key_in_merge_insert_clause4246( FOLLOW_not_key_in_merge_insert_clause4246_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_matched_key_in_merge_insert_clause4248_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_matched_key_in_merge_insert_clause4248( FOLLOW_matched_key_in_merge_insert_clause4248_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_then_key_in_merge_insert_clause4250_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_then_key_in_merge_insert_clause4250( FOLLOW_then_key_in_merge_insert_clause4250_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_insert_key_in_merge_insert_clause4252_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000010000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_insert_key_in_merge_insert_clause4252( FOLLOW_insert_key_in_merge_insert_clause4252_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_merge_insert_clause4264_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_merge_insert_clause4264( FOLLOW_LEFT_PAREN_in_merge_insert_clause4264_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_merge_insert_clause4266_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_merge_insert_clause4266( FOLLOW_column_name_in_merge_insert_clause4266_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_merge_insert_clause4269_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_merge_insert_clause4269( FOLLOW_COMMA_in_merge_insert_clause4269_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_merge_insert_clause4271_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_merge_insert_clause4271( FOLLOW_column_name_in_merge_insert_clause4271_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_merge_insert_clause4275_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000010000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_merge_insert_clause4275( FOLLOW_RIGHT_PAREN_in_merge_insert_clause4275_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_values_key_in_merge_insert_clause4287_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_values_key_in_merge_insert_clause4287( FOLLOW_values_key_in_merge_insert_clause4287_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_merge_insert_clause4289_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000080000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_list_in_merge_insert_clause4289( FOLLOW_expression_list_in_merge_insert_clause4289_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_where_clause_in_merge_insert_clause4291_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_where_clause_in_merge_insert_clause4291( FOLLOW_where_clause_in_merge_insert_clause4291_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_selected_tableview4314_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_selected_tableview4314( FOLLOW_tableview_name_in_selected_tableview4314_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_selected_tableview4318_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_selected_tableview4318( FOLLOW_LEFT_PAREN_in_selected_tableview4318_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_selected_tableview4320_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_statement_in_selected_tableview4320( FOLLOW_select_statement_in_selected_tableview4320_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_selected_tableview4322_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_selected_tableview4322( FOLLOW_RIGHT_PAREN_in_selected_tableview4322_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_alias_in_selected_tableview4326_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_alias_in_selected_tableview4326( FOLLOW_table_alias_in_selected_tableview4326_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_lock_key_in_lock_table_statement4349_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000100) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_lock_key_in_lock_table_statement4349( FOLLOW_lock_key_in_lock_table_statement4349_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_key_in_lock_table_statement4351_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_key_in_lock_table_statement4351( FOLLOW_table_key_in_lock_table_statement4351_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_lock_table_element_in_lock_table_statement4362_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0010000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_lock_table_element_in_lock_table_statement4362( FOLLOW_lock_table_element_in_lock_table_statement4362_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_lock_table_statement4365_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_lock_table_statement4365( FOLLOW_COMMA_in_lock_table_statement4365_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_lock_table_element_in_lock_table_statement4367_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0010000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_lock_table_element_in_lock_table_statement4367( FOLLOW_lock_table_element_in_lock_table_statement4367_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_lock_table_statement4380_bits[]	= { ANTLR_UINT64_LIT(0x1002000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_in_key_in_lock_table_statement4380( FOLLOW_in_key_in_lock_table_statement4380_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_lock_mode_in_lock_table_statement4382_bits[]	= { ANTLR_UINT64_LIT(0x0100000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_lock_mode_in_lock_table_statement4382( FOLLOW_lock_mode_in_lock_table_statement4382_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_mode_key_in_lock_table_statement4384_bits[]	= { ANTLR_UINT64_LIT(0x0400000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_mode_key_in_lock_table_statement4384( FOLLOW_mode_key_in_lock_table_statement4384_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_wait_nowait_part_in_lock_table_statement4386_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_wait_nowait_part_in_lock_table_statement4386( FOLLOW_wait_nowait_part_in_lock_table_statement4386_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_wait_key_in_wait_nowait_part4407_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_wait_key_in_wait_nowait_part4407( FOLLOW_wait_key_in_wait_nowait_part4407_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_wait_nowait_part4409_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_wait_nowait_part4409( FOLLOW_expression_in_wait_nowait_part4409_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nowait_key_in_wait_nowait_part4420_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nowait_key_in_wait_nowait_part4420( FOLLOW_nowait_key_in_wait_nowait_part4420_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_lock_table_element4442_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_lock_table_element4442( FOLLOW_tableview_name_in_lock_table_element4442_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_partition_extension_clause_in_lock_table_element4444_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_partition_extension_clause_in_lock_table_element4444( FOLLOW_partition_extension_clause_in_lock_table_element4444_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_row_key_in_lock_mode4465_bits[]	= { ANTLR_UINT64_LIT(0x1000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_row_key_in_lock_mode4465( FOLLOW_row_key_in_lock_mode4465_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_share_key_in_lock_mode4467_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_share_key_in_lock_mode4467( FOLLOW_share_key_in_lock_mode4467_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_row_key_in_lock_mode4478_bits[]	= { ANTLR_UINT64_LIT(0x0002000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_row_key_in_lock_mode4478( FOLLOW_row_key_in_lock_mode4478_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_exclusive_key_in_lock_mode4480_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_exclusive_key_in_lock_mode4480( FOLLOW_exclusive_key_in_lock_mode4480_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_share_key_in_lock_mode4491_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_share_key_in_lock_mode4491( FOLLOW_share_key_in_lock_mode4491_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_update_key_in_lock_mode4493_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_update_key_in_lock_mode4493( FOLLOW_update_key_in_lock_mode4493_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_share_key_in_lock_mode4505_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_share_key_in_lock_mode4505( FOLLOW_share_key_in_lock_mode4505_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_row_key_in_lock_mode4507_bits[]	= { ANTLR_UINT64_LIT(0x0002000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_row_key_in_lock_mode4507( FOLLOW_row_key_in_lock_mode4507_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_exclusive_key_in_lock_mode4509_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_exclusive_key_in_lock_mode4509( FOLLOW_exclusive_key_in_lock_mode4509_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_exclusive_key_in_lock_mode4520_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_exclusive_key_in_lock_mode4520( FOLLOW_exclusive_key_in_lock_mode4520_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_dml_table_expression_clause_in_general_table_ref4548_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_dml_table_expression_clause_in_general_table_ref4548( FOLLOW_dml_table_expression_clause_in_general_table_ref4548_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_only_key_in_general_table_ref4563_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_only_key_in_general_table_ref4563( FOLLOW_only_key_in_general_table_ref4563_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_general_table_ref4565_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_general_table_ref4565( FOLLOW_LEFT_PAREN_in_general_table_ref4565_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_dml_table_expression_clause_in_general_table_ref4567_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_dml_table_expression_clause_in_general_table_ref4567( FOLLOW_dml_table_expression_clause_in_general_table_ref4567_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_general_table_ref4569_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_general_table_ref4569( FOLLOW_RIGHT_PAREN_in_general_table_ref4569_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_alias_in_general_table_ref4584_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_alias_in_general_table_ref4584( FOLLOW_table_alias_in_general_table_ref4584_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_returning_key_in_static_returning_clause4606_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_returning_key_in_static_returning_clause4606( FOLLOW_returning_key_in_static_returning_clause4606_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_return_key_in_static_returning_clause4608_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_return_key_in_static_returning_clause4608( FOLLOW_return_key_in_static_returning_clause4608_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_static_returning_clause4611_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0080000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_static_returning_clause4611( FOLLOW_expression_in_static_returning_clause4611_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_static_returning_clause4614_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_static_returning_clause4614( FOLLOW_COMMA_in_static_returning_clause4614_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_static_returning_clause4616_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0080000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_static_returning_clause4616( FOLLOW_expression_in_static_returning_clause4616_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_into_clause_in_static_returning_clause4629_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_into_clause_in_static_returning_clause4629( FOLLOW_into_clause_in_static_returning_clause4629_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_log_key_in_error_logging_clause4649_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_log_key_in_error_logging_clause4649( FOLLOW_log_key_in_error_logging_clause4649_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_errors_key_in_error_logging_clause4651_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447222), ANTLR_UINT64_LIT(0x0C80184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_errors_key_in_error_logging_clause4651( FOLLOW_errors_key_in_error_logging_clause4651_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_error_logging_into_part_in_error_logging_clause4662_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447222), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_error_logging_into_part_in_error_logging_clause4662( FOLLOW_error_logging_into_part_in_error_logging_clause4662_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_error_logging_clause4679_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_error_logging_clause4679( FOLLOW_expression_wrapper_in_error_logging_clause4679_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_error_logging_reject_part_in_error_logging_clause4691_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_error_logging_reject_part_in_error_logging_clause4691( FOLLOW_error_logging_reject_part_in_error_logging_clause4691_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_into_key_in_error_logging_into_part4712_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_into_key_in_error_logging_into_part4712( FOLLOW_into_key_in_error_logging_into_part4712_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_error_logging_into_part4714_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_error_logging_into_part4714( FOLLOW_tableview_name_in_error_logging_into_part4714_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_reject_key_in_error_logging_reject_part4734_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_reject_key_in_error_logging_reject_part4734( FOLLOW_reject_key_in_error_logging_reject_part4734_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_limit_key_in_error_logging_reject_part4736_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_limit_key_in_error_logging_reject_part4736( FOLLOW_limit_key_in_error_logging_reject_part4736_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unlimited_key_in_error_logging_reject_part4743_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unlimited_key_in_error_logging_reject_part4743( FOLLOW_unlimited_key_in_error_logging_reject_part4743_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_error_logging_reject_part4745_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_error_logging_reject_part4745( FOLLOW_expression_wrapper_in_error_logging_reject_part4745_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_collection_expression_in_dml_table_expression_clause4766_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_collection_expression_in_dml_table_expression_clause4766( FOLLOW_table_collection_expression_in_dml_table_expression_clause4766_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_dml_table_expression_clause4777_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_dml_table_expression_clause4777( FOLLOW_LEFT_PAREN_in_dml_table_expression_clause4777_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_dml_table_expression_clause4779_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_statement_in_dml_table_expression_clause4779( FOLLOW_select_statement_in_dml_table_expression_clause4779_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_restriction_clause_in_dml_table_expression_clause4781_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_restriction_clause_in_dml_table_expression_clause4781( FOLLOW_subquery_restriction_clause_in_dml_table_expression_clause4781_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_dml_table_expression_clause4784_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_dml_table_expression_clause4784( FOLLOW_RIGHT_PAREN_in_dml_table_expression_clause4784_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_dml_table_expression_clause4795_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_dml_table_expression_clause4795( FOLLOW_tableview_name_in_dml_table_expression_clause4795_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_sample_clause_in_dml_table_expression_clause4797_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_sample_clause_in_dml_table_expression_clause4797( FOLLOW_sample_clause_in_dml_table_expression_clause4797_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_key_in_table_collection_expression4820_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_key_in_table_collection_expression4820( FOLLOW_table_key_in_table_collection_expression4820_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_the_key_in_table_collection_expression4824_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_the_key_in_table_collection_expression4824( FOLLOW_the_key_in_table_collection_expression4824_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_table_collection_expression4852_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_table_collection_expression4852( FOLLOW_LEFT_PAREN_in_table_collection_expression4852_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_table_collection_expression4854_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_table_collection_expression4854( FOLLOW_subquery_in_table_collection_expression4854_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_table_collection_expression4856_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_table_collection_expression4856( FOLLOW_RIGHT_PAREN_in_table_collection_expression4856_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_table_collection_expression4869_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_table_collection_expression4869( FOLLOW_LEFT_PAREN_in_table_collection_expression4869_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_table_collection_expression4871_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_table_collection_expression4871( FOLLOW_expression_in_table_collection_expression4871_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_table_collection_expression4873_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_table_collection_expression4873( FOLLOW_RIGHT_PAREN_in_table_collection_expression4873_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_subquery_restriction_clause4905_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000010000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_subquery_restriction_clause4905( FOLLOW_with_key_in_subquery_restriction_clause4905_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_read_key_in_subquery_restriction_clause4916_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_read_key_in_subquery_restriction_clause4916( FOLLOW_read_key_in_subquery_restriction_clause4916_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_only_key_in_subquery_restriction_clause4918_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_only_key_in_subquery_restriction_clause4918( FOLLOW_only_key_in_subquery_restriction_clause4918_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_check_key_in_subquery_restriction_clause4929_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_check_key_in_subquery_restriction_clause4929( FOLLOW_check_key_in_subquery_restriction_clause4929_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_option_key_in_subquery_restriction_clause4931_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_option_key_in_subquery_restriction_clause4931( FOLLOW_option_key_in_subquery_restriction_clause4931_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_constraint_key_in_subquery_restriction_clause4934_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_constraint_key_in_subquery_restriction_clause4934( FOLLOW_constraint_key_in_subquery_restriction_clause4934_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_constraint_name_in_subquery_restriction_clause4936_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_constraint_name_in_subquery_restriction_clause4936( FOLLOW_constraint_name_in_subquery_restriction_clause4936_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_sample_key_in_sample_clause4964_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_sample_key_in_sample_clause4964( FOLLOW_sample_key_in_sample_clause4964_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_block_key_in_sample_clause4966_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_block_key_in_sample_clause4966( FOLLOW_block_key_in_sample_clause4966_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_sample_clause4978_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_sample_clause4978( FOLLOW_LEFT_PAREN_in_sample_clause4978_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_sample_clause4980_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_sample_clause4980( FOLLOW_expression_in_sample_clause4980_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_sample_clause4983_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_sample_clause4983( FOLLOW_COMMA_in_sample_clause4983_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_sample_clause4985_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_sample_clause4985( FOLLOW_expression_in_sample_clause4985_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_sample_clause4989_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_sample_clause4989( FOLLOW_RIGHT_PAREN_in_sample_clause4989_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_seed_part_in_sample_clause4999_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_seed_part_in_sample_clause4999( FOLLOW_seed_part_in_sample_clause4999_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_seed_key_in_seed_part5020_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_seed_key_in_seed_part5020( FOLLOW_seed_key_in_seed_part5020_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_seed_part5022_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_seed_part5022( FOLLOW_LEFT_PAREN_in_seed_part5022_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_seed_part5024_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_seed_part5024( FOLLOW_expression_in_seed_part5024_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_seed_part5026_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_seed_part5026( FOLLOW_RIGHT_PAREN_in_seed_part5026_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_key_in_cursor_expression5049_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cursor_key_in_cursor_expression5049( FOLLOW_cursor_key_in_cursor_expression5049_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_cursor_expression5051_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_cursor_expression5051( FOLLOW_LEFT_PAREN_in_cursor_expression5051_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_cursor_expression5053_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_cursor_expression5053( FOLLOW_subquery_in_cursor_expression5053_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_cursor_expression5055_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_cursor_expression5055( FOLLOW_RIGHT_PAREN_in_cursor_expression5055_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_expression_list5075_bits[]	= { ANTLR_UINT64_LIT(0x000000865044F220), ANTLR_UINT64_LIT(0x0C00184B08241401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_expression_list5075( FOLLOW_LEFT_PAREN_in_expression_list5075_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_expression_list5077_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_expression_list5077( FOLLOW_expression_in_expression_list5077_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_expression_list5081_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_expression_list5081( FOLLOW_COMMA_in_expression_list5081_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_expression_list5083_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_expression_list5083( FOLLOW_expression_in_expression_list5083_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_expression_list5087_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_expression_list5087( FOLLOW_RIGHT_PAREN_in_expression_list5087_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_condition5108_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_condition5108( FOLLOW_expression_in_condition5108_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_condition_wrapper5128_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_condition_wrapper5128( FOLLOW_expression_in_condition_wrapper5128_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_expression_in_expression5162_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cursor_expression_in_expression5162( FOLLOW_cursor_expression_in_expression5162_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_logical_and_expression_in_expression5173_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x8000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_logical_and_expression_in_expression5173( FOLLOW_logical_and_expression_in_expression5173_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_or_key_in_expression5177_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_or_key_in_expression5177( FOLLOW_or_key_in_expression5177_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_logical_and_expression_in_expression5179_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x8000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_logical_and_expression_in_expression5179( FOLLOW_logical_and_expression_in_expression5179_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_expression_wrapper5202_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_expression_wrapper5202( FOLLOW_expression_in_expression_wrapper5202_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_negated_expression_in_logical_and_expression5222_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_negated_expression_in_logical_and_expression5222( FOLLOW_negated_expression_in_logical_and_expression5222_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_and_key_in_logical_and_expression5226_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_and_key_in_logical_and_expression5226( FOLLOW_and_key_in_logical_and_expression5226_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_negated_expression_in_logical_and_expression5228_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_negated_expression_in_logical_and_expression5228( FOLLOW_negated_expression_in_logical_and_expression5228_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_not_key_in_negated_expression5251_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_not_key_in_negated_expression5251( FOLLOW_not_key_in_negated_expression5251_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_negated_expression_in_negated_expression5253_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_negated_expression_in_negated_expression5253( FOLLOW_negated_expression_in_negated_expression5253_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_equality_expression_in_negated_expression5264_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_equality_expression_in_negated_expression5264( FOLLOW_equality_expression_in_negated_expression5264_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multiset_comparsion_in_equality_expression5284_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0100000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multiset_comparsion_in_equality_expression5284( FOLLOW_multiset_comparsion_in_equality_expression5284_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_equality_expression5295_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1C00000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_is_key_in_equality_expression5295( FOLLOW_is_key_in_equality_expression5295_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_not_key_in_equality_expression5297_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1800000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_not_key_in_equality_expression5297( FOLLOW_not_key_in_equality_expression5297_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_null_key_in_equality_expression5313_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_null_key_in_equality_expression5313( FOLLOW_null_key_in_equality_expression5313_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nan_key_in_equality_expression5328_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nan_key_in_equality_expression5328( FOLLOW_nan_key_in_equality_expression5328_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_present_key_in_equality_expression5343_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_present_key_in_equality_expression5343( FOLLOW_present_key_in_equality_expression5343_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_infinite_key_in_equality_expression5358_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_infinite_key_in_equality_expression5358( FOLLOW_infinite_key_in_equality_expression5358_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_a_key_in_equality_expression5373_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_a_key_in_equality_expression5373( FOLLOW_a_key_in_equality_expression5373_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_set_key_in_equality_expression5375_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_set_key_in_equality_expression5375( FOLLOW_set_key_in_equality_expression5375_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_empty_key_in_equality_expression5390_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_empty_key_in_equality_expression5390( FOLLOW_empty_key_in_equality_expression5390_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_of_key_in_equality_expression5405_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_of_key_in_equality_expression5405( FOLLOW_of_key_in_equality_expression5405_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_type_key_in_equality_expression5407_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_type_key_in_equality_expression5407( FOLLOW_type_key_in_equality_expression5407_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_equality_expression5410_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_equality_expression5410( FOLLOW_LEFT_PAREN_in_equality_expression5410_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_only_key_in_equality_expression5412_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_only_key_in_equality_expression5412( FOLLOW_only_key_in_equality_expression5412_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_equality_expression5415_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_type_spec_in_equality_expression5415( FOLLOW_type_spec_in_equality_expression5415_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_equality_expression5418_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_equality_expression5418( FOLLOW_COMMA_in_equality_expression5418_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_equality_expression5420_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_type_spec_in_equality_expression5420( FOLLOW_type_spec_in_equality_expression5420_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_equality_expression5424_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_equality_expression5424( FOLLOW_RIGHT_PAREN_in_equality_expression5424_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_relational_expression_in_multiset_comparsion5462_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_relational_expression_in_multiset_comparsion5462( FOLLOW_relational_expression_in_multiset_comparsion5462_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multiset_type_in_multiset_comparsion5473_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x1800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multiset_type_in_multiset_comparsion5473( FOLLOW_multiset_type_in_multiset_comparsion5473_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_of_key_in_multiset_comparsion5475_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_of_key_in_multiset_comparsion5475( FOLLOW_of_key_in_multiset_comparsion5475_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_multiset_comparsion5478_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_in_multiset_comparsion5478( FOLLOW_concatenation_in_multiset_comparsion5478_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_member_key_in_multiset_type5500_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_member_key_in_multiset_type5500( FOLLOW_member_key_in_multiset_type5500_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_submultiset_key_in_multiset_type5511_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_submultiset_key_in_multiset_type5511( FOLLOW_submultiset_key_in_multiset_type5511_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_compound_expression_in_relational_expression5531_bits[]	= { ANTLR_UINT64_LIT(0x0000001186A00802) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_compound_expression_in_relational_expression5531( FOLLOW_compound_expression_in_relational_expression5531_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_relational_expression5541_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_relational_expression5541( FOLLOW_EQUALS_OP_in_relational_expression5541_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_not_equal_op_in_relational_expression5545_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_not_equal_op_in_relational_expression5545( FOLLOW_not_equal_op_in_relational_expression5545_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LESS_THAN_OP_in_relational_expression5549_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LESS_THAN_OP_in_relational_expression5549( FOLLOW_LESS_THAN_OP_in_relational_expression5549_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OP_in_relational_expression5553_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_GREATER_THAN_OP_in_relational_expression5553( FOLLOW_GREATER_THAN_OP_in_relational_expression5553_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_less_than_or_equals_op_in_relational_expression5557_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_less_than_or_equals_op_in_relational_expression5557( FOLLOW_less_than_or_equals_op_in_relational_expression5557_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_greater_than_or_equals_op_in_relational_expression5561_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_greater_than_or_equals_op_in_relational_expression5561( FOLLOW_greater_than_or_equals_op_in_relational_expression5561_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_compound_expression_in_relational_expression5565_bits[]	= { ANTLR_UINT64_LIT(0x0000001186A00802) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_compound_expression_in_relational_expression5565( FOLLOW_compound_expression_in_relational_expression5565_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_compound_expression5587_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0610000002000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_in_compound_expression5587( FOLLOW_concatenation_in_compound_expression5587_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_not_key_in_compound_expression5598_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0210000002000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_not_key_in_compound_expression5598( FOLLOW_not_key_in_compound_expression5598_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_compound_expression5614_bits[]	= { ANTLR_UINT64_LIT(0x0000000450447220), ANTLR_UINT64_LIT(0x0800100A00000400), ANTLR_UINT64_LIT(0x0000000000801000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_in_key_in_compound_expression5614( FOLLOW_in_key_in_compound_expression5614_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_in_elements_in_compound_expression5616_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_in_elements_in_compound_expression5616( FOLLOW_in_elements_in_compound_expression5616_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_between_key_in_compound_expression5631_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_between_key_in_compound_expression5631( FOLLOW_between_key_in_compound_expression5631_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_between_elements_in_compound_expression5633_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_between_elements_in_compound_expression5633( FOLLOW_between_elements_in_compound_expression5633_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_like_type_in_compound_expression5648_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_like_type_in_compound_expression5648( FOLLOW_like_type_in_compound_expression5648_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_compound_expression5650_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_in_compound_expression5650( FOLLOW_concatenation_in_compound_expression5650_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_like_escape_part_in_compound_expression5652_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_like_escape_part_in_compound_expression5652( FOLLOW_like_escape_part_in_compound_expression5652_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_like_key_in_like_type5690_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_like_key_in_like_type5690( FOLLOW_like_key_in_like_type5690_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_likec_key_in_like_type5701_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_likec_key_in_like_type5701( FOLLOW_likec_key_in_like_type5701_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_like2_key_in_like_type5712_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_like2_key_in_like_type5712( FOLLOW_like2_key_in_like_type5712_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_like4_key_in_like_type5723_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_like4_key_in_like_type5723( FOLLOW_like4_key_in_like_type5723_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_escape_key_in_like_escape_part5743_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_escape_key_in_like_escape_part5743( FOLLOW_escape_key_in_like_escape_part5743_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_like_escape_part5745_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_in_like_escape_part5745( FOLLOW_concatenation_in_like_escape_part5745_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_in_elements5778_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_in_elements5778( FOLLOW_LEFT_PAREN_in_in_elements5778_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_in_elements5780_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_in_elements5780( FOLLOW_subquery_in_in_elements5780_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_in_elements5782_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_in_elements5782( FOLLOW_RIGHT_PAREN_in_in_elements5782_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_in_elements5793_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_in_elements5793( FOLLOW_LEFT_PAREN_in_in_elements5793_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_in_elements5795_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_in_elements5795( FOLLOW_concatenation_wrapper_in_in_elements5795_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_in_elements5798_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_in_elements5798( FOLLOW_COMMA_in_in_elements5798_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_in_elements5800_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_in_elements5800( FOLLOW_concatenation_wrapper_in_in_elements5800_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_in_elements5804_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_in_elements5804( FOLLOW_RIGHT_PAREN_in_in_elements5804_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_constant_in_in_elements5815_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_constant_in_in_elements5815( FOLLOW_constant_in_in_elements5815_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_in_elements5826_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_bind_variable_in_in_elements5826( FOLLOW_bind_variable_in_in_elements5826_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_in_in_elements5837_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_in_in_elements5837( FOLLOW_general_element_in_in_elements5837_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_between_elements5857_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_in_between_elements5857( FOLLOW_concatenation_in_between_elements5857_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_and_key_in_between_elements5859_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_and_key_in_between_elements5859( FOLLOW_and_key_in_between_elements5859_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_between_elements5861_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_in_between_elements5861( FOLLOW_concatenation_in_between_elements5861_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_additive_expression_in_concatenation5881_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000001000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_additive_expression_in_concatenation5881( FOLLOW_additive_expression_in_concatenation5881_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_op_in_concatenation5884_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_op_in_concatenation5884( FOLLOW_concatenation_op_in_concatenation5884_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_additive_expression_in_concatenation5886_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000001000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_additive_expression_in_concatenation5886( FOLLOW_additive_expression_in_concatenation5886_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_concatenation_wrapper5908_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_in_concatenation_wrapper5908( FOLLOW_concatenation_in_concatenation_wrapper5908_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multiply_expression_in_additive_expression5928_bits[]	= { ANTLR_UINT64_LIT(0x0000000200000002), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multiply_expression_in_additive_expression5928( FOLLOW_multiply_expression_in_additive_expression5928_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_additive_expression5932_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_set_in_additive_expression5932( FOLLOW_set_in_additive_expression5932_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multiply_expression_in_additive_expression5942_bits[]	= { ANTLR_UINT64_LIT(0x0000000200000002), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multiply_expression_in_additive_expression5942( FOLLOW_multiply_expression_in_additive_expression5942_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_datetime_expression_in_multiply_expression5964_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000082), ANTLR_UINT64_LIT(0x0000000000010000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_datetime_expression_in_multiply_expression5964( FOLLOW_datetime_expression_in_multiply_expression5964_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_multiply_expression5968_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_set_in_multiply_expression5968( FOLLOW_set_in_multiply_expression5968_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_datetime_expression_in_multiply_expression5978_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000082), ANTLR_UINT64_LIT(0x0000000000010000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_datetime_expression_in_multiply_expression5978( FOLLOW_datetime_expression_in_multiply_expression5978_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_expression_in_datetime_expression6000_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_expression_in_datetime_expression6000( FOLLOW_model_expression_in_datetime_expression6000_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_at_key_in_datetime_expression6011_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_at_key_in_datetime_expression6011( FOLLOW_at_key_in_datetime_expression6011_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_local_key_in_datetime_expression6014_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_local_key_in_datetime_expression6014( FOLLOW_local_key_in_datetime_expression6014_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_time_key_in_datetime_expression6016_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_time_key_in_datetime_expression6016( FOLLOW_time_key_in_datetime_expression6016_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_zone_key_in_datetime_expression6018_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_zone_key_in_datetime_expression6018( FOLLOW_zone_key_in_datetime_expression6018_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_datetime_expression6020_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_datetime_expression6020( FOLLOW_concatenation_wrapper_in_datetime_expression6020_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_interval_expression_in_datetime_expression6037_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_interval_expression_in_datetime_expression6037( FOLLOW_interval_expression_in_datetime_expression6037_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_day_key_in_interval_expression6064_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_day_key_in_interval_expression6064( FOLLOW_day_key_in_interval_expression6064_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_interval_expression6070_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_interval_expression6070( FOLLOW_LEFT_PAREN_in_interval_expression6070_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_interval_expression6072_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_interval_expression6072( FOLLOW_concatenation_wrapper_in_interval_expression6072_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_interval_expression6074_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_interval_expression6074( FOLLOW_RIGHT_PAREN_in_interval_expression6074_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_to_key_in_interval_expression6078_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_to_key_in_interval_expression6078( FOLLOW_to_key_in_interval_expression6078_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_second_key_in_interval_expression6080_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_second_key_in_interval_expression6080( FOLLOW_second_key_in_interval_expression6080_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_interval_expression6083_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_interval_expression6083( FOLLOW_LEFT_PAREN_in_interval_expression6083_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_interval_expression6085_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_interval_expression6085( FOLLOW_concatenation_wrapper_in_interval_expression6085_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_interval_expression6087_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_interval_expression6087( FOLLOW_RIGHT_PAREN_in_interval_expression6087_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_year_key_in_interval_expression6100_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_year_key_in_interval_expression6100( FOLLOW_year_key_in_interval_expression6100_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_interval_expression6103_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_interval_expression6103( FOLLOW_LEFT_PAREN_in_interval_expression6103_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_interval_expression6105_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_interval_expression6105( FOLLOW_concatenation_wrapper_in_interval_expression6105_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_interval_expression6107_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_interval_expression6107( FOLLOW_RIGHT_PAREN_in_interval_expression6107_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_to_key_in_interval_expression6111_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_to_key_in_interval_expression6111( FOLLOW_to_key_in_interval_expression6111_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_month_key_in_interval_expression6113_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_month_key_in_interval_expression6113( FOLLOW_month_key_in_interval_expression6113_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multiset_expression_in_model_expression6133_bits[]	= { ANTLR_UINT64_LIT(0x0000000020000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multiset_expression_in_model_expression6133( FOLLOW_multiset_expression_in_model_expression6133_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_BRACKET_in_model_expression6144_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00584B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_BRACKET_in_model_expression6144( FOLLOW_LEFT_BRACKET_in_model_expression6144_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_expression_element_in_model_expression6146_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_expression_element_in_model_expression6146( FOLLOW_model_expression_element_in_model_expression6146_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_BRACKET_in_model_expression6148_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_BRACKET_in_model_expression6148( FOLLOW_RIGHT_BRACKET_in_model_expression6148_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_any_key_in_model_expression_element6176_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_any_key_in_model_expression_element6176( FOLLOW_any_key_in_model_expression_element6176_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_wrapper_in_model_expression_element6178_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_wrapper_in_model_expression_element6178( FOLLOW_condition_wrapper_in_model_expression_element6178_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_model_expression_element6182_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_model_expression_element6182( FOLLOW_COMMA_in_model_expression_element6182_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_any_key_in_model_expression_element6190_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_any_key_in_model_expression_element6190( FOLLOW_any_key_in_model_expression_element6190_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_wrapper_in_model_expression_element6192_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_wrapper_in_model_expression_element6192( FOLLOW_condition_wrapper_in_model_expression_element6192_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_single_column_for_loop_in_model_expression_element6206_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_single_column_for_loop_in_model_expression_element6206( FOLLOW_single_column_for_loop_in_model_expression_element6206_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_model_expression_element6209_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_model_expression_element6209( FOLLOW_COMMA_in_model_expression_element6209_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_single_column_for_loop_in_model_expression_element6211_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_single_column_for_loop_in_model_expression_element6211( FOLLOW_single_column_for_loop_in_model_expression_element6211_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multi_column_for_loop_in_model_expression_element6224_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multi_column_for_loop_in_model_expression_element6224( FOLLOW_multi_column_for_loop_in_model_expression_element6224_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_key_in_single_column_for_loop6244_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_key_in_single_column_for_loop6244( FOLLOW_for_key_in_single_column_for_loop6244_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_single_column_for_loop6246_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0210800000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_single_column_for_loop6246( FOLLOW_column_name_in_single_column_for_loop6246_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_single_column_for_loop6258_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_in_key_in_single_column_for_loop6258( FOLLOW_in_key_in_single_column_for_loop6258_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_single_column_for_loop6260_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_list_in_single_column_for_loop6260( FOLLOW_expression_list_in_single_column_for_loop6260_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_like_part_in_single_column_for_loop6271_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_like_part_in_single_column_for_loop6271( FOLLOW_for_like_part_in_single_column_for_loop6271_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_from_key_in_single_column_for_loop6274_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_from_key_in_single_column_for_loop6274( FOLLOW_from_key_in_single_column_for_loop6274_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_single_column_for_loop6278_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_single_column_for_loop6278( FOLLOW_expression_in_single_column_for_loop6278_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_to_key_in_single_column_for_loop6292_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_to_key_in_single_column_for_loop6292( FOLLOW_to_key_in_single_column_for_loop6292_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_single_column_for_loop6296_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_single_column_for_loop6296( FOLLOW_expression_in_single_column_for_loop6296_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_increment_decrement_type_in_single_column_for_loop6298_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_increment_decrement_type_in_single_column_for_loop6298( FOLLOW_for_increment_decrement_type_in_single_column_for_loop6298_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_single_column_for_loop6302_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_single_column_for_loop6302( FOLLOW_expression_in_single_column_for_loop6302_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_like_key_in_for_like_part6333_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_like_key_in_for_like_part6333( FOLLOW_like_key_in_for_like_part6333_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_for_like_part6335_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_for_like_part6335( FOLLOW_expression_in_for_like_part6335_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_increment_key_in_for_increment_decrement_type6355_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_increment_key_in_for_increment_decrement_type6355( FOLLOW_increment_key_in_for_increment_decrement_type6355_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_decrement_key_in_for_increment_decrement_type6366_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_decrement_key_in_for_increment_decrement_type6366( FOLLOW_decrement_key_in_for_increment_decrement_type6366_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_key_in_multi_column_for_loop6386_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_key_in_multi_column_for_loop6386( FOLLOW_for_key_in_multi_column_for_loop6386_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_multi_column_for_loop6388_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_multi_column_for_loop6388( FOLLOW_LEFT_PAREN_in_multi_column_for_loop6388_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_multi_column_for_loop6390_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_multi_column_for_loop6390( FOLLOW_column_name_in_multi_column_for_loop6390_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_multi_column_for_loop6393_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_multi_column_for_loop6393( FOLLOW_COMMA_in_multi_column_for_loop6393_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_multi_column_for_loop6395_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_multi_column_for_loop6395( FOLLOW_column_name_in_multi_column_for_loop6395_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6399_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0010000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6399( FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6399_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_multi_column_for_loop6401_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_in_key_in_multi_column_for_loop6401( FOLLOW_in_key_in_multi_column_for_loop6401_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_multi_column_for_loop6411_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_multi_column_for_loop6411( FOLLOW_LEFT_PAREN_in_multi_column_for_loop6411_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_multi_column_for_loop6435_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_multi_column_for_loop6435( FOLLOW_subquery_in_multi_column_for_loop6435_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_multi_column_for_loop6459_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_multi_column_for_loop6459( FOLLOW_LEFT_PAREN_in_multi_column_for_loop6459_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_multi_column_for_loop6461_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_list_in_multi_column_for_loop6461( FOLLOW_expression_list_in_multi_column_for_loop6461_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_multi_column_for_loop6464_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_multi_column_for_loop6464( FOLLOW_COMMA_in_multi_column_for_loop6464_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_multi_column_for_loop6466_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_list_in_multi_column_for_loop6466( FOLLOW_expression_list_in_multi_column_for_loop6466_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6470_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6470( FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6470_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6494_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6494( FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6494_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_multiset_expression6508_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_multiset_expression6508( FOLLOW_unary_expression_in_multiset_expression6508_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multiset_op_in_multiset_expression6514_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multiset_op_in_multiset_expression6514( FOLLOW_multiset_op_in_multiset_expression6514_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_multiset_expression6516_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_multiset_expression6516( FOLLOW_unary_expression_in_multiset_expression6516_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_MINUS_SIGN_in_unary_expression6545_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_MINUS_SIGN_in_unary_expression6545( FOLLOW_MINUS_SIGN_in_unary_expression6545_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression6547_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression6547( FOLLOW_unary_expression_in_unary_expression6547_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PLUS_SIGN_in_unary_expression6558_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PLUS_SIGN_in_unary_expression6558( FOLLOW_PLUS_SIGN_in_unary_expression6558_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression6560_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression6560( FOLLOW_unary_expression_in_unary_expression6560_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_prior_key_in_unary_expression6571_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_prior_key_in_unary_expression6571( FOLLOW_prior_key_in_unary_expression6571_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression6573_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression6573( FOLLOW_unary_expression_in_unary_expression6573_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_connect_by_root_key_in_unary_expression6584_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_connect_by_root_key_in_unary_expression6584( FOLLOW_connect_by_root_key_in_unary_expression6584_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression6586_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression6586( FOLLOW_unary_expression_in_unary_expression6586_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_new_key_in_unary_expression6601_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_new_key_in_unary_expression6601( FOLLOW_new_key_in_unary_expression6601_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression6603_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression6603( FOLLOW_unary_expression_in_unary_expression6603_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_distinct_key_in_unary_expression6614_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_distinct_key_in_unary_expression6614( FOLLOW_distinct_key_in_unary_expression6614_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression6616_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression6616( FOLLOW_unary_expression_in_unary_expression6616_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_unary_expression6627_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_unary_expression6627( FOLLOW_all_key_in_unary_expression6627_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression6629_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression6629( FOLLOW_unary_expression_in_unary_expression6629_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_case_statement_in_unary_expression6642_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_case_statement_in_unary_expression6642( FOLLOW_case_statement_in_unary_expression6642_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_quantified_expression_in_unary_expression6654_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_quantified_expression_in_unary_expression6654( FOLLOW_quantified_expression_in_unary_expression6654_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_standard_function_in_unary_expression6665_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_standard_function_in_unary_expression6665( FOLLOW_standard_function_in_unary_expression6665_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_atom_in_unary_expression6676_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_atom_in_unary_expression6676( FOLLOW_atom_in_unary_expression6676_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_searched_case_statement_in_case_statement6723_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_searched_case_statement_in_case_statement6723( FOLLOW_searched_case_statement_in_case_statement6723_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_simple_case_statement_in_case_statement6734_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_simple_case_statement_in_case_statement6734( FOLLOW_simple_case_statement_in_case_statement6734_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_label_name_in_simple_case_statement6756_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000008000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_label_name_in_simple_case_statement6756( FOLLOW_label_name_in_simple_case_statement6756_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_case_key_in_simple_case_statement6761_bits[]	= { ANTLR_UINT64_LIT(0x0000000450447220), ANTLR_UINT64_LIT(0x0800100A00000400), ANTLR_UINT64_LIT(0x0000000000801000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_case_key_in_simple_case_statement6761( FOLLOW_case_key_in_simple_case_statement6761_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_atom_in_simple_case_statement6763_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_atom_in_simple_case_statement6763( FOLLOW_atom_in_simple_case_statement6763_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_simple_case_when_part_in_simple_case_statement6773_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000030000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_simple_case_when_part_in_simple_case_statement6773( FOLLOW_simple_case_when_part_in_simple_case_statement6773_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_case_else_part_in_simple_case_statement6785_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_case_else_part_in_simple_case_statement6785( FOLLOW_case_else_part_in_simple_case_statement6785_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_end_key_in_simple_case_statement6796_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040002), ANTLR_UINT64_LIT(0x0000000008000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_end_key_in_simple_case_statement6796( FOLLOW_end_key_in_simple_case_statement6796_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_case_key_in_simple_case_statement6798_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_case_key_in_simple_case_statement6798( FOLLOW_case_key_in_simple_case_statement6798_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_label_name_in_simple_case_statement6801_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_label_name_in_simple_case_statement6801( FOLLOW_label_name_in_simple_case_statement6801_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_simple_case_when_part6822_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_when_key_in_simple_case_when_part6822( FOLLOW_when_key_in_simple_case_when_part6822_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_simple_case_when_part6824_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_simple_case_when_part6824( FOLLOW_expression_wrapper_in_simple_case_when_part6824_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_then_key_in_simple_case_when_part6826_bits[]	= { ANTLR_UINT64_LIT(0x00480086D0447220), ANTLR_UINT64_LIT(0x0C23785F492C0401), ANTLR_UINT64_LIT(0x000000000090904C) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_then_key_in_simple_case_when_part6826( FOLLOW_then_key_in_simple_case_when_part6826_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_seq_of_statements_in_simple_case_when_part6831_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_seq_of_statements_in_simple_case_when_part6831( FOLLOW_seq_of_statements_in_simple_case_when_part6831_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_simple_case_when_part6835_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_simple_case_when_part6835( FOLLOW_expression_wrapper_in_simple_case_when_part6835_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_label_name_in_searched_case_statement6856_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000008000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_label_name_in_searched_case_statement6856( FOLLOW_label_name_in_searched_case_statement6856_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_case_key_in_searched_case_statement6861_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_case_key_in_searched_case_statement6861( FOLLOW_case_key_in_searched_case_statement6861_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_searched_case_when_part_in_searched_case_statement6871_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000030000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_searched_case_when_part_in_searched_case_statement6871( FOLLOW_searched_case_when_part_in_searched_case_statement6871_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_case_else_part_in_searched_case_statement6882_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_case_else_part_in_searched_case_statement6882( FOLLOW_case_else_part_in_searched_case_statement6882_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_end_key_in_searched_case_statement6893_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040002), ANTLR_UINT64_LIT(0x0000000008000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_end_key_in_searched_case_statement6893( FOLLOW_end_key_in_searched_case_statement6893_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_case_key_in_searched_case_statement6895_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_case_key_in_searched_case_statement6895( FOLLOW_case_key_in_searched_case_statement6895_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_label_name_in_searched_case_statement6898_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_label_name_in_searched_case_statement6898( FOLLOW_label_name_in_searched_case_statement6898_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_searched_case_when_part6919_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_when_key_in_searched_case_when_part6919( FOLLOW_when_key_in_searched_case_when_part6919_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_wrapper_in_searched_case_when_part6921_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_wrapper_in_searched_case_when_part6921( FOLLOW_condition_wrapper_in_searched_case_when_part6921_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_then_key_in_searched_case_when_part6923_bits[]	= { ANTLR_UINT64_LIT(0x00480086D0447220), ANTLR_UINT64_LIT(0x0C23785F492C0401), ANTLR_UINT64_LIT(0x000000000090904C) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_then_key_in_searched_case_when_part6923( FOLLOW_then_key_in_searched_case_when_part6923_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_seq_of_statements_in_searched_case_when_part6928_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_seq_of_statements_in_searched_case_when_part6928( FOLLOW_seq_of_statements_in_searched_case_when_part6928_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_searched_case_when_part6932_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_searched_case_when_part6932( FOLLOW_expression_wrapper_in_searched_case_when_part6932_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_else_key_in_case_else_part6953_bits[]	= { ANTLR_UINT64_LIT(0x00480086D0447220), ANTLR_UINT64_LIT(0x0C23785F492C0401), ANTLR_UINT64_LIT(0x000000000090904C) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_else_key_in_case_else_part6953( FOLLOW_else_key_in_case_else_part6953_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_seq_of_statements_in_case_else_part6958_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_seq_of_statements_in_case_else_part6958( FOLLOW_seq_of_statements_in_case_else_part6958_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_case_else_part6962_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_case_else_part6962( FOLLOW_expression_wrapper_in_case_else_part6962_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_element_in_atom7001_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_element_in_atom7001( FOLLOW_table_element_in_atom7001_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_outer_join_sign_in_atom7003_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_outer_join_sign_in_atom7003( FOLLOW_outer_join_sign_in_atom7003_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_atom7014_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_bind_variable_in_atom7014( FOLLOW_bind_variable_in_atom7014_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_constant_in_atom7025_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_constant_in_atom7025( FOLLOW_constant_in_atom7025_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_in_atom7036_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_in_atom7036( FOLLOW_general_element_in_atom7036_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_atom7047_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801044) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_atom7047( FOLLOW_LEFT_PAREN_in_atom7047_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_atom7084_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_atom7084( FOLLOW_subquery_in_atom7084_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_atom7086_bits[]	= { ANTLR_UINT64_LIT(0x0080000000000002), ANTLR_UINT64_LIT(0x0040000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_atom7086( FOLLOW_RIGHT_PAREN_in_atom7086_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_operation_part_in_atom7088_bits[]	= { ANTLR_UINT64_LIT(0x0080000000000002), ANTLR_UINT64_LIT(0x0040000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_operation_part_in_atom7088( FOLLOW_subquery_operation_part_in_atom7088_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_or_vector_in_atom7107_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_or_vector_in_atom7107( FOLLOW_expression_or_vector_in_atom7107_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_atom7109_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_atom7109( FOLLOW_RIGHT_PAREN_in_atom7109_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_expression_or_vector7140_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_expression_or_vector7140( FOLLOW_expression_in_expression_or_vector7140_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_vector_expr_in_expression_or_vector7143_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_vector_expr_in_expression_or_vector7143( FOLLOW_vector_expr_in_expression_or_vector7143_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_vector_expr7165_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_vector_expr7165( FOLLOW_COMMA_in_vector_expr7165_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_vector_expr7167_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_vector_expr7167( FOLLOW_expression_in_vector_expr7167_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_vector_expr7170_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_vector_expr7170( FOLLOW_COMMA_in_vector_expr7170_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_vector_expr7172_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_vector_expr7172( FOLLOW_expression_in_vector_expr7172_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_some_key_in_quantified_expression7196_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_some_key_in_quantified_expression7196( FOLLOW_some_key_in_quantified_expression7196_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_exists_key_in_quantified_expression7200_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_exists_key_in_quantified_expression7200( FOLLOW_exists_key_in_quantified_expression7200_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_quantified_expression7204_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_quantified_expression7204( FOLLOW_all_key_in_quantified_expression7204_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_any_key_in_quantified_expression7208_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_any_key_in_quantified_expression7208( FOLLOW_any_key_in_quantified_expression7208_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_quantified_expression7235_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_quantified_expression7235( FOLLOW_LEFT_PAREN_in_quantified_expression7235_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_quantified_expression7237_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_quantified_expression7237( FOLLOW_subquery_in_quantified_expression7237_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_quantified_expression7239_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_quantified_expression7239( FOLLOW_RIGHT_PAREN_in_quantified_expression7239_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_quantified_expression7254_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_quantified_expression7254( FOLLOW_LEFT_PAREN_in_quantified_expression7254_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_quantified_expression7256_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_quantified_expression7256( FOLLOW_expression_wrapper_in_quantified_expression7256_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_quantified_expression7258_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_quantified_expression7258( FOLLOW_RIGHT_PAREN_in_quantified_expression7258_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_stantard_function_enabling_over_in_standard_function7289_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_stantard_function_enabling_over_in_standard_function7289( FOLLOW_stantard_function_enabling_over_in_standard_function7289_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_function_argument_analytic_in_standard_function7291_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_function_argument_analytic_in_standard_function7291( FOLLOW_function_argument_analytic_in_standard_function7291_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_over_clause_in_standard_function7293_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_over_clause_in_standard_function7293( FOLLOW_over_clause_in_standard_function7293_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_stantard_function_enabling_using_in_standard_function7305_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_stantard_function_enabling_using_in_standard_function7305( FOLLOW_stantard_function_enabling_using_in_standard_function7305_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_function_argument_modeling_in_standard_function7307_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_function_argument_modeling_in_standard_function7307( FOLLOW_function_argument_modeling_in_standard_function7307_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_using_clause_in_standard_function7309_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_using_clause_in_standard_function7309( FOLLOW_using_clause_in_standard_function7309_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_count_key_in_standard_function7321_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_count_key_in_standard_function7321( FOLLOW_count_key_in_standard_function7321_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function7335_bits[]	= { ANTLR_UINT64_LIT(0x00000086504472A0), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000805004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function7335( FOLLOW_LEFT_PAREN_in_standard_function7335_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_standard_function7355_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_ASTERISK_in_standard_function7355( FOLLOW_ASTERISK_in_standard_function7355_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_distinct_key_in_standard_function7360_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_distinct_key_in_standard_function7360( FOLLOW_distinct_key_in_standard_function7360_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unique_key_in_standard_function7362_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unique_key_in_standard_function7362( FOLLOW_unique_key_in_standard_function7362_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_standard_function7364_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_standard_function7364( FOLLOW_all_key_in_standard_function7364_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function7368_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function7368( FOLLOW_concatenation_wrapper_in_standard_function7368_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function7384_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function7384( FOLLOW_RIGHT_PAREN_in_standard_function7384_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_over_clause_in_standard_function7386_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_over_clause_in_standard_function7386( FOLLOW_over_clause_in_standard_function7386_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cast_key_in_standard_function7399_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cast_key_in_standard_function7399( FOLLOW_cast_key_in_standard_function7399_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlcast_key_in_standard_function7401_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlcast_key_in_standard_function7401( FOLLOW_xmlcast_key_in_standard_function7401_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function7417_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function7417( FOLLOW_LEFT_PAREN_in_standard_function7417_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multiset_key_in_standard_function7445_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multiset_key_in_standard_function7445( FOLLOW_multiset_key_in_standard_function7445_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function7447_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function7447( FOLLOW_LEFT_PAREN_in_standard_function7447_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_standard_function7449_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_standard_function7449( FOLLOW_subquery_in_standard_function7449_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_standard_function7451_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_by_clause_in_standard_function7451( FOLLOW_order_by_clause_in_standard_function7451_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function7454_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000401000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function7454( FOLLOW_RIGHT_PAREN_in_standard_function7454_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_standard_function7468_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_as_key_in_standard_function7468( FOLLOW_as_key_in_standard_function7468_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_standard_function7470_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_type_spec_in_standard_function7470( FOLLOW_type_spec_in_standard_function7470_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function7492_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000400000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function7492( FOLLOW_concatenation_wrapper_in_standard_function7492_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_standard_function7494_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_as_key_in_standard_function7494( FOLLOW_as_key_in_standard_function7494_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_standard_function7496_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_type_spec_in_standard_function7496( FOLLOW_type_spec_in_standard_function7496_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function7528_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function7528( FOLLOW_RIGHT_PAREN_in_standard_function7528_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_chr_key_in_standard_function7539_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_chr_key_in_standard_function7539( FOLLOW_chr_key_in_standard_function7539_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function7553_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function7553( FOLLOW_LEFT_PAREN_in_standard_function7553_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function7572_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function7572( FOLLOW_concatenation_wrapper_in_standard_function7572_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_using_key_in_standard_function7574_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_using_key_in_standard_function7574( FOLLOW_using_key_in_standard_function7574_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nchar_cs_key_in_standard_function7576_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nchar_cs_key_in_standard_function7576( FOLLOW_nchar_cs_key_in_standard_function7576_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function7591_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function7591( FOLLOW_RIGHT_PAREN_in_standard_function7591_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_collect_key_in_standard_function7602_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_collect_key_in_standard_function7602( FOLLOW_collect_key_in_standard_function7602_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function7616_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000805004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function7616( FOLLOW_LEFT_PAREN_in_standard_function7616_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_distinct_key_in_standard_function7636_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_distinct_key_in_standard_function7636( FOLLOW_distinct_key_in_standard_function7636_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unique_key_in_standard_function7638_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unique_key_in_standard_function7638( FOLLOW_unique_key_in_standard_function7638_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function7642_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function7642( FOLLOW_concatenation_wrapper_in_standard_function7642_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_collect_order_by_part_in_standard_function7644_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_collect_order_by_part_in_standard_function7644( FOLLOW_collect_order_by_part_in_standard_function7644_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function7659_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function7659( FOLLOW_RIGHT_PAREN_in_standard_function7659_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_stantard_function_enabling_within_or_over_in_standard_function7670_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_stantard_function_enabling_within_or_over_in_standard_function7670( FOLLOW_stantard_function_enabling_within_or_over_in_standard_function7670_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_function_argument_in_standard_function7685_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_function_argument_in_standard_function7685( FOLLOW_function_argument_in_standard_function7685_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_within_or_over_part_in_standard_function7687_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_within_or_over_part_in_standard_function7687( FOLLOW_within_or_over_part_in_standard_function7687_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_decompose_key_in_standard_function7699_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_decompose_key_in_standard_function7699( FOLLOW_decompose_key_in_standard_function7699_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function7713_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function7713( FOLLOW_LEFT_PAREN_in_standard_function7713_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function7732_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function7732( FOLLOW_concatenation_wrapper_in_standard_function7732_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_canonical_key_in_standard_function7735_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_canonical_key_in_standard_function7735( FOLLOW_canonical_key_in_standard_function7735_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_compatibility_key_in_standard_function7737_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_compatibility_key_in_standard_function7737( FOLLOW_compatibility_key_in_standard_function7737_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function7754_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function7754( FOLLOW_RIGHT_PAREN_in_standard_function7754_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_extract_key_in_standard_function7765_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_extract_key_in_standard_function7765( FOLLOW_extract_key_in_standard_function7765_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function7779_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function7779( FOLLOW_LEFT_PAREN_in_standard_function7779_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_standard_function7797_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_standard_function7797( FOLLOW_REGULAR_ID_in_standard_function7797_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_from_key_in_standard_function7799_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_from_key_in_standard_function7799( FOLLOW_from_key_in_standard_function7799_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function7801_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function7801( FOLLOW_concatenation_wrapper_in_standard_function7801_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function7816_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function7816( FOLLOW_RIGHT_PAREN_in_standard_function7816_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_first_value_key_in_standard_function7828_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_first_value_key_in_standard_function7828( FOLLOW_first_value_key_in_standard_function7828_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_last_value_key_in_standard_function7830_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_last_value_key_in_standard_function7830( FOLLOW_last_value_key_in_standard_function7830_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_function_argument_analytic_in_standard_function7833_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_function_argument_analytic_in_standard_function7833( FOLLOW_function_argument_analytic_in_standard_function7833_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_respect_or_ignore_nulls_in_standard_function7848_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_respect_or_ignore_nulls_in_standard_function7848( FOLLOW_respect_or_ignore_nulls_in_standard_function7848_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_over_clause_in_standard_function7851_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_over_clause_in_standard_function7851( FOLLOW_over_clause_in_standard_function7851_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_stantard_function_pedictions_in_standard_function7862_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_stantard_function_pedictions_in_standard_function7862( FOLLOW_stantard_function_pedictions_in_standard_function7862_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function7876_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function7876( FOLLOW_LEFT_PAREN_in_standard_function7876_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function7894_bits[]	= { ANTLR_UINT64_LIT(0x0000100000008000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function7894( FOLLOW_expression_wrapper_in_standard_function7894_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function7897_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function7897( FOLLOW_COMMA_in_standard_function7897_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function7899_bits[]	= { ANTLR_UINT64_LIT(0x0000100000008000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function7899( FOLLOW_expression_wrapper_in_standard_function7899_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cost_matrix_clause_in_standard_function7903_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cost_matrix_clause_in_standard_function7903( FOLLOW_cost_matrix_clause_in_standard_function7903_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_using_clause_in_standard_function7906_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_using_clause_in_standard_function7906( FOLLOW_using_clause_in_standard_function7906_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function7922_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function7922( FOLLOW_RIGHT_PAREN_in_standard_function7922_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_translate_key_in_standard_function7933_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_translate_key_in_standard_function7933( FOLLOW_translate_key_in_standard_function7933_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function7947_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function7947( FOLLOW_LEFT_PAREN_in_standard_function7947_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function7966_bits[]	= { ANTLR_UINT64_LIT(0x0000100000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function7966( FOLLOW_expression_wrapper_in_standard_function7966_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_using_key_in_standard_function7969_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_using_key_in_standard_function7969( FOLLOW_using_key_in_standard_function7969_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_char_cs_key_in_standard_function7972_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_char_cs_key_in_standard_function7972( FOLLOW_char_cs_key_in_standard_function7972_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nchar_cs_key_in_standard_function7974_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nchar_cs_key_in_standard_function7974( FOLLOW_nchar_cs_key_in_standard_function7974_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function8001_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function8001( FOLLOW_COMMA_in_standard_function8001_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function8003_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function8003( FOLLOW_expression_wrapper_in_standard_function8003_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8020_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8020( FOLLOW_RIGHT_PAREN_in_standard_function8020_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_treat_key_in_standard_function8031_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_treat_key_in_standard_function8031( FOLLOW_treat_key_in_standard_function8031_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8045_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8045( FOLLOW_LEFT_PAREN_in_standard_function8045_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function8063_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000400000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function8063( FOLLOW_expression_wrapper_in_standard_function8063_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_standard_function8065_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_as_key_in_standard_function8065( FOLLOW_as_key_in_standard_function8065_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_ref_key_in_standard_function8067_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_ref_key_in_standard_function8067( FOLLOW_ref_key_in_standard_function8067_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_standard_function8070_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_type_spec_in_standard_function8070( FOLLOW_type_spec_in_standard_function8070_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8085_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8085( FOLLOW_RIGHT_PAREN_in_standard_function8085_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_trim_key_in_standard_function8096_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_trim_key_in_standard_function8096( FOLLOW_trim_key_in_standard_function8096_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8110_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800984A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8110( FOLLOW_LEFT_PAREN_in_standard_function8110_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_leading_key_in_standard_function8131_bits[]	= { ANTLR_UINT64_LIT(0x0000000400003000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_leading_key_in_standard_function8131( FOLLOW_leading_key_in_standard_function8131_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_trailing_key_in_standard_function8133_bits[]	= { ANTLR_UINT64_LIT(0x0000000400003000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_trailing_key_in_standard_function8133( FOLLOW_trailing_key_in_standard_function8133_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_both_key_in_standard_function8135_bits[]	= { ANTLR_UINT64_LIT(0x0000000400003000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_both_key_in_standard_function8135( FOLLOW_both_key_in_standard_function8135_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_standard_function8139_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_quoted_string_in_standard_function8139( FOLLOW_quoted_string_in_standard_function8139_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_from_key_in_standard_function8142_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_from_key_in_standard_function8142( FOLLOW_from_key_in_standard_function8142_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function8162_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function8162( FOLLOW_concatenation_wrapper_in_standard_function8162_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8176_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8176( FOLLOW_RIGHT_PAREN_in_standard_function8176_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlagg_key_in_standard_function8187_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlagg_key_in_standard_function8187( FOLLOW_xmlagg_key_in_standard_function8187_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8201_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8201( FOLLOW_LEFT_PAREN_in_standard_function8201_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function8220_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function8220( FOLLOW_expression_wrapper_in_standard_function8220_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_standard_function8222_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_by_clause_in_standard_function8222( FOLLOW_order_by_clause_in_standard_function8222_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8238_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8238( FOLLOW_RIGHT_PAREN_in_standard_function8238_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function8253_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function8253( FOLLOW_PERIOD_in_standard_function8253_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function8255_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function8255( FOLLOW_general_element_part_in_standard_function8255_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlcolattval_key_in_standard_function8269_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlcolattval_key_in_standard_function8269( FOLLOW_xmlcolattval_key_in_standard_function8269_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlforest_key_in_standard_function8271_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlforest_key_in_standard_function8271( FOLLOW_xmlforest_key_in_standard_function8271_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8287_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8287( FOLLOW_LEFT_PAREN_in_standard_function8287_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_multiuse_expression_element_in_standard_function8305_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_multiuse_expression_element_in_standard_function8305( FOLLOW_xml_multiuse_expression_element_in_standard_function8305_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function8308_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function8308( FOLLOW_COMMA_in_standard_function8308_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_multiuse_expression_element_in_standard_function8310_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_multiuse_expression_element_in_standard_function8310( FOLLOW_xml_multiuse_expression_element_in_standard_function8310_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8326_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8326( FOLLOW_RIGHT_PAREN_in_standard_function8326_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function8341_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function8341( FOLLOW_PERIOD_in_standard_function8341_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function8343_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function8343( FOLLOW_general_element_part_in_standard_function8343_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlelement_key_in_standard_function8356_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlelement_key_in_standard_function8356( FOLLOW_xmlelement_key_in_standard_function8356_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8370_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8370( FOLLOW_LEFT_PAREN_in_standard_function8370_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_entityescaping_key_in_standard_function8389_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_entityescaping_key_in_standard_function8389( FOLLOW_entityescaping_key_in_standard_function8389_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_noentityescaping_key_in_standard_function8391_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_noentityescaping_key_in_standard_function8391( FOLLOW_noentityescaping_key_in_standard_function8391_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_name_key_in_standard_function8412_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_name_key_in_standard_function8412( FOLLOW_name_key_in_standard_function8412_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_evalname_key_in_standard_function8414_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_evalname_key_in_standard_function8414( FOLLOW_evalname_key_in_standard_function8414_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function8418_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function8418( FOLLOW_expression_wrapper_in_standard_function8418_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function8439_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function8439( FOLLOW_COMMA_in_standard_function8439_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_attributes_clause_in_standard_function8441_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_attributes_clause_in_standard_function8441( FOLLOW_xml_attributes_clause_in_standard_function8441_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function8462_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function8462( FOLLOW_COMMA_in_standard_function8462_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function8464_bits[]	= { ANTLR_UINT64_LIT(0x000000041004B000), ANTLR_UINT64_LIT(0x0000000000401400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function8464( FOLLOW_expression_wrapper_in_standard_function8464_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_standard_function8466_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_alias_in_standard_function8466( FOLLOW_column_alias_in_standard_function8466_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8483_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8483( FOLLOW_RIGHT_PAREN_in_standard_function8483_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function8498_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function8498( FOLLOW_PERIOD_in_standard_function8498_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function8500_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function8500( FOLLOW_general_element_part_in_standard_function8500_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlexists_key_in_standard_function8513_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlexists_key_in_standard_function8513( FOLLOW_xmlexists_key_in_standard_function8513_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8527_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8527( FOLLOW_LEFT_PAREN_in_standard_function8527_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function8545_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function8545( FOLLOW_expression_wrapper_in_standard_function8545_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_passing_clause_in_standard_function8563_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_passing_clause_in_standard_function8563( FOLLOW_xml_passing_clause_in_standard_function8563_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8578_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8578( FOLLOW_RIGHT_PAREN_in_standard_function8578_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlparse_key_in_standard_function8589_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlparse_key_in_standard_function8589( FOLLOW_xmlparse_key_in_standard_function8589_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8603_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8603( FOLLOW_LEFT_PAREN_in_standard_function8603_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_document_key_in_standard_function8623_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_document_key_in_standard_function8623( FOLLOW_document_key_in_standard_function8623_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_content_key_in_standard_function8625_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_content_key_in_standard_function8625( FOLLOW_content_key_in_standard_function8625_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function8628_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function8628( FOLLOW_concatenation_wrapper_in_standard_function8628_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_wellformed_key_in_standard_function8630_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_wellformed_key_in_standard_function8630( FOLLOW_wellformed_key_in_standard_function8630_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8645_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8645( FOLLOW_RIGHT_PAREN_in_standard_function8645_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function8660_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function8660( FOLLOW_PERIOD_in_standard_function8660_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function8662_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function8662( FOLLOW_general_element_part_in_standard_function8662_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlpi_key_in_standard_function8675_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlpi_key_in_standard_function8675( FOLLOW_xmlpi_key_in_standard_function8675_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8689_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8689( FOLLOW_LEFT_PAREN_in_standard_function8689_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_name_key_in_standard_function8713_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_name_key_in_standard_function8713( FOLLOW_name_key_in_standard_function8713_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_id_in_standard_function8715_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_id_in_standard_function8715( FOLLOW_id_in_standard_function8715_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_evalname_key_in_standard_function8738_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_evalname_key_in_standard_function8738( FOLLOW_evalname_key_in_standard_function8738_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function8740_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function8740( FOLLOW_concatenation_wrapper_in_standard_function8740_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function8777_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function8777( FOLLOW_COMMA_in_standard_function8777_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function8779_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function8779( FOLLOW_concatenation_wrapper_in_standard_function8779_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8795_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8795( FOLLOW_RIGHT_PAREN_in_standard_function8795_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function8810_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function8810( FOLLOW_PERIOD_in_standard_function8810_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function8812_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function8812( FOLLOW_general_element_part_in_standard_function8812_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlquery_key_in_standard_function8825_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlquery_key_in_standard_function8825( FOLLOW_xmlquery_key_in_standard_function8825_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8839_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8839( FOLLOW_LEFT_PAREN_in_standard_function8839_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function8858_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function8858( FOLLOW_concatenation_wrapper_in_standard_function8858_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_passing_clause_in_standard_function8860_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_passing_clause_in_standard_function8860( FOLLOW_xml_passing_clause_in_standard_function8860_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_returning_key_in_standard_function8879_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_returning_key_in_standard_function8879( FOLLOW_returning_key_in_standard_function8879_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_content_key_in_standard_function8881_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0800000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_content_key_in_standard_function8881( FOLLOW_content_key_in_standard_function8881_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_null_key_in_standard_function8884_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_null_key_in_standard_function8884( FOLLOW_null_key_in_standard_function8884_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_on_key_in_standard_function8886_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_on_key_in_standard_function8886( FOLLOW_on_key_in_standard_function8886_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_empty_key_in_standard_function8888_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_empty_key_in_standard_function8888( FOLLOW_empty_key_in_standard_function8888_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8904_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8904( FOLLOW_RIGHT_PAREN_in_standard_function8904_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function8919_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function8919( FOLLOW_PERIOD_in_standard_function8919_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function8921_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function8921( FOLLOW_general_element_part_in_standard_function8921_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlroot_key_in_standard_function8934_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlroot_key_in_standard_function8934( FOLLOW_xmlroot_key_in_standard_function8934_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8948_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8948( FOLLOW_LEFT_PAREN_in_standard_function8948_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function8966_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function8966( FOLLOW_concatenation_wrapper_in_standard_function8966_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlroot_param_version_part_in_standard_function8988_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlroot_param_version_part_in_standard_function8988( FOLLOW_xmlroot_param_version_part_in_standard_function8988_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function9011_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function9011( FOLLOW_COMMA_in_standard_function9011_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlroot_param_standalone_part_in_standard_function9013_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlroot_param_standalone_part_in_standard_function9013( FOLLOW_xmlroot_param_standalone_part_in_standard_function9013_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function9029_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function9029( FOLLOW_RIGHT_PAREN_in_standard_function9029_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function9044_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function9044( FOLLOW_PERIOD_in_standard_function9044_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function9046_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function9046( FOLLOW_general_element_part_in_standard_function9046_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlserialize_key_in_standard_function9059_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlserialize_key_in_standard_function9059( FOLLOW_xmlserialize_key_in_standard_function9059_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function9073_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function9073( FOLLOW_LEFT_PAREN_in_standard_function9073_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_document_key_in_standard_function9092_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_document_key_in_standard_function9092( FOLLOW_document_key_in_standard_function9092_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_content_key_in_standard_function9094_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_content_key_in_standard_function9094( FOLLOW_content_key_in_standard_function9094_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function9113_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000401400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function9113( FOLLOW_concatenation_wrapper_in_standard_function9113_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_standard_function9116_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_as_key_in_standard_function9116( FOLLOW_as_key_in_standard_function9116_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_standard_function9118_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_type_spec_in_standard_function9118( FOLLOW_type_spec_in_standard_function9118_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlserialize_param_enconding_part_in_standard_function9138_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlserialize_param_enconding_part_in_standard_function9138( FOLLOW_xmlserialize_param_enconding_part_in_standard_function9138_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlserialize_param_version_part_in_standard_function9157_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlserialize_param_version_part_in_standard_function9157( FOLLOW_xmlserialize_param_version_part_in_standard_function9157_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlserialize_param_ident_part_in_standard_function9176_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlserialize_param_ident_part_in_standard_function9176( FOLLOW_xmlserialize_param_ident_part_in_standard_function9176_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_hide_key_in_standard_function9197_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_hide_key_in_standard_function9197( FOLLOW_hide_key_in_standard_function9197_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_show_key_in_standard_function9199_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_show_key_in_standard_function9199( FOLLOW_show_key_in_standard_function9199_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_defaults_key_in_standard_function9202_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_defaults_key_in_standard_function9202( FOLLOW_defaults_key_in_standard_function9202_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function9218_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function9218( FOLLOW_RIGHT_PAREN_in_standard_function9218_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function9233_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function9233( FOLLOW_PERIOD_in_standard_function9233_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function9235_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function9235( FOLLOW_general_element_part_in_standard_function9235_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmltable_key_in_standard_function9248_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmltable_key_in_standard_function9248( FOLLOW_xmltable_key_in_standard_function9248_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function9262_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function9262( FOLLOW_LEFT_PAREN_in_standard_function9262_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_namespaces_clause_in_standard_function9280_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_namespaces_clause_in_standard_function9280( FOLLOW_xml_namespaces_clause_in_standard_function9280_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function9299_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function9299( FOLLOW_concatenation_wrapper_in_standard_function9299_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_passing_clause_in_standard_function9317_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_passing_clause_in_standard_function9317( FOLLOW_xml_passing_clause_in_standard_function9317_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_columns_key_in_standard_function9337_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_columns_key_in_standard_function9337( FOLLOW_columns_key_in_standard_function9337_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_table_column_in_standard_function9339_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_table_column_in_standard_function9339( FOLLOW_xml_table_column_in_standard_function9339_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function9342_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function9342( FOLLOW_COMMA_in_standard_function9342_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_table_column_in_standard_function9344_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_table_column_in_standard_function9344( FOLLOW_xml_table_column_in_standard_function9344_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function9361_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function9361( FOLLOW_RIGHT_PAREN_in_standard_function9361_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function9376_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function9376( FOLLOW_PERIOD_in_standard_function9376_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function9378_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function9378( FOLLOW_general_element_part_in_standard_function9378_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_stantard_function_enabling_over9403_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_stantard_function_enabling_over9403( FOLLOW_REGULAR_ID_in_stantard_function_enabling_over9403_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_stantard_function_enabling_using9426_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_stantard_function_enabling_using9426( FOLLOW_REGULAR_ID_in_stantard_function_enabling_using9426_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_stantard_function_enabling_within_or_over9449_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_stantard_function_enabling_within_or_over9449( FOLLOW_REGULAR_ID_in_stantard_function_enabling_within_or_over9449_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_stantard_function_pedictions9472_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_stantard_function_pedictions9472( FOLLOW_REGULAR_ID_in_stantard_function_pedictions9472_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_over_key_in_over_clause9492_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_over_key_in_over_clause9492( FOLLOW_over_key_in_over_clause9492_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_over_clause9502_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_over_clause9502( FOLLOW_LEFT_PAREN_in_over_clause9502_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_query_partition_clause_in_over_clause9516_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_query_partition_clause_in_over_clause9516( FOLLOW_query_partition_clause_in_over_clause9516_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_over_clause9532_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_by_clause_in_over_clause9532( FOLLOW_order_by_clause_in_over_clause9532_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_windowing_clause_in_over_clause9534_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_windowing_clause_in_over_clause9534( FOLLOW_windowing_clause_in_over_clause9534_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_over_clause9547_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_over_clause9547( FOLLOW_RIGHT_PAREN_in_over_clause9547_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_windowing_type_in_windowing_clause9567_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A8A240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_windowing_type_in_windowing_clause9567( FOLLOW_windowing_type_in_windowing_clause9567_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_between_key_in_windowing_clause9578_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A88240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_between_key_in_windowing_clause9578( FOLLOW_between_key_in_windowing_clause9578_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_windowing_elements_in_windowing_clause9580_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_windowing_elements_in_windowing_clause9580( FOLLOW_windowing_elements_in_windowing_clause9580_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_and_key_in_windowing_clause9582_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A88240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_and_key_in_windowing_clause9582( FOLLOW_and_key_in_windowing_clause9582_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_windowing_elements_in_windowing_clause9584_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_windowing_elements_in_windowing_clause9584( FOLLOW_windowing_elements_in_windowing_clause9584_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_windowing_elements_in_windowing_clause9595_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_windowing_elements_in_windowing_clause9595( FOLLOW_windowing_elements_in_windowing_clause9595_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_rows_key_in_windowing_type9620_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_rows_key_in_windowing_type9620( FOLLOW_rows_key_in_windowing_type9620_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_range_key_in_windowing_type9631_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_range_key_in_windowing_type9631( FOLLOW_range_key_in_windowing_type9631_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unbounded_key_in_windowing_elements9651_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unbounded_key_in_windowing_elements9651( FOLLOW_unbounded_key_in_windowing_elements9651_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_preceding_key_in_windowing_elements9653_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_preceding_key_in_windowing_elements9653( FOLLOW_preceding_key_in_windowing_elements9653_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_current_key_in_windowing_elements9664_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_current_key_in_windowing_elements9664( FOLLOW_current_key_in_windowing_elements9664_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_row_key_in_windowing_elements9666_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_row_key_in_windowing_elements9666( FOLLOW_row_key_in_windowing_elements9666_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_windowing_elements9677_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_windowing_elements9677( FOLLOW_concatenation_wrapper_in_windowing_elements9677_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_preceding_key_in_windowing_elements9680_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_preceding_key_in_windowing_elements9680( FOLLOW_preceding_key_in_windowing_elements9680_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_following_key_in_windowing_elements9682_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_following_key_in_windowing_elements9682( FOLLOW_following_key_in_windowing_elements9682_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_using_key_in_using_clause9703_bits[]	= { ANTLR_UINT64_LIT(0x00000086504472A0), ANTLR_UINT64_LIT(0x0C10184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_using_key_in_using_clause9703( FOLLOW_using_key_in_using_clause9703_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_using_clause9714_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_ASTERISK_in_using_clause9714( FOLLOW_ASTERISK_in_using_clause9714_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_using_element_in_using_clause9725_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_using_element_in_using_clause9725( FOLLOW_using_element_in_using_clause9725_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_using_clause9728_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C10184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_using_clause9728( FOLLOW_COMMA_in_using_clause9728_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_using_element_in_using_clause9730_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_using_element_in_using_clause9730( FOLLOW_using_element_in_using_clause9730_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_using_element9759_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_in_key_in_using_element9759( FOLLOW_in_key_in_using_element9759_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_out_key_in_using_element9761_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_out_key_in_using_element9761( FOLLOW_out_key_in_using_element9761_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_out_key_in_using_element9764_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_out_key_in_using_element9764( FOLLOW_out_key_in_using_element9764_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_list_elements_in_using_element9768_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_list_elements_in_using_element9768( FOLLOW_select_list_elements_in_using_element9768_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_using_element9770_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_alias_in_using_element9770( FOLLOW_column_alias_in_using_element9770_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_key_in_collect_order_by_part9791_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_key_in_collect_order_by_part9791( FOLLOW_order_key_in_collect_order_by_part9791_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_collect_order_by_part9793_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_collect_order_by_part9793( FOLLOW_by_key_in_collect_order_by_part9793_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_collect_order_by_part9795_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_collect_order_by_part9795( FOLLOW_concatenation_wrapper_in_collect_order_by_part9795_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_within_key_in_within_or_over_part9815_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0004000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_within_key_in_within_or_over_part9815( FOLLOW_within_key_in_within_or_over_part9815_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_key_in_within_or_over_part9817_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_key_in_within_or_over_part9817( FOLLOW_group_key_in_within_or_over_part9817_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_within_or_over_part9819_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_within_or_over_part9819( FOLLOW_LEFT_PAREN_in_within_or_over_part9819_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_within_or_over_part9821_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_by_clause_in_within_or_over_part9821( FOLLOW_order_by_clause_in_within_or_over_part9821_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_within_or_over_part9823_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_within_or_over_part9823( FOLLOW_RIGHT_PAREN_in_within_or_over_part9823_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_over_clause_in_within_or_over_part9834_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_over_clause_in_within_or_over_part9834( FOLLOW_over_clause_in_within_or_over_part9834_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cost_key_in_cost_matrix_clause9854_bits[]	= { ANTLR_UINT64_LIT(0x0000020040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cost_key_in_cost_matrix_clause9854( FOLLOW_cost_key_in_cost_matrix_clause9854_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_key_in_cost_matrix_clause9865_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_key_in_cost_matrix_clause9865( FOLLOW_model_key_in_cost_matrix_clause9865_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_auto_key_in_cost_matrix_clause9867_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_auto_key_in_cost_matrix_clause9867( FOLLOW_auto_key_in_cost_matrix_clause9867_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_cost_matrix_clause9879_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_cost_matrix_clause9879( FOLLOW_LEFT_PAREN_in_cost_matrix_clause9879_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cost_class_name_in_cost_matrix_clause9881_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cost_class_name_in_cost_matrix_clause9881( FOLLOW_cost_class_name_in_cost_matrix_clause9881_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_cost_matrix_clause9884_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_cost_matrix_clause9884( FOLLOW_COMMA_in_cost_matrix_clause9884_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cost_class_name_in_cost_matrix_clause9886_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cost_class_name_in_cost_matrix_clause9886( FOLLOW_cost_class_name_in_cost_matrix_clause9886_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_cost_matrix_clause9890_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000010000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_cost_matrix_clause9890( FOLLOW_RIGHT_PAREN_in_cost_matrix_clause9890_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_values_key_in_cost_matrix_clause9892_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_values_key_in_cost_matrix_clause9892( FOLLOW_values_key_in_cost_matrix_clause9892_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_cost_matrix_clause9907_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_list_in_cost_matrix_clause9907( FOLLOW_expression_list_in_cost_matrix_clause9907_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_passing_key_in_xml_passing_clause9933_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B0C240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_passing_key_in_xml_passing_clause9933( FOLLOW_passing_key_in_xml_passing_clause9933_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_xml_passing_clause9936_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_xml_passing_clause9936( FOLLOW_by_key_in_xml_passing_clause9936_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_value_key_in_xml_passing_clause9938_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_value_key_in_xml_passing_clause9938( FOLLOW_value_key_in_xml_passing_clause9938_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_xml_passing_clause9954_bits[]	= { ANTLR_UINT64_LIT(0x000000041004B000), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_xml_passing_clause9954( FOLLOW_expression_wrapper_in_xml_passing_clause9954_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_xml_passing_clause9956_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_alias_in_xml_passing_clause9956( FOLLOW_column_alias_in_xml_passing_clause9956_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_xml_passing_clause9960_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_xml_passing_clause9960( FOLLOW_COMMA_in_xml_passing_clause9960_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_xml_passing_clause9962_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_xml_passing_clause9962( FOLLOW_expression_wrapper_in_xml_passing_clause9962_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_xml_passing_clause9964_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_alias_in_xml_passing_clause9964( FOLLOW_column_alias_in_xml_passing_clause9964_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlattributes_key_in_xml_attributes_clause9986_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlattributes_key_in_xml_attributes_clause9986( FOLLOW_xmlattributes_key_in_xml_attributes_clause9986_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_xml_attributes_clause9996_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_xml_attributes_clause9996( FOLLOW_LEFT_PAREN_in_xml_attributes_clause9996_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_entityescaping_key_in_xml_attributes_clause10011_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_entityescaping_key_in_xml_attributes_clause10011( FOLLOW_entityescaping_key_in_xml_attributes_clause10011_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_noentityescaping_key_in_xml_attributes_clause10013_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_noentityescaping_key_in_xml_attributes_clause10013( FOLLOW_noentityescaping_key_in_xml_attributes_clause10013_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_schemacheck_key_in_xml_attributes_clause10030_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_schemacheck_key_in_xml_attributes_clause10030( FOLLOW_schemacheck_key_in_xml_attributes_clause10030_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_noschemacheck_key_in_xml_attributes_clause10032_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_noschemacheck_key_in_xml_attributes_clause10032( FOLLOW_noschemacheck_key_in_xml_attributes_clause10032_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause10048_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause10048( FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause10048_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_xml_attributes_clause10051_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_xml_attributes_clause10051( FOLLOW_COMMA_in_xml_attributes_clause10051_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause10053_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause10053( FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause10053_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_xml_attributes_clause10065_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_xml_attributes_clause10065( FOLLOW_RIGHT_PAREN_in_xml_attributes_clause10065_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlnamespaces_key_in_xml_namespaces_clause10085_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlnamespaces_key_in_xml_namespaces_clause10085( FOLLOW_xmlnamespaces_key_in_xml_namespaces_clause10085_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_xml_namespaces_clause10095_bits[]	= { ANTLR_UINT64_LIT(0x000000865044F220), ANTLR_UINT64_LIT(0x0800184A08241401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_xml_namespaces_clause10095( FOLLOW_LEFT_PAREN_in_xml_namespaces_clause10095_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xml_namespaces_clause10110_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043000), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xml_namespaces_clause10110( FOLLOW_concatenation_wrapper_in_xml_namespaces_clause10110_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_xml_namespaces_clause10112_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000800001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_alias_in_xml_namespaces_clause10112( FOLLOW_column_alias_in_xml_namespaces_clause10112_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_xml_namespaces_clause10133_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_xml_namespaces_clause10133( FOLLOW_COMMA_in_xml_namespaces_clause10133_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xml_namespaces_clause10135_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043000), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xml_namespaces_clause10135( FOLLOW_concatenation_wrapper_in_xml_namespaces_clause10135_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_xml_namespaces_clause10137_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000800001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_alias_in_xml_namespaces_clause10137( FOLLOW_column_alias_in_xml_namespaces_clause10137_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_general_default_part_in_xml_namespaces_clause10159_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_general_default_part_in_xml_namespaces_clause10159( FOLLOW_xml_general_default_part_in_xml_namespaces_clause10159_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_xml_namespaces_clause10171_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_xml_namespaces_clause10171( FOLLOW_RIGHT_PAREN_in_xml_namespaces_clause10171_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_column_name_in_xml_table_column10191_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000400200000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_column_name_in_xml_table_column10191( FOLLOW_xml_column_name_in_xml_table_column10191_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_key_in_xml_table_column10202_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_key_in_xml_table_column10202( FOLLOW_for_key_in_xml_table_column10202_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_ordinality_key_in_xml_table_column10204_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_ordinality_key_in_xml_table_column10204( FOLLOW_ordinality_key_in_xml_table_column10204_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_xml_table_column10215_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000800000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_type_spec_in_xml_table_column10215( FOLLOW_type_spec_in_xml_table_column10215_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_path_key_in_xml_table_column10218_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_path_key_in_xml_table_column10218( FOLLOW_path_key_in_xml_table_column10218_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xml_table_column10220_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000800000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xml_table_column10220( FOLLOW_concatenation_wrapper_in_xml_table_column10220_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_general_default_part_in_xml_table_column10230_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_general_default_part_in_xml_table_column10230( FOLLOW_xml_general_default_part_in_xml_table_column10230_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_default_key_in_xml_general_default_part10258_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_default_key_in_xml_general_default_part10258( FOLLOW_default_key_in_xml_general_default_part10258_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xml_general_default_part10260_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xml_general_default_part10260( FOLLOW_concatenation_wrapper_in_xml_general_default_part10260_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_xml_multiuse_expression_element10280_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000400000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_xml_multiuse_expression_element10280( FOLLOW_expression_in_xml_multiuse_expression_element10280_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_xml_multiuse_expression_element10283_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_as_key_in_xml_multiuse_expression_element10283( FOLLOW_as_key_in_xml_multiuse_expression_element10283_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_xml_multiuse_expression_element10286_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_id_expression_in_xml_multiuse_expression_element10286( FOLLOW_id_expression_in_xml_multiuse_expression_element10286_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_evalname_key_in_xml_multiuse_expression_element10289_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_evalname_key_in_xml_multiuse_expression_element10289( FOLLOW_evalname_key_in_xml_multiuse_expression_element10289_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_xml_multiuse_expression_element10291_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_in_xml_multiuse_expression_element10291( FOLLOW_concatenation_in_xml_multiuse_expression_element10291_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_version_key_in_xmlroot_param_version_part10315_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_version_key_in_xmlroot_param_version_part10315( FOLLOW_version_key_in_xmlroot_param_version_part10315_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_no_key_in_xmlroot_param_version_part10318_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_no_key_in_xmlroot_param_version_part10318( FOLLOW_no_key_in_xmlroot_param_version_part10318_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_value_key_in_xmlroot_param_version_part10320_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_value_key_in_xmlroot_param_version_part10320( FOLLOW_value_key_in_xmlroot_param_version_part10320_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_xmlroot_param_version_part10322_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_xmlroot_param_version_part10322( FOLLOW_expression_wrapper_in_xmlroot_param_version_part10322_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_standalone_key_in_xmlroot_param_standalone_part10343_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_standalone_key_in_xmlroot_param_standalone_part10343( FOLLOW_standalone_key_in_xmlroot_param_standalone_part10343_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_yes_key_in_xmlroot_param_standalone_part10346_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_yes_key_in_xmlroot_param_standalone_part10346( FOLLOW_yes_key_in_xmlroot_param_standalone_part10346_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_no_key_in_xmlroot_param_standalone_part10348_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_no_key_in_xmlroot_param_standalone_part10348( FOLLOW_no_key_in_xmlroot_param_standalone_part10348_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_value_key_in_xmlroot_param_standalone_part10350_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_value_key_in_xmlroot_param_standalone_part10350( FOLLOW_value_key_in_xmlroot_param_standalone_part10350_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_encoding_key_in_xmlserialize_param_enconding_part10372_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_encoding_key_in_xmlserialize_param_enconding_part10372( FOLLOW_encoding_key_in_xmlserialize_param_enconding_part10372_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xmlserialize_param_enconding_part10374_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xmlserialize_param_enconding_part10374( FOLLOW_concatenation_wrapper_in_xmlserialize_param_enconding_part10374_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_version_key_in_xmlserialize_param_version_part10394_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_version_key_in_xmlserialize_param_version_part10394( FOLLOW_version_key_in_xmlserialize_param_version_part10394_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xmlserialize_param_version_part10396_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xmlserialize_param_version_part10396( FOLLOW_concatenation_wrapper_in_xmlserialize_param_version_part10396_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_no_key_in_xmlserialize_param_ident_part10416_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_no_key_in_xmlserialize_param_ident_part10416( FOLLOW_no_key_in_xmlserialize_param_ident_part10416_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_indent_key_in_xmlserialize_param_ident_part10418_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_indent_key_in_xmlserialize_param_ident_part10418( FOLLOW_indent_key_in_xmlserialize_param_ident_part10418_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_indent_key_in_xmlserialize_param_ident_part10429_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000080) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_indent_key_in_xmlserialize_param_ident_part10429( FOLLOW_indent_key_in_xmlserialize_param_ident_part10429_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_size_key_in_xmlserialize_param_ident_part10432_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_size_key_in_xmlserialize_param_ident_part10432( FOLLOW_size_key_in_xmlserialize_param_ident_part10432_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_xmlserialize_param_ident_part10434_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_xmlserialize_param_ident_part10434( FOLLOW_EQUALS_OP_in_xmlserialize_param_ident_part10434_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xmlserialize_param_ident_part10436_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xmlserialize_param_ident_part10436( FOLLOW_concatenation_wrapper_in_xmlserialize_param_ident_part10436_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_key_in_synpred1_PLSQL_DMLParser356_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_key_in_synpred1_PLSQL_DMLParser356( FOLLOW_order_key_in_synpred1_PLSQL_DMLParser356_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_siblings_key_in_synpred1_PLSQL_DMLParser358_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_siblings_key_in_synpred1_PLSQL_DMLParser358( FOLLOW_siblings_key_in_synpred1_PLSQL_DMLParser358_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_synpred1_PLSQL_DMLParser361_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_synpred1_PLSQL_DMLParser361( FOLLOW_by_key_in_synpred1_PLSQL_DMLParser361_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_distinct_key_in_synpred2_PLSQL_DMLParser762_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_distinct_key_in_synpred2_PLSQL_DMLParser762( FOLLOW_distinct_key_in_synpred2_PLSQL_DMLParser762_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unique_key_in_synpred2_PLSQL_DMLParser764_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unique_key_in_synpred2_PLSQL_DMLParser764( FOLLOW_unique_key_in_synpred2_PLSQL_DMLParser764_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_synpred2_PLSQL_DMLParser766_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_synpred2_PLSQL_DMLParser766( FOLLOW_all_key_in_synpred2_PLSQL_DMLParser766_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_synpred3_PLSQL_DMLParser935_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_synpred3_PLSQL_DMLParser935( FOLLOW_tableview_name_in_synpred3_PLSQL_DMLParser935_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred3_PLSQL_DMLParser937_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred3_PLSQL_DMLParser937( FOLLOW_PERIOD_in_synpred3_PLSQL_DMLParser937_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_synpred3_PLSQL_DMLParser939_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_ASTERISK_in_synpred3_PLSQL_DMLParser939( FOLLOW_ASTERISK_in_synpred3_PLSQL_DMLParser939_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred4_PLSQL_DMLParser1046_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred4_PLSQL_DMLParser1046( FOLLOW_LEFT_PAREN_in_synpred4_PLSQL_DMLParser1046_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred4_PLSQL_DMLParser1049_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred4_PLSQL_DMLParser1049( FOLLOW_select_key_in_synpred4_PLSQL_DMLParser1049_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred4_PLSQL_DMLParser1051_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_synpred4_PLSQL_DMLParser1051( FOLLOW_with_key_in_synpred4_PLSQL_DMLParser1051_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred5_PLSQL_DMLParser1076_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred5_PLSQL_DMLParser1076( FOLLOW_LEFT_PAREN_in_synpred5_PLSQL_DMLParser1076_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_only_key_in_synpred6_PLSQL_DMLParser1107_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_only_key_in_synpred6_PLSQL_DMLParser1107( FOLLOW_only_key_in_synpred6_PLSQL_DMLParser1107_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred6_PLSQL_DMLParser1109_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred6_PLSQL_DMLParser1109( FOLLOW_LEFT_PAREN_in_synpred6_PLSQL_DMLParser1109_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred7_PLSQL_DMLParser1423_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred7_PLSQL_DMLParser1423( FOLLOW_LEFT_PAREN_in_synpred7_PLSQL_DMLParser1423_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred7_PLSQL_DMLParser1426_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred7_PLSQL_DMLParser1426( FOLLOW_select_key_in_synpred7_PLSQL_DMLParser1426_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred7_PLSQL_DMLParser1428_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_synpred7_PLSQL_DMLParser1428( FOLLOW_with_key_in_synpred7_PLSQL_DMLParser1428_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred8_PLSQL_DMLParser1450_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred8_PLSQL_DMLParser1450( FOLLOW_LEFT_PAREN_in_synpred8_PLSQL_DMLParser1450_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred9_PLSQL_DMLParser1764_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred9_PLSQL_DMLParser1764( FOLLOW_select_key_in_synpred9_PLSQL_DMLParser1764_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_any_key_in_synpred10_PLSQL_DMLParser1789_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_any_key_in_synpred10_PLSQL_DMLParser1789( FOLLOW_any_key_in_synpred10_PLSQL_DMLParser1789_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred11_PLSQL_DMLParser1905_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred11_PLSQL_DMLParser1905( FOLLOW_LEFT_PAREN_in_synpred11_PLSQL_DMLParser1905_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred12_PLSQL_DMLParser2230_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred12_PLSQL_DMLParser2230( FOLLOW_LEFT_PAREN_in_synpred12_PLSQL_DMLParser2230_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_key_in_synpred13_PLSQL_DMLParser2361_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_key_in_synpred13_PLSQL_DMLParser2361( FOLLOW_group_key_in_synpred13_PLSQL_DMLParser2361_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_synpred14_PLSQL_DMLParser2386_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_synpred14_PLSQL_DMLParser2386( FOLLOW_COMMA_in_synpred14_PLSQL_DMLParser2386_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_by_elements_in_synpred14_PLSQL_DMLParser2388_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_by_elements_in_synpred14_PLSQL_DMLParser2388( FOLLOW_group_by_elements_in_synpred14_PLSQL_DMLParser2388_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_having_key_in_synpred15_PLSQL_DMLParser2422_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_having_key_in_synpred15_PLSQL_DMLParser2422( FOLLOW_having_key_in_synpred15_PLSQL_DMLParser2422_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_synpred16_PLSQL_DMLParser2462_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_synpred16_PLSQL_DMLParser2462( FOLLOW_COMMA_in_synpred16_PLSQL_DMLParser2462_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_by_elements_in_synpred16_PLSQL_DMLParser2464_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_by_elements_in_synpred16_PLSQL_DMLParser2464( FOLLOW_group_by_elements_in_synpred16_PLSQL_DMLParser2464_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_rollup_key_in_synpred17_PLSQL_DMLParser2620_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_rollup_key_in_synpred17_PLSQL_DMLParser2620( FOLLOW_rollup_key_in_synpred17_PLSQL_DMLParser2620_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cube_key_in_synpred17_PLSQL_DMLParser2622_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cube_key_in_synpred17_PLSQL_DMLParser2622( FOLLOW_cube_key_in_synpred17_PLSQL_DMLParser2622_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred18_PLSQL_DMLParser2638_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred18_PLSQL_DMLParser2638( FOLLOW_LEFT_PAREN_in_synpred18_PLSQL_DMLParser2638_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_synpred19_PLSQL_DMLParser3096_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_synpred19_PLSQL_DMLParser3096( FOLLOW_all_key_in_synpred19_PLSQL_DMLParser3096_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_synpred20_PLSQL_DMLParser4047_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_when_key_in_synpred20_PLSQL_DMLParser4047( FOLLOW_when_key_in_synpred20_PLSQL_DMLParser4047_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_matched_key_in_synpred20_PLSQL_DMLParser4049_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_matched_key_in_synpred20_PLSQL_DMLParser4049( FOLLOW_matched_key_in_synpred20_PLSQL_DMLParser4049_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_synpred21_PLSQL_DMLParser4082_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0400000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_when_key_in_synpred21_PLSQL_DMLParser4082( FOLLOW_when_key_in_synpred21_PLSQL_DMLParser4082_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_not_key_in_synpred21_PLSQL_DMLParser4084_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_not_key_in_synpred21_PLSQL_DMLParser4084( FOLLOW_not_key_in_synpred21_PLSQL_DMLParser4084_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_matched_key_in_synpred21_PLSQL_DMLParser4086_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_matched_key_in_synpred21_PLSQL_DMLParser4086( FOLLOW_matched_key_in_synpred21_PLSQL_DMLParser4086_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred22_PLSQL_DMLParser4675_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred22_PLSQL_DMLParser4675( FOLLOW_LEFT_PAREN_in_synpred22_PLSQL_DMLParser4675_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unlimited_key_in_synpred23_PLSQL_DMLParser4740_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unlimited_key_in_synpred23_PLSQL_DMLParser4740( FOLLOW_unlimited_key_in_synpred23_PLSQL_DMLParser4740_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred24_PLSQL_DMLParser4839_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred24_PLSQL_DMLParser4839( FOLLOW_LEFT_PAREN_in_synpred24_PLSQL_DMLParser4839_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred24_PLSQL_DMLParser4842_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred24_PLSQL_DMLParser4842( FOLLOW_select_key_in_synpred24_PLSQL_DMLParser4842_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred24_PLSQL_DMLParser4846_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_synpred24_PLSQL_DMLParser4846( FOLLOW_with_key_in_synpred24_PLSQL_DMLParser4846_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_key_in_synpred25_PLSQL_DMLParser5149_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cursor_key_in_synpred25_PLSQL_DMLParser5149( FOLLOW_cursor_key_in_synpred25_PLSQL_DMLParser5149_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred25_PLSQL_DMLParser5151_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred25_PLSQL_DMLParser5151( FOLLOW_LEFT_PAREN_in_synpred25_PLSQL_DMLParser5151_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred25_PLSQL_DMLParser5154_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred25_PLSQL_DMLParser5154( FOLLOW_select_key_in_synpred25_PLSQL_DMLParser5154_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred25_PLSQL_DMLParser5156_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_synpred25_PLSQL_DMLParser5156( FOLLOW_with_key_in_synpred25_PLSQL_DMLParser5156_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred26_PLSQL_DMLParser5766_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred26_PLSQL_DMLParser5766( FOLLOW_LEFT_PAREN_in_synpred26_PLSQL_DMLParser5766_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred26_PLSQL_DMLParser5770_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred26_PLSQL_DMLParser5770( FOLLOW_select_key_in_synpred26_PLSQL_DMLParser5770_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred26_PLSQL_DMLParser5772_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_synpred26_PLSQL_DMLParser5772( FOLLOW_with_key_in_synpred26_PLSQL_DMLParser5772_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_interval_expression_in_synpred27_PLSQL_DMLParser6033_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_interval_expression_in_synpred27_PLSQL_DMLParser6033( FOLLOW_interval_expression_in_synpred27_PLSQL_DMLParser6033_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_any_key_in_synpred28_PLSQL_DMLParser6172_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_any_key_in_synpred28_PLSQL_DMLParser6172( FOLLOW_any_key_in_synpred28_PLSQL_DMLParser6172_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_any_key_in_synpred29_PLSQL_DMLParser6186_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_any_key_in_synpred29_PLSQL_DMLParser6186( FOLLOW_any_key_in_synpred29_PLSQL_DMLParser6186_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred30_PLSQL_DMLParser6431_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred30_PLSQL_DMLParser6431( FOLLOW_select_key_in_synpred30_PLSQL_DMLParser6431_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred31_PLSQL_DMLParser6455_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred31_PLSQL_DMLParser6455( FOLLOW_LEFT_PAREN_in_synpred31_PLSQL_DMLParser6455_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_new_key_in_synpred36_PLSQL_DMLParser6601_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_new_key_in_synpred36_PLSQL_DMLParser6601( FOLLOW_new_key_in_synpred36_PLSQL_DMLParser6601_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_synpred36_PLSQL_DMLParser6603_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_synpred36_PLSQL_DMLParser6603( FOLLOW_unary_expression_in_synpred36_PLSQL_DMLParser6603_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_synpred38_PLSQL_DMLParser6627_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_synpred38_PLSQL_DMLParser6627( FOLLOW_all_key_in_synpred38_PLSQL_DMLParser6627_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_synpred38_PLSQL_DMLParser6629_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_synpred38_PLSQL_DMLParser6629( FOLLOW_unary_expression_in_synpred38_PLSQL_DMLParser6629_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_case_statement_in_synpred39_PLSQL_DMLParser6642_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_case_statement_in_synpred39_PLSQL_DMLParser6642( FOLLOW_case_statement_in_synpred39_PLSQL_DMLParser6642_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_quantified_expression_in_synpred40_PLSQL_DMLParser6654_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_quantified_expression_in_synpred40_PLSQL_DMLParser6654( FOLLOW_quantified_expression_in_synpred40_PLSQL_DMLParser6654_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_standard_function_in_synpred41_PLSQL_DMLParser6665_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_standard_function_in_synpred41_PLSQL_DMLParser6665( FOLLOW_standard_function_in_synpred41_PLSQL_DMLParser6665_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_label_name_in_synpred42_PLSQL_DMLParser6714_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000008000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_label_name_in_synpred42_PLSQL_DMLParser6714( FOLLOW_label_name_in_synpred42_PLSQL_DMLParser6714_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_case_key_in_synpred42_PLSQL_DMLParser6717_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_case_key_in_synpred42_PLSQL_DMLParser6717( FOLLOW_case_key_in_synpred42_PLSQL_DMLParser6717_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_synpred42_PLSQL_DMLParser6719_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_when_key_in_synpred42_PLSQL_DMLParser6719( FOLLOW_when_key_in_synpred42_PLSQL_DMLParser6719_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_element_in_synpred43_PLSQL_DMLParser6994_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_element_in_synpred43_PLSQL_DMLParser6994( FOLLOW_table_element_in_synpred43_PLSQL_DMLParser6994_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_outer_join_sign_in_synpred43_PLSQL_DMLParser6996_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_outer_join_sign_in_synpred43_PLSQL_DMLParser6996( FOLLOW_outer_join_sign_in_synpred43_PLSQL_DMLParser6996_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_constant_in_synpred45_PLSQL_DMLParser7025_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_constant_in_synpred45_PLSQL_DMLParser7025( FOLLOW_constant_in_synpred45_PLSQL_DMLParser7025_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_in_synpred46_PLSQL_DMLParser7036_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_in_synpred46_PLSQL_DMLParser7036( FOLLOW_general_element_in_synpred46_PLSQL_DMLParser7036_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred47_PLSQL_DMLParser7076_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred47_PLSQL_DMLParser7076( FOLLOW_select_key_in_synpred47_PLSQL_DMLParser7076_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred47_PLSQL_DMLParser7080_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_synpred47_PLSQL_DMLParser7080( FOLLOW_with_key_in_synpred47_PLSQL_DMLParser7080_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred48_PLSQL_DMLParser7224_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred48_PLSQL_DMLParser7224( FOLLOW_LEFT_PAREN_in_synpred48_PLSQL_DMLParser7224_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred48_PLSQL_DMLParser7227_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred48_PLSQL_DMLParser7227( FOLLOW_select_key_in_synpred48_PLSQL_DMLParser7227_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred48_PLSQL_DMLParser7229_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_synpred48_PLSQL_DMLParser7229( FOLLOW_with_key_in_synpred48_PLSQL_DMLParser7229_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multiset_key_in_synpred49_PLSQL_DMLParser7431_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multiset_key_in_synpred49_PLSQL_DMLParser7431( FOLLOW_multiset_key_in_synpred49_PLSQL_DMLParser7431_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred49_PLSQL_DMLParser7433_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred49_PLSQL_DMLParser7433( FOLLOW_LEFT_PAREN_in_synpred49_PLSQL_DMLParser7433_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred49_PLSQL_DMLParser7437_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred49_PLSQL_DMLParser7437( FOLLOW_select_key_in_synpred49_PLSQL_DMLParser7437_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred49_PLSQL_DMLParser7439_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_synpred49_PLSQL_DMLParser7439( FOLLOW_with_key_in_synpred49_PLSQL_DMLParser7439_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_default_key_in_synpred50_PLSQL_DMLParser10155_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_default_key_in_synpred50_PLSQL_DMLParser10155( FOLLOW_default_key_in_synpred50_PLSQL_DMLParser10155_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_default_key_in_synpred51_PLSQL_DMLParser10226_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_default_key_in_synpred51_PLSQL_DMLParser10226( FOLLOW_default_key_in_synpred51_PLSQL_DMLParser10226_bits, 1 );



/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    85:70: ( nulls_key last_key )?
 */
static const ANTLR_INT32 dfa18_eot[34] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa18_eof[34] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa18_min[34] =
    {
	15, 18, -1, 15, -1, 18, 18, 18, 15, 18, 15, 18, -1, 18, 18, 18, 18, 18, 
	18, 15, 18, 15, 18, 15, 18, 18, 18, 18, 18, 18, 15, 18, 18, 18
    };
static const ANTLR_INT32 dfa18_max[34] =
    {
	74, 74, -1, 134, -1, 74, 74, 74, 101, 74, 134, 74, -1, 74, 74, 74, 74, 
	74, 74, 134, 74, 139, 74, 86, 74, 74, 74, 74, 74, 74, 139, 74, 74, 74
    };
static const ANTLR_INT32 dfa18_accept[34] =
    {
	-1, -1, 2, -1, 2, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa18_special[34] =
    {
	25, 24, -1, 15, -1, 23, 21, 4, 16, 3, 26, 9, -1, 10, 22, 17, 0, 13, 14, 
	18, 5, 1, 6, 2, 30, 29, 8, 20, 7, 12, 19, 11, 28, 27
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa18_T_empty	 =   NULL;

static const ANTLR_INT32 dfa18_T0[] =
    {
	23, -1, -1, -1, -1, -1, -1, -1, -1, -1, 22, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 23
    };

static const ANTLR_INT32 dfa18_T1[] =
    {
	12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa18_T2[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, -1, -1, 
	-1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12
    };

static const ANTLR_INT32 dfa18_T3[] =
    {
	13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 13
    };

static const ANTLR_INT32 dfa18_T4[] =
    {
	11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 11
    };

static const ANTLR_INT32 dfa18_T5[] =
    {
	26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 26
    };

static const ANTLR_INT32 dfa18_T6[] =
    {
	28, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 28
    };

static const ANTLR_INT32 dfa18_T7[] =
    {
	23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 23
    };

static const ANTLR_INT32 dfa18_T8[] =
    {
	21, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 21
    };

static const ANTLR_INT32 dfa18_T9[] =
    {
	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 8
    };

static const ANTLR_INT32 dfa18_T10[] =
    {
	10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 10
    };

static const ANTLR_INT32 dfa18_T11[] =
    {
	33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 33
    };

static const ANTLR_INT32 dfa18_T12[] =
    {
	32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 32
    };

static const ANTLR_INT32 dfa18_T13[] =
    {
	24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 24
    };

static const ANTLR_INT32 dfa18_T14[] =
    {
	25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 25
    };

static const ANTLR_INT32 dfa18_T15[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, 
	-1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa18_T16[] =
    {
	12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, 
	-1, -1, -1, -1, -1, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 
	12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12
    };

static const ANTLR_INT32 dfa18_T17[] =
    {
	21, -1, -1, -1, -1, -1, -1, -1, -1, -1, 20, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 21
    };

static const ANTLR_INT32 dfa18_T18[] =
    {
	16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, -1, -1, 
	-1, -1, -1, -1, -1, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12
    };

static const ANTLR_INT32 dfa18_T19[] =
    {
	30, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 30
    };

static const ANTLR_INT32 dfa18_T20[] =
    {
	10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 10
    };

static const ANTLR_INT32 dfa18_T21[] =
    {
	19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 19
    };

static const ANTLR_INT32 dfa18_T22[] =
    {
	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 8
    };

static const ANTLR_INT32 dfa18_T23[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 3
    };

static const ANTLR_INT32 dfa18_T24[] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa18_transitions[] =
{
    dfa18_T24, dfa18_T23, NULL, dfa18_T15, NULL, dfa18_T22, dfa18_T20, dfa18_T4, 
    dfa18_T16, dfa18_T3, dfa18_T18, dfa18_T9, NULL, dfa18_T10, dfa18_T21, 
    dfa18_T17, dfa18_T0, dfa18_T13, dfa18_T14, dfa18_T18, dfa18_T5, dfa18_T1, 
    dfa18_T6, dfa18_T2, dfa18_T9, dfa18_T10, dfa18_T8, dfa18_T19, dfa18_T7, 
    dfa18_T12, dfa18_T1, dfa18_T11, dfa18_T8, dfa18_T7
};


/* Declare tracking structure for Cyclic DFA 18
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA18 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA18( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA18_16;

	    		    ANTLR_MARKER index18_16;


	    		    LA18_16 = ctx->LA(1);

	    		     
	    		        index18_16 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_16 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 22;
	    		    }

	    		    else if ( (LA18_16 == DELIMITED_ID || LA18_16 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 23;
	    		    }

	    			 
	    				ctx->seek(index18_16);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA18_21;

	    		    ANTLR_MARKER index18_21;


	    		    LA18_21 = ctx->LA(1);

	    		     
	    		        index18_21 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_21 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 27;
	    		    }

	    		    else if ( (LA18_21 == COMMA || LA18_21 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA18_21 == SQL92_RESERVED_TO) && ((equalsIgnoreCase(LT(1)->getText(), "SET"))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_21);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA18_23;

	    		    ANTLR_MARKER index18_23;


	    		    LA18_23 = ctx->LA(1);

	    		     
	    		        index18_23 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_23 == LEFT_PAREN || LA18_23 == SQL92_RESERVED_AS) && ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA18_23 == COMMA || LA18_23 == PERIOD || LA18_23 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "SET"))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_23);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA18_9;

	    		    ANTLR_MARKER index18_9;


	    		    LA18_9 = ctx->LA(1);

	    		     
	    		        index18_9 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_9 == DELIMITED_ID || LA18_9 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 13;
	    		    }

	    			 
	    				ctx->seek(index18_9);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA18_7;

	    		    ANTLR_MARKER index18_7;


	    		    LA18_7 = ctx->LA(1);

	    		     
	    		        index18_7 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_7 == DELIMITED_ID || LA18_7 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 11;
	    		    }

	    			 
	    				ctx->seek(index18_7);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA18_20;

	    		    ANTLR_MARKER index18_20;


	    		    LA18_20 = ctx->LA(1);

	    		     
	    		        index18_20 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_20 == DELIMITED_ID || LA18_20 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 26;
	    		    }

	    			 
	    				ctx->seek(index18_20);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA18_22;

	    		    ANTLR_MARKER index18_22;


	    		    LA18_22 = ctx->LA(1);

	    		     
	    		        index18_22 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_22 == DELIMITED_ID || LA18_22 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 28;
	    		    }

	    			 
	    				ctx->seek(index18_22);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 7:

	    		{
	    		    ANTLR_UINT32 LA18_28;

	    		    ANTLR_MARKER index18_28;


	    		    LA18_28 = ctx->LA(1);

	    		     
	    		        index18_28 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_28 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 31;
	    		    }

	    		    else if ( (LA18_28 == DELIMITED_ID || LA18_28 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 23;
	    		    }

	    			 
	    				ctx->seek(index18_28);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 8:

	    		{
	    		    ANTLR_UINT32 LA18_26;

	    		    ANTLR_MARKER index18_26;


	    		    LA18_26 = ctx->LA(1);

	    		     
	    		        index18_26 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_26 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 29;
	    		    }

	    		    else if ( (LA18_26 == DELIMITED_ID || LA18_26 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 21;
	    		    }

	    			 
	    				ctx->seek(index18_26);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 9:

	    		{
	    		    ANTLR_UINT32 LA18_11;

	    		    ANTLR_MARKER index18_11;


	    		    LA18_11 = ctx->LA(1);

	    		     
	    		        index18_11 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_11 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 17;
	    		    }

	    		    else if ( (LA18_11 == DELIMITED_ID || LA18_11 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index18_11);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 10:

	    		{
	    		    ANTLR_UINT32 LA18_13;

	    		    ANTLR_MARKER index18_13;


	    		    LA18_13 = ctx->LA(1);

	    		     
	    		        index18_13 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_13 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( (LA18_13 == DELIMITED_ID || LA18_13 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index18_13);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 11:

	    		{
	    		    ANTLR_UINT32 LA18_31;

	    		    ANTLR_MARKER index18_31;


	    		    LA18_31 = ctx->LA(1);

	    		     
	    		        index18_31 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_31 == DELIMITED_ID || LA18_31 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 33;
	    		    }

	    			 
	    				ctx->seek(index18_31);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 12:

	    		{
	    		    ANTLR_UINT32 LA18_29;

	    		    ANTLR_MARKER index18_29;


	    		    LA18_29 = ctx->LA(1);

	    		     
	    		        index18_29 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_29 == DELIMITED_ID || LA18_29 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 32;
	    		    }

	    			 
	    				ctx->seek(index18_29);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 13:

	    		{
	    		    ANTLR_UINT32 LA18_17;

	    		    ANTLR_MARKER index18_17;


	    		    LA18_17 = ctx->LA(1);

	    		     
	    		        index18_17 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_17 == DELIMITED_ID || LA18_17 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 24;
	    		    }

	    			 
	    				ctx->seek(index18_17);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 14:

	    		{
	    		    ANTLR_UINT32 LA18_18;

	    		    ANTLR_MARKER index18_18;


	    		    LA18_18 = ctx->LA(1);

	    		     
	    		        index18_18 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_18 == DELIMITED_ID || LA18_18 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 25;
	    		    }

	    			 
	    				ctx->seek(index18_18);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 15:

	    		{
	    		    ANTLR_UINT32 LA18_3;

	    		    ANTLR_MARKER index18_3;


	    		    LA18_3 = ctx->LA(1);

	    		     
	    		        index18_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_3 == COMMA) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( (LA18_3 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA18_3 == LEFT_PAREN || LA18_3 == PERIOD || LA18_3 == SQL92_RESERVED_SELECT) && ((equalsIgnoreCase(LT(1)->getText(), "SET"))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 16:

	    		{
	    		    ANTLR_UINT32 LA18_8;

	    		    ANTLR_MARKER index18_8;


	    		    LA18_8 = ctx->LA(1);

	    		     
	    		        index18_8 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_8 == COMMA || LA18_8 == PERIOD || LA18_8 == REGULAR_ID || LA18_8 == SQL92_RESERVED_ASC || LA18_8 == SQL92_RESERVED_DESC) && ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA18_8 == LEFT_PAREN || LA18_8 == SQL92_RESERVED_AS) && ((equalsIgnoreCase(LT(1)->getText(), "SET"))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_8);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 17:

	    		{
	    		    ANTLR_UINT32 LA18_15;

	    		    ANTLR_MARKER index18_15;


	    		    LA18_15 = ctx->LA(1);

	    		     
	    		        index18_15 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_15 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 20;
	    		    }

	    		    else if ( (LA18_15 == DELIMITED_ID || LA18_15 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 21;
	    		    }

	    			 
	    				ctx->seek(index18_15);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 18:

	    		{
	    		    ANTLR_UINT32 LA18_19;

	    		    ANTLR_MARKER index18_19;


	    		    LA18_19 = ctx->LA(1);

	    		     
	    		        index18_19 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_19 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA18_19 == COMMA) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 16;
	    		    }

	    		    else if ( (LA18_19 == LEFT_PAREN || LA18_19 == SQL92_RESERVED_SELECT) && ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA18_19 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 14;
	    		    }

	    			 
	    				ctx->seek(index18_19);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 19:

	    		{
	    		    ANTLR_UINT32 LA18_30;

	    		    ANTLR_MARKER index18_30;


	    		    LA18_30 = ctx->LA(1);

	    		     
	    		        index18_30 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_30 == COMMA || LA18_30 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA18_30 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 27;
	    		    }

	    		    else if ( (LA18_30 == SQL92_RESERVED_TO) && ((equalsIgnoreCase(LT(1)->getText(), "SET"))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_30);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 20:

	    		{
	    		    ANTLR_UINT32 LA18_27;

	    		    ANTLR_MARKER index18_27;


	    		    LA18_27 = ctx->LA(1);

	    		     
	    		        index18_27 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_27 == DELIMITED_ID || LA18_27 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 30;
	    		    }

	    			 
	    				ctx->seek(index18_27);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 21:

	    		{
	    		    ANTLR_UINT32 LA18_6;

	    		    ANTLR_MARKER index18_6;


	    		    LA18_6 = ctx->LA(1);

	    		     
	    		        index18_6 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_6 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA18_6 == DELIMITED_ID || LA18_6 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index18_6);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 22:

	    		{
	    		    ANTLR_UINT32 LA18_14;

	    		    ANTLR_MARKER index18_14;


	    		    LA18_14 = ctx->LA(1);

	    		     
	    		        index18_14 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_14 == DELIMITED_ID || LA18_14 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 19;
	    		    }

	    			 
	    				ctx->seek(index18_14);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 23:

	    		{
	    		    ANTLR_UINT32 LA18_5;

	    		    ANTLR_MARKER index18_5;


	    		    LA18_5 = ctx->LA(1);

	    		     
	    		        index18_5 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_5 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( (LA18_5 == DELIMITED_ID || LA18_5 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index18_5);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 24:

	    		{
	    		    ANTLR_UINT32 LA18_1;

	    		    ANTLR_MARKER index18_1;


	    		    LA18_1 = ctx->LA(1);

	    		     
	    		        index18_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA18_1 == DELIMITED_ID || LA18_1 == INTRODUCER) && ((equalsIgnoreCase(LT(1)->getText(), "SET"))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 25:

	    		{
	    		    ANTLR_UINT32 LA18_0;

	    		    ANTLR_MARKER index18_0;


	    		    LA18_0 = ctx->LA(1);

	    		     
	    		        index18_0 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 1;
	    		    }

	    		    else if ( (LA18_0 == COMMA)  )
	    		    {
	    		        s = 2;
	    		    }

	    			 
	    				ctx->seek(index18_0);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 26:

	    		{
	    		    ANTLR_UINT32 LA18_10;

	    		    ANTLR_MARKER index18_10;


	    		    LA18_10 = ctx->LA(1);

	    		     
	    		        index18_10 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_10 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 14;
	    		    }

	    		    else if ( (LA18_10 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA18_10 == COMMA) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 16;
	    		    }

	    		    else if ( (LA18_10 == LEFT_PAREN || LA18_10 == SQL92_RESERVED_SELECT) && ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) )
	    		    {
	    		        s = 12;
	    		    }

	    			 
	    				ctx->seek(index18_10);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 27:

	    		{
	    		    ANTLR_UINT32 LA18_33;

	    		    ANTLR_MARKER index18_33;


	    		    LA18_33 = ctx->LA(1);

	    		     
	    		        index18_33 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_33 == DELIMITED_ID || LA18_33 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 23;
	    		    }

	    		    else if ( (LA18_33 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 31;
	    		    }

	    			 
	    				ctx->seek(index18_33);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 28:

	    		{
	    		    ANTLR_UINT32 LA18_32;

	    		    ANTLR_MARKER index18_32;


	    		    LA18_32 = ctx->LA(1);

	    		     
	    		        index18_32 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_32 == DELIMITED_ID || LA18_32 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 21;
	    		    }

	    		    else if ( (LA18_32 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 29;
	    		    }

	    			 
	    				ctx->seek(index18_32);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 29:

	    		{
	    		    ANTLR_UINT32 LA18_25;

	    		    ANTLR_MARKER index18_25;


	    		    LA18_25 = ctx->LA(1);

	    		     
	    		        index18_25 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_25 == DELIMITED_ID || LA18_25 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA18_25 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 18;
	    		    }

	    			 
	    				ctx->seek(index18_25);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 30:

	    		{
	    		    ANTLR_UINT32 LA18_24;

	    		    ANTLR_MARKER index18_24;


	    		    LA18_24 = ctx->LA(1);

	    		     
	    		        index18_24 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA18_24 == DELIMITED_ID || LA18_24 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA18_24 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 17;
	    		    }

	    			 
	    				ctx->seek(index18_24);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "85:70: ( nulls_key last_key )?" );
	    ex->set_decisionNum( 18 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParser_PLSQL_DMLParserCyclicDFA18  cdfa18(
	    18,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"85:70: ( nulls_key last_key )?",
	    dfa18_eot,	    /* EOT table			    */
	    dfa18_eof,	    /* EOF table			    */
	    dfa18_min,	    /* Minimum tokens for each state    */
	    dfa18_max,	    /* Maximum tokens for each state    */
	    dfa18_accept,	/* Accept table			    */
	    dfa18_special,	/* Special transition states	    */
	    dfa18_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 18
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    86:77: ( nulls_key last_key )?
 */
static const ANTLR_INT32 dfa22_eot[34] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa22_eof[34] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa22_min[34] =
    {
	15, 18, -1, 15, -1, 18, 18, 18, 15, 18, 15, 18, 18, 18, 18, -1, 18, 18, 
	15, 18, 15, 18, 15, 18, 18, 18, 18, 18, 18, 18, 15, 18, 18, 18
    };
static const ANTLR_INT32 dfa22_max[34] =
    {
	74, 74, -1, 134, -1, 74, 74, 74, 134, 74, 101, 74, 74, 74, 74, -1, 74, 
	74, 134, 74, 139, 74, 86, 74, 74, 74, 74, 74, 74, 74, 139, 74, 74, 74
    };
static const ANTLR_INT32 dfa22_accept[34] =
    {
	-1, -1, 2, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa22_special[34] =
    {
	7, 13, -1, 8, -1, 24, 25, 4, 26, 3, 18, 11, 23, 19, 0, -1, 12, 16, 20, 
	5, 1, 6, 2, 17, 30, 10, 22, 9, 29, 15, 21, 14, 28, 27
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa22_T_empty	 =   NULL;

static const ANTLR_INT32 dfa22_T0[] =
    {
	22, -1, -1, -1, -1, -1, -1, -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 22
    };

static const ANTLR_INT32 dfa22_T1[] =
    {
	15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa22_T2[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, 
	-1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15
    };

static const ANTLR_INT32 dfa22_T3[] =
    {
	16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 16
    };

static const ANTLR_INT32 dfa22_T4[] =
    {
	11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 11
    };

static const ANTLR_INT32 dfa22_T5[] =
    {
	25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 25
    };

static const ANTLR_INT32 dfa22_T6[] =
    {
	27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 27
    };

static const ANTLR_INT32 dfa22_T7[] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 1
    };

static const ANTLR_INT32 dfa22_T8[] =
    {
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, 
	-1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa22_T9[] =
    {
	22, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 22
    };

static const ANTLR_INT32 dfa22_T10[] =
    {
	20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 20
    };

static const ANTLR_INT32 dfa22_T11[] =
    {
	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 8
    };

static const ANTLR_INT32 dfa22_T12[] =
    {
	10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 10
    };

static const ANTLR_INT32 dfa22_T13[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 3
    };

static const ANTLR_INT32 dfa22_T14[] =
    {
	33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 33
    };

static const ANTLR_INT32 dfa22_T15[] =
    {
	32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 32
    };

static const ANTLR_INT32 dfa22_T16[] =
    {
	24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 24
    };

static const ANTLR_INT32 dfa22_T17[] =
    {
	28, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 28
    };

static const ANTLR_INT32 dfa22_T18[] =
    {
	15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, 
	-1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 
	15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15
    };

static const ANTLR_INT32 dfa22_T19[] =
    {
	20, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 20
    };

static const ANTLR_INT32 dfa22_T20[] =
    {
	14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, 
	-1, -1, -1, -1, -1, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15
    };

static const ANTLR_INT32 dfa22_T21[] =
    {
	30, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 30
    };

static const ANTLR_INT32 dfa22_T22[] =
    {
	18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 18
    };

static const ANTLR_INT32 dfa22_T23[] =
    {
	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 8
    };

static const ANTLR_INT32 dfa22_T24[] =
    {
	10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 10
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa22_transitions[] =
{
    dfa22_T7, dfa22_T13, NULL, dfa22_T8, NULL, dfa22_T23, dfa22_T24, dfa22_T4, 
    dfa22_T20, dfa22_T3, dfa22_T18, dfa22_T11, dfa22_T22, dfa22_T19, dfa22_T0, 
    NULL, dfa22_T12, dfa22_T16, dfa22_T20, dfa22_T5, dfa22_T1, dfa22_T6, 
    dfa22_T2, dfa22_T17, dfa22_T11, dfa22_T10, dfa22_T21, dfa22_T9, dfa22_T12, 
    dfa22_T15, dfa22_T1, dfa22_T14, dfa22_T10, dfa22_T9
};


/* Declare tracking structure for Cyclic DFA 22
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA22 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA22( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA22_14;

	    		    ANTLR_MARKER index22_14;


	    		    LA22_14 = ctx->LA(1);

	    		     
	    		        index22_14 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_14 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 21;
	    		    }

	    		    else if ( (LA22_14 == DELIMITED_ID || LA22_14 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 22;
	    		    }

	    			 
	    				ctx->seek(index22_14);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA22_20;

	    		    ANTLR_MARKER index22_20;


	    		    LA22_20 = ctx->LA(1);

	    		     
	    		        index22_20 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_20 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 26;
	    		    }

	    		    else if ( (LA22_20 == COMMA || LA22_20 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA22_20 == SQL92_RESERVED_TO) && ((equalsIgnoreCase(LT(1)->getText(), "SET"))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_20);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA22_22;

	    		    ANTLR_MARKER index22_22;


	    		    LA22_22 = ctx->LA(1);

	    		     
	    		        index22_22 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_22 == LEFT_PAREN || LA22_22 == SQL92_RESERVED_AS) && ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA22_22 == COMMA || LA22_22 == PERIOD || LA22_22 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "SET"))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_22);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA22_9;

	    		    ANTLR_MARKER index22_9;


	    		    LA22_9 = ctx->LA(1);

	    		     
	    		        index22_9 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_9 == DELIMITED_ID || LA22_9 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 16;
	    		    }

	    			 
	    				ctx->seek(index22_9);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA22_7;

	    		    ANTLR_MARKER index22_7;


	    		    LA22_7 = ctx->LA(1);

	    		     
	    		        index22_7 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_7 == DELIMITED_ID || LA22_7 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 11;
	    		    }

	    			 
	    				ctx->seek(index22_7);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA22_19;

	    		    ANTLR_MARKER index22_19;


	    		    LA22_19 = ctx->LA(1);

	    		     
	    		        index22_19 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_19 == DELIMITED_ID || LA22_19 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 25;
	    		    }

	    			 
	    				ctx->seek(index22_19);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA22_21;

	    		    ANTLR_MARKER index22_21;


	    		    LA22_21 = ctx->LA(1);

	    		     
	    		        index22_21 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_21 == DELIMITED_ID || LA22_21 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 27;
	    		    }

	    			 
	    				ctx->seek(index22_21);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 7:

	    		{
	    		    ANTLR_UINT32 LA22_0;

	    		    ANTLR_MARKER index22_0;


	    		    LA22_0 = ctx->LA(1);

	    		     
	    		        index22_0 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 1;
	    		    }

	    		    else if ( (LA22_0 == COMMA)  )
	    		    {
	    		        s = 2;
	    		    }

	    			 
	    				ctx->seek(index22_0);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 8:

	    		{
	    		    ANTLR_UINT32 LA22_3;

	    		    ANTLR_MARKER index22_3;


	    		    LA22_3 = ctx->LA(1);

	    		     
	    		        index22_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_3 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( (LA22_3 == COMMA) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA22_3 == LEFT_PAREN || LA22_3 == PERIOD || LA22_3 == SQL92_RESERVED_SELECT) && ((equalsIgnoreCase(LT(1)->getText(), "SET"))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 9:

	    		{
	    		    ANTLR_UINT32 LA22_27;

	    		    ANTLR_MARKER index22_27;


	    		    LA22_27 = ctx->LA(1);

	    		     
	    		        index22_27 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_27 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 31;
	    		    }

	    		    else if ( (LA22_27 == DELIMITED_ID || LA22_27 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 22;
	    		    }

	    			 
	    				ctx->seek(index22_27);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 10:

	    		{
	    		    ANTLR_UINT32 LA22_25;

	    		    ANTLR_MARKER index22_25;


	    		    LA22_25 = ctx->LA(1);

	    		     
	    		        index22_25 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_25 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 29;
	    		    }

	    		    else if ( (LA22_25 == DELIMITED_ID || LA22_25 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 20;
	    		    }

	    			 
	    				ctx->seek(index22_25);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 11:

	    		{
	    		    ANTLR_UINT32 LA22_11;

	    		    ANTLR_MARKER index22_11;


	    		    LA22_11 = ctx->LA(1);

	    		     
	    		        index22_11 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_11 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 17;
	    		    }

	    		    else if ( (LA22_11 == DELIMITED_ID || LA22_11 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index22_11);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 12:

	    		{
	    		    ANTLR_UINT32 LA22_16;

	    		    ANTLR_MARKER index22_16;


	    		    LA22_16 = ctx->LA(1);

	    		     
	    		        index22_16 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_16 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 23;
	    		    }

	    		    else if ( (LA22_16 == DELIMITED_ID || LA22_16 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index22_16);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 13:

	    		{
	    		    ANTLR_UINT32 LA22_1;

	    		    ANTLR_MARKER index22_1;


	    		    LA22_1 = ctx->LA(1);

	    		     
	    		        index22_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA22_1 == DELIMITED_ID || LA22_1 == INTRODUCER) && ((equalsIgnoreCase(LT(1)->getText(), "SET"))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 14:

	    		{
	    		    ANTLR_UINT32 LA22_31;

	    		    ANTLR_MARKER index22_31;


	    		    LA22_31 = ctx->LA(1);

	    		     
	    		        index22_31 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_31 == DELIMITED_ID || LA22_31 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 33;
	    		    }

	    			 
	    				ctx->seek(index22_31);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 15:

	    		{
	    		    ANTLR_UINT32 LA22_29;

	    		    ANTLR_MARKER index22_29;


	    		    LA22_29 = ctx->LA(1);

	    		     
	    		        index22_29 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_29 == DELIMITED_ID || LA22_29 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 32;
	    		    }

	    			 
	    				ctx->seek(index22_29);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 16:

	    		{
	    		    ANTLR_UINT32 LA22_17;

	    		    ANTLR_MARKER index22_17;


	    		    LA22_17 = ctx->LA(1);

	    		     
	    		        index22_17 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_17 == DELIMITED_ID || LA22_17 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 24;
	    		    }

	    			 
	    				ctx->seek(index22_17);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 17:

	    		{
	    		    ANTLR_UINT32 LA22_23;

	    		    ANTLR_MARKER index22_23;


	    		    LA22_23 = ctx->LA(1);

	    		     
	    		        index22_23 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_23 == DELIMITED_ID || LA22_23 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 28;
	    		    }

	    			 
	    				ctx->seek(index22_23);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 18:

	    		{
	    		    ANTLR_UINT32 LA22_10;

	    		    ANTLR_MARKER index22_10;


	    		    LA22_10 = ctx->LA(1);

	    		     
	    		        index22_10 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_10 == COMMA || LA22_10 == PERIOD || LA22_10 == REGULAR_ID || LA22_10 == SQL92_RESERVED_ASC || LA22_10 == SQL92_RESERVED_DESC) && ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA22_10 == LEFT_PAREN || LA22_10 == SQL92_RESERVED_AS) && ((equalsIgnoreCase(LT(1)->getText(), "SET"))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_10);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 19:

	    		{
	    		    ANTLR_UINT32 LA22_13;

	    		    ANTLR_MARKER index22_13;


	    		    LA22_13 = ctx->LA(1);

	    		     
	    		        index22_13 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_13 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 19;
	    		    }

	    		    else if ( (LA22_13 == DELIMITED_ID || LA22_13 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 20;
	    		    }

	    			 
	    				ctx->seek(index22_13);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 20:

	    		{
	    		    ANTLR_UINT32 LA22_18;

	    		    ANTLR_MARKER index22_18;


	    		    LA22_18 = ctx->LA(1);

	    		     
	    		        index22_18 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_18 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( (LA22_18 == COMMA) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 14;
	    		    }

	    		    else if ( (LA22_18 == LEFT_PAREN || LA22_18 == SQL92_RESERVED_SELECT) && ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA22_18 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 12;
	    		    }

	    			 
	    				ctx->seek(index22_18);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 21:

	    		{
	    		    ANTLR_UINT32 LA22_30;

	    		    ANTLR_MARKER index22_30;


	    		    LA22_30 = ctx->LA(1);

	    		     
	    		        index22_30 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_30 == COMMA || LA22_30 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( (LA22_30 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 26;
	    		    }

	    		    else if ( (LA22_30 == SQL92_RESERVED_TO) && ((equalsIgnoreCase(LT(1)->getText(), "SET"))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_30);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 22:

	    		{
	    		    ANTLR_UINT32 LA22_26;

	    		    ANTLR_MARKER index22_26;


	    		    LA22_26 = ctx->LA(1);

	    		     
	    		        index22_26 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_26 == DELIMITED_ID || LA22_26 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 30;
	    		    }

	    			 
	    				ctx->seek(index22_26);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 23:

	    		{
	    		    ANTLR_UINT32 LA22_12;

	    		    ANTLR_MARKER index22_12;


	    		    LA22_12 = ctx->LA(1);

	    		     
	    		        index22_12 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_12 == DELIMITED_ID || LA22_12 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 18;
	    		    }

	    			 
	    				ctx->seek(index22_12);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 24:

	    		{
	    		    ANTLR_UINT32 LA22_5;

	    		    ANTLR_MARKER index22_5;


	    		    LA22_5 = ctx->LA(1);

	    		     
	    		        index22_5 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_5 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( (LA22_5 == DELIMITED_ID || LA22_5 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index22_5);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 25:

	    		{
	    		    ANTLR_UINT32 LA22_6;

	    		    ANTLR_MARKER index22_6;


	    		    LA22_6 = ctx->LA(1);

	    		     
	    		        index22_6 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_6 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA22_6 == DELIMITED_ID || LA22_6 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index22_6);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 26:

	    		{
	    		    ANTLR_UINT32 LA22_8;

	    		    ANTLR_MARKER index22_8;


	    		    LA22_8 = ctx->LA(1);

	    		     
	    		        index22_8 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_8 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( (LA22_8 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( (LA22_8 == COMMA) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 14;
	    		    }

	    		    else if ( (LA22_8 == LEFT_PAREN || LA22_8 == SQL92_RESERVED_SELECT) && ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) )
	    		    {
	    		        s = 15;
	    		    }

	    			 
	    				ctx->seek(index22_8);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 27:

	    		{
	    		    ANTLR_UINT32 LA22_33;

	    		    ANTLR_MARKER index22_33;


	    		    LA22_33 = ctx->LA(1);

	    		     
	    		        index22_33 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_33 == DELIMITED_ID || LA22_33 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 22;
	    		    }

	    		    else if ( (LA22_33 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 31;
	    		    }

	    			 
	    				ctx->seek(index22_33);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 28:

	    		{
	    		    ANTLR_UINT32 LA22_32;

	    		    ANTLR_MARKER index22_32;


	    		    LA22_32 = ctx->LA(1);

	    		     
	    		        index22_32 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_32 == DELIMITED_ID || LA22_32 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 20;
	    		    }

	    		    else if ( (LA22_32 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 29;
	    		    }

	    			 
	    				ctx->seek(index22_32);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 29:

	    		{
	    		    ANTLR_UINT32 LA22_28;

	    		    ANTLR_MARKER index22_28;


	    		    LA22_28 = ctx->LA(1);

	    		     
	    		        index22_28 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_28 == DELIMITED_ID || LA22_28 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( (LA22_28 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 23;
	    		    }

	    			 
	    				ctx->seek(index22_28);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 30:

	    		{
	    		    ANTLR_UINT32 LA22_24;

	    		    ANTLR_MARKER index22_24;


	    		    LA22_24 = ctx->LA(1);

	    		     
	    		        index22_24 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA22_24 == DELIMITED_ID || LA22_24 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA22_24 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) )
	    		    {
	    		        s = 17;
	    		    }

	    			 
	    				ctx->seek(index22_24);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "86:77: ( nulls_key last_key )?" );
	    ex->set_decisionNum( 22 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParser_PLSQL_DMLParserCyclicDFA22  cdfa22(
	    22,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"86:77: ( nulls_key last_key )?",
	    dfa22_eot,	    /* EOT table			    */
	    dfa22_eof,	    /* EOF table			    */
	    dfa22_min,	    /* Minimum tokens for each state    */
	    dfa22_max,	    /* Maximum tokens for each state    */
	    dfa22_accept,	/* Accept table			    */
	    dfa22_special,	/* Special transition states	    */
	    dfa22_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 22
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    146:76: ( pivot_clause | unpivot_clause )?
 */
static const ANTLR_INT32 dfa43_eot[72] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa43_eof[72] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa43_min[72] =
    {
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa43_max[72] =
    {
	152, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa43_accept[72] =
    {
	-1, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa43_special[72] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa43_T_empty	 =   NULL;

static const ANTLR_INT32 dfa43_T0[] =
    {
	3, -1, -1, -1, 3, 3, 3, -1, 3, -1, 3, 3, -1, 3, 3, -1, 3, -1, 3, 3, -1, 
	3, 3, 3, 3, 3, 3, 3, -1, 3, -1, -1, -1, -1, 3, 1, 2, 3, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, -1, -1, 
	-1, -1, -1, -1, -1, -1, 3, 3, 3, 3, -1, -1, 3, -1, -1, 3, 3, -1, 3, 3, 
	-1, 3, 3, -1, -1, 3, 3, -1, -1, -1, -1, 3, 3, 3, -1, 3, 3, 3, -1, -1, -1, 
	3, 3, 3, -1, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, -1, 3, 3, -1, -1, 
	3, -1, -1, 3, -1, -1, -1, 3, 3, -1, 3, -1, 3, -1, -1, 3, 3, 3, -1, -1, 
	-1, 3
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa43_transitions[] =
{
    dfa43_T0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL
};


/* Declare tracking structure for Cyclic DFA 43
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA43 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA43( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		
	}

};

static PLSQLParser_PLSQL_DMLParserCyclicDFA43  cdfa43(
	    43,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"146:76: ( pivot_clause | unpivot_clause )?",
	    dfa43_eot,	    /* EOT table			    */
	    dfa43_eof,	    /* EOF table			    */
	    dfa43_min,	    /* Minimum tokens for each state    */
	    dfa43_max,	    /* Maximum tokens for each state    */
	    dfa43_accept,	/* Accept table			    */
	    dfa43_special,	/* Special transition states	    */
	    dfa43_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 43
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    147:84: ( pivot_clause | unpivot_clause )?
 */
static const ANTLR_INT32 dfa45_eot[72] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa45_eof[72] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa45_min[72] =
    {
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa45_max[72] =
    {
	152, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa45_accept[72] =
    {
	-1, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa45_special[72] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa45_T_empty	 =   NULL;

static const ANTLR_INT32 dfa45_T0[] =
    {
	3, -1, -1, -1, 3, 3, 3, -1, 3, -1, 3, 3, -1, 3, 3, -1, 3, -1, 3, 3, -1, 
	3, 3, 3, 3, 3, 3, 3, -1, 3, -1, -1, -1, -1, 3, 1, 2, 3, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, -1, -1, 
	-1, -1, -1, -1, -1, -1, 3, 3, 3, 3, -1, -1, 3, -1, -1, 3, 3, -1, 3, 3, 
	-1, 3, 3, -1, -1, 3, 3, -1, -1, -1, -1, 3, 3, 3, -1, 3, 3, 3, -1, -1, -1, 
	3, 3, 3, -1, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, -1, 3, 3, -1, -1, 
	3, -1, -1, 3, -1, -1, -1, 3, 3, -1, 3, -1, 3, -1, -1, 3, 3, 3, -1, -1, 
	-1, 3
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa45_transitions[] =
{
    dfa45_T0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL
};


/* Declare tracking structure for Cyclic DFA 45
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA45 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA45( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		
	}

};

static PLSQLParser_PLSQL_DMLParserCyclicDFA45  cdfa45(
	    45,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"147:84: ( pivot_clause | unpivot_clause )?",
	    dfa45_eot,	    /* EOT table			    */
	    dfa45_eof,	    /* EOF table			    */
	    dfa45_min,	    /* Minimum tokens for each state    */
	    dfa45_max,	    /* Maximum tokens for each state    */
	    dfa45_accept,	/* Accept table			    */
	    dfa45_special,	/* Special transition states	    */
	    dfa45_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 45
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    149:38: ( pivot_clause | unpivot_clause )?
 */
static const ANTLR_INT32 dfa46_eot[72] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa46_eof[72] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa46_min[72] =
    {
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa46_max[72] =
    {
	152, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa46_accept[72] =
    {
	-1, 1, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa46_special[72] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa46_T_empty	 =   NULL;

static const ANTLR_INT32 dfa46_T0[] =
    {
	3, -1, -1, -1, 3, 3, 3, -1, 3, -1, 3, 3, -1, 3, 3, -1, 3, -1, 3, 3, -1, 
	3, 3, 3, 3, 3, 3, 3, -1, 3, -1, -1, -1, -1, 3, 1, 2, 3, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, -1, -1, 
	-1, -1, -1, -1, -1, -1, 3, 3, 3, 3, -1, -1, 3, -1, -1, 3, 3, -1, 3, 3, 
	-1, 3, 3, -1, -1, 3, 3, -1, -1, -1, -1, 3, 3, 3, -1, 3, 3, 3, -1, -1, -1, 
	3, 3, 3, -1, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, 3, -1, 3, 3, -1, -1, 
	3, -1, -1, 3, -1, -1, -1, 3, 3, -1, 3, -1, 3, -1, -1, 3, 3, 3, -1, -1, 
	-1, 3
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa46_transitions[] =
{
    dfa46_T0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL
};


/* Declare tracking structure for Cyclic DFA 46
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA46 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA46( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		
	}

};

static PLSQLParser_PLSQL_DMLParserCyclicDFA46  cdfa46(
	    46,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"149:38: ( pivot_clause | unpivot_clause )?",
	    dfa46_eot,	    /* EOT table			    */
	    dfa46_eof,	    /* EOF table			    */
	    dfa46_min,	    /* Minimum tokens for each state    */
	    dfa46_max,	    /* Maximum tokens for each state    */
	    dfa46_accept,	/* Accept table			    */
	    dfa46_special,	/* Special transition states	    */
	    dfa46_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 46
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 308:64: ( reference_model )*
 */
static const ANTLR_INT32 dfa99_eot[10] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa99_eof[10] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa99_min[10] =
    {
	74, 18, 18, 74, -1, 18, -1, -1, 18, 18
    };
static const ANTLR_INT32 dfa99_max[10] =
    {
	74, 90, 74, 125, -1, 74, -1, -1, 74, 74
    };
static const ANTLR_INT32 dfa99_accept[10] =
    {
	-1, -1, -1, -1, 2, -1, 2, 1, -1, -1
    };
static const ANTLR_INT32 dfa99_special[10] =
    {
	6, 2, 4, 1, -1, 3, -1, -1, 0, 5
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa99_T_empty	 =   NULL;

static const ANTLR_INT32 dfa99_T0[] =
    {
	9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 9
    };

static const ANTLR_INT32 dfa99_T1[] =
    {
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7
    };

static const ANTLR_INT32 dfa99_T2[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa99_T3[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 3
    };

static const ANTLR_INT32 dfa99_T4[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 5
    };

static const ANTLR_INT32 dfa99_T5[] =
    {
	1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa99_transitions[] =
{
    dfa99_T5, dfa99_T2, dfa99_T4, dfa99_T1, NULL, dfa99_T3, NULL, NULL, 
    dfa99_T0, dfa99_T3
};


/* Declare tracking structure for Cyclic DFA 99
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA99 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA99( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA99_8;

	    		    ANTLR_MARKER index99_8;


	    		    LA99_8 = ctx->LA(1);

	    		     
	    		        index99_8 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA99_8 == DELIMITED_ID || LA99_8 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) )
	    		    {
	    		        s = 9;
	    		    }

	    			 
	    				ctx->seek(index99_8);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA99_3;

	    		    ANTLR_MARKER index99_3;


	    		    LA99_3 = ctx->LA(1);

	    		     
	    		        index99_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA99_3 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "MAIN"))) )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( (LA99_3 == SQL92_RESERVED_ON) && ((equalsIgnoreCase(LT(1)->getText(), "REFERENCE"))) )
	    		    {
	    		        s = 7;
	    		    }

	    			 
	    				ctx->seek(index99_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA99_1;

	    		    ANTLR_MARKER index99_1;


	    		    LA99_1 = ctx->LA(1);

	    		     
	    		        index99_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA99_1 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) )
	    		    {
	    		        s = 2;
	    		    }

	    		    else if ( (LA99_1 == DELIMITED_ID || LA99_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA99_1 == SQL92_RESERVED_BY) && ((((equalsIgnoreCase(LT(1)->getText(), "DIMENSION")))||((equalsIgnoreCase(LT(1)->getText(), "PARTITION"))))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index99_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA99_5;

	    		    ANTLR_MARKER index99_5;


	    		    LA99_5 = ctx->LA(1);

	    		     
	    		        index99_5 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA99_5 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA99_5 == DELIMITED_ID || LA99_5 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) )
	    		    {
	    		        s = 3;
	    		    }

	    			 
	    				ctx->seek(index99_5);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA99_2;

	    		    ANTLR_MARKER index99_2;


	    		    LA99_2 = ctx->LA(1);

	    		     
	    		        index99_2 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA99_2 == DELIMITED_ID || LA99_2 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) )
	    		    {
	    		        s = 5;
	    		    }

	    			 
	    				ctx->seek(index99_2);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA99_9;

	    		    ANTLR_MARKER index99_9;


	    		    LA99_9 = ctx->LA(1);

	    		     
	    		        index99_9 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA99_9 == DELIMITED_ID || LA99_9 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA99_9 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index99_9);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA99_0;

	    		    ANTLR_MARKER index99_0;


	    		    LA99_0 = ctx->LA(1);

	    		     
	    		        index99_0 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA99_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "DIMENSION")))||((equalsIgnoreCase(LT(1)->getText(), "PARTITION")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) )
	    		    {
	    		        s = 1;
	    		    }

	    			 
	    				ctx->seek(index99_0);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "()* loopback of 308:64: ( reference_model )*" );
	    ex->set_decisionNum( 99 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParser_PLSQL_DMLParserCyclicDFA99  cdfa99(
	    99,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"()* loopback of 308:64: ( reference_model )*",
	    dfa99_eot,	    /* EOT table			    */
	    dfa99_eof,	    /* EOF table			    */
	    dfa99_min,	    /* Minimum tokens for each state    */
	    dfa99_max,	    /* Maximum tokens for each state    */
	    dfa99_accept,	/* Accept table			    */
	    dfa99_special,	/* Special transition states	    */
	    dfa99_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 99
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    557:9: ( error_logging_into_part )?
 */
static const ANTLR_INT32 dfa179_eot[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa179_eof[9] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa179_min[9] =
    {
	5, 18, -1, 18, -1, -1, 18, 18, 18
    };
static const ANTLR_INT32 dfa179_max[9] =
    {
	151, 137, -1, 74, -1, -1, 74, 74, 74
    };
static const ANTLR_INT32 dfa179_accept[9] =
    {
	-1, -1, 2, -1, 1, 1, -1, -1, -1
    };
static const ANTLR_INT32 dfa179_special[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa179_T_empty	 =   NULL;

static const ANTLR_INT32 dfa179_T0[] =
    {
	2, -1, -1, -1, 2, -1, -1, 2, 2, 2, -1, -1, -1, 2, -1, -1, -1, 2, -1, -1, 
	-1, -1, -1, 2, -1, 2, -1, -1, 2, 2, -1, -1, -1, -1, 2, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, 2, -1, -1, 2, 
	-1, 2, 2, -1, 2, -1, -1, -1, -1, -1, 2, -1, -1, 2, -1, 2, 2, -1, 2, 2, 
	-1, 2, 2, 2, -1, -1, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, 1, -1, 
	-1, 2, 2, -1, -1, -1, -1, -1, -1, 2, 2, -1, -1, 2, -1, -1, -1, -1, -1, 
	2, -1, -1, 2, -1, -1, 2, -1, 2, -1, -1, 2
    };

static const ANTLR_INT32 dfa179_T1[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 5
    };

static const ANTLR_INT32 dfa179_T2[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, 2, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 2
    };

static const ANTLR_INT32 dfa179_T3[] =
    {
	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 8
    };

static const ANTLR_INT32 dfa179_T4[] =
    {
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 6
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa179_transitions[] =
{
    dfa179_T0, dfa179_T2, NULL, dfa179_T4, NULL, NULL, dfa179_T1, dfa179_T3, 
    dfa179_T1
};


/* Declare tracking structure for Cyclic DFA 179
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA179 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA179( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		
	}

};

static PLSQLParser_PLSQL_DMLParserCyclicDFA179  cdfa179(
	    179,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"557:9: ( error_logging_into_part )?",
	    dfa179_eot,	    /* EOT table			    */
	    dfa179_eof,	    /* EOF table			    */
	    dfa179_min,	    /* Minimum tokens for each state    */
	    dfa179_max,	    /* Maximum tokens for each state    */
	    dfa179_accept,	/* Accept table			    */
	    dfa179_special,	/* Special transition states	    */
	    dfa179_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 179
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    573:25: ( sample_clause )?
 */
static const ANTLR_INT32 dfa184_eot[74] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1
    };
static const ANTLR_INT32 dfa184_eof[74] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1
    };
static const ANTLR_INT32 dfa184_min[74] =
    {
	7, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1
    };
static const ANTLR_INT32 dfa184_max[74] =
    {
	152, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1
    };
static const ANTLR_INT32 dfa184_accept[74] =
    {
	-1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 1
    };
static const ANTLR_INT32 dfa184_special[74] =
    {
	-1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa184_T_empty	 =   NULL;

static const ANTLR_INT32 dfa184_T0[] =
    {
	2, -1, -1, -1, 2, 2, 2, -1, 2, -1, 2, 2, -1, 2, 2, -1, 2, -1, 2, 2, -1, 
	2, 2, 2, 2, 2, 2, 2, -1, 2, -1, -1, -1, -1, 2, 2, 2, 2, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 2, 2, -1, -1, -1, -1, -1, 2, -1, -1, 2, 2, -1, -1, 
	-1, -1, -1, -1, -1, -1, 1, 2, 2, 2, -1, -1, 2, -1, -1, 2, 2, -1, 2, 2, 
	-1, 2, 2, -1, -1, 2, 2, -1, -1, -1, -1, 2, 2, 2, -1, 2, 2, 2, -1, -1, -1, 
	2, 2, 2, -1, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, -1, -1, 2, -1, 2, 2, -1, -1, 
	2, -1, -1, 2, -1, -1, -1, 2, 2, -1, 2, -1, 2, 2, -1, 2, 2, 2, -1, -1, -1, 
	2
    };

static const ANTLR_INT32 dfa184_T1[] =
    {
	-1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa184_transitions[] =
{
    dfa184_T0, dfa184_T1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL
};


/* Declare tracking structure for Cyclic DFA 184
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA184 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA184( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA184_1;

	    		    ANTLR_MARKER index184_1;


	    		    LA184_1 = ctx->LA(1);

	    		     
	    		        index184_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "SAMPLE")))  )
	    		    {
	    		        s = 73;
	    		    }

	    		    else if ( (true)  )
	    		    {
	    		        s = 2;
	    		    }

	    			 
	    				ctx->seek(index184_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "573:25: ( sample_clause )?" );
	    ex->set_decisionNum( 184 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParser_PLSQL_DMLParserCyclicDFA184  cdfa184(
	    184,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"573:25: ( sample_clause )?",
	    dfa184_eot,	    /* EOT table			    */
	    dfa184_eof,	    /* EOF table			    */
	    dfa184_min,	    /* Minimum tokens for each state    */
	    dfa184_max,	    /* Maximum tokens for each state    */
	    dfa184_accept,	/* Accept table			    */
	    dfa184_special,	/* Special transition states	    */
	    dfa184_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 184
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    593:9: ( seed_part )?
 */
static const ANTLR_INT32 dfa192_eot[74] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1
    };
static const ANTLR_INT32 dfa192_eof[74] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1
    };
static const ANTLR_INT32 dfa192_min[74] =
    {
	7, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1
    };
static const ANTLR_INT32 dfa192_max[74] =
    {
	152, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1
    };
static const ANTLR_INT32 dfa192_accept[74] =
    {
	-1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 1
    };
static const ANTLR_INT32 dfa192_special[74] =
    {
	-1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa192_T_empty	 =   NULL;

static const ANTLR_INT32 dfa192_T0[] =
    {
	2, -1, -1, -1, 2, 2, 2, -1, 2, -1, 2, 2, -1, 2, 2, -1, 2, -1, 2, 2, -1, 
	2, 2, 2, 2, 2, 2, 2, -1, 2, -1, -1, -1, -1, 2, 2, 2, 2, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 2, 2, -1, -1, -1, -1, -1, 2, -1, -1, 2, 2, -1, -1, 
	-1, -1, -1, -1, -1, -1, 1, 2, 2, 2, -1, -1, 2, -1, -1, 2, 2, -1, 2, 2, 
	-1, 2, 2, -1, -1, 2, 2, -1, -1, -1, -1, 2, 2, 2, -1, 2, 2, 2, -1, -1, -1, 
	2, 2, 2, -1, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, -1, -1, 2, -1, 2, 2, -1, -1, 
	2, -1, -1, 2, -1, -1, -1, 2, 2, -1, 2, -1, 2, 2, -1, 2, 2, 2, -1, -1, -1, 
	2
    };

static const ANTLR_INT32 dfa192_T1[] =
    {
	-1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa192_transitions[] =
{
    dfa192_T0, dfa192_T1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL
};


/* Declare tracking structure for Cyclic DFA 192
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA192 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA192( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA192_1;

	    		    ANTLR_MARKER index192_1;


	    		    LA192_1 = ctx->LA(1);

	    		     
	    		        index192_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "SEED")))  )
	    		    {
	    		        s = 73;
	    		    }

	    		    else if ( (true)  )
	    		    {
	    		        s = 2;
	    		    }

	    			 
	    				ctx->seek(index192_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "593:9: ( seed_part )?" );
	    ex->set_decisionNum( 192 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParser_PLSQL_DMLParserCyclicDFA192  cdfa192(
	    192,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"593:9: ( seed_part )?",
	    dfa192_eot,	    /* EOT table			    */
	    dfa192_eof,	    /* EOF table			    */
	    dfa192_min,	    /* Minimum tokens for each state    */
	    dfa192_max,	    /* Maximum tokens for each state    */
	    dfa192_accept,	/* Accept table			    */
	    dfa192_special,	/* Special transition states	    */
	    dfa192_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 192
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    724:87: ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )?
 */
static const ANTLR_INT32 dfa223_eot[72] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa223_eof[72] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa223_min[72] =
    {
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa223_max[72] =
    {
	152, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa223_accept[72] =
    {
	-1, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa223_special[72] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa223_T_empty	 =   NULL;

static const ANTLR_INT32 dfa223_T0[] =
    {
	2, -1, -1, -1, 2, 2, 2, -1, 2, -1, 2, 2, -1, 2, 2, -1, 2, -1, 2, 2, -1, 
	2, 2, 1, 2, 2, 2, 2, -1, 2, -1, -1, -1, -1, 2, 2, 2, 2, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 2, 2, -1, -1, -1, -1, -1, 2, -1, -1, 2, 2, -1, -1, 
	-1, -1, -1, -1, -1, -1, 2, 2, 2, 2, -1, -1, 2, -1, -1, 2, 2, -1, 2, 2, 
	-1, 2, 2, -1, -1, 2, 2, -1, -1, -1, -1, 2, 2, 2, -1, 2, 2, 2, -1, -1, -1, 
	2, 2, 2, -1, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, -1, -1, 2, -1, 2, 2, -1, -1, 
	2, -1, -1, 2, -1, -1, -1, 2, 2, -1, 2, -1, 2, -1, -1, 2, 2, 2, -1, -1, 
	-1, 2
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa223_transitions[] =
{
    dfa223_T0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL
};


/* Declare tracking structure for Cyclic DFA 223
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA223 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA223( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		
	}

};

static PLSQLParser_PLSQL_DMLParserCyclicDFA223  cdfa223(
	    223,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"724:87: ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )?",
	    dfa223_eot,	    /* EOT table			    */
	    dfa223_eof,	    /* EOF table			    */
	    dfa223_min,	    /* Minimum tokens for each state    */
	    dfa223_max,	    /* Maximum tokens for each state    */
	    dfa223_accept,	/* Accept table			    */
	    dfa223_special,	/* Special transition states	    */
	    dfa223_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 223
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    828:1: atom options {backtrack=true; } : ( ( table_element outer_join_sign )=> table_element outer_join_sign | bind_variable | constant | general_element | LEFT_PAREN ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN ) );
 */
static const ANTLR_INT32 dfa256_eot[22] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1
    };
static const ANTLR_INT32 dfa256_eof[22] =
    {
	-1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, 
	-1, -1, -1, 10
    };
static const ANTLR_INT32 dfa256_min[22] =
    {
	5, 18, 30, -1, 7, -1, -1, 18, -1, -1, -1, 18, 5, 18, 7, 5, 18, 5, 18, -1, 
	5, 7
    };
static const ANTLR_INT32 dfa256_max[22] =
    {
	151, 74, 38, -1, 152, -1, -1, 74, -1, -1, -1, 74, 151, 74, 152, 151, 74, 
	151, 74, -1, 151, 152
    };
static const ANTLR_INT32 dfa256_accept[22] =
    {
	-1, -1, -1, 2, -1, 3, 5, -1, 1, 1, 4, -1, -1, -1, -1, -1, -1, -1, -1, 1, 
	-1, -1
    };
static const ANTLR_INT32 dfa256_special[22] =
    {
	-1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, 
	-1, 1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa256_T_empty	 =   NULL;

static const ANTLR_INT32 dfa256_T0[] =
    {
	10, -1, -1, -1, 10, 10, 10, -1, 10, -1, 10, 10, -1, 10, 10, -1, 10, -1, 
	10, 10, -1, 10, 10, 12, 10, 10, 10, 10, -1, 10, -1, 11, -1, -1, 10, 10, 
	10, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 10, -1, -1, -1, -1, -1, 
	10, -1, -1, 10, 10, -1, -1, -1, -1, -1, -1, -1, -1, 10, 10, 10, 10, -1, 
	-1, 10, -1, -1, 10, 10, -1, 10, 10, -1, 10, 10, -1, -1, 10, 10, -1, -1, 
	-1, -1, 10, 10, 10, -1, 10, 10, 10, -1, -1, -1, 10, 10, 10, -1, -1, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, -1, -1, 10, -1, 10, 10, -1, -1, 10, -1, 
	-1, 10, -1, -1, -1, 10, 10, -1, 10, -1, 10, -1, -1, 10, 10, 10, -1, -1, 
	-1, 10
    };

static const ANTLR_INT32 dfa256_T1[] =
    {
	14, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 14
    };

static const ANTLR_INT32 dfa256_T2[] =
    {
	5, -1, -1, -1, 3, -1, -1, 5, 5, 3, -1, -1, -1, 4, -1, -1, -1, 5, -1, -1, 
	-1, -1, -1, 1, -1, 6, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 
	-1, 5, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5
    };

static const ANTLR_INT32 dfa256_T3[] =
    {
	10, -1, -1, -1, 10, 10, 10, -1, 10, -1, 10, 10, -1, 10, 10, -1, 10, -1, 
	10, 10, -1, 10, 10, 17, 10, 10, 10, 10, -1, 10, -1, 18, -1, -1, 10, 10, 
	10, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 10, -1, -1, -1, -1, -1, 
	10, -1, -1, 10, 10, -1, -1, -1, -1, -1, -1, -1, -1, 10, 10, 10, 10, -1, 
	-1, 10, -1, -1, 10, 10, -1, 10, 10, -1, 10, 10, -1, -1, 10, 10, -1, -1, 
	-1, -1, 10, 10, 10, -1, 10, 10, 10, -1, -1, -1, 10, 10, 10, -1, -1, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, -1, -1, 10, -1, 10, 10, -1, -1, 10, -1, 
	-1, 10, -1, -1, -1, 10, 10, -1, 10, -1, 10, -1, -1, 10, 10, 10, -1, -1, 
	-1, 10
    };

static const ANTLR_INT32 dfa256_T4[] =
    {
	10, -1, -1, -1, 10, -1, -1, 10, 10, 10, 10, -1, -1, 10, -1, -1, -1, 10, 
	-1, -1, -1, -1, -1, 10, -1, 10, -1, -1, 10, 10, -1, -1, -1, -1, 10, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 20, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, 10, 
	-1, -1, -1, -1, -1, 10, -1, -1, 10, -1, -1, -1, -1, -1, 10, -1, -1, -1, 
	-1, 10, 10, -1, 10, -1, -1, 10, -1, -1, -1, -1, 10, 10, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 10, -1, -1, -1, -1, -1, -1, 10, 
	-1, -1, -1, 10, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 10
    };

static const ANTLR_INT32 dfa256_T5[] =
    {
	10, -1, -1, -1, 10, -1, -1, 10, 10, 10, -1, -1, -1, 10, -1, -1, -1, 10, 
	-1, -1, -1, -1, -1, 10, -1, 10, -1, -1, 10, 10, -1, -1, -1, -1, 10, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, 19, 
	-1, -1, -1, -1, -1, 10, -1, -1, 10, -1, -1, -1, -1, -1, 10, -1, -1, -1, 
	-1, -1, 10, -1, 10, -1, -1, 10, -1, -1, -1, -1, 10, 10, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, 10, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 10
    };

static const ANTLR_INT32 dfa256_T6[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4
    };

static const ANTLR_INT32 dfa256_T7[] =
    {
	10, -1, -1, -1, 10, -1, -1, 10, 10, 10, 10, -1, -1, 10, -1, -1, -1, 10, 
	-1, -1, -1, -1, -1, 10, -1, 10, -1, -1, 10, 10, -1, -1, -1, -1, 10, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, 10, 
	-1, -1, -1, -1, -1, 10, -1, -1, 10, -1, -1, -1, -1, -1, 10, -1, -1, -1, 
	-1, 10, 10, -1, 10, -1, -1, 10, -1, -1, -1, -1, 10, 10, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 10, -1, -1, -1, -1, -1, -1, 10, 
	-1, -1, -1, 10, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 10
    };

static const ANTLR_INT32 dfa256_T8[] =
    {
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 7
    };

static const ANTLR_INT32 dfa256_T9[] =
    {
	21, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 21
    };

static const ANTLR_INT32 dfa256_T10[] =
    {
	9, -1, -1, -1, -1, -1, -1, -1, 8
    };

static const ANTLR_INT32 dfa256_T11[] =
    {
	16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 16
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa256_transitions[] =
{
    dfa256_T2, dfa256_T8, dfa256_T10, NULL, dfa256_T0, NULL, NULL, dfa256_T6, 
    NULL, NULL, NULL, dfa256_T1, dfa256_T7, dfa256_T11, dfa256_T3, dfa256_T5, 
    dfa256_T6, dfa256_T4, dfa256_T9, NULL, dfa256_T5, dfa256_T3
};


/* Declare tracking structure for Cyclic DFA 256
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA256 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA256( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA256_15;

	    		    ANTLR_MARKER index256_15;


	    		    LA256_15 = ctx->LA(1);

	    		     
	    		        index256_15 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA256_15 == RIGHT_PAREN) && (this->msynpred( antlr3::ClassForwarder<synpred43_PLSQL_DMLParser>() )) )
	    		    {
	    		        s = 19;
	    		    }

	    		    else if ( (LA256_15 == APPROXIMATE_NUM_LIT || LA256_15 == BINDVAR || ((LA256_15 >= CHAR_STRING) && (LA256_15 <= COLON)) || LA256_15 == DELIMITED_ID || LA256_15 == EXACT_NUM_LIT || LA256_15 == INTRODUCER || LA256_15 == LEFT_PAREN || ((LA256_15 >= MINUS_SIGN) && (LA256_15 <= NATIONAL_CHAR_STRING_LIT)) || LA256_15 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA256_15 == PLUS_SIGN || LA256_15 == REGULAR_ID || LA256_15 == SQL92_RESERVED_ALL || LA256_15 == SQL92_RESERVED_ANY || LA256_15 == SQL92_RESERVED_CASE || LA256_15 == SQL92_RESERVED_DATE || LA256_15 == SQL92_RESERVED_DEFAULT || LA256_15 == SQL92_RESERVED_DISTINCT || ((LA256_15 >= SQL92_RESERVED_EXISTS) && (LA256_15 <= SQL92_RESERVED_FALSE)) || LA256_15 == SQL92_RESERVED_NULL || LA256_15 == SQL92_RESERVED_PRIOR || LA256_15 == SQL92_RESERVED_TRUE || LA256_15 == UNSIGNED_INTEGER)  )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index256_15);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA256_20;

	    		    ANTLR_MARKER index256_20;


	    		    LA256_20 = ctx->LA(1);

	    		     
	    		        index256_20 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA256_20 == RIGHT_PAREN) && (this->msynpred( antlr3::ClassForwarder<synpred43_PLSQL_DMLParser>() )) )
	    		    {
	    		        s = 19;
	    		    }

	    		    else if ( (LA256_20 == APPROXIMATE_NUM_LIT || LA256_20 == BINDVAR || ((LA256_20 >= CHAR_STRING) && (LA256_20 <= COLON)) || LA256_20 == DELIMITED_ID || LA256_20 == EXACT_NUM_LIT || LA256_20 == INTRODUCER || LA256_20 == LEFT_PAREN || ((LA256_20 >= MINUS_SIGN) && (LA256_20 <= NATIONAL_CHAR_STRING_LIT)) || LA256_20 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA256_20 == PLUS_SIGN || LA256_20 == REGULAR_ID || LA256_20 == SQL92_RESERVED_ALL || LA256_20 == SQL92_RESERVED_ANY || LA256_20 == SQL92_RESERVED_CASE || LA256_20 == SQL92_RESERVED_DATE || LA256_20 == SQL92_RESERVED_DEFAULT || LA256_20 == SQL92_RESERVED_DISTINCT || ((LA256_20 >= SQL92_RESERVED_EXISTS) && (LA256_20 <= SQL92_RESERVED_FALSE)) || LA256_20 == SQL92_RESERVED_NULL || LA256_20 == SQL92_RESERVED_PRIOR || LA256_20 == SQL92_RESERVED_TRUE || LA256_20 == UNSIGNED_INTEGER)  )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index256_20);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA256_2;

	    		    ANTLR_MARKER index256_2;


	    		    LA256_2 = ctx->LA(1);

	    		     
	    		        index256_2 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA256_2 == PERIOD) && (this->msynpred( antlr3::ClassForwarder<synpred43_PLSQL_DMLParser>() )) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA256_2 == LEFT_PAREN) && (this->msynpred( antlr3::ClassForwarder<synpred43_PLSQL_DMLParser>() )) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (( ((((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||((equalsIgnoreCase(LT(1)->getText(), "MAXVALUE")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP")))||((equalsIgnoreCase(LT(1)->getText(), "MINVALUE")))||((equalsIgnoreCase(LT(1)->getText(), "SESSIONTIMEZONE")))||((equalsIgnoreCase(LT(1)->getText(), "DBTIMEZONE"))))) && (this->msynpred( antlr3::ClassForwarder<synpred45_PLSQL_DMLParser>() )) ))  )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred46_PLSQL_DMLParser>() ))  )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index256_2);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "828:1: atom options {backtrack=true; } : ( ( table_element outer_join_sign )=> table_element outer_join_sign | bind_variable | constant | general_element | LEFT_PAREN ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN ) );" );
	    ex->set_decisionNum( 256 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParser_PLSQL_DMLParserCyclicDFA256  cdfa256(
	    256,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"828:1: atom options {backtrack=true; } : ( ( table_element outer_join_sign )=> table_element outer_join_sign | bind_variable | constant | general_element | LEFT_PAREN ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN ) );",
	    dfa256_eot,	    /* EOT table			    */
	    dfa256_eof,	    /* EOF table			    */
	    dfa256_min,	    /* Minimum tokens for each state    */
	    dfa256_max,	    /* Maximum tokens for each state    */
	    dfa256_accept,	/* Accept table			    */
	    dfa256_special,	/* Special transition states	    */
	    dfa256_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 256
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    861:70: ( using_clause )?
 */
static const ANTLR_INT32 dfa262_eot[72] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa262_eof[72] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa262_min[72] =
    {
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa262_max[72] =
    {
	152, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa262_accept[72] =
    {
	-1, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa262_special[72] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa262_T_empty	 =   NULL;

static const ANTLR_INT32 dfa262_T0[] =
    {
	2, -1, -1, -1, 2, 2, 2, -1, 2, -1, 2, 2, -1, 2, 2, -1, 2, -1, 2, 2, -1, 
	2, 2, 2, 2, 2, 2, 2, -1, 2, -1, -1, -1, -1, 2, 2, 2, 1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 2, 2, -1, -1, -1, -1, -1, 2, -1, -1, 2, 2, -1, -1, 
	-1, -1, -1, -1, -1, -1, 2, 2, 2, 2, -1, -1, 2, -1, -1, 2, 2, -1, 2, 2, 
	-1, 2, 2, -1, -1, 2, 2, -1, -1, -1, -1, 2, 2, 2, -1, 2, 2, 2, -1, -1, -1, 
	2, 2, 2, -1, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, -1, -1, 2, -1, 2, 2, -1, -1, 
	2, -1, -1, 2, -1, -1, -1, 2, 2, -1, 2, -1, 2, -1, -1, 2, 2, 2, -1, -1, 
	-1, 2
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa262_transitions[] =
{
    dfa262_T0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL
};


/* Declare tracking structure for Cyclic DFA 262
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA262 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA262( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		
	}

};

static PLSQLParser_PLSQL_DMLParserCyclicDFA262  cdfa262(
	    262,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"861:70: ( using_clause )?",
	    dfa262_eot,	    /* EOT table			    */
	    dfa262_eof,	    /* EOF table			    */
	    dfa262_min,	    /* Minimum tokens for each state    */
	    dfa262_max,	    /* Maximum tokens for each state    */
	    dfa262_accept,	/* Accept table			    */
	    dfa262_special,	/* Special transition states	    */
	    dfa262_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 262
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    941:17: ( name_key id | evalname_key concatenation_wrapper )
 */
static const ANTLR_INT32 dfa301_eot[11] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa301_eof[11] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa301_min[11] =
    {
	74, 5, 18, 0, -1, 0, 18, -1, 18, 0, 18
    };
static const ANTLR_INT32 dfa301_max[11] =
    {
	74, 151, 74, 0, -1, 0, 74, -1, 74, 0, 74
    };
static const ANTLR_INT32 dfa301_accept[11] =
    {
	-1, -1, -1, -1, 2, -1, -1, 1, -1, -1, -1
    };
static const ANTLR_INT32 dfa301_special[11] =
    {
	7, 3, 8, 2, -1, 1, 4, -1, 0, 6, 5
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa301_T_empty	 =   NULL;

static const ANTLR_INT32 dfa301_T0[] =
    {
	10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 10
    };

static const ANTLR_INT32 dfa301_T1[] =
    {
	-1
    };

static const ANTLR_INT32 dfa301_T2[] =
    {
	4, -1, -1, -1, 4, -1, -1, 4, 4, 4, -1, -1, -1, 5, -1, -1, -1, 4, -1, -1, 
	-1, -1, -1, 2, -1, 4, -1, -1, 4, 4, -1, -1, -1, -1, 4, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, 
	-1, 4, -1, -1, 4, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, 4, -1, 4, 
	-1, -1, 4, -1, -1, -1, -1, 4, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa301_T3[] =
    {
	9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 9
    };

static const ANTLR_INT32 dfa301_T4[] =
    {
	1
    };

static const ANTLR_INT32 dfa301_T5[] =
    {
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 6
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa301_transitions[] =
{
    dfa301_T4, dfa301_T2, dfa301_T5, dfa301_T1, NULL, dfa301_T1, dfa301_T3, 
    NULL, dfa301_T0, dfa301_T1, dfa301_T3
};


/* Declare tracking structure for Cyclic DFA 301
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA301 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA301( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA301_8;

	    		    ANTLR_MARKER index301_8;


	    		    LA301_8 = ctx->LA(1);

	    		     
	    		        index301_8 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA301_8 == DELIMITED_ID || LA301_8 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index301_8);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA301_5;

	    		    ANTLR_MARKER index301_5;


	    		    LA301_5 = ctx->LA(1);

	    		     
	    		        index301_5 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "NAME")))  )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))  )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index301_5);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA301_3;

	    		    ANTLR_MARKER index301_3;


	    		    LA301_3 = ctx->LA(1);

	    		     
	    		        index301_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "NAME")))  )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))  )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index301_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA301_1;

	    		    ANTLR_MARKER index301_1;


	    		    LA301_1 = ctx->LA(1);

	    		     
	    		        index301_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA301_1 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) )
	    		    {
	    		        s = 2;
	    		    }

	    		    else if ( (LA301_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( (LA301_1 == APPROXIMATE_NUM_LIT || LA301_1 == BINDVAR || ((LA301_1 >= CHAR_STRING) && (LA301_1 <= COLON)) || LA301_1 == EXACT_NUM_LIT || LA301_1 == LEFT_PAREN || ((LA301_1 >= MINUS_SIGN) && (LA301_1 <= NATIONAL_CHAR_STRING_LIT)) || LA301_1 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA301_1 == PLUS_SIGN || LA301_1 == SQL92_RESERVED_ALL || LA301_1 == SQL92_RESERVED_ANY || LA301_1 == SQL92_RESERVED_CASE || LA301_1 == SQL92_RESERVED_DATE || LA301_1 == SQL92_RESERVED_DEFAULT || LA301_1 == SQL92_RESERVED_DISTINCT || ((LA301_1 >= SQL92_RESERVED_EXISTS) && (LA301_1 <= SQL92_RESERVED_FALSE)) || LA301_1 == SQL92_RESERVED_NULL || LA301_1 == SQL92_RESERVED_PRIOR || LA301_1 == SQL92_RESERVED_TRUE || LA301_1 == UNSIGNED_INTEGER) && ((equalsIgnoreCase(LT(1)->getText(), "EVALNAME"))) )
	    		    {
	    		        s = 4;
	    		    }

	    		    else if ( (LA301_1 == DELIMITED_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) )
	    		    {
	    		        s = 5;
	    		    }

	    			 
	    				ctx->seek(index301_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA301_6;

	    		    ANTLR_MARKER index301_6;


	    		    LA301_6 = ctx->LA(1);

	    		     
	    		        index301_6 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA301_6 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (LA301_6 == DELIMITED_ID || LA301_6 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) )
	    		    {
	    		        s = 9;
	    		    }

	    			 
	    				ctx->seek(index301_6);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA301_10;

	    		    ANTLR_MARKER index301_10;


	    		    LA301_10 = ctx->LA(1);

	    		     
	    		        index301_10 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA301_10 == DELIMITED_ID || LA301_10 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (LA301_10 == PERIOD) && ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index301_10);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA301_9;

	    		    ANTLR_MARKER index301_9;


	    		    LA301_9 = ctx->LA(1);

	    		     
	    		        index301_9 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "NAME")))  )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))  )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index301_9);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 7:

	    		{
	    		    ANTLR_UINT32 LA301_0;

	    		    ANTLR_MARKER index301_0;


	    		    LA301_0 = ctx->LA(1);

	    		     
	    		        index301_0 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA301_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) )
	    		    {
	    		        s = 1;
	    		    }

	    			 
	    				ctx->seek(index301_0);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 8:

	    		{
	    		    ANTLR_UINT32 LA301_2;

	    		    ANTLR_MARKER index301_2;


	    		    LA301_2 = ctx->LA(1);

	    		     
	    		        index301_2 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (LA301_2 == DELIMITED_ID || LA301_2 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) )
	    		    {
	    		        s = 6;
	    		    }

	    			 
	    				ctx->seek(index301_2);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "941:17: ( name_key id | evalname_key concatenation_wrapper )" );
	    ex->set_decisionNum( 301 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParser_PLSQL_DMLParserCyclicDFA301  cdfa301(
	    301,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"941:17: ( name_key id | evalname_key concatenation_wrapper )",
	    dfa301_eot,	    /* EOT table			    */
	    dfa301_eof,	    /* EOF table			    */
	    dfa301_min,	    /* Minimum tokens for each state    */
	    dfa301_max,	    /* Maximum tokens for each state    */
	    dfa301_accept,	/* Accept table			    */
	    dfa301_special,	/* Special transition states	    */
	    dfa301_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 301
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */

/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start explain_statement
 * PLSQL_DMLParser.g:53:1: explain_statement : explain_key plan_key ( set_key statement_id_key EQUALS_OP quoted_string )? ( into_key tableview_name )? for_key ( select_statement | update_statement | delete_statement | insert_statement | merge_statement ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::explain_statement()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:54:5: ( explain_key plan_key ( set_key statement_id_key EQUALS_OP quoted_string )? ( into_key tableview_name )? for_key ( select_statement | update_statement | delete_statement | insert_statement | merge_statement ) )
        // PLSQL_DMLParser.g:54:10: explain_key plan_key ( set_key statement_id_key EQUALS_OP quoted_string )? ( into_key tableview_name )? for_key ( select_statement | update_statement | delete_statement | insert_statement | merge_statement )
        {
            this->followPush(FOLLOW_explain_key_in_explain_statement186);
            m_gPLSQLParser->explain_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexplain_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_plan_key_in_explain_statement188);
            m_gPLSQLParser->plan_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexplain_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:55:10: ( set_key statement_id_key EQUALS_OP quoted_string )?
            {
                int alt3=2;
                {
                    int LA3_0 = this->LA(1);
                    if ( (LA3_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "SET"))))
                    {
                        alt3=1;
                    }
                }
                switch (alt3)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:55:11: set_key statement_id_key EQUALS_OP quoted_string
            	    {
            	        this->followPush(FOLLOW_set_key_in_explain_statement200);
            	        m_gPLSQLParser->set_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_statement_id_key_in_explain_statement202);
            	        m_gPLSQLParser->statement_id_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_explain_statement204);
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_quoted_string_in_explain_statement206);
            	        m_gPLSQLParser->quoted_string();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:56:10: ( into_key tableview_name )?
            {
                int alt4=2;
                {
                    int LA4_0 = this->LA(1);
                    if ( (LA4_0 == SQL92_RESERVED_INTO))
                    {
                        alt4=1;
                    }
                }
                switch (alt4)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:56:11: into_key tableview_name
            	    {
            	        this->followPush(FOLLOW_into_key_in_explain_statement220);
            	        m_gPLSQLParser->into_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_tableview_name_in_explain_statement222);
            	        m_gPLSQLParser->tableview_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_for_key_in_explain_statement235);
            m_gPLSQLParser->for_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexplain_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:58:10: ( select_statement | update_statement | delete_statement | insert_statement | merge_statement )
            {
                int alt5=5;
                {
                    int LA5_0 = this->LA(1);
                    if ( (LA5_0 == LEFT_PAREN || LA5_0 == SQL92_RESERVED_SELECT || LA5_0 == SQL92_RESERVED_WITH))
                    {
                        alt5=1;
                    }
                    else if ( (LA5_0 == SQL92_RESERVED_UPDATE))
                    {
                        alt5=2;
                    }
                    else if ( (LA5_0 == SQL92_RESERVED_DELETE))
                    {
                        alt5=3;
                    }
                    else if ( (LA5_0 == SQL92_RESERVED_INSERT))
                    {
                        alt5=4;
                    }
                    else if ( (LA5_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "MERGE"))))
                    {
                        alt5=5;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 5 );
                        ex->set_state( 0 );


                        goto ruleexplain_statementEx;

                    }
                }
                switch (alt5)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:58:12: select_statement
            	    {
            	        this->followPush(FOLLOW_select_statement_in_explain_statement248);
            	        select_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:59:12: update_statement
            	    {
            	        this->followPush(FOLLOW_update_statement_in_explain_statement261);
            	        update_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQL_DMLParser.g:60:12: delete_statement
            	    {
            	        this->followPush(FOLLOW_delete_statement_in_explain_statement274);
            	        delete_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 4:
            	    // PLSQL_DMLParser.g:61:12: insert_statement
            	    {
            	        this->followPush(FOLLOW_insert_statement_in_explain_statement287);
            	        insert_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 5:
            	    // PLSQL_DMLParser.g:62:12: merge_statement
            	    {
            	        this->followPush(FOLLOW_merge_statement_in_explain_statement300);
            	        merge_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexplain_statementEx; /* Prevent compiler warnings */
    ruleexplain_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end explain_statement */

/**
 * $ANTLR start select_statement
 * PLSQL_DMLParser.g:66:1: select_statement : ( subquery_factoring_clause )? subquery ( for_update_clause | ( order_key ( siblings_key )? by_key )=> order_by_clause )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::select_statement()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:67:5: ( ( subquery_factoring_clause )? subquery ( for_update_clause | ( order_key ( siblings_key )? by_key )=> order_by_clause )* )
        // PLSQL_DMLParser.g:67:10: ( subquery_factoring_clause )? subquery ( for_update_clause | ( order_key ( siblings_key )? by_key )=> order_by_clause )*
        {
            // PLSQL_DMLParser.g:67:10: ( subquery_factoring_clause )?
            {
                int alt6=2;
                {
                    int LA6_0 = this->LA(1);
                    if ( (LA6_0 == SQL92_RESERVED_WITH))
                    {
                        alt6=1;
                    }
                }
                switch (alt6)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:67:10: subquery_factoring_clause
            	    {
            	        this->followPush(FOLLOW_subquery_factoring_clause_in_select_statement331);
            	        subquery_factoring_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselect_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_subquery_in_select_statement342);
            subquery();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleselect_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:69:9: ( for_update_clause | ( order_key ( siblings_key )? by_key )=> order_by_clause )*

            for (;;)
            {
                int alt7=3;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA7_0 = this->LA(1);
                    if ( (LA7_0 == SQL92_RESERVED_FOR))
                    {
                        alt7=1;
                    }
                    else if ( (LA7_0 == SQL92_RESERVED_ORDER) && (this->msynpred( antlr3::ClassForwarder<synpred1_PLSQL_DMLParser>() )))
                    {
                        alt7=2;
                    }

                }
                switch (alt7)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:69:10: for_update_clause
            	    {
            	        this->followPush(FOLLOW_for_update_clause_in_select_statement353);
            	        for_update_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselect_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:69:28: ( order_key ( siblings_key )? by_key )=> order_by_clause
            	    {
            	        this->followPush(FOLLOW_order_by_clause_in_select_statement365);
            	        order_by_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselect_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleselect_statementEx; /* Prevent compiler warnings */
    ruleselect_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end select_statement */

/**
 * $ANTLR start subquery_factoring_clause
 * PLSQL_DMLParser.g:73:1: subquery_factoring_clause : with_key factoring_element ( COMMA factoring_element )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::subquery_factoring_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:74:5: ( with_key factoring_element ( COMMA factoring_element )* )
        // PLSQL_DMLParser.g:74:10: with_key factoring_element ( COMMA factoring_element )*
        {
            this->followPush(FOLLOW_with_key_in_subquery_factoring_clause388);
            m_gPLSQLParser->with_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubquery_factoring_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_factoring_element_in_subquery_factoring_clause390);
            factoring_element();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubquery_factoring_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:74:37: ( COMMA factoring_element )*

            for (;;)
            {
                int alt8=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA8_0 = this->LA(1);
                    if ( (LA8_0 == COMMA))
                    {
                        alt8=1;
                    }

                }
                switch (alt8)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:74:38: COMMA factoring_element
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_subquery_factoring_clause393);
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_factoring_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_factoring_element_in_subquery_factoring_clause395);
            	        factoring_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_factoring_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop8;	/* break out of the loop */
            	    break;
                }
            }
            loop8: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubquery_factoring_clauseEx; /* Prevent compiler warnings */
    rulesubquery_factoring_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end subquery_factoring_clause */

/**
 * $ANTLR start factoring_element
 * PLSQL_DMLParser.g:77:1: factoring_element : query_name ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? as_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( search_clause )? ( cycle_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::factoring_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:78:5: ( query_name ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? as_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( search_clause )? ( cycle_clause )? )
        // PLSQL_DMLParser.g:78:10: query_name ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? as_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( search_clause )? ( cycle_clause )?
        {
            this->followPush(FOLLOW_query_name_in_factoring_element417);
            m_gPLSQLParser->query_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefactoring_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:78:21: ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )?
            {
                int alt10=2;
                {
                    int LA10_0 = this->LA(1);
                    if ( (LA10_0 == LEFT_PAREN))
                    {
                        alt10=1;
                    }
                }
                switch (alt10)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:78:22: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_factoring_element420);
            	        if  (this->hasException())
            	        {
            	            goto rulefactoring_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_factoring_element422);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefactoring_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:78:45: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            int alt9=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA9_0 = this->LA(1);
            	                if ( (LA9_0 == COMMA))
            	                {
            	                    alt9=1;
            	                }

            	            }
            	            switch (alt9)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:78:46: COMMA column_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_factoring_element425);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefactoring_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_column_name_in_factoring_element427);
            	        	        m_gPLSQLParser->column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefactoring_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop9;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop9: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_factoring_element431);
            	        if  (this->hasException())
            	        {
            	            goto rulefactoring_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_as_key_in_factoring_element435);
            m_gPLSQLParser->as_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefactoring_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_factoring_element437);
            if  (this->hasException())
            {
                goto rulefactoring_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_subquery_in_factoring_element439);
            subquery();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefactoring_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:78:107: ( order_by_clause )?
            {
                int alt11=2;
                {
                    int LA11_0 = this->LA(1);
                    if ( (LA11_0 == SQL92_RESERVED_ORDER))
                    {
                        alt11=1;
                    }
                }
                switch (alt11)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:78:107: order_by_clause
            	    {
            	        this->followPush(FOLLOW_order_by_clause_in_factoring_element441);
            	        order_by_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefactoring_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_factoring_element444);
            if  (this->hasException())
            {
                goto rulefactoring_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:79:10: ( search_clause )?
            {
                int alt12=2;
                {
                    int LA12_0 = this->LA(1);
                    if ( (LA12_0 == REGULAR_ID))
                    {
                        {
                            int LA12_1 = this->LA(2);
                            if ( (LA12_1 == REGULAR_ID))
                            {
                                {
                                    int LA12_3 = this->LA(3);
                                    if ( (LA12_3 == REGULAR_ID))
                                    {
                                        {
                                            int LA12_4 = this->LA(4);
                                            if ( (LA12_4 == SQL92_RESERVED_BY))
                                            {
                                                alt12=1;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt12)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:79:10: search_clause
            	    {
            	        this->followPush(FOLLOW_search_clause_in_factoring_element455);
            	        search_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefactoring_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:80:10: ( cycle_clause )?
            {
                int alt13=2;
                {
                    int LA13_0 = this->LA(1);
                    if ( (LA13_0 == REGULAR_ID))
                    {
                        alt13=1;
                    }
                }
                switch (alt13)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:80:10: cycle_clause
            	    {
            	        this->followPush(FOLLOW_cycle_clause_in_factoring_element467);
            	        cycle_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefactoring_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulefactoring_elementEx; /* Prevent compiler warnings */
    rulefactoring_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end factoring_element */

/**
 * $ANTLR start search_clause
 * PLSQL_DMLParser.g:83:1: search_clause : search_key ( depth_key | breadth_key ) first_key by_key column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? ( COMMA column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? )* set_key column_name ;
 */
void
PLSQLParser_PLSQL_DMLParser::search_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:84:5: ( search_key ( depth_key | breadth_key ) first_key by_key column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? ( COMMA column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? )* set_key column_name )
        // PLSQL_DMLParser.g:84:10: search_key ( depth_key | breadth_key ) first_key by_key column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? ( COMMA column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? )* set_key column_name
        {
            this->followPush(FOLLOW_search_key_in_search_clause488);
            m_gPLSQLParser->search_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearch_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:84:21: ( depth_key | breadth_key )
            {
                int alt14=2;
                {
                    int LA14_0 = this->LA(1);
                    if ( (LA14_0 == REGULAR_ID))
                    {
                        {
                            int LA14_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "DEPTH"))))
                            {
                                alt14=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "BREADTH"))))
                            {
                                alt14=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 14 );
                                ex->set_state( 1 );


                                goto rulesearch_clauseEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 14 );
                        ex->set_state( 0 );


                        goto rulesearch_clauseEx;

                    }
                }
                switch (alt14)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:84:23: depth_key
            	    {
            	        this->followPush(FOLLOW_depth_key_in_search_clause492);
            	        m_gPLSQLParser->depth_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:84:35: breadth_key
            	    {
            	        this->followPush(FOLLOW_breadth_key_in_search_clause496);
            	        m_gPLSQLParser->breadth_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_first_key_in_search_clause500);
            m_gPLSQLParser->first_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearch_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_by_key_in_search_clause502);
            m_gPLSQLParser->by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearch_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_search_clause517);
            m_gPLSQLParser->column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearch_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:85:26: ( asc_key )?
            {
                int alt15=2;
                {
                    int LA15_0 = this->LA(1);
                    if ( (LA15_0 == SQL92_RESERVED_ASC))
                    {
                        alt15=1;
                    }
                }
                switch (alt15)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:85:26: asc_key
            	    {
            	        this->followPush(FOLLOW_asc_key_in_search_clause519);
            	        m_gPLSQLParser->asc_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:85:36: ( desc_key )?
            {
                int alt16=2;
                {
                    int LA16_0 = this->LA(1);
                    if ( (LA16_0 == SQL92_RESERVED_DESC))
                    {
                        alt16=1;
                    }
                }
                switch (alt16)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:85:36: desc_key
            	    {
            	        this->followPush(FOLLOW_desc_key_in_search_clause523);
            	        m_gPLSQLParser->desc_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:85:47: ( nulls_key first_key )?
            {
                int alt17=2;
                {
                    int LA17_0 = this->LA(1);
                    if ( (LA17_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))))
                    {
                        {
                            int LA17_1 = this->LA(2);
                            if ( (LA17_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))))
                            {
                                {
                                    int LA17_3 = this->LA(3);
                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))
                                    {
                                        alt17=1;
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt17)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:85:48: nulls_key first_key
            	    {
            	        this->followPush(FOLLOW_nulls_key_in_search_clause528);
            	        m_gPLSQLParser->nulls_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_first_key_in_search_clause530);
            	        m_gPLSQLParser->first_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:85:70: ( nulls_key last_key )?
            {
                int alt18=2;
                alt18 = cdfa18.predict(this, this->get_rec(), this->get_istream(), cdfa18 );
                if  (this->hasException())
                {
                    goto rulesearch_clauseEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }

                switch (alt18)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:85:71: nulls_key last_key
            	    {
            	        this->followPush(FOLLOW_nulls_key_in_search_clause535);
            	        m_gPLSQLParser->nulls_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_last_key_in_search_clause537);
            	        m_gPLSQLParser->last_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:86:14: ( COMMA column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? )*

            for (;;)
            {
                int alt23=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA23_0 = this->LA(1);
                    if ( (LA23_0 == COMMA))
                    {
                        alt23=1;
                    }

                }
                switch (alt23)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:86:15: COMMA column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )?
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_search_clause555);
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_search_clause557);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:86:33: ( asc_key )?
            	        {
            	            int alt19=2;
            	            {
            	                int LA19_0 = this->LA(1);
            	                if ( (LA19_0 == SQL92_RESERVED_ASC))
            	                {
            	                    alt19=1;
            	                }
            	            }
            	            switch (alt19)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:86:33: asc_key
            	        	    {
            	        	        this->followPush(FOLLOW_asc_key_in_search_clause559);
            	        	        m_gPLSQLParser->asc_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearch_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQL_DMLParser.g:86:43: ( desc_key )?
            	        {
            	            int alt20=2;
            	            {
            	                int LA20_0 = this->LA(1);
            	                if ( (LA20_0 == SQL92_RESERVED_DESC))
            	                {
            	                    alt20=1;
            	                }
            	            }
            	            switch (alt20)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:86:43: desc_key
            	        	    {
            	        	        this->followPush(FOLLOW_desc_key_in_search_clause563);
            	        	        m_gPLSQLParser->desc_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearch_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQL_DMLParser.g:86:54: ( nulls_key first_key )?
            	        {
            	            int alt21=2;
            	            {
            	                int LA21_0 = this->LA(1);
            	                if ( (LA21_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))))
            	                {
            	                    {
            	                        int LA21_1 = this->LA(2);
            	                        if ( (LA21_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))))
            	                        {
            	                            {
            	                                int LA21_3 = this->LA(3);
            	                                if ( ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))
            	                                {
            	                                    alt21=1;
            	                                }
            	                            }
            	                        }
            	                    }
            	                }
            	            }
            	            switch (alt21)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:86:55: nulls_key first_key
            	        	    {
            	        	        this->followPush(FOLLOW_nulls_key_in_search_clause568);
            	        	        m_gPLSQLParser->nulls_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearch_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_first_key_in_search_clause570);
            	        	        m_gPLSQLParser->first_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearch_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQL_DMLParser.g:86:77: ( nulls_key last_key )?
            	        {
            	            int alt22=2;
            	            alt22 = cdfa22.predict(this, this->get_rec(), this->get_istream(), cdfa22 );
            	            if  (this->hasException())
            	            {
            	                goto rulesearch_clauseEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }

            	            switch (alt22)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:86:78: nulls_key last_key
            	        	    {
            	        	        this->followPush(FOLLOW_nulls_key_in_search_clause575);
            	        	        m_gPLSQLParser->nulls_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearch_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_last_key_in_search_clause577);
            	        	        m_gPLSQLParser->last_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearch_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop23;	/* break out of the loop */
            	    break;
                }
            }
            loop23: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_set_key_in_search_clause597);
            m_gPLSQLParser->set_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearch_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_search_clause599);
            m_gPLSQLParser->column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearch_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesearch_clauseEx; /* Prevent compiler warnings */
    rulesearch_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end search_clause */

/**
 * $ANTLR start cycle_clause
 * PLSQL_DMLParser.g:90:1: cycle_clause : cycle_key column_name ( COMMA column_name )* set_key column_name to_key expression default_key expression ;
 */
void
PLSQLParser_PLSQL_DMLParser::cycle_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:91:5: ( cycle_key column_name ( COMMA column_name )* set_key column_name to_key expression default_key expression )
        // PLSQL_DMLParser.g:91:10: cycle_key column_name ( COMMA column_name )* set_key column_name to_key expression default_key expression
        {
            this->followPush(FOLLOW_cycle_key_in_cycle_clause619);
            m_gPLSQLParser->cycle_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_cycle_clause621);
            m_gPLSQLParser->column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:91:32: ( COMMA column_name )*

            for (;;)
            {
                int alt24=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA24_0 = this->LA(1);
                    if ( (LA24_0 == COMMA))
                    {
                        alt24=1;
                    }

                }
                switch (alt24)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:91:34: COMMA column_name
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_cycle_clause625);
            	        if  (this->hasException())
            	        {
            	            goto rulecycle_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_cycle_clause627);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecycle_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop24;	/* break out of the loop */
            	    break;
                }
            }
            loop24: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_set_key_in_cycle_clause631);
            m_gPLSQLParser->set_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_cycle_clause633);
            m_gPLSQLParser->column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_to_key_in_cycle_clause635);
            m_gPLSQLParser->to_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_cycle_clause637);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_default_key_in_cycle_clause639);
            m_gPLSQLParser->default_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_cycle_clause641);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecycle_clauseEx; /* Prevent compiler warnings */
    rulecycle_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cycle_clause */

/**
 * $ANTLR start subquery
 * PLSQL_DMLParser.g:94:1: subquery : subquery_basic_elements ( subquery_operation_part )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::subquery()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:95:5: ( subquery_basic_elements ( subquery_operation_part )* )
        // PLSQL_DMLParser.g:95:10: subquery_basic_elements ( subquery_operation_part )*
        {
            this->followPush(FOLLOW_subquery_basic_elements_in_subquery661);
            subquery_basic_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubqueryEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:95:34: ( subquery_operation_part )*

            for (;;)
            {
                int alt25=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA25_0 = this->LA(1);
                    if ( (LA25_0 == PLSQL_RESERVED_MINUS || LA25_0 == SQL92_RESERVED_INTERSECT || LA25_0 == SQL92_RESERVED_UNION))
                    {
                        alt25=1;
                    }

                }
                switch (alt25)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:95:34: subquery_operation_part
            	    {
            	        this->followPush(FOLLOW_subquery_operation_part_in_subquery663);
            	        subquery_operation_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubqueryEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop25;	/* break out of the loop */
            	    break;
                }
            }
            loop25: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubqueryEx; /* Prevent compiler warnings */
    rulesubqueryEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end subquery */

/**
 * $ANTLR start subquery_operation_part
 * PLSQL_DMLParser.g:98:1: subquery_operation_part : ( union_key ( all_key )? | intersect_key | minus_key ) subquery_basic_elements ;
 */
void
PLSQLParser_PLSQL_DMLParser::subquery_operation_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:99:5: ( ( union_key ( all_key )? | intersect_key | minus_key ) subquery_basic_elements )
        // PLSQL_DMLParser.g:99:10: ( union_key ( all_key )? | intersect_key | minus_key ) subquery_basic_elements
        {
            // PLSQL_DMLParser.g:99:10: ( union_key ( all_key )? | intersect_key | minus_key )
            {
                int alt27=3;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_UNION:
                	{
                		alt27=1;
                	}
                    break;
                case SQL92_RESERVED_INTERSECT:
                	{
                		alt27=2;
                	}
                    break;
                case PLSQL_RESERVED_MINUS:
                	{
                		alt27=3;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 27 );
                    ex->set_state( 0 );


                    goto rulesubquery_operation_partEx;

                }

                switch (alt27)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:99:11: union_key ( all_key )?
            	    {
            	        this->followPush(FOLLOW_union_key_in_subquery_operation_part685);
            	        m_gPLSQLParser->union_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_operation_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:99:21: ( all_key )?
            	        {
            	            int alt26=2;
            	            {
            	                int LA26_0 = this->LA(1);
            	                if ( (LA26_0 == SQL92_RESERVED_ALL))
            	                {
            	                    alt26=1;
            	                }
            	            }
            	            switch (alt26)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:99:21: all_key
            	        	    {
            	        	        this->followPush(FOLLOW_all_key_in_subquery_operation_part687);
            	        	        m_gPLSQLParser->all_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesubquery_operation_partEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:99:30: intersect_key
            	    {
            	        this->followPush(FOLLOW_intersect_key_in_subquery_operation_part690);
            	        m_gPLSQLParser->intersect_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_operation_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQL_DMLParser.g:99:44: minus_key
            	    {
            	        this->followPush(FOLLOW_minus_key_in_subquery_operation_part692);
            	        m_gPLSQLParser->minus_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_operation_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_subquery_basic_elements_in_subquery_operation_part695);
            subquery_basic_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubquery_operation_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubquery_operation_partEx; /* Prevent compiler warnings */
    rulesubquery_operation_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end subquery_operation_part */

/**
 * $ANTLR start subquery_basic_elements
 * PLSQL_DMLParser.g:102:1: subquery_basic_elements : ( query_block | LEFT_PAREN subquery RIGHT_PAREN );
 */
void
PLSQLParser_PLSQL_DMLParser::subquery_basic_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:103:5: ( query_block | LEFT_PAREN subquery RIGHT_PAREN )

            ANTLR_UINT32 alt28;

            alt28=2;

            {
                int LA28_0 = this->LA(1);
                if ( (LA28_0 == SQL92_RESERVED_SELECT))
                {
                    alt28=1;
                }
                else if ( (LA28_0 == LEFT_PAREN))
                {
                    alt28=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 28 );
                    ex->set_state( 0 );


                    goto rulesubquery_basic_elementsEx;

                }
            }
            switch (alt28)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:103:10: query_block
        	    {
        	        this->followPush(FOLLOW_query_block_in_subquery_basic_elements715);
        	        query_block();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesubquery_basic_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:104:10: LEFT_PAREN subquery RIGHT_PAREN
        	    {
        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_subquery_basic_elements726);
        	        if  (this->hasException())
        	        {
        	            goto rulesubquery_basic_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_subquery_in_subquery_basic_elements728);
        	        subquery();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesubquery_basic_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_subquery_basic_elements730);
        	        if  (this->hasException())
        	        {
        	            goto rulesubquery_basic_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesubquery_basic_elementsEx; /* Prevent compiler warnings */
    rulesubquery_basic_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end subquery_basic_elements */

/**
 * $ANTLR start query_block
 * PLSQL_DMLParser.g:107:1: query_block : select_key ( ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key ) )? ( ASTERISK | selected_element ( COMMA selected_element )* ) ( into_clause )? from_clause ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::query_block()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:108:5: ( select_key ( ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key ) )? ( ASTERISK | selected_element ( COMMA selected_element )* ) ( into_clause )? from_clause ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? )
        // PLSQL_DMLParser.g:108:10: select_key ( ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key ) )? ( ASTERISK | selected_element ( COMMA selected_element )* ) ( into_clause )? from_clause ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )?
        {
            this->followPush(FOLLOW_select_key_in_query_block750);
            m_gPLSQLParser->select_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulequery_blockEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:109:9: ( ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key ) )?
            {
                int alt30=2;
                {
                    int LA30_0 = this->LA(1);
                    if ( (LA30_0 == SQL92_RESERVED_DISTINCT))
                    {
                        {
                            int LA30_1 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred2_PLSQL_DMLParser>() )))
                            {
                                alt30=1;
                            }
                        }
                    }
                    else if ( (LA30_0 == SQL92_RESERVED_UNIQUE) && (this->msynpred( antlr3::ClassForwarder<synpred2_PLSQL_DMLParser>() )))
                    {
                        alt30=1;
                    }
                    else if ( (LA30_0 == SQL92_RESERVED_ALL))
                    {
                        {
                            int LA30_3 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred2_PLSQL_DMLParser>() )))
                            {
                                alt30=1;
                            }
                        }
                    }
                }
                switch (alt30)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:109:10: ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key )
            	    {
            	        // PLSQL_DMLParser.g:109:46: ( distinct_key | unique_key | all_key )
            	        {
            	            int alt29=3;
            	            switch ( this->LA(1) )
            	            {
            	            case SQL92_RESERVED_DISTINCT:
            	            	{
            	            		alt29=1;
            	            	}
            	                break;
            	            case SQL92_RESERVED_UNIQUE:
            	            	{
            	            		alt29=2;
            	            	}
            	                break;
            	            case SQL92_RESERVED_ALL:
            	            	{
            	            		alt29=3;
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return ;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 29 );
            	                ex->set_state( 0 );


            	                goto rulequery_blockEx;

            	            }

            	            switch (alt29)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:109:47: distinct_key
            	        	    {
            	        	        this->followPush(FOLLOW_distinct_key_in_query_block771);
            	        	        m_gPLSQLParser->distinct_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulequery_blockEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:109:60: unique_key
            	        	    {
            	        	        this->followPush(FOLLOW_unique_key_in_query_block773);
            	        	        m_gPLSQLParser->unique_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulequery_blockEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // PLSQL_DMLParser.g:109:71: all_key
            	        	    {
            	        	        this->followPush(FOLLOW_all_key_in_query_block775);
            	        	        m_gPLSQLParser->all_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulequery_blockEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:110:9: ( ASTERISK | selected_element ( COMMA selected_element )* )
            {
                int alt32=2;
                {
                    int LA32_0 = this->LA(1);
                    if ( (LA32_0 == ASTERISK))
                    {
                        alt32=1;
                    }
                    else if ( (LA32_0 == APPROXIMATE_NUM_LIT || LA32_0 == BINDVAR || ((LA32_0 >= CHAR_STRING) && (LA32_0 <= COLON)) || LA32_0 == DELIMITED_ID || LA32_0 == EXACT_NUM_LIT || LA32_0 == INTRODUCER || LA32_0 == LEFT_PAREN || ((LA32_0 >= MINUS_SIGN) && (LA32_0 <= NATIONAL_CHAR_STRING_LIT)) || LA32_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA32_0 == PLUS_SIGN || LA32_0 == REGULAR_ID || LA32_0 == SQL92_RESERVED_ALL || LA32_0 == SQL92_RESERVED_ANY || LA32_0 == SQL92_RESERVED_CASE || ((LA32_0 >= SQL92_RESERVED_CURSOR) && (LA32_0 <= SQL92_RESERVED_DATE)) || LA32_0 == SQL92_RESERVED_DEFAULT || LA32_0 == SQL92_RESERVED_DISTINCT || ((LA32_0 >= SQL92_RESERVED_EXISTS) && (LA32_0 <= SQL92_RESERVED_FALSE)) || ((LA32_0 >= SQL92_RESERVED_NOT) && (LA32_0 <= SQL92_RESERVED_NULL)) || LA32_0 == SQL92_RESERVED_PRIOR || LA32_0 == SQL92_RESERVED_TRUE || LA32_0 == UNSIGNED_INTEGER))
                    {
                        alt32=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 32 );
                        ex->set_state( 0 );


                        goto rulequery_blockEx;

                    }
                }
                switch (alt32)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:110:10: ASTERISK
            	    {
            	         this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_query_block789);
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:110:21: selected_element ( COMMA selected_element )*
            	    {
            	        this->followPush(FOLLOW_selected_element_in_query_block793);
            	        selected_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:110:38: ( COMMA selected_element )*

            	        for (;;)
            	        {
            	            int alt31=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA31_0 = this->LA(1);
            	                if ( (LA31_0 == COMMA))
            	                {
            	                    alt31=1;
            	                }

            	            }
            	            switch (alt31)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:110:39: COMMA selected_element
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_query_block796);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulequery_blockEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_selected_element_in_query_block798);
            	        	        selected_element();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulequery_blockEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop31;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop31: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:111:9: ( into_clause )?
            {
                int alt33=2;
                {
                    int LA33_0 = this->LA(1);
                    if ( (LA33_0 == SQL92_RESERVED_INTO))
                    {
                        alt33=1;
                    }
                    else if ( (LA33_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "BULK"))))
                    {
                        alt33=1;
                    }
                }
                switch (alt33)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:111:9: into_clause
            	    {
            	        this->followPush(FOLLOW_into_clause_in_query_block811);
            	        m_gPLSQLParser->into_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_from_clause_in_query_block822);
            from_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulequery_blockEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:113:9: ( where_clause )?
            {
                int alt34=2;
                {
                    int LA34_0 = this->LA(1);
                    if ( (LA34_0 == SQL92_RESERVED_WHERE))
                    {
                        alt34=1;
                    }
                }
                switch (alt34)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:113:9: where_clause
            	    {
            	        this->followPush(FOLLOW_where_clause_in_query_block833);
            	        m_gPLSQLParser->where_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:114:9: ( hierarchical_query_clause )?
            {
                int alt35=2;
                {
                    int LA35_0 = this->LA(1);
                    if ( (LA35_0 == SQL92_RESERVED_CONNECT))
                    {
                        alt35=1;
                    }
                    else if ( (LA35_0 == PLSQL_RESERVED_START))
                    {
                        alt35=1;
                    }
                }
                switch (alt35)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:114:9: hierarchical_query_clause
            	    {
            	        this->followPush(FOLLOW_hierarchical_query_clause_in_query_block845);
            	        hierarchical_query_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:115:9: ( group_by_clause )?
            {
                int alt36=2;
                {
                    int LA36_0 = this->LA(1);
                    if ( (LA36_0 == SQL92_RESERVED_GROUP))
                    {
                        alt36=1;
                    }
                    else if ( (LA36_0 == SQL92_RESERVED_HAVING))
                    {
                        alt36=1;
                    }
                }
                switch (alt36)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:115:9: group_by_clause
            	    {
            	        this->followPush(FOLLOW_group_by_clause_in_query_block857);
            	        group_by_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:116:9: ( model_clause )?
            {
                int alt37=2;
                {
                    int LA37_0 = this->LA(1);
                    if ( (LA37_0 == PLSQL_NON_RESERVED_MODEL))
                    {
                        alt37=1;
                    }
                }
                switch (alt37)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:116:9: model_clause
            	    {
            	        this->followPush(FOLLOW_model_clause_in_query_block868);
            	        model_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulequery_blockEx; /* Prevent compiler warnings */
    rulequery_blockEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end query_block */

/**
 * $ANTLR start selected_element
 * PLSQL_DMLParser.g:119:1: selected_element : select_list_elements ( column_alias )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::selected_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:120:5: ( select_list_elements ( column_alias )? )
        // PLSQL_DMLParser.g:120:10: select_list_elements ( column_alias )?
        {
            this->followPush(FOLLOW_select_list_elements_in_selected_element889);
            select_list_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleselected_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:120:31: ( column_alias )?
            {
                int alt38=2;
                {
                    int LA38_0 = this->LA(1);
                    if ( (((LA38_0 >= CHAR_STRING) && (LA38_0 <= CHAR_STRING_PERL)) || LA38_0 == DELIMITED_ID || LA38_0 == INTRODUCER || LA38_0 == NATIONAL_CHAR_STRING_LIT || LA38_0 == SQL92_RESERVED_AS))
                    {
                        alt38=1;
                    }
                    else if ( (LA38_0 == REGULAR_ID))
                    {
                        {
                            int LA38_2 = this->LA(2);
                            if ( (LA38_2 == COMMA || LA38_2 == SQL92_RESERVED_FROM || LA38_2 == SQL92_RESERVED_INTO))
                            {
                                alt38=1;
                            }
                            else if ( (LA38_2 == REGULAR_ID))
                            {
                                {
                                    int LA38_4 = this->LA(3);
                                    if ( (LA38_4 == REGULAR_ID))
                                    {
                                        alt38=1;
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt38)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:120:31: column_alias
            	    {
            	        this->followPush(FOLLOW_column_alias_in_selected_element891);
            	        m_gPLSQLParser->column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleselected_elementEx; /* Prevent compiler warnings */
    ruleselected_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end selected_element */

/**
 * $ANTLR start from_clause
 * PLSQL_DMLParser.g:123:1: from_clause : from_key table_ref_list ;
 */
void
PLSQLParser_PLSQL_DMLParser::from_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:124:5: ( from_key table_ref_list )
        // PLSQL_DMLParser.g:124:10: from_key table_ref_list
        {
            this->followPush(FOLLOW_from_key_in_from_clause912);
            m_gPLSQLParser->from_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefrom_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_table_ref_list_in_from_clause914);
            table_ref_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefrom_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefrom_clauseEx; /* Prevent compiler warnings */
    rulefrom_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end from_clause */

/**
 * $ANTLR start select_list_elements
 * PLSQL_DMLParser.g:127:1: select_list_elements : ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK | expression );
 */
void
PLSQLParser_PLSQL_DMLParser::select_list_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:128:5: ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK | expression )

            ANTLR_UINT32 alt39;

            alt39=2;

            switch ( this->LA(1) )
            {
            case INTRODUCER:
            	{
            		{
            		    int LA39_1 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_PLSQL_DMLParser>() )))
            		    {
            		        alt39=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt39=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 39 );
            		        ex->set_state( 1 );


            		        goto ruleselect_list_elementsEx;

            		    }
            		}
            	}
                break;
            case REGULAR_ID:
            	{
            		{
            		    int LA39_2 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_PLSQL_DMLParser>() )))
            		    {
            		        alt39=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt39=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 39 );
            		        ex->set_state( 2 );


            		        goto ruleselect_list_elementsEx;

            		    }
            		}
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case EXACT_NUM_LIT:
            case LEFT_PAREN:
            case MINUS_SIGN:
            case NATIONAL_CHAR_STRING_LIT:
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            case PLUS_SIGN:
            case SQL92_RESERVED_ALL:
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_CASE:
            case SQL92_RESERVED_CURSOR:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_DISTINCT:
            case SQL92_RESERVED_EXISTS:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NOT:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_PRIOR:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt39=2;
            	}
                break;
            case DELIMITED_ID:
            	{
            		{
            		    int LA39_9 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_PLSQL_DMLParser>() )))
            		    {
            		        alt39=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt39=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 39 );
            		        ex->set_state( 9 );


            		        goto ruleselect_list_elementsEx;

            		    }
            		}
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 39 );
                ex->set_state( 0 );


                goto ruleselect_list_elementsEx;

            }

            switch (alt39)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:128:10: ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK
        	    {
        	        this->followPush(FOLLOW_tableview_name_in_select_list_elements943);
        	        m_gPLSQLParser->tableview_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleselect_list_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_select_list_elements945);
        	        if  (this->hasException())
        	        {
        	            goto ruleselect_list_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_select_list_elements947);
        	        if  (this->hasException())
        	        {
        	            goto ruleselect_list_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:129:10: expression
        	    {
        	        this->followPush(FOLLOW_expression_in_select_list_elements958);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleselect_list_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleselect_list_elementsEx; /* Prevent compiler warnings */
    ruleselect_list_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end select_list_elements */

/**
 * $ANTLR start table_ref_list
 * PLSQL_DMLParser.g:132:1: table_ref_list : table_ref ( COMMA table_ref )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::table_ref_list()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:133:5: ( table_ref ( COMMA table_ref )* )
        // PLSQL_DMLParser.g:133:10: table_ref ( COMMA table_ref )*
        {
            this->followPush(FOLLOW_table_ref_in_table_ref_list978);
            table_ref();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_ref_listEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:133:20: ( COMMA table_ref )*

            for (;;)
            {
                int alt40=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA40_0 = this->LA(1);
                    if ( (LA40_0 == COMMA))
                    {
                        alt40=1;
                    }

                }
                switch (alt40)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:133:21: COMMA table_ref
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_table_ref_list981);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_table_ref_in_table_ref_list983);
            	        table_ref();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop40;	/* break out of the loop */
            	    break;
                }
            }
            loop40: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_ref_listEx; /* Prevent compiler warnings */
    ruletable_ref_listEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_ref_list */

/**
 * $ANTLR start table_ref
 * PLSQL_DMLParser.g:140:1: table_ref : table_ref_aux ( join_clause )* ( pivot_clause | unpivot_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::table_ref()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:141:5: ( table_ref_aux ( join_clause )* ( pivot_clause | unpivot_clause )? )
        // PLSQL_DMLParser.g:141:10: table_ref_aux ( join_clause )* ( pivot_clause | unpivot_clause )?
        {
            this->followPush(FOLLOW_table_ref_aux_in_table_ref1009);
            table_ref_aux();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_refEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:141:24: ( join_clause )*

            for (;;)
            {
                int alt41=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA41_0 = this->LA(1);
                    if ( (LA41_0 == REGULAR_ID))
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA41_2 = this->LA(2);
                            if ( ((((equalsIgnoreCase(LT(1)->getText(), "FULL")))||((equalsIgnoreCase(LT(1)->getText(), "JOIN")))||((equalsIgnoreCase(LT(1)->getText(), "RIGHT")))||((equalsIgnoreCase(LT(1)->getText(), "INNER")))||((equalsIgnoreCase(LT(1)->getText(), "PARTITION")))||((equalsIgnoreCase(LT(1)->getText(), "LEFT")))||((equalsIgnoreCase(LT(1)->getText(), "CROSS")))||((equalsIgnoreCase(LT(1)->getText(), "NATURAL"))))))
                            {
                                alt41=1;
                            }

                        }
                    }

                }
                switch (alt41)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:141:24: join_clause
            	    {
            	        this->followPush(FOLLOW_join_clause_in_table_ref1011);
            	        join_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop41;	/* break out of the loop */
            	    break;
                }
            }
            loop41: ; /* Jump out to here if this rule does not match */


            // PLSQL_DMLParser.g:141:37: ( pivot_clause | unpivot_clause )?
            {
                int alt42=3;
                {
                    int LA42_0 = this->LA(1);
                    if ( (LA42_0 == PLSQL_NON_RESERVED_PIVOT))
                    {
                        alt42=1;
                    }
                    else if ( (LA42_0 == PLSQL_NON_RESERVED_UNPIVOT))
                    {
                        alt42=2;
                    }
                }
                switch (alt42)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:141:38: pivot_clause
            	    {
            	        this->followPush(FOLLOW_pivot_clause_in_table_ref1015);
            	        pivot_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:141:51: unpivot_clause
            	    {
            	        this->followPush(FOLLOW_unpivot_clause_in_table_ref1017);
            	        unpivot_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_refEx; /* Prevent compiler warnings */
    ruletable_refEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_ref */

/**
 * $ANTLR start table_ref_aux
 * PLSQL_DMLParser.g:144:1: table_ref_aux : ( ( LEFT_PAREN ( select_key | with_key ) )=> dml_table_expression_clause ( pivot_clause | unpivot_clause )? | ( LEFT_PAREN )=> LEFT_PAREN table_ref ( subquery_operation_part )* RIGHT_PAREN ( pivot_clause | unpivot_clause )? | ( only_key LEFT_PAREN )=> only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN | dml_table_expression_clause ( pivot_clause | unpivot_clause )? ) ( flashback_query_clause )* ({...}? table_alias )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::table_ref_aux()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:145:5: ( ( ( LEFT_PAREN ( select_key | with_key ) )=> dml_table_expression_clause ( pivot_clause | unpivot_clause )? | ( LEFT_PAREN )=> LEFT_PAREN table_ref ( subquery_operation_part )* RIGHT_PAREN ( pivot_clause | unpivot_clause )? | ( only_key LEFT_PAREN )=> only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN | dml_table_expression_clause ( pivot_clause | unpivot_clause )? ) ( flashback_query_clause )* ({...}? table_alias )? )
        // PLSQL_DMLParser.g:146:5: ( ( LEFT_PAREN ( select_key | with_key ) )=> dml_table_expression_clause ( pivot_clause | unpivot_clause )? | ( LEFT_PAREN )=> LEFT_PAREN table_ref ( subquery_operation_part )* RIGHT_PAREN ( pivot_clause | unpivot_clause )? | ( only_key LEFT_PAREN )=> only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN | dml_table_expression_clause ( pivot_clause | unpivot_clause )? ) ( flashback_query_clause )* ({...}? table_alias )?
        {
            // PLSQL_DMLParser.g:146:5: ( ( LEFT_PAREN ( select_key | with_key ) )=> dml_table_expression_clause ( pivot_clause | unpivot_clause )? | ( LEFT_PAREN )=> LEFT_PAREN table_ref ( subquery_operation_part )* RIGHT_PAREN ( pivot_clause | unpivot_clause )? | ( only_key LEFT_PAREN )=> only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN | dml_table_expression_clause ( pivot_clause | unpivot_clause )? )
            {
                int alt47=4;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_TABLE:
                	{
                		{
                		    int LA47_1 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_PLSQL_DMLParser>() )))
                		    {
                		        alt47=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt47=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 47 );
                		        ex->set_state( 1 );


                		        goto ruletable_ref_auxEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_THE:
                	{
                		{
                		    int LA47_2 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_PLSQL_DMLParser>() )))
                		    {
                		        alt47=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt47=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 47 );
                		        ex->set_state( 2 );


                		        goto ruletable_ref_auxEx;

                		    }
                		}
                	}
                    break;
                case LEFT_PAREN:
                	{
                		{
                		    int LA47_3 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_PLSQL_DMLParser>() )))
                		    {
                		        alt47=1;
                		    }
                		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred5_PLSQL_DMLParser>() )))
                		    {
                		        alt47=2;
                		    }
                		    else if ( (true))
                		    {
                		        alt47=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 47 );
                		        ex->set_state( 3 );


                		        goto ruletable_ref_auxEx;

                		    }
                		}
                	}
                    break;
                case INTRODUCER:
                	{
                		{
                		    int LA47_4 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_PLSQL_DMLParser>() )))
                		    {
                		        alt47=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt47=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 47 );
                		        ex->set_state( 4 );


                		        goto ruletable_ref_auxEx;

                		    }
                		}
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    int LA47_5 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_PLSQL_DMLParser>() )))
                		    {
                		        alt47=1;
                		    }
                		    else if ( (( (this->msynpred( antlr3::ClassForwarder<synpred6_PLSQL_DMLParser>() )) && ((equalsIgnoreCase(LT(1)->getText(), "ONLY"))) )))
                		    {
                		        alt47=3;
                		    }
                		    else if ( (true))
                		    {
                		        alt47=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 47 );
                		        ex->set_state( 5 );


                		        goto ruletable_ref_auxEx;

                		    }
                		}
                	}
                    break;
                case DELIMITED_ID:
                	{
                		{
                		    int LA47_6 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_PLSQL_DMLParser>() )))
                		    {
                		        alt47=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt47=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 47 );
                		        ex->set_state( 6 );


                		        goto ruletable_ref_auxEx;

                		    }
                		}
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 47 );
                    ex->set_state( 0 );


                    goto ruletable_ref_auxEx;

                }

                switch (alt47)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:146:10: ( LEFT_PAREN ( select_key | with_key ) )=> dml_table_expression_clause ( pivot_clause | unpivot_clause )?
            	    {
            	        this->followPush(FOLLOW_dml_table_expression_clause_in_table_ref_aux1057);
            	        dml_table_expression_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:146:76: ( pivot_clause | unpivot_clause )?
            	        {
            	            int alt43=3;
            	            alt43 = cdfa43.predict(this, this->get_rec(), this->get_istream(), cdfa43 );
            	            if  (this->hasException())
            	            {
            	                goto ruletable_ref_auxEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }

            	            switch (alt43)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:146:77: pivot_clause
            	        	    {
            	        	        this->followPush(FOLLOW_pivot_clause_in_table_ref_aux1060);
            	        	        pivot_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletable_ref_auxEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:146:90: unpivot_clause
            	        	    {
            	        	        this->followPush(FOLLOW_unpivot_clause_in_table_ref_aux1062);
            	        	        unpivot_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletable_ref_auxEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:147:10: ( LEFT_PAREN )=> LEFT_PAREN table_ref ( subquery_operation_part )* RIGHT_PAREN ( pivot_clause | unpivot_clause )?
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_table_ref_aux1081);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_table_ref_in_table_ref_aux1083);
            	        table_ref();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:147:47: ( subquery_operation_part )*

            	        for (;;)
            	        {
            	            int alt44=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA44_0 = this->LA(1);
            	                if ( (LA44_0 == PLSQL_RESERVED_MINUS || LA44_0 == SQL92_RESERVED_INTERSECT || LA44_0 == SQL92_RESERVED_UNION))
            	                {
            	                    alt44=1;
            	                }

            	            }
            	            switch (alt44)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:147:47: subquery_operation_part
            	        	    {
            	        	        this->followPush(FOLLOW_subquery_operation_part_in_table_ref_aux1085);
            	        	        subquery_operation_part();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletable_ref_auxEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop44;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop44: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_table_ref_aux1088);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:147:84: ( pivot_clause | unpivot_clause )?
            	        {
            	            int alt45=3;
            	            alt45 = cdfa45.predict(this, this->get_rec(), this->get_istream(), cdfa45 );
            	            if  (this->hasException())
            	            {
            	                goto ruletable_ref_auxEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }

            	            switch (alt45)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:147:85: pivot_clause
            	        	    {
            	        	        this->followPush(FOLLOW_pivot_clause_in_table_ref_aux1091);
            	        	        pivot_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletable_ref_auxEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:147:98: unpivot_clause
            	        	    {
            	        	        this->followPush(FOLLOW_unpivot_clause_in_table_ref_aux1093);
            	        	        unpivot_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletable_ref_auxEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 3:
            	    // PLSQL_DMLParser.g:148:10: ( only_key LEFT_PAREN )=> only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN
            	    {
            	        this->followPush(FOLLOW_only_key_in_table_ref_aux1114);
            	        m_gPLSQLParser->only_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_table_ref_aux1116);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_dml_table_expression_clause_in_table_ref_aux1118);
            	        dml_table_expression_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_table_ref_aux1120);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 4:
            	    // PLSQL_DMLParser.g:149:10: dml_table_expression_clause ( pivot_clause | unpivot_clause )?
            	    {
            	        this->followPush(FOLLOW_dml_table_expression_clause_in_table_ref_aux1131);
            	        dml_table_expression_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:149:38: ( pivot_clause | unpivot_clause )?
            	        {
            	            int alt46=3;
            	            alt46 = cdfa46.predict(this, this->get_rec(), this->get_istream(), cdfa46 );
            	            if  (this->hasException())
            	            {
            	                goto ruletable_ref_auxEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }

            	            switch (alt46)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:149:39: pivot_clause
            	        	    {
            	        	        this->followPush(FOLLOW_pivot_clause_in_table_ref_aux1134);
            	        	        pivot_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletable_ref_auxEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:149:52: unpivot_clause
            	        	    {
            	        	        this->followPush(FOLLOW_unpivot_clause_in_table_ref_aux1136);
            	        	        unpivot_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletable_ref_auxEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:151:9: ( flashback_query_clause )*

            for (;;)
            {
                int alt48=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA48_0 = this->LA(1);
                    if ( (LA48_0 == REGULAR_ID))
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA48_2 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "VERSIONS"))))
                            {
                                alt48=1;
                            }

                        }
                    }
                    else if ( (LA48_0 == SQL92_RESERVED_AS))
                    {
                        alt48=1;
                    }

                }
                switch (alt48)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:151:9: flashback_query_clause
            	    {
            	        this->followPush(FOLLOW_flashback_query_clause_in_table_ref_aux1154);
            	        flashback_query_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop48;	/* break out of the loop */
            	    break;
                }
            }
            loop48: ; /* Jump out to here if this rule does not match */


            // PLSQL_DMLParser.g:152:9: ({...}? table_alias )?
            {
                int alt49=2;
                switch ( this->LA(1) )
                {
                    case INTRODUCER:
                    	{
                    		{
                    		    int LA49_1 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt49=1;
                    		    }
                    		}
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA49_2 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt49=1;
                    		    }
                    		}
                    	}
                        break;
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case NATIONAL_CHAR_STRING_LIT:
                    	{
                    		{
                    		    int LA49_3 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt49=1;
                    		    }
                    		}
                    	}
                        break;
                    case DELIMITED_ID:
                    	{
                    		{
                    		    int LA49_4 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt49=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt49)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:152:10: {...}? table_alias
            	    {
            	        if ( !((isTableAlias(LT(1), LT(2)))) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return ;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "isTableAlias(LT(1), LT(2))" );
            	                ex->set_ruleName( "table_ref_aux" );


            	        }

            	        this->followPush(FOLLOW_table_alias_in_table_ref_aux1168);
            	        m_gPLSQLParser->table_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_ref_auxEx; /* Prevent compiler warnings */
    ruletable_ref_auxEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_ref_aux */

/**
 * $ANTLR start join_clause
 * PLSQL_DMLParser.g:155:1: join_clause : ( query_partition_clause )? ( cross_key | natural_key )? ( inner_key | outer_join_type )? join_key table_ref_aux ( query_partition_clause )? ( join_on_part | join_using_part )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::join_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:156:5: ( ( query_partition_clause )? ( cross_key | natural_key )? ( inner_key | outer_join_type )? join_key table_ref_aux ( query_partition_clause )? ( join_on_part | join_using_part )* )
        // PLSQL_DMLParser.g:156:10: ( query_partition_clause )? ( cross_key | natural_key )? ( inner_key | outer_join_type )? join_key table_ref_aux ( query_partition_clause )? ( join_on_part | join_using_part )*
        {
            // PLSQL_DMLParser.g:156:10: ( query_partition_clause )?
            {
                int alt50=2;
                {
                    int LA50_0 = this->LA(1);
                    if ( (LA50_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FULL")))||((equalsIgnoreCase(LT(1)->getText(), "JOIN")))||((equalsIgnoreCase(LT(1)->getText(), "RIGHT")))||((equalsIgnoreCase(LT(1)->getText(), "INNER")))||((equalsIgnoreCase(LT(1)->getText(), "PARTITION")))||((equalsIgnoreCase(LT(1)->getText(), "CROSS")))||((equalsIgnoreCase(LT(1)->getText(), "LEFT")))||((equalsIgnoreCase(LT(1)->getText(), "NATURAL"))))))
                    {
                        {
                            int LA50_1 = this->LA(2);
                            if ( (LA50_1 == SQL92_RESERVED_BY) && ((equalsIgnoreCase(LT(1)->getText(), "PARTITION"))))
                            {
                                alt50=1;
                            }
                        }
                    }
                }
                switch (alt50)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:156:10: query_partition_clause
            	    {
            	        this->followPush(FOLLOW_query_partition_clause_in_join_clause1190);
            	        query_partition_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:157:9: ( cross_key | natural_key )?
            {
                int alt51=3;
                {
                    int LA51_0 = this->LA(1);
                    if ( (LA51_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FULL")))||((equalsIgnoreCase(LT(1)->getText(), "JOIN")))||((equalsIgnoreCase(LT(1)->getText(), "RIGHT")))||((equalsIgnoreCase(LT(1)->getText(), "INNER")))||((equalsIgnoreCase(LT(1)->getText(), "LEFT")))||((equalsIgnoreCase(LT(1)->getText(), "CROSS")))||((equalsIgnoreCase(LT(1)->getText(), "NATURAL"))))))
                    {
                        {
                            int LA51_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "CROSS"))))
                            {
                                alt51=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "NATURAL"))))
                            {
                                alt51=2;
                            }
                        }
                    }
                }
                switch (alt51)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:157:10: cross_key
            	    {
            	        this->followPush(FOLLOW_cross_key_in_join_clause1202);
            	        m_gPLSQLParser->cross_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:157:20: natural_key
            	    {
            	        this->followPush(FOLLOW_natural_key_in_join_clause1204);
            	        m_gPLSQLParser->natural_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:157:34: ( inner_key | outer_join_type )?
            {
                int alt52=3;
                {
                    int LA52_0 = this->LA(1);
                    if ( (LA52_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FULL")))||((equalsIgnoreCase(LT(1)->getText(), "JOIN")))||((equalsIgnoreCase(LT(1)->getText(), "RIGHT")))||((equalsIgnoreCase(LT(1)->getText(), "INNER")))||((equalsIgnoreCase(LT(1)->getText(), "LEFT"))))))
                    {
                        {
                            int LA52_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "INNER"))))
                            {
                                alt52=1;
                            }
                            else if ( ((((equalsIgnoreCase(LT(1)->getText(), "FULL")))||((equalsIgnoreCase(LT(1)->getText(), "RIGHT")))||((equalsIgnoreCase(LT(1)->getText(), "LEFT"))))))
                            {
                                alt52=2;
                            }
                        }
                    }
                }
                switch (alt52)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:157:35: inner_key
            	    {
            	        this->followPush(FOLLOW_inner_key_in_join_clause1209);
            	        m_gPLSQLParser->inner_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:157:45: outer_join_type
            	    {
            	        this->followPush(FOLLOW_outer_join_type_in_join_clause1211);
            	        outer_join_type();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_join_key_in_join_clause1215);
            m_gPLSQLParser->join_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejoin_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_table_ref_aux_in_join_clause1225);
            table_ref_aux();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejoin_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:159:9: ( query_partition_clause )?
            {
                int alt53=2;
                {
                    int LA53_0 = this->LA(1);
                    if ( (LA53_0 == REGULAR_ID))
                    {
                        {
                            int LA53_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "PARTITION"))))
                            {
                                alt53=1;
                            }
                        }
                    }
                }
                switch (alt53)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:159:9: query_partition_clause
            	    {
            	        this->followPush(FOLLOW_query_partition_clause_in_join_clause1235);
            	        query_partition_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:160:5: ( join_on_part | join_using_part )*

            for (;;)
            {
                int alt54=3;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA54_0 = this->LA(1);
                    if ( (LA54_0 == PLSQL_NON_RESERVED_USING))
                    {
                        alt54=2;
                    }
                    else if ( (LA54_0 == SQL92_RESERVED_ON))
                    {
                        alt54=1;
                    }

                }
                switch (alt54)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:160:10: join_on_part
            	    {
            	        this->followPush(FOLLOW_join_on_part_in_join_clause1247);
            	        join_on_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:161:10: join_using_part
            	    {
            	        this->followPush(FOLLOW_join_using_part_in_join_clause1258);
            	        join_using_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop54;	/* break out of the loop */
            	    break;
                }
            }
            loop54: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulejoin_clauseEx; /* Prevent compiler warnings */
    rulejoin_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end join_clause */

/**
 * $ANTLR start join_on_part
 * PLSQL_DMLParser.g:165:1: join_on_part : on_key condition ;
 */
void
PLSQLParser_PLSQL_DMLParser::join_on_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:166:5: ( on_key condition )
        // PLSQL_DMLParser.g:166:10: on_key condition
        {
            this->followPush(FOLLOW_on_key_in_join_on_part1285);
            m_gPLSQLParser->on_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejoin_on_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_condition_in_join_on_part1287);
            condition();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejoin_on_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulejoin_on_partEx; /* Prevent compiler warnings */
    rulejoin_on_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end join_on_part */

/**
 * $ANTLR start join_using_part
 * PLSQL_DMLParser.g:169:1: join_using_part : using_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::join_using_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:170:5: ( using_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
        // PLSQL_DMLParser.g:170:10: using_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
        {
            this->followPush(FOLLOW_using_key_in_join_using_part1307);
            m_gPLSQLParser->using_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejoin_using_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_join_using_part1309);
            if  (this->hasException())
            {
                goto rulejoin_using_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_join_using_part1311);
            m_gPLSQLParser->column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejoin_using_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:170:43: ( COMMA column_name )*

            for (;;)
            {
                int alt55=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA55_0 = this->LA(1);
                    if ( (LA55_0 == COMMA))
                    {
                        alt55=1;
                    }

                }
                switch (alt55)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:170:44: COMMA column_name
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_join_using_part1314);
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_using_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_join_using_part1316);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_using_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop55;	/* break out of the loop */
            	    break;
                }
            }
            loop55: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_join_using_part1320);
            if  (this->hasException())
            {
                goto rulejoin_using_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulejoin_using_partEx; /* Prevent compiler warnings */
    rulejoin_using_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end join_using_part */

/**
 * $ANTLR start outer_join_type
 * PLSQL_DMLParser.g:173:1: outer_join_type : ( full_key | left_key | right_key ) ( outer_key )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::outer_join_type()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:174:5: ( ( full_key | left_key | right_key ) ( outer_key )? )
        // PLSQL_DMLParser.g:175:5: ( full_key | left_key | right_key ) ( outer_key )?
        {
            // PLSQL_DMLParser.g:175:5: ( full_key | left_key | right_key )
            {
                int alt56=3;
                {
                    int LA56_0 = this->LA(1);
                    if ( (LA56_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FULL")))||((equalsIgnoreCase(LT(1)->getText(), "RIGHT")))||((equalsIgnoreCase(LT(1)->getText(), "LEFT"))))))
                    {
                        {
                            int LA56_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "FULL"))))
                            {
                                alt56=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "LEFT"))))
                            {
                                alt56=2;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "RIGHT"))))
                            {
                                alt56=3;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 56 );
                                ex->set_state( 1 );


                                goto ruleouter_join_typeEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 56 );
                        ex->set_state( 0 );


                        goto ruleouter_join_typeEx;

                    }
                }
                switch (alt56)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:175:10: full_key
            	    {
            	        this->followPush(FOLLOW_full_key_in_outer_join_type1350);
            	        m_gPLSQLParser->full_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleouter_join_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:176:10: left_key
            	    {
            	        this->followPush(FOLLOW_left_key_in_outer_join_type1361);
            	        m_gPLSQLParser->left_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleouter_join_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQL_DMLParser.g:177:10: right_key
            	    {
            	        this->followPush(FOLLOW_right_key_in_outer_join_type1372);
            	        m_gPLSQLParser->right_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleouter_join_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:179:9: ( outer_key )?
            {
                int alt57=2;
                {
                    int LA57_0 = this->LA(1);
                    if ( (LA57_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "OUTER")))||((equalsIgnoreCase(LT(1)->getText(), "JOIN"))))))
                    {
                        {
                            int LA57_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "OUTER"))))
                            {
                                alt57=1;
                            }
                        }
                    }
                }
                switch (alt57)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:179:9: outer_key
            	    {
            	        this->followPush(FOLLOW_outer_key_in_outer_join_type1388);
            	        m_gPLSQLParser->outer_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleouter_join_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleouter_join_typeEx; /* Prevent compiler warnings */
    ruleouter_join_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end outer_join_type */

/**
 * $ANTLR start query_partition_clause
 * PLSQL_DMLParser.g:182:1: query_partition_clause : partition_key by_key ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | ( LEFT_PAREN )=> expression_list | expression ( COMMA expression )* ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::query_partition_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:183:5: ( partition_key by_key ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | ( LEFT_PAREN )=> expression_list | expression ( COMMA expression )* ) )
        // PLSQL_DMLParser.g:183:10: partition_key by_key ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | ( LEFT_PAREN )=> expression_list | expression ( COMMA expression )* )
        {
            this->followPush(FOLLOW_partition_key_in_query_partition_clause1409);
            m_gPLSQLParser->partition_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulequery_partition_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_by_key_in_query_partition_clause1411);
            m_gPLSQLParser->by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulequery_partition_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:184:5: ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | ( LEFT_PAREN )=> expression_list | expression ( COMMA expression )* )
            {
                int alt59=3;
                {
                    int LA59_0 = this->LA(1);
                    if ( (LA59_0 == LEFT_PAREN))
                    {
                        {
                            int LA59_1 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred7_PLSQL_DMLParser>() )))
                            {
                                alt59=1;
                            }
                            else if ( (this->msynpred( antlr3::ClassForwarder<synpred8_PLSQL_DMLParser>() )))
                            {
                                alt59=2;
                            }
                            else if ( (true))
                            {
                                alt59=3;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 59 );
                                ex->set_state( 1 );


                                goto rulequery_partition_clauseEx;

                            }
                        }
                    }
                    else if ( (LA59_0 == APPROXIMATE_NUM_LIT || LA59_0 == BINDVAR || ((LA59_0 >= CHAR_STRING) && (LA59_0 <= COLON)) || LA59_0 == DELIMITED_ID || LA59_0 == EXACT_NUM_LIT || LA59_0 == INTRODUCER || ((LA59_0 >= MINUS_SIGN) && (LA59_0 <= NATIONAL_CHAR_STRING_LIT)) || LA59_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA59_0 == PLUS_SIGN || LA59_0 == REGULAR_ID || LA59_0 == SQL92_RESERVED_ALL || LA59_0 == SQL92_RESERVED_ANY || LA59_0 == SQL92_RESERVED_CASE || ((LA59_0 >= SQL92_RESERVED_CURSOR) && (LA59_0 <= SQL92_RESERVED_DATE)) || LA59_0 == SQL92_RESERVED_DEFAULT || LA59_0 == SQL92_RESERVED_DISTINCT || ((LA59_0 >= SQL92_RESERVED_EXISTS) && (LA59_0 <= SQL92_RESERVED_FALSE)) || ((LA59_0 >= SQL92_RESERVED_NOT) && (LA59_0 <= SQL92_RESERVED_NULL)) || LA59_0 == SQL92_RESERVED_PRIOR || LA59_0 == SQL92_RESERVED_TRUE || LA59_0 == UNSIGNED_INTEGER))
                    {
                        alt59=3;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 59 );
                        ex->set_state( 0 );


                        goto rulequery_partition_clauseEx;

                    }
                }
                switch (alt59)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:184:10: ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_query_partition_clause1434);
            	        if  (this->hasException())
            	        {
            	            goto rulequery_partition_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_subquery_in_query_partition_clause1436);
            	        subquery();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_partition_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_query_partition_clause1438);
            	        if  (this->hasException())
            	        {
            	            goto rulequery_partition_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:185:10: ( LEFT_PAREN )=> expression_list
            	    {
            	        this->followPush(FOLLOW_expression_list_in_query_partition_clause1454);
            	        expression_list();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_partition_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQL_DMLParser.g:186:10: expression ( COMMA expression )*
            	    {
            	        this->followPush(FOLLOW_expression_in_query_partition_clause1465);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_partition_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:186:21: ( COMMA expression )*

            	        for (;;)
            	        {
            	            int alt58=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA58_0 = this->LA(1);
            	                if ( (LA58_0 == COMMA))
            	                {
            	                    alt58=1;
            	                }

            	            }
            	            switch (alt58)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:186:22: COMMA expression
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_query_partition_clause1468);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulequery_partition_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_expression_in_query_partition_clause1470);
            	        	        expression();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulequery_partition_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop58;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop58: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulequery_partition_clauseEx; /* Prevent compiler warnings */
    rulequery_partition_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end query_partition_clause */

/**
 * $ANTLR start flashback_query_clause
 * PLSQL_DMLParser.g:190:1: flashback_query_clause : ( versions_key between_key ( scn_key | timestamp_key ) expression | as_key of_key ( scn_key | timestamp_key | snapshot_key ) expression );
 */
void
PLSQLParser_PLSQL_DMLParser::flashback_query_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:191:5: ( versions_key between_key ( scn_key | timestamp_key ) expression | as_key of_key ( scn_key | timestamp_key | snapshot_key ) expression )

            ANTLR_UINT32 alt62;

            alt62=2;

            {
                int LA62_0 = this->LA(1);
                if ( (LA62_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "VERSIONS"))))
                {
                    alt62=1;
                }
                else if ( (LA62_0 == SQL92_RESERVED_AS))
                {
                    alt62=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 62 );
                    ex->set_state( 0 );


                    goto ruleflashback_query_clauseEx;

                }
            }
            switch (alt62)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:191:10: versions_key between_key ( scn_key | timestamp_key ) expression
        	    {
        	        this->followPush(FOLLOW_versions_key_in_flashback_query_clause1498);
        	        m_gPLSQLParser->versions_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleflashback_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_between_key_in_flashback_query_clause1500);
        	        m_gPLSQLParser->between_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleflashback_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:191:35: ( scn_key | timestamp_key )
        	        {
        	            int alt60=2;
        	            {
        	                int LA60_0 = this->LA(1);
        	                if ( (LA60_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA60_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "SCN"))))
        	                        {
        	                            alt60=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP"))))
        	                        {
        	                            alt60=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 60 );
        	                            ex->set_state( 1 );


        	                            goto ruleflashback_query_clauseEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 60 );
        	                    ex->set_state( 0 );


        	                    goto ruleflashback_query_clauseEx;

        	                }
        	            }
        	            switch (alt60)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:191:36: scn_key
        	        	    {
        	        	        this->followPush(FOLLOW_scn_key_in_flashback_query_clause1503);
        	        	        m_gPLSQLParser->scn_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleflashback_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:191:44: timestamp_key
        	        	    {
        	        	        this->followPush(FOLLOW_timestamp_key_in_flashback_query_clause1505);
        	        	        m_gPLSQLParser->timestamp_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleflashback_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_expression_in_flashback_query_clause1508);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleflashback_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:192:10: as_key of_key ( scn_key | timestamp_key | snapshot_key ) expression
        	    {
        	        this->followPush(FOLLOW_as_key_in_flashback_query_clause1519);
        	        m_gPLSQLParser->as_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleflashback_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_of_key_in_flashback_query_clause1521);
        	        m_gPLSQLParser->of_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleflashback_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:192:24: ( scn_key | timestamp_key | snapshot_key )
        	        {
        	            int alt61=3;
        	            {
        	                int LA61_0 = this->LA(1);
        	                if ( (LA61_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA61_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "SCN"))))
        	                        {
        	                            alt61=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP"))))
        	                        {
        	                            alt61=2;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "SNAPSHOT"))))
        	                        {
        	                            alt61=3;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 61 );
        	                            ex->set_state( 1 );


        	                            goto ruleflashback_query_clauseEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 61 );
        	                    ex->set_state( 0 );


        	                    goto ruleflashback_query_clauseEx;

        	                }
        	            }
        	            switch (alt61)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:192:25: scn_key
        	        	    {
        	        	        this->followPush(FOLLOW_scn_key_in_flashback_query_clause1524);
        	        	        m_gPLSQLParser->scn_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleflashback_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:192:33: timestamp_key
        	        	    {
        	        	        this->followPush(FOLLOW_timestamp_key_in_flashback_query_clause1526);
        	        	        m_gPLSQLParser->timestamp_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleflashback_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // PLSQL_DMLParser.g:192:47: snapshot_key
        	        	    {
        	        	        this->followPush(FOLLOW_snapshot_key_in_flashback_query_clause1528);
        	        	        m_gPLSQLParser->snapshot_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleflashback_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_expression_in_flashback_query_clause1531);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleflashback_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleflashback_query_clauseEx; /* Prevent compiler warnings */
    ruleflashback_query_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end flashback_query_clause */

/**
 * $ANTLR start pivot_clause
 * PLSQL_DMLParser.g:195:1: pivot_clause : pivot_key ( xml_key )? LEFT_PAREN pivot_element ( COMMA pivot_element )* pivot_for_clause pivot_in_clause RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::pivot_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:196:5: ( pivot_key ( xml_key )? LEFT_PAREN pivot_element ( COMMA pivot_element )* pivot_for_clause pivot_in_clause RIGHT_PAREN )
        // PLSQL_DMLParser.g:196:10: pivot_key ( xml_key )? LEFT_PAREN pivot_element ( COMMA pivot_element )* pivot_for_clause pivot_in_clause RIGHT_PAREN
        {
            this->followPush(FOLLOW_pivot_key_in_pivot_clause1551);
            m_gPLSQLParser->pivot_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:196:20: ( xml_key )?
            {
                int alt63=2;
                {
                    int LA63_0 = this->LA(1);
                    if ( (LA63_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "XML"))))
                    {
                        alt63=1;
                    }
                }
                switch (alt63)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:196:20: xml_key
            	    {
            	        this->followPush(FOLLOW_xml_key_in_pivot_clause1553);
            	        m_gPLSQLParser->xml_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_pivot_clause1564);
            if  (this->hasException())
            {
                goto rulepivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_pivot_element_in_pivot_clause1578);
            pivot_element();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:198:27: ( COMMA pivot_element )*

            for (;;)
            {
                int alt64=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA64_0 = this->LA(1);
                    if ( (LA64_0 == COMMA))
                    {
                        alt64=1;
                    }

                }
                switch (alt64)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:198:28: COMMA pivot_element
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_pivot_clause1581);
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_pivot_element_in_pivot_clause1583);
            	        pivot_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop64;	/* break out of the loop */
            	    break;
                }
            }
            loop64: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_pivot_for_clause_in_pivot_clause1599);
            pivot_for_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_pivot_in_clause_in_pivot_clause1613);
            pivot_in_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_pivot_clause1625);
            if  (this->hasException())
            {
                goto rulepivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepivot_clauseEx; /* Prevent compiler warnings */
    rulepivot_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pivot_clause */

/**
 * $ANTLR start pivot_element
 * PLSQL_DMLParser.g:204:1: pivot_element : aggregate_function_name LEFT_PAREN expression RIGHT_PAREN ( column_alias )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::pivot_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:205:5: ( aggregate_function_name LEFT_PAREN expression RIGHT_PAREN ( column_alias )? )
        // PLSQL_DMLParser.g:205:10: aggregate_function_name LEFT_PAREN expression RIGHT_PAREN ( column_alias )?
        {
            this->followPush(FOLLOW_aggregate_function_name_in_pivot_element1645);
            m_gPLSQLParser->aggregate_function_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_pivot_element1647);
            if  (this->hasException())
            {
                goto rulepivot_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_pivot_element1649);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_pivot_element1651);
            if  (this->hasException())
            {
                goto rulepivot_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:205:68: ( column_alias )?
            {
                int alt65=2;
                {
                    int LA65_0 = this->LA(1);
                    if ( (((LA65_0 >= CHAR_STRING) && (LA65_0 <= CHAR_STRING_PERL)) || LA65_0 == DELIMITED_ID || LA65_0 == INTRODUCER || LA65_0 == NATIONAL_CHAR_STRING_LIT || LA65_0 == REGULAR_ID || LA65_0 == SQL92_RESERVED_AS))
                    {
                        alt65=1;
                    }
                }
                switch (alt65)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:205:68: column_alias
            	    {
            	        this->followPush(FOLLOW_column_alias_in_pivot_element1653);
            	        m_gPLSQLParser->column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulepivot_elementEx; /* Prevent compiler warnings */
    rulepivot_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pivot_element */

/**
 * $ANTLR start pivot_for_clause
 * PLSQL_DMLParser.g:208:1: pivot_for_clause : for_key ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::pivot_for_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:209:5: ( for_key ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) )
        // PLSQL_DMLParser.g:209:10: for_key ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
        {
            this->followPush(FOLLOW_for_key_in_pivot_for_clause1674);
            m_gPLSQLParser->for_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_for_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:210:5: ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
            {
                int alt67=2;
                {
                    int LA67_0 = this->LA(1);
                    if ( (LA67_0 == DELIMITED_ID || LA67_0 == INTRODUCER || LA67_0 == REGULAR_ID))
                    {
                        alt67=1;
                    }
                    else if ( (LA67_0 == LEFT_PAREN))
                    {
                        alt67=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 67 );
                        ex->set_state( 0 );


                        goto rulepivot_for_clauseEx;

                    }
                }
                switch (alt67)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:210:10: column_name
            	    {
            	        this->followPush(FOLLOW_column_name_in_pivot_for_clause1686);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_for_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:211:10: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_pivot_for_clause1697);
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_for_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_pivot_for_clause1699);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_for_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:211:33: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            int alt66=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA66_0 = this->LA(1);
            	                if ( (LA66_0 == COMMA))
            	                {
            	                    alt66=1;
            	                }

            	            }
            	            switch (alt66)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:211:34: COMMA column_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_pivot_for_clause1702);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepivot_for_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_column_name_in_pivot_for_clause1704);
            	        	        m_gPLSQLParser->column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepivot_for_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop66;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop66: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_pivot_for_clause1708);
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_for_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulepivot_for_clauseEx; /* Prevent compiler warnings */
    rulepivot_for_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pivot_for_clause */

/**
 * $ANTLR start pivot_in_clause
 * PLSQL_DMLParser.g:215:1: pivot_in_clause : in_key LEFT_PAREN ( ( select_key )=> subquery | ( any_key )=> any_key ( COMMA any_key )* | pivot_in_clause_element ( COMMA pivot_in_clause_element )* ) RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::pivot_in_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:216:5: ( in_key LEFT_PAREN ( ( select_key )=> subquery | ( any_key )=> any_key ( COMMA any_key )* | pivot_in_clause_element ( COMMA pivot_in_clause_element )* ) RIGHT_PAREN )
        // PLSQL_DMLParser.g:216:10: in_key LEFT_PAREN ( ( select_key )=> subquery | ( any_key )=> any_key ( COMMA any_key )* | pivot_in_clause_element ( COMMA pivot_in_clause_element )* ) RIGHT_PAREN
        {
            this->followPush(FOLLOW_in_key_in_pivot_in_clause1734);
            m_gPLSQLParser->in_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_pivot_in_clause1744);
            if  (this->hasException())
            {
                goto rulepivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:218:13: ( ( select_key )=> subquery | ( any_key )=> any_key ( COMMA any_key )* | pivot_in_clause_element ( COMMA pivot_in_clause_element )* )
            {
                int alt70=3;
                {
                    int LA70_0 = this->LA(1);
                    if ( (LA70_0 == SQL92_RESERVED_SELECT) && (this->msynpred( antlr3::ClassForwarder<synpred9_PLSQL_DMLParser>() )))
                    {
                        alt70=1;
                    }
                    else if ( (LA70_0 == LEFT_PAREN))
                    {
                        {
                            int LA70_2 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred9_PLSQL_DMLParser>() )))
                            {
                                alt70=1;
                            }
                            else if ( (true))
                            {
                                alt70=3;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 70 );
                                ex->set_state( 2 );


                                goto rulepivot_in_clauseEx;

                            }
                        }
                    }
                    else if ( (LA70_0 == SQL92_RESERVED_ANY))
                    {
                        {
                            int LA70_3 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred10_PLSQL_DMLParser>() )))
                            {
                                alt70=2;
                            }
                            else if ( (true))
                            {
                                alt70=3;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 70 );
                                ex->set_state( 3 );


                                goto rulepivot_in_clauseEx;

                            }
                        }
                    }
                    else if ( (LA70_0 == APPROXIMATE_NUM_LIT || LA70_0 == BINDVAR || ((LA70_0 >= CHAR_STRING) && (LA70_0 <= COLON)) || LA70_0 == DELIMITED_ID || LA70_0 == EXACT_NUM_LIT || LA70_0 == INTRODUCER || ((LA70_0 >= MINUS_SIGN) && (LA70_0 <= NATIONAL_CHAR_STRING_LIT)) || LA70_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA70_0 == PLUS_SIGN || LA70_0 == REGULAR_ID || LA70_0 == SQL92_RESERVED_ALL || LA70_0 == SQL92_RESERVED_CASE || ((LA70_0 >= SQL92_RESERVED_CURSOR) && (LA70_0 <= SQL92_RESERVED_DATE)) || LA70_0 == SQL92_RESERVED_DEFAULT || LA70_0 == SQL92_RESERVED_DISTINCT || ((LA70_0 >= SQL92_RESERVED_EXISTS) && (LA70_0 <= SQL92_RESERVED_FALSE)) || ((LA70_0 >= SQL92_RESERVED_NOT) && (LA70_0 <= SQL92_RESERVED_NULL)) || LA70_0 == SQL92_RESERVED_PRIOR || LA70_0 == SQL92_RESERVED_TRUE || LA70_0 == UNSIGNED_INTEGER))
                    {
                        alt70=3;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 70 );
                        ex->set_state( 0 );


                        goto rulepivot_in_clauseEx;

                    }
                }
                switch (alt70)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:218:18: ( select_key )=> subquery
            	    {
            	        this->followPush(FOLLOW_subquery_in_pivot_in_clause1768);
            	        subquery();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_in_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:219:18: ( any_key )=> any_key ( COMMA any_key )*
            	    {
            	        this->followPush(FOLLOW_any_key_in_pivot_in_clause1793);
            	        m_gPLSQLParser->any_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_in_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:219:38: ( COMMA any_key )*

            	        for (;;)
            	        {
            	            int alt68=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA68_0 = this->LA(1);
            	                if ( (LA68_0 == COMMA))
            	                {
            	                    alt68=1;
            	                }

            	            }
            	            switch (alt68)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:219:39: COMMA any_key
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_pivot_in_clause1796);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepivot_in_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_any_key_in_pivot_in_clause1798);
            	        	        m_gPLSQLParser->any_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepivot_in_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop68;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop68: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;
            	case 3:
            	    // PLSQL_DMLParser.g:220:18: pivot_in_clause_element ( COMMA pivot_in_clause_element )*
            	    {
            	        this->followPush(FOLLOW_pivot_in_clause_element_in_pivot_in_clause1819);
            	        pivot_in_clause_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_in_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:220:42: ( COMMA pivot_in_clause_element )*

            	        for (;;)
            	        {
            	            int alt69=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA69_0 = this->LA(1);
            	                if ( (LA69_0 == COMMA))
            	                {
            	                    alt69=1;
            	                }

            	            }
            	            switch (alt69)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:220:43: COMMA pivot_in_clause_element
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_pivot_in_clause1822);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepivot_in_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_pivot_in_clause_element_in_pivot_in_clause1824);
            	        	        pivot_in_clause_element();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepivot_in_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop69;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop69: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_pivot_in_clause1850);
            if  (this->hasException())
            {
                goto rulepivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepivot_in_clauseEx; /* Prevent compiler warnings */
    rulepivot_in_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pivot_in_clause */

/**
 * $ANTLR start pivot_in_clause_element
 * PLSQL_DMLParser.g:225:1: pivot_in_clause_element : pivot_in_clause_elements ( column_alias )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::pivot_in_clause_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:226:5: ( pivot_in_clause_elements ( column_alias )? )
        // PLSQL_DMLParser.g:226:10: pivot_in_clause_elements ( column_alias )?
        {
            this->followPush(FOLLOW_pivot_in_clause_elements_in_pivot_in_clause_element1870);
            pivot_in_clause_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_in_clause_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:226:35: ( column_alias )?
            {
                int alt71=2;
                {
                    int LA71_0 = this->LA(1);
                    if ( (((LA71_0 >= CHAR_STRING) && (LA71_0 <= CHAR_STRING_PERL)) || LA71_0 == DELIMITED_ID || LA71_0 == INTRODUCER || LA71_0 == NATIONAL_CHAR_STRING_LIT || LA71_0 == REGULAR_ID || LA71_0 == SQL92_RESERVED_AS))
                    {
                        alt71=1;
                    }
                }
                switch (alt71)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:226:35: column_alias
            	    {
            	        this->followPush(FOLLOW_column_alias_in_pivot_in_clause_element1872);
            	        m_gPLSQLParser->column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_in_clause_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulepivot_in_clause_elementEx; /* Prevent compiler warnings */
    rulepivot_in_clause_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pivot_in_clause_element */

/**
 * $ANTLR start pivot_in_clause_elements
 * PLSQL_DMLParser.g:229:1: pivot_in_clause_elements : ( expression | ( LEFT_PAREN )=> expression_list );
 */
void
PLSQLParser_PLSQL_DMLParser::pivot_in_clause_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:230:5: ( expression | ( LEFT_PAREN )=> expression_list )

            ANTLR_UINT32 alt72;

            alt72=2;

            {
                int LA72_0 = this->LA(1);
                if ( (LA72_0 == APPROXIMATE_NUM_LIT || LA72_0 == BINDVAR || ((LA72_0 >= CHAR_STRING) && (LA72_0 <= COLON)) || LA72_0 == DELIMITED_ID || LA72_0 == EXACT_NUM_LIT || LA72_0 == INTRODUCER || ((LA72_0 >= MINUS_SIGN) && (LA72_0 <= NATIONAL_CHAR_STRING_LIT)) || LA72_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA72_0 == PLUS_SIGN || LA72_0 == REGULAR_ID || LA72_0 == SQL92_RESERVED_ALL || LA72_0 == SQL92_RESERVED_ANY || LA72_0 == SQL92_RESERVED_CASE || ((LA72_0 >= SQL92_RESERVED_CURSOR) && (LA72_0 <= SQL92_RESERVED_DATE)) || LA72_0 == SQL92_RESERVED_DEFAULT || LA72_0 == SQL92_RESERVED_DISTINCT || ((LA72_0 >= SQL92_RESERVED_EXISTS) && (LA72_0 <= SQL92_RESERVED_FALSE)) || ((LA72_0 >= SQL92_RESERVED_NOT) && (LA72_0 <= SQL92_RESERVED_NULL)) || LA72_0 == SQL92_RESERVED_PRIOR || LA72_0 == SQL92_RESERVED_TRUE || LA72_0 == UNSIGNED_INTEGER))
                {
                    alt72=1;
                }
                else if ( (LA72_0 == LEFT_PAREN))
                {
                    {
                        int LA72_24 = this->LA(2);
                        if ( (true))
                        {
                            alt72=1;
                        }
                        else if ( (this->msynpred( antlr3::ClassForwarder<synpred11_PLSQL_DMLParser>() )))
                        {
                            alt72=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 72 );
                            ex->set_state( 24 );


                            goto rulepivot_in_clause_elementsEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 72 );
                    ex->set_state( 0 );


                    goto rulepivot_in_clause_elementsEx;

                }
            }
            switch (alt72)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:230:10: expression
        	    {
        	        this->followPush(FOLLOW_expression_in_pivot_in_clause_elements1893);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepivot_in_clause_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:231:10: ( LEFT_PAREN )=> expression_list
        	    {
        	        this->followPush(FOLLOW_expression_list_in_pivot_in_clause_elements1909);
        	        expression_list();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepivot_in_clause_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulepivot_in_clause_elementsEx; /* Prevent compiler warnings */
    rulepivot_in_clause_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pivot_in_clause_elements */

/**
 * $ANTLR start unpivot_clause
 * PLSQL_DMLParser.g:234:1: unpivot_clause : unpivot_key ( ( include_key | exclude_key ) nulls_key )? LEFT_PAREN ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) pivot_for_clause unpivot_in_clause RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::unpivot_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:235:5: ( unpivot_key ( ( include_key | exclude_key ) nulls_key )? LEFT_PAREN ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) pivot_for_clause unpivot_in_clause RIGHT_PAREN )
        // PLSQL_DMLParser.g:235:10: unpivot_key ( ( include_key | exclude_key ) nulls_key )? LEFT_PAREN ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) pivot_for_clause unpivot_in_clause RIGHT_PAREN
        {
            this->followPush(FOLLOW_unpivot_key_in_unpivot_clause1929);
            m_gPLSQLParser->unpivot_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleunpivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:236:9: ( ( include_key | exclude_key ) nulls_key )?
            {
                int alt74=2;
                {
                    int LA74_0 = this->LA(1);
                    if ( (LA74_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "EXCLUDE")))||((equalsIgnoreCase(LT(1)->getText(), "INCLUDE"))))))
                    {
                        alt74=1;
                    }
                }
                switch (alt74)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:236:10: ( include_key | exclude_key ) nulls_key
            	    {
            	        // PLSQL_DMLParser.g:236:10: ( include_key | exclude_key )
            	        {
            	            int alt73=2;
            	            {
            	                int LA73_0 = this->LA(1);
            	                if ( (LA73_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "EXCLUDE")))||((equalsIgnoreCase(LT(1)->getText(), "INCLUDE"))))))
            	                {
            	                    {
            	                        int LA73_1 = this->LA(2);
            	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "INCLUDE"))))
            	                        {
            	                            alt73=1;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "EXCLUDE"))))
            	                        {
            	                            alt73=2;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 73 );
            	                            ex->set_state( 1 );


            	                            goto ruleunpivot_clauseEx;

            	                        }
            	                    }
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 73 );
            	                    ex->set_state( 0 );


            	                    goto ruleunpivot_clauseEx;

            	                }
            	            }
            	            switch (alt73)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:236:11: include_key
            	        	    {
            	        	        this->followPush(FOLLOW_include_key_in_unpivot_clause1942);
            	        	        m_gPLSQLParser->include_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:236:23: exclude_key
            	        	    {
            	        	        this->followPush(FOLLOW_exclude_key_in_unpivot_clause1944);
            	        	        m_gPLSQLParser->exclude_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_nulls_key_in_unpivot_clause1947);
            	        m_gPLSQLParser->nulls_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_unpivot_clause1959);
            if  (this->hasException())
            {
                goto ruleunpivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:238:13: ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
            {
                int alt76=2;
                {
                    int LA76_0 = this->LA(1);
                    if ( (LA76_0 == DELIMITED_ID || LA76_0 == INTRODUCER || LA76_0 == REGULAR_ID))
                    {
                        alt76=1;
                    }
                    else if ( (LA76_0 == LEFT_PAREN))
                    {
                        alt76=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 76 );
                        ex->set_state( 0 );


                        goto ruleunpivot_clauseEx;

                    }
                }
                switch (alt76)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:238:18: column_name
            	    {
            	        this->followPush(FOLLOW_column_name_in_unpivot_clause1978);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:239:18: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_unpivot_clause1997);
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_unpivot_clause1999);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:239:41: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            int alt75=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA75_0 = this->LA(1);
            	                if ( (LA75_0 == COMMA))
            	                {
            	                    alt75=1;
            	                }

            	            }
            	            switch (alt75)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:239:42: COMMA column_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_unpivot_clause2002);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_column_name_in_unpivot_clause2004);
            	        	        m_gPLSQLParser->column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop75;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop75: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_unpivot_clause2008);
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_pivot_for_clause_in_unpivot_clause2036);
            pivot_for_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleunpivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_unpivot_in_clause_in_unpivot_clause2050);
            unpivot_in_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleunpivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_unpivot_clause2060);
            if  (this->hasException())
            {
                goto ruleunpivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunpivot_clauseEx; /* Prevent compiler warnings */
    ruleunpivot_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unpivot_clause */

/**
 * $ANTLR start unpivot_in_clause
 * PLSQL_DMLParser.g:246:1: unpivot_in_clause : in_key LEFT_PAREN unpivot_in_elements ( COMMA unpivot_in_elements )* RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::unpivot_in_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:247:5: ( in_key LEFT_PAREN unpivot_in_elements ( COMMA unpivot_in_elements )* RIGHT_PAREN )
        // PLSQL_DMLParser.g:247:10: in_key LEFT_PAREN unpivot_in_elements ( COMMA unpivot_in_elements )* RIGHT_PAREN
        {
            this->followPush(FOLLOW_in_key_in_unpivot_in_clause2080);
            m_gPLSQLParser->in_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleunpivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_unpivot_in_clause2090);
            if  (this->hasException())
            {
                goto ruleunpivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_unpivot_in_elements_in_unpivot_in_clause2104);
            unpivot_in_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleunpivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:249:33: ( COMMA unpivot_in_elements )*

            for (;;)
            {
                int alt77=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA77_0 = this->LA(1);
                    if ( (LA77_0 == COMMA))
                    {
                        alt77=1;
                    }

                }
                switch (alt77)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:249:34: COMMA unpivot_in_elements
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_unpivot_in_clause2107);
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_unpivot_in_elements_in_unpivot_in_clause2109);
            	        unpivot_in_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop77;	/* break out of the loop */
            	    break;
                }
            }
            loop77: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_unpivot_in_clause2121);
            if  (this->hasException())
            {
                goto ruleunpivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunpivot_in_clauseEx; /* Prevent compiler warnings */
    ruleunpivot_in_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unpivot_in_clause */

/**
 * $ANTLR start unpivot_in_elements
 * PLSQL_DMLParser.g:253:1: unpivot_in_elements : ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) ( as_key ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN ) )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::unpivot_in_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:254:5: ( ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) ( as_key ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN ) )? )
        // PLSQL_DMLParser.g:254:9: ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) ( as_key ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN ) )?
        {
            // PLSQL_DMLParser.g:254:9: ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
            {
                int alt79=2;
                {
                    int LA79_0 = this->LA(1);
                    if ( (LA79_0 == DELIMITED_ID || LA79_0 == INTRODUCER || LA79_0 == REGULAR_ID))
                    {
                        alt79=1;
                    }
                    else if ( (LA79_0 == LEFT_PAREN))
                    {
                        alt79=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 79 );
                        ex->set_state( 0 );


                        goto ruleunpivot_in_elementsEx;

                    }
                }
                switch (alt79)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:254:14: column_name
            	    {
            	        this->followPush(FOLLOW_column_name_in_unpivot_in_elements2145);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:255:14: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_unpivot_in_elements2160);
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_unpivot_in_elements2162);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:255:37: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            int alt78=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA78_0 = this->LA(1);
            	                if ( (LA78_0 == COMMA))
            	                {
            	                    alt78=1;
            	                }

            	            }
            	            switch (alt78)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:255:38: COMMA column_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_unpivot_in_elements2165);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_in_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_column_name_in_unpivot_in_elements2167);
            	        	        m_gPLSQLParser->column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_in_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop78;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop78: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_unpivot_in_elements2171);
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:257:9: ( as_key ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN ) )?
            {
                int alt82=2;
                {
                    int LA82_0 = this->LA(1);
                    if ( (LA82_0 == SQL92_RESERVED_AS))
                    {
                        alt82=1;
                    }
                }
                switch (alt82)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:257:15: as_key ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN )
            	    {
            	        this->followPush(FOLLOW_as_key_in_unpivot_in_elements2197);
            	        m_gPLSQLParser->as_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:258:10: ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN )
            	        {
            	            int alt81=2;
            	            {
            	                int LA81_0 = this->LA(1);
            	                if ( (LA81_0 == APPROXIMATE_NUM_LIT || ((LA81_0 >= CHAR_STRING) && (LA81_0 <= CHAR_STRING_PERL)) || LA81_0 == EXACT_NUM_LIT || LA81_0 == NATIONAL_CHAR_STRING_LIT || LA81_0 == REGULAR_ID || LA81_0 == SQL92_RESERVED_DATE || LA81_0 == SQL92_RESERVED_DEFAULT || LA81_0 == SQL92_RESERVED_FALSE || LA81_0 == SQL92_RESERVED_NULL || LA81_0 == SQL92_RESERVED_TRUE || LA81_0 == UNSIGNED_INTEGER))
            	                {
            	                    alt81=1;
            	                }
            	                else if ( (LA81_0 == LEFT_PAREN) && (this->msynpred( antlr3::ClassForwarder<synpred12_PLSQL_DMLParser>() )))
            	                {
            	                    alt81=2;
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 81 );
            	                    ex->set_state( 0 );


            	                    goto ruleunpivot_in_elementsEx;

            	                }
            	            }
            	            switch (alt81)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:258:15: constant
            	        	    {
            	        	        this->followPush(FOLLOW_constant_in_unpivot_in_elements2213);
            	        	        m_gPLSQLParser->constant();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_in_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:259:15: ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN
            	        	    {
            	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_unpivot_in_elements2234);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_in_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_constant_in_unpivot_in_elements2236);
            	        	        m_gPLSQLParser->constant();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_in_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // PLSQL_DMLParser.g:259:50: ( COMMA constant )*

            	        	        for (;;)
            	        	        {
            	        	            int alt80=2;
            	        	            {
            	        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	        	                */
            	        	                int LA80_0 = this->LA(1);
            	        	                if ( (LA80_0 == COMMA))
            	        	                {
            	        	                    alt80=1;
            	        	                }

            	        	            }
            	        	            switch (alt80)
            	        	            {
            	        	        	case 1:
            	        	        	    // PLSQL_DMLParser.g:259:51: COMMA constant
            	        	        	    {
            	        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_unpivot_in_elements2239);
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleunpivot_in_elementsEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	        this->followPush(FOLLOW_constant_in_unpivot_in_elements2241);
            	        	        	        m_gPLSQLParser->constant();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleunpivot_in_elementsEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	        	default:
            	        	        	    goto loop80;	/* break out of the loop */
            	        	        	    break;
            	        	            }
            	        	        }
            	        	        loop80: ; /* Jump out to here if this rule does not match */


            	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_unpivot_in_elements2245);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_in_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunpivot_in_elementsEx; /* Prevent compiler warnings */
    ruleunpivot_in_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unpivot_in_elements */

/**
 * $ANTLR start hierarchical_query_clause
 * PLSQL_DMLParser.g:264:1: hierarchical_query_clause : ( connect_key by_key ( nocycle_key )? condition ( start_part )? | start_part connect_key by_key ( nocycle_key )? condition );
 */
void
PLSQLParser_PLSQL_DMLParser::hierarchical_query_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:265:5: ( connect_key by_key ( nocycle_key )? condition ( start_part )? | start_part connect_key by_key ( nocycle_key )? condition )

            ANTLR_UINT32 alt86;

            alt86=2;

            {
                int LA86_0 = this->LA(1);
                if ( (LA86_0 == SQL92_RESERVED_CONNECT))
                {
                    alt86=1;
                }
                else if ( (LA86_0 == PLSQL_RESERVED_START))
                {
                    alt86=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 86 );
                    ex->set_state( 0 );


                    goto rulehierarchical_query_clauseEx;

                }
            }
            switch (alt86)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:265:10: connect_key by_key ( nocycle_key )? condition ( start_part )?
        	    {
        	        this->followPush(FOLLOW_connect_key_in_hierarchical_query_clause2287);
        	        m_gPLSQLParser->connect_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_by_key_in_hierarchical_query_clause2289);
        	        m_gPLSQLParser->by_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:265:29: ( nocycle_key )?
        	        {
        	            int alt83=2;
        	            {
        	                int LA83_0 = this->LA(1);
        	                if ( (LA83_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA83_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "NOCYCLE"))))
        	                        {
        	                            alt83=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt83)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:265:29: nocycle_key
        	        	    {
        	        	        this->followPush(FOLLOW_nocycle_key_in_hierarchical_query_clause2291);
        	        	        m_gPLSQLParser->nocycle_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulehierarchical_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_condition_in_hierarchical_query_clause2294);
        	        condition();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:265:52: ( start_part )?
        	        {
        	            int alt84=2;
        	            {
        	                int LA84_0 = this->LA(1);
        	                if ( (LA84_0 == PLSQL_RESERVED_START))
        	                {
        	                    alt84=1;
        	                }
        	            }
        	            switch (alt84)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:265:52: start_part
        	        	    {
        	        	        this->followPush(FOLLOW_start_part_in_hierarchical_query_clause2296);
        	        	        start_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulehierarchical_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:266:10: start_part connect_key by_key ( nocycle_key )? condition
        	    {
        	        this->followPush(FOLLOW_start_part_in_hierarchical_query_clause2308);
        	        start_part();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_connect_key_in_hierarchical_query_clause2310);
        	        m_gPLSQLParser->connect_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_by_key_in_hierarchical_query_clause2312);
        	        m_gPLSQLParser->by_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:266:40: ( nocycle_key )?
        	        {
        	            int alt85=2;
        	            {
        	                int LA85_0 = this->LA(1);
        	                if ( (LA85_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA85_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "NOCYCLE"))))
        	                        {
        	                            alt85=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt85)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:266:40: nocycle_key
        	        	    {
        	        	        this->followPush(FOLLOW_nocycle_key_in_hierarchical_query_clause2314);
        	        	        m_gPLSQLParser->nocycle_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulehierarchical_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_condition_in_hierarchical_query_clause2317);
        	        condition();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulehierarchical_query_clauseEx; /* Prevent compiler warnings */
    rulehierarchical_query_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end hierarchical_query_clause */

/**
 * $ANTLR start start_part
 * PLSQL_DMLParser.g:269:1: start_part : start_key with_key condition ;
 */
void
PLSQLParser_PLSQL_DMLParser::start_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:270:5: ( start_key with_key condition )
        // PLSQL_DMLParser.g:270:10: start_key with_key condition
        {
            this->followPush(FOLLOW_start_key_in_start_part2337);
            m_gPLSQLParser->start_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestart_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_with_key_in_start_part2339);
            m_gPLSQLParser->with_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestart_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_condition_in_start_part2341);
            condition();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestart_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestart_partEx; /* Prevent compiler warnings */
    rulestart_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end start_part */

/**
 * $ANTLR start group_by_clause
 * PLSQL_DMLParser.g:273:1: group_by_clause : ( ( group_key )=> group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* ( having_clause )? | ( having_key )=> having_clause ( group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* )? );
 */
void
PLSQLParser_PLSQL_DMLParser::group_by_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:274:5: ( ( group_key )=> group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* ( having_clause )? | ( having_key )=> having_clause ( group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* )? )

            ANTLR_UINT32 alt91;

            alt91=2;

            {
                int LA91_0 = this->LA(1);
                if ( (LA91_0 == SQL92_RESERVED_GROUP) && (this->msynpred( antlr3::ClassForwarder<synpred13_PLSQL_DMLParser>() )))
                {
                    alt91=1;
                }
                else if ( (LA91_0 == SQL92_RESERVED_HAVING) && (this->msynpred( antlr3::ClassForwarder<synpred15_PLSQL_DMLParser>() )))
                {
                    alt91=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 91 );
                    ex->set_state( 0 );


                    goto rulegroup_by_clauseEx;

                }
            }
            switch (alt91)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:274:9: ( group_key )=> group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* ( having_clause )?
        	    {
        	        this->followPush(FOLLOW_group_key_in_group_by_clause2366);
        	        m_gPLSQLParser->group_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_by_key_in_group_by_clause2368);
        	        m_gPLSQLParser->by_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_group_by_elements_in_group_by_clause2370);
        	        group_by_elements();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:275:13: ( ( COMMA group_by_elements )=> COMMA group_by_elements )*

        	        for (;;)
        	        {
        	            int alt87=2;
        	            {
        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                */
        	                int LA87_0 = this->LA(1);
        	                if ( (LA87_0 == COMMA))
        	                {
        	                    {
        	                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                        */
        	                        int LA87_2 = this->LA(2);
        	                        if ( (this->msynpred( antlr3::ClassForwarder<synpred14_PLSQL_DMLParser>() )))
        	                        {
        	                            alt87=1;
        	                        }

        	                    }
        	                }

        	            }
        	            switch (alt87)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:275:14: ( COMMA group_by_elements )=> COMMA group_by_elements
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_group_by_clause2392);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulegroup_by_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_group_by_elements_in_group_by_clause2394);
        	        	        group_by_elements();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulegroup_by_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop87;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop87: ; /* Jump out to here if this rule does not match */


        	        // PLSQL_DMLParser.g:276:13: ( having_clause )?
        	        {
        	            int alt88=2;
        	            {
        	                int LA88_0 = this->LA(1);
        	                if ( (LA88_0 == SQL92_RESERVED_HAVING))
        	                {
        	                    alt88=1;
        	                }
        	            }
        	            switch (alt88)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:276:13: having_clause
        	        	    {
        	        	        this->followPush(FOLLOW_having_clause_in_group_by_clause2410);
        	        	        having_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulegroup_by_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:277:9: ( having_key )=> having_clause ( group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* )?
        	    {
        	        this->followPush(FOLLOW_having_clause_in_group_by_clause2427);
        	        having_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:278:13: ( group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* )?
        	        {
        	            int alt90=2;
        	            {
        	                int LA90_0 = this->LA(1);
        	                if ( (LA90_0 == SQL92_RESERVED_GROUP))
        	                {
        	                    alt90=1;
        	                }
        	            }
        	            switch (alt90)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:278:14: group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )*
        	        	    {
        	        	        this->followPush(FOLLOW_group_key_in_group_by_clause2442);
        	        	        m_gPLSQLParser->group_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulegroup_by_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_by_key_in_group_by_clause2444);
        	        	        m_gPLSQLParser->by_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulegroup_by_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_group_by_elements_in_group_by_clause2446);
        	        	        group_by_elements();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulegroup_by_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQL_DMLParser.g:279:13: ( ( COMMA group_by_elements )=> COMMA group_by_elements )*

        	        	        for (;;)
        	        	        {
        	        	            int alt89=2;
        	        	            {
        	        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	        	                */
        	        	                int LA89_0 = this->LA(1);
        	        	                if ( (LA89_0 == COMMA))
        	        	                {
        	        	                    {
        	        	                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	        	                        */
        	        	                        int LA89_2 = this->LA(2);
        	        	                        if ( (this->msynpred( antlr3::ClassForwarder<synpred16_PLSQL_DMLParser>() )))
        	        	                        {
        	        	                            alt89=1;
        	        	                        }

        	        	                    }
        	        	                }

        	        	            }
        	        	            switch (alt89)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:279:14: ( COMMA group_by_elements )=> COMMA group_by_elements
        	        	        	    {
        	        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_group_by_clause2468);
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulegroup_by_clauseEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        this->followPush(FOLLOW_group_by_elements_in_group_by_clause2470);
        	        	        	        group_by_elements();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulegroup_by_clauseEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	        	default:
        	        	        	    goto loop89;	/* break out of the loop */
        	        	        	    break;
        	        	            }
        	        	        }
        	        	        loop89: ; /* Jump out to here if this rule does not match */


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulegroup_by_clauseEx; /* Prevent compiler warnings */
    rulegroup_by_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end group_by_clause */

/**
 * $ANTLR start group_by_elements
 * PLSQL_DMLParser.g:282:1: group_by_elements : ( grouping_sets_clause | rollup_cube_clause | expression );
 */
void
PLSQLParser_PLSQL_DMLParser::group_by_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:283:5: ( grouping_sets_clause | rollup_cube_clause | expression )

            ANTLR_UINT32 alt92;

            alt92=3;

            {
                int LA92_0 = this->LA(1);
                if ( (LA92_0 == REGULAR_ID))
                {
                    {
                        int LA92_1 = this->LA(2);
                        if ( ((equalsIgnoreCase(LT(1)->getText(), "GROUPING"))))
                        {
                            alt92=1;
                        }
                        else if ( ((((equalsIgnoreCase(LT(1)->getText(), "CUBE")))||((equalsIgnoreCase(LT(1)->getText(), "ROLLUP"))))))
                        {
                            alt92=2;
                        }
                        else if ( (true))
                        {
                            alt92=3;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 92 );
                            ex->set_state( 1 );


                            goto rulegroup_by_elementsEx;

                        }
                    }
                }
                else if ( (LA92_0 == APPROXIMATE_NUM_LIT || LA92_0 == BINDVAR || ((LA92_0 >= CHAR_STRING) && (LA92_0 <= COLON)) || LA92_0 == DELIMITED_ID || LA92_0 == EXACT_NUM_LIT || LA92_0 == INTRODUCER || LA92_0 == LEFT_PAREN || ((LA92_0 >= MINUS_SIGN) && (LA92_0 <= NATIONAL_CHAR_STRING_LIT)) || LA92_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA92_0 == PLUS_SIGN || LA92_0 == SQL92_RESERVED_ALL || LA92_0 == SQL92_RESERVED_ANY || LA92_0 == SQL92_RESERVED_CASE || ((LA92_0 >= SQL92_RESERVED_CURSOR) && (LA92_0 <= SQL92_RESERVED_DATE)) || LA92_0 == SQL92_RESERVED_DEFAULT || LA92_0 == SQL92_RESERVED_DISTINCT || ((LA92_0 >= SQL92_RESERVED_EXISTS) && (LA92_0 <= SQL92_RESERVED_FALSE)) || ((LA92_0 >= SQL92_RESERVED_NOT) && (LA92_0 <= SQL92_RESERVED_NULL)) || LA92_0 == SQL92_RESERVED_PRIOR || LA92_0 == SQL92_RESERVED_TRUE || LA92_0 == UNSIGNED_INTEGER))
                {
                    alt92=3;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 92 );
                    ex->set_state( 0 );


                    goto rulegroup_by_elementsEx;

                }
            }
            switch (alt92)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:283:10: grouping_sets_clause
        	    {
        	        this->followPush(FOLLOW_grouping_sets_clause_in_group_by_elements2494);
        	        grouping_sets_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:284:10: rollup_cube_clause
        	    {
        	        this->followPush(FOLLOW_rollup_cube_clause_in_group_by_elements2505);
        	        rollup_cube_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:285:10: expression
        	    {
        	        this->followPush(FOLLOW_expression_in_group_by_elements2517);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulegroup_by_elementsEx; /* Prevent compiler warnings */
    rulegroup_by_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end group_by_elements */

/**
 * $ANTLR start rollup_cube_clause
 * PLSQL_DMLParser.g:288:1: rollup_cube_clause : ( rollup_key | cube_key ) LEFT_PAREN grouping_sets_elements ( COMMA grouping_sets_elements )* RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::rollup_cube_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:289:5: ( ( rollup_key | cube_key ) LEFT_PAREN grouping_sets_elements ( COMMA grouping_sets_elements )* RIGHT_PAREN )
        // PLSQL_DMLParser.g:289:10: ( rollup_key | cube_key ) LEFT_PAREN grouping_sets_elements ( COMMA grouping_sets_elements )* RIGHT_PAREN
        {
            // PLSQL_DMLParser.g:289:10: ( rollup_key | cube_key )
            {
                int alt93=2;
                {
                    int LA93_0 = this->LA(1);
                    if ( (LA93_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "CUBE")))||((equalsIgnoreCase(LT(1)->getText(), "ROLLUP"))))))
                    {
                        {
                            int LA93_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "ROLLUP"))))
                            {
                                alt93=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "CUBE"))))
                            {
                                alt93=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 93 );
                                ex->set_state( 1 );


                                goto rulerollup_cube_clauseEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 93 );
                        ex->set_state( 0 );


                        goto rulerollup_cube_clauseEx;

                    }
                }
                switch (alt93)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:289:11: rollup_key
            	    {
            	        this->followPush(FOLLOW_rollup_key_in_rollup_cube_clause2538);
            	        m_gPLSQLParser->rollup_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerollup_cube_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:289:22: cube_key
            	    {
            	        this->followPush(FOLLOW_cube_key_in_rollup_cube_clause2540);
            	        m_gPLSQLParser->cube_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerollup_cube_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_rollup_cube_clause2543);
            if  (this->hasException())
            {
                goto rulerollup_cube_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_grouping_sets_elements_in_rollup_cube_clause2545);
            grouping_sets_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerollup_cube_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:289:66: ( COMMA grouping_sets_elements )*

            for (;;)
            {
                int alt94=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA94_0 = this->LA(1);
                    if ( (LA94_0 == COMMA))
                    {
                        alt94=1;
                    }

                }
                switch (alt94)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:289:67: COMMA grouping_sets_elements
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_rollup_cube_clause2548);
            	        if  (this->hasException())
            	        {
            	            goto rulerollup_cube_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_grouping_sets_elements_in_rollup_cube_clause2550);
            	        grouping_sets_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerollup_cube_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop94;	/* break out of the loop */
            	    break;
                }
            }
            loop94: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_rollup_cube_clause2554);
            if  (this->hasException())
            {
                goto rulerollup_cube_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerollup_cube_clauseEx; /* Prevent compiler warnings */
    rulerollup_cube_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rollup_cube_clause */

/**
 * $ANTLR start grouping_sets_clause
 * PLSQL_DMLParser.g:292:1: grouping_sets_clause : grouping_key sets_key LEFT_PAREN grouping_sets_elements ( COMMA grouping_sets_elements )* RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::grouping_sets_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:293:5: ( grouping_key sets_key LEFT_PAREN grouping_sets_elements ( COMMA grouping_sets_elements )* RIGHT_PAREN )
        // PLSQL_DMLParser.g:293:10: grouping_key sets_key LEFT_PAREN grouping_sets_elements ( COMMA grouping_sets_elements )* RIGHT_PAREN
        {
            this->followPush(FOLLOW_grouping_key_in_grouping_sets_clause2575);
            m_gPLSQLParser->grouping_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulegrouping_sets_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_sets_key_in_grouping_sets_clause2577);
            m_gPLSQLParser->sets_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulegrouping_sets_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_grouping_sets_clause2588);
            if  (this->hasException())
            {
                goto rulegrouping_sets_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_grouping_sets_elements_in_grouping_sets_clause2590);
            grouping_sets_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto rulegrouping_sets_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:294:43: ( COMMA grouping_sets_elements )*

            for (;;)
            {
                int alt95=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA95_0 = this->LA(1);
                    if ( (LA95_0 == COMMA))
                    {
                        alt95=1;
                    }

                }
                switch (alt95)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:294:44: COMMA grouping_sets_elements
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_grouping_sets_clause2593);
            	        if  (this->hasException())
            	        {
            	            goto rulegrouping_sets_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_grouping_sets_elements_in_grouping_sets_clause2595);
            	        grouping_sets_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegrouping_sets_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop95;	/* break out of the loop */
            	    break;
                }
            }
            loop95: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_grouping_sets_clause2599);
            if  (this->hasException())
            {
                goto rulegrouping_sets_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulegrouping_sets_clauseEx; /* Prevent compiler warnings */
    rulegrouping_sets_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end grouping_sets_clause */

/**
 * $ANTLR start grouping_sets_elements
 * PLSQL_DMLParser.g:297:1: grouping_sets_elements : ( ( rollup_key | cube_key )=> rollup_cube_clause | ( LEFT_PAREN )=> expression_list | expression );
 */
void
PLSQLParser_PLSQL_DMLParser::grouping_sets_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:298:5: ( ( rollup_key | cube_key )=> rollup_cube_clause | ( LEFT_PAREN )=> expression_list | expression )

            ANTLR_UINT32 alt96;

            alt96=3;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    int LA96_1 = this->LA(2);
            		    if ( (( ((((equalsIgnoreCase(LT(1)->getText(), "CUBE")))||((equalsIgnoreCase(LT(1)->getText(), "ROLLUP"))))) && (this->msynpred( antlr3::ClassForwarder<synpred17_PLSQL_DMLParser>() )) )))
            		    {
            		        alt96=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt96=3;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 96 );
            		        ex->set_state( 1 );


            		        goto rulegrouping_sets_elementsEx;

            		    }
            		}
            	}
                break;
            case LEFT_PAREN:
            	{
            		{
            		    int LA96_2 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred18_PLSQL_DMLParser>() )))
            		    {
            		        alt96=2;
            		    }
            		    else if ( (true))
            		    {
            		        alt96=3;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 96 );
            		        ex->set_state( 2 );


            		        goto rulegrouping_sets_elementsEx;

            		    }
            		}
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case DELIMITED_ID:
            case EXACT_NUM_LIT:
            case INTRODUCER:
            case MINUS_SIGN:
            case NATIONAL_CHAR_STRING_LIT:
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            case PLUS_SIGN:
            case SQL92_RESERVED_ALL:
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_CASE:
            case SQL92_RESERVED_CURSOR:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_DISTINCT:
            case SQL92_RESERVED_EXISTS:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NOT:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_PRIOR:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt96=3;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 96 );
                ex->set_state( 0 );


                goto rulegrouping_sets_elementsEx;

            }

            switch (alt96)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:298:10: ( rollup_key | cube_key )=> rollup_cube_clause
        	    {
        	        this->followPush(FOLLOW_rollup_cube_clause_in_grouping_sets_elements2626);
        	        rollup_cube_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegrouping_sets_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:299:10: ( LEFT_PAREN )=> expression_list
        	    {
        	        this->followPush(FOLLOW_expression_list_in_grouping_sets_elements2642);
        	        expression_list();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegrouping_sets_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:300:10: expression
        	    {
        	        this->followPush(FOLLOW_expression_in_grouping_sets_elements2653);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegrouping_sets_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulegrouping_sets_elementsEx; /* Prevent compiler warnings */
    rulegrouping_sets_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end grouping_sets_elements */

/**
 * $ANTLR start having_clause
 * PLSQL_DMLParser.g:303:1: having_clause : having_key condition ;
 */
void
PLSQLParser_PLSQL_DMLParser::having_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:304:5: ( having_key condition )
        // PLSQL_DMLParser.g:304:10: having_key condition
        {
            this->followPush(FOLLOW_having_key_in_having_clause2673);
            m_gPLSQLParser->having_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulehaving_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_condition_in_having_clause2675);
            condition();

            this->followPop();
            if  (this->hasException())
            {
                goto rulehaving_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulehaving_clauseEx; /* Prevent compiler warnings */
    rulehaving_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end having_clause */

/**
 * $ANTLR start model_clause
 * PLSQL_DMLParser.g:307:1: model_clause : model_key ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* main_model ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:308:5: ( model_key ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* main_model )
        // PLSQL_DMLParser.g:308:10: model_key ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* main_model
        {
            this->followPush(FOLLOW_model_key_in_model_clause2695);
            m_gPLSQLParser->model_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:308:20: ( cell_reference_options )*

            for (;;)
            {
                int alt97=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA97_0 = this->LA(1);
                    if ( (LA97_0 == REGULAR_ID))
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA97_1 = this->LA(2);
                            if ( (LA97_1 == REGULAR_ID))
                            {
                                {
                                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                                    */
                                    int LA97_3 = this->LA(3);
                                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))))
                                    {
                                        alt97=1;
                                    }

                                }
                            }

                        }
                    }
                    else if ( (LA97_0 == SQL92_RESERVED_UNIQUE))
                    {
                        alt97=1;
                    }

                }
                switch (alt97)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:308:20: cell_reference_options
            	    {
            	        this->followPush(FOLLOW_cell_reference_options_in_model_clause2697);
            	        cell_reference_options();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop97;	/* break out of the loop */
            	    break;
                }
            }
            loop97: ; /* Jump out to here if this rule does not match */


            // PLSQL_DMLParser.g:308:44: ( return_rows_clause )?
            {
                int alt98=2;
                {
                    int LA98_0 = this->LA(1);
                    if ( (LA98_0 == REGULAR_ID))
                    {
                        {
                            int LA98_1 = this->LA(2);
                            if ( (LA98_1 == REGULAR_ID))
                            {
                                {
                                    int LA98_2 = this->LA(3);
                                    if ( (LA98_2 == REGULAR_ID))
                                    {
                                        {
                                            int LA98_6 = this->LA(4);
                                            if ( (LA98_6 == REGULAR_ID))
                                            {
                                                alt98=1;
                                            }
                                        }
                                    }
                                }
                            }
                            else if ( (LA98_1 == SQL92_RESERVED_ALL))
                            {
                                alt98=1;
                            }
                        }
                    }
                }
                switch (alt98)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:308:44: return_rows_clause
            	    {
            	        this->followPush(FOLLOW_return_rows_clause_in_model_clause2700);
            	        return_rows_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:308:64: ( reference_model )*

            for (;;)
            {
                int alt99=2;
                alt99 = cdfa99.predict(this, this->get_rec(), this->get_istream(), cdfa99 );
                if  (this->hasException())
                {
                    goto rulemodel_clauseEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }

                switch (alt99)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:308:64: reference_model
            	    {
            	        this->followPush(FOLLOW_reference_model_in_model_clause2703);
            	        reference_model();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop99;	/* break out of the loop */
            	    break;
                }
            }
            loop99: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_main_model_in_model_clause2706);
            main_model();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_clauseEx; /* Prevent compiler warnings */
    rulemodel_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_clause */

/**
 * $ANTLR start cell_reference_options
 * PLSQL_DMLParser.g:311:1: cell_reference_options : ( ( ignore_key | keep_key ) nav_key | unique_key ( dimension_key | single_key reference_key ) );
 */
void
PLSQLParser_PLSQL_DMLParser::cell_reference_options()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:312:5: ( ( ignore_key | keep_key ) nav_key | unique_key ( dimension_key | single_key reference_key ) )

            ANTLR_UINT32 alt102;

            alt102=2;

            {
                int LA102_0 = this->LA(1);
                if ( (LA102_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))))
                {
                    alt102=1;
                }
                else if ( (LA102_0 == SQL92_RESERVED_UNIQUE))
                {
                    alt102=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 102 );
                    ex->set_state( 0 );


                    goto rulecell_reference_optionsEx;

                }
            }
            switch (alt102)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:312:10: ( ignore_key | keep_key ) nav_key
        	    {
        	        // PLSQL_DMLParser.g:312:10: ( ignore_key | keep_key )
        	        {
        	            int alt100=2;
        	            {
        	                int LA100_0 = this->LA(1);
        	                if ( (LA100_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))))
        	                {
        	                    {
        	                        int LA100_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "IGNORE"))))
        	                        {
        	                            alt100=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))
        	                        {
        	                            alt100=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 100 );
        	                            ex->set_state( 1 );


        	                            goto rulecell_reference_optionsEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 100 );
        	                    ex->set_state( 0 );


        	                    goto rulecell_reference_optionsEx;

        	                }
        	            }
        	            switch (alt100)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:312:11: ignore_key
        	        	    {
        	        	        this->followPush(FOLLOW_ignore_key_in_cell_reference_options2727);
        	        	        m_gPLSQLParser->ignore_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecell_reference_optionsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:312:22: keep_key
        	        	    {
        	        	        this->followPush(FOLLOW_keep_key_in_cell_reference_options2729);
        	        	        m_gPLSQLParser->keep_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecell_reference_optionsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_nav_key_in_cell_reference_options2732);
        	        m_gPLSQLParser->nav_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecell_reference_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:313:10: unique_key ( dimension_key | single_key reference_key )
        	    {
        	        this->followPush(FOLLOW_unique_key_in_cell_reference_options2743);
        	        m_gPLSQLParser->unique_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecell_reference_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:313:21: ( dimension_key | single_key reference_key )
        	        {
        	            int alt101=2;
        	            {
        	                int LA101_0 = this->LA(1);
        	                if ( (LA101_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SINGLE")))||((equalsIgnoreCase(LT(1)->getText(), "DIMENSION"))))))
        	                {
        	                    {
        	                        int LA101_1 = this->LA(2);
        	                        if ( (LA101_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SINGLE")))||((equalsIgnoreCase(LT(1)->getText(), "DIMENSION"))))))
        	                        {
        	                            {
        	                                int LA101_2 = this->LA(3);
        	                                if ( ((equalsIgnoreCase(LT(1)->getText(), "DIMENSION"))))
        	                                {
        	                                    alt101=1;
        	                                }
        	                                else if ( ((equalsIgnoreCase(LT(1)->getText(), "SINGLE"))))
        	                                {
        	                                    alt101=2;
        	                                }
        	                                else
        	                                {
        	                                    if (this->get_backtracking()>0)
        	                                    {
        	                                        this->set_failedflag( true );
        	                                        return ;
        	                                    }


        	                                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                                    ex->set_decisionNum( 101 );
        	                                    ex->set_state( 2 );


        	                                    goto rulecell_reference_optionsEx;

        	                                }
        	                            }
        	                        }
        	                        else if ( (LA101_1 == LEFT_PAREN || LA101_1 == SQL92_RESERVED_UNIQUE) && ((equalsIgnoreCase(LT(1)->getText(), "DIMENSION"))))
        	                        {
        	                            alt101=1;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 101 );
        	                            ex->set_state( 1 );


        	                            goto rulecell_reference_optionsEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 101 );
        	                    ex->set_state( 0 );


        	                    goto rulecell_reference_optionsEx;

        	                }
        	            }
        	            switch (alt101)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:313:22: dimension_key
        	        	    {
        	        	        this->followPush(FOLLOW_dimension_key_in_cell_reference_options2746);
        	        	        m_gPLSQLParser->dimension_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecell_reference_optionsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:313:36: single_key reference_key
        	        	    {
        	        	        this->followPush(FOLLOW_single_key_in_cell_reference_options2748);
        	        	        m_gPLSQLParser->single_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecell_reference_optionsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_reference_key_in_cell_reference_options2750);
        	        	        m_gPLSQLParser->reference_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecell_reference_optionsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulecell_reference_optionsEx; /* Prevent compiler warnings */
    rulecell_reference_optionsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cell_reference_options */

/**
 * $ANTLR start return_rows_clause
 * PLSQL_DMLParser.g:316:1: return_rows_clause : return_key ( updated_key | all_key ) rows_key ;
 */
void
PLSQLParser_PLSQL_DMLParser::return_rows_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:317:5: ( return_key ( updated_key | all_key ) rows_key )
        // PLSQL_DMLParser.g:317:10: return_key ( updated_key | all_key ) rows_key
        {
            this->followPush(FOLLOW_return_key_in_return_rows_clause2772);
            m_gPLSQLParser->return_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereturn_rows_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:317:21: ( updated_key | all_key )
            {
                int alt103=2;
                {
                    int LA103_0 = this->LA(1);
                    if ( (LA103_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "UPDATED"))))
                    {
                        alt103=1;
                    }
                    else if ( (LA103_0 == SQL92_RESERVED_ALL))
                    {
                        alt103=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 103 );
                        ex->set_state( 0 );


                        goto rulereturn_rows_clauseEx;

                    }
                }
                switch (alt103)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:317:22: updated_key
            	    {
            	        this->followPush(FOLLOW_updated_key_in_return_rows_clause2775);
            	        m_gPLSQLParser->updated_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulereturn_rows_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:317:34: all_key
            	    {
            	        this->followPush(FOLLOW_all_key_in_return_rows_clause2777);
            	        m_gPLSQLParser->all_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulereturn_rows_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_rows_key_in_return_rows_clause2780);
            m_gPLSQLParser->rows_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereturn_rows_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereturn_rows_clauseEx; /* Prevent compiler warnings */
    rulereturn_rows_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end return_rows_clause */

/**
 * $ANTLR start reference_model
 * PLSQL_DMLParser.g:320:1: reference_model : reference_key reference_model_name on_key LEFT_PAREN subquery RIGHT_PAREN model_column_clauses ( cell_reference_options )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::reference_model()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:321:5: ( reference_key reference_model_name on_key LEFT_PAREN subquery RIGHT_PAREN model_column_clauses ( cell_reference_options )* )
        // PLSQL_DMLParser.g:321:10: reference_key reference_model_name on_key LEFT_PAREN subquery RIGHT_PAREN model_column_clauses ( cell_reference_options )*
        {
            this->followPush(FOLLOW_reference_key_in_reference_model2800);
            m_gPLSQLParser->reference_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_reference_model_name_in_reference_model2802);
            m_gPLSQLParser->reference_model_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_on_key_in_reference_model2804);
            m_gPLSQLParser->on_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_reference_model2819);
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_subquery_in_reference_model2821);
            subquery();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_reference_model2823);
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_model_column_clauses_in_reference_model2825);
            model_column_clauses();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:323:13: ( cell_reference_options )*

            for (;;)
            {
                int alt104=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA104_0 = this->LA(1);
                    if ( (LA104_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "DIMENSION")))||((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "PARTITION")))||((equalsIgnoreCase(LT(1)->getText(), "KEEP")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))))
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA104_1 = this->LA(2);
                            if ( (LA104_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "KEEP")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))))
                            {
                                {
                                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                                    */
                                    int LA104_4 = this->LA(3);
                                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))))
                                    {
                                        alt104=1;
                                    }

                                }
                            }

                        }
                    }
                    else if ( (LA104_0 == SQL92_RESERVED_UNIQUE))
                    {
                        alt104=1;
                    }

                }
                switch (alt104)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:323:13: cell_reference_options
            	    {
            	        this->followPush(FOLLOW_cell_reference_options_in_reference_model2840);
            	        cell_reference_options();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulereference_modelEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop104;	/* break out of the loop */
            	    break;
                }
            }
            loop104: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereference_modelEx; /* Prevent compiler warnings */
    rulereference_modelEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end reference_model */

/**
 * $ANTLR start main_model
 * PLSQL_DMLParser.g:326:1: main_model : ( main_key main_model_name )? model_column_clauses ( cell_reference_options )* model_rules_clause ;
 */
void
PLSQLParser_PLSQL_DMLParser::main_model()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:327:5: ( ( main_key main_model_name )? model_column_clauses ( cell_reference_options )* model_rules_clause )
        // PLSQL_DMLParser.g:327:10: ( main_key main_model_name )? model_column_clauses ( cell_reference_options )* model_rules_clause
        {
            // PLSQL_DMLParser.g:327:10: ( main_key main_model_name )?
            {
                int alt105=2;
                {
                    int LA105_0 = this->LA(1);
                    if ( (LA105_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "DIMENSION")))||((equalsIgnoreCase(LT(1)->getText(), "PARTITION")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))))
                    {
                        {
                            int LA105_1 = this->LA(2);
                            if ( (LA105_1 == DELIMITED_ID || LA105_1 == INTRODUCER || LA105_1 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))
                            {
                                alt105=1;
                            }
                        }
                    }
                }
                switch (alt105)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:327:11: main_key main_model_name
            	    {
            	        this->followPush(FOLLOW_main_key_in_main_model2862);
            	        m_gPLSQLParser->main_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemain_modelEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_main_model_name_in_main_model2864);
            	        m_gPLSQLParser->main_model_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemain_modelEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_model_column_clauses_in_main_model2868);
            model_column_clauses();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemain_modelEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:327:59: ( cell_reference_options )*

            for (;;)
            {
                int alt106=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA106_0 = this->LA(1);
                    if ( (LA106_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "RULES")))||((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))))
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA106_1 = this->LA(2);
                            if ( (LA106_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "RULES")))||((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))))
                            {
                                {
                                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                                    */
                                    int LA106_5 = this->LA(3);
                                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))))
                                    {
                                        alt106=1;
                                    }

                                }
                            }

                        }
                    }
                    else if ( (LA106_0 == SQL92_RESERVED_UNIQUE))
                    {
                        alt106=1;
                    }

                }
                switch (alt106)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:327:59: cell_reference_options
            	    {
            	        this->followPush(FOLLOW_cell_reference_options_in_main_model2870);
            	        cell_reference_options();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemain_modelEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop106;	/* break out of the loop */
            	    break;
                }
            }
            loop106: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_model_rules_clause_in_main_model2873);
            model_rules_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemain_modelEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemain_modelEx; /* Prevent compiler warnings */
    rulemain_modelEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end main_model */

/**
 * $ANTLR start model_column_clauses
 * PLSQL_DMLParser.g:330:1: model_column_clauses : ( model_column_partition_part )? dimension_key by_key model_column_list measures_key model_column_list ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_column_clauses()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:331:5: ( ( model_column_partition_part )? dimension_key by_key model_column_list measures_key model_column_list )
        // PLSQL_DMLParser.g:331:10: ( model_column_partition_part )? dimension_key by_key model_column_list measures_key model_column_list
        {
            // PLSQL_DMLParser.g:331:10: ( model_column_partition_part )?
            {
                int alt107=2;
                {
                    int LA107_0 = this->LA(1);
                    if ( (LA107_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "DIMENSION")))||((equalsIgnoreCase(LT(1)->getText(), "PARTITION"))))))
                    {
                        {
                            int LA107_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "PARTITION"))))
                            {
                                alt107=1;
                            }
                        }
                    }
                }
                switch (alt107)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:331:10: model_column_partition_part
            	    {
            	        this->followPush(FOLLOW_model_column_partition_part_in_model_column_clauses2893);
            	        model_column_partition_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_column_clausesEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_dimension_key_in_model_column_clauses2904);
            m_gPLSQLParser->dimension_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_clausesEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_by_key_in_model_column_clauses2906);
            m_gPLSQLParser->by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_clausesEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_model_column_list_in_model_column_clauses2908);
            model_column_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_clausesEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_measures_key_in_model_column_clauses2910);
            m_gPLSQLParser->measures_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_clausesEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_model_column_list_in_model_column_clauses2912);
            model_column_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_clausesEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_column_clausesEx; /* Prevent compiler warnings */
    rulemodel_column_clausesEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_column_clauses */

/**
 * $ANTLR start model_column_partition_part
 * PLSQL_DMLParser.g:335:1: model_column_partition_part : partition_key by_key model_column_list ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_column_partition_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:336:5: ( partition_key by_key model_column_list )
        // PLSQL_DMLParser.g:336:10: partition_key by_key model_column_list
        {
            this->followPush(FOLLOW_partition_key_in_model_column_partition_part2932);
            m_gPLSQLParser->partition_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_partition_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_by_key_in_model_column_partition_part2934);
            m_gPLSQLParser->by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_partition_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_model_column_list_in_model_column_partition_part2936);
            model_column_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_partition_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_column_partition_partEx; /* Prevent compiler warnings */
    rulemodel_column_partition_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_column_partition_part */

/**
 * $ANTLR start model_column_list
 * PLSQL_DMLParser.g:339:1: model_column_list : LEFT_PAREN model_column ( COMMA model_column )* RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_column_list()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:340:5: ( LEFT_PAREN model_column ( COMMA model_column )* RIGHT_PAREN )
        // PLSQL_DMLParser.g:340:10: LEFT_PAREN model_column ( COMMA model_column )* RIGHT_PAREN
        {
             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_model_column_list2956);
            if  (this->hasException())
            {
                goto rulemodel_column_listEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_model_column_in_model_column_list2958);
            model_column();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_listEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:340:34: ( COMMA model_column )*

            for (;;)
            {
                int alt108=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA108_0 = this->LA(1);
                    if ( (LA108_0 == COMMA))
                    {
                        alt108=1;
                    }

                }
                switch (alt108)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:340:35: COMMA model_column
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_model_column_list2961);
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_column_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_model_column_in_model_column_list2963);
            	        model_column();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_column_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop108;	/* break out of the loop */
            	    break;
                }
            }
            loop108: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_model_column_list2968);
            if  (this->hasException())
            {
                goto rulemodel_column_listEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_column_listEx; /* Prevent compiler warnings */
    rulemodel_column_listEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_column_list */

/**
 * $ANTLR start model_column
 * PLSQL_DMLParser.g:343:1: model_column : expression ( table_alias )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_column()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:344:5: ( expression ( table_alias )? )
        // PLSQL_DMLParser.g:344:10: expression ( table_alias )?
        {
            this->followPush(FOLLOW_expression_in_model_column2988);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_columnEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:344:21: ( table_alias )?
            {
                int alt109=2;
                {
                    int LA109_0 = this->LA(1);
                    if ( (((LA109_0 >= CHAR_STRING) && (LA109_0 <= CHAR_STRING_PERL)) || LA109_0 == DELIMITED_ID || LA109_0 == INTRODUCER || LA109_0 == NATIONAL_CHAR_STRING_LIT || LA109_0 == REGULAR_ID))
                    {
                        alt109=1;
                    }
                }
                switch (alt109)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:344:21: table_alias
            	    {
            	        this->followPush(FOLLOW_table_alias_in_model_column2990);
            	        m_gPLSQLParser->table_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_columnEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_columnEx; /* Prevent compiler warnings */
    rulemodel_columnEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_column */

/**
 * $ANTLR start model_rules_clause
 * PLSQL_DMLParser.g:347:1: model_rules_clause : ( model_rules_part )? LEFT_PAREN model_rules_element ( COMMA model_rules_element )* RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_rules_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:348:5: ( ( model_rules_part )? LEFT_PAREN model_rules_element ( COMMA model_rules_element )* RIGHT_PAREN )
        // PLSQL_DMLParser.g:348:10: ( model_rules_part )? LEFT_PAREN model_rules_element ( COMMA model_rules_element )* RIGHT_PAREN
        {
            // PLSQL_DMLParser.g:348:10: ( model_rules_part )?
            {
                int alt110=2;
                {
                    int LA110_0 = this->LA(1);
                    if ( (LA110_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "RULES"))))
                    {
                        alt110=1;
                    }
                }
                switch (alt110)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:348:10: model_rules_part
            	    {
            	        this->followPush(FOLLOW_model_rules_part_in_model_rules_clause3011);
            	        model_rules_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_model_rules_clause3014);
            if  (this->hasException())
            {
                goto rulemodel_rules_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_model_rules_element_in_model_rules_clause3016);
            model_rules_element();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_rules_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:348:59: ( COMMA model_rules_element )*

            for (;;)
            {
                int alt111=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA111_0 = this->LA(1);
                    if ( (LA111_0 == COMMA))
                    {
                        alt111=1;
                    }

                }
                switch (alt111)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:348:60: COMMA model_rules_element
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_model_rules_clause3019);
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_model_rules_element_in_model_rules_clause3021);
            	        model_rules_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop111;	/* break out of the loop */
            	    break;
                }
            }
            loop111: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_model_rules_clause3025);
            if  (this->hasException())
            {
                goto rulemodel_rules_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_rules_clauseEx; /* Prevent compiler warnings */
    rulemodel_rules_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_rules_clause */

/**
 * $ANTLR start model_rules_part
 * PLSQL_DMLParser.g:351:1: model_rules_part : rules_key ( update_key | upsert_key ( all_key )? )? ( ( automatic_key | sequential_key ) order_key )? ( model_iterate_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_rules_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:352:5: ( rules_key ( update_key | upsert_key ( all_key )? )? ( ( automatic_key | sequential_key ) order_key )? ( model_iterate_clause )? )
        // PLSQL_DMLParser.g:352:10: rules_key ( update_key | upsert_key ( all_key )? )? ( ( automatic_key | sequential_key ) order_key )? ( model_iterate_clause )?
        {
            this->followPush(FOLLOW_rules_key_in_model_rules_part3045);
            m_gPLSQLParser->rules_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_rules_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:352:20: ( update_key | upsert_key ( all_key )? )?
            {
                int alt113=3;
                {
                    int LA113_0 = this->LA(1);
                    if ( (LA113_0 == SQL92_RESERVED_UPDATE))
                    {
                        alt113=1;
                    }
                    else if ( (LA113_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "AUTOMATIC")))||((equalsIgnoreCase(LT(1)->getText(), "UPSERT")))||((equalsIgnoreCase(LT(1)->getText(), "ITERATE")))||((equalsIgnoreCase(LT(1)->getText(), "SEQUENTIAL"))))))
                    {
                        {
                            int LA113_2 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "UPSERT"))))
                            {
                                alt113=2;
                            }
                        }
                    }
                }
                switch (alt113)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:352:21: update_key
            	    {
            	        this->followPush(FOLLOW_update_key_in_model_rules_part3048);
            	        m_gPLSQLParser->update_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:352:32: upsert_key ( all_key )?
            	    {
            	        this->followPush(FOLLOW_upsert_key_in_model_rules_part3050);
            	        m_gPLSQLParser->upsert_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:352:43: ( all_key )?
            	        {
            	            int alt112=2;
            	            {
            	                int LA112_0 = this->LA(1);
            	                if ( (LA112_0 == SQL92_RESERVED_ALL))
            	                {
            	                    alt112=1;
            	                }
            	            }
            	            switch (alt112)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:352:43: all_key
            	        	    {
            	        	        this->followPush(FOLLOW_all_key_in_model_rules_part3052);
            	        	        m_gPLSQLParser->all_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemodel_rules_partEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:352:54: ( ( automatic_key | sequential_key ) order_key )?
            {
                int alt115=2;
                {
                    int LA115_0 = this->LA(1);
                    if ( (LA115_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "AUTOMATIC")))||((equalsIgnoreCase(LT(1)->getText(), "ITERATE")))||((equalsIgnoreCase(LT(1)->getText(), "SEQUENTIAL"))))))
                    {
                        {
                            int LA115_1 = this->LA(2);
                            if ( (LA115_1 == SQL92_RESERVED_ORDER) && ((((equalsIgnoreCase(LT(1)->getText(), "AUTOMATIC")))||((equalsIgnoreCase(LT(1)->getText(), "SEQUENTIAL"))))))
                            {
                                alt115=1;
                            }
                        }
                    }
                }
                switch (alt115)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:352:55: ( automatic_key | sequential_key ) order_key
            	    {
            	        // PLSQL_DMLParser.g:352:55: ( automatic_key | sequential_key )
            	        {
            	            int alt114=2;
            	            {
            	                int LA114_0 = this->LA(1);
            	                if ( (LA114_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "AUTOMATIC")))||((equalsIgnoreCase(LT(1)->getText(), "SEQUENTIAL"))))))
            	                {
            	                    {
            	                        int LA114_1 = this->LA(2);
            	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "AUTOMATIC"))))
            	                        {
            	                            alt114=1;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "SEQUENTIAL"))))
            	                        {
            	                            alt114=2;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 114 );
            	                            ex->set_state( 1 );


            	                            goto rulemodel_rules_partEx;

            	                        }
            	                    }
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 114 );
            	                    ex->set_state( 0 );


            	                    goto rulemodel_rules_partEx;

            	                }
            	            }
            	            switch (alt114)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:352:56: automatic_key
            	        	    {
            	        	        this->followPush(FOLLOW_automatic_key_in_model_rules_part3059);
            	        	        m_gPLSQLParser->automatic_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemodel_rules_partEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:352:70: sequential_key
            	        	    {
            	        	        this->followPush(FOLLOW_sequential_key_in_model_rules_part3061);
            	        	        m_gPLSQLParser->sequential_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemodel_rules_partEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_order_key_in_model_rules_part3064);
            	        m_gPLSQLParser->order_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:352:98: ( model_iterate_clause )?
            {
                int alt116=2;
                {
                    int LA116_0 = this->LA(1);
                    if ( (LA116_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "ITERATE"))))
                    {
                        alt116=1;
                    }
                }
                switch (alt116)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:352:98: model_iterate_clause
            	    {
            	        this->followPush(FOLLOW_model_iterate_clause_in_model_rules_part3068);
            	        model_iterate_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_rules_partEx; /* Prevent compiler warnings */
    rulemodel_rules_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_rules_part */

/**
 * $ANTLR start model_rules_element
 * PLSQL_DMLParser.g:355:1: model_rules_element : ( update_key | upsert_key ( ( all_key )=> all_key )? )? cell_assignment ( order_by_clause )? EQUALS_OP expression ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_rules_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:356:5: ( ( update_key | upsert_key ( ( all_key )=> all_key )? )? cell_assignment ( order_by_clause )? EQUALS_OP expression )
        // PLSQL_DMLParser.g:356:10: ( update_key | upsert_key ( ( all_key )=> all_key )? )? cell_assignment ( order_by_clause )? EQUALS_OP expression
        {
            // PLSQL_DMLParser.g:356:10: ( update_key | upsert_key ( ( all_key )=> all_key )? )?
            {
                int alt118=3;
                {
                    int LA118_0 = this->LA(1);
                    if ( (LA118_0 == SQL92_RESERVED_UPDATE))
                    {
                        alt118=1;
                    }
                    else if ( (LA118_0 == REGULAR_ID))
                    {
                        {
                            int LA118_2 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "UPSERT"))))
                            {
                                alt118=2;
                            }
                        }
                    }
                }
                switch (alt118)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:356:11: update_key
            	    {
            	        this->followPush(FOLLOW_update_key_in_model_rules_element3090);
            	        m_gPLSQLParser->update_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:356:22: upsert_key ( ( all_key )=> all_key )?
            	    {
            	        this->followPush(FOLLOW_upsert_key_in_model_rules_element3092);
            	        m_gPLSQLParser->upsert_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:356:33: ( ( all_key )=> all_key )?
            	        {
            	            int alt117=2;
            	            {
            	                int LA117_0 = this->LA(1);
            	                if ( (LA117_0 == SQL92_RESERVED_ALL))
            	                {
            	                    {
            	                        int LA117_1 = this->LA(2);
            	                        if ( (this->msynpred( antlr3::ClassForwarder<synpred19_PLSQL_DMLParser>() )))
            	                        {
            	                            alt117=1;
            	                        }
            	                    }
            	                }
            	            }
            	            switch (alt117)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:356:34: ( all_key )=> all_key
            	        	    {
            	        	        this->followPush(FOLLOW_all_key_in_model_rules_element3100);
            	        	        m_gPLSQLParser->all_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemodel_rules_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_cell_assignment_in_model_rules_element3114);
            cell_assignment();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_rules_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:358:17: ( order_by_clause )?
            {
                int alt119=2;
                {
                    int LA119_0 = this->LA(1);
                    if ( (LA119_0 == SQL92_RESERVED_ORDER))
                    {
                        alt119=1;
                    }
                }
                switch (alt119)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:358:17: order_by_clause
            	    {
            	        this->followPush(FOLLOW_order_by_clause_in_model_rules_element3132);
            	        order_by_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_model_rules_element3147);
            if  (this->hasException())
            {
                goto rulemodel_rules_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_model_rules_element3149);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_rules_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_rules_elementEx; /* Prevent compiler warnings */
    rulemodel_rules_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_rules_element */

/**
 * $ANTLR start cell_assignment
 * PLSQL_DMLParser.g:362:1: cell_assignment : model_expression ;
 */
void
PLSQLParser_PLSQL_DMLParser::cell_assignment()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:363:5: ( model_expression )
        // PLSQL_DMLParser.g:363:10: model_expression
        {
            this->followPush(FOLLOW_model_expression_in_cell_assignment3169);
            model_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecell_assignmentEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecell_assignmentEx; /* Prevent compiler warnings */
    rulecell_assignmentEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cell_assignment */

/**
 * $ANTLR start model_iterate_clause
 * PLSQL_DMLParser.g:366:1: model_iterate_clause : iterate_key LEFT_PAREN expression RIGHT_PAREN ( until_part )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_iterate_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:367:5: ( iterate_key LEFT_PAREN expression RIGHT_PAREN ( until_part )? )
        // PLSQL_DMLParser.g:367:10: iterate_key LEFT_PAREN expression RIGHT_PAREN ( until_part )?
        {
            this->followPush(FOLLOW_iterate_key_in_model_iterate_clause3189);
            m_gPLSQLParser->iterate_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_iterate_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_model_iterate_clause3191);
            if  (this->hasException())
            {
                goto rulemodel_iterate_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_model_iterate_clause3193);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_iterate_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_model_iterate_clause3195);
            if  (this->hasException())
            {
                goto rulemodel_iterate_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:367:56: ( until_part )?
            {
                int alt120=2;
                {
                    int LA120_0 = this->LA(1);
                    if ( (LA120_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "UNTIL"))))
                    {
                        alt120=1;
                    }
                }
                switch (alt120)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:367:56: until_part
            	    {
            	        this->followPush(FOLLOW_until_part_in_model_iterate_clause3197);
            	        until_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_iterate_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_iterate_clauseEx; /* Prevent compiler warnings */
    rulemodel_iterate_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_iterate_clause */

/**
 * $ANTLR start until_part
 * PLSQL_DMLParser.g:370:1: until_part : until_key LEFT_PAREN condition RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::until_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:371:5: ( until_key LEFT_PAREN condition RIGHT_PAREN )
        // PLSQL_DMLParser.g:371:10: until_key LEFT_PAREN condition RIGHT_PAREN
        {
            this->followPush(FOLLOW_until_key_in_until_part3218);
            m_gPLSQLParser->until_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleuntil_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_until_part3220);
            if  (this->hasException())
            {
                goto ruleuntil_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_condition_in_until_part3222);
            condition();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleuntil_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_until_part3224);
            if  (this->hasException())
            {
                goto ruleuntil_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleuntil_partEx; /* Prevent compiler warnings */
    ruleuntil_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end until_part */

/**
 * $ANTLR start order_by_clause
 * PLSQL_DMLParser.g:374:1: order_by_clause : order_key ( siblings_key )? by_key order_by_elements ( COMMA order_by_elements )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::order_by_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:375:5: ( order_key ( siblings_key )? by_key order_by_elements ( COMMA order_by_elements )* )
        // PLSQL_DMLParser.g:375:10: order_key ( siblings_key )? by_key order_by_elements ( COMMA order_by_elements )*
        {
            this->followPush(FOLLOW_order_key_in_order_by_clause3244);
            m_gPLSQLParser->order_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleorder_by_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:375:20: ( siblings_key )?
            {
                int alt121=2;
                {
                    int LA121_0 = this->LA(1);
                    if ( (LA121_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "SIBLINGS"))))
                    {
                        alt121=1;
                    }
                }
                switch (alt121)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:375:20: siblings_key
            	    {
            	        this->followPush(FOLLOW_siblings_key_in_order_by_clause3246);
            	        m_gPLSQLParser->siblings_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_by_key_in_order_by_clause3249);
            m_gPLSQLParser->by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleorder_by_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_order_by_elements_in_order_by_clause3251);
            order_by_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleorder_by_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:375:59: ( COMMA order_by_elements )*

            for (;;)
            {
                int alt122=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA122_0 = this->LA(1);
                    if ( (LA122_0 == COMMA))
                    {
                        alt122=1;
                    }

                }
                switch (alt122)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:375:60: COMMA order_by_elements
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_order_by_clause3254);
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_order_by_elements_in_order_by_clause3256);
            	        order_by_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop122;	/* break out of the loop */
            	    break;
                }
            }
            loop122: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleorder_by_clauseEx; /* Prevent compiler warnings */
    ruleorder_by_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end order_by_clause */

/**
 * $ANTLR start order_by_elements
 * PLSQL_DMLParser.g:378:1: order_by_elements : expression ( asc_key | desc_key )? ( nulls_key ( first_key | last_key ) )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::order_by_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:379:5: ( expression ( asc_key | desc_key )? ( nulls_key ( first_key | last_key ) )? )
        // PLSQL_DMLParser.g:379:10: expression ( asc_key | desc_key )? ( nulls_key ( first_key | last_key ) )?
        {
            this->followPush(FOLLOW_expression_in_order_by_elements3278);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleorder_by_elementsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:379:21: ( asc_key | desc_key )?
            {
                int alt123=3;
                {
                    int LA123_0 = this->LA(1);
                    if ( (LA123_0 == SQL92_RESERVED_ASC))
                    {
                        alt123=1;
                    }
                    else if ( (LA123_0 == SQL92_RESERVED_DESC))
                    {
                        alt123=2;
                    }
                }
                switch (alt123)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:379:22: asc_key
            	    {
            	        this->followPush(FOLLOW_asc_key_in_order_by_elements3281);
            	        m_gPLSQLParser->asc_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:379:30: desc_key
            	    {
            	        this->followPush(FOLLOW_desc_key_in_order_by_elements3283);
            	        m_gPLSQLParser->desc_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:379:41: ( nulls_key ( first_key | last_key ) )?
            {
                int alt125=2;
                {
                    int LA125_0 = this->LA(1);
                    if ( (LA125_0 == REGULAR_ID))
                    {
                        {
                            int LA125_1 = this->LA(2);
                            if ( (LA125_1 == REGULAR_ID))
                            {
                                {
                                    int LA125_3 = this->LA(3);
                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))
                                    {
                                        alt125=1;
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt125)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:379:42: nulls_key ( first_key | last_key )
            	    {
            	        this->followPush(FOLLOW_nulls_key_in_order_by_elements3288);
            	        m_gPLSQLParser->nulls_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:379:52: ( first_key | last_key )
            	        {
            	            int alt124=2;
            	            {
            	                int LA124_0 = this->LA(1);
            	                if ( (LA124_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FIRST")))||((equalsIgnoreCase(LT(1)->getText(), "LAST"))))))
            	                {
            	                    {
            	                        int LA124_1 = this->LA(2);
            	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "FIRST"))))
            	                        {
            	                            alt124=1;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "LAST"))))
            	                        {
            	                            alt124=2;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 124 );
            	                            ex->set_state( 1 );


            	                            goto ruleorder_by_elementsEx;

            	                        }
            	                    }
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 124 );
            	                    ex->set_state( 0 );


            	                    goto ruleorder_by_elementsEx;

            	                }
            	            }
            	            switch (alt124)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:379:53: first_key
            	        	    {
            	        	        this->followPush(FOLLOW_first_key_in_order_by_elements3291);
            	        	        m_gPLSQLParser->first_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleorder_by_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:379:63: last_key
            	        	    {
            	        	        this->followPush(FOLLOW_last_key_in_order_by_elements3293);
            	        	        m_gPLSQLParser->last_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleorder_by_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleorder_by_elementsEx; /* Prevent compiler warnings */
    ruleorder_by_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end order_by_elements */

/**
 * $ANTLR start for_update_clause
 * PLSQL_DMLParser.g:382:1: for_update_clause : for_key update_key ( for_update_of_part )? ( for_update_options )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::for_update_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:383:5: ( for_key update_key ( for_update_of_part )? ( for_update_options )? )
        // PLSQL_DMLParser.g:383:10: for_key update_key ( for_update_of_part )? ( for_update_options )?
        {
            this->followPush(FOLLOW_for_key_in_for_update_clause3316);
            m_gPLSQLParser->for_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_update_key_in_for_update_clause3318);
            m_gPLSQLParser->update_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:383:29: ( for_update_of_part )?
            {
                int alt126=2;
                {
                    int LA126_0 = this->LA(1);
                    if ( (LA126_0 == SQL92_RESERVED_OF))
                    {
                        alt126=1;
                    }
                }
                switch (alt126)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:383:29: for_update_of_part
            	    {
            	        this->followPush(FOLLOW_for_update_of_part_in_for_update_clause3320);
            	        for_update_of_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefor_update_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:383:49: ( for_update_options )?
            {
                int alt127=2;
                {
                    int LA127_0 = this->LA(1);
                    if ( (LA127_0 == REGULAR_ID))
                    {
                        {
                            int LA127_1 = this->LA(2);
                            if ( ((((equalsIgnoreCase(LT(1)->getText(), "SKIP")))||((equalsIgnoreCase(LT(1)->getText(), "WAIT"))))))
                            {
                                alt127=1;
                            }
                        }
                    }
                    else if ( (LA127_0 == PLSQL_RESERVED_NOWAIT))
                    {
                        alt127=1;
                    }
                }
                switch (alt127)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:383:49: for_update_options
            	    {
            	        this->followPush(FOLLOW_for_update_options_in_for_update_clause3323);
            	        for_update_options();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefor_update_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulefor_update_clauseEx; /* Prevent compiler warnings */
    rulefor_update_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end for_update_clause */

/**
 * $ANTLR start for_update_of_part
 * PLSQL_DMLParser.g:386:1: for_update_of_part : of_key column_name ( COMMA column_name )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::for_update_of_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:387:5: ( of_key column_name ( COMMA column_name )* )
        // PLSQL_DMLParser.g:387:10: of_key column_name ( COMMA column_name )*
        {
            this->followPush(FOLLOW_of_key_in_for_update_of_part3344);
            m_gPLSQLParser->of_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_update_of_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_for_update_of_part3346);
            m_gPLSQLParser->column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_update_of_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:387:29: ( COMMA column_name )*

            for (;;)
            {
                int alt128=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA128_0 = this->LA(1);
                    if ( (LA128_0 == COMMA))
                    {
                        alt128=1;
                    }

                }
                switch (alt128)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:387:30: COMMA column_name
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_for_update_of_part3349);
            	        if  (this->hasException())
            	        {
            	            goto rulefor_update_of_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_for_update_of_part3351);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefor_update_of_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop128;	/* break out of the loop */
            	    break;
                }
            }
            loop128: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefor_update_of_partEx; /* Prevent compiler warnings */
    rulefor_update_of_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end for_update_of_part */

/**
 * $ANTLR start for_update_options
 * PLSQL_DMLParser.g:390:1: for_update_options : ( skip_key locked_key | nowait_key | wait_key expression );
 */
void
PLSQLParser_PLSQL_DMLParser::for_update_options()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:391:5: ( skip_key locked_key | nowait_key | wait_key expression )

            ANTLR_UINT32 alt129;

            alt129=3;

            {
                int LA129_0 = this->LA(1);
                if ( (LA129_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SKIP")))||((equalsIgnoreCase(LT(1)->getText(), "WAIT"))))))
                {
                    {
                        int LA129_1 = this->LA(2);
                        if ( (LA129_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SKIP")))||((equalsIgnoreCase(LT(1)->getText(), "WAIT"))))))
                        {
                            {
                                int LA129_3 = this->LA(3);
                                if ( ((equalsIgnoreCase(LT(1)->getText(), "SKIP"))))
                                {
                                    alt129=1;
                                }
                                else if ( ((equalsIgnoreCase(LT(1)->getText(), "WAIT"))))
                                {
                                    alt129=3;
                                }
                                else
                                {
                                    if (this->get_backtracking()>0)
                                    {
                                        this->set_failedflag( true );
                                        return ;
                                    }


                                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                    ex->set_decisionNum( 129 );
                                    ex->set_state( 3 );


                                    goto rulefor_update_optionsEx;

                                }
                            }
                        }
                        else if ( (LA129_1 == APPROXIMATE_NUM_LIT || LA129_1 == BINDVAR || ((LA129_1 >= CHAR_STRING) && (LA129_1 <= COLON)) || LA129_1 == DELIMITED_ID || LA129_1 == EXACT_NUM_LIT || LA129_1 == INTRODUCER || LA129_1 == LEFT_PAREN || ((LA129_1 >= MINUS_SIGN) && (LA129_1 <= NATIONAL_CHAR_STRING_LIT)) || LA129_1 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA129_1 == PLUS_SIGN || LA129_1 == SQL92_RESERVED_ALL || LA129_1 == SQL92_RESERVED_ANY || LA129_1 == SQL92_RESERVED_CASE || ((LA129_1 >= SQL92_RESERVED_CURSOR) && (LA129_1 <= SQL92_RESERVED_DATE)) || LA129_1 == SQL92_RESERVED_DEFAULT || LA129_1 == SQL92_RESERVED_DISTINCT || ((LA129_1 >= SQL92_RESERVED_EXISTS) && (LA129_1 <= SQL92_RESERVED_FALSE)) || ((LA129_1 >= SQL92_RESERVED_NOT) && (LA129_1 <= SQL92_RESERVED_NULL)) || LA129_1 == SQL92_RESERVED_PRIOR || LA129_1 == SQL92_RESERVED_TRUE || LA129_1 == UNSIGNED_INTEGER) && ((equalsIgnoreCase(LT(1)->getText(), "WAIT"))))
                        {
                            alt129=3;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 129 );
                            ex->set_state( 1 );


                            goto rulefor_update_optionsEx;

                        }
                    }
                }
                else if ( (LA129_0 == PLSQL_RESERVED_NOWAIT))
                {
                    alt129=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 129 );
                    ex->set_state( 0 );


                    goto rulefor_update_optionsEx;

                }
            }
            switch (alt129)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:391:10: skip_key locked_key
        	    {
        	        this->followPush(FOLLOW_skip_key_in_for_update_options3373);
        	        m_gPLSQLParser->skip_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_update_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_locked_key_in_for_update_options3375);
        	        m_gPLSQLParser->locked_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_update_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:392:10: nowait_key
        	    {
        	        this->followPush(FOLLOW_nowait_key_in_for_update_options3386);
        	        m_gPLSQLParser->nowait_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_update_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:393:10: wait_key expression
        	    {
        	        this->followPush(FOLLOW_wait_key_in_for_update_options3397);
        	        m_gPLSQLParser->wait_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_update_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_in_for_update_options3399);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_update_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulefor_update_optionsEx; /* Prevent compiler warnings */
    rulefor_update_optionsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end for_update_options */

/**
 * $ANTLR start update_statement
 * PLSQL_DMLParser.g:398:1: update_statement : update_key general_table_ref update_set_clause ( where_clause )? ( static_returning_clause )? ( error_logging_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::update_statement()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:399:5: ( update_key general_table_ref update_set_clause ( where_clause )? ( static_returning_clause )? ( error_logging_clause )? )
        // PLSQL_DMLParser.g:399:10: update_key general_table_ref update_set_clause ( where_clause )? ( static_returning_clause )? ( error_logging_clause )?
        {
            this->followPush(FOLLOW_update_key_in_update_statement3421);
            m_gPLSQLParser->update_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleupdate_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_general_table_ref_in_update_statement3423);
            general_table_ref();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleupdate_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_update_set_clause_in_update_statement3433);
            update_set_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleupdate_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:401:9: ( where_clause )?
            {
                int alt130=2;
                {
                    int LA130_0 = this->LA(1);
                    if ( (LA130_0 == SQL92_RESERVED_WHERE))
                    {
                        alt130=1;
                    }
                }
                switch (alt130)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:401:9: where_clause
            	    {
            	        this->followPush(FOLLOW_where_clause_in_update_statement3443);
            	        m_gPLSQLParser->where_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:401:23: ( static_returning_clause )?
            {
                int alt131=2;
                {
                    int LA131_0 = this->LA(1);
                    if ( (LA131_0 == REGULAR_ID))
                    {
                        {
                            int LA131_1 = this->LA(2);
                            if ( ((((equalsIgnoreCase(LT(1)->getText(), "RETURNING")))||((equalsIgnoreCase(LT(1)->getText(), "RETURN"))))))
                            {
                                alt131=1;
                            }
                        }
                    }
                }
                switch (alt131)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:401:23: static_returning_clause
            	    {
            	        this->followPush(FOLLOW_static_returning_clause_in_update_statement3446);
            	        static_returning_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:401:48: ( error_logging_clause )?
            {
                int alt132=2;
                {
                    int LA132_0 = this->LA(1);
                    if ( (LA132_0 == REGULAR_ID))
                    {
                        {
                            int LA132_1 = this->LA(2);
                            if ( (LA132_1 == REGULAR_ID))
                            {
                                {
                                    int LA132_3 = this->LA(3);
                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "LOG"))))
                                    {
                                        alt132=1;
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt132)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:401:48: error_logging_clause
            	    {
            	        this->followPush(FOLLOW_error_logging_clause_in_update_statement3449);
            	        error_logging_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleupdate_statementEx; /* Prevent compiler warnings */
    ruleupdate_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end update_statement */

/**
 * $ANTLR start update_set_clause
 * PLSQL_DMLParser.g:405:1: update_set_clause : set_key ( column_based_update_set_clause ( COMMA column_based_update_set_clause )* | value_key LEFT_PAREN id RIGHT_PAREN EQUALS_OP expression ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::update_set_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:406:5: ( set_key ( column_based_update_set_clause ( COMMA column_based_update_set_clause )* | value_key LEFT_PAREN id RIGHT_PAREN EQUALS_OP expression ) )
        // PLSQL_DMLParser.g:406:10: set_key ( column_based_update_set_clause ( COMMA column_based_update_set_clause )* | value_key LEFT_PAREN id RIGHT_PAREN EQUALS_OP expression )
        {
            this->followPush(FOLLOW_set_key_in_update_set_clause3471);
            m_gPLSQLParser->set_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleupdate_set_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:407:5: ( column_based_update_set_clause ( COMMA column_based_update_set_clause )* | value_key LEFT_PAREN id RIGHT_PAREN EQUALS_OP expression )
            {
                int alt134=2;
                {
                    int LA134_0 = this->LA(1);
                    if ( (LA134_0 == DELIMITED_ID || LA134_0 == INTRODUCER || LA134_0 == LEFT_PAREN))
                    {
                        alt134=1;
                    }
                    else if ( (LA134_0 == REGULAR_ID))
                    {
                        {
                            int LA134_2 = this->LA(2);
                            if ( (LA134_2 == EQUALS_OP || LA134_2 == PERIOD))
                            {
                                alt134=1;
                            }
                            else if ( (LA134_2 == LEFT_PAREN))
                            {
                                alt134=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 134 );
                                ex->set_state( 2 );


                                goto ruleupdate_set_clauseEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 134 );
                        ex->set_state( 0 );


                        goto ruleupdate_set_clauseEx;

                    }
                }
                switch (alt134)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:407:10: column_based_update_set_clause ( COMMA column_based_update_set_clause )*
            	    {
            	        this->followPush(FOLLOW_column_based_update_set_clause_in_update_set_clause3482);
            	        column_based_update_set_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:407:41: ( COMMA column_based_update_set_clause )*

            	        for (;;)
            	        {
            	            int alt133=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA133_0 = this->LA(1);
            	                if ( (LA133_0 == COMMA))
            	                {
            	                    alt133=1;
            	                }

            	            }
            	            switch (alt133)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:407:42: COMMA column_based_update_set_clause
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_update_set_clause3485);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleupdate_set_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_column_based_update_set_clause_in_update_set_clause3487);
            	        	        column_based_update_set_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleupdate_set_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop133;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop133: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:408:10: value_key LEFT_PAREN id RIGHT_PAREN EQUALS_OP expression
            	    {
            	        this->followPush(FOLLOW_value_key_in_update_set_clause3500);
            	        m_gPLSQLParser->value_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_update_set_clause3502);
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_in_update_set_clause3504);
            	        m_gPLSQLParser->id();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_update_set_clause3506);
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_update_set_clause3508);
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_update_set_clause3510);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleupdate_set_clauseEx; /* Prevent compiler warnings */
    ruleupdate_set_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end update_set_clause */

/**
 * $ANTLR start column_based_update_set_clause
 * PLSQL_DMLParser.g:412:1: column_based_update_set_clause : ( column_name EQUALS_OP expression | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN EQUALS_OP subquery );
 */
void
PLSQLParser_PLSQL_DMLParser::column_based_update_set_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:413:5: ( column_name EQUALS_OP expression | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN EQUALS_OP subquery )

            ANTLR_UINT32 alt136;

            alt136=2;

            {
                int LA136_0 = this->LA(1);
                if ( (LA136_0 == DELIMITED_ID || LA136_0 == INTRODUCER || LA136_0 == REGULAR_ID))
                {
                    alt136=1;
                }
                else if ( (LA136_0 == LEFT_PAREN))
                {
                    alt136=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 136 );
                    ex->set_state( 0 );


                    goto rulecolumn_based_update_set_clauseEx;

                }
            }
            switch (alt136)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:413:10: column_name EQUALS_OP expression
        	    {
        	        this->followPush(FOLLOW_column_name_in_column_based_update_set_clause3536);
        	        m_gPLSQLParser->column_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_column_based_update_set_clause3538);
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_in_column_based_update_set_clause3540);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:414:10: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN EQUALS_OP subquery
        	    {
        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_column_based_update_set_clause3551);
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_column_name_in_column_based_update_set_clause3553);
        	        m_gPLSQLParser->column_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:414:33: ( COMMA column_name )*

        	        for (;;)
        	        {
        	            int alt135=2;
        	            {
        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                */
        	                int LA135_0 = this->LA(1);
        	                if ( (LA135_0 == COMMA))
        	                {
        	                    alt135=1;
        	                }

        	            }
        	            switch (alt135)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:414:34: COMMA column_name
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_column_based_update_set_clause3556);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecolumn_based_update_set_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_column_name_in_column_based_update_set_clause3558);
        	        	        m_gPLSQLParser->column_name();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecolumn_based_update_set_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop135;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop135: ; /* Jump out to here if this rule does not match */


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_column_based_update_set_clause3562);
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_column_based_update_set_clause3564);
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_subquery_in_column_based_update_set_clause3566);
        	        subquery();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulecolumn_based_update_set_clauseEx; /* Prevent compiler warnings */
    rulecolumn_based_update_set_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end column_based_update_set_clause */

/**
 * $ANTLR start delete_statement
 * PLSQL_DMLParser.g:419:1: delete_statement : delete_key ( from_key )? general_table_ref ( where_clause )? ( static_returning_clause )? ( error_logging_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::delete_statement()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:420:5: ( delete_key ( from_key )? general_table_ref ( where_clause )? ( static_returning_clause )? ( error_logging_clause )? )
        // PLSQL_DMLParser.g:420:10: delete_key ( from_key )? general_table_ref ( where_clause )? ( static_returning_clause )? ( error_logging_clause )?
        {
            this->followPush(FOLLOW_delete_key_in_delete_statement3588);
            m_gPLSQLParser->delete_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledelete_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:420:21: ( from_key )?
            {
                int alt137=2;
                {
                    int LA137_0 = this->LA(1);
                    if ( (LA137_0 == SQL92_RESERVED_FROM))
                    {
                        alt137=1;
                    }
                }
                switch (alt137)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:420:21: from_key
            	    {
            	        this->followPush(FOLLOW_from_key_in_delete_statement3590);
            	        m_gPLSQLParser->from_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledelete_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_general_table_ref_in_delete_statement3601);
            general_table_ref();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledelete_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:422:9: ( where_clause )?
            {
                int alt138=2;
                {
                    int LA138_0 = this->LA(1);
                    if ( (LA138_0 == SQL92_RESERVED_WHERE))
                    {
                        alt138=1;
                    }
                }
                switch (alt138)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:422:9: where_clause
            	    {
            	        this->followPush(FOLLOW_where_clause_in_delete_statement3611);
            	        m_gPLSQLParser->where_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledelete_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:422:23: ( static_returning_clause )?
            {
                int alt139=2;
                {
                    int LA139_0 = this->LA(1);
                    if ( (LA139_0 == REGULAR_ID))
                    {
                        {
                            int LA139_1 = this->LA(2);
                            if ( ((((equalsIgnoreCase(LT(1)->getText(), "RETURNING")))||((equalsIgnoreCase(LT(1)->getText(), "RETURN"))))))
                            {
                                alt139=1;
                            }
                        }
                    }
                }
                switch (alt139)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:422:23: static_returning_clause
            	    {
            	        this->followPush(FOLLOW_static_returning_clause_in_delete_statement3614);
            	        static_returning_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledelete_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:422:48: ( error_logging_clause )?
            {
                int alt140=2;
                {
                    int LA140_0 = this->LA(1);
                    if ( (LA140_0 == REGULAR_ID))
                    {
                        {
                            int LA140_1 = this->LA(2);
                            if ( (LA140_1 == REGULAR_ID))
                            {
                                {
                                    int LA140_3 = this->LA(3);
                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "LOG"))))
                                    {
                                        alt140=1;
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt140)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:422:48: error_logging_clause
            	    {
            	        this->followPush(FOLLOW_error_logging_clause_in_delete_statement3617);
            	        error_logging_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledelete_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruledelete_statementEx; /* Prevent compiler warnings */
    ruledelete_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end delete_statement */

/**
 * $ANTLR start insert_statement
 * PLSQL_DMLParser.g:425:1: insert_statement : insert_key ( single_table_insert | multi_table_insert ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::insert_statement()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:426:5: ( insert_key ( single_table_insert | multi_table_insert ) )
        // PLSQL_DMLParser.g:426:10: insert_key ( single_table_insert | multi_table_insert )
        {
            this->followPush(FOLLOW_insert_key_in_insert_statement3638);
            m_gPLSQLParser->insert_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleinsert_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:427:5: ( single_table_insert | multi_table_insert )
            {
                int alt141=2;
                {
                    int LA141_0 = this->LA(1);
                    if ( (LA141_0 == SQL92_RESERVED_INTO))
                    {
                        alt141=1;
                    }
                    else if ( (LA141_0 == SQL92_RESERVED_ALL))
                    {
                        alt141=2;
                    }
                    else if ( (LA141_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "FIRST"))))
                    {
                        alt141=2;
                    }
                    else if ( (LA141_0 == SQL92_RESERVED_WHEN))
                    {
                        alt141=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 141 );
                        ex->set_state( 0 );


                        goto ruleinsert_statementEx;

                    }
                }
                switch (alt141)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:427:10: single_table_insert
            	    {
            	        this->followPush(FOLLOW_single_table_insert_in_insert_statement3649);
            	        single_table_insert();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleinsert_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:428:10: multi_table_insert
            	    {
            	        this->followPush(FOLLOW_multi_table_insert_in_insert_statement3660);
            	        multi_table_insert();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleinsert_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinsert_statementEx; /* Prevent compiler warnings */
    ruleinsert_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end insert_statement */

/**
 * $ANTLR start single_table_insert
 * PLSQL_DMLParser.g:434:1: single_table_insert : insert_into_clause ( values_clause ( static_returning_clause )? | select_statement ) ( error_logging_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::single_table_insert()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:435:5: ( insert_into_clause ( values_clause ( static_returning_clause )? | select_statement ) ( error_logging_clause )? )
        // PLSQL_DMLParser.g:435:10: insert_into_clause ( values_clause ( static_returning_clause )? | select_statement ) ( error_logging_clause )?
        {
            this->followPush(FOLLOW_insert_into_clause_in_single_table_insert3688);
            insert_into_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesingle_table_insertEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:436:5: ( values_clause ( static_returning_clause )? | select_statement )
            {
                int alt143=2;
                {
                    int LA143_0 = this->LA(1);
                    if ( (LA143_0 == SQL92_RESERVED_VALUES))
                    {
                        alt143=1;
                    }
                    else if ( (LA143_0 == LEFT_PAREN || LA143_0 == SQL92_RESERVED_SELECT || LA143_0 == SQL92_RESERVED_WITH))
                    {
                        alt143=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 143 );
                        ex->set_state( 0 );


                        goto rulesingle_table_insertEx;

                    }
                }
                switch (alt143)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:436:10: values_clause ( static_returning_clause )?
            	    {
            	        this->followPush(FOLLOW_values_clause_in_single_table_insert3699);
            	        values_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_table_insertEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:436:24: ( static_returning_clause )?
            	        {
            	            int alt142=2;
            	            {
            	                int LA142_0 = this->LA(1);
            	                if ( (LA142_0 == REGULAR_ID))
            	                {
            	                    {
            	                        int LA142_1 = this->LA(2);
            	                        if ( ((((equalsIgnoreCase(LT(1)->getText(), "RETURNING")))||((equalsIgnoreCase(LT(1)->getText(), "RETURN"))))))
            	                        {
            	                            alt142=1;
            	                        }
            	                    }
            	                }
            	            }
            	            switch (alt142)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:436:24: static_returning_clause
            	        	    {
            	        	        this->followPush(FOLLOW_static_returning_clause_in_single_table_insert3701);
            	        	        static_returning_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesingle_table_insertEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:437:10: select_statement
            	    {
            	        this->followPush(FOLLOW_select_statement_in_single_table_insert3713);
            	        select_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_table_insertEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:439:9: ( error_logging_clause )?
            {
                int alt144=2;
                {
                    int LA144_0 = this->LA(1);
                    if ( (LA144_0 == REGULAR_ID))
                    {
                        {
                            int LA144_1 = this->LA(2);
                            if ( (LA144_1 == REGULAR_ID))
                            {
                                {
                                    int LA144_3 = this->LA(3);
                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "LOG"))))
                                    {
                                        alt144=1;
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt144)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:439:9: error_logging_clause
            	    {
            	        this->followPush(FOLLOW_error_logging_clause_in_single_table_insert3729);
            	        error_logging_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_table_insertEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesingle_table_insertEx; /* Prevent compiler warnings */
    rulesingle_table_insertEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end single_table_insert */

/**
 * $ANTLR start multi_table_insert
 * PLSQL_DMLParser.g:442:1: multi_table_insert : ( all_key ( multi_table_element )+ | conditional_insert_clause ) select_statement ;
 */
void
PLSQLParser_PLSQL_DMLParser::multi_table_insert()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:443:5: ( ( all_key ( multi_table_element )+ | conditional_insert_clause ) select_statement )
        // PLSQL_DMLParser.g:444:5: ( all_key ( multi_table_element )+ | conditional_insert_clause ) select_statement
        {
            // PLSQL_DMLParser.g:444:5: ( all_key ( multi_table_element )+ | conditional_insert_clause )
            {
                int alt146=2;
                {
                    int LA146_0 = this->LA(1);
                    if ( (LA146_0 == SQL92_RESERVED_ALL))
                    {
                        {
                            int LA146_1 = this->LA(2);
                            if ( (LA146_1 == SQL92_RESERVED_INTO))
                            {
                                alt146=1;
                            }
                            else if ( (LA146_1 == SQL92_RESERVED_WHEN))
                            {
                                alt146=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 146 );
                                ex->set_state( 1 );


                                goto rulemulti_table_insertEx;

                            }
                        }
                    }
                    else if ( (LA146_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "FIRST"))))
                    {
                        alt146=2;
                    }
                    else if ( (LA146_0 == SQL92_RESERVED_WHEN))
                    {
                        alt146=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 146 );
                        ex->set_state( 0 );


                        goto rulemulti_table_insertEx;

                    }
                }
                switch (alt146)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:444:10: all_key ( multi_table_element )+
            	    {
            	        this->followPush(FOLLOW_all_key_in_multi_table_insert3760);
            	        m_gPLSQLParser->all_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_table_insertEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:444:18: ( multi_table_element )+
            	        {
            	            int cnt145=0;

            	            for (;;)
            	            {
            	                int alt145=2;
            	        	{
            	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	        	    */
            	        	    int LA145_0 = this->LA(1);
            	        	    if ( (LA145_0 == SQL92_RESERVED_INTO))
            	        	    {
            	        	        alt145=1;
            	        	    }

            	        	}
            	        	switch (alt145)
            	        	{
            	        	    case 1:
            	        	        // PLSQL_DMLParser.g:444:18: multi_table_element
            	        	        {
            	        	            this->followPush(FOLLOW_multi_table_element_in_multi_table_insert3762);
            	        	            multi_table_element();

            	        	            this->followPop();
            	        	            if  (this->hasException())
            	        	            {
            	        	                goto rulemulti_table_insertEx;
            	        	            }
            	        	            if (this->hasFailed())
            	        	            {
            	        	                return ;
            	        	            }


            	        	        }
            	        	        break;

            	        	    default:

            	        		if ( cnt145 >= 1 )
            	        		{
            	        		    goto loop145;
            	        		}
            	        		if (this->get_backtracking()>0)
            	        		{
            	        		    this->set_failedflag( true );
            	        		    return ;
            	        		}

            	        		/* mismatchedSetEx()
            	        		 */
            	        		new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            	        		goto rulemulti_table_insertEx;
            	        	}
            	        	cnt145++;
            	            }
            	            loop145: ;	/* Jump to here if this rule does not match */
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:445:10: conditional_insert_clause
            	    {
            	        this->followPush(FOLLOW_conditional_insert_clause_in_multi_table_insert3774);
            	        conditional_insert_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_table_insertEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_select_statement_in_multi_table_insert3790);
            select_statement();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemulti_table_insertEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemulti_table_insertEx; /* Prevent compiler warnings */
    rulemulti_table_insertEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multi_table_insert */

/**
 * $ANTLR start multi_table_element
 * PLSQL_DMLParser.g:450:1: multi_table_element : insert_into_clause ( values_clause )? ( error_logging_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::multi_table_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:451:5: ( insert_into_clause ( values_clause )? ( error_logging_clause )? )
        // PLSQL_DMLParser.g:451:10: insert_into_clause ( values_clause )? ( error_logging_clause )?
        {
            this->followPush(FOLLOW_insert_into_clause_in_multi_table_element3810);
            insert_into_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemulti_table_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:451:29: ( values_clause )?
            {
                int alt147=2;
                {
                    int LA147_0 = this->LA(1);
                    if ( (LA147_0 == SQL92_RESERVED_VALUES))
                    {
                        alt147=1;
                    }
                }
                switch (alt147)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:451:29: values_clause
            	    {
            	        this->followPush(FOLLOW_values_clause_in_multi_table_element3812);
            	        values_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_table_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:451:44: ( error_logging_clause )?
            {
                int alt148=2;
                {
                    int LA148_0 = this->LA(1);
                    if ( (LA148_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "LOG"))))
                    {
                        alt148=1;
                    }
                }
                switch (alt148)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:451:44: error_logging_clause
            	    {
            	        this->followPush(FOLLOW_error_logging_clause_in_multi_table_element3815);
            	        error_logging_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_table_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemulti_table_elementEx; /* Prevent compiler warnings */
    rulemulti_table_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multi_table_element */

/**
 * $ANTLR start conditional_insert_clause
 * PLSQL_DMLParser.g:454:1: conditional_insert_clause : ( all_key | first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::conditional_insert_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:455:5: ( ( all_key | first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )? )
        // PLSQL_DMLParser.g:455:10: ( all_key | first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )?
        {
            // PLSQL_DMLParser.g:455:10: ( all_key | first_key )?
            {
                int alt149=3;
                {
                    int LA149_0 = this->LA(1);
                    if ( (LA149_0 == SQL92_RESERVED_ALL))
                    {
                        alt149=1;
                    }
                    else if ( (LA149_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "FIRST"))))
                    {
                        alt149=2;
                    }
                }
                switch (alt149)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:455:11: all_key
            	    {
            	        this->followPush(FOLLOW_all_key_in_conditional_insert_clause3837);
            	        m_gPLSQLParser->all_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconditional_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:455:19: first_key
            	    {
            	        this->followPush(FOLLOW_first_key_in_conditional_insert_clause3839);
            	        m_gPLSQLParser->first_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconditional_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:456:9: ( conditional_insert_when_part )+
            {
                int cnt150=0;

                for (;;)
                {
                    int alt150=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA150_0 = this->LA(1);
            	    if ( (LA150_0 == SQL92_RESERVED_WHEN))
            	    {
            	        alt150=1;
            	    }

            	}
            	switch (alt150)
            	{
            	    case 1:
            	        // PLSQL_DMLParser.g:456:9: conditional_insert_when_part
            	        {
            	            this->followPush(FOLLOW_conditional_insert_when_part_in_conditional_insert_clause3851);
            	            conditional_insert_when_part();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleconditional_insert_clauseEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt150 >= 1 )
            		{
            		    goto loop150;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleconditional_insert_clauseEx;
            	}
            	cnt150++;
                }
                loop150: ;	/* Jump to here if this rule does not match */
            }

            // PLSQL_DMLParser.g:456:39: ( conditional_insert_else_part )?
            {
                int alt151=2;
                {
                    int LA151_0 = this->LA(1);
                    if ( (LA151_0 == SQL92_RESERVED_ELSE))
                    {
                        alt151=1;
                    }
                }
                switch (alt151)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:456:39: conditional_insert_else_part
            	    {
            	        this->followPush(FOLLOW_conditional_insert_else_part_in_conditional_insert_clause3854);
            	        conditional_insert_else_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconditional_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconditional_insert_clauseEx; /* Prevent compiler warnings */
    ruleconditional_insert_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end conditional_insert_clause */

/**
 * $ANTLR start conditional_insert_when_part
 * PLSQL_DMLParser.g:459:1: conditional_insert_when_part : when_key condition then_key ( multi_table_element )+ ;
 */
void
PLSQLParser_PLSQL_DMLParser::conditional_insert_when_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:460:5: ( when_key condition then_key ( multi_table_element )+ )
        // PLSQL_DMLParser.g:460:10: when_key condition then_key ( multi_table_element )+
        {
            this->followPush(FOLLOW_when_key_in_conditional_insert_when_part3875);
            m_gPLSQLParser->when_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconditional_insert_when_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_condition_in_conditional_insert_when_part3877);
            condition();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconditional_insert_when_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_then_key_in_conditional_insert_when_part3879);
            m_gPLSQLParser->then_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconditional_insert_when_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:460:38: ( multi_table_element )+
            {
                int cnt152=0;

                for (;;)
                {
                    int alt152=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA152_0 = this->LA(1);
            	    if ( (LA152_0 == SQL92_RESERVED_INTO))
            	    {
            	        alt152=1;
            	    }

            	}
            	switch (alt152)
            	{
            	    case 1:
            	        // PLSQL_DMLParser.g:460:38: multi_table_element
            	        {
            	            this->followPush(FOLLOW_multi_table_element_in_conditional_insert_when_part3881);
            	            multi_table_element();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleconditional_insert_when_partEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt152 >= 1 )
            		{
            		    goto loop152;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleconditional_insert_when_partEx;
            	}
            	cnt152++;
                }
                loop152: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconditional_insert_when_partEx; /* Prevent compiler warnings */
    ruleconditional_insert_when_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end conditional_insert_when_part */

/**
 * $ANTLR start conditional_insert_else_part
 * PLSQL_DMLParser.g:463:1: conditional_insert_else_part : else_key ( multi_table_element )+ ;
 */
void
PLSQLParser_PLSQL_DMLParser::conditional_insert_else_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:464:5: ( else_key ( multi_table_element )+ )
        // PLSQL_DMLParser.g:464:10: else_key ( multi_table_element )+
        {
            this->followPush(FOLLOW_else_key_in_conditional_insert_else_part3902);
            m_gPLSQLParser->else_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconditional_insert_else_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:464:19: ( multi_table_element )+
            {
                int cnt153=0;

                for (;;)
                {
                    int alt153=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA153_0 = this->LA(1);
            	    if ( (LA153_0 == SQL92_RESERVED_INTO))
            	    {
            	        alt153=1;
            	    }

            	}
            	switch (alt153)
            	{
            	    case 1:
            	        // PLSQL_DMLParser.g:464:19: multi_table_element
            	        {
            	            this->followPush(FOLLOW_multi_table_element_in_conditional_insert_else_part3904);
            	            multi_table_element();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleconditional_insert_else_partEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt153 >= 1 )
            		{
            		    goto loop153;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleconditional_insert_else_partEx;
            	}
            	cnt153++;
                }
                loop153: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconditional_insert_else_partEx; /* Prevent compiler warnings */
    ruleconditional_insert_else_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end conditional_insert_else_part */

/**
 * $ANTLR start insert_into_clause
 * PLSQL_DMLParser.g:467:1: insert_into_clause : into_key general_table_ref ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::insert_into_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:468:5: ( into_key general_table_ref ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? )
        // PLSQL_DMLParser.g:468:10: into_key general_table_ref ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )?
        {
            this->followPush(FOLLOW_into_key_in_insert_into_clause3925);
            m_gPLSQLParser->into_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleinsert_into_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_general_table_ref_in_insert_into_clause3927);
            general_table_ref();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleinsert_into_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:469:9: ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )?
            {
                int alt155=2;
                {
                    int LA155_0 = this->LA(1);
                    if ( (LA155_0 == LEFT_PAREN))
                    {
                        {
                            int LA155_1 = this->LA(2);
                            if ( (LA155_1 == DELIMITED_ID || LA155_1 == INTRODUCER || LA155_1 == REGULAR_ID))
                            {
                                alt155=1;
                            }
                        }
                    }
                }
                switch (alt155)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:469:10: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_insert_into_clause3939);
            	        if  (this->hasException())
            	        {
            	            goto ruleinsert_into_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_insert_into_clause3941);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleinsert_into_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:469:33: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            int alt154=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA154_0 = this->LA(1);
            	                if ( (LA154_0 == COMMA))
            	                {
            	                    alt154=1;
            	                }

            	            }
            	            switch (alt154)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:469:34: COMMA column_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_insert_into_clause3944);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleinsert_into_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_column_name_in_insert_into_clause3946);
            	        	        m_gPLSQLParser->column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleinsert_into_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop154;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop154: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_insert_into_clause3950);
            	        if  (this->hasException())
            	        {
            	            goto ruleinsert_into_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinsert_into_clauseEx; /* Prevent compiler warnings */
    ruleinsert_into_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end insert_into_clause */

/**
 * $ANTLR start values_clause
 * PLSQL_DMLParser.g:472:1: values_clause : values_key expression_list ;
 */
void
PLSQLParser_PLSQL_DMLParser::values_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:473:5: ( values_key expression_list )
        // PLSQL_DMLParser.g:473:10: values_key expression_list
        {
            this->followPush(FOLLOW_values_key_in_values_clause3972);
            m_gPLSQLParser->values_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulevalues_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_list_in_values_clause3974);
            expression_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulevalues_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevalues_clauseEx; /* Prevent compiler warnings */
    rulevalues_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end values_clause */

/**
 * $ANTLR start merge_statement
 * PLSQL_DMLParser.g:477:1: merge_statement : merge_key into_key tableview_name ( table_alias )? using_key selected_tableview on_key LEFT_PAREN condition RIGHT_PAREN ( ( when_key matched_key )=> merge_update_clause ( merge_insert_clause )? | ( when_key not_key matched_key )=> merge_insert_clause ( merge_update_clause )? )? ( error_logging_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::merge_statement()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:478:5: ( merge_key into_key tableview_name ( table_alias )? using_key selected_tableview on_key LEFT_PAREN condition RIGHT_PAREN ( ( when_key matched_key )=> merge_update_clause ( merge_insert_clause )? | ( when_key not_key matched_key )=> merge_insert_clause ( merge_update_clause )? )? ( error_logging_clause )? )
        // PLSQL_DMLParser.g:478:10: merge_key into_key tableview_name ( table_alias )? using_key selected_tableview on_key LEFT_PAREN condition RIGHT_PAREN ( ( when_key matched_key )=> merge_update_clause ( merge_insert_clause )? | ( when_key not_key matched_key )=> merge_insert_clause ( merge_update_clause )? )? ( error_logging_clause )?
        {
            this->followPush(FOLLOW_merge_key_in_merge_statement3995);
            m_gPLSQLParser->merge_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_into_key_in_merge_statement3997);
            m_gPLSQLParser->into_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_tableview_name_in_merge_statement3999);
            m_gPLSQLParser->tableview_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:478:44: ( table_alias )?
            {
                int alt156=2;
                {
                    int LA156_0 = this->LA(1);
                    if ( (((LA156_0 >= CHAR_STRING) && (LA156_0 <= CHAR_STRING_PERL)) || LA156_0 == DELIMITED_ID || LA156_0 == INTRODUCER || LA156_0 == NATIONAL_CHAR_STRING_LIT || LA156_0 == REGULAR_ID))
                    {
                        alt156=1;
                    }
                }
                switch (alt156)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:478:44: table_alias
            	    {
            	        this->followPush(FOLLOW_table_alias_in_merge_statement4001);
            	        m_gPLSQLParser->table_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_using_key_in_merge_statement4012);
            m_gPLSQLParser->using_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_selected_tableview_in_merge_statement4014);
            selected_tableview();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_on_key_in_merge_statement4016);
            m_gPLSQLParser->on_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_merge_statement4018);
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_condition_in_merge_statement4020);
            condition();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_merge_statement4022);
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:480:9: ( ( when_key matched_key )=> merge_update_clause ( merge_insert_clause )? | ( when_key not_key matched_key )=> merge_insert_clause ( merge_update_clause )? )?
            {
                int alt159=3;
                {
                    int LA159_0 = this->LA(1);
                    if ( (LA159_0 == SQL92_RESERVED_WHEN))
                    {
                        {
                            int LA159_1 = this->LA(2);
                            if ( (LA159_1 == REGULAR_ID) && (this->msynpred( antlr3::ClassForwarder<synpred20_PLSQL_DMLParser>() )))
                            {
                                alt159=1;
                            }
                            else if ( (LA159_1 == SQL92_RESERVED_NOT) && (this->msynpred( antlr3::ClassForwarder<synpred21_PLSQL_DMLParser>() )))
                            {
                                alt159=2;
                            }
                        }
                    }
                }
                switch (alt159)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:481:13: ( when_key matched_key )=> merge_update_clause ( merge_insert_clause )?
            	    {
            	        this->followPush(FOLLOW_merge_update_clause_in_merge_statement4054);
            	        merge_update_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:481:59: ( merge_insert_clause )?
            	        {
            	            int alt157=2;
            	            {
            	                int LA157_0 = this->LA(1);
            	                if ( (LA157_0 == SQL92_RESERVED_WHEN))
            	                {
            	                    alt157=1;
            	                }
            	            }
            	            switch (alt157)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:481:59: merge_insert_clause
            	        	    {
            	        	        this->followPush(FOLLOW_merge_insert_clause_in_merge_statement4056);
            	        	        merge_insert_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemerge_statementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:483:13: ( when_key not_key matched_key )=> merge_insert_clause ( merge_update_clause )?
            	    {
            	        this->followPush(FOLLOW_merge_insert_clause_in_merge_statement4091);
            	        merge_insert_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:483:67: ( merge_update_clause )?
            	        {
            	            int alt158=2;
            	            {
            	                int LA158_0 = this->LA(1);
            	                if ( (LA158_0 == SQL92_RESERVED_WHEN))
            	                {
            	                    alt158=1;
            	                }
            	            }
            	            switch (alt158)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:483:67: merge_update_clause
            	        	    {
            	        	        this->followPush(FOLLOW_merge_update_clause_in_merge_statement4093);
            	        	        merge_update_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemerge_statementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:485:9: ( error_logging_clause )?
            {
                int alt160=2;
                {
                    int LA160_0 = this->LA(1);
                    if ( (LA160_0 == REGULAR_ID))
                    {
                        {
                            int LA160_1 = this->LA(2);
                            if ( (LA160_1 == REGULAR_ID))
                            {
                                {
                                    int LA160_3 = this->LA(3);
                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "LOG"))))
                                    {
                                        alt160=1;
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt160)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:485:9: error_logging_clause
            	    {
            	        this->followPush(FOLLOW_error_logging_clause_in_merge_statement4115);
            	        error_logging_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemerge_statementEx; /* Prevent compiler warnings */
    rulemerge_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end merge_statement */

/**
 * $ANTLR start merge_update_clause
 * PLSQL_DMLParser.g:490:1: merge_update_clause : when_key matched_key then_key update_key set_key merge_element ( COMMA merge_element )* ( where_clause )? ( merge_update_delete_part )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::merge_update_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:491:5: ( when_key matched_key then_key update_key set_key merge_element ( COMMA merge_element )* ( where_clause )? ( merge_update_delete_part )? )
        // PLSQL_DMLParser.g:491:10: when_key matched_key then_key update_key set_key merge_element ( COMMA merge_element )* ( where_clause )? ( merge_update_delete_part )?
        {
            this->followPush(FOLLOW_when_key_in_merge_update_clause4138);
            m_gPLSQLParser->when_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_matched_key_in_merge_update_clause4140);
            m_gPLSQLParser->matched_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_then_key_in_merge_update_clause4142);
            m_gPLSQLParser->then_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_update_key_in_merge_update_clause4144);
            m_gPLSQLParser->update_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_set_key_in_merge_update_clause4146);
            m_gPLSQLParser->set_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_merge_element_in_merge_update_clause4157);
            merge_element();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:492:23: ( COMMA merge_element )*

            for (;;)
            {
                int alt161=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA161_0 = this->LA(1);
                    if ( (LA161_0 == COMMA))
                    {
                        alt161=1;
                    }

                }
                switch (alt161)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:492:24: COMMA merge_element
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_merge_update_clause4160);
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_update_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_merge_element_in_merge_update_clause4162);
            	        merge_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_update_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop161;	/* break out of the loop */
            	    break;
                }
            }
            loop161: ; /* Jump out to here if this rule does not match */


            // PLSQL_DMLParser.g:493:9: ( where_clause )?
            {
                int alt162=2;
                {
                    int LA162_0 = this->LA(1);
                    if ( (LA162_0 == SQL92_RESERVED_WHERE))
                    {
                        alt162=1;
                    }
                }
                switch (alt162)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:493:9: where_clause
            	    {
            	        this->followPush(FOLLOW_where_clause_in_merge_update_clause4174);
            	        m_gPLSQLParser->where_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_update_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:493:23: ( merge_update_delete_part )?
            {
                int alt163=2;
                {
                    int LA163_0 = this->LA(1);
                    if ( (LA163_0 == SQL92_RESERVED_DELETE))
                    {
                        {
                            int LA163_1 = this->LA(2);
                            if ( (LA163_1 == SQL92_RESERVED_WHERE))
                            {
                                alt163=1;
                            }
                        }
                    }
                }
                switch (alt163)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:493:23: merge_update_delete_part
            	    {
            	        this->followPush(FOLLOW_merge_update_delete_part_in_merge_update_clause4177);
            	        merge_update_delete_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_update_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemerge_update_clauseEx; /* Prevent compiler warnings */
    rulemerge_update_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end merge_update_clause */

/**
 * $ANTLR start merge_element
 * PLSQL_DMLParser.g:496:1: merge_element : column_name EQUALS_OP expression ;
 */
void
PLSQLParser_PLSQL_DMLParser::merge_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:497:5: ( column_name EQUALS_OP expression )
        // PLSQL_DMLParser.g:497:10: column_name EQUALS_OP expression
        {
            this->followPush(FOLLOW_column_name_in_merge_element4198);
            m_gPLSQLParser->column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_merge_element4200);
            if  (this->hasException())
            {
                goto rulemerge_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_merge_element4202);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemerge_elementEx; /* Prevent compiler warnings */
    rulemerge_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end merge_element */

/**
 * $ANTLR start merge_update_delete_part
 * PLSQL_DMLParser.g:500:1: merge_update_delete_part : delete_key where_clause ;
 */
void
PLSQLParser_PLSQL_DMLParser::merge_update_delete_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:501:5: ( delete_key where_clause )
        // PLSQL_DMLParser.g:501:10: delete_key where_clause
        {
            this->followPush(FOLLOW_delete_key_in_merge_update_delete_part4222);
            m_gPLSQLParser->delete_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_delete_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_where_clause_in_merge_update_delete_part4224);
            m_gPLSQLParser->where_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_delete_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemerge_update_delete_partEx; /* Prevent compiler warnings */
    rulemerge_update_delete_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end merge_update_delete_part */

/**
 * $ANTLR start merge_insert_clause
 * PLSQL_DMLParser.g:504:1: merge_insert_clause : when_key not_key matched_key then_key insert_key ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? values_key expression_list ( where_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::merge_insert_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:505:5: ( when_key not_key matched_key then_key insert_key ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? values_key expression_list ( where_clause )? )
        // PLSQL_DMLParser.g:505:10: when_key not_key matched_key then_key insert_key ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? values_key expression_list ( where_clause )?
        {
            this->followPush(FOLLOW_when_key_in_merge_insert_clause4244);
            m_gPLSQLParser->when_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_not_key_in_merge_insert_clause4246);
            m_gPLSQLParser->not_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_matched_key_in_merge_insert_clause4248);
            m_gPLSQLParser->matched_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_then_key_in_merge_insert_clause4250);
            m_gPLSQLParser->then_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_insert_key_in_merge_insert_clause4252);
            m_gPLSQLParser->insert_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:506:9: ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )?
            {
                int alt165=2;
                {
                    int LA165_0 = this->LA(1);
                    if ( (LA165_0 == LEFT_PAREN))
                    {
                        alt165=1;
                    }
                }
                switch (alt165)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:506:10: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_merge_insert_clause4264);
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_merge_insert_clause4266);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:506:33: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            int alt164=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA164_0 = this->LA(1);
            	                if ( (LA164_0 == COMMA))
            	                {
            	                    alt164=1;
            	                }

            	            }
            	            switch (alt164)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:506:34: COMMA column_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_merge_insert_clause4269);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemerge_insert_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_column_name_in_merge_insert_clause4271);
            	        	        m_gPLSQLParser->column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemerge_insert_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop164;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop164: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_merge_insert_clause4275);
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_values_key_in_merge_insert_clause4287);
            m_gPLSQLParser->values_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_list_in_merge_insert_clause4289);
            expression_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:507:36: ( where_clause )?
            {
                int alt166=2;
                {
                    int LA166_0 = this->LA(1);
                    if ( (LA166_0 == SQL92_RESERVED_WHERE))
                    {
                        alt166=1;
                    }
                }
                switch (alt166)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:507:36: where_clause
            	    {
            	        this->followPush(FOLLOW_where_clause_in_merge_insert_clause4291);
            	        m_gPLSQLParser->where_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemerge_insert_clauseEx; /* Prevent compiler warnings */
    rulemerge_insert_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end merge_insert_clause */

/**
 * $ANTLR start selected_tableview
 * PLSQL_DMLParser.g:510:1: selected_tableview : ( tableview_name | LEFT_PAREN select_statement RIGHT_PAREN ) ( table_alias )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::selected_tableview()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:511:5: ( ( tableview_name | LEFT_PAREN select_statement RIGHT_PAREN ) ( table_alias )? )
        // PLSQL_DMLParser.g:511:10: ( tableview_name | LEFT_PAREN select_statement RIGHT_PAREN ) ( table_alias )?
        {
            // PLSQL_DMLParser.g:511:10: ( tableview_name | LEFT_PAREN select_statement RIGHT_PAREN )
            {
                int alt167=2;
                {
                    int LA167_0 = this->LA(1);
                    if ( (LA167_0 == DELIMITED_ID || LA167_0 == INTRODUCER || LA167_0 == REGULAR_ID))
                    {
                        alt167=1;
                    }
                    else if ( (LA167_0 == LEFT_PAREN))
                    {
                        alt167=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 167 );
                        ex->set_state( 0 );


                        goto ruleselected_tableviewEx;

                    }
                }
                switch (alt167)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:511:12: tableview_name
            	    {
            	        this->followPush(FOLLOW_tableview_name_in_selected_tableview4314);
            	        m_gPLSQLParser->tableview_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_tableviewEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:511:29: LEFT_PAREN select_statement RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_selected_tableview4318);
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_tableviewEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_select_statement_in_selected_tableview4320);
            	        select_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_tableviewEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_selected_tableview4322);
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_tableviewEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:511:71: ( table_alias )?
            {
                int alt168=2;
                {
                    int LA168_0 = this->LA(1);
                    if ( (((LA168_0 >= CHAR_STRING) && (LA168_0 <= CHAR_STRING_PERL)) || LA168_0 == DELIMITED_ID || LA168_0 == INTRODUCER || LA168_0 == NATIONAL_CHAR_STRING_LIT || LA168_0 == REGULAR_ID))
                    {
                        alt168=1;
                    }
                }
                switch (alt168)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:511:71: table_alias
            	    {
            	        this->followPush(FOLLOW_table_alias_in_selected_tableview4326);
            	        m_gPLSQLParser->table_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_tableviewEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleselected_tableviewEx; /* Prevent compiler warnings */
    ruleselected_tableviewEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end selected_tableview */

/**
 * $ANTLR start lock_table_statement
 * PLSQL_DMLParser.g:516:1: lock_table_statement : lock_key table_key lock_table_element ( COMMA lock_table_element )* in_key lock_mode mode_key ( wait_nowait_part )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::lock_table_statement()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:517:5: ( lock_key table_key lock_table_element ( COMMA lock_table_element )* in_key lock_mode mode_key ( wait_nowait_part )? )
        // PLSQL_DMLParser.g:517:10: lock_key table_key lock_table_element ( COMMA lock_table_element )* in_key lock_mode mode_key ( wait_nowait_part )?
        {
            this->followPush(FOLLOW_lock_key_in_lock_table_statement4349);
            m_gPLSQLParser->lock_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_table_key_in_lock_table_statement4351);
            m_gPLSQLParser->table_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_lock_table_element_in_lock_table_statement4362);
            lock_table_element();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:518:28: ( COMMA lock_table_element )*

            for (;;)
            {
                int alt169=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA169_0 = this->LA(1);
                    if ( (LA169_0 == COMMA))
                    {
                        alt169=1;
                    }

                }
                switch (alt169)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:518:29: COMMA lock_table_element
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_lock_table_statement4365);
            	        if  (this->hasException())
            	        {
            	            goto rulelock_table_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_lock_table_element_in_lock_table_statement4367);
            	        lock_table_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulelock_table_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop169;	/* break out of the loop */
            	    break;
                }
            }
            loop169: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_in_key_in_lock_table_statement4380);
            m_gPLSQLParser->in_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_lock_mode_in_lock_table_statement4382);
            lock_mode();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_mode_key_in_lock_table_statement4384);
            m_gPLSQLParser->mode_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:519:35: ( wait_nowait_part )?
            {
                int alt170=2;
                {
                    int LA170_0 = this->LA(1);
                    if ( (LA170_0 == REGULAR_ID))
                    {
                        {
                            int LA170_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "WAIT"))))
                            {
                                alt170=1;
                            }
                        }
                    }
                    else if ( (LA170_0 == PLSQL_RESERVED_NOWAIT))
                    {
                        alt170=1;
                    }
                }
                switch (alt170)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:519:35: wait_nowait_part
            	    {
            	        this->followPush(FOLLOW_wait_nowait_part_in_lock_table_statement4386);
            	        wait_nowait_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulelock_table_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulelock_table_statementEx; /* Prevent compiler warnings */
    rulelock_table_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end lock_table_statement */

/**
 * $ANTLR start wait_nowait_part
 * PLSQL_DMLParser.g:522:1: wait_nowait_part : ( wait_key expression | nowait_key );
 */
void
PLSQLParser_PLSQL_DMLParser::wait_nowait_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:523:5: ( wait_key expression | nowait_key )

            ANTLR_UINT32 alt171;

            alt171=2;

            {
                int LA171_0 = this->LA(1);
                if ( (LA171_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "WAIT"))))
                {
                    alt171=1;
                }
                else if ( (LA171_0 == PLSQL_RESERVED_NOWAIT))
                {
                    alt171=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 171 );
                    ex->set_state( 0 );


                    goto rulewait_nowait_partEx;

                }
            }
            switch (alt171)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:523:10: wait_key expression
        	    {
        	        this->followPush(FOLLOW_wait_key_in_wait_nowait_part4407);
        	        m_gPLSQLParser->wait_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewait_nowait_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_in_wait_nowait_part4409);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewait_nowait_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:524:10: nowait_key
        	    {
        	        this->followPush(FOLLOW_nowait_key_in_wait_nowait_part4420);
        	        m_gPLSQLParser->nowait_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewait_nowait_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulewait_nowait_partEx; /* Prevent compiler warnings */
    rulewait_nowait_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end wait_nowait_part */

/**
 * $ANTLR start lock_table_element
 * PLSQL_DMLParser.g:529:1: lock_table_element : tableview_name ( partition_extension_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::lock_table_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:530:5: ( tableview_name ( partition_extension_clause )? )
        // PLSQL_DMLParser.g:530:10: tableview_name ( partition_extension_clause )?
        {
            this->followPush(FOLLOW_tableview_name_in_lock_table_element4442);
            m_gPLSQLParser->tableview_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:530:25: ( partition_extension_clause )?
            {
                int alt172=2;
                {
                    int LA172_0 = this->LA(1);
                    if ( (LA172_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "PARTITION")))||((equalsIgnoreCase(LT(1)->getText(), "SUBPARTITION"))))))
                    {
                        alt172=1;
                    }
                }
                switch (alt172)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:530:25: partition_extension_clause
            	    {
            	        this->followPush(FOLLOW_partition_extension_clause_in_lock_table_element4444);
            	        m_gPLSQLParser->partition_extension_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulelock_table_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulelock_table_elementEx; /* Prevent compiler warnings */
    rulelock_table_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end lock_table_element */

/**
 * $ANTLR start lock_mode
 * PLSQL_DMLParser.g:533:1: lock_mode : ( row_key share_key | row_key exclusive_key | share_key ( update_key )? | share_key row_key exclusive_key | exclusive_key );
 */
void
PLSQLParser_PLSQL_DMLParser::lock_mode()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:534:5: ( row_key share_key | row_key exclusive_key | share_key ( update_key )? | share_key row_key exclusive_key | exclusive_key )

            ANTLR_UINT32 alt174;

            alt174=5;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    int LA174_1 = this->LA(2);
            		    if ( (LA174_1 == PLSQL_RESERVED_SHARE))
            		    {
            		        alt174=1;
            		    }
            		    else if ( (LA174_1 == PLSQL_RESERVED_EXCLUSIVE))
            		    {
            		        alt174=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 174 );
            		        ex->set_state( 1 );


            		        goto rulelock_modeEx;

            		    }
            		}
            	}
                break;
            case PLSQL_RESERVED_SHARE:
            	{
            		{
            		    int LA174_2 = this->LA(2);
            		    if ( (LA174_2 == PLSQL_RESERVED_MODE || LA174_2 == SQL92_RESERVED_UPDATE))
            		    {
            		        alt174=3;
            		    }
            		    else if ( (LA174_2 == REGULAR_ID))
            		    {
            		        alt174=4;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 174 );
            		        ex->set_state( 2 );


            		        goto rulelock_modeEx;

            		    }
            		}
            	}
                break;
            case PLSQL_RESERVED_EXCLUSIVE:
            	{
            		alt174=5;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 174 );
                ex->set_state( 0 );


                goto rulelock_modeEx;

            }

            switch (alt174)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:534:10: row_key share_key
        	    {
        	        this->followPush(FOLLOW_row_key_in_lock_mode4465);
        	        m_gPLSQLParser->row_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_share_key_in_lock_mode4467);
        	        m_gPLSQLParser->share_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:535:10: row_key exclusive_key
        	    {
        	        this->followPush(FOLLOW_row_key_in_lock_mode4478);
        	        m_gPLSQLParser->row_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_exclusive_key_in_lock_mode4480);
        	        m_gPLSQLParser->exclusive_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:536:10: share_key ( update_key )?
        	    {
        	        this->followPush(FOLLOW_share_key_in_lock_mode4491);
        	        m_gPLSQLParser->share_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:536:20: ( update_key )?
        	        {
        	            int alt173=2;
        	            {
        	                int LA173_0 = this->LA(1);
        	                if ( (LA173_0 == SQL92_RESERVED_UPDATE))
        	                {
        	                    alt173=1;
        	                }
        	            }
        	            switch (alt173)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:536:20: update_key
        	        	    {
        	        	        this->followPush(FOLLOW_update_key_in_lock_mode4493);
        	        	        m_gPLSQLParser->update_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulelock_modeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 4:
        	    // PLSQL_DMLParser.g:537:10: share_key row_key exclusive_key
        	    {
        	        this->followPush(FOLLOW_share_key_in_lock_mode4505);
        	        m_gPLSQLParser->share_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_row_key_in_lock_mode4507);
        	        m_gPLSQLParser->row_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_exclusive_key_in_lock_mode4509);
        	        m_gPLSQLParser->exclusive_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQL_DMLParser.g:538:10: exclusive_key
        	    {
        	        this->followPush(FOLLOW_exclusive_key_in_lock_mode4520);
        	        m_gPLSQLParser->exclusive_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulelock_modeEx; /* Prevent compiler warnings */
    rulelock_modeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end lock_mode */

/**
 * $ANTLR start general_table_ref
 * PLSQL_DMLParser.g:544:1: general_table_ref : ( dml_table_expression_clause | only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN ) ( table_alias )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::general_table_ref()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:545:5: ( ( dml_table_expression_clause | only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN ) ( table_alias )? )
        // PLSQL_DMLParser.g:545:10: ( dml_table_expression_clause | only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN ) ( table_alias )?
        {
            // PLSQL_DMLParser.g:545:10: ( dml_table_expression_clause | only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN )
            {
                int alt175=2;
                {
                    int LA175_0 = this->LA(1);
                    if ( (LA175_0 == DELIMITED_ID || LA175_0 == INTRODUCER || LA175_0 == LEFT_PAREN || ((LA175_0 >= SQL92_RESERVED_TABLE) && (LA175_0 <= SQL92_RESERVED_THE))))
                    {
                        alt175=1;
                    }
                    else if ( (LA175_0 == REGULAR_ID))
                    {
                        {
                            int LA175_5 = this->LA(2);
                            if ( (!( ((equalsIgnoreCase(LT(1)->getText(), "ONLY"))) )))
                            {
                                alt175=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "ONLY"))))
                            {
                                alt175=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 175 );
                                ex->set_state( 5 );


                                goto rulegeneral_table_refEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 175 );
                        ex->set_state( 0 );


                        goto rulegeneral_table_refEx;

                    }
                }
                switch (alt175)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:545:15: dml_table_expression_clause
            	    {
            	        this->followPush(FOLLOW_dml_table_expression_clause_in_general_table_ref4548);
            	        dml_table_expression_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_table_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:546:14: only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN
            	    {
            	        this->followPush(FOLLOW_only_key_in_general_table_ref4563);
            	        m_gPLSQLParser->only_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_table_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_general_table_ref4565);
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_table_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_dml_table_expression_clause_in_general_table_ref4567);
            	        dml_table_expression_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_table_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_general_table_ref4569);
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_table_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:547:14: ( table_alias )?
            {
                int alt176=2;
                {
                    int LA176_0 = this->LA(1);
                    if ( (((LA176_0 >= CHAR_STRING) && (LA176_0 <= CHAR_STRING_PERL)) || LA176_0 == DELIMITED_ID || LA176_0 == INTRODUCER || LA176_0 == NATIONAL_CHAR_STRING_LIT))
                    {
                        alt176=1;
                    }
                    else if ( (LA176_0 == REGULAR_ID))
                    {
                        {
                            int LA176_2 = this->LA(2);
                            if ( (!( ((((equalsIgnoreCase(LT(1)->getText(), "RETURNING")))||((equalsIgnoreCase(LT(1)->getText(), "EXPLAIN")))||((equalsIgnoreCase(LT(1)->getText(), "MERGE")))||((equalsIgnoreCase(LT(1)->getText(), "RETURN")))||((equalsIgnoreCase(LT(1)->getText(), "LOG")))||((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "EXIT")))||((equalsIgnoreCase(LT(1)->getText(), "FUNCTION")))||((equalsIgnoreCase(LT(1)->getText(), "SAVE")))||((equalsIgnoreCase(LT(1)->getText(), "WHENEVER"))))) )))
                            {
                                alt176=1;
                            }
                        }
                    }
                }
                switch (alt176)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:547:14: table_alias
            	    {
            	        this->followPush(FOLLOW_table_alias_in_general_table_ref4584);
            	        m_gPLSQLParser->table_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_table_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulegeneral_table_refEx; /* Prevent compiler warnings */
    rulegeneral_table_refEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end general_table_ref */

/**
 * $ANTLR start static_returning_clause
 * PLSQL_DMLParser.g:550:1: static_returning_clause : ( returning_key | return_key ) expression ( COMMA expression )* into_clause ;
 */
void
PLSQLParser_PLSQL_DMLParser::static_returning_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:551:5: ( ( returning_key | return_key ) expression ( COMMA expression )* into_clause )
        // PLSQL_DMLParser.g:551:10: ( returning_key | return_key ) expression ( COMMA expression )* into_clause
        {
            // PLSQL_DMLParser.g:551:10: ( returning_key | return_key )
            {
                int alt177=2;
                {
                    int LA177_0 = this->LA(1);
                    if ( (LA177_0 == REGULAR_ID))
                    {
                        {
                            int LA177_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "RETURNING"))))
                            {
                                alt177=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "RETURN"))))
                            {
                                alt177=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 177 );
                                ex->set_state( 1 );


                                goto rulestatic_returning_clauseEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 177 );
                        ex->set_state( 0 );


                        goto rulestatic_returning_clauseEx;

                    }
                }
                switch (alt177)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:551:11: returning_key
            	    {
            	        this->followPush(FOLLOW_returning_key_in_static_returning_clause4606);
            	        m_gPLSQLParser->returning_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulestatic_returning_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:551:25: return_key
            	    {
            	        this->followPush(FOLLOW_return_key_in_static_returning_clause4608);
            	        m_gPLSQLParser->return_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulestatic_returning_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_expression_in_static_returning_clause4611);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestatic_returning_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:551:48: ( COMMA expression )*

            for (;;)
            {
                int alt178=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA178_0 = this->LA(1);
                    if ( (LA178_0 == COMMA))
                    {
                        alt178=1;
                    }

                }
                switch (alt178)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:551:49: COMMA expression
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_static_returning_clause4614);
            	        if  (this->hasException())
            	        {
            	            goto rulestatic_returning_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_static_returning_clause4616);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulestatic_returning_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop178;	/* break out of the loop */
            	    break;
                }
            }
            loop178: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_into_clause_in_static_returning_clause4629);
            m_gPLSQLParser->into_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestatic_returning_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestatic_returning_clauseEx; /* Prevent compiler warnings */
    rulestatic_returning_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end static_returning_clause */

/**
 * $ANTLR start error_logging_clause
 * PLSQL_DMLParser.g:555:1: error_logging_clause : log_key errors_key ( error_logging_into_part )? ( ( LEFT_PAREN )=> expression_wrapper )? ( error_logging_reject_part )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::error_logging_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:556:5: ( log_key errors_key ( error_logging_into_part )? ( ( LEFT_PAREN )=> expression_wrapper )? ( error_logging_reject_part )? )
        // PLSQL_DMLParser.g:556:10: log_key errors_key ( error_logging_into_part )? ( ( LEFT_PAREN )=> expression_wrapper )? ( error_logging_reject_part )?
        {
            this->followPush(FOLLOW_log_key_in_error_logging_clause4649);
            m_gPLSQLParser->log_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleerror_logging_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_errors_key_in_error_logging_clause4651);
            m_gPLSQLParser->errors_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleerror_logging_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:557:9: ( error_logging_into_part )?
            {
                int alt179=2;
                alt179 = cdfa179.predict(this, this->get_rec(), this->get_istream(), cdfa179 );
                if  (this->hasException())
                {
                    goto ruleerror_logging_clauseEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }

                switch (alt179)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:557:9: error_logging_into_part
            	    {
            	        this->followPush(FOLLOW_error_logging_into_part_in_error_logging_clause4662);
            	        error_logging_into_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleerror_logging_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:558:9: ( ( LEFT_PAREN )=> expression_wrapper )?
            {
                int alt180=2;
                {
                    int LA180_0 = this->LA(1);
                    if ( (LA180_0 == SQL92_RESERVED_CURSOR) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == SQL92_RESERVED_NOT) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == MINUS_SIGN) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == PLUS_SIGN) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == SQL92_RESERVED_PRIOR) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == REGULAR_ID))
                    {
                        {
                            int LA180_7 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                            {
                                alt180=1;
                            }
                        }
                    }
                    else if ( (LA180_0 == SQL92_RESERVED_DISTINCT) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == SQL92_RESERVED_ALL) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == DELIMITED_ID) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == SQL92_RESERVED_CASE) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == SQL92_RESERVED_EXISTS) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == SQL92_RESERVED_ANY) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == INTRODUCER) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == BINDVAR) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == COLON) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == APPROXIMATE_NUM_LIT || LA180_0 == EXACT_NUM_LIT || LA180_0 == UNSIGNED_INTEGER) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == SQL92_RESERVED_DATE) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (((LA180_0 >= CHAR_STRING) && (LA180_0 <= CHAR_STRING_PERL)) || LA180_0 == NATIONAL_CHAR_STRING_LIT) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == SQL92_RESERVED_NULL) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == SQL92_RESERVED_TRUE) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == SQL92_RESERVED_FALSE) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == SQL92_RESERVED_DEFAULT) && (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == LEFT_PAREN))
                    {
                        {
                            int LA180_24 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                            {
                                alt180=1;
                            }
                        }
                    }
                }
                switch (alt180)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:558:10: ( LEFT_PAREN )=> expression_wrapper
            	    {
            	        this->followPush(FOLLOW_expression_wrapper_in_error_logging_clause4679);
            	        expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleerror_logging_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:559:9: ( error_logging_reject_part )?
            {
                int alt181=2;
                {
                    int LA181_0 = this->LA(1);
                    if ( (LA181_0 == REGULAR_ID))
                    {
                        {
                            int LA181_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "REJECT"))))
                            {
                                alt181=1;
                            }
                        }
                    }
                }
                switch (alt181)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:559:9: error_logging_reject_part
            	    {
            	        this->followPush(FOLLOW_error_logging_reject_part_in_error_logging_clause4691);
            	        error_logging_reject_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleerror_logging_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleerror_logging_clauseEx; /* Prevent compiler warnings */
    ruleerror_logging_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end error_logging_clause */

/**
 * $ANTLR start error_logging_into_part
 * PLSQL_DMLParser.g:562:1: error_logging_into_part : into_key tableview_name ;
 */
void
PLSQLParser_PLSQL_DMLParser::error_logging_into_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:563:5: ( into_key tableview_name )
        // PLSQL_DMLParser.g:563:10: into_key tableview_name
        {
            this->followPush(FOLLOW_into_key_in_error_logging_into_part4712);
            m_gPLSQLParser->into_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleerror_logging_into_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_tableview_name_in_error_logging_into_part4714);
            m_gPLSQLParser->tableview_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleerror_logging_into_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleerror_logging_into_partEx; /* Prevent compiler warnings */
    ruleerror_logging_into_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end error_logging_into_part */

/**
 * $ANTLR start error_logging_reject_part
 * PLSQL_DMLParser.g:566:1: error_logging_reject_part : reject_key limit_key ( ( unlimited_key )=> unlimited_key | expression_wrapper ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::error_logging_reject_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:567:5: ( reject_key limit_key ( ( unlimited_key )=> unlimited_key | expression_wrapper ) )
        // PLSQL_DMLParser.g:567:10: reject_key limit_key ( ( unlimited_key )=> unlimited_key | expression_wrapper )
        {
            this->followPush(FOLLOW_reject_key_in_error_logging_reject_part4734);
            m_gPLSQLParser->reject_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleerror_logging_reject_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_limit_key_in_error_logging_reject_part4736);
            m_gPLSQLParser->limit_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleerror_logging_reject_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:567:31: ( ( unlimited_key )=> unlimited_key | expression_wrapper )
            {
                int alt182=2;
                {
                    int LA182_0 = this->LA(1);
                    if ( (LA182_0 == REGULAR_ID))
                    {
                        {
                            int LA182_1 = this->LA(2);
                            if ( (( ((equalsIgnoreCase(LT(1)->getText(), "UNLIMITED"))) && (this->msynpred( antlr3::ClassForwarder<synpred23_PLSQL_DMLParser>() )) )))
                            {
                                alt182=1;
                            }
                            else if ( (true))
                            {
                                alt182=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 182 );
                                ex->set_state( 1 );


                                goto ruleerror_logging_reject_partEx;

                            }
                        }
                    }
                    else if ( (LA182_0 == APPROXIMATE_NUM_LIT || LA182_0 == BINDVAR || ((LA182_0 >= CHAR_STRING) && (LA182_0 <= COLON)) || LA182_0 == DELIMITED_ID || LA182_0 == EXACT_NUM_LIT || LA182_0 == INTRODUCER || LA182_0 == LEFT_PAREN || ((LA182_0 >= MINUS_SIGN) && (LA182_0 <= NATIONAL_CHAR_STRING_LIT)) || LA182_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA182_0 == PLUS_SIGN || LA182_0 == SQL92_RESERVED_ALL || LA182_0 == SQL92_RESERVED_ANY || LA182_0 == SQL92_RESERVED_CASE || ((LA182_0 >= SQL92_RESERVED_CURSOR) && (LA182_0 <= SQL92_RESERVED_DATE)) || LA182_0 == SQL92_RESERVED_DEFAULT || LA182_0 == SQL92_RESERVED_DISTINCT || ((LA182_0 >= SQL92_RESERVED_EXISTS) && (LA182_0 <= SQL92_RESERVED_FALSE)) || ((LA182_0 >= SQL92_RESERVED_NOT) && (LA182_0 <= SQL92_RESERVED_NULL)) || LA182_0 == SQL92_RESERVED_PRIOR || LA182_0 == SQL92_RESERVED_TRUE || LA182_0 == UNSIGNED_INTEGER))
                    {
                        alt182=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 182 );
                        ex->set_state( 0 );


                        goto ruleerror_logging_reject_partEx;

                    }
                }
                switch (alt182)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:567:32: ( unlimited_key )=> unlimited_key
            	    {
            	        this->followPush(FOLLOW_unlimited_key_in_error_logging_reject_part4743);
            	        m_gPLSQLParser->unlimited_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleerror_logging_reject_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:567:63: expression_wrapper
            	    {
            	        this->followPush(FOLLOW_expression_wrapper_in_error_logging_reject_part4745);
            	        expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleerror_logging_reject_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleerror_logging_reject_partEx; /* Prevent compiler warnings */
    ruleerror_logging_reject_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end error_logging_reject_part */

/**
 * $ANTLR start dml_table_expression_clause
 * PLSQL_DMLParser.g:570:1: dml_table_expression_clause : ( table_collection_expression | LEFT_PAREN select_statement ( subquery_restriction_clause )? RIGHT_PAREN | tableview_name ( sample_clause )? );
 */
void
PLSQLParser_PLSQL_DMLParser::dml_table_expression_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:571:5: ( table_collection_expression | LEFT_PAREN select_statement ( subquery_restriction_clause )? RIGHT_PAREN | tableview_name ( sample_clause )? )

            ANTLR_UINT32 alt185;

            alt185=3;

            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_TABLE:
            case SQL92_RESERVED_THE:
            	{
            		alt185=1;
            	}
                break;
            case LEFT_PAREN:
            	{
            		alt185=2;
            	}
                break;
            case DELIMITED_ID:
            case INTRODUCER:
            case REGULAR_ID:
            	{
            		alt185=3;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 185 );
                ex->set_state( 0 );


                goto ruledml_table_expression_clauseEx;

            }

            switch (alt185)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:571:10: table_collection_expression
        	    {
        	        this->followPush(FOLLOW_table_collection_expression_in_dml_table_expression_clause4766);
        	        table_collection_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledml_table_expression_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:572:10: LEFT_PAREN select_statement ( subquery_restriction_clause )? RIGHT_PAREN
        	    {
        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_dml_table_expression_clause4777);
        	        if  (this->hasException())
        	        {
        	            goto ruledml_table_expression_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_select_statement_in_dml_table_expression_clause4779);
        	        select_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledml_table_expression_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:572:38: ( subquery_restriction_clause )?
        	        {
        	            int alt183=2;
        	            {
        	                int LA183_0 = this->LA(1);
        	                if ( (LA183_0 == SQL92_RESERVED_WITH))
        	                {
        	                    alt183=1;
        	                }
        	            }
        	            switch (alt183)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:572:38: subquery_restriction_clause
        	        	    {
        	        	        this->followPush(FOLLOW_subquery_restriction_clause_in_dml_table_expression_clause4781);
        	        	        subquery_restriction_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledml_table_expression_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_dml_table_expression_clause4784);
        	        if  (this->hasException())
        	        {
        	            goto ruledml_table_expression_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:573:10: tableview_name ( sample_clause )?
        	    {
        	        this->followPush(FOLLOW_tableview_name_in_dml_table_expression_clause4795);
        	        m_gPLSQLParser->tableview_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledml_table_expression_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:573:25: ( sample_clause )?
        	        {
        	            int alt184=2;
        	            alt184 = cdfa184.predict(this, this->get_rec(), this->get_istream(), cdfa184 );
        	            if  (this->hasException())
        	            {
        	                goto ruledml_table_expression_clauseEx;
        	            }
        	            if (this->hasFailed())
        	            {
        	                return ;
        	            }

        	            switch (alt184)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:573:25: sample_clause
        	        	    {
        	        	        this->followPush(FOLLOW_sample_clause_in_dml_table_expression_clause4797);
        	        	        sample_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledml_table_expression_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruledml_table_expression_clauseEx; /* Prevent compiler warnings */
    ruledml_table_expression_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dml_table_expression_clause */

/**
 * $ANTLR start table_collection_expression
 * PLSQL_DMLParser.g:576:1: table_collection_expression : ( table_key | the_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression RIGHT_PAREN ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::table_collection_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:577:5: ( ( table_key | the_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression RIGHT_PAREN ) )
        // PLSQL_DMLParser.g:577:10: ( table_key | the_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression RIGHT_PAREN )
        {
            // PLSQL_DMLParser.g:577:10: ( table_key | the_key )
            {
                int alt186=2;
                {
                    int LA186_0 = this->LA(1);
                    if ( (LA186_0 == SQL92_RESERVED_TABLE))
                    {
                        alt186=1;
                    }
                    else if ( (LA186_0 == SQL92_RESERVED_THE))
                    {
                        alt186=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 186 );
                        ex->set_state( 0 );


                        goto ruletable_collection_expressionEx;

                    }
                }
                switch (alt186)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:577:12: table_key
            	    {
            	        this->followPush(FOLLOW_table_key_in_table_collection_expression4820);
            	        m_gPLSQLParser->table_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:577:24: the_key
            	    {
            	        this->followPush(FOLLOW_the_key_in_table_collection_expression4824);
            	        m_gPLSQLParser->the_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:578:10: ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression RIGHT_PAREN )
            {
                int alt187=2;
                {
                    int LA187_0 = this->LA(1);
                    if ( (LA187_0 == LEFT_PAREN))
                    {
                        {
                            int LA187_1 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred24_PLSQL_DMLParser>() )))
                            {
                                alt187=1;
                            }
                            else if ( (true))
                            {
                                alt187=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 187 );
                                ex->set_state( 1 );


                                goto ruletable_collection_expressionEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 187 );
                        ex->set_state( 0 );


                        goto ruletable_collection_expressionEx;

                    }
                }
                switch (alt187)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:578:12: ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_table_collection_expression4852);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_subquery_in_table_collection_expression4854);
            	        subquery();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_table_collection_expression4856);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:579:12: LEFT_PAREN expression RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_table_collection_expression4869);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_table_collection_expression4871);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_table_collection_expression4873);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_collection_expressionEx; /* Prevent compiler warnings */
    ruletable_collection_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_collection_expression */

/**
 * $ANTLR start subquery_restriction_clause
 * PLSQL_DMLParser.g:583:1: subquery_restriction_clause : with_key ( read_key only_key | check_key option_key ( constraint_key constraint_name )? ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::subquery_restriction_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:584:5: ( with_key ( read_key only_key | check_key option_key ( constraint_key constraint_name )? ) )
        // PLSQL_DMLParser.g:584:10: with_key ( read_key only_key | check_key option_key ( constraint_key constraint_name )? )
        {
            this->followPush(FOLLOW_with_key_in_subquery_restriction_clause4905);
            m_gPLSQLParser->with_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubquery_restriction_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:585:5: ( read_key only_key | check_key option_key ( constraint_key constraint_name )? )
            {
                int alt189=2;
                {
                    int LA189_0 = this->LA(1);
                    if ( (LA189_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "READ"))))
                    {
                        alt189=1;
                    }
                    else if ( (LA189_0 == SQL92_RESERVED_CHECK))
                    {
                        alt189=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 189 );
                        ex->set_state( 0 );


                        goto rulesubquery_restriction_clauseEx;

                    }
                }
                switch (alt189)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:585:10: read_key only_key
            	    {
            	        this->followPush(FOLLOW_read_key_in_subquery_restriction_clause4916);
            	        m_gPLSQLParser->read_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_restriction_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_only_key_in_subquery_restriction_clause4918);
            	        m_gPLSQLParser->only_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_restriction_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:586:10: check_key option_key ( constraint_key constraint_name )?
            	    {
            	        this->followPush(FOLLOW_check_key_in_subquery_restriction_clause4929);
            	        m_gPLSQLParser->check_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_restriction_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_option_key_in_subquery_restriction_clause4931);
            	        m_gPLSQLParser->option_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_restriction_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:586:31: ( constraint_key constraint_name )?
            	        {
            	            int alt188=2;
            	            {
            	                int LA188_0 = this->LA(1);
            	                if ( (LA188_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "CONSTRAINT"))))
            	                {
            	                    alt188=1;
            	                }
            	            }
            	            switch (alt188)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:586:32: constraint_key constraint_name
            	        	    {
            	        	        this->followPush(FOLLOW_constraint_key_in_subquery_restriction_clause4934);
            	        	        m_gPLSQLParser->constraint_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesubquery_restriction_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_constraint_name_in_subquery_restriction_clause4936);
            	        	        m_gPLSQLParser->constraint_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesubquery_restriction_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubquery_restriction_clauseEx; /* Prevent compiler warnings */
    rulesubquery_restriction_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end subquery_restriction_clause */

/**
 * $ANTLR start sample_clause
 * PLSQL_DMLParser.g:590:1: sample_clause : sample_key ( block_key )? LEFT_PAREN expression ( COMMA expression )? RIGHT_PAREN ( seed_part )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::sample_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:591:5: ( sample_key ( block_key )? LEFT_PAREN expression ( COMMA expression )? RIGHT_PAREN ( seed_part )? )
        // PLSQL_DMLParser.g:591:10: sample_key ( block_key )? LEFT_PAREN expression ( COMMA expression )? RIGHT_PAREN ( seed_part )?
        {
            this->followPush(FOLLOW_sample_key_in_sample_clause4964);
            m_gPLSQLParser->sample_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesample_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:591:21: ( block_key )?
            {
                int alt190=2;
                {
                    int LA190_0 = this->LA(1);
                    if ( (LA190_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "BLOCK"))))
                    {
                        alt190=1;
                    }
                }
                switch (alt190)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:591:21: block_key
            	    {
            	        this->followPush(FOLLOW_block_key_in_sample_clause4966);
            	        m_gPLSQLParser->block_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesample_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_sample_clause4978);
            if  (this->hasException())
            {
                goto rulesample_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_sample_clause4980);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesample_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:592:31: ( COMMA expression )?
            {
                int alt191=2;
                {
                    int LA191_0 = this->LA(1);
                    if ( (LA191_0 == COMMA))
                    {
                        alt191=1;
                    }
                }
                switch (alt191)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:592:32: COMMA expression
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_sample_clause4983);
            	        if  (this->hasException())
            	        {
            	            goto rulesample_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_sample_clause4985);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesample_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_sample_clause4989);
            if  (this->hasException())
            {
                goto rulesample_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:593:9: ( seed_part )?
            {
                int alt192=2;
                alt192 = cdfa192.predict(this, this->get_rec(), this->get_istream(), cdfa192 );
                if  (this->hasException())
                {
                    goto rulesample_clauseEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }

                switch (alt192)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:593:9: seed_part
            	    {
            	        this->followPush(FOLLOW_seed_part_in_sample_clause4999);
            	        seed_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesample_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesample_clauseEx; /* Prevent compiler warnings */
    rulesample_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sample_clause */

/**
 * $ANTLR start seed_part
 * PLSQL_DMLParser.g:596:1: seed_part : seed_key LEFT_PAREN expression RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::seed_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:597:5: ( seed_key LEFT_PAREN expression RIGHT_PAREN )
        // PLSQL_DMLParser.g:597:10: seed_key LEFT_PAREN expression RIGHT_PAREN
        {
            this->followPush(FOLLOW_seed_key_in_seed_part5020);
            m_gPLSQLParser->seed_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleseed_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_seed_part5022);
            if  (this->hasException())
            {
                goto ruleseed_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_seed_part5024);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleseed_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_seed_part5026);
            if  (this->hasException())
            {
                goto ruleseed_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleseed_partEx; /* Prevent compiler warnings */
    ruleseed_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end seed_part */

/**
 * $ANTLR start cursor_expression
 * PLSQL_DMLParser.g:603:1: cursor_expression : cursor_key LEFT_PAREN subquery RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::cursor_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:604:5: ( cursor_key LEFT_PAREN subquery RIGHT_PAREN )
        // PLSQL_DMLParser.g:604:10: cursor_key LEFT_PAREN subquery RIGHT_PAREN
        {
            this->followPush(FOLLOW_cursor_key_in_cursor_expression5049);
            m_gPLSQLParser->cursor_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecursor_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_cursor_expression5051);
            if  (this->hasException())
            {
                goto rulecursor_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_subquery_in_cursor_expression5053);
            subquery();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecursor_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_cursor_expression5055);
            if  (this->hasException())
            {
                goto rulecursor_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecursor_expressionEx; /* Prevent compiler warnings */
    rulecursor_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cursor_expression */

/**
 * $ANTLR start expression_list
 * PLSQL_DMLParser.g:607:1: expression_list : LEFT_PAREN ( expression )? ( COMMA expression )* RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::expression_list()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:608:5: ( LEFT_PAREN ( expression )? ( COMMA expression )* RIGHT_PAREN )
        // PLSQL_DMLParser.g:608:10: LEFT_PAREN ( expression )? ( COMMA expression )* RIGHT_PAREN
        {
             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_expression_list5075);
            if  (this->hasException())
            {
                goto ruleexpression_listEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:608:21: ( expression )?
            {
                int alt193=2;
                {
                    int LA193_0 = this->LA(1);
                    if ( (LA193_0 == APPROXIMATE_NUM_LIT || LA193_0 == BINDVAR || ((LA193_0 >= CHAR_STRING) && (LA193_0 <= COLON)) || LA193_0 == DELIMITED_ID || LA193_0 == EXACT_NUM_LIT || LA193_0 == INTRODUCER || LA193_0 == LEFT_PAREN || ((LA193_0 >= MINUS_SIGN) && (LA193_0 <= NATIONAL_CHAR_STRING_LIT)) || LA193_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA193_0 == PLUS_SIGN || LA193_0 == REGULAR_ID || LA193_0 == SQL92_RESERVED_ALL || LA193_0 == SQL92_RESERVED_ANY || LA193_0 == SQL92_RESERVED_CASE || ((LA193_0 >= SQL92_RESERVED_CURSOR) && (LA193_0 <= SQL92_RESERVED_DATE)) || LA193_0 == SQL92_RESERVED_DEFAULT || LA193_0 == SQL92_RESERVED_DISTINCT || ((LA193_0 >= SQL92_RESERVED_EXISTS) && (LA193_0 <= SQL92_RESERVED_FALSE)) || ((LA193_0 >= SQL92_RESERVED_NOT) && (LA193_0 <= SQL92_RESERVED_NULL)) || LA193_0 == SQL92_RESERVED_PRIOR || LA193_0 == SQL92_RESERVED_TRUE || LA193_0 == UNSIGNED_INTEGER))
                    {
                        alt193=1;
                    }
                }
                switch (alt193)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:608:21: expression
            	    {
            	        this->followPush(FOLLOW_expression_in_expression_list5077);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexpression_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:608:33: ( COMMA expression )*

            for (;;)
            {
                int alt194=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA194_0 = this->LA(1);
                    if ( (LA194_0 == COMMA))
                    {
                        alt194=1;
                    }

                }
                switch (alt194)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:608:34: COMMA expression
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_expression_list5081);
            	        if  (this->hasException())
            	        {
            	            goto ruleexpression_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_expression_list5083);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexpression_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop194;	/* break out of the loop */
            	    break;
                }
            }
            loop194: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_expression_list5087);
            if  (this->hasException())
            {
                goto ruleexpression_listEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexpression_listEx; /* Prevent compiler warnings */
    ruleexpression_listEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end expression_list */

/**
 * $ANTLR start condition
 * PLSQL_DMLParser.g:611:1: condition : expression ;
 */
void
PLSQLParser_PLSQL_DMLParser::condition()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:612:5: ( expression )
        // PLSQL_DMLParser.g:612:11: expression
        {
            this->followPush(FOLLOW_expression_in_condition5108);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconditionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconditionEx; /* Prevent compiler warnings */
    ruleconditionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end condition */

/**
 * $ANTLR start condition_wrapper
 * PLSQL_DMLParser.g:615:1: condition_wrapper : expression ;
 */
void
PLSQLParser_PLSQL_DMLParser::condition_wrapper()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:616:5: ( expression )
        // PLSQL_DMLParser.g:616:10: expression
        {
            this->followPush(FOLLOW_expression_in_condition_wrapper5128);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecondition_wrapperEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecondition_wrapperEx; /* Prevent compiler warnings */
    rulecondition_wrapperEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end condition_wrapper */

/**
 * $ANTLR start expression
 * PLSQL_DMLParser.g:619:1: expression : ( ( cursor_key LEFT_PAREN ( select_key | with_key ) )=> cursor_expression | logical_and_expression ( or_key logical_and_expression )* );
 */
void
PLSQLParser_PLSQL_DMLParser::expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:620:5: ( ( cursor_key LEFT_PAREN ( select_key | with_key ) )=> cursor_expression | logical_and_expression ( or_key logical_and_expression )* )

            ANTLR_UINT32 alt196;

            alt196=2;

            {
                int LA196_0 = this->LA(1);
                if ( (LA196_0 == SQL92_RESERVED_CURSOR) && (this->msynpred( antlr3::ClassForwarder<synpred25_PLSQL_DMLParser>() )))
                {
                    alt196=1;
                }
                else if ( (LA196_0 == APPROXIMATE_NUM_LIT || LA196_0 == BINDVAR || ((LA196_0 >= CHAR_STRING) && (LA196_0 <= COLON)) || LA196_0 == DELIMITED_ID || LA196_0 == EXACT_NUM_LIT || LA196_0 == INTRODUCER || LA196_0 == LEFT_PAREN || ((LA196_0 >= MINUS_SIGN) && (LA196_0 <= NATIONAL_CHAR_STRING_LIT)) || LA196_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA196_0 == PLUS_SIGN || LA196_0 == REGULAR_ID || LA196_0 == SQL92_RESERVED_ALL || LA196_0 == SQL92_RESERVED_ANY || LA196_0 == SQL92_RESERVED_CASE || LA196_0 == SQL92_RESERVED_DATE || LA196_0 == SQL92_RESERVED_DEFAULT || LA196_0 == SQL92_RESERVED_DISTINCT || ((LA196_0 >= SQL92_RESERVED_EXISTS) && (LA196_0 <= SQL92_RESERVED_FALSE)) || ((LA196_0 >= SQL92_RESERVED_NOT) && (LA196_0 <= SQL92_RESERVED_NULL)) || LA196_0 == SQL92_RESERVED_PRIOR || LA196_0 == SQL92_RESERVED_TRUE || LA196_0 == UNSIGNED_INTEGER))
                {
                    alt196=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 196 );
                    ex->set_state( 0 );


                    goto ruleexpressionEx;

                }
            }
            switch (alt196)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:620:10: ( cursor_key LEFT_PAREN ( select_key | with_key ) )=> cursor_expression
        	    {
        	        this->followPush(FOLLOW_cursor_expression_in_expression5162);
        	        cursor_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleexpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:621:10: logical_and_expression ( or_key logical_and_expression )*
        	    {
        	        this->followPush(FOLLOW_logical_and_expression_in_expression5173);
        	        logical_and_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleexpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:621:33: ( or_key logical_and_expression )*

        	        for (;;)
        	        {
        	            int alt195=2;
        	            {
        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                */
        	                int LA195_0 = this->LA(1);
        	                if ( (LA195_0 == SQL92_RESERVED_OR))
        	                {
        	                    alt195=1;
        	                }

        	            }
        	            switch (alt195)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:621:35: or_key logical_and_expression
        	        	    {
        	        	        this->followPush(FOLLOW_or_key_in_expression5177);
        	        	        m_gPLSQLParser->or_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleexpressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_logical_and_expression_in_expression5179);
        	        	        logical_and_expression();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleexpressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop195;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop195: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end expression */

/**
 * $ANTLR start expression_wrapper
 * PLSQL_DMLParser.g:624:1: expression_wrapper : expression ;
 */
void
PLSQLParser_PLSQL_DMLParser::expression_wrapper()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:625:5: ( expression )
        // PLSQL_DMLParser.g:625:10: expression
        {
            this->followPush(FOLLOW_expression_in_expression_wrapper5202);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexpression_wrapperEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexpression_wrapperEx; /* Prevent compiler warnings */
    ruleexpression_wrapperEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end expression_wrapper */

/**
 * $ANTLR start logical_and_expression
 * PLSQL_DMLParser.g:628:1: logical_and_expression : negated_expression ( and_key negated_expression )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::logical_and_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:629:5: ( negated_expression ( and_key negated_expression )* )
        // PLSQL_DMLParser.g:629:10: negated_expression ( and_key negated_expression )*
        {
            this->followPush(FOLLOW_negated_expression_in_logical_and_expression5222);
            negated_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelogical_and_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:629:29: ( and_key negated_expression )*

            for (;;)
            {
                int alt197=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA197_0 = this->LA(1);
                    if ( (LA197_0 == SQL92_RESERVED_AND))
                    {
                        alt197=1;
                    }

                }
                switch (alt197)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:629:31: and_key negated_expression
            	    {
            	        this->followPush(FOLLOW_and_key_in_logical_and_expression5226);
            	        m_gPLSQLParser->and_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulelogical_and_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_negated_expression_in_logical_and_expression5228);
            	        negated_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulelogical_and_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop197;	/* break out of the loop */
            	    break;
                }
            }
            loop197: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelogical_and_expressionEx; /* Prevent compiler warnings */
    rulelogical_and_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end logical_and_expression */

/**
 * $ANTLR start negated_expression
 * PLSQL_DMLParser.g:632:1: negated_expression : ( not_key negated_expression | equality_expression );
 */
void
PLSQLParser_PLSQL_DMLParser::negated_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:633:5: ( not_key negated_expression | equality_expression )

            ANTLR_UINT32 alt198;

            alt198=2;

            {
                int LA198_0 = this->LA(1);
                if ( (LA198_0 == SQL92_RESERVED_NOT))
                {
                    alt198=1;
                }
                else if ( (LA198_0 == APPROXIMATE_NUM_LIT || LA198_0 == BINDVAR || ((LA198_0 >= CHAR_STRING) && (LA198_0 <= COLON)) || LA198_0 == DELIMITED_ID || LA198_0 == EXACT_NUM_LIT || LA198_0 == INTRODUCER || LA198_0 == LEFT_PAREN || ((LA198_0 >= MINUS_SIGN) && (LA198_0 <= NATIONAL_CHAR_STRING_LIT)) || LA198_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA198_0 == PLUS_SIGN || LA198_0 == REGULAR_ID || LA198_0 == SQL92_RESERVED_ALL || LA198_0 == SQL92_RESERVED_ANY || LA198_0 == SQL92_RESERVED_CASE || LA198_0 == SQL92_RESERVED_DATE || LA198_0 == SQL92_RESERVED_DEFAULT || LA198_0 == SQL92_RESERVED_DISTINCT || ((LA198_0 >= SQL92_RESERVED_EXISTS) && (LA198_0 <= SQL92_RESERVED_FALSE)) || LA198_0 == SQL92_RESERVED_NULL || LA198_0 == SQL92_RESERVED_PRIOR || LA198_0 == SQL92_RESERVED_TRUE || LA198_0 == UNSIGNED_INTEGER))
                {
                    alt198=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 198 );
                    ex->set_state( 0 );


                    goto rulenegated_expressionEx;

                }
            }
            switch (alt198)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:633:10: not_key negated_expression
        	    {
        	        this->followPush(FOLLOW_not_key_in_negated_expression5251);
        	        m_gPLSQLParser->not_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenegated_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_negated_expression_in_negated_expression5253);
        	        negated_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenegated_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:634:10: equality_expression
        	    {
        	        this->followPush(FOLLOW_equality_expression_in_negated_expression5264);
        	        equality_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenegated_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulenegated_expressionEx; /* Prevent compiler warnings */
    rulenegated_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end negated_expression */

/**
 * $ANTLR start equality_expression
 * PLSQL_DMLParser.g:637:1: equality_expression : multiset_comparsion ( is_key ( not_key )? ( null_key | nan_key | present_key | infinite_key | a_key set_key | empty_key | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN ) )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::equality_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:638:5: ( multiset_comparsion ( is_key ( not_key )? ( null_key | nan_key | present_key | infinite_key | a_key set_key | empty_key | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN ) )? )
        // PLSQL_DMLParser.g:638:10: multiset_comparsion ( is_key ( not_key )? ( null_key | nan_key | present_key | infinite_key | a_key set_key | empty_key | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN ) )?
        {
            this->followPush(FOLLOW_multiset_comparsion_in_equality_expression5284);
            multiset_comparsion();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleequality_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:639:5: ( is_key ( not_key )? ( null_key | nan_key | present_key | infinite_key | a_key set_key | empty_key | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN ) )?
            {
                int alt204=2;
                {
                    int LA204_0 = this->LA(1);
                    if ( (LA204_0 == SQL92_RESERVED_IS))
                    {
                        alt204=1;
                    }
                }
                switch (alt204)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:639:10: is_key ( not_key )? ( null_key | nan_key | present_key | infinite_key | a_key set_key | empty_key | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN )
            	    {
            	        this->followPush(FOLLOW_is_key_in_equality_expression5295);
            	        m_gPLSQLParser->is_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleequality_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:639:17: ( not_key )?
            	        {
            	            int alt199=2;
            	            {
            	                int LA199_0 = this->LA(1);
            	                if ( (LA199_0 == SQL92_RESERVED_NOT))
            	                {
            	                    alt199=1;
            	                }
            	            }
            	            switch (alt199)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:639:17: not_key
            	        	    {
            	        	        this->followPush(FOLLOW_not_key_in_equality_expression5297);
            	        	        m_gPLSQLParser->not_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQL_DMLParser.g:640:9: ( null_key | nan_key | present_key | infinite_key | a_key set_key | empty_key | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN )
            	        {
            	            int alt203=7;
            	            {
            	                int LA203_0 = this->LA(1);
            	                if ( (LA203_0 == SQL92_RESERVED_NULL))
            	                {
            	                    alt203=1;
            	                }
            	                else if ( (LA203_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "EMPTY")))||((equalsIgnoreCase(LT(1)->getText(), "A")))||((equalsIgnoreCase(LT(1)->getText(), "PRESENT")))||((equalsIgnoreCase(LT(1)->getText(), "NAN")))||((equalsIgnoreCase(LT(1)->getText(), "INFINITE"))))))
            	                {
            	                    {
            	                        int LA203_2 = this->LA(2);
            	                        if ( (LA203_2 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "A"))))
            	                        {
            	                            alt203=5;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NAN"))))
            	                        {
            	                            alt203=2;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "PRESENT"))))
            	                        {
            	                            alt203=3;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "INFINITE"))))
            	                        {
            	                            alt203=4;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "EMPTY"))))
            	                        {
            	                            alt203=6;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 203 );
            	                            ex->set_state( 2 );


            	                            goto ruleequality_expressionEx;

            	                        }
            	                    }
            	                }
            	                else if ( (LA203_0 == SQL92_RESERVED_OF))
            	                {
            	                    alt203=7;
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 203 );
            	                    ex->set_state( 0 );


            	                    goto ruleequality_expressionEx;

            	                }
            	            }
            	            switch (alt203)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:640:14: null_key
            	        	    {
            	        	        this->followPush(FOLLOW_null_key_in_equality_expression5313);
            	        	        m_gPLSQLParser->null_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:641:14: nan_key
            	        	    {
            	        	        this->followPush(FOLLOW_nan_key_in_equality_expression5328);
            	        	        m_gPLSQLParser->nan_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // PLSQL_DMLParser.g:642:14: present_key
            	        	    {
            	        	        this->followPush(FOLLOW_present_key_in_equality_expression5343);
            	        	        m_gPLSQLParser->present_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 4:
            	        	    // PLSQL_DMLParser.g:643:14: infinite_key
            	        	    {
            	        	        this->followPush(FOLLOW_infinite_key_in_equality_expression5358);
            	        	        m_gPLSQLParser->infinite_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 5:
            	        	    // PLSQL_DMLParser.g:644:14: a_key set_key
            	        	    {
            	        	        this->followPush(FOLLOW_a_key_in_equality_expression5373);
            	        	        m_gPLSQLParser->a_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_set_key_in_equality_expression5375);
            	        	        m_gPLSQLParser->set_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 6:
            	        	    // PLSQL_DMLParser.g:645:14: empty_key
            	        	    {
            	        	        this->followPush(FOLLOW_empty_key_in_equality_expression5390);
            	        	        m_gPLSQLParser->empty_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 7:
            	        	    // PLSQL_DMLParser.g:646:14: of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN
            	        	    {
            	        	        this->followPush(FOLLOW_of_key_in_equality_expression5405);
            	        	        m_gPLSQLParser->of_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // PLSQL_DMLParser.g:646:21: ( type_key )?
            	        	        {
            	        	            int alt200=2;
            	        	            {
            	        	                int LA200_0 = this->LA(1);
            	        	                if ( (LA200_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "TYPE"))))
            	        	                {
            	        	                    alt200=1;
            	        	                }
            	        	            }
            	        	            switch (alt200)
            	        	            {
            	        	        	case 1:
            	        	        	    // PLSQL_DMLParser.g:646:21: type_key
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_type_key_in_equality_expression5407);
            	        	        	        m_gPLSQLParser->type_key();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleequality_expressionEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_equality_expression5410);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // PLSQL_DMLParser.g:646:42: ( only_key )?
            	        	        {
            	        	            int alt201=2;
            	        	            {
            	        	                int LA201_0 = this->LA(1);
            	        	                if ( (LA201_0 == REGULAR_ID))
            	        	                {
            	        	                    {
            	        	                        int LA201_1 = this->LA(2);
            	        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "ONLY"))))
            	        	                        {
            	        	                            alt201=1;
            	        	                        }
            	        	                    }
            	        	                }
            	        	            }
            	        	            switch (alt201)
            	        	            {
            	        	        	case 1:
            	        	        	    // PLSQL_DMLParser.g:646:42: only_key
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_only_key_in_equality_expression5412);
            	        	        	        m_gPLSQLParser->only_key();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleequality_expressionEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        this->followPush(FOLLOW_type_spec_in_equality_expression5415);
            	        	        m_gPLSQLParser->type_spec();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // PLSQL_DMLParser.g:646:62: ( COMMA type_spec )*

            	        	        for (;;)
            	        	        {
            	        	            int alt202=2;
            	        	            {
            	        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	        	                */
            	        	                int LA202_0 = this->LA(1);
            	        	                if ( (LA202_0 == COMMA))
            	        	                {
            	        	                    alt202=1;
            	        	                }

            	        	            }
            	        	            switch (alt202)
            	        	            {
            	        	        	case 1:
            	        	        	    // PLSQL_DMLParser.g:646:63: COMMA type_spec
            	        	        	    {
            	        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_equality_expression5418);
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleequality_expressionEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	        this->followPush(FOLLOW_type_spec_in_equality_expression5420);
            	        	        	        m_gPLSQLParser->type_spec();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleequality_expressionEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	        	default:
            	        	        	    goto loop202;	/* break out of the loop */
            	        	        	    break;
            	        	            }
            	        	        }
            	        	        loop202: ; /* Jump out to here if this rule does not match */


            	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_equality_expression5424);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleequality_expressionEx; /* Prevent compiler warnings */
    ruleequality_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end equality_expression */

/**
 * $ANTLR start multiset_comparsion
 * PLSQL_DMLParser.g:652:1: multiset_comparsion : relational_expression ( multiset_type ( of_key )? concatenation )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::multiset_comparsion()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:653:5: ( relational_expression ( multiset_type ( of_key )? concatenation )? )
        // PLSQL_DMLParser.g:653:10: relational_expression ( multiset_type ( of_key )? concatenation )?
        {
            this->followPush(FOLLOW_relational_expression_in_multiset_comparsion5462);
            relational_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemultiset_comparsionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:654:5: ( multiset_type ( of_key )? concatenation )?
            {
                int alt206=2;
                {
                    int LA206_0 = this->LA(1);
                    if ( (LA206_0 == REGULAR_ID))
                    {
                        {
                            int LA206_1 = this->LA(2);
                            if ( ((((equalsIgnoreCase(LT(1)->getText(), "SUBMULTISET")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))))
                            {
                                alt206=1;
                            }
                        }
                    }
                }
                switch (alt206)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:654:10: multiset_type ( of_key )? concatenation
            	    {
            	        this->followPush(FOLLOW_multiset_type_in_multiset_comparsion5473);
            	        multiset_type();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_comparsionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:654:24: ( of_key )?
            	        {
            	            int alt205=2;
            	            {
            	                int LA205_0 = this->LA(1);
            	                if ( (LA205_0 == SQL92_RESERVED_OF))
            	                {
            	                    alt205=1;
            	                }
            	            }
            	            switch (alt205)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:654:24: of_key
            	        	    {
            	        	        this->followPush(FOLLOW_of_key_in_multiset_comparsion5475);
            	        	        m_gPLSQLParser->of_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemultiset_comparsionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_concatenation_in_multiset_comparsion5478);
            	        concatenation();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_comparsionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemultiset_comparsionEx; /* Prevent compiler warnings */
    rulemultiset_comparsionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multiset_comparsion */

/**
 * $ANTLR start multiset_type
 * PLSQL_DMLParser.g:657:1: multiset_type : ( member_key | submultiset_key );
 */
void
PLSQLParser_PLSQL_DMLParser::multiset_type()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:658:5: ( member_key | submultiset_key )

            ANTLR_UINT32 alt207;

            alt207=2;

            {
                int LA207_0 = this->LA(1);
                if ( (LA207_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "SUBMULTISET")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))))
                {
                    {
                        int LA207_1 = this->LA(2);
                        if ( ((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))
                        {
                            alt207=1;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "SUBMULTISET"))))
                        {
                            alt207=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 207 );
                            ex->set_state( 1 );


                            goto rulemultiset_typeEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 207 );
                    ex->set_state( 0 );


                    goto rulemultiset_typeEx;

                }
            }
            switch (alt207)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:658:10: member_key
        	    {
        	        this->followPush(FOLLOW_member_key_in_multiset_type5500);
        	        m_gPLSQLParser->member_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemultiset_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:659:10: submultiset_key
        	    {
        	        this->followPush(FOLLOW_submultiset_key_in_multiset_type5511);
        	        m_gPLSQLParser->submultiset_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemultiset_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulemultiset_typeEx; /* Prevent compiler warnings */
    rulemultiset_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multiset_type */

/**
 * $ANTLR start relational_expression
 * PLSQL_DMLParser.g:662:1: relational_expression : compound_expression ( ( EQUALS_OP | not_equal_op | LESS_THAN_OP | GREATER_THAN_OP | less_than_or_equals_op | greater_than_or_equals_op ) compound_expression )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::relational_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:663:5: ( compound_expression ( ( EQUALS_OP | not_equal_op | LESS_THAN_OP | GREATER_THAN_OP | less_than_or_equals_op | greater_than_or_equals_op ) compound_expression )* )
        // PLSQL_DMLParser.g:663:10: compound_expression ( ( EQUALS_OP | not_equal_op | LESS_THAN_OP | GREATER_THAN_OP | less_than_or_equals_op | greater_than_or_equals_op ) compound_expression )*
        {
            this->followPush(FOLLOW_compound_expression_in_relational_expression5531);
            compound_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerelational_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:664:5: ( ( EQUALS_OP | not_equal_op | LESS_THAN_OP | GREATER_THAN_OP | less_than_or_equals_op | greater_than_or_equals_op ) compound_expression )*

            for (;;)
            {
                int alt209=2;
                switch ( this->LA(1) )
                {
                case EQUALS_OP:
                	{
                		alt209=1;
                	}
                    break;
                case NOT_EQUAL_OP:
                	{
                		alt209=1;
                	}
                    break;
                case LESS_THAN_OP:
                	{
                		alt209=1;
                	}
                    break;
                case EXCLAMATION_OPERATOR_PART:
                	{
                		alt209=1;
                	}
                    break;
                case CARRET_OPERATOR_PART:
                	{
                		alt209=1;
                	}
                    break;
                case GREATER_THAN_OP:
                	{
                		alt209=1;
                	}
                    break;
                case LESS_THAN_OR_EQUALS_OP:
                	{
                		alt209=1;
                	}
                    break;
                case GREATER_THAN_OR_EQUALS_OP:
                	{
                		alt209=1;
                	}
                    break;

                }

                switch (alt209)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:664:7: ( EQUALS_OP | not_equal_op | LESS_THAN_OP | GREATER_THAN_OP | less_than_or_equals_op | greater_than_or_equals_op ) compound_expression
            	    {
            	        // PLSQL_DMLParser.g:664:7: ( EQUALS_OP | not_equal_op | LESS_THAN_OP | GREATER_THAN_OP | less_than_or_equals_op | greater_than_or_equals_op )
            	        {
            	            int alt208=6;
            	            switch ( this->LA(1) )
            	            {
            	            case EQUALS_OP:
            	            	{
            	            		alt208=1;
            	            	}
            	                break;
            	            case CARRET_OPERATOR_PART:
            	            case EXCLAMATION_OPERATOR_PART:
            	            case NOT_EQUAL_OP:
            	            	{
            	            		alt208=2;
            	            	}
            	                break;
            	            case LESS_THAN_OP:
            	            	{
            	            		switch ( this->LA(2) )
            	            		{
            	            		case GREATER_THAN_OP:
            	            			{
            	            				alt208=2;
            	            			}
            	            		    break;
            	            		case EQUALS_OP:
            	            			{
            	            				alt208=5;
            	            			}
            	            		    break;
            	            		case APPROXIMATE_NUM_LIT:
            	            		case BINDVAR:
            	            		case CHAR_STRING:
            	            		case CHAR_STRING_PERL:
            	            		case COLON:
            	            		case DELIMITED_ID:
            	            		case EXACT_NUM_LIT:
            	            		case INTRODUCER:
            	            		case LEFT_PAREN:
            	            		case MINUS_SIGN:
            	            		case NATIONAL_CHAR_STRING_LIT:
            	            		case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            	            		case PLUS_SIGN:
            	            		case REGULAR_ID:
            	            		case SQL92_RESERVED_ALL:
            	            		case SQL92_RESERVED_ANY:
            	            		case SQL92_RESERVED_CASE:
            	            		case SQL92_RESERVED_DATE:
            	            		case SQL92_RESERVED_DEFAULT:
            	            		case SQL92_RESERVED_DISTINCT:
            	            		case SQL92_RESERVED_EXISTS:
            	            		case SQL92_RESERVED_FALSE:
            	            		case SQL92_RESERVED_NULL:
            	            		case SQL92_RESERVED_PRIOR:
            	            		case SQL92_RESERVED_TRUE:
            	            		case UNSIGNED_INTEGER:
            	            			{
            	            				alt208=3;
            	            			}
            	            		    break;

            	            		default:
            	            		    if (this->get_backtracking()>0)
            	            		    {
            	            		        this->set_failedflag( true );
            	            		        return ;
            	            		    }

            	            		    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            		    ex->set_decisionNum( 208 );
            	            		    ex->set_state( 3 );


            	            		    goto rulerelational_expressionEx;

            	            		}

            	            	}
            	                break;
            	            case GREATER_THAN_OP:
            	            	{
            	            		{
            	            		    int LA208_4 = this->LA(2);
            	            		    if ( (LA208_4 == EQUALS_OP))
            	            		    {
            	            		        alt208=6;
            	            		    }
            	            		    else if ( (LA208_4 == APPROXIMATE_NUM_LIT || LA208_4 == BINDVAR || ((LA208_4 >= CHAR_STRING) && (LA208_4 <= COLON)) || LA208_4 == DELIMITED_ID || LA208_4 == EXACT_NUM_LIT || LA208_4 == INTRODUCER || LA208_4 == LEFT_PAREN || ((LA208_4 >= MINUS_SIGN) && (LA208_4 <= NATIONAL_CHAR_STRING_LIT)) || LA208_4 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA208_4 == PLUS_SIGN || LA208_4 == REGULAR_ID || LA208_4 == SQL92_RESERVED_ALL || LA208_4 == SQL92_RESERVED_ANY || LA208_4 == SQL92_RESERVED_CASE || LA208_4 == SQL92_RESERVED_DATE || LA208_4 == SQL92_RESERVED_DEFAULT || LA208_4 == SQL92_RESERVED_DISTINCT || ((LA208_4 >= SQL92_RESERVED_EXISTS) && (LA208_4 <= SQL92_RESERVED_FALSE)) || LA208_4 == SQL92_RESERVED_NULL || LA208_4 == SQL92_RESERVED_PRIOR || LA208_4 == SQL92_RESERVED_TRUE || LA208_4 == UNSIGNED_INTEGER))
            	            		    {
            	            		        alt208=4;
            	            		    }
            	            		    else
            	            		    {
            	            		        if (this->get_backtracking()>0)
            	            		        {
            	            		            this->set_failedflag( true );
            	            		            return ;
            	            		        }


            	            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            		        ex->set_decisionNum( 208 );
            	            		        ex->set_state( 4 );


            	            		        goto rulerelational_expressionEx;

            	            		    }
            	            		}
            	            	}
            	                break;
            	            case LESS_THAN_OR_EQUALS_OP:
            	            	{
            	            		alt208=5;
            	            	}
            	                break;
            	            case GREATER_THAN_OR_EQUALS_OP:
            	            	{
            	            		alt208=6;
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return ;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 208 );
            	                ex->set_state( 0 );


            	                goto rulerelational_expressionEx;

            	            }

            	            switch (alt208)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:664:9: EQUALS_OP
            	        	    {
            	        	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_relational_expression5541);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerelational_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:664:21: not_equal_op
            	        	    {
            	        	        this->followPush(FOLLOW_not_equal_op_in_relational_expression5545);
            	        	        m_gPLSQLParser->not_equal_op();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerelational_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // PLSQL_DMLParser.g:664:36: LESS_THAN_OP
            	        	    {
            	        	         this->matchToken(LESS_THAN_OP, &FOLLOW_LESS_THAN_OP_in_relational_expression5549);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerelational_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 4:
            	        	    // PLSQL_DMLParser.g:664:51: GREATER_THAN_OP
            	        	    {
            	        	         this->matchToken(GREATER_THAN_OP, &FOLLOW_GREATER_THAN_OP_in_relational_expression5553);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerelational_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 5:
            	        	    // PLSQL_DMLParser.g:664:69: less_than_or_equals_op
            	        	    {
            	        	        this->followPush(FOLLOW_less_than_or_equals_op_in_relational_expression5557);
            	        	        m_gPLSQLParser->less_than_or_equals_op();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerelational_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 6:
            	        	    // PLSQL_DMLParser.g:664:94: greater_than_or_equals_op
            	        	    {
            	        	        this->followPush(FOLLOW_greater_than_or_equals_op_in_relational_expression5561);
            	        	        m_gPLSQLParser->greater_than_or_equals_op();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerelational_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_compound_expression_in_relational_expression5565);
            	        compound_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerelational_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop209;	/* break out of the loop */
            	    break;
                }
            }
            loop209: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerelational_expressionEx; /* Prevent compiler warnings */
    rulerelational_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end relational_expression */

/**
 * $ANTLR start compound_expression
 * PLSQL_DMLParser.g:667:1: compound_expression : concatenation ( ( not_key )? ( in_key in_elements | between_key between_elements | like_type concatenation ( like_escape_part )? ) )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::compound_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:668:5: ( concatenation ( ( not_key )? ( in_key in_elements | between_key between_elements | like_type concatenation ( like_escape_part )? ) )? )
        // PLSQL_DMLParser.g:668:10: concatenation ( ( not_key )? ( in_key in_elements | between_key between_elements | like_type concatenation ( like_escape_part )? ) )?
        {
            this->followPush(FOLLOW_concatenation_in_compound_expression5587);
            concatenation();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecompound_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:669:5: ( ( not_key )? ( in_key in_elements | between_key between_elements | like_type concatenation ( like_escape_part )? ) )?
            {
                int alt213=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_NOT:
                    	{
                    		alt213=1;
                    	}
                        break;
                    case SQL92_RESERVED_IN:
                    	{
                    		alt213=1;
                    	}
                        break;
                    case SQL92_RESERVED_BETWEEN:
                    	{
                    		alt213=1;
                    	}
                        break;
                    case SQL92_RESERVED_LIKE:
                    	{
                    		alt213=1;
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA213_5 = this->LA(2);
                    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "LIKEC")))||((equalsIgnoreCase(LT(1)->getText(), "LIKE4")))||((equalsIgnoreCase(LT(1)->getText(), "LIKE2"))))))
                    		    {
                    		        alt213=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt213)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:669:10: ( not_key )? ( in_key in_elements | between_key between_elements | like_type concatenation ( like_escape_part )? )
            	    {
            	        // PLSQL_DMLParser.g:669:10: ( not_key )?
            	        {
            	            int alt210=2;
            	            {
            	                int LA210_0 = this->LA(1);
            	                if ( (LA210_0 == SQL92_RESERVED_NOT))
            	                {
            	                    alt210=1;
            	                }
            	            }
            	            switch (alt210)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:669:10: not_key
            	        	    {
            	        	        this->followPush(FOLLOW_not_key_in_compound_expression5598);
            	        	        m_gPLSQLParser->not_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQL_DMLParser.g:670:9: ( in_key in_elements | between_key between_elements | like_type concatenation ( like_escape_part )? )
            	        {
            	            int alt212=3;
            	            {
            	                int LA212_0 = this->LA(1);
            	                if ( (LA212_0 == SQL92_RESERVED_IN))
            	                {
            	                    alt212=1;
            	                }
            	                else if ( (LA212_0 == SQL92_RESERVED_BETWEEN))
            	                {
            	                    alt212=2;
            	                }
            	                else if ( (LA212_0 == SQL92_RESERVED_LIKE))
            	                {
            	                    alt212=3;
            	                }
            	                else if ( (LA212_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "LIKEC")))||((equalsIgnoreCase(LT(1)->getText(), "LIKE4")))||((equalsIgnoreCase(LT(1)->getText(), "LIKE2"))))))
            	                {
            	                    alt212=3;
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 212 );
            	                    ex->set_state( 0 );


            	                    goto rulecompound_expressionEx;

            	                }
            	            }
            	            switch (alt212)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:670:14: in_key in_elements
            	        	    {
            	        	        this->followPush(FOLLOW_in_key_in_compound_expression5614);
            	        	        m_gPLSQLParser->in_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_in_elements_in_compound_expression5616);
            	        	        in_elements();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:671:14: between_key between_elements
            	        	    {
            	        	        this->followPush(FOLLOW_between_key_in_compound_expression5631);
            	        	        m_gPLSQLParser->between_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_between_elements_in_compound_expression5633);
            	        	        between_elements();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // PLSQL_DMLParser.g:672:14: like_type concatenation ( like_escape_part )?
            	        	    {
            	        	        this->followPush(FOLLOW_like_type_in_compound_expression5648);
            	        	        like_type();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_concatenation_in_compound_expression5650);
            	        	        concatenation();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // PLSQL_DMLParser.g:672:38: ( like_escape_part )?
            	        	        {
            	        	            int alt211=2;
            	        	            {
            	        	                int LA211_0 = this->LA(1);
            	        	                if ( (LA211_0 == REGULAR_ID))
            	        	                {
            	        	                    {
            	        	                        int LA211_1 = this->LA(2);
            	        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "ESCAPE"))))
            	        	                        {
            	        	                            alt211=1;
            	        	                        }
            	        	                    }
            	        	                }
            	        	            }
            	        	            switch (alt211)
            	        	            {
            	        	        	case 1:
            	        	        	    // PLSQL_DMLParser.g:672:38: like_escape_part
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_like_escape_part_in_compound_expression5652);
            	        	        	        like_escape_part();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto rulecompound_expressionEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulecompound_expressionEx; /* Prevent compiler warnings */
    rulecompound_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end compound_expression */

/**
 * $ANTLR start like_type
 * PLSQL_DMLParser.g:677:1: like_type : ( like_key | likec_key | like2_key | like4_key );
 */
void
PLSQLParser_PLSQL_DMLParser::like_type()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:678:5: ( like_key | likec_key | like2_key | like4_key )

            ANTLR_UINT32 alt214;

            alt214=4;

            {
                int LA214_0 = this->LA(1);
                if ( (LA214_0 == SQL92_RESERVED_LIKE))
                {
                    alt214=1;
                }
                else if ( (LA214_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "LIKEC")))||((equalsIgnoreCase(LT(1)->getText(), "LIKE4")))||((equalsIgnoreCase(LT(1)->getText(), "LIKE2"))))))
                {
                    {
                        int LA214_2 = this->LA(2);
                        if ( ((equalsIgnoreCase(LT(1)->getText(), "LIKEC"))))
                        {
                            alt214=2;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "LIKE2"))))
                        {
                            alt214=3;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "LIKE4"))))
                        {
                            alt214=4;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 214 );
                            ex->set_state( 2 );


                            goto rulelike_typeEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 214 );
                    ex->set_state( 0 );


                    goto rulelike_typeEx;

                }
            }
            switch (alt214)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:678:10: like_key
        	    {
        	        this->followPush(FOLLOW_like_key_in_like_type5690);
        	        m_gPLSQLParser->like_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelike_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:679:10: likec_key
        	    {
        	        this->followPush(FOLLOW_likec_key_in_like_type5701);
        	        m_gPLSQLParser->likec_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelike_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:680:10: like2_key
        	    {
        	        this->followPush(FOLLOW_like2_key_in_like_type5712);
        	        m_gPLSQLParser->like2_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelike_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQL_DMLParser.g:681:10: like4_key
        	    {
        	        this->followPush(FOLLOW_like4_key_in_like_type5723);
        	        m_gPLSQLParser->like4_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelike_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulelike_typeEx; /* Prevent compiler warnings */
    rulelike_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end like_type */

/**
 * $ANTLR start like_escape_part
 * PLSQL_DMLParser.g:684:1: like_escape_part : escape_key concatenation ;
 */
void
PLSQLParser_PLSQL_DMLParser::like_escape_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:685:5: ( escape_key concatenation )
        // PLSQL_DMLParser.g:685:10: escape_key concatenation
        {
            this->followPush(FOLLOW_escape_key_in_like_escape_part5743);
            m_gPLSQLParser->escape_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelike_escape_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_concatenation_in_like_escape_part5745);
            concatenation();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelike_escape_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelike_escape_partEx; /* Prevent compiler warnings */
    rulelike_escape_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end like_escape_part */

/**
 * $ANTLR start in_elements
 * PLSQL_DMLParser.g:688:1: in_elements : ( ( ( LEFT_PAREN )+ ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN concatenation_wrapper ( COMMA concatenation_wrapper )* RIGHT_PAREN | constant | bind_variable | general_element );
 */
void
PLSQLParser_PLSQL_DMLParser::in_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:689:5: ( ( ( LEFT_PAREN )+ ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN concatenation_wrapper ( COMMA concatenation_wrapper )* RIGHT_PAREN | constant | bind_variable | general_element )

            ANTLR_UINT32 alt216;

            alt216=5;

            switch ( this->LA(1) )
            {
            case LEFT_PAREN:
            	{
            		{
            		    int LA216_1 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred26_PLSQL_DMLParser>() )))
            		    {
            		        alt216=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt216=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 216 );
            		        ex->set_state( 1 );


            		        goto rulein_elementsEx;

            		    }
            		}
            	}
                break;
            case REGULAR_ID:
            	{
            		{
            		    int LA216_2 = this->LA(2);
            		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||((equalsIgnoreCase(LT(1)->getText(), "MAXVALUE")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP")))||((equalsIgnoreCase(LT(1)->getText(), "MINVALUE")))||((equalsIgnoreCase(LT(1)->getText(), "SESSIONTIMEZONE")))||((equalsIgnoreCase(LT(1)->getText(), "DBTIMEZONE"))))))
            		    {
            		        alt216=3;
            		    }
            		    else if ( (true))
            		    {
            		        alt216=5;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 216 );
            		        ex->set_state( 2 );


            		        goto rulein_elementsEx;

            		    }
            		}
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case EXACT_NUM_LIT:
            case NATIONAL_CHAR_STRING_LIT:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt216=3;
            	}
                break;
            case BINDVAR:
            case COLON:
            	{
            		alt216=4;
            	}
                break;
            case DELIMITED_ID:
            case INTRODUCER:
            	{
            		alt216=5;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 216 );
                ex->set_state( 0 );


                goto rulein_elementsEx;

            }

            switch (alt216)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:689:10: ( ( LEFT_PAREN )+ ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN
        	    {
        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_in_elements5778);
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_subquery_in_in_elements5780);
        	        subquery();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_in_elements5782);
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:690:10: LEFT_PAREN concatenation_wrapper ( COMMA concatenation_wrapper )* RIGHT_PAREN
        	    {
        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_in_elements5793);
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_concatenation_wrapper_in_in_elements5795);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:690:43: ( COMMA concatenation_wrapper )*

        	        for (;;)
        	        {
        	            int alt215=2;
        	            {
        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                */
        	                int LA215_0 = this->LA(1);
        	                if ( (LA215_0 == COMMA))
        	                {
        	                    alt215=1;
        	                }

        	            }
        	            switch (alt215)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:690:44: COMMA concatenation_wrapper
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_in_elements5798);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulein_elementsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_in_elements5800);
        	        	        concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulein_elementsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop215;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop215: ; /* Jump out to here if this rule does not match */


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_in_elements5804);
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:691:10: constant
        	    {
        	        this->followPush(FOLLOW_constant_in_in_elements5815);
        	        m_gPLSQLParser->constant();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQL_DMLParser.g:692:10: bind_variable
        	    {
        	        this->followPush(FOLLOW_bind_variable_in_in_elements5826);
        	        m_gPLSQLParser->bind_variable();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQL_DMLParser.g:693:10: general_element
        	    {
        	        this->followPush(FOLLOW_general_element_in_in_elements5837);
        	        m_gPLSQLParser->general_element();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulein_elementsEx; /* Prevent compiler warnings */
    rulein_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end in_elements */

/**
 * $ANTLR start between_elements
 * PLSQL_DMLParser.g:696:1: between_elements : concatenation and_key concatenation ;
 */
void
PLSQLParser_PLSQL_DMLParser::between_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:697:5: ( concatenation and_key concatenation )
        // PLSQL_DMLParser.g:697:10: concatenation and_key concatenation
        {
            this->followPush(FOLLOW_concatenation_in_between_elements5857);
            concatenation();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebetween_elementsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_and_key_in_between_elements5859);
            m_gPLSQLParser->and_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebetween_elementsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_concatenation_in_between_elements5861);
            concatenation();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebetween_elementsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebetween_elementsEx; /* Prevent compiler warnings */
    rulebetween_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end between_elements */

/**
 * $ANTLR start concatenation
 * PLSQL_DMLParser.g:700:1: concatenation : additive_expression ( concatenation_op additive_expression )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::concatenation()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:701:5: ( additive_expression ( concatenation_op additive_expression )* )
        // PLSQL_DMLParser.g:701:10: additive_expression ( concatenation_op additive_expression )*
        {
            this->followPush(FOLLOW_additive_expression_in_concatenation5881);
            additive_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconcatenationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:701:30: ( concatenation_op additive_expression )*

            for (;;)
            {
                int alt217=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA217_0 = this->LA(1);
                    if ( (LA217_0 == CONCATENATION_OP))
                    {
                        alt217=1;
                    }
                    else if ( (LA217_0 == VERTICAL_BAR))
                    {
                        alt217=1;
                    }

                }
                switch (alt217)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:701:31: concatenation_op additive_expression
            	    {
            	        this->followPush(FOLLOW_concatenation_op_in_concatenation5884);
            	        m_gPLSQLParser->concatenation_op();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconcatenationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_additive_expression_in_concatenation5886);
            	        additive_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconcatenationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop217;	/* break out of the loop */
            	    break;
                }
            }
            loop217: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconcatenationEx; /* Prevent compiler warnings */
    ruleconcatenationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end concatenation */

/**
 * $ANTLR start concatenation_wrapper
 * PLSQL_DMLParser.g:704:1: concatenation_wrapper : concatenation ;
 */
void
PLSQLParser_PLSQL_DMLParser::concatenation_wrapper()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:705:5: ( concatenation )
        // PLSQL_DMLParser.g:705:10: concatenation
        {
            this->followPush(FOLLOW_concatenation_in_concatenation_wrapper5908);
            concatenation();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconcatenation_wrapperEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconcatenation_wrapperEx; /* Prevent compiler warnings */
    ruleconcatenation_wrapperEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end concatenation_wrapper */

/**
 * $ANTLR start additive_expression
 * PLSQL_DMLParser.g:708:1: additive_expression : multiply_expression ( ( PLUS_SIGN | MINUS_SIGN ) multiply_expression )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::additive_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:709:5: ( multiply_expression ( ( PLUS_SIGN | MINUS_SIGN ) multiply_expression )* )
        // PLSQL_DMLParser.g:709:10: multiply_expression ( ( PLUS_SIGN | MINUS_SIGN ) multiply_expression )*
        {
            this->followPush(FOLLOW_multiply_expression_in_additive_expression5928);
            multiply_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleadditive_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:709:30: ( ( PLUS_SIGN | MINUS_SIGN ) multiply_expression )*

            for (;;)
            {
                int alt218=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA218_0 = this->LA(1);
                    if ( (LA218_0 == MINUS_SIGN || LA218_0 == PLUS_SIGN))
                    {
                        alt218=1;
                    }

                }
                switch (alt218)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:709:32: ( PLUS_SIGN | MINUS_SIGN ) multiply_expression
            	    {
            	        if ( this->LA(1) == MINUS_SIGN || this->LA(1) == PLUS_SIGN )
            	        {
            	            this->consume();
            	            this->set_perror_recovery(false);
            	             this->set_failedflag(false); 

            	        }
            	        else
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return ;
            	            }

            	            new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            this->get_exception()->set_expectingSet(NULL);

            	            goto ruleadditive_expressionEx;
            	        }


            	        this->followPush(FOLLOW_multiply_expression_in_additive_expression5942);
            	        multiply_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleadditive_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop218;	/* break out of the loop */
            	    break;
                }
            }
            loop218: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleadditive_expressionEx; /* Prevent compiler warnings */
    ruleadditive_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end additive_expression */

/**
 * $ANTLR start multiply_expression
 * PLSQL_DMLParser.g:712:1: multiply_expression : datetime_expression ( ( ASTERISK | SOLIDUS ) datetime_expression )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::multiply_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:713:5: ( datetime_expression ( ( ASTERISK | SOLIDUS ) datetime_expression )* )
        // PLSQL_DMLParser.g:713:10: datetime_expression ( ( ASTERISK | SOLIDUS ) datetime_expression )*
        {
            this->followPush(FOLLOW_datetime_expression_in_multiply_expression5964);
            datetime_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemultiply_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:713:30: ( ( ASTERISK | SOLIDUS ) datetime_expression )*

            for (;;)
            {
                int alt219=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA219_0 = this->LA(1);
                    if ( (LA219_0 == SOLIDUS))
                    {
                        alt219=1;
                    }
                    else if ( (LA219_0 == ASTERISK))
                    {
                        alt219=1;
                    }

                }
                switch (alt219)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:713:32: ( ASTERISK | SOLIDUS ) datetime_expression
            	    {
            	        if ( this->LA(1) == ASTERISK || this->LA(1) == SOLIDUS )
            	        {
            	            this->consume();
            	            this->set_perror_recovery(false);
            	             this->set_failedflag(false); 

            	        }
            	        else
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return ;
            	            }

            	            new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            this->get_exception()->set_expectingSet(NULL);

            	            goto rulemultiply_expressionEx;
            	        }


            	        this->followPush(FOLLOW_datetime_expression_in_multiply_expression5978);
            	        datetime_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiply_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop219;	/* break out of the loop */
            	    break;
                }
            }
            loop219: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemultiply_expressionEx; /* Prevent compiler warnings */
    rulemultiply_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multiply_expression */

/**
 * $ANTLR start datetime_expression
 * PLSQL_DMLParser.g:716:1: datetime_expression : model_expression ( at_key ( local_key | time_key zone_key concatenation_wrapper ) | ( interval_expression )=> interval_expression )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::datetime_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:717:5: ( model_expression ( at_key ( local_key | time_key zone_key concatenation_wrapper ) | ( interval_expression )=> interval_expression )? )
        // PLSQL_DMLParser.g:717:10: model_expression ( at_key ( local_key | time_key zone_key concatenation_wrapper ) | ( interval_expression )=> interval_expression )?
        {
            this->followPush(FOLLOW_model_expression_in_datetime_expression6000);
            model_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledatetime_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:718:5: ( at_key ( local_key | time_key zone_key concatenation_wrapper ) | ( interval_expression )=> interval_expression )?
            {
                int alt221=3;
                {
                    int LA221_0 = this->LA(1);
                    if ( (LA221_0 == REGULAR_ID))
                    {
                        {
                            int LA221_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "AT"))))
                            {
                                alt221=1;
                            }
                            else if ( (( (this->msynpred( antlr3::ClassForwarder<synpred27_PLSQL_DMLParser>() )) && ((((equalsIgnoreCase(LT(1)->getText(), "DAY")))||((equalsIgnoreCase(LT(1)->getText(), "YEAR"))))) )))
                            {
                                alt221=2;
                            }
                        }
                    }
                }
                switch (alt221)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:718:10: at_key ( local_key | time_key zone_key concatenation_wrapper )
            	    {
            	        this->followPush(FOLLOW_at_key_in_datetime_expression6011);
            	        m_gPLSQLParser->at_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledatetime_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:718:17: ( local_key | time_key zone_key concatenation_wrapper )
            	        {
            	            int alt220=2;
            	            {
            	                int LA220_0 = this->LA(1);
            	                if ( (LA220_0 == REGULAR_ID))
            	                {
            	                    {
            	                        int LA220_1 = this->LA(2);
            	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "LOCAL"))))
            	                        {
            	                            alt220=1;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIME"))))
            	                        {
            	                            alt220=2;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 220 );
            	                            ex->set_state( 1 );


            	                            goto ruledatetime_expressionEx;

            	                        }
            	                    }
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 220 );
            	                    ex->set_state( 0 );


            	                    goto ruledatetime_expressionEx;

            	                }
            	            }
            	            switch (alt220)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:718:18: local_key
            	        	    {
            	        	        this->followPush(FOLLOW_local_key_in_datetime_expression6014);
            	        	        m_gPLSQLParser->local_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruledatetime_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:718:28: time_key zone_key concatenation_wrapper
            	        	    {
            	        	        this->followPush(FOLLOW_time_key_in_datetime_expression6016);
            	        	        m_gPLSQLParser->time_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruledatetime_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_zone_key_in_datetime_expression6018);
            	        	        m_gPLSQLParser->zone_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruledatetime_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_concatenation_wrapper_in_datetime_expression6020);
            	        	        concatenation_wrapper();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruledatetime_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:719:10: ( interval_expression )=> interval_expression
            	    {
            	        this->followPush(FOLLOW_interval_expression_in_datetime_expression6037);
            	        interval_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledatetime_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruledatetime_expressionEx; /* Prevent compiler warnings */
    ruledatetime_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end datetime_expression */

/**
 * $ANTLR start interval_expression
 * PLSQL_DMLParser.g:723:1: interval_expression : ( day_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? to_key second_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? | year_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? to_key month_key );
 */
void
PLSQLParser_PLSQL_DMLParser::interval_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:724:5: ( day_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? to_key second_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? | year_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? to_key month_key )

            ANTLR_UINT32 alt225;

            alt225=2;

            {
                int LA225_0 = this->LA(1);
                if ( (LA225_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "DAY")))||((equalsIgnoreCase(LT(1)->getText(), "YEAR"))))))
                {
                    {
                        int LA225_1 = this->LA(2);
                        if ( ((equalsIgnoreCase(LT(1)->getText(), "DAY"))))
                        {
                            alt225=1;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "YEAR"))))
                        {
                            alt225=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 225 );
                            ex->set_state( 1 );


                            goto ruleinterval_expressionEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 225 );
                    ex->set_state( 0 );


                    goto ruleinterval_expressionEx;

                }
            }
            switch (alt225)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:724:10: day_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? to_key second_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )?
        	    {
        	        this->followPush(FOLLOW_day_key_in_interval_expression6064);
        	        m_gPLSQLParser->day_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinterval_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:724:21: ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )?
        	        {
        	            int alt222=2;
        	            {
        	                int LA222_0 = this->LA(1);
        	                if ( (LA222_0 == LEFT_PAREN))
        	                {
        	                    alt222=1;
        	                }
        	            }
        	            switch (alt222)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:724:22: LEFT_PAREN concatenation_wrapper RIGHT_PAREN
        	        	    {
        	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_interval_expression6070);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_interval_expression6072);
        	        	        concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_interval_expression6074);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_to_key_in_interval_expression6078);
        	        m_gPLSQLParser->to_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinterval_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_second_key_in_interval_expression6080);
        	        m_gPLSQLParser->second_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinterval_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:724:87: ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )?
        	        {
        	            int alt223=2;
        	            alt223 = cdfa223.predict(this, this->get_rec(), this->get_istream(), cdfa223 );
        	            if  (this->hasException())
        	            {
        	                goto ruleinterval_expressionEx;
        	            }
        	            if (this->hasFailed())
        	            {
        	                return ;
        	            }

        	            switch (alt223)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:724:88: LEFT_PAREN concatenation_wrapper RIGHT_PAREN
        	        	    {
        	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_interval_expression6083);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_interval_expression6085);
        	        	        concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_interval_expression6087);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:725:10: year_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? to_key month_key
        	    {
        	        this->followPush(FOLLOW_year_key_in_interval_expression6100);
        	        m_gPLSQLParser->year_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinterval_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:725:19: ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )?
        	        {
        	            int alt224=2;
        	            {
        	                int LA224_0 = this->LA(1);
        	                if ( (LA224_0 == LEFT_PAREN))
        	                {
        	                    alt224=1;
        	                }
        	            }
        	            switch (alt224)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:725:20: LEFT_PAREN concatenation_wrapper RIGHT_PAREN
        	        	    {
        	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_interval_expression6103);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_interval_expression6105);
        	        	        concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_interval_expression6107);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_to_key_in_interval_expression6111);
        	        m_gPLSQLParser->to_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinterval_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_month_key_in_interval_expression6113);
        	        m_gPLSQLParser->month_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinterval_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleinterval_expressionEx; /* Prevent compiler warnings */
    ruleinterval_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end interval_expression */

/**
 * $ANTLR start model_expression
 * PLSQL_DMLParser.g:728:1: model_expression : multiset_expression ( LEFT_BRACKET model_expression_element RIGHT_BRACKET )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:729:5: ( multiset_expression ( LEFT_BRACKET model_expression_element RIGHT_BRACKET )? )
        // PLSQL_DMLParser.g:729:10: multiset_expression ( LEFT_BRACKET model_expression_element RIGHT_BRACKET )?
        {
            this->followPush(FOLLOW_multiset_expression_in_model_expression6133);
            multiset_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:730:9: ( LEFT_BRACKET model_expression_element RIGHT_BRACKET )?
            {
                int alt226=2;
                {
                    int LA226_0 = this->LA(1);
                    if ( (LA226_0 == LEFT_BRACKET))
                    {
                        alt226=1;
                    }
                }
                switch (alt226)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:730:10: LEFT_BRACKET model_expression_element RIGHT_BRACKET
            	    {
            	         this->matchToken(LEFT_BRACKET, &FOLLOW_LEFT_BRACKET_in_model_expression6144);
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_model_expression_element_in_model_expression6146);
            	        model_expression_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_BRACKET, &FOLLOW_RIGHT_BRACKET_in_model_expression6148);
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_expressionEx; /* Prevent compiler warnings */
    rulemodel_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_expression */

/**
 * $ANTLR start model_expression_element
 * PLSQL_DMLParser.g:733:1: model_expression_element : ( ( ( any_key )=> any_key | condition_wrapper ) ( COMMA ( ( any_key )=> any_key | condition_wrapper ) )* | single_column_for_loop ( COMMA single_column_for_loop )* | multi_column_for_loop );
 */
void
PLSQLParser_PLSQL_DMLParser::model_expression_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:734:5: ( ( ( any_key )=> any_key | condition_wrapper ) ( COMMA ( ( any_key )=> any_key | condition_wrapper ) )* | single_column_for_loop ( COMMA single_column_for_loop )* | multi_column_for_loop )

            ANTLR_UINT32 alt231;

            alt231=3;

            {
                int LA231_0 = this->LA(1);
                if ( (LA231_0 == APPROXIMATE_NUM_LIT || LA231_0 == BINDVAR || ((LA231_0 >= CHAR_STRING) && (LA231_0 <= COLON)) || LA231_0 == DELIMITED_ID || LA231_0 == EXACT_NUM_LIT || LA231_0 == INTRODUCER || LA231_0 == LEFT_PAREN || ((LA231_0 >= MINUS_SIGN) && (LA231_0 <= NATIONAL_CHAR_STRING_LIT)) || LA231_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA231_0 == PLUS_SIGN || LA231_0 == REGULAR_ID || LA231_0 == SQL92_RESERVED_ALL || LA231_0 == SQL92_RESERVED_ANY || LA231_0 == SQL92_RESERVED_CASE || ((LA231_0 >= SQL92_RESERVED_CURSOR) && (LA231_0 <= SQL92_RESERVED_DATE)) || LA231_0 == SQL92_RESERVED_DEFAULT || LA231_0 == SQL92_RESERVED_DISTINCT || ((LA231_0 >= SQL92_RESERVED_EXISTS) && (LA231_0 <= SQL92_RESERVED_FALSE)) || ((LA231_0 >= SQL92_RESERVED_NOT) && (LA231_0 <= SQL92_RESERVED_NULL)) || LA231_0 == SQL92_RESERVED_PRIOR || LA231_0 == SQL92_RESERVED_TRUE || LA231_0 == UNSIGNED_INTEGER))
                {
                    alt231=1;
                }
                else if ( (LA231_0 == SQL92_RESERVED_FOR))
                {
                    {
                        int LA231_2 = this->LA(2);
                        if ( (LA231_2 == DELIMITED_ID || LA231_2 == INTRODUCER || LA231_2 == REGULAR_ID))
                        {
                            alt231=2;
                        }
                        else if ( (LA231_2 == LEFT_PAREN))
                        {
                            alt231=3;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 231 );
                            ex->set_state( 2 );


                            goto rulemodel_expression_elementEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 231 );
                    ex->set_state( 0 );


                    goto rulemodel_expression_elementEx;

                }
            }
            switch (alt231)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:734:10: ( ( any_key )=> any_key | condition_wrapper ) ( COMMA ( ( any_key )=> any_key | condition_wrapper ) )*
        	    {
        	        // PLSQL_DMLParser.g:734:10: ( ( any_key )=> any_key | condition_wrapper )
        	        {
        	            int alt227=2;
        	            {
        	                int LA227_0 = this->LA(1);
        	                if ( (LA227_0 == SQL92_RESERVED_ANY))
        	                {
        	                    {
        	                        int LA227_1 = this->LA(2);
        	                        if ( (LA227_1 == COMMA) && (this->msynpred( antlr3::ClassForwarder<synpred28_PLSQL_DMLParser>() )))
        	                        {
        	                            alt227=1;
        	                        }
        	                        else if ( (LA227_1 == RIGHT_BRACKET) && (this->msynpred( antlr3::ClassForwarder<synpred28_PLSQL_DMLParser>() )))
        	                        {
        	                            alt227=1;
        	                        }
        	                        else if ( (LA227_1 == LEFT_PAREN))
        	                        {
        	                            alt227=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 227 );
        	                            ex->set_state( 1 );


        	                            goto rulemodel_expression_elementEx;

        	                        }
        	                    }
        	                }
        	                else if ( (LA227_0 == APPROXIMATE_NUM_LIT || LA227_0 == BINDVAR || ((LA227_0 >= CHAR_STRING) && (LA227_0 <= COLON)) || LA227_0 == DELIMITED_ID || LA227_0 == EXACT_NUM_LIT || LA227_0 == INTRODUCER || LA227_0 == LEFT_PAREN || ((LA227_0 >= MINUS_SIGN) && (LA227_0 <= NATIONAL_CHAR_STRING_LIT)) || LA227_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA227_0 == PLUS_SIGN || LA227_0 == REGULAR_ID || LA227_0 == SQL92_RESERVED_ALL || LA227_0 == SQL92_RESERVED_CASE || ((LA227_0 >= SQL92_RESERVED_CURSOR) && (LA227_0 <= SQL92_RESERVED_DATE)) || LA227_0 == SQL92_RESERVED_DEFAULT || LA227_0 == SQL92_RESERVED_DISTINCT || ((LA227_0 >= SQL92_RESERVED_EXISTS) && (LA227_0 <= SQL92_RESERVED_FALSE)) || ((LA227_0 >= SQL92_RESERVED_NOT) && (LA227_0 <= SQL92_RESERVED_NULL)) || LA227_0 == SQL92_RESERVED_PRIOR || LA227_0 == SQL92_RESERVED_TRUE || LA227_0 == UNSIGNED_INTEGER))
        	                {
        	                    alt227=2;
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 227 );
        	                    ex->set_state( 0 );


        	                    goto rulemodel_expression_elementEx;

        	                }
        	            }
        	            switch (alt227)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:734:11: ( any_key )=> any_key
        	        	    {
        	        	        this->followPush(FOLLOW_any_key_in_model_expression_element6176);
        	        	        m_gPLSQLParser->any_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemodel_expression_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:734:31: condition_wrapper
        	        	    {
        	        	        this->followPush(FOLLOW_condition_wrapper_in_model_expression_element6178);
        	        	        condition_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemodel_expression_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:734:50: ( COMMA ( ( any_key )=> any_key | condition_wrapper ) )*

        	        for (;;)
        	        {
        	            int alt229=2;
        	            {
        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                */
        	                int LA229_0 = this->LA(1);
        	                if ( (LA229_0 == COMMA))
        	                {
        	                    alt229=1;
        	                }

        	            }
        	            switch (alt229)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:734:51: COMMA ( ( any_key )=> any_key | condition_wrapper )
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_model_expression_element6182);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemodel_expression_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQL_DMLParser.g:734:57: ( ( any_key )=> any_key | condition_wrapper )
        	        	        {
        	        	            int alt228=2;
        	        	            {
        	        	                int LA228_0 = this->LA(1);
        	        	                if ( (LA228_0 == SQL92_RESERVED_ANY))
        	        	                {
        	        	                    {
        	        	                        int LA228_1 = this->LA(2);
        	        	                        if ( (LA228_1 == RIGHT_BRACKET) && (this->msynpred( antlr3::ClassForwarder<synpred29_PLSQL_DMLParser>() )))
        	        	                        {
        	        	                            alt228=1;
        	        	                        }
        	        	                        else if ( (LA228_1 == COMMA) && (this->msynpred( antlr3::ClassForwarder<synpred29_PLSQL_DMLParser>() )))
        	        	                        {
        	        	                            alt228=1;
        	        	                        }
        	        	                        else if ( (LA228_1 == LEFT_PAREN))
        	        	                        {
        	        	                            alt228=2;
        	        	                        }
        	        	                        else
        	        	                        {
        	        	                            if (this->get_backtracking()>0)
        	        	                            {
        	        	                                this->set_failedflag( true );
        	        	                                return ;
        	        	                            }


        	        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                            ex->set_decisionNum( 228 );
        	        	                            ex->set_state( 1 );


        	        	                            goto rulemodel_expression_elementEx;

        	        	                        }
        	        	                    }
        	        	                }
        	        	                else if ( (LA228_0 == APPROXIMATE_NUM_LIT || LA228_0 == BINDVAR || ((LA228_0 >= CHAR_STRING) && (LA228_0 <= COLON)) || LA228_0 == DELIMITED_ID || LA228_0 == EXACT_NUM_LIT || LA228_0 == INTRODUCER || LA228_0 == LEFT_PAREN || ((LA228_0 >= MINUS_SIGN) && (LA228_0 <= NATIONAL_CHAR_STRING_LIT)) || LA228_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA228_0 == PLUS_SIGN || LA228_0 == REGULAR_ID || LA228_0 == SQL92_RESERVED_ALL || LA228_0 == SQL92_RESERVED_CASE || ((LA228_0 >= SQL92_RESERVED_CURSOR) && (LA228_0 <= SQL92_RESERVED_DATE)) || LA228_0 == SQL92_RESERVED_DEFAULT || LA228_0 == SQL92_RESERVED_DISTINCT || ((LA228_0 >= SQL92_RESERVED_EXISTS) && (LA228_0 <= SQL92_RESERVED_FALSE)) || ((LA228_0 >= SQL92_RESERVED_NOT) && (LA228_0 <= SQL92_RESERVED_NULL)) || LA228_0 == SQL92_RESERVED_PRIOR || LA228_0 == SQL92_RESERVED_TRUE || LA228_0 == UNSIGNED_INTEGER))
        	        	                {
        	        	                    alt228=2;
        	        	                }
        	        	                else
        	        	                {
        	        	                    if (this->get_backtracking()>0)
        	        	                    {
        	        	                        this->set_failedflag( true );
        	        	                        return ;
        	        	                    }


        	        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                    ex->set_decisionNum( 228 );
        	        	                    ex->set_state( 0 );


        	        	                    goto rulemodel_expression_elementEx;

        	        	                }
        	        	            }
        	        	            switch (alt228)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:734:58: ( any_key )=> any_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_any_key_in_model_expression_element6190);
        	        	        	        m_gPLSQLParser->any_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulemodel_expression_elementEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // PLSQL_DMLParser.g:734:78: condition_wrapper
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_condition_wrapper_in_model_expression_element6192);
        	        	        	        condition_wrapper();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulemodel_expression_elementEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop229;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop229: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:735:10: single_column_for_loop ( COMMA single_column_for_loop )*
        	    {
        	        this->followPush(FOLLOW_single_column_for_loop_in_model_expression_element6206);
        	        single_column_for_loop();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemodel_expression_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:735:33: ( COMMA single_column_for_loop )*

        	        for (;;)
        	        {
        	            int alt230=2;
        	            {
        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                */
        	                int LA230_0 = this->LA(1);
        	                if ( (LA230_0 == COMMA))
        	                {
        	                    alt230=1;
        	                }

        	            }
        	            switch (alt230)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:735:34: COMMA single_column_for_loop
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_model_expression_element6209);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemodel_expression_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_single_column_for_loop_in_model_expression_element6211);
        	        	        single_column_for_loop();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemodel_expression_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop230;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop230: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:736:10: multi_column_for_loop
        	    {
        	        this->followPush(FOLLOW_multi_column_for_loop_in_model_expression_element6224);
        	        multi_column_for_loop();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemodel_expression_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulemodel_expression_elementEx; /* Prevent compiler warnings */
    rulemodel_expression_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_expression_element */

/**
 * $ANTLR start single_column_for_loop
 * PLSQL_DMLParser.g:739:1: single_column_for_loop : for_key column_name ( in_key expression_list | ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::single_column_for_loop()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:740:5: ( for_key column_name ( in_key expression_list | ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression ) )
        // PLSQL_DMLParser.g:740:10: for_key column_name ( in_key expression_list | ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression )
        {
            this->followPush(FOLLOW_for_key_in_single_column_for_loop6244);
            m_gPLSQLParser->for_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesingle_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_single_column_for_loop6246);
            m_gPLSQLParser->column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesingle_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:741:5: ( in_key expression_list | ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression )
            {
                int alt233=2;
                {
                    int LA233_0 = this->LA(1);
                    if ( (LA233_0 == SQL92_RESERVED_IN))
                    {
                        alt233=1;
                    }
                    else if ( (LA233_0 == SQL92_RESERVED_FROM || LA233_0 == SQL92_RESERVED_LIKE))
                    {
                        alt233=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 233 );
                        ex->set_state( 0 );


                        goto rulesingle_column_for_loopEx;

                    }
                }
                switch (alt233)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:741:10: in_key expression_list
            	    {
            	        this->followPush(FOLLOW_in_key_in_single_column_for_loop6258);
            	        m_gPLSQLParser->in_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_list_in_single_column_for_loop6260);
            	        expression_list();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:742:10: ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression
            	    {
            	        // PLSQL_DMLParser.g:742:10: ( for_like_part )?
            	        {
            	            int alt232=2;
            	            {
            	                int LA232_0 = this->LA(1);
            	                if ( (LA232_0 == SQL92_RESERVED_LIKE))
            	                {
            	                    alt232=1;
            	                }
            	            }
            	            switch (alt232)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:742:10: for_like_part
            	        	    {
            	        	        this->followPush(FOLLOW_for_like_part_in_single_column_for_loop6271);
            	        	        for_like_part();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesingle_column_for_loopEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_from_key_in_single_column_for_loop6274);
            	        m_gPLSQLParser->from_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_single_column_for_loop6278);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_to_key_in_single_column_for_loop6292);
            	        m_gPLSQLParser->to_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_single_column_for_loop6296);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_for_increment_decrement_type_in_single_column_for_loop6298);
            	        for_increment_decrement_type();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_single_column_for_loop6302);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesingle_column_for_loopEx; /* Prevent compiler warnings */
    rulesingle_column_for_loopEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end single_column_for_loop */

/**
 * $ANTLR start for_like_part
 * PLSQL_DMLParser.g:747:1: for_like_part : like_key expression ;
 */
void
PLSQLParser_PLSQL_DMLParser::for_like_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:748:5: ( like_key expression )
        // PLSQL_DMLParser.g:748:10: like_key expression
        {
            this->followPush(FOLLOW_like_key_in_for_like_part6333);
            m_gPLSQLParser->like_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_like_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_for_like_part6335);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_like_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefor_like_partEx; /* Prevent compiler warnings */
    rulefor_like_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end for_like_part */

/**
 * $ANTLR start for_increment_decrement_type
 * PLSQL_DMLParser.g:751:1: for_increment_decrement_type : ( increment_key | decrement_key );
 */
void
PLSQLParser_PLSQL_DMLParser::for_increment_decrement_type()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:752:5: ( increment_key | decrement_key )

            ANTLR_UINT32 alt234;

            alt234=2;

            {
                int LA234_0 = this->LA(1);
                if ( (LA234_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "DECREMENT")))||((equalsIgnoreCase(LT(1)->getText(), "INCREMENT"))))))
                {
                    {
                        int LA234_1 = this->LA(2);
                        if ( ((equalsIgnoreCase(LT(1)->getText(), "INCREMENT"))))
                        {
                            alt234=1;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "DECREMENT"))))
                        {
                            alt234=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 234 );
                            ex->set_state( 1 );


                            goto rulefor_increment_decrement_typeEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 234 );
                    ex->set_state( 0 );


                    goto rulefor_increment_decrement_typeEx;

                }
            }
            switch (alt234)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:752:10: increment_key
        	    {
        	        this->followPush(FOLLOW_increment_key_in_for_increment_decrement_type6355);
        	        m_gPLSQLParser->increment_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_increment_decrement_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:753:10: decrement_key
        	    {
        	        this->followPush(FOLLOW_decrement_key_in_for_increment_decrement_type6366);
        	        m_gPLSQLParser->decrement_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_increment_decrement_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulefor_increment_decrement_typeEx; /* Prevent compiler warnings */
    rulefor_increment_decrement_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end for_increment_decrement_type */

/**
 * $ANTLR start multi_column_for_loop
 * PLSQL_DMLParser.g:756:1: multi_column_for_loop : for_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN in_key LEFT_PAREN ( ( select_key )=> subquery | ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN ) RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::multi_column_for_loop()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:757:5: ( for_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN in_key LEFT_PAREN ( ( select_key )=> subquery | ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN ) RIGHT_PAREN )
        // PLSQL_DMLParser.g:757:10: for_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN in_key LEFT_PAREN ( ( select_key )=> subquery | ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN ) RIGHT_PAREN
        {
            this->followPush(FOLLOW_for_key_in_multi_column_for_loop6386);
            m_gPLSQLParser->for_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_multi_column_for_loop6388);
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_multi_column_for_loop6390);
            m_gPLSQLParser->column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:757:41: ( COMMA column_name )*

            for (;;)
            {
                int alt235=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA235_0 = this->LA(1);
                    if ( (LA235_0 == COMMA))
                    {
                        alt235=1;
                    }

                }
                switch (alt235)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:757:42: COMMA column_name
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_multi_column_for_loop6393);
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_multi_column_for_loop6395);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop235;	/* break out of the loop */
            	    break;
                }
            }
            loop235: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6399);
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_in_key_in_multi_column_for_loop6401);
            m_gPLSQLParser->in_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_multi_column_for_loop6411);
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:759:13: ( ( select_key )=> subquery | ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN )
            {
                int alt237=2;
                {
                    int LA237_0 = this->LA(1);
                    if ( (LA237_0 == SQL92_RESERVED_SELECT) && (this->msynpred( antlr3::ClassForwarder<synpred30_PLSQL_DMLParser>() )))
                    {
                        alt237=1;
                    }
                    else if ( (LA237_0 == LEFT_PAREN))
                    {
                        {
                            int LA237_2 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred30_PLSQL_DMLParser>() )))
                            {
                                alt237=1;
                            }
                            else if ( (this->msynpred( antlr3::ClassForwarder<synpred31_PLSQL_DMLParser>() )))
                            {
                                alt237=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 237 );
                                ex->set_state( 2 );


                                goto rulemulti_column_for_loopEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 237 );
                        ex->set_state( 0 );


                        goto rulemulti_column_for_loopEx;

                    }
                }
                switch (alt237)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:759:18: ( select_key )=> subquery
            	    {
            	        this->followPush(FOLLOW_subquery_in_multi_column_for_loop6435);
            	        subquery();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:760:18: ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_multi_column_for_loop6459);
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_list_in_multi_column_for_loop6461);
            	        expression_list();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:760:60: ( COMMA expression_list )*

            	        for (;;)
            	        {
            	            int alt236=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA236_0 = this->LA(1);
            	                if ( (LA236_0 == COMMA))
            	                {
            	                    alt236=1;
            	                }

            	            }
            	            switch (alt236)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:760:61: COMMA expression_list
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_multi_column_for_loop6464);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemulti_column_for_loopEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_expression_list_in_multi_column_for_loop6466);
            	        	        expression_list();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemulti_column_for_loopEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop236;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop236: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6470);
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6494);
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemulti_column_for_loopEx; /* Prevent compiler warnings */
    rulemulti_column_for_loopEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multi_column_for_loop */

/**
 * $ANTLR start multiset_expression
 * PLSQL_DMLParser.g:765:1: multiset_expression : unary_expression ( multiset_op unary_expression )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::multiset_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:766:2: ( unary_expression ( multiset_op unary_expression )* )
        // PLSQL_DMLParser.g:766:4: unary_expression ( multiset_op unary_expression )*
        {
            this->followPush(FOLLOW_unary_expression_in_multiset_expression6508);
            unary_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemultiset_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:767:3: ( multiset_op unary_expression )*

            for (;;)
            {
                int alt238=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA238_0 = this->LA(1);
                    if ( (LA238_0 == REGULAR_ID))
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA238_2 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "MULTISET"))))
                            {
                                alt238=1;
                            }

                        }
                    }

                }
                switch (alt238)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:767:5: multiset_op unary_expression
            	    {
            	        this->followPush(FOLLOW_multiset_op_in_multiset_expression6514);
            	        m_gPLSQLParser->multiset_op();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_unary_expression_in_multiset_expression6516);
            	        unary_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop238;	/* break out of the loop */
            	    break;
                }
            }
            loop238: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemultiset_expressionEx; /* Prevent compiler warnings */
    rulemultiset_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multiset_expression */

/**
 * $ANTLR start unary_expression
 * PLSQL_DMLParser.g:770:1: unary_expression options {backtrack=true; } : ( MINUS_SIGN unary_expression | PLUS_SIGN unary_expression | prior_key unary_expression | connect_by_root_key unary_expression |{...}? => new_key unary_expression | distinct_key unary_expression | all_key unary_expression |{...}? case_statement[false] | quantified_expression | standard_function | atom );
 */
void
PLSQLParser_PLSQL_DMLParser::unary_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:775:5: ( MINUS_SIGN unary_expression | PLUS_SIGN unary_expression | prior_key unary_expression | connect_by_root_key unary_expression |{...}? => new_key unary_expression | distinct_key unary_expression | all_key unary_expression |{...}? case_statement[false] | quantified_expression | standard_function | atom )

            ANTLR_UINT32 alt239;

            alt239=11;

            switch ( this->LA(1) )
            {
            case MINUS_SIGN:
            	{
            		alt239=1;
            	}
                break;
            case PLUS_SIGN:
            	{
            		alt239=2;
            	}
                break;
            case SQL92_RESERVED_PRIOR:
            	{
            		alt239=3;
            	}
                break;
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            	{
            		alt239=4;
            	}
                break;
            case REGULAR_ID:
            	{
            		{
            		    int LA239_5 = this->LA(2);
            		    if ( (( (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (this->msynpred( antlr3::ClassForwarder<synpred36_PLSQL_DMLParser>() )) )) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )))
            		    {
            		        alt239=5;
            		    }
            		    else if ( (( (( LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE )) && (this->msynpred( antlr3::ClassForwarder<synpred39_PLSQL_DMLParser>() )) )))
            		    {
            		        alt239=8;
            		    }
            		    else if ( (( (this->msynpred( antlr3::ClassForwarder<synpred40_PLSQL_DMLParser>() )) && ((equalsIgnoreCase(LT(1)->getText(), "SOME"))) )))
            		    {
            		        alt239=9;
            		    }
            		    else if ( (( ((((equalsIgnoreCase(LT(1)->getText(), "COUNT")))||((equalsIgnoreCase(LT(1)->getText(), "XMLROOT")))||((equalsIgnoreCase(LT(1)->getText(), "LAST_VALUE")))||((equalsIgnoreCase(LT(1)->getText(), "XMLPI")))||((enablesWithinOrOverClause(LT(1)->getText())))||((equalsIgnoreCase(LT(1)->getText(), "XMLSERIALIZE")))||((equalsIgnoreCase(LT(1)->getText(), "XMLCAST")))||((isStandardPredictionFunction(LT(1)->getText())))||((equalsIgnoreCase(LT(1)->getText(), "DECOMPOSE")))||((equalsIgnoreCase(LT(1)->getText(), "COLLECT")))||((equalsIgnoreCase(LT(1)->getText(), "XMLELEMENT")))||((equalsIgnoreCase(LT(1)->getText(), "XMLTABLE")))||((equalsIgnoreCase(LT(1)->getText(), "XMLEXISTS")))||((enablesOverClause(LT(1)->getText())))||((enablesUsingClause(LT(1)->getText())))||((equalsIgnoreCase(LT(1)->getText(), "FIRST_VALUE")))||((equalsIgnoreCase(LT(1)->getText(), "CAST")))||((equalsIgnoreCase(LT(1)->getText(), "EXTRACT")))||((equalsIgnoreCase(LT(1)->getText(), "XMLQUERY")))||((equalsIgnoreCase(LT(1)->getText(), "TREAT")))||((equalsIgnoreCase(LT(1)->getText(), "TRANSLATE")))||((equalsIgnoreCase(LT(1)->getText(), "XMLPARSE")))||((equalsIgnoreCase(LT(1)->getText(), "XMLCOLATTVAL")))||((equalsIgnoreCase(LT(1)->getText(), "TRIM")))||((equalsIgnoreCase(LT(1)->getText(), "XMLAGG")))||((equalsIgnoreCase(LT(1)->getText(), "CHR")))||((equalsIgnoreCase(LT(1)->getText(), "XMLFOREST"))))) && (this->msynpred( antlr3::ClassForwarder<synpred41_PLSQL_DMLParser>() )) )))
            		    {
            		        alt239=10;
            		    }
            		    else if ( (true))
            		    {
            		        alt239=11;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 239 );
            		        ex->set_state( 5 );


            		        goto ruleunary_expressionEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_DISTINCT:
            	{
            		alt239=6;
            	}
                break;
            case SQL92_RESERVED_ALL:
            	{
            		{
            		    int LA239_7 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred38_PLSQL_DMLParser>() )))
            		    {
            		        alt239=7;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred40_PLSQL_DMLParser>() )))
            		    {
            		        alt239=9;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 239 );
            		        ex->set_state( 7 );


            		        goto ruleunary_expressionEx;

            		    }
            		}
            	}
                break;
            case DELIMITED_ID:
            	{
            		{
            		    int LA239_8 = this->LA(2);
            		    if ( (( (( LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE )) && (this->msynpred( antlr3::ClassForwarder<synpred39_PLSQL_DMLParser>() )) )))
            		    {
            		        alt239=8;
            		    }
            		    else if ( (true))
            		    {
            		        alt239=11;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 239 );
            		        ex->set_state( 8 );


            		        goto ruleunary_expressionEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_CASE:
            	{
            		alt239=8;
            	}
                break;
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_EXISTS:
            	{
            		alt239=9;
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case EXACT_NUM_LIT:
            case INTRODUCER:
            case LEFT_PAREN:
            case NATIONAL_CHAR_STRING_LIT:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt239=11;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 239 );
                ex->set_state( 0 );


                goto ruleunary_expressionEx;

            }

            switch (alt239)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:775:10: MINUS_SIGN unary_expression
        	    {
        	         this->matchToken(MINUS_SIGN, &FOLLOW_MINUS_SIGN_in_unary_expression6545);
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_unary_expression_in_unary_expression6547);
        	        unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:776:10: PLUS_SIGN unary_expression
        	    {
        	         this->matchToken(PLUS_SIGN, &FOLLOW_PLUS_SIGN_in_unary_expression6558);
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_unary_expression_in_unary_expression6560);
        	        unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:777:10: prior_key unary_expression
        	    {
        	        this->followPush(FOLLOW_prior_key_in_unary_expression6571);
        	        m_gPLSQLParser->prior_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_unary_expression_in_unary_expression6573);
        	        unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQL_DMLParser.g:778:10: connect_by_root_key unary_expression
        	    {
        	        this->followPush(FOLLOW_connect_by_root_key_in_unary_expression6584);
        	        m_gPLSQLParser->connect_by_root_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_unary_expression_in_unary_expression6586);
        	        unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQL_DMLParser.g:779:10: {...}? => new_key unary_expression
        	    {
        	        if ( !(( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
        	                    equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
        	                 )) )
        	        {
        	            if (this->get_backtracking()>0)
        	            {
        	                this->set_failedflag( true );
        	                return ;
        	            }

        	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), " // input.LT(1).getText().equalsIgnoreCase(\"new\") && !input.LT(2).getText().equals(\".\")}?\n            equalsIgnoreCase(LT(1)->getText(), \"NEW\") && !equalsIgnoreCase(LT(2)->getText(), \".\" )\n         " );
        	                ex->set_ruleName( "unary_expression" );


        	        }

        	        this->followPush(FOLLOW_new_key_in_unary_expression6601);
        	        m_gPLSQLParser->new_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_unary_expression_in_unary_expression6603);
        	        unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // PLSQL_DMLParser.g:782:10: distinct_key unary_expression
        	    {
        	        this->followPush(FOLLOW_distinct_key_in_unary_expression6614);
        	        m_gPLSQLParser->distinct_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_unary_expression_in_unary_expression6616);
        	        unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 7:
        	    // PLSQL_DMLParser.g:783:10: all_key unary_expression
        	    {
        	        this->followPush(FOLLOW_all_key_in_unary_expression6627);
        	        m_gPLSQLParser->all_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_unary_expression_in_unary_expression6629);
        	        unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 8:
        	    // PLSQL_DMLParser.g:784:10: {...}? case_statement[false]
        	    {
        	        if ( !(( LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE )) )
        	        {
        	            if (this->get_backtracking()>0)
        	            {
        	                this->set_failedflag( true );
        	                return ;
        	            }

        	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), " LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE " );
        	                ex->set_ruleName( "unary_expression" );


        	        }

        	        this->followPush(FOLLOW_case_statement_in_unary_expression6642);
        	        case_statement(false);

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 9:
        	    // PLSQL_DMLParser.g:785:10: quantified_expression
        	    {
        	        this->followPush(FOLLOW_quantified_expression_in_unary_expression6654);
        	        quantified_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 10:
        	    // PLSQL_DMLParser.g:786:10: standard_function
        	    {
        	        this->followPush(FOLLOW_standard_function_in_unary_expression6665);
        	        standard_function();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 11:
        	    // PLSQL_DMLParser.g:787:10: atom
        	    {
        	        this->followPush(FOLLOW_atom_in_unary_expression6676);
        	        atom();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleunary_expressionEx; /* Prevent compiler warnings */
    ruleunary_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unary_expression */

/**
 * $ANTLR start case_statement
 * PLSQL_DMLParser.g:790:1: case_statement[int isStatementParameter] : ( ( ( label_name )? case_key when_key )=> searched_case_statement | simple_case_statement );
 */
void
PLSQLParser_PLSQL_DMLParser::case_statement(int isStatementParameter)
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */
    m_case_statement_stack.push(case_statementScope()); 
    m_case_statement_stack.peek().isStatement = isStatementParameter;

 
    {
        {
            //  PLSQL_DMLParser.g:795:5: ( ( ( label_name )? case_key when_key )=> searched_case_statement | simple_case_statement )

            ANTLR_UINT32 alt240;

            alt240=2;

            {
                int LA240_0 = this->LA(1);
                if ( (LA240_0 == DELIMITED_ID || LA240_0 == REGULAR_ID))
                {
                    {
                        int LA240_1 = this->LA(2);
                        if ( (LA240_1 == SQL92_RESERVED_CASE))
                        {
                            {
                                int LA240_2 = this->LA(3);
                                if ( (LA240_2 == SQL92_RESERVED_WHEN) && (this->msynpred( antlr3::ClassForwarder<synpred42_PLSQL_DMLParser>() )))
                                {
                                    alt240=1;
                                }
                                else if ( (LA240_2 == APPROXIMATE_NUM_LIT || LA240_2 == BINDVAR || ((LA240_2 >= CHAR_STRING) && (LA240_2 <= COLON)) || LA240_2 == DELIMITED_ID || LA240_2 == EXACT_NUM_LIT || LA240_2 == INTRODUCER || LA240_2 == LEFT_PAREN || LA240_2 == NATIONAL_CHAR_STRING_LIT || LA240_2 == REGULAR_ID || LA240_2 == SQL92_RESERVED_DATE || LA240_2 == SQL92_RESERVED_DEFAULT || LA240_2 == SQL92_RESERVED_FALSE || LA240_2 == SQL92_RESERVED_NULL || LA240_2 == SQL92_RESERVED_TRUE || LA240_2 == UNSIGNED_INTEGER))
                                {
                                    alt240=2;
                                }
                                else
                                {
                                    if (this->get_backtracking()>0)
                                    {
                                        this->set_failedflag( true );
                                        m_case_statement_stack.pop(); 

                                        return ;
                                    }


                                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                    ex->set_decisionNum( 240 );
                                    ex->set_state( 2 );


                                    goto rulecase_statementEx;

                                }
                            }
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                m_case_statement_stack.pop(); 

                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 240 );
                            ex->set_state( 1 );


                            goto rulecase_statementEx;

                        }
                    }
                }
                else if ( (LA240_0 == SQL92_RESERVED_CASE))
                {
                    {
                        int LA240_2 = this->LA(2);
                        if ( (LA240_2 == SQL92_RESERVED_WHEN) && (this->msynpred( antlr3::ClassForwarder<synpred42_PLSQL_DMLParser>() )))
                        {
                            alt240=1;
                        }
                        else if ( (LA240_2 == APPROXIMATE_NUM_LIT || LA240_2 == BINDVAR || ((LA240_2 >= CHAR_STRING) && (LA240_2 <= COLON)) || LA240_2 == DELIMITED_ID || LA240_2 == EXACT_NUM_LIT || LA240_2 == INTRODUCER || LA240_2 == LEFT_PAREN || LA240_2 == NATIONAL_CHAR_STRING_LIT || LA240_2 == REGULAR_ID || LA240_2 == SQL92_RESERVED_DATE || LA240_2 == SQL92_RESERVED_DEFAULT || LA240_2 == SQL92_RESERVED_FALSE || LA240_2 == SQL92_RESERVED_NULL || LA240_2 == SQL92_RESERVED_TRUE || LA240_2 == UNSIGNED_INTEGER))
                        {
                            alt240=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                m_case_statement_stack.pop(); 

                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 240 );
                            ex->set_state( 2 );


                            goto rulecase_statementEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        m_case_statement_stack.pop(); 

                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 240 );
                    ex->set_state( 0 );


                    goto rulecase_statementEx;

                }
            }
            switch (alt240)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:795:10: ( ( label_name )? case_key when_key )=> searched_case_statement
        	    {
        	        this->followPush(FOLLOW_searched_case_statement_in_case_statement6723);
        	        searched_case_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecase_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            m_case_statement_stack.pop(); 

        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:796:10: simple_case_statement
        	    {
        	        this->followPush(FOLLOW_simple_case_statement_in_case_statement6734);
        	        simple_case_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecase_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            m_case_statement_stack.pop(); 

        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulecase_statementEx; /* Prevent compiler warnings */
    rulecase_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    m_case_statement_stack.pop(); 

    return ;
}
/* $ANTLR end case_statement */

/**
 * $ANTLR start simple_case_statement
 * PLSQL_DMLParser.g:801:1: simple_case_statement : ( label_name )? ck1= case_key atom ( simple_case_when_part )+ ( case_else_part )? end_key ( case_key )? ( label_name )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::simple_case_statement()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:802:5: ( ( label_name )? ck1= case_key atom ( simple_case_when_part )+ ( case_else_part )? end_key ( case_key )? ( label_name )? )
        // PLSQL_DMLParser.g:802:10: ( label_name )? ck1= case_key atom ( simple_case_when_part )+ ( case_else_part )? end_key ( case_key )? ( label_name )?
        {
            // PLSQL_DMLParser.g:802:10: ( label_name )?
            {
                int alt241=2;
                {
                    int LA241_0 = this->LA(1);
                    if ( (LA241_0 == DELIMITED_ID || LA241_0 == REGULAR_ID))
                    {
                        alt241=1;
                    }
                }
                switch (alt241)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:802:10: label_name
            	    {
            	        this->followPush(FOLLOW_label_name_in_simple_case_statement6756);
            	        m_gPLSQLParser->label_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_case_key_in_simple_case_statement6761);
            m_gPLSQLParser->case_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_case_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_atom_in_simple_case_statement6763);
            atom();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_case_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:803:9: ( simple_case_when_part )+
            {
                int cnt242=0;

                for (;;)
                {
                    int alt242=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA242_0 = this->LA(1);
            	    if ( (LA242_0 == SQL92_RESERVED_WHEN))
            	    {
            	        alt242=1;
            	    }

            	}
            	switch (alt242)
            	{
            	    case 1:
            	        // PLSQL_DMLParser.g:803:9: simple_case_when_part
            	        {
            	            this->followPush(FOLLOW_simple_case_when_part_in_simple_case_statement6773);
            	            simple_case_when_part();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulesimple_case_statementEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt242 >= 1 )
            		{
            		    goto loop242;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto rulesimple_case_statementEx;
            	}
            	cnt242++;
                }
                loop242: ;	/* Jump to here if this rule does not match */
            }

            // PLSQL_DMLParser.g:804:9: ( case_else_part )?
            {
                int alt243=2;
                {
                    int LA243_0 = this->LA(1);
                    if ( (LA243_0 == SQL92_RESERVED_ELSE))
                    {
                        alt243=1;
                    }
                }
                switch (alt243)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:804:9: case_else_part
            	    {
            	        this->followPush(FOLLOW_case_else_part_in_simple_case_statement6785);
            	        case_else_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_end_key_in_simple_case_statement6796);
            m_gPLSQLParser->end_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_case_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:805:17: ( case_key )?
            {
                int alt244=2;
                {
                    int LA244_0 = this->LA(1);
                    if ( (LA244_0 == SQL92_RESERVED_CASE))
                    {
                        alt244=1;
                    }
                }
                switch (alt244)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:805:17: case_key
            	    {
            	        this->followPush(FOLLOW_case_key_in_simple_case_statement6798);
            	        m_gPLSQLParser->case_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:805:27: ( label_name )?
            {
                int alt245=2;
                {
                    int LA245_0 = this->LA(1);
                    if ( (LA245_0 == REGULAR_ID))
                    {
                        alt245=1;
                    }
                    else if ( (LA245_0 == DELIMITED_ID))
                    {
                        alt245=1;
                    }
                }
                switch (alt245)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:805:27: label_name
            	    {
            	        this->followPush(FOLLOW_label_name_in_simple_case_statement6801);
            	        m_gPLSQLParser->label_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesimple_case_statementEx; /* Prevent compiler warnings */
    rulesimple_case_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end simple_case_statement */

/**
 * $ANTLR start simple_case_when_part
 * PLSQL_DMLParser.g:808:1: simple_case_when_part : when_key expression_wrapper then_key ({...}? seq_of_statements | expression_wrapper ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::simple_case_when_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:809:5: ( when_key expression_wrapper then_key ({...}? seq_of_statements | expression_wrapper ) )
        // PLSQL_DMLParser.g:809:10: when_key expression_wrapper then_key ({...}? seq_of_statements | expression_wrapper )
        {
            this->followPush(FOLLOW_when_key_in_simple_case_when_part6822);
            m_gPLSQLParser->when_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_case_when_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_wrapper_in_simple_case_when_part6824);
            expression_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_case_when_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_then_key_in_simple_case_when_part6826);
            m_gPLSQLParser->then_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_case_when_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:809:47: ({...}? seq_of_statements | expression_wrapper )
            {
                int alt246=2;
                switch ( this->LA(1) )
                {
                case LESS_THAN_OP:
                case PLSQL_RESERVED_IF:
                case PLSQL_RESERVED_LOCK:
                case SQL92_RESERVED_ALTER:
                case SQL92_RESERVED_BEGIN:
                case SQL92_RESERVED_CREATE:
                case SQL92_RESERVED_DECLARE:
                case SQL92_RESERVED_DELETE:
                case SQL92_RESERVED_FETCH:
                case SQL92_RESERVED_FOR:
                case SQL92_RESERVED_GOTO:
                case SQL92_RESERVED_GRANT:
                case SQL92_RESERVED_INSERT:
                case SQL92_RESERVED_PROCEDURE:
                case SQL92_RESERVED_SELECT:
                case SQL92_RESERVED_UPDATE:
                case SQL92_RESERVED_WITH:
                	{
                		alt246=1;
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    int LA246_4 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt246=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt246=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 246 );
                		        ex->set_state( 4 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case INTRODUCER:
                	{
                		{
                		    int LA246_7 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt246=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt246=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 246 );
                		        ex->set_state( 7 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case DELIMITED_ID:
                	{
                		{
                		    int LA246_8 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt246=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt246=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 246 );
                		        ex->set_state( 8 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case BINDVAR:
                	{
                		{
                		    int LA246_9 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt246=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt246=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 246 );
                		        ex->set_state( 9 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case COLON:
                	{
                		{
                		    int LA246_10 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt246=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt246=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 246 );
                		        ex->set_state( 10 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_CURSOR:
                	{
                		{
                		    int LA246_11 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt246=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt246=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 246 );
                		        ex->set_state( 11 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_NULL:
                	{
                		{
                		    int LA246_16 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt246=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt246=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 246 );
                		        ex->set_state( 16 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_CASE:
                	{
                		{
                		    int LA246_17 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt246=1;
                		    }
                		    else if ( (( LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE )))
                		    {
                		        alt246=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 246 );
                		        ex->set_state( 17 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case LEFT_PAREN:
                	{
                		{
                		    int LA246_21 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt246=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt246=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 246 );
                		        ex->set_state( 21 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case EXACT_NUM_LIT:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt246=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 246 );
                    ex->set_state( 0 );


                    goto rulesimple_case_when_partEx;

                }

                switch (alt246)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:809:48: {...}? seq_of_statements
            	    {
            	        if ( !((m_case_statement_stack.peek().isStatement)) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return ;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "$case_statement::isStatement" );
            	                ex->set_ruleName( "simple_case_when_part" );


            	        }

            	        this->followPush(FOLLOW_seq_of_statements_in_simple_case_when_part6831);
            	        m_gPLSQLParser->seq_of_statements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_case_when_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:809:100: expression_wrapper
            	    {
            	        this->followPush(FOLLOW_expression_wrapper_in_simple_case_when_part6835);
            	        expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_case_when_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesimple_case_when_partEx; /* Prevent compiler warnings */
    rulesimple_case_when_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end simple_case_when_part */

/**
 * $ANTLR start searched_case_statement
 * PLSQL_DMLParser.g:812:1: searched_case_statement : ( label_name )? ck1= case_key ( searched_case_when_part )+ ( case_else_part )? end_key ( case_key )? ( label_name )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::searched_case_statement()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:813:5: ( ( label_name )? ck1= case_key ( searched_case_when_part )+ ( case_else_part )? end_key ( case_key )? ( label_name )? )
        // PLSQL_DMLParser.g:813:10: ( label_name )? ck1= case_key ( searched_case_when_part )+ ( case_else_part )? end_key ( case_key )? ( label_name )?
        {
            // PLSQL_DMLParser.g:813:10: ( label_name )?
            {
                int alt247=2;
                {
                    int LA247_0 = this->LA(1);
                    if ( (LA247_0 == DELIMITED_ID || LA247_0 == REGULAR_ID))
                    {
                        alt247=1;
                    }
                }
                switch (alt247)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:813:10: label_name
            	    {
            	        this->followPush(FOLLOW_label_name_in_searched_case_statement6856);
            	        m_gPLSQLParser->label_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearched_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_case_key_in_searched_case_statement6861);
            m_gPLSQLParser->case_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearched_case_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:814:9: ( searched_case_when_part )+
            {
                int cnt248=0;

                for (;;)
                {
                    int alt248=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA248_0 = this->LA(1);
            	    if ( (LA248_0 == SQL92_RESERVED_WHEN))
            	    {
            	        alt248=1;
            	    }

            	}
            	switch (alt248)
            	{
            	    case 1:
            	        // PLSQL_DMLParser.g:814:9: searched_case_when_part
            	        {
            	            this->followPush(FOLLOW_searched_case_when_part_in_searched_case_statement6871);
            	            searched_case_when_part();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulesearched_case_statementEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt248 >= 1 )
            		{
            		    goto loop248;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto rulesearched_case_statementEx;
            	}
            	cnt248++;
                }
                loop248: ;	/* Jump to here if this rule does not match */
            }

            // PLSQL_DMLParser.g:815:9: ( case_else_part )?
            {
                int alt249=2;
                {
                    int LA249_0 = this->LA(1);
                    if ( (LA249_0 == SQL92_RESERVED_ELSE))
                    {
                        alt249=1;
                    }
                }
                switch (alt249)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:815:9: case_else_part
            	    {
            	        this->followPush(FOLLOW_case_else_part_in_searched_case_statement6882);
            	        case_else_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearched_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_end_key_in_searched_case_statement6893);
            m_gPLSQLParser->end_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearched_case_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:816:17: ( case_key )?
            {
                int alt250=2;
                {
                    int LA250_0 = this->LA(1);
                    if ( (LA250_0 == SQL92_RESERVED_CASE))
                    {
                        alt250=1;
                    }
                }
                switch (alt250)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:816:17: case_key
            	    {
            	        this->followPush(FOLLOW_case_key_in_searched_case_statement6895);
            	        m_gPLSQLParser->case_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearched_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:816:27: ( label_name )?
            {
                int alt251=2;
                {
                    int LA251_0 = this->LA(1);
                    if ( (LA251_0 == REGULAR_ID))
                    {
                        alt251=1;
                    }
                    else if ( (LA251_0 == DELIMITED_ID))
                    {
                        alt251=1;
                    }
                }
                switch (alt251)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:816:27: label_name
            	    {
            	        this->followPush(FOLLOW_label_name_in_searched_case_statement6898);
            	        m_gPLSQLParser->label_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearched_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesearched_case_statementEx; /* Prevent compiler warnings */
    rulesearched_case_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end searched_case_statement */

/**
 * $ANTLR start searched_case_when_part
 * PLSQL_DMLParser.g:819:1: searched_case_when_part : when_key condition_wrapper then_key ({...}? seq_of_statements | expression_wrapper ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::searched_case_when_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:820:5: ( when_key condition_wrapper then_key ({...}? seq_of_statements | expression_wrapper ) )
        // PLSQL_DMLParser.g:820:10: when_key condition_wrapper then_key ({...}? seq_of_statements | expression_wrapper )
        {
            this->followPush(FOLLOW_when_key_in_searched_case_when_part6919);
            m_gPLSQLParser->when_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearched_case_when_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_condition_wrapper_in_searched_case_when_part6921);
            condition_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearched_case_when_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_then_key_in_searched_case_when_part6923);
            m_gPLSQLParser->then_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearched_case_when_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:820:46: ({...}? seq_of_statements | expression_wrapper )
            {
                int alt252=2;
                switch ( this->LA(1) )
                {
                case LESS_THAN_OP:
                case PLSQL_RESERVED_IF:
                case PLSQL_RESERVED_LOCK:
                case SQL92_RESERVED_ALTER:
                case SQL92_RESERVED_BEGIN:
                case SQL92_RESERVED_CREATE:
                case SQL92_RESERVED_DECLARE:
                case SQL92_RESERVED_DELETE:
                case SQL92_RESERVED_FETCH:
                case SQL92_RESERVED_FOR:
                case SQL92_RESERVED_GOTO:
                case SQL92_RESERVED_GRANT:
                case SQL92_RESERVED_INSERT:
                case SQL92_RESERVED_PROCEDURE:
                case SQL92_RESERVED_SELECT:
                case SQL92_RESERVED_UPDATE:
                case SQL92_RESERVED_WITH:
                	{
                		alt252=1;
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    int LA252_4 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt252=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt252=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 252 );
                		        ex->set_state( 4 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case INTRODUCER:
                	{
                		{
                		    int LA252_7 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt252=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt252=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 252 );
                		        ex->set_state( 7 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case DELIMITED_ID:
                	{
                		{
                		    int LA252_8 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt252=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt252=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 252 );
                		        ex->set_state( 8 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case BINDVAR:
                	{
                		{
                		    int LA252_9 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt252=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt252=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 252 );
                		        ex->set_state( 9 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case COLON:
                	{
                		{
                		    int LA252_10 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt252=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt252=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 252 );
                		        ex->set_state( 10 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_CURSOR:
                	{
                		{
                		    int LA252_11 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt252=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt252=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 252 );
                		        ex->set_state( 11 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_NULL:
                	{
                		{
                		    int LA252_16 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt252=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt252=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 252 );
                		        ex->set_state( 16 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_CASE:
                	{
                		{
                		    int LA252_17 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt252=1;
                		    }
                		    else if ( (( LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE )))
                		    {
                		        alt252=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 252 );
                		        ex->set_state( 17 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case LEFT_PAREN:
                	{
                		{
                		    int LA252_21 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt252=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt252=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 252 );
                		        ex->set_state( 21 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case EXACT_NUM_LIT:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt252=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 252 );
                    ex->set_state( 0 );


                    goto rulesearched_case_when_partEx;

                }

                switch (alt252)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:820:47: {...}? seq_of_statements
            	    {
            	        if ( !((m_case_statement_stack.peek().isStatement)) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return ;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "$case_statement::isStatement" );
            	                ex->set_ruleName( "searched_case_when_part" );


            	        }

            	        this->followPush(FOLLOW_seq_of_statements_in_searched_case_when_part6928);
            	        m_gPLSQLParser->seq_of_statements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearched_case_when_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:820:99: expression_wrapper
            	    {
            	        this->followPush(FOLLOW_expression_wrapper_in_searched_case_when_part6932);
            	        expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearched_case_when_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesearched_case_when_partEx; /* Prevent compiler warnings */
    rulesearched_case_when_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end searched_case_when_part */

/**
 * $ANTLR start case_else_part
 * PLSQL_DMLParser.g:823:1: case_else_part : else_key ({...}? seq_of_statements | expression_wrapper ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::case_else_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:824:5: ( else_key ({...}? seq_of_statements | expression_wrapper ) )
        // PLSQL_DMLParser.g:824:10: else_key ({...}? seq_of_statements | expression_wrapper )
        {
            this->followPush(FOLLOW_else_key_in_case_else_part6953);
            m_gPLSQLParser->else_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecase_else_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:824:19: ({...}? seq_of_statements | expression_wrapper )
            {
                int alt253=2;
                switch ( this->LA(1) )
                {
                case LESS_THAN_OP:
                case PLSQL_RESERVED_IF:
                case PLSQL_RESERVED_LOCK:
                case SQL92_RESERVED_ALTER:
                case SQL92_RESERVED_BEGIN:
                case SQL92_RESERVED_CREATE:
                case SQL92_RESERVED_DECLARE:
                case SQL92_RESERVED_DELETE:
                case SQL92_RESERVED_FETCH:
                case SQL92_RESERVED_FOR:
                case SQL92_RESERVED_GOTO:
                case SQL92_RESERVED_GRANT:
                case SQL92_RESERVED_INSERT:
                case SQL92_RESERVED_PROCEDURE:
                case SQL92_RESERVED_SELECT:
                case SQL92_RESERVED_UPDATE:
                case SQL92_RESERVED_WITH:
                	{
                		alt253=1;
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    int LA253_4 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt253=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt253=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 253 );
                		        ex->set_state( 4 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case INTRODUCER:
                	{
                		{
                		    int LA253_7 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt253=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt253=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 253 );
                		        ex->set_state( 7 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case DELIMITED_ID:
                	{
                		{
                		    int LA253_8 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt253=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt253=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 253 );
                		        ex->set_state( 8 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case BINDVAR:
                	{
                		{
                		    int LA253_9 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt253=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt253=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 253 );
                		        ex->set_state( 9 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case COLON:
                	{
                		{
                		    int LA253_10 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt253=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt253=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 253 );
                		        ex->set_state( 10 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_CURSOR:
                	{
                		{
                		    int LA253_11 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt253=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt253=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 253 );
                		        ex->set_state( 11 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_NULL:
                	{
                		{
                		    int LA253_16 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt253=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt253=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 253 );
                		        ex->set_state( 16 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_CASE:
                	{
                		{
                		    int LA253_17 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt253=1;
                		    }
                		    else if ( (( LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE )))
                		    {
                		        alt253=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 253 );
                		        ex->set_state( 17 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case LEFT_PAREN:
                	{
                		{
                		    int LA253_21 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt253=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt253=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 253 );
                		        ex->set_state( 21 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case EXACT_NUM_LIT:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt253=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 253 );
                    ex->set_state( 0 );


                    goto rulecase_else_partEx;

                }

                switch (alt253)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:824:20: {...}? seq_of_statements
            	    {
            	        if ( !((m_case_statement_stack.peek().isStatement)) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return ;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "$case_statement::isStatement" );
            	                ex->set_ruleName( "case_else_part" );


            	        }

            	        this->followPush(FOLLOW_seq_of_statements_in_case_else_part6958);
            	        m_gPLSQLParser->seq_of_statements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecase_else_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:824:72: expression_wrapper
            	    {
            	        this->followPush(FOLLOW_expression_wrapper_in_case_else_part6962);
            	        expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecase_else_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulecase_else_partEx; /* Prevent compiler warnings */
    rulecase_else_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end case_else_part */

/**
 * $ANTLR start atom
 * PLSQL_DMLParser.g:828:1: atom options {backtrack=true; } : ( ( table_element outer_join_sign )=> table_element outer_join_sign | bind_variable | constant | general_element | LEFT_PAREN ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN ) );
 */
void
PLSQLParser_PLSQL_DMLParser::atom()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:833:5: ( ( table_element outer_join_sign )=> table_element outer_join_sign | bind_variable | constant | general_element | LEFT_PAREN ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN ) )

            ANTLR_UINT32 alt256;

            alt256=5;

            alt256 = cdfa256.predict(this, this->get_rec(), this->get_istream(), cdfa256 );
            if  (this->hasException())
            {
                goto ruleatomEx;
            }
            if (this->hasFailed())
            {
                return ;
            }

            switch (alt256)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:833:10: ( table_element outer_join_sign )=> table_element outer_join_sign
        	    {
        	        this->followPush(FOLLOW_table_element_in_atom7001);
        	        m_gPLSQLParser->table_element();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_outer_join_sign_in_atom7003);
        	        m_gPLSQLParser->outer_join_sign();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:834:10: bind_variable
        	    {
        	        this->followPush(FOLLOW_bind_variable_in_atom7014);
        	        m_gPLSQLParser->bind_variable();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:835:10: constant
        	    {
        	        this->followPush(FOLLOW_constant_in_atom7025);
        	        m_gPLSQLParser->constant();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQL_DMLParser.g:836:10: general_element
        	    {
        	        this->followPush(FOLLOW_general_element_in_atom7036);
        	        m_gPLSQLParser->general_element();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQL_DMLParser.g:837:10: LEFT_PAREN ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN )
        	    {
        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_atom7047);
        	        if  (this->hasException())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:838:10: ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN )
        	        {
        	            int alt255=2;
        	            {
        	                int LA255_0 = this->LA(1);
        	                if ( (LA255_0 == SQL92_RESERVED_SELECT) && (this->msynpred( antlr3::ClassForwarder<synpred47_PLSQL_DMLParser>() )))
        	                {
        	                    alt255=1;
        	                }
        	                else if ( (LA255_0 == LEFT_PAREN))
        	                {
        	                    {
        	                        int LA255_2 = this->LA(2);
        	                        if ( (this->msynpred( antlr3::ClassForwarder<synpred47_PLSQL_DMLParser>() )))
        	                        {
        	                            alt255=1;
        	                        }
        	                        else if ( (true))
        	                        {
        	                            alt255=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 255 );
        	                            ex->set_state( 2 );


        	                            goto ruleatomEx;

        	                        }
        	                    }
        	                }
        	                else if ( (LA255_0 == APPROXIMATE_NUM_LIT || LA255_0 == BINDVAR || ((LA255_0 >= CHAR_STRING) && (LA255_0 <= COLON)) || LA255_0 == DELIMITED_ID || LA255_0 == EXACT_NUM_LIT || LA255_0 == INTRODUCER || ((LA255_0 >= MINUS_SIGN) && (LA255_0 <= NATIONAL_CHAR_STRING_LIT)) || LA255_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA255_0 == PLUS_SIGN || LA255_0 == REGULAR_ID || LA255_0 == SQL92_RESERVED_ALL || LA255_0 == SQL92_RESERVED_ANY || LA255_0 == SQL92_RESERVED_CASE || ((LA255_0 >= SQL92_RESERVED_CURSOR) && (LA255_0 <= SQL92_RESERVED_DATE)) || LA255_0 == SQL92_RESERVED_DEFAULT || LA255_0 == SQL92_RESERVED_DISTINCT || ((LA255_0 >= SQL92_RESERVED_EXISTS) && (LA255_0 <= SQL92_RESERVED_FALSE)) || ((LA255_0 >= SQL92_RESERVED_NOT) && (LA255_0 <= SQL92_RESERVED_NULL)) || LA255_0 == SQL92_RESERVED_PRIOR || LA255_0 == SQL92_RESERVED_TRUE || LA255_0 == UNSIGNED_INTEGER))
        	                {
        	                    alt255=2;
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 255 );
        	                    ex->set_state( 0 );


        	                    goto ruleatomEx;

        	                }
        	            }
        	            switch (alt255)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:839:15: ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )*
        	        	    {
        	        	        this->followPush(FOLLOW_subquery_in_atom7084);
        	        	        subquery();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_atom7086);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQL_DMLParser.g:839:63: ( subquery_operation_part )*

        	        	        for (;;)
        	        	        {
        	        	            int alt254=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	            case SQL92_RESERVED_UNION:
        	        	            	{
        	        	            		alt254=1;
        	        	            	}
        	        	                break;
        	        	            case SQL92_RESERVED_INTERSECT:
        	        	            	{
        	        	            		alt254=1;
        	        	            	}
        	        	                break;
        	        	            case PLSQL_RESERVED_MINUS:
        	        	            	{
        	        	            		alt254=1;
        	        	            	}
        	        	                break;

        	        	            }

        	        	            switch (alt254)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:839:63: subquery_operation_part
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_subquery_operation_part_in_atom7088);
        	        	        	        subquery_operation_part();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleatomEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	        	default:
        	        	        	    goto loop254;	/* break out of the loop */
        	        	        	    break;
        	        	            }
        	        	        }
        	        	        loop254: ; /* Jump out to here if this rule does not match */


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:840:17: expression_or_vector RIGHT_PAREN
        	        	    {
        	        	        this->followPush(FOLLOW_expression_or_vector_in_atom7107);
        	        	        expression_or_vector();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_atom7109);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleatomEx; /* Prevent compiler warnings */
    ruleatomEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end atom */

/**
 * $ANTLR start expression_or_vector
 * PLSQL_DMLParser.g:844:1: expression_or_vector : expression ( vector_expr )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::expression_or_vector()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:845:5: ( expression ( vector_expr )? )
        // PLSQL_DMLParser.g:845:10: expression ( vector_expr )?
        {
            this->followPush(FOLLOW_expression_in_expression_or_vector7140);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexpression_or_vectorEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:845:21: ( vector_expr )?
            {
                int alt257=2;
                {
                    int LA257_0 = this->LA(1);
                    if ( (LA257_0 == COMMA))
                    {
                        alt257=1;
                    }
                }
                switch (alt257)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:845:22: vector_expr
            	    {
            	        this->followPush(FOLLOW_vector_expr_in_expression_or_vector7143);
            	        vector_expr();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexpression_or_vectorEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexpression_or_vectorEx; /* Prevent compiler warnings */
    ruleexpression_or_vectorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end expression_or_vector */

/**
 * $ANTLR start vector_expr
 * PLSQL_DMLParser.g:848:1: vector_expr : COMMA expression ( COMMA expression )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::vector_expr()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:849:5: ( COMMA expression ( COMMA expression )* )
        // PLSQL_DMLParser.g:849:10: COMMA expression ( COMMA expression )*
        {
             this->matchToken(COMMA, &FOLLOW_COMMA_in_vector_expr7165);
            if  (this->hasException())
            {
                goto rulevector_exprEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_vector_expr7167);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulevector_exprEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:849:27: ( COMMA expression )*

            for (;;)
            {
                int alt258=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA258_0 = this->LA(1);
                    if ( (LA258_0 == COMMA))
                    {
                        alt258=1;
                    }

                }
                switch (alt258)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:849:28: COMMA expression
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_vector_expr7170);
            	        if  (this->hasException())
            	        {
            	            goto rulevector_exprEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_vector_expr7172);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulevector_exprEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop258;	/* break out of the loop */
            	    break;
                }
            }
            loop258: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevector_exprEx; /* Prevent compiler warnings */
    rulevector_exprEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end vector_expr */

/**
 * $ANTLR start quantified_expression
 * PLSQL_DMLParser.g:852:1: quantified_expression : ( some_key | exists_key | all_key | any_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression_wrapper RIGHT_PAREN ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::quantified_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:853:5: ( ( some_key | exists_key | all_key | any_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression_wrapper RIGHT_PAREN ) )
        // PLSQL_DMLParser.g:853:10: ( some_key | exists_key | all_key | any_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression_wrapper RIGHT_PAREN )
        {
            // PLSQL_DMLParser.g:853:10: ( some_key | exists_key | all_key | any_key )
            {
                int alt259=4;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		alt259=1;
                	}
                    break;
                case SQL92_RESERVED_EXISTS:
                	{
                		alt259=2;
                	}
                    break;
                case SQL92_RESERVED_ALL:
                	{
                		alt259=3;
                	}
                    break;
                case SQL92_RESERVED_ANY:
                	{
                		alt259=4;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 259 );
                    ex->set_state( 0 );


                    goto rulequantified_expressionEx;

                }

                switch (alt259)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:853:12: some_key
            	    {
            	        this->followPush(FOLLOW_some_key_in_quantified_expression7196);
            	        m_gPLSQLParser->some_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:853:23: exists_key
            	    {
            	        this->followPush(FOLLOW_exists_key_in_quantified_expression7200);
            	        m_gPLSQLParser->exists_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQL_DMLParser.g:853:36: all_key
            	    {
            	        this->followPush(FOLLOW_all_key_in_quantified_expression7204);
            	        m_gPLSQLParser->all_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 4:
            	    // PLSQL_DMLParser.g:853:46: any_key
            	    {
            	        this->followPush(FOLLOW_any_key_in_quantified_expression7208);
            	        m_gPLSQLParser->any_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:854:10: ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression_wrapper RIGHT_PAREN )
            {
                int alt260=2;
                {
                    int LA260_0 = this->LA(1);
                    if ( (LA260_0 == LEFT_PAREN))
                    {
                        {
                            int LA260_1 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred48_PLSQL_DMLParser>() )))
                            {
                                alt260=1;
                            }
                            else if ( (true))
                            {
                                alt260=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 260 );
                                ex->set_state( 1 );


                                goto rulequantified_expressionEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 260 );
                        ex->set_state( 0 );


                        goto rulequantified_expressionEx;

                    }
                }
                switch (alt260)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:854:12: ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_quantified_expression7235);
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_subquery_in_quantified_expression7237);
            	        subquery();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_quantified_expression7239);
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:855:14: LEFT_PAREN expression_wrapper RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_quantified_expression7254);
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_wrapper_in_quantified_expression7256);
            	        expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_quantified_expression7258);
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulequantified_expressionEx; /* Prevent compiler warnings */
    rulequantified_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end quantified_expression */

/**
 * $ANTLR start standard_function
 * PLSQL_DMLParser.g:859:1: standard_function : ( stantard_function_enabling_over function_argument_analytic ( over_clause )? | stantard_function_enabling_using function_argument_modeling ( using_clause )? | count_key LEFT_PAREN ( ASTERISK | ( distinct_key | unique_key | all_key )? concatenation_wrapper ) RIGHT_PAREN ( over_clause )? | ( cast_key | xmlcast_key ) LEFT_PAREN ( ( multiset_key ( LEFT_PAREN )+ ( select_key | with_key ) )=> multiset_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( as_key type_spec )? | concatenation_wrapper as_key type_spec ) RIGHT_PAREN | chr_key LEFT_PAREN concatenation_wrapper using_key nchar_cs_key RIGHT_PAREN | collect_key LEFT_PAREN ( distinct_key | unique_key )? concatenation_wrapper ( collect_order_by_part )? RIGHT_PAREN | stantard_function_enabling_within_or_over function_argument ( within_or_over_part )+ | decompose_key LEFT_PAREN concatenation_wrapper ( canonical_key | compatibility_key )? RIGHT_PAREN | extract_key LEFT_PAREN REGULAR_ID from_key concatenation_wrapper RIGHT_PAREN | ( first_value_key | last_value_key ) function_argument_analytic ( respect_or_ignore_nulls )? over_clause | stantard_function_pedictions LEFT_PAREN expression_wrapper ( COMMA expression_wrapper )* ( cost_matrix_clause )? ( using_clause )? RIGHT_PAREN | translate_key LEFT_PAREN expression_wrapper ( using_key ( char_cs_key | nchar_cs_key ) )? ( COMMA expression_wrapper )* RIGHT_PAREN | treat_key LEFT_PAREN expression_wrapper as_key ( ref_key )? type_spec RIGHT_PAREN | trim_key LEFT_PAREN ( ( leading_key | trailing_key | both_key )? ( quoted_string )? from_key )? concatenation_wrapper RIGHT_PAREN | xmlagg_key LEFT_PAREN expression_wrapper ( order_by_clause )? RIGHT_PAREN ( PERIOD general_element_part )? | ( xmlcolattval_key | xmlforest_key ) LEFT_PAREN xml_multiuse_expression_element ( COMMA xml_multiuse_expression_element )* RIGHT_PAREN ( PERIOD general_element_part )? | xmlelement_key LEFT_PAREN ( entityescaping_key | noentityescaping_key )? ( name_key | evalname_key )? expression_wrapper ({...}? COMMA xml_attributes_clause )? ( COMMA expression_wrapper ( column_alias )? )* RIGHT_PAREN ( PERIOD general_element_part )? | xmlexists_key LEFT_PAREN expression_wrapper ( xml_passing_clause )? RIGHT_PAREN | xmlparse_key LEFT_PAREN ( document_key | content_key ) concatenation_wrapper ( wellformed_key )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlpi_key LEFT_PAREN ( name_key id | evalname_key concatenation_wrapper ) ( COMMA concatenation_wrapper )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlquery_key LEFT_PAREN concatenation_wrapper ( xml_passing_clause )? returning_key content_key ( null_key on_key empty_key )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlroot_key LEFT_PAREN concatenation_wrapper xmlroot_param_version_part ( COMMA xmlroot_param_standalone_part )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlserialize_key LEFT_PAREN ( document_key | content_key ) concatenation_wrapper ( as_key type_spec )? ( xmlserialize_param_enconding_part )? ( xmlserialize_param_version_part )? ( xmlserialize_param_ident_part )? ( ( hide_key | show_key ) defaults_key )? RIGHT_PAREN ( PERIOD general_element_part )? | xmltable_key LEFT_PAREN ( xml_namespaces_clause )? concatenation_wrapper ( xml_passing_clause )? ( columns_key xml_table_column ( COMMA xml_table_column ) )? RIGHT_PAREN ( PERIOD general_element_part )? );
 */
void
PLSQLParser_PLSQL_DMLParser::standard_function()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:860:5: ( stantard_function_enabling_over function_argument_analytic ( over_clause )? | stantard_function_enabling_using function_argument_modeling ( using_clause )? | count_key LEFT_PAREN ( ASTERISK | ( distinct_key | unique_key | all_key )? concatenation_wrapper ) RIGHT_PAREN ( over_clause )? | ( cast_key | xmlcast_key ) LEFT_PAREN ( ( multiset_key ( LEFT_PAREN )+ ( select_key | with_key ) )=> multiset_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( as_key type_spec )? | concatenation_wrapper as_key type_spec ) RIGHT_PAREN | chr_key LEFT_PAREN concatenation_wrapper using_key nchar_cs_key RIGHT_PAREN | collect_key LEFT_PAREN ( distinct_key | unique_key )? concatenation_wrapper ( collect_order_by_part )? RIGHT_PAREN | stantard_function_enabling_within_or_over function_argument ( within_or_over_part )+ | decompose_key LEFT_PAREN concatenation_wrapper ( canonical_key | compatibility_key )? RIGHT_PAREN | extract_key LEFT_PAREN REGULAR_ID from_key concatenation_wrapper RIGHT_PAREN | ( first_value_key | last_value_key ) function_argument_analytic ( respect_or_ignore_nulls )? over_clause | stantard_function_pedictions LEFT_PAREN expression_wrapper ( COMMA expression_wrapper )* ( cost_matrix_clause )? ( using_clause )? RIGHT_PAREN | translate_key LEFT_PAREN expression_wrapper ( using_key ( char_cs_key | nchar_cs_key ) )? ( COMMA expression_wrapper )* RIGHT_PAREN | treat_key LEFT_PAREN expression_wrapper as_key ( ref_key )? type_spec RIGHT_PAREN | trim_key LEFT_PAREN ( ( leading_key | trailing_key | both_key )? ( quoted_string )? from_key )? concatenation_wrapper RIGHT_PAREN | xmlagg_key LEFT_PAREN expression_wrapper ( order_by_clause )? RIGHT_PAREN ( PERIOD general_element_part )? | ( xmlcolattval_key | xmlforest_key ) LEFT_PAREN xml_multiuse_expression_element ( COMMA xml_multiuse_expression_element )* RIGHT_PAREN ( PERIOD general_element_part )? | xmlelement_key LEFT_PAREN ( entityescaping_key | noentityescaping_key )? ( name_key | evalname_key )? expression_wrapper ({...}? COMMA xml_attributes_clause )? ( COMMA expression_wrapper ( column_alias )? )* RIGHT_PAREN ( PERIOD general_element_part )? | xmlexists_key LEFT_PAREN expression_wrapper ( xml_passing_clause )? RIGHT_PAREN | xmlparse_key LEFT_PAREN ( document_key | content_key ) concatenation_wrapper ( wellformed_key )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlpi_key LEFT_PAREN ( name_key id | evalname_key concatenation_wrapper ) ( COMMA concatenation_wrapper )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlquery_key LEFT_PAREN concatenation_wrapper ( xml_passing_clause )? returning_key content_key ( null_key on_key empty_key )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlroot_key LEFT_PAREN concatenation_wrapper xmlroot_param_version_part ( COMMA xmlroot_param_standalone_part )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlserialize_key LEFT_PAREN ( document_key | content_key ) concatenation_wrapper ( as_key type_spec )? ( xmlserialize_param_enconding_part )? ( xmlserialize_param_version_part )? ( xmlserialize_param_ident_part )? ( ( hide_key | show_key ) defaults_key )? RIGHT_PAREN ( PERIOD general_element_part )? | xmltable_key LEFT_PAREN ( xml_namespaces_clause )? concatenation_wrapper ( xml_passing_clause )? ( columns_key xml_table_column ( COMMA xml_table_column ) )? RIGHT_PAREN ( PERIOD general_element_part )? )

            ANTLR_UINT32 alt321;

            alt321=24;

            {
                int LA321_0 = this->LA(1);
                if ( (LA321_0 == REGULAR_ID))
                {
                    {
                        int LA321_1 = this->LA(2);
                        if ( ((enablesOverClause(LT(1)->getText()))))
                        {
                            alt321=1;
                        }
                        else if ( ((enablesUsingClause(LT(1)->getText()))))
                        {
                            alt321=2;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "COUNT"))))
                        {
                            alt321=3;
                        }
                        else if ( ((((equalsIgnoreCase(LT(1)->getText(), "CAST")))||((equalsIgnoreCase(LT(1)->getText(), "XMLCAST"))))))
                        {
                            alt321=4;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "CHR"))))
                        {
                            alt321=5;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "COLLECT"))))
                        {
                            alt321=6;
                        }
                        else if ( ((enablesWithinOrOverClause(LT(1)->getText()))))
                        {
                            alt321=7;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "DECOMPOSE"))))
                        {
                            alt321=8;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "EXTRACT"))))
                        {
                            alt321=9;
                        }
                        else if ( ((((equalsIgnoreCase(LT(1)->getText(), "FIRST_VALUE")))||((equalsIgnoreCase(LT(1)->getText(), "LAST_VALUE"))))))
                        {
                            alt321=10;
                        }
                        else if ( ((isStandardPredictionFunction(LT(1)->getText()))))
                        {
                            alt321=11;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "TRANSLATE"))))
                        {
                            alt321=12;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "TREAT"))))
                        {
                            alt321=13;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "TRIM"))))
                        {
                            alt321=14;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLAGG"))))
                        {
                            alt321=15;
                        }
                        else if ( ((((equalsIgnoreCase(LT(1)->getText(), "XMLFOREST")))||((equalsIgnoreCase(LT(1)->getText(), "XMLCOLATTVAL"))))))
                        {
                            alt321=16;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLELEMENT"))))
                        {
                            alt321=17;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLEXISTS"))))
                        {
                            alt321=18;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLPARSE"))))
                        {
                            alt321=19;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLPI"))))
                        {
                            alt321=20;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLQUERY"))))
                        {
                            alt321=21;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLROOT"))))
                        {
                            alt321=22;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLSERIALIZE"))))
                        {
                            alt321=23;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLTABLE"))))
                        {
                            alt321=24;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 321 );
                            ex->set_state( 1 );


                            goto rulestandard_functionEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 321 );
                    ex->set_state( 0 );


                    goto rulestandard_functionEx;

                }
            }
            switch (alt321)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:860:10: stantard_function_enabling_over function_argument_analytic ( over_clause )?
        	    {
        	        this->followPush(FOLLOW_stantard_function_enabling_over_in_standard_function7289);
        	        stantard_function_enabling_over();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_function_argument_analytic_in_standard_function7291);
        	        m_gPLSQLParser->function_argument_analytic();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:860:69: ( over_clause )?
        	        {
        	            int alt261=2;
        	            {
        	                int LA261_0 = this->LA(1);
        	                if ( (LA261_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA261_1 = this->LA(2);
        	                        if ( (LA261_1 == LEFT_PAREN))
        	                        {
        	                            {
        	                                int LA261_3 = this->LA(3);
        	                                if ( (LA261_3 == REGULAR_ID))
        	                                {
        	                                    {
        	                                        int LA261_11 = this->LA(4);
        	                                        if ( (LA261_11 == SQL92_RESERVED_BY) && ((equalsIgnoreCase(LT(1)->getText(), "OVER"))))
        	                                        {
        	                                            alt261=1;
        	                                        }
        	                                    }
        	                                }
        	                                else if ( (LA261_3 == RIGHT_PAREN || LA261_3 == SQL92_RESERVED_ORDER) && ((equalsIgnoreCase(LT(1)->getText(), "OVER"))))
        	                                {
        	                                    alt261=1;
        	                                }
        	                            }
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt261)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:860:69: over_clause
        	        	    {
        	        	        this->followPush(FOLLOW_over_clause_in_standard_function7293);
        	        	        over_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:861:10: stantard_function_enabling_using function_argument_modeling ( using_clause )?
        	    {
        	        this->followPush(FOLLOW_stantard_function_enabling_using_in_standard_function7305);
        	        stantard_function_enabling_using();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_function_argument_modeling_in_standard_function7307);
        	        m_gPLSQLParser->function_argument_modeling();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:861:70: ( using_clause )?
        	        {
        	            int alt262=2;
        	            alt262 = cdfa262.predict(this, this->get_rec(), this->get_istream(), cdfa262 );
        	            if  (this->hasException())
        	            {
        	                goto rulestandard_functionEx;
        	            }
        	            if (this->hasFailed())
        	            {
        	                return ;
        	            }

        	            switch (alt262)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:861:70: using_clause
        	        	    {
        	        	        this->followPush(FOLLOW_using_clause_in_standard_function7309);
        	        	        using_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:862:10: count_key LEFT_PAREN ( ASTERISK | ( distinct_key | unique_key | all_key )? concatenation_wrapper ) RIGHT_PAREN ( over_clause )?
        	    {
        	        this->followPush(FOLLOW_count_key_in_standard_function7321);
        	        m_gPLSQLParser->count_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function7335);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:864:17: ( ASTERISK | ( distinct_key | unique_key | all_key )? concatenation_wrapper )
        	        {
        	            int alt264=2;
        	            {
        	                int LA264_0 = this->LA(1);
        	                if ( (LA264_0 == ASTERISK))
        	                {
        	                    alt264=1;
        	                }
        	                else if ( (LA264_0 == APPROXIMATE_NUM_LIT || LA264_0 == BINDVAR || ((LA264_0 >= CHAR_STRING) && (LA264_0 <= COLON)) || LA264_0 == DELIMITED_ID || LA264_0 == EXACT_NUM_LIT || LA264_0 == INTRODUCER || LA264_0 == LEFT_PAREN || ((LA264_0 >= MINUS_SIGN) && (LA264_0 <= NATIONAL_CHAR_STRING_LIT)) || LA264_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA264_0 == PLUS_SIGN || LA264_0 == REGULAR_ID || LA264_0 == SQL92_RESERVED_ALL || LA264_0 == SQL92_RESERVED_ANY || LA264_0 == SQL92_RESERVED_CASE || LA264_0 == SQL92_RESERVED_DATE || LA264_0 == SQL92_RESERVED_DEFAULT || LA264_0 == SQL92_RESERVED_DISTINCT || ((LA264_0 >= SQL92_RESERVED_EXISTS) && (LA264_0 <= SQL92_RESERVED_FALSE)) || LA264_0 == SQL92_RESERVED_NULL || LA264_0 == SQL92_RESERVED_PRIOR || LA264_0 == SQL92_RESERVED_TRUE || LA264_0 == SQL92_RESERVED_UNIQUE || LA264_0 == UNSIGNED_INTEGER))
        	                {
        	                    alt264=2;
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 264 );
        	                    ex->set_state( 0 );


        	                    goto rulestandard_functionEx;

        	                }
        	            }
        	            switch (alt264)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:864:19: ASTERISK
        	        	    {
        	        	         this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_standard_function7355);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:864:30: ( distinct_key | unique_key | all_key )? concatenation_wrapper
        	        	    {
        	        	        // PLSQL_DMLParser.g:864:30: ( distinct_key | unique_key | all_key )?
        	        	        {
        	        	            int alt263=4;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case SQL92_RESERVED_DISTINCT:
        	        	                	{
        	        	                		alt263=1;
        	        	                	}
        	        	                    break;
        	        	                case SQL92_RESERVED_UNIQUE:
        	        	                	{
        	        	                		alt263=2;
        	        	                	}
        	        	                    break;
        	        	                case SQL92_RESERVED_ALL:
        	        	                	{
        	        	                		alt263=3;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt263)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:864:31: distinct_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_distinct_key_in_standard_function7360);
        	        	        	        m_gPLSQLParser->distinct_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // PLSQL_DMLParser.g:864:44: unique_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_unique_key_in_standard_function7362);
        	        	        	        m_gPLSQLParser->unique_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 3:
        	        	        	    // PLSQL_DMLParser.g:864:55: all_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_all_key_in_standard_function7364);
        	        	        	        m_gPLSQLParser->all_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function7368);
        	        	        concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function7384);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:865:25: ( over_clause )?
        	        {
        	            int alt265=2;
        	            {
        	                int LA265_0 = this->LA(1);
        	                if ( (LA265_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA265_1 = this->LA(2);
        	                        if ( (LA265_1 == LEFT_PAREN))
        	                        {
        	                            {
        	                                int LA265_3 = this->LA(3);
        	                                if ( (LA265_3 == REGULAR_ID))
        	                                {
        	                                    {
        	                                        int LA265_11 = this->LA(4);
        	                                        if ( (LA265_11 == SQL92_RESERVED_BY) && ((equalsIgnoreCase(LT(1)->getText(), "OVER"))))
        	                                        {
        	                                            alt265=1;
        	                                        }
        	                                    }
        	                                }
        	                                else if ( (LA265_3 == RIGHT_PAREN || LA265_3 == SQL92_RESERVED_ORDER) && ((equalsIgnoreCase(LT(1)->getText(), "OVER"))))
        	                                {
        	                                    alt265=1;
        	                                }
        	                            }
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt265)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:865:25: over_clause
        	        	    {
        	        	        this->followPush(FOLLOW_over_clause_in_standard_function7386);
        	        	        over_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 4:
        	    // PLSQL_DMLParser.g:866:10: ( cast_key | xmlcast_key ) LEFT_PAREN ( ( multiset_key ( LEFT_PAREN )+ ( select_key | with_key ) )=> multiset_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( as_key type_spec )? | concatenation_wrapper as_key type_spec ) RIGHT_PAREN
        	    {
        	        // PLSQL_DMLParser.g:866:10: ( cast_key | xmlcast_key )
        	        {
        	            int alt266=2;
        	            {
        	                int LA266_0 = this->LA(1);
        	                if ( (LA266_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA266_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "CAST"))))
        	                        {
        	                            alt266=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLCAST"))))
        	                        {
        	                            alt266=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 266 );
        	                            ex->set_state( 1 );


        	                            goto rulestandard_functionEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 266 );
        	                    ex->set_state( 0 );


        	                    goto rulestandard_functionEx;

        	                }
        	            }
        	            switch (alt266)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:866:11: cast_key
        	        	    {
        	        	        this->followPush(FOLLOW_cast_key_in_standard_function7399);
        	        	        m_gPLSQLParser->cast_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:866:20: xmlcast_key
        	        	    {
        	        	        this->followPush(FOLLOW_xmlcast_key_in_standard_function7401);
        	        	        m_gPLSQLParser->xmlcast_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function7417);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:868:10: ( ( multiset_key ( LEFT_PAREN )+ ( select_key | with_key ) )=> multiset_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( as_key type_spec )? | concatenation_wrapper as_key type_spec )
        	        {
        	            int alt269=2;
        	            {
        	                int LA269_0 = this->LA(1);
        	                if ( (LA269_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA269_1 = this->LA(2);
        	                        if ( (( ((equalsIgnoreCase(LT(1)->getText(), "MULTISET"))) && (this->msynpred( antlr3::ClassForwarder<synpred49_PLSQL_DMLParser>() )) )))
        	                        {
        	                            alt269=1;
        	                        }
        	                        else if ( (true))
        	                        {
        	                            alt269=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 269 );
        	                            ex->set_state( 1 );


        	                            goto rulestandard_functionEx;

        	                        }
        	                    }
        	                }
        	                else if ( (LA269_0 == APPROXIMATE_NUM_LIT || LA269_0 == BINDVAR || ((LA269_0 >= CHAR_STRING) && (LA269_0 <= COLON)) || LA269_0 == DELIMITED_ID || LA269_0 == EXACT_NUM_LIT || LA269_0 == INTRODUCER || LA269_0 == LEFT_PAREN || ((LA269_0 >= MINUS_SIGN) && (LA269_0 <= NATIONAL_CHAR_STRING_LIT)) || LA269_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA269_0 == PLUS_SIGN || LA269_0 == SQL92_RESERVED_ALL || LA269_0 == SQL92_RESERVED_ANY || LA269_0 == SQL92_RESERVED_CASE || LA269_0 == SQL92_RESERVED_DATE || LA269_0 == SQL92_RESERVED_DEFAULT || LA269_0 == SQL92_RESERVED_DISTINCT || ((LA269_0 >= SQL92_RESERVED_EXISTS) && (LA269_0 <= SQL92_RESERVED_FALSE)) || LA269_0 == SQL92_RESERVED_NULL || LA269_0 == SQL92_RESERVED_PRIOR || LA269_0 == SQL92_RESERVED_TRUE || LA269_0 == UNSIGNED_INTEGER))
        	                {
        	                    alt269=2;
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 269 );
        	                    ex->set_state( 0 );


        	                    goto rulestandard_functionEx;

        	                }
        	            }
        	            switch (alt269)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:868:12: ( multiset_key ( LEFT_PAREN )+ ( select_key | with_key ) )=> multiset_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( as_key type_spec )?
        	        	    {
        	        	        this->followPush(FOLLOW_multiset_key_in_standard_function7445);
        	        	        m_gPLSQLParser->multiset_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function7447);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_subquery_in_standard_function7449);
        	        	        subquery();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQL_DMLParser.g:868:97: ( order_by_clause )?
        	        	        {
        	        	            int alt267=2;
        	        	            {
        	        	                int LA267_0 = this->LA(1);
        	        	                if ( (LA267_0 == SQL92_RESERVED_ORDER))
        	        	                {
        	        	                    alt267=1;
        	        	                }
        	        	            }
        	        	            switch (alt267)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:868:97: order_by_clause
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_order_by_clause_in_standard_function7451);
        	        	        	        order_by_clause();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function7454);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQL_DMLParser.g:869:12: ( as_key type_spec )?
        	        	        {
        	        	            int alt268=2;
        	        	            {
        	        	                int LA268_0 = this->LA(1);
        	        	                if ( (LA268_0 == SQL92_RESERVED_AS))
        	        	                {
        	        	                    alt268=1;
        	        	                }
        	        	            }
        	        	            switch (alt268)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:869:13: as_key type_spec
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_as_key_in_standard_function7468);
        	        	        	        m_gPLSQLParser->as_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        this->followPush(FOLLOW_type_spec_in_standard_function7470);
        	        	        	        m_gPLSQLParser->type_spec();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:870:19: concatenation_wrapper as_key type_spec
        	        	    {
        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function7492);
        	        	        concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_as_key_in_standard_function7494);
        	        	        m_gPLSQLParser->as_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_type_spec_in_standard_function7496);
        	        	        m_gPLSQLParser->type_spec();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function7528);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQL_DMLParser.g:873:10: chr_key LEFT_PAREN concatenation_wrapper using_key nchar_cs_key RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_chr_key_in_standard_function7539);
        	        m_gPLSQLParser->chr_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function7553);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function7572);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_using_key_in_standard_function7574);
        	        m_gPLSQLParser->using_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_nchar_cs_key_in_standard_function7576);
        	        m_gPLSQLParser->nchar_cs_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function7591);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // PLSQL_DMLParser.g:877:10: collect_key LEFT_PAREN ( distinct_key | unique_key )? concatenation_wrapper ( collect_order_by_part )? RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_collect_key_in_standard_function7602);
        	        m_gPLSQLParser->collect_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function7616);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:879:17: ( distinct_key | unique_key )?
        	        {
        	            int alt270=3;
        	            {
        	                int LA270_0 = this->LA(1);
        	                if ( (LA270_0 == SQL92_RESERVED_DISTINCT))
        	                {
        	                    alt270=1;
        	                }
        	                else if ( (LA270_0 == SQL92_RESERVED_UNIQUE))
        	                {
        	                    alt270=2;
        	                }
        	            }
        	            switch (alt270)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:879:18: distinct_key
        	        	    {
        	        	        this->followPush(FOLLOW_distinct_key_in_standard_function7636);
        	        	        m_gPLSQLParser->distinct_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:879:31: unique_key
        	        	    {
        	        	        this->followPush(FOLLOW_unique_key_in_standard_function7638);
        	        	        m_gPLSQLParser->unique_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function7642);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:879:66: ( collect_order_by_part )?
        	        {
        	            int alt271=2;
        	            {
        	                int LA271_0 = this->LA(1);
        	                if ( (LA271_0 == SQL92_RESERVED_ORDER))
        	                {
        	                    alt271=1;
        	                }
        	            }
        	            switch (alt271)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:879:66: collect_order_by_part
        	        	    {
        	        	        this->followPush(FOLLOW_collect_order_by_part_in_standard_function7644);
        	        	        collect_order_by_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function7659);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 7:
        	    // PLSQL_DMLParser.g:881:10: stantard_function_enabling_within_or_over function_argument ( within_or_over_part )+
        	    {
        	        this->followPush(FOLLOW_stantard_function_enabling_within_or_over_in_standard_function7670);
        	        stantard_function_enabling_within_or_over();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_function_argument_in_standard_function7685);
        	        m_gPLSQLParser->function_argument();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:882:31: ( within_or_over_part )+
        	        {
        	            int cnt272=0;

        	            for (;;)
        	            {
        	                int alt272=2;
        	        	{
        	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	        	    */
        	        	    int LA272_0 = this->LA(1);
        	        	    if ( (LA272_0 == REGULAR_ID))
        	        	    {
        	        	        {
        	        	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	        	            */
        	        	            int LA272_1 = this->LA(2);
        	        	            if ( (LA272_1 == LEFT_PAREN))
        	        	            {
        	        	                {
        	        	                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	        	                    */
        	        	                    int LA272_3 = this->LA(3);
        	        	                    if ( (LA272_3 == REGULAR_ID))
        	        	                    {
        	        	                        {
        	        	                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	        	                            */
        	        	                            int LA272_13 = this->LA(4);
        	        	                            if ( (LA272_13 == SQL92_RESERVED_BY) && ((equalsIgnoreCase(LT(1)->getText(), "OVER"))))
        	        	                            {
        	        	                                alt272=1;
        	        	                            }

        	        	                        }
        	        	                    }
        	        	                    else if ( (LA272_3 == RIGHT_PAREN || LA272_3 == SQL92_RESERVED_ORDER) && ((equalsIgnoreCase(LT(1)->getText(), "OVER"))))
        	        	                    {
        	        	                        alt272=1;
        	        	                    }

        	        	                }
        	        	            }
        	        	            else if ( (LA272_1 == SQL92_RESERVED_GROUP))
        	        	            {
        	        	                {
        	        	                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	        	                    */
        	        	                    int LA272_4 = this->LA(3);
        	        	                    if ( (LA272_4 == LEFT_PAREN) && ((equalsIgnoreCase(LT(1)->getText(), "WITHIN"))))
        	        	                    {
        	        	                        alt272=1;
        	        	                    }

        	        	                }
        	        	            }

        	        	        }
        	        	    }

        	        	}
        	        	switch (alt272)
        	        	{
        	        	    case 1:
        	        	        // PLSQL_DMLParser.g:882:31: within_or_over_part
        	        	        {
        	        	            this->followPush(FOLLOW_within_or_over_part_in_standard_function7687);
        	        	            within_or_over_part();

        	        	            this->followPop();
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulestandard_functionEx;
        	        	            }
        	        	            if (this->hasFailed())
        	        	            {
        	        	                return ;
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt272 >= 1 )
        	        		{
        	        		    goto loop272;
        	        		}
        	        		if (this->get_backtracking()>0)
        	        		{
        	        		    this->set_failedflag( true );
        	        		    return ;
        	        		}

        	        		/* mismatchedSetEx()
        	        		 */
        	        		new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        	        		goto rulestandard_functionEx;
        	        	}
        	        	cnt272++;
        	            }
        	            loop272: ;	/* Jump to here if this rule does not match */
        	        }

        	    }
        	    break;
        	case 8:
        	    // PLSQL_DMLParser.g:883:10: decompose_key LEFT_PAREN concatenation_wrapper ( canonical_key | compatibility_key )? RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_decompose_key_in_standard_function7699);
        	        m_gPLSQLParser->decompose_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function7713);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function7732);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:885:39: ( canonical_key | compatibility_key )?
        	        {
        	            int alt273=3;
        	            {
        	                int LA273_0 = this->LA(1);
        	                if ( (LA273_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "COMPATIBILITY")))||((equalsIgnoreCase(LT(1)->getText(), "CANONICAL"))))))
        	                {
        	                    {
        	                        int LA273_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "CANONICAL"))))
        	                        {
        	                            alt273=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "COMPATIBILITY"))))
        	                        {
        	                            alt273=2;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt273)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:885:40: canonical_key
        	        	    {
        	        	        this->followPush(FOLLOW_canonical_key_in_standard_function7735);
        	        	        m_gPLSQLParser->canonical_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:885:54: compatibility_key
        	        	    {
        	        	        this->followPush(FOLLOW_compatibility_key_in_standard_function7737);
        	        	        m_gPLSQLParser->compatibility_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function7754);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 9:
        	    // PLSQL_DMLParser.g:887:10: extract_key LEFT_PAREN REGULAR_ID from_key concatenation_wrapper RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_extract_key_in_standard_function7765);
        	        m_gPLSQLParser->extract_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function7779);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_standard_function7797);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_from_key_in_standard_function7799);
        	        m_gPLSQLParser->from_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function7801);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function7816);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 10:
        	    // PLSQL_DMLParser.g:891:10: ( first_value_key | last_value_key ) function_argument_analytic ( respect_or_ignore_nulls )? over_clause
        	    {
        	        // PLSQL_DMLParser.g:891:10: ( first_value_key | last_value_key )
        	        {
        	            int alt274=2;
        	            {
        	                int LA274_0 = this->LA(1);
        	                if ( (LA274_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FIRST_VALUE")))||((equalsIgnoreCase(LT(1)->getText(), "LAST_VALUE"))))))
        	                {
        	                    {
        	                        int LA274_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "FIRST_VALUE"))))
        	                        {
        	                            alt274=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "LAST_VALUE"))))
        	                        {
        	                            alt274=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 274 );
        	                            ex->set_state( 1 );


        	                            goto rulestandard_functionEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 274 );
        	                    ex->set_state( 0 );


        	                    goto rulestandard_functionEx;

        	                }
        	            }
        	            switch (alt274)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:891:11: first_value_key
        	        	    {
        	        	        this->followPush(FOLLOW_first_value_key_in_standard_function7828);
        	        	        m_gPLSQLParser->first_value_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:891:27: last_value_key
        	        	    {
        	        	        this->followPush(FOLLOW_last_value_key_in_standard_function7830);
        	        	        m_gPLSQLParser->last_value_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_function_argument_analytic_in_standard_function7833);
        	        m_gPLSQLParser->function_argument_analytic();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:892:14: ( respect_or_ignore_nulls )?
        	        {
        	            int alt275=2;
        	            {
        	                int LA275_0 = this->LA(1);
        	                if ( (LA275_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "OVER")))||((equalsIgnoreCase(LT(1)->getText(), "RESPECT"))))))
        	                {
        	                    {
        	                        int LA275_1 = this->LA(2);
        	                        if ( (LA275_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "RESPECT"))))))
        	                        {
        	                            alt275=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt275)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:892:14: respect_or_ignore_nulls
        	        	    {
        	        	        this->followPush(FOLLOW_respect_or_ignore_nulls_in_standard_function7848);
        	        	        m_gPLSQLParser->respect_or_ignore_nulls();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_over_clause_in_standard_function7851);
        	        over_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 11:
        	    // PLSQL_DMLParser.g:893:10: stantard_function_pedictions LEFT_PAREN expression_wrapper ( COMMA expression_wrapper )* ( cost_matrix_clause )? ( using_clause )? RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_stantard_function_pedictions_in_standard_function7862);
        	        stantard_function_pedictions();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function7876);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function7894);
        	        expression_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:895:36: ( COMMA expression_wrapper )*

        	        for (;;)
        	        {
        	            int alt276=2;
        	            {
        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                */
        	                int LA276_0 = this->LA(1);
        	                if ( (LA276_0 == COMMA))
        	                {
        	                    alt276=1;
        	                }

        	            }
        	            switch (alt276)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:895:37: COMMA expression_wrapper
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function7897);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function7899);
        	        	        expression_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop276;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop276: ; /* Jump out to here if this rule does not match */


        	        // PLSQL_DMLParser.g:895:64: ( cost_matrix_clause )?
        	        {
        	            int alt277=2;
        	            {
        	                int LA277_0 = this->LA(1);
        	                if ( (LA277_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "COST"))))
        	                {
        	                    alt277=1;
        	                }
        	            }
        	            switch (alt277)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:895:64: cost_matrix_clause
        	        	    {
        	        	        this->followPush(FOLLOW_cost_matrix_clause_in_standard_function7903);
        	        	        cost_matrix_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:895:84: ( using_clause )?
        	        {
        	            int alt278=2;
        	            {
        	                int LA278_0 = this->LA(1);
        	                if ( (LA278_0 == PLSQL_NON_RESERVED_USING))
        	                {
        	                    alt278=1;
        	                }
        	            }
        	            switch (alt278)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:895:84: using_clause
        	        	    {
        	        	        this->followPush(FOLLOW_using_clause_in_standard_function7906);
        	        	        using_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function7922);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 12:
        	    // PLSQL_DMLParser.g:897:10: translate_key LEFT_PAREN expression_wrapper ( using_key ( char_cs_key | nchar_cs_key ) )? ( COMMA expression_wrapper )* RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_translate_key_in_standard_function7933);
        	        m_gPLSQLParser->translate_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function7947);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function7966);
        	        expression_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:899:36: ( using_key ( char_cs_key | nchar_cs_key ) )?
        	        {
        	            int alt280=2;
        	            {
        	                int LA280_0 = this->LA(1);
        	                if ( (LA280_0 == PLSQL_NON_RESERVED_USING))
        	                {
        	                    alt280=1;
        	                }
        	            }
        	            switch (alt280)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:899:37: using_key ( char_cs_key | nchar_cs_key )
        	        	    {
        	        	        this->followPush(FOLLOW_using_key_in_standard_function7969);
        	        	        m_gPLSQLParser->using_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQL_DMLParser.g:899:47: ( char_cs_key | nchar_cs_key )
        	        	        {
        	        	            int alt279=2;
        	        	            {
        	        	                int LA279_0 = this->LA(1);
        	        	                if ( (LA279_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "CHAR_CS")))||((equalsIgnoreCase(LT(1)->getText(), "NCHAR_CS"))))))
        	        	                {
        	        	                    {
        	        	                        int LA279_1 = this->LA(2);
        	        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "CHAR_CS"))))
        	        	                        {
        	        	                            alt279=1;
        	        	                        }
        	        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NCHAR_CS"))))
        	        	                        {
        	        	                            alt279=2;
        	        	                        }
        	        	                        else
        	        	                        {
        	        	                            if (this->get_backtracking()>0)
        	        	                            {
        	        	                                this->set_failedflag( true );
        	        	                                return ;
        	        	                            }


        	        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                            ex->set_decisionNum( 279 );
        	        	                            ex->set_state( 1 );


        	        	                            goto rulestandard_functionEx;

        	        	                        }
        	        	                    }
        	        	                }
        	        	                else
        	        	                {
        	        	                    if (this->get_backtracking()>0)
        	        	                    {
        	        	                        this->set_failedflag( true );
        	        	                        return ;
        	        	                    }


        	        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                    ex->set_decisionNum( 279 );
        	        	                    ex->set_state( 0 );


        	        	                    goto rulestandard_functionEx;

        	        	                }
        	        	            }
        	        	            switch (alt279)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:899:48: char_cs_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_char_cs_key_in_standard_function7972);
        	        	        	        m_gPLSQLParser->char_cs_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // PLSQL_DMLParser.g:899:60: nchar_cs_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_nchar_cs_key_in_standard_function7974);
        	        	        	        m_gPLSQLParser->nchar_cs_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:900:21: ( COMMA expression_wrapper )*

        	        for (;;)
        	        {
        	            int alt281=2;
        	            {
        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                */
        	                int LA281_0 = this->LA(1);
        	                if ( (LA281_0 == COMMA))
        	                {
        	                    alt281=1;
        	                }

        	            }
        	            switch (alt281)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:900:22: COMMA expression_wrapper
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function8001);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function8003);
        	        	        expression_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop281;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop281: ; /* Jump out to here if this rule does not match */


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8020);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 13:
        	    // PLSQL_DMLParser.g:902:10: treat_key LEFT_PAREN expression_wrapper as_key ( ref_key )? type_spec RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_treat_key_in_standard_function8031);
        	        m_gPLSQLParser->treat_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8045);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function8063);
        	        expression_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_as_key_in_standard_function8065);
        	        m_gPLSQLParser->as_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:904:43: ( ref_key )?
        	        {
        	            int alt282=2;
        	            {
        	                int LA282_0 = this->LA(1);
        	                if ( (LA282_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA282_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "REF"))))
        	                        {
        	                            alt282=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt282)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:904:43: ref_key
        	        	    {
        	        	        this->followPush(FOLLOW_ref_key_in_standard_function8067);
        	        	        m_gPLSQLParser->ref_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_type_spec_in_standard_function8070);
        	        m_gPLSQLParser->type_spec();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8085);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 14:
        	    // PLSQL_DMLParser.g:906:10: trim_key LEFT_PAREN ( ( leading_key | trailing_key | both_key )? ( quoted_string )? from_key )? concatenation_wrapper RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_trim_key_in_standard_function8096);
        	        m_gPLSQLParser->trim_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8110);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:908:17: ( ( leading_key | trailing_key | both_key )? ( quoted_string )? from_key )?
        	        {
        	            int alt285=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    int LA285_1 = this->LA(2);
        	                		    if ( (((LA285_1 >= CHAR_STRING) && (LA285_1 <= CHAR_STRING_PERL)) || LA285_1 == NATIONAL_CHAR_STRING_LIT))
        	                		    {
        	                		        {
        	                		            int LA285_5 = this->LA(3);
        	                		            if ( (LA285_5 == SQL92_RESERVED_FROM))
        	                		            {
        	                		                alt285=1;
        	                		            }
        	                		        }
        	                		    }
        	                		    else if ( (LA285_1 == SQL92_RESERVED_FROM))
        	                		    {
        	                		        alt285=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	                case CHAR_STRING:
        	                case CHAR_STRING_PERL:
        	                case NATIONAL_CHAR_STRING_LIT:
        	                	{
        	                		{
        	                		    int LA285_2 = this->LA(2);
        	                		    if ( (LA285_2 == SQL92_RESERVED_FROM))
        	                		    {
        	                		        alt285=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	                case SQL92_RESERVED_FROM:
        	                	{
        	                		alt285=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt285)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:908:18: ( leading_key | trailing_key | both_key )? ( quoted_string )? from_key
        	        	    {
        	        	        // PLSQL_DMLParser.g:908:18: ( leading_key | trailing_key | both_key )?
        	        	        {
        	        	            int alt283=4;
        	        	            {
        	        	                int LA283_0 = this->LA(1);
        	        	                if ( (LA283_0 == REGULAR_ID))
        	        	                {
        	        	                    {
        	        	                        int LA283_1 = this->LA(2);
        	        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "LEADING"))))
        	        	                        {
        	        	                            alt283=1;
        	        	                        }
        	        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "TRAILING"))))
        	        	                        {
        	        	                            alt283=2;
        	        	                        }
        	        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "BOTH"))))
        	        	                        {
        	        	                            alt283=3;
        	        	                        }
        	        	                    }
        	        	                }
        	        	            }
        	        	            switch (alt283)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:908:19: leading_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_leading_key_in_standard_function8131);
        	        	        	        m_gPLSQLParser->leading_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // PLSQL_DMLParser.g:908:31: trailing_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_trailing_key_in_standard_function8133);
        	        	        	        m_gPLSQLParser->trailing_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 3:
        	        	        	    // PLSQL_DMLParser.g:908:44: both_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_both_key_in_standard_function8135);
        	        	        	        m_gPLSQLParser->both_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        // PLSQL_DMLParser.g:908:55: ( quoted_string )?
        	        	        {
        	        	            int alt284=2;
        	        	            {
        	        	                int LA284_0 = this->LA(1);
        	        	                if ( (((LA284_0 >= CHAR_STRING) && (LA284_0 <= CHAR_STRING_PERL)) || LA284_0 == NATIONAL_CHAR_STRING_LIT))
        	        	                {
        	        	                    alt284=1;
        	        	                }
        	        	            }
        	        	            switch (alt284)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:908:55: quoted_string
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_quoted_string_in_standard_function8139);
        	        	        	        m_gPLSQLParser->quoted_string();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        this->followPush(FOLLOW_from_key_in_standard_function8142);
        	        	        m_gPLSQLParser->from_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function8162);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8176);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 15:
        	    // PLSQL_DMLParser.g:911:10: xmlagg_key LEFT_PAREN expression_wrapper ( order_by_clause )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        this->followPush(FOLLOW_xmlagg_key_in_standard_function8187);
        	        m_gPLSQLParser->xmlagg_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8201);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function8220);
        	        expression_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:913:36: ( order_by_clause )?
        	        {
        	            int alt286=2;
        	            {
        	                int LA286_0 = this->LA(1);
        	                if ( (LA286_0 == SQL92_RESERVED_ORDER))
        	                {
        	                    alt286=1;
        	                }
        	            }
        	            switch (alt286)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:913:36: order_by_clause
        	        	    {
        	        	        this->followPush(FOLLOW_order_by_clause_in_standard_function8222);
        	        	        order_by_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8238);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:915:13: ( PERIOD general_element_part )?
        	        {
        	            int alt287=2;
        	            {
        	                int LA287_0 = this->LA(1);
        	                if ( (LA287_0 == PERIOD))
        	                {
        	                    alt287=1;
        	                }
        	            }
        	            switch (alt287)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:915:14: PERIOD general_element_part
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function8253);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function8255);
        	        	        m_gPLSQLParser->general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 16:
        	    // PLSQL_DMLParser.g:916:10: ( xmlcolattval_key | xmlforest_key ) LEFT_PAREN xml_multiuse_expression_element ( COMMA xml_multiuse_expression_element )* RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        // PLSQL_DMLParser.g:916:10: ( xmlcolattval_key | xmlforest_key )
        	        {
        	            int alt288=2;
        	            {
        	                int LA288_0 = this->LA(1);
        	                if ( (LA288_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "XMLFOREST")))||((equalsIgnoreCase(LT(1)->getText(), "XMLCOLATTVAL"))))))
        	                {
        	                    {
        	                        int LA288_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLCOLATTVAL"))))
        	                        {
        	                            alt288=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLFOREST"))))
        	                        {
        	                            alt288=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 288 );
        	                            ex->set_state( 1 );


        	                            goto rulestandard_functionEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 288 );
        	                    ex->set_state( 0 );


        	                    goto rulestandard_functionEx;

        	                }
        	            }
        	            switch (alt288)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:916:11: xmlcolattval_key
        	        	    {
        	        	        this->followPush(FOLLOW_xmlcolattval_key_in_standard_function8269);
        	        	        m_gPLSQLParser->xmlcolattval_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:916:28: xmlforest_key
        	        	    {
        	        	        this->followPush(FOLLOW_xmlforest_key_in_standard_function8271);
        	        	        m_gPLSQLParser->xmlforest_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8287);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_xml_multiuse_expression_element_in_standard_function8305);
        	        xml_multiuse_expression_element();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:918:49: ( COMMA xml_multiuse_expression_element )*

        	        for (;;)
        	        {
        	            int alt289=2;
        	            {
        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                */
        	                int LA289_0 = this->LA(1);
        	                if ( (LA289_0 == COMMA))
        	                {
        	                    alt289=1;
        	                }

        	            }
        	            switch (alt289)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:918:50: COMMA xml_multiuse_expression_element
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function8308);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_xml_multiuse_expression_element_in_standard_function8310);
        	        	        xml_multiuse_expression_element();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop289;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop289: ; /* Jump out to here if this rule does not match */


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8326);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:920:13: ( PERIOD general_element_part )?
        	        {
        	            int alt290=2;
        	            {
        	                int LA290_0 = this->LA(1);
        	                if ( (LA290_0 == PERIOD))
        	                {
        	                    alt290=1;
        	                }
        	            }
        	            switch (alt290)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:920:14: PERIOD general_element_part
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function8341);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function8343);
        	        	        m_gPLSQLParser->general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 17:
        	    // PLSQL_DMLParser.g:921:10: xmlelement_key LEFT_PAREN ( entityescaping_key | noentityescaping_key )? ( name_key | evalname_key )? expression_wrapper ({...}? COMMA xml_attributes_clause )? ( COMMA expression_wrapper ( column_alias )? )* RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        this->followPush(FOLLOW_xmlelement_key_in_standard_function8356);
        	        m_gPLSQLParser->xmlelement_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8370);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:923:17: ( entityescaping_key | noentityescaping_key )?
        	        {
        	            int alt291=3;
        	            {
        	                int LA291_0 = this->LA(1);
        	                if ( (LA291_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA291_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "ENTITYESCAPING"))))
        	                        {
        	                            alt291=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NOENTITYESCAPING"))))
        	                        {
        	                            alt291=2;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt291)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:923:18: entityescaping_key
        	        	    {
        	        	        this->followPush(FOLLOW_entityescaping_key_in_standard_function8389);
        	        	        m_gPLSQLParser->entityescaping_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:923:37: noentityescaping_key
        	        	    {
        	        	        this->followPush(FOLLOW_noentityescaping_key_in_standard_function8391);
        	        	        m_gPLSQLParser->noentityescaping_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:924:17: ( name_key | evalname_key )?
        	        {
        	            int alt292=3;
        	            {
        	                int LA292_0 = this->LA(1);
        	                if ( (LA292_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA292_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "NAME"))))
        	                        {
        	                            alt292=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "EVALNAME"))))
        	                        {
        	                            alt292=2;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt292)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:924:18: name_key
        	        	    {
        	        	        this->followPush(FOLLOW_name_key_in_standard_function8412);
        	        	        m_gPLSQLParser->name_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:924:27: evalname_key
        	        	    {
        	        	        this->followPush(FOLLOW_evalname_key_in_standard_function8414);
        	        	        m_gPLSQLParser->evalname_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function8418);
        	        expression_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:925:17: ({...}? COMMA xml_attributes_clause )?
        	        {
        	            int alt293=2;
        	            {
        	                int LA293_0 = this->LA(1);
        	                if ( (LA293_0 == COMMA))
        	                {
        	                    {
        	                        int LA293_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(2)->getText(), "XMLATTRIBUTES"))))
        	                        {
        	                            alt293=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt293)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:925:18: {...}? COMMA xml_attributes_clause
        	        	    {
        	        	        if ( !((equalsIgnoreCase(LT(2)->getText(), "XMLATTRIBUTES"))) )
        	        	        {
        	        	            if (this->get_backtracking()>0)
        	        	            {
        	        	                this->set_failedflag( true );
        	        	                return ;
        	        	            }

        	        	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(2)->getText(), \"XMLATTRIBUTES\")" );
        	        	                ex->set_ruleName( "standard_function" );


        	        	        }

        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function8439);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_xml_attributes_clause_in_standard_function8441);
        	        	        xml_attributes_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:926:17: ( COMMA expression_wrapper ( column_alias )? )*

        	        for (;;)
        	        {
        	            int alt295=2;
        	            {
        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	                */
        	                int LA295_0 = this->LA(1);
        	                if ( (LA295_0 == COMMA))
        	                {
        	                    alt295=1;
        	                }

        	            }
        	            switch (alt295)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:926:18: COMMA expression_wrapper ( column_alias )?
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function8462);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function8464);
        	        	        expression_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQL_DMLParser.g:926:43: ( column_alias )?
        	        	        {
        	        	            int alt294=2;
        	        	            {
        	        	                int LA294_0 = this->LA(1);
        	        	                if ( (((LA294_0 >= CHAR_STRING) && (LA294_0 <= CHAR_STRING_PERL)) || LA294_0 == DELIMITED_ID || LA294_0 == INTRODUCER || LA294_0 == NATIONAL_CHAR_STRING_LIT || LA294_0 == REGULAR_ID || LA294_0 == SQL92_RESERVED_AS))
        	        	                {
        	        	                    alt294=1;
        	        	                }
        	        	            }
        	        	            switch (alt294)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:926:43: column_alias
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_column_alias_in_standard_function8466);
        	        	        	        m_gPLSQLParser->column_alias();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop295;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop295: ; /* Jump out to here if this rule does not match */


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8483);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:928:13: ( PERIOD general_element_part )?
        	        {
        	            int alt296=2;
        	            {
        	                int LA296_0 = this->LA(1);
        	                if ( (LA296_0 == PERIOD))
        	                {
        	                    alt296=1;
        	                }
        	            }
        	            switch (alt296)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:928:14: PERIOD general_element_part
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function8498);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function8500);
        	        	        m_gPLSQLParser->general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 18:
        	    // PLSQL_DMLParser.g:929:10: xmlexists_key LEFT_PAREN expression_wrapper ( xml_passing_clause )? RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_xmlexists_key_in_standard_function8513);
        	        m_gPLSQLParser->xmlexists_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8527);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function8545);
        	        expression_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:932:17: ( xml_passing_clause )?
        	        {
        	            int alt297=2;
        	            {
        	                int LA297_0 = this->LA(1);
        	                if ( (LA297_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "PASSING"))))
        	                {
        	                    alt297=1;
        	                }
        	            }
        	            switch (alt297)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:932:17: xml_passing_clause
        	        	    {
        	        	        this->followPush(FOLLOW_xml_passing_clause_in_standard_function8563);
        	        	        xml_passing_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8578);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 19:
        	    // PLSQL_DMLParser.g:934:10: xmlparse_key LEFT_PAREN ( document_key | content_key ) concatenation_wrapper ( wellformed_key )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        this->followPush(FOLLOW_xmlparse_key_in_standard_function8589);
        	        m_gPLSQLParser->xmlparse_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8603);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:936:17: ( document_key | content_key )
        	        {
        	            int alt298=2;
        	            {
        	                int LA298_0 = this->LA(1);
        	                if ( (LA298_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "DOCUMENT")))||((equalsIgnoreCase(LT(1)->getText(), "CONTENT"))))))
        	                {
        	                    {
        	                        int LA298_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "DOCUMENT"))))
        	                        {
        	                            alt298=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "CONTENT"))))
        	                        {
        	                            alt298=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 298 );
        	                            ex->set_state( 1 );


        	                            goto rulestandard_functionEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 298 );
        	                    ex->set_state( 0 );


        	                    goto rulestandard_functionEx;

        	                }
        	            }
        	            switch (alt298)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:936:18: document_key
        	        	    {
        	        	        this->followPush(FOLLOW_document_key_in_standard_function8623);
        	        	        m_gPLSQLParser->document_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:936:31: content_key
        	        	    {
        	        	        this->followPush(FOLLOW_content_key_in_standard_function8625);
        	        	        m_gPLSQLParser->content_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function8628);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:936:66: ( wellformed_key )?
        	        {
        	            int alt299=2;
        	            {
        	                int LA299_0 = this->LA(1);
        	                if ( (LA299_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "WELLFORMED"))))
        	                {
        	                    alt299=1;
        	                }
        	            }
        	            switch (alt299)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:936:66: wellformed_key
        	        	    {
        	        	        this->followPush(FOLLOW_wellformed_key_in_standard_function8630);
        	        	        m_gPLSQLParser->wellformed_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8645);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:938:13: ( PERIOD general_element_part )?
        	        {
        	            int alt300=2;
        	            {
        	                int LA300_0 = this->LA(1);
        	                if ( (LA300_0 == PERIOD))
        	                {
        	                    alt300=1;
        	                }
        	            }
        	            switch (alt300)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:938:14: PERIOD general_element_part
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function8660);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function8662);
        	        	        m_gPLSQLParser->general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 20:
        	    // PLSQL_DMLParser.g:939:10: xmlpi_key LEFT_PAREN ( name_key id | evalname_key concatenation_wrapper ) ( COMMA concatenation_wrapper )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        this->followPush(FOLLOW_xmlpi_key_in_standard_function8675);
        	        m_gPLSQLParser->xmlpi_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8689);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:941:17: ( name_key id | evalname_key concatenation_wrapper )
        	        {
        	            int alt301=2;
        	            alt301 = cdfa301.predict(this, this->get_rec(), this->get_istream(), cdfa301 );
        	            if  (this->hasException())
        	            {
        	                goto rulestandard_functionEx;
        	            }
        	            if (this->hasFailed())
        	            {
        	                return ;
        	            }

        	            switch (alt301)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:941:22: name_key id
        	        	    {
        	        	        this->followPush(FOLLOW_name_key_in_standard_function8713);
        	        	        m_gPLSQLParser->name_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_id_in_standard_function8715);
        	        	        m_gPLSQLParser->id();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:942:22: evalname_key concatenation_wrapper
        	        	    {
        	        	        this->followPush(FOLLOW_evalname_key_in_standard_function8738);
        	        	        m_gPLSQLParser->evalname_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function8740);
        	        	        concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:944:17: ( COMMA concatenation_wrapper )?
        	        {
        	            int alt302=2;
        	            {
        	                int LA302_0 = this->LA(1);
        	                if ( (LA302_0 == COMMA))
        	                {
        	                    alt302=1;
        	                }
        	            }
        	            switch (alt302)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:944:18: COMMA concatenation_wrapper
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function8777);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function8779);
        	        	        concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8795);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:946:13: ( PERIOD general_element_part )?
        	        {
        	            int alt303=2;
        	            {
        	                int LA303_0 = this->LA(1);
        	                if ( (LA303_0 == PERIOD))
        	                {
        	                    alt303=1;
        	                }
        	            }
        	            switch (alt303)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:946:14: PERIOD general_element_part
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function8810);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function8812);
        	        	        m_gPLSQLParser->general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 21:
        	    // PLSQL_DMLParser.g:947:10: xmlquery_key LEFT_PAREN concatenation_wrapper ( xml_passing_clause )? returning_key content_key ( null_key on_key empty_key )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        this->followPush(FOLLOW_xmlquery_key_in_standard_function8825);
        	        m_gPLSQLParser->xmlquery_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8839);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function8858);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:949:39: ( xml_passing_clause )?
        	        {
        	            int alt304=2;
        	            {
        	                int LA304_0 = this->LA(1);
        	                if ( (LA304_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "RETURNING")))||((equalsIgnoreCase(LT(1)->getText(), "PASSING"))))))
        	                {
        	                    {
        	                        int LA304_1 = this->LA(2);
        	                        if ( (LA304_1 == APPROXIMATE_NUM_LIT || LA304_1 == BINDVAR || ((LA304_1 >= CHAR_STRING) && (LA304_1 <= COLON)) || LA304_1 == DELIMITED_ID || LA304_1 == EXACT_NUM_LIT || LA304_1 == INTRODUCER || LA304_1 == LEFT_PAREN || ((LA304_1 >= MINUS_SIGN) && (LA304_1 <= NATIONAL_CHAR_STRING_LIT)) || LA304_1 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA304_1 == PLUS_SIGN || LA304_1 == SQL92_RESERVED_ALL || LA304_1 == SQL92_RESERVED_ANY || ((LA304_1 >= SQL92_RESERVED_BY) && (LA304_1 <= SQL92_RESERVED_CASE)) || ((LA304_1 >= SQL92_RESERVED_CURSOR) && (LA304_1 <= SQL92_RESERVED_DATE)) || LA304_1 == SQL92_RESERVED_DEFAULT || LA304_1 == SQL92_RESERVED_DISTINCT || ((LA304_1 >= SQL92_RESERVED_EXISTS) && (LA304_1 <= SQL92_RESERVED_FALSE)) || ((LA304_1 >= SQL92_RESERVED_NOT) && (LA304_1 <= SQL92_RESERVED_NULL)) || LA304_1 == SQL92_RESERVED_PRIOR || LA304_1 == SQL92_RESERVED_TRUE || LA304_1 == UNSIGNED_INTEGER) && ((equalsIgnoreCase(LT(1)->getText(), "PASSING"))))
        	                        {
        	                            alt304=1;
        	                        }
        	                        else if ( (LA304_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "RETURNING")))||((equalsIgnoreCase(LT(1)->getText(), "PASSING"))))))
        	                        {
        	                            {
        	                                int LA304_3 = this->LA(3);
        	                                if ( (LA304_3 == APPROXIMATE_NUM_LIT || LA304_3 == ASTERISK || LA304_3 == BINDVAR || ((LA304_3 >= CARRET_OPERATOR_PART) && (LA304_3 <= COMMA)) || ((LA304_3 >= CONCATENATION_OP) && (LA304_3 <= DELIMITED_ID)) || ((LA304_3 >= EQUALS_OP) && (LA304_3 <= EXCLAMATION_OPERATOR_PART)) || ((LA304_3 >= GREATER_THAN_OP) && (LA304_3 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA304_3 >= INTRODUCER) && (LA304_3 <= NATIONAL_CHAR_STRING_LIT)) || LA304_3 == NOT_EQUAL_OP || ((LA304_3 >= PERIOD) && (LA304_3 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA304_3 == PLUS_SIGN || LA304_3 == REGULAR_ID || LA304_3 == SOLIDUS || LA304_3 == SQL92_RESERVED_ALL || ((LA304_3 >= SQL92_RESERVED_AND) && (LA304_3 <= SQL92_RESERVED_AS)) || LA304_3 == SQL92_RESERVED_BETWEEN || LA304_3 == SQL92_RESERVED_CASE || LA304_3 == SQL92_RESERVED_DATE || LA304_3 == SQL92_RESERVED_DEFAULT || LA304_3 == SQL92_RESERVED_DISTINCT || ((LA304_3 >= SQL92_RESERVED_EXISTS) && (LA304_3 <= SQL92_RESERVED_FALSE)) || LA304_3 == SQL92_RESERVED_IN || ((LA304_3 >= SQL92_RESERVED_IS) && (LA304_3 <= SQL92_RESERVED_NOT)) || LA304_3 == SQL92_RESERVED_OR || LA304_3 == SQL92_RESERVED_PRIOR || LA304_3 == SQL92_RESERVED_TRUE || ((LA304_3 >= UNSIGNED_INTEGER) && (LA304_3 <= VERTICAL_BAR))) && ((equalsIgnoreCase(LT(1)->getText(), "PASSING"))))
        	                                {
        	                                    alt304=1;
        	                                }
        	                                else if ( (LA304_3 == SQL92_RESERVED_NULL) && ((((equalsIgnoreCase(LT(1)->getText(), "RETURNING")))||((equalsIgnoreCase(LT(1)->getText(), "PASSING"))))))
        	                                {
        	                                    {
        	                                        int LA304_4 = this->LA(4);
        	                                        if ( (LA304_4 == ASTERISK || ((LA304_4 >= CARRET_OPERATOR_PART) && (LA304_4 <= CHAR_STRING_PERL)) || LA304_4 == COMMA || ((LA304_4 >= CONCATENATION_OP) && (LA304_4 <= DELIMITED_ID)) || LA304_4 == EQUALS_OP || LA304_4 == EXCLAMATION_OPERATOR_PART || ((LA304_4 >= GREATER_THAN_OP) && (LA304_4 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA304_4 >= INTRODUCER) && (LA304_4 <= LEFT_BRACKET)) || ((LA304_4 >= LESS_THAN_OP) && (LA304_4 <= NATIONAL_CHAR_STRING_LIT)) || LA304_4 == NOT_EQUAL_OP || LA304_4 == PLUS_SIGN || LA304_4 == REGULAR_ID || LA304_4 == SOLIDUS || LA304_4 == SQL92_RESERVED_AND || LA304_4 == SQL92_RESERVED_AS || LA304_4 == SQL92_RESERVED_BETWEEN || LA304_4 == SQL92_RESERVED_IN || ((LA304_4 >= SQL92_RESERVED_IS) && (LA304_4 <= SQL92_RESERVED_NOT)) || LA304_4 == SQL92_RESERVED_OR || LA304_4 == VERTICAL_BAR) && ((equalsIgnoreCase(LT(1)->getText(), "PASSING"))))
        	                                        {
        	                                            alt304=1;
        	                                        }
        	                                    }
        	                                }
        	                            }
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt304)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:949:39: xml_passing_clause
        	        	    {
        	        	        this->followPush(FOLLOW_xml_passing_clause_in_standard_function8860);
        	        	        xml_passing_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_returning_key_in_standard_function8879);
        	        m_gPLSQLParser->returning_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_content_key_in_standard_function8881);
        	        m_gPLSQLParser->content_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:950:43: ( null_key on_key empty_key )?
        	        {
        	            int alt305=2;
        	            {
        	                int LA305_0 = this->LA(1);
        	                if ( (LA305_0 == SQL92_RESERVED_NULL))
        	                {
        	                    alt305=1;
        	                }
        	            }
        	            switch (alt305)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:950:44: null_key on_key empty_key
        	        	    {
        	        	        this->followPush(FOLLOW_null_key_in_standard_function8884);
        	        	        m_gPLSQLParser->null_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_on_key_in_standard_function8886);
        	        	        m_gPLSQLParser->on_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_empty_key_in_standard_function8888);
        	        	        m_gPLSQLParser->empty_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8904);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:952:13: ( PERIOD general_element_part )?
        	        {
        	            int alt306=2;
        	            {
        	                int LA306_0 = this->LA(1);
        	                if ( (LA306_0 == PERIOD))
        	                {
        	                    alt306=1;
        	                }
        	            }
        	            switch (alt306)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:952:14: PERIOD general_element_part
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function8919);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function8921);
        	        	        m_gPLSQLParser->general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 22:
        	    // PLSQL_DMLParser.g:953:10: xmlroot_key LEFT_PAREN concatenation_wrapper xmlroot_param_version_part ( COMMA xmlroot_param_standalone_part )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        this->followPush(FOLLOW_xmlroot_key_in_standard_function8934);
        	        m_gPLSQLParser->xmlroot_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8948);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function8966);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_xmlroot_param_version_part_in_standard_function8988);
        	        xmlroot_param_version_part();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:957:21: ( COMMA xmlroot_param_standalone_part )?
        	        {
        	            int alt307=2;
        	            {
        	                int LA307_0 = this->LA(1);
        	                if ( (LA307_0 == COMMA))
        	                {
        	                    alt307=1;
        	                }
        	            }
        	            switch (alt307)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:957:22: COMMA xmlroot_param_standalone_part
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function9011);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_xmlroot_param_standalone_part_in_standard_function9013);
        	        	        xmlroot_param_standalone_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function9029);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:959:13: ( PERIOD general_element_part )?
        	        {
        	            int alt308=2;
        	            {
        	                int LA308_0 = this->LA(1);
        	                if ( (LA308_0 == PERIOD))
        	                {
        	                    alt308=1;
        	                }
        	            }
        	            switch (alt308)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:959:14: PERIOD general_element_part
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function9044);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function9046);
        	        	        m_gPLSQLParser->general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 23:
        	    // PLSQL_DMLParser.g:960:10: xmlserialize_key LEFT_PAREN ( document_key | content_key ) concatenation_wrapper ( as_key type_spec )? ( xmlserialize_param_enconding_part )? ( xmlserialize_param_version_part )? ( xmlserialize_param_ident_part )? ( ( hide_key | show_key ) defaults_key )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        this->followPush(FOLLOW_xmlserialize_key_in_standard_function9059);
        	        m_gPLSQLParser->xmlserialize_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function9073);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:962:17: ( document_key | content_key )
        	        {
        	            int alt309=2;
        	            {
        	                int LA309_0 = this->LA(1);
        	                if ( (LA309_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "DOCUMENT")))||((equalsIgnoreCase(LT(1)->getText(), "CONTENT"))))))
        	                {
        	                    {
        	                        int LA309_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "DOCUMENT"))))
        	                        {
        	                            alt309=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "CONTENT"))))
        	                        {
        	                            alt309=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 309 );
        	                            ex->set_state( 1 );


        	                            goto rulestandard_functionEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 309 );
        	                    ex->set_state( 0 );


        	                    goto rulestandard_functionEx;

        	                }
        	            }
        	            switch (alt309)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:962:18: document_key
        	        	    {
        	        	        this->followPush(FOLLOW_document_key_in_standard_function9092);
        	        	        m_gPLSQLParser->document_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:962:31: content_key
        	        	    {
        	        	        this->followPush(FOLLOW_content_key_in_standard_function9094);
        	        	        m_gPLSQLParser->content_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function9113);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:963:39: ( as_key type_spec )?
        	        {
        	            int alt310=2;
        	            {
        	                int LA310_0 = this->LA(1);
        	                if ( (LA310_0 == SQL92_RESERVED_AS))
        	                {
        	                    alt310=1;
        	                }
        	            }
        	            switch (alt310)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:963:40: as_key type_spec
        	        	    {
        	        	        this->followPush(FOLLOW_as_key_in_standard_function9116);
        	        	        m_gPLSQLParser->as_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_type_spec_in_standard_function9118);
        	        	        m_gPLSQLParser->type_spec();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:964:17: ( xmlserialize_param_enconding_part )?
        	        {
        	            int alt311=2;
        	            {
        	                int LA311_0 = this->LA(1);
        	                if ( (LA311_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "HIDE")))||((equalsIgnoreCase(LT(1)->getText(), "SHOW")))||((equalsIgnoreCase(LT(1)->getText(), "NO")))||((equalsIgnoreCase(LT(1)->getText(), "ENCODING")))||((equalsIgnoreCase(LT(1)->getText(), "VERSION")))||((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))))
        	                {
        	                    {
        	                        int LA311_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "ENCODING"))))
        	                        {
        	                            alt311=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt311)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:964:17: xmlserialize_param_enconding_part
        	        	    {
        	        	        this->followPush(FOLLOW_xmlserialize_param_enconding_part_in_standard_function9138);
        	        	        xmlserialize_param_enconding_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:965:17: ( xmlserialize_param_version_part )?
        	        {
        	            int alt312=2;
        	            {
        	                int LA312_0 = this->LA(1);
        	                if ( (LA312_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "HIDE")))||((equalsIgnoreCase(LT(1)->getText(), "SHOW")))||((equalsIgnoreCase(LT(1)->getText(), "NO")))||((equalsIgnoreCase(LT(1)->getText(), "VERSION")))||((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))))
        	                {
        	                    {
        	                        int LA312_1 = this->LA(2);
        	                        if ( (LA312_1 == APPROXIMATE_NUM_LIT || LA312_1 == BINDVAR || ((LA312_1 >= CHAR_STRING) && (LA312_1 <= COLON)) || LA312_1 == DELIMITED_ID || LA312_1 == EXACT_NUM_LIT || LA312_1 == INTRODUCER || LA312_1 == LEFT_PAREN || ((LA312_1 >= MINUS_SIGN) && (LA312_1 <= NATIONAL_CHAR_STRING_LIT)) || LA312_1 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA312_1 == PLUS_SIGN || LA312_1 == SQL92_RESERVED_ALL || LA312_1 == SQL92_RESERVED_ANY || LA312_1 == SQL92_RESERVED_CASE || LA312_1 == SQL92_RESERVED_DATE || LA312_1 == SQL92_RESERVED_DEFAULT || LA312_1 == SQL92_RESERVED_DISTINCT || ((LA312_1 >= SQL92_RESERVED_EXISTS) && (LA312_1 <= SQL92_RESERVED_FALSE)) || LA312_1 == SQL92_RESERVED_NULL || LA312_1 == SQL92_RESERVED_PRIOR || LA312_1 == SQL92_RESERVED_TRUE || LA312_1 == UNSIGNED_INTEGER) && ((equalsIgnoreCase(LT(1)->getText(), "VERSION"))))
        	                        {
        	                            alt312=1;
        	                        }
        	                        else if ( (LA312_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "HIDE")))||((equalsIgnoreCase(LT(1)->getText(), "SHOW")))||((equalsIgnoreCase(LT(1)->getText(), "NO")))||((equalsIgnoreCase(LT(1)->getText(), "VERSION")))||((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))))
        	                        {
        	                            {
        	                                int LA312_4 = this->LA(3);
        	                                if ( ((equalsIgnoreCase(LT(1)->getText(), "VERSION"))))
        	                                {
        	                                    alt312=1;
        	                                }
        	                            }
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt312)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:965:17: xmlserialize_param_version_part
        	        	    {
        	        	        this->followPush(FOLLOW_xmlserialize_param_version_part_in_standard_function9157);
        	        	        xmlserialize_param_version_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:966:17: ( xmlserialize_param_ident_part )?
        	        {
        	            int alt313=2;
        	            {
        	                int LA313_0 = this->LA(1);
        	                if ( (LA313_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "HIDE")))||((equalsIgnoreCase(LT(1)->getText(), "SHOW")))||((equalsIgnoreCase(LT(1)->getText(), "NO")))||((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))))
        	                {
        	                    {
        	                        int LA313_1 = this->LA(2);
        	                        if ( (LA313_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "HIDE")))||((equalsIgnoreCase(LT(1)->getText(), "SHOW")))||((equalsIgnoreCase(LT(1)->getText(), "NO")))||((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))))
        	                        {
        	                            {
        	                                int LA313_3 = this->LA(3);
        	                                if ( ((((equalsIgnoreCase(LT(1)->getText(), "NO")))||((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))))
        	                                {
        	                                    alt313=1;
        	                                }
        	                            }
        	                        }
        	                        else if ( (LA313_1 == RIGHT_PAREN || LA313_1 == SQL92_RESERVED_SIZE) && ((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))
        	                        {
        	                            alt313=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt313)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:966:17: xmlserialize_param_ident_part
        	        	    {
        	        	        this->followPush(FOLLOW_xmlserialize_param_ident_part_in_standard_function9176);
        	        	        xmlserialize_param_ident_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:967:17: ( ( hide_key | show_key ) defaults_key )?
        	        {
        	            int alt315=2;
        	            {
        	                int LA315_0 = this->LA(1);
        	                if ( (LA315_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "HIDE")))||((equalsIgnoreCase(LT(1)->getText(), "SHOW"))))))
        	                {
        	                    alt315=1;
        	                }
        	            }
        	            switch (alt315)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:967:18: ( hide_key | show_key ) defaults_key
        	        	    {
        	        	        // PLSQL_DMLParser.g:967:18: ( hide_key | show_key )
        	        	        {
        	        	            int alt314=2;
        	        	            {
        	        	                int LA314_0 = this->LA(1);
        	        	                if ( (LA314_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "HIDE")))||((equalsIgnoreCase(LT(1)->getText(), "SHOW"))))))
        	        	                {
        	        	                    {
        	        	                        int LA314_1 = this->LA(2);
        	        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "HIDE"))))
        	        	                        {
        	        	                            alt314=1;
        	        	                        }
        	        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "SHOW"))))
        	        	                        {
        	        	                            alt314=2;
        	        	                        }
        	        	                        else
        	        	                        {
        	        	                            if (this->get_backtracking()>0)
        	        	                            {
        	        	                                this->set_failedflag( true );
        	        	                                return ;
        	        	                            }


        	        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                            ex->set_decisionNum( 314 );
        	        	                            ex->set_state( 1 );


        	        	                            goto rulestandard_functionEx;

        	        	                        }
        	        	                    }
        	        	                }
        	        	                else
        	        	                {
        	        	                    if (this->get_backtracking()>0)
        	        	                    {
        	        	                        this->set_failedflag( true );
        	        	                        return ;
        	        	                    }


        	        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                    ex->set_decisionNum( 314 );
        	        	                    ex->set_state( 0 );


        	        	                    goto rulestandard_functionEx;

        	        	                }
        	        	            }
        	        	            switch (alt314)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:967:19: hide_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_hide_key_in_standard_function9197);
        	        	        	        m_gPLSQLParser->hide_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // PLSQL_DMLParser.g:967:28: show_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_show_key_in_standard_function9199);
        	        	        	        m_gPLSQLParser->show_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        this->followPush(FOLLOW_defaults_key_in_standard_function9202);
        	        	        m_gPLSQLParser->defaults_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function9218);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:969:13: ( PERIOD general_element_part )?
        	        {
        	            int alt316=2;
        	            {
        	                int LA316_0 = this->LA(1);
        	                if ( (LA316_0 == PERIOD))
        	                {
        	                    alt316=1;
        	                }
        	            }
        	            switch (alt316)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:969:14: PERIOD general_element_part
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function9233);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function9235);
        	        	        m_gPLSQLParser->general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 24:
        	    // PLSQL_DMLParser.g:970:10: xmltable_key LEFT_PAREN ( xml_namespaces_clause )? concatenation_wrapper ( xml_passing_clause )? ( columns_key xml_table_column ( COMMA xml_table_column ) )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        this->followPush(FOLLOW_xmltable_key_in_standard_function9248);
        	        m_gPLSQLParser->xmltable_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function9262);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:972:17: ( xml_namespaces_clause )?
        	        {
        	            int alt317=2;
        	            {
        	                int LA317_0 = this->LA(1);
        	                if ( (LA317_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA317_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLNAMESPACES"))))
        	                        {
        	                            alt317=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt317)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:972:17: xml_namespaces_clause
        	        	    {
        	        	        this->followPush(FOLLOW_xml_namespaces_clause_in_standard_function9280);
        	        	        xml_namespaces_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function9299);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:974:17: ( xml_passing_clause )?
        	        {
        	            int alt318=2;
        	            {
        	                int LA318_0 = this->LA(1);
        	                if ( (LA318_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "COLUMNS")))||((equalsIgnoreCase(LT(1)->getText(), "PASSING"))))))
        	                {
        	                    {
        	                        int LA318_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "PASSING"))))
        	                        {
        	                            alt318=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt318)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:974:17: xml_passing_clause
        	        	    {
        	        	        this->followPush(FOLLOW_xml_passing_clause_in_standard_function9317);
        	        	        xml_passing_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:975:17: ( columns_key xml_table_column ( COMMA xml_table_column ) )?
        	        {
        	            int alt319=2;
        	            {
        	                int LA319_0 = this->LA(1);
        	                if ( (LA319_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "COLUMNS"))))
        	                {
        	                    alt319=1;
        	                }
        	            }
        	            switch (alt319)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:975:18: columns_key xml_table_column ( COMMA xml_table_column )
        	        	    {
        	        	        this->followPush(FOLLOW_columns_key_in_standard_function9337);
        	        	        m_gPLSQLParser->columns_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_xml_table_column_in_standard_function9339);
        	        	        xml_table_column();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQL_DMLParser.g:975:47: ( COMMA xml_table_column )
        	        	        // PLSQL_DMLParser.g:975:48: COMMA xml_table_column
        	        	        {
        	        	             this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function9342);
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulestandard_functionEx;
        	        	            }
        	        	            if (this->hasFailed())
        	        	            {
        	        	                return ;
        	        	            }


        	        	            this->followPush(FOLLOW_xml_table_column_in_standard_function9344);
        	        	            xml_table_column();

        	        	            this->followPop();
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulestandard_functionEx;
        	        	            }
        	        	            if (this->hasFailed())
        	        	            {
        	        	                return ;
        	        	            }


        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function9361);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:977:13: ( PERIOD general_element_part )?
        	        {
        	            int alt320=2;
        	            {
        	                int LA320_0 = this->LA(1);
        	                if ( (LA320_0 == PERIOD))
        	                {
        	                    alt320=1;
        	                }
        	            }
        	            switch (alt320)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:977:14: PERIOD general_element_part
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function9376);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function9378);
        	        	        m_gPLSQLParser->general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulestandard_functionEx; /* Prevent compiler warnings */
    rulestandard_functionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end standard_function */

/**
 * $ANTLR start stantard_function_enabling_over
 * PLSQL_DMLParser.g:980:1: stantard_function_enabling_over :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQL_DMLParser::stantard_function_enabling_over()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:981:5: ({...}? => REGULAR_ID )
        // PLSQL_DMLParser.g:981:10: {...}? => REGULAR_ID
        {
            if ( !((enablesOverClause(LT(1)->getText()))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "enablesOverClause(LT(1)->getText())" );
                    ex->set_ruleName( "stantard_function_enabling_over" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_stantard_function_enabling_over9403);
            if  (this->hasException())
            {
                goto rulestantard_function_enabling_overEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestantard_function_enabling_overEx; /* Prevent compiler warnings */
    rulestantard_function_enabling_overEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end stantard_function_enabling_over */

/**
 * $ANTLR start stantard_function_enabling_using
 * PLSQL_DMLParser.g:984:1: stantard_function_enabling_using :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQL_DMLParser::stantard_function_enabling_using()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:985:5: ({...}? => REGULAR_ID )
        // PLSQL_DMLParser.g:985:10: {...}? => REGULAR_ID
        {
            if ( !((enablesUsingClause(LT(1)->getText()))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "enablesUsingClause(LT(1)->getText())" );
                    ex->set_ruleName( "stantard_function_enabling_using" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_stantard_function_enabling_using9426);
            if  (this->hasException())
            {
                goto rulestantard_function_enabling_usingEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestantard_function_enabling_usingEx; /* Prevent compiler warnings */
    rulestantard_function_enabling_usingEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end stantard_function_enabling_using */

/**
 * $ANTLR start stantard_function_enabling_within_or_over
 * PLSQL_DMLParser.g:988:1: stantard_function_enabling_within_or_over :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQL_DMLParser::stantard_function_enabling_within_or_over()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:989:5: ({...}? => REGULAR_ID )
        // PLSQL_DMLParser.g:989:10: {...}? => REGULAR_ID
        {
            if ( !((enablesWithinOrOverClause(LT(1)->getText()))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "enablesWithinOrOverClause(LT(1)->getText())" );
                    ex->set_ruleName( "stantard_function_enabling_within_or_over" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_stantard_function_enabling_within_or_over9449);
            if  (this->hasException())
            {
                goto rulestantard_function_enabling_within_or_overEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestantard_function_enabling_within_or_overEx; /* Prevent compiler warnings */
    rulestantard_function_enabling_within_or_overEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end stantard_function_enabling_within_or_over */

/**
 * $ANTLR start stantard_function_pedictions
 * PLSQL_DMLParser.g:992:1: stantard_function_pedictions :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQL_DMLParser::stantard_function_pedictions()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:993:5: ({...}? => REGULAR_ID )
        // PLSQL_DMLParser.g:993:10: {...}? => REGULAR_ID
        {
            if ( !((isStandardPredictionFunction(LT(1)->getText()))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "isStandardPredictionFunction(LT(1)->getText())" );
                    ex->set_ruleName( "stantard_function_pedictions" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_stantard_function_pedictions9472);
            if  (this->hasException())
            {
                goto rulestantard_function_pedictionsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestantard_function_pedictionsEx; /* Prevent compiler warnings */
    rulestantard_function_pedictionsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end stantard_function_pedictions */

/**
 * $ANTLR start over_clause
 * PLSQL_DMLParser.g:996:1: over_clause : over_key LEFT_PAREN ( query_partition_clause )? ( order_by_clause ( windowing_clause )? )? RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::over_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:997:5: ( over_key LEFT_PAREN ( query_partition_clause )? ( order_by_clause ( windowing_clause )? )? RIGHT_PAREN )
        // PLSQL_DMLParser.g:997:10: over_key LEFT_PAREN ( query_partition_clause )? ( order_by_clause ( windowing_clause )? )? RIGHT_PAREN
        {
            this->followPush(FOLLOW_over_key_in_over_clause9492);
            m_gPLSQLParser->over_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleover_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_over_clause9502);
            if  (this->hasException())
            {
                goto ruleover_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:999:13: ( query_partition_clause )?
            {
                int alt322=2;
                {
                    int LA322_0 = this->LA(1);
                    if ( (LA322_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "PARTITION"))))
                    {
                        alt322=1;
                    }
                }
                switch (alt322)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:999:13: query_partition_clause
            	    {
            	        this->followPush(FOLLOW_query_partition_clause_in_over_clause9516);
            	        query_partition_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleover_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:1000:13: ( order_by_clause ( windowing_clause )? )?
            {
                int alt324=2;
                {
                    int LA324_0 = this->LA(1);
                    if ( (LA324_0 == SQL92_RESERVED_ORDER))
                    {
                        alt324=1;
                    }
                }
                switch (alt324)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1000:14: order_by_clause ( windowing_clause )?
            	    {
            	        this->followPush(FOLLOW_order_by_clause_in_over_clause9532);
            	        order_by_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleover_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:1000:30: ( windowing_clause )?
            	        {
            	            int alt323=2;
            	            {
            	                int LA323_0 = this->LA(1);
            	                if ( (LA323_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "ROWS")))||((equalsIgnoreCase(LT(1)->getText(), "RANGE"))))))
            	                {
            	                    alt323=1;
            	                }
            	            }
            	            switch (alt323)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:1000:30: windowing_clause
            	        	    {
            	        	        this->followPush(FOLLOW_windowing_clause_in_over_clause9534);
            	        	        windowing_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleover_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_over_clause9547);
            if  (this->hasException())
            {
                goto ruleover_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleover_clauseEx; /* Prevent compiler warnings */
    ruleover_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end over_clause */

/**
 * $ANTLR start windowing_clause
 * PLSQL_DMLParser.g:1004:1: windowing_clause : windowing_type ( between_key windowing_elements and_key windowing_elements | windowing_elements ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::windowing_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1005:5: ( windowing_type ( between_key windowing_elements and_key windowing_elements | windowing_elements ) )
        // PLSQL_DMLParser.g:1005:10: windowing_type ( between_key windowing_elements and_key windowing_elements | windowing_elements )
        {
            this->followPush(FOLLOW_windowing_type_in_windowing_clause9567);
            windowing_type();

            this->followPop();
            if  (this->hasException())
            {
                goto rulewindowing_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1006:5: ( between_key windowing_elements and_key windowing_elements | windowing_elements )
            {
                int alt325=2;
                {
                    int LA325_0 = this->LA(1);
                    if ( (LA325_0 == SQL92_RESERVED_BETWEEN))
                    {
                        alt325=1;
                    }
                    else if ( (LA325_0 == APPROXIMATE_NUM_LIT || LA325_0 == BINDVAR || ((LA325_0 >= CHAR_STRING) && (LA325_0 <= COLON)) || LA325_0 == DELIMITED_ID || LA325_0 == EXACT_NUM_LIT || LA325_0 == INTRODUCER || LA325_0 == LEFT_PAREN || ((LA325_0 >= MINUS_SIGN) && (LA325_0 <= NATIONAL_CHAR_STRING_LIT)) || LA325_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA325_0 == PLUS_SIGN || LA325_0 == REGULAR_ID || LA325_0 == SQL92_RESERVED_ALL || LA325_0 == SQL92_RESERVED_ANY || LA325_0 == SQL92_RESERVED_CASE || LA325_0 == SQL92_RESERVED_CURRENT || LA325_0 == SQL92_RESERVED_DATE || LA325_0 == SQL92_RESERVED_DEFAULT || LA325_0 == SQL92_RESERVED_DISTINCT || ((LA325_0 >= SQL92_RESERVED_EXISTS) && (LA325_0 <= SQL92_RESERVED_FALSE)) || LA325_0 == SQL92_RESERVED_NULL || LA325_0 == SQL92_RESERVED_PRIOR || LA325_0 == SQL92_RESERVED_TRUE || LA325_0 == UNSIGNED_INTEGER))
                    {
                        alt325=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 325 );
                        ex->set_state( 0 );


                        goto rulewindowing_clauseEx;

                    }
                }
                switch (alt325)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1006:10: between_key windowing_elements and_key windowing_elements
            	    {
            	        this->followPush(FOLLOW_between_key_in_windowing_clause9578);
            	        m_gPLSQLParser->between_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewindowing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_windowing_elements_in_windowing_clause9580);
            	        windowing_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewindowing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_and_key_in_windowing_clause9582);
            	        m_gPLSQLParser->and_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewindowing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_windowing_elements_in_windowing_clause9584);
            	        windowing_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewindowing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:1007:10: windowing_elements
            	    {
            	        this->followPush(FOLLOW_windowing_elements_in_windowing_clause9595);
            	        windowing_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewindowing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulewindowing_clauseEx; /* Prevent compiler warnings */
    rulewindowing_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end windowing_clause */

/**
 * $ANTLR start windowing_type
 * PLSQL_DMLParser.g:1010:1: windowing_type : ( rows_key | range_key );
 */
void
PLSQLParser_PLSQL_DMLParser::windowing_type()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:1011:5: ( rows_key | range_key )

            ANTLR_UINT32 alt326;

            alt326=2;

            {
                int LA326_0 = this->LA(1);
                if ( (LA326_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "ROWS")))||((equalsIgnoreCase(LT(1)->getText(), "RANGE"))))))
                {
                    {
                        int LA326_1 = this->LA(2);
                        if ( ((equalsIgnoreCase(LT(1)->getText(), "ROWS"))))
                        {
                            alt326=1;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "RANGE"))))
                        {
                            alt326=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 326 );
                            ex->set_state( 1 );


                            goto rulewindowing_typeEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 326 );
                    ex->set_state( 0 );


                    goto rulewindowing_typeEx;

                }
            }
            switch (alt326)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:1011:10: rows_key
        	    {
        	        this->followPush(FOLLOW_rows_key_in_windowing_type9620);
        	        m_gPLSQLParser->rows_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:1012:10: range_key
        	    {
        	        this->followPush(FOLLOW_range_key_in_windowing_type9631);
        	        m_gPLSQLParser->range_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulewindowing_typeEx; /* Prevent compiler warnings */
    rulewindowing_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end windowing_type */

/**
 * $ANTLR start windowing_elements
 * PLSQL_DMLParser.g:1015:1: windowing_elements : ( unbounded_key preceding_key | current_key row_key | concatenation_wrapper ( preceding_key | following_key ) );
 */
void
PLSQLParser_PLSQL_DMLParser::windowing_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:1016:5: ( unbounded_key preceding_key | current_key row_key | concatenation_wrapper ( preceding_key | following_key ) )

            ANTLR_UINT32 alt328;

            alt328=3;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    int LA328_1 = this->LA(2);
            		    if ( (LA328_1 == REGULAR_ID))
            		    {
            		        {
            		            int LA328_4 = this->LA(3);
            		            if ( ((equalsIgnoreCase(LT(1)->getText(), "UNBOUNDED"))))
            		            {
            		                alt328=1;
            		            }
            		            else if ( (true))
            		            {
            		                alt328=3;
            		            }
            		            else
            		            {
            		                if (this->get_backtracking()>0)
            		                {
            		                    this->set_failedflag( true );
            		                    return ;
            		                }


            		                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		                ex->set_decisionNum( 328 );
            		                ex->set_state( 4 );


            		                goto rulewindowing_elementsEx;

            		            }
            		        }
            		    }
            		    else if ( (LA328_1 == MINUS_SIGN || LA328_1 == PLUS_SIGN))
            		    {
            		        alt328=3;
            		    }
            		    else if ( (LA328_1 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA328_1 == SQL92_RESERVED_ALL || LA328_1 == SQL92_RESERVED_DISTINCT || LA328_1 == SQL92_RESERVED_PRIOR) && (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )))
            		    {
            		        alt328=3;
            		    }
            		    else if ( (LA328_1 == DELIMITED_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||(( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )))))
            		    {
            		        alt328=3;
            		    }
            		    else if ( (LA328_1 == SQL92_RESERVED_CASE))
            		    {
            		        alt328=3;
            		    }
            		    else if ( (LA328_1 == SQL92_RESERVED_ANY || LA328_1 == SQL92_RESERVED_EXISTS) && (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )))
            		    {
            		        alt328=3;
            		    }
            		    else if ( (LA328_1 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||(( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )))))
            		    {
            		        alt328=3;
            		    }
            		    else if ( (LA328_1 == BINDVAR || LA328_1 == COLON))
            		    {
            		        alt328=3;
            		    }
            		    else if ( (LA328_1 == APPROXIMATE_NUM_LIT || LA328_1 == EXACT_NUM_LIT || LA328_1 == SQL92_RESERVED_DATE || LA328_1 == UNSIGNED_INTEGER) && (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )))
            		    {
            		        alt328=3;
            		    }
            		    else if ( (((LA328_1 >= CHAR_STRING) && (LA328_1 <= CHAR_STRING_PERL)) || LA328_1 == NATIONAL_CHAR_STRING_LIT))
            		    {
            		        alt328=3;
            		    }
            		    else if ( (LA328_1 == SQL92_RESERVED_DEFAULT || LA328_1 == SQL92_RESERVED_FALSE || LA328_1 == SQL92_RESERVED_NULL || LA328_1 == SQL92_RESERVED_TRUE) && (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )))
            		    {
            		        alt328=3;
            		    }
            		    else if ( (LA328_1 == ASTERISK || LA328_1 == CONCATENATION_OP || ((LA328_1 >= LEFT_BRACKET) && (LA328_1 <= LEFT_PAREN)) || LA328_1 == PERIOD || LA328_1 == SOLIDUS || LA328_1 == VERTICAL_BAR))
            		    {
            		        alt328=3;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 328 );
            		        ex->set_state( 1 );


            		        goto rulewindowing_elementsEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_CURRENT:
            	{
            		alt328=2;
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case DELIMITED_ID:
            case EXACT_NUM_LIT:
            case INTRODUCER:
            case LEFT_PAREN:
            case MINUS_SIGN:
            case NATIONAL_CHAR_STRING_LIT:
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            case PLUS_SIGN:
            case SQL92_RESERVED_ALL:
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_CASE:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_DISTINCT:
            case SQL92_RESERVED_EXISTS:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_PRIOR:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt328=3;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 328 );
                ex->set_state( 0 );


                goto rulewindowing_elementsEx;

            }

            switch (alt328)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:1016:10: unbounded_key preceding_key
        	    {
        	        this->followPush(FOLLOW_unbounded_key_in_windowing_elements9651);
        	        m_gPLSQLParser->unbounded_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_preceding_key_in_windowing_elements9653);
        	        m_gPLSQLParser->preceding_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:1017:10: current_key row_key
        	    {
        	        this->followPush(FOLLOW_current_key_in_windowing_elements9664);
        	        m_gPLSQLParser->current_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_row_key_in_windowing_elements9666);
        	        m_gPLSQLParser->row_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:1018:10: concatenation_wrapper ( preceding_key | following_key )
        	    {
        	        this->followPush(FOLLOW_concatenation_wrapper_in_windowing_elements9677);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:1018:32: ( preceding_key | following_key )
        	        {
        	            int alt327=2;
        	            {
        	                int LA327_0 = this->LA(1);
        	                if ( (LA327_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWING")))||((equalsIgnoreCase(LT(1)->getText(), "PRECEDING"))))))
        	                {
        	                    {
        	                        int LA327_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "PRECEDING"))))
        	                        {
        	                            alt327=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "FOLLOWING"))))
        	                        {
        	                            alt327=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 327 );
        	                            ex->set_state( 1 );


        	                            goto rulewindowing_elementsEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 327 );
        	                    ex->set_state( 0 );


        	                    goto rulewindowing_elementsEx;

        	                }
        	            }
        	            switch (alt327)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:1018:33: preceding_key
        	        	    {
        	        	        this->followPush(FOLLOW_preceding_key_in_windowing_elements9680);
        	        	        m_gPLSQLParser->preceding_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulewindowing_elementsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:1018:47: following_key
        	        	    {
        	        	        this->followPush(FOLLOW_following_key_in_windowing_elements9682);
        	        	        m_gPLSQLParser->following_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulewindowing_elementsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulewindowing_elementsEx; /* Prevent compiler warnings */
    rulewindowing_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end windowing_elements */

/**
 * $ANTLR start using_clause
 * PLSQL_DMLParser.g:1021:1: using_clause : using_key ( ASTERISK | using_element ( COMMA using_element )* ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::using_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1022:5: ( using_key ( ASTERISK | using_element ( COMMA using_element )* ) )
        // PLSQL_DMLParser.g:1022:10: using_key ( ASTERISK | using_element ( COMMA using_element )* )
        {
            this->followPush(FOLLOW_using_key_in_using_clause9703);
            m_gPLSQLParser->using_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleusing_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1023:5: ( ASTERISK | using_element ( COMMA using_element )* )
            {
                int alt330=2;
                {
                    int LA330_0 = this->LA(1);
                    if ( (LA330_0 == ASTERISK))
                    {
                        alt330=1;
                    }
                    else if ( (LA330_0 == APPROXIMATE_NUM_LIT || LA330_0 == BINDVAR || ((LA330_0 >= CHAR_STRING) && (LA330_0 <= COLON)) || LA330_0 == DELIMITED_ID || LA330_0 == EXACT_NUM_LIT || LA330_0 == INTRODUCER || LA330_0 == LEFT_PAREN || ((LA330_0 >= MINUS_SIGN) && (LA330_0 <= NATIONAL_CHAR_STRING_LIT)) || LA330_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA330_0 == PLUS_SIGN || LA330_0 == REGULAR_ID || LA330_0 == SQL92_RESERVED_ALL || LA330_0 == SQL92_RESERVED_ANY || LA330_0 == SQL92_RESERVED_CASE || ((LA330_0 >= SQL92_RESERVED_CURSOR) && (LA330_0 <= SQL92_RESERVED_DATE)) || LA330_0 == SQL92_RESERVED_DEFAULT || LA330_0 == SQL92_RESERVED_DISTINCT || ((LA330_0 >= SQL92_RESERVED_EXISTS) && (LA330_0 <= SQL92_RESERVED_FALSE)) || LA330_0 == SQL92_RESERVED_IN || ((LA330_0 >= SQL92_RESERVED_NOT) && (LA330_0 <= SQL92_RESERVED_NULL)) || LA330_0 == SQL92_RESERVED_PRIOR || LA330_0 == SQL92_RESERVED_TRUE || LA330_0 == UNSIGNED_INTEGER))
                    {
                        alt330=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 330 );
                        ex->set_state( 0 );


                        goto ruleusing_clauseEx;

                    }
                }
                switch (alt330)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1023:10: ASTERISK
            	    {
            	         this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_using_clause9714);
            	        if  (this->hasException())
            	        {
            	            goto ruleusing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:1024:10: using_element ( COMMA using_element )*
            	    {
            	        this->followPush(FOLLOW_using_element_in_using_clause9725);
            	        using_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleusing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:1024:24: ( COMMA using_element )*

            	        for (;;)
            	        {
            	            int alt329=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA329_0 = this->LA(1);
            	                if ( (LA329_0 == COMMA))
            	                {
            	                    alt329=1;
            	                }

            	            }
            	            switch (alt329)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:1024:25: COMMA using_element
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_using_clause9728);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleusing_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_using_element_in_using_clause9730);
            	        	        using_element();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleusing_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop329;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop329: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleusing_clauseEx; /* Prevent compiler warnings */
    ruleusing_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end using_clause */

/**
 * $ANTLR start using_element
 * PLSQL_DMLParser.g:1028:1: using_element : ( in_key ( out_key )? | out_key )? select_list_elements ( column_alias )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::using_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1029:5: ( ( in_key ( out_key )? | out_key )? select_list_elements ( column_alias )? )
        // PLSQL_DMLParser.g:1029:10: ( in_key ( out_key )? | out_key )? select_list_elements ( column_alias )?
        {
            // PLSQL_DMLParser.g:1029:10: ( in_key ( out_key )? | out_key )?
            {
                int alt332=3;
                {
                    int LA332_0 = this->LA(1);
                    if ( (LA332_0 == SQL92_RESERVED_IN))
                    {
                        alt332=1;
                    }
                    else if ( (LA332_0 == REGULAR_ID))
                    {
                        {
                            int LA332_2 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "OUT"))))
                            {
                                alt332=2;
                            }
                        }
                    }
                }
                switch (alt332)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1029:11: in_key ( out_key )?
            	    {
            	        this->followPush(FOLLOW_in_key_in_using_element9759);
            	        m_gPLSQLParser->in_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleusing_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:1029:18: ( out_key )?
            	        {
            	            int alt331=2;
            	            {
            	                int LA331_0 = this->LA(1);
            	                if ( (LA331_0 == REGULAR_ID))
            	                {
            	                    {
            	                        int LA331_1 = this->LA(2);
            	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "OUT"))))
            	                        {
            	                            alt331=1;
            	                        }
            	                    }
            	                }
            	            }
            	            switch (alt331)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:1029:18: out_key
            	        	    {
            	        	        this->followPush(FOLLOW_out_key_in_using_element9761);
            	        	        m_gPLSQLParser->out_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleusing_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:1029:27: out_key
            	    {
            	        this->followPush(FOLLOW_out_key_in_using_element9764);
            	        m_gPLSQLParser->out_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleusing_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_select_list_elements_in_using_element9768);
            select_list_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleusing_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1029:58: ( column_alias )?
            {
                int alt333=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_AS:
                    	{
                    		alt333=1;
                    	}
                        break;
                    case INTRODUCER:
                    	{
                    		alt333=1;
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		alt333=1;
                    	}
                        break;
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case NATIONAL_CHAR_STRING_LIT:
                    	{
                    		alt333=1;
                    	}
                        break;
                    case DELIMITED_ID:
                    	{
                    		alt333=1;
                    	}
                        break;
                }

                switch (alt333)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1029:58: column_alias
            	    {
            	        this->followPush(FOLLOW_column_alias_in_using_element9770);
            	        m_gPLSQLParser->column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleusing_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleusing_elementEx; /* Prevent compiler warnings */
    ruleusing_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end using_element */

/**
 * $ANTLR start collect_order_by_part
 * PLSQL_DMLParser.g:1032:1: collect_order_by_part : order_key by_key concatenation_wrapper ;
 */
void
PLSQLParser_PLSQL_DMLParser::collect_order_by_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1033:5: ( order_key by_key concatenation_wrapper )
        // PLSQL_DMLParser.g:1033:10: order_key by_key concatenation_wrapper
        {
            this->followPush(FOLLOW_order_key_in_collect_order_by_part9791);
            m_gPLSQLParser->order_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecollect_order_by_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_by_key_in_collect_order_by_part9793);
            m_gPLSQLParser->by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecollect_order_by_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_concatenation_wrapper_in_collect_order_by_part9795);
            concatenation_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecollect_order_by_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecollect_order_by_partEx; /* Prevent compiler warnings */
    rulecollect_order_by_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end collect_order_by_part */

/**
 * $ANTLR start within_or_over_part
 * PLSQL_DMLParser.g:1036:1: within_or_over_part : ( within_key group_key LEFT_PAREN order_by_clause RIGHT_PAREN | over_clause );
 */
void
PLSQLParser_PLSQL_DMLParser::within_or_over_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:1037:5: ( within_key group_key LEFT_PAREN order_by_clause RIGHT_PAREN | over_clause )

            ANTLR_UINT32 alt334;

            alt334=2;

            {
                int LA334_0 = this->LA(1);
                if ( (LA334_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "WITHIN")))||((equalsIgnoreCase(LT(1)->getText(), "OVER"))))))
                {
                    {
                        int LA334_1 = this->LA(2);
                        if ( (LA334_1 == SQL92_RESERVED_GROUP) && ((equalsIgnoreCase(LT(1)->getText(), "WITHIN"))))
                        {
                            alt334=1;
                        }
                        else if ( (LA334_1 == LEFT_PAREN) && ((equalsIgnoreCase(LT(1)->getText(), "OVER"))))
                        {
                            alt334=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 334 );
                            ex->set_state( 1 );


                            goto rulewithin_or_over_partEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 334 );
                    ex->set_state( 0 );


                    goto rulewithin_or_over_partEx;

                }
            }
            switch (alt334)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:1037:10: within_key group_key LEFT_PAREN order_by_clause RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_within_key_in_within_or_over_part9815);
        	        m_gPLSQLParser->within_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewithin_or_over_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_group_key_in_within_or_over_part9817);
        	        m_gPLSQLParser->group_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewithin_or_over_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_within_or_over_part9819);
        	        if  (this->hasException())
        	        {
        	            goto rulewithin_or_over_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_order_by_clause_in_within_or_over_part9821);
        	        order_by_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewithin_or_over_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_within_or_over_part9823);
        	        if  (this->hasException())
        	        {
        	            goto rulewithin_or_over_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:1038:10: over_clause
        	    {
        	        this->followPush(FOLLOW_over_clause_in_within_or_over_part9834);
        	        over_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewithin_or_over_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulewithin_or_over_partEx; /* Prevent compiler warnings */
    rulewithin_or_over_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end within_or_over_part */

/**
 * $ANTLR start cost_matrix_clause
 * PLSQL_DMLParser.g:1041:1: cost_matrix_clause : cost_key ( model_key ( auto_key )? | LEFT_PAREN cost_class_name ( COMMA cost_class_name )* RIGHT_PAREN values_key expression_list ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::cost_matrix_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1042:5: ( cost_key ( model_key ( auto_key )? | LEFT_PAREN cost_class_name ( COMMA cost_class_name )* RIGHT_PAREN values_key expression_list ) )
        // PLSQL_DMLParser.g:1042:10: cost_key ( model_key ( auto_key )? | LEFT_PAREN cost_class_name ( COMMA cost_class_name )* RIGHT_PAREN values_key expression_list )
        {
            this->followPush(FOLLOW_cost_key_in_cost_matrix_clause9854);
            m_gPLSQLParser->cost_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecost_matrix_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1043:5: ( model_key ( auto_key )? | LEFT_PAREN cost_class_name ( COMMA cost_class_name )* RIGHT_PAREN values_key expression_list )
            {
                int alt337=2;
                {
                    int LA337_0 = this->LA(1);
                    if ( (LA337_0 == PLSQL_NON_RESERVED_MODEL))
                    {
                        alt337=1;
                    }
                    else if ( (LA337_0 == LEFT_PAREN))
                    {
                        alt337=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 337 );
                        ex->set_state( 0 );


                        goto rulecost_matrix_clauseEx;

                    }
                }
                switch (alt337)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1043:10: model_key ( auto_key )?
            	    {
            	        this->followPush(FOLLOW_model_key_in_cost_matrix_clause9865);
            	        m_gPLSQLParser->model_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecost_matrix_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:1043:20: ( auto_key )?
            	        {
            	            int alt335=2;
            	            {
            	                int LA335_0 = this->LA(1);
            	                if ( (LA335_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "AUTO"))))
            	                {
            	                    alt335=1;
            	                }
            	            }
            	            switch (alt335)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:1043:20: auto_key
            	        	    {
            	        	        this->followPush(FOLLOW_auto_key_in_cost_matrix_clause9867);
            	        	        m_gPLSQLParser->auto_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecost_matrix_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:1044:10: LEFT_PAREN cost_class_name ( COMMA cost_class_name )* RIGHT_PAREN values_key expression_list
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_cost_matrix_clause9879);
            	        if  (this->hasException())
            	        {
            	            goto rulecost_matrix_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_cost_class_name_in_cost_matrix_clause9881);
            	        m_gPLSQLParser->cost_class_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecost_matrix_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:1044:37: ( COMMA cost_class_name )*

            	        for (;;)
            	        {
            	            int alt336=2;
            	            {
            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	                */
            	                int LA336_0 = this->LA(1);
            	                if ( (LA336_0 == COMMA))
            	                {
            	                    alt336=1;
            	                }

            	            }
            	            switch (alt336)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:1044:38: COMMA cost_class_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_cost_matrix_clause9884);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecost_matrix_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_cost_class_name_in_cost_matrix_clause9886);
            	        	        m_gPLSQLParser->cost_class_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecost_matrix_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop336;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop336: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_cost_matrix_clause9890);
            	        if  (this->hasException())
            	        {
            	            goto rulecost_matrix_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_values_key_in_cost_matrix_clause9892);
            	        m_gPLSQLParser->values_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecost_matrix_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_list_in_cost_matrix_clause9907);
            	        expression_list();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecost_matrix_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulecost_matrix_clauseEx; /* Prevent compiler warnings */
    rulecost_matrix_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cost_matrix_clause */

/**
 * $ANTLR start xml_passing_clause
 * PLSQL_DMLParser.g:1049:1: xml_passing_clause : passing_key ( by_key value_key )? expression_wrapper ( column_alias )? ( COMMA expression_wrapper ( column_alias )? ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::xml_passing_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1050:5: ( passing_key ( by_key value_key )? expression_wrapper ( column_alias )? ( COMMA expression_wrapper ( column_alias )? ) )
        // PLSQL_DMLParser.g:1050:10: passing_key ( by_key value_key )? expression_wrapper ( column_alias )? ( COMMA expression_wrapper ( column_alias )? )
        {
            this->followPush(FOLLOW_passing_key_in_xml_passing_clause9933);
            m_gPLSQLParser->passing_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_passing_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1050:22: ( by_key value_key )?
            {
                int alt338=2;
                {
                    int LA338_0 = this->LA(1);
                    if ( (LA338_0 == SQL92_RESERVED_BY))
                    {
                        alt338=1;
                    }
                }
                switch (alt338)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1050:23: by_key value_key
            	    {
            	        this->followPush(FOLLOW_by_key_in_xml_passing_clause9936);
            	        m_gPLSQLParser->by_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_passing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_value_key_in_xml_passing_clause9938);
            	        m_gPLSQLParser->value_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_passing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_expression_wrapper_in_xml_passing_clause9954);
            expression_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_passing_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1051:32: ( column_alias )?
            {
                int alt339=2;
                {
                    int LA339_0 = this->LA(1);
                    if ( (((LA339_0 >= CHAR_STRING) && (LA339_0 <= CHAR_STRING_PERL)) || LA339_0 == DELIMITED_ID || LA339_0 == INTRODUCER || LA339_0 == NATIONAL_CHAR_STRING_LIT || LA339_0 == REGULAR_ID || LA339_0 == SQL92_RESERVED_AS))
                    {
                        alt339=1;
                    }
                }
                switch (alt339)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1051:32: column_alias
            	    {
            	        this->followPush(FOLLOW_column_alias_in_xml_passing_clause9956);
            	        m_gPLSQLParser->column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_passing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:1051:46: ( COMMA expression_wrapper ( column_alias )? )
            // PLSQL_DMLParser.g:1051:47: COMMA expression_wrapper ( column_alias )?
            {
                 this->matchToken(COMMA, &FOLLOW_COMMA_in_xml_passing_clause9960);
                if  (this->hasException())
                {
                    goto rulexml_passing_clauseEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }


                this->followPush(FOLLOW_expression_wrapper_in_xml_passing_clause9962);
                expression_wrapper();

                this->followPop();
                if  (this->hasException())
                {
                    goto rulexml_passing_clauseEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }


                // PLSQL_DMLParser.g:1051:72: ( column_alias )?
                {
                    int alt340=2;
                    {
                        int LA340_0 = this->LA(1);
                        if ( (((LA340_0 >= CHAR_STRING) && (LA340_0 <= CHAR_STRING_PERL)) || LA340_0 == DELIMITED_ID || LA340_0 == INTRODUCER || LA340_0 == NATIONAL_CHAR_STRING_LIT || LA340_0 == SQL92_RESERVED_AS))
                        {
                            alt340=1;
                        }
                        else if ( (LA340_0 == REGULAR_ID))
                        {
                            {
                                int LA340_3 = this->LA(2);
                                if ( (!( ((((equalsIgnoreCase(LT(1)->getText(), "RETURNING")))||((equalsIgnoreCase(LT(1)->getText(), "COLUMNS"))))) )))
                                {
                                    alt340=1;
                                }
                            }
                        }
                    }
                    switch (alt340)
                    {
                	case 1:
                	    // PLSQL_DMLParser.g:1051:72: column_alias
                	    {
                	        this->followPush(FOLLOW_column_alias_in_xml_passing_clause9964);
                	        m_gPLSQLParser->column_alias();

                	        this->followPop();
                	        if  (this->hasException())
                	        {
                	            goto rulexml_passing_clauseEx;
                	        }
                	        if (this->hasFailed())
                	        {
                	            return ;
                	        }


                	    }
                	    break;

                    }
                }

            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexml_passing_clauseEx; /* Prevent compiler warnings */
    rulexml_passing_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xml_passing_clause */

/**
 * $ANTLR start xml_attributes_clause
 * PLSQL_DMLParser.g:1054:1: xml_attributes_clause : xmlattributes_key LEFT_PAREN ( entityescaping_key | noentityescaping_key )? ( schemacheck_key | noschemacheck_key )? xml_multiuse_expression_element ( COMMA xml_multiuse_expression_element )* RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::xml_attributes_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1055:5: ( xmlattributes_key LEFT_PAREN ( entityescaping_key | noentityescaping_key )? ( schemacheck_key | noschemacheck_key )? xml_multiuse_expression_element ( COMMA xml_multiuse_expression_element )* RIGHT_PAREN )
        // PLSQL_DMLParser.g:1055:10: xmlattributes_key LEFT_PAREN ( entityescaping_key | noentityescaping_key )? ( schemacheck_key | noschemacheck_key )? xml_multiuse_expression_element ( COMMA xml_multiuse_expression_element )* RIGHT_PAREN
        {
            this->followPush(FOLLOW_xmlattributes_key_in_xml_attributes_clause9986);
            m_gPLSQLParser->xmlattributes_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_attributes_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_xml_attributes_clause9996);
            if  (this->hasException())
            {
                goto rulexml_attributes_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1057:13: ( entityescaping_key | noentityescaping_key )?
            {
                int alt341=3;
                {
                    int LA341_0 = this->LA(1);
                    if ( (LA341_0 == REGULAR_ID))
                    {
                        {
                            int LA341_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "ENTITYESCAPING"))))
                            {
                                alt341=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "NOENTITYESCAPING"))))
                            {
                                alt341=2;
                            }
                        }
                    }
                }
                switch (alt341)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1057:14: entityescaping_key
            	    {
            	        this->followPush(FOLLOW_entityescaping_key_in_xml_attributes_clause10011);
            	        m_gPLSQLParser->entityescaping_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_attributes_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:1057:33: noentityescaping_key
            	    {
            	        this->followPush(FOLLOW_noentityescaping_key_in_xml_attributes_clause10013);
            	        m_gPLSQLParser->noentityescaping_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_attributes_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:1058:13: ( schemacheck_key | noschemacheck_key )?
            {
                int alt342=3;
                {
                    int LA342_0 = this->LA(1);
                    if ( (LA342_0 == REGULAR_ID))
                    {
                        {
                            int LA342_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "SCHEMACHECK"))))
                            {
                                alt342=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "NOSCHEMACHECK"))))
                            {
                                alt342=2;
                            }
                        }
                    }
                }
                switch (alt342)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1058:14: schemacheck_key
            	    {
            	        this->followPush(FOLLOW_schemacheck_key_in_xml_attributes_clause10030);
            	        m_gPLSQLParser->schemacheck_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_attributes_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:1058:30: noschemacheck_key
            	    {
            	        this->followPush(FOLLOW_noschemacheck_key_in_xml_attributes_clause10032);
            	        m_gPLSQLParser->noschemacheck_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_attributes_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause10048);
            xml_multiuse_expression_element();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_attributes_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1059:45: ( COMMA xml_multiuse_expression_element )*

            for (;;)
            {
                int alt343=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA343_0 = this->LA(1);
                    if ( (LA343_0 == COMMA))
                    {
                        alt343=1;
                    }

                }
                switch (alt343)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1059:46: COMMA xml_multiuse_expression_element
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_xml_attributes_clause10051);
            	        if  (this->hasException())
            	        {
            	            goto rulexml_attributes_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause10053);
            	        xml_multiuse_expression_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_attributes_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop343;	/* break out of the loop */
            	    break;
                }
            }
            loop343: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_xml_attributes_clause10065);
            if  (this->hasException())
            {
                goto rulexml_attributes_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexml_attributes_clauseEx; /* Prevent compiler warnings */
    rulexml_attributes_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xml_attributes_clause */

/**
 * $ANTLR start xml_namespaces_clause
 * PLSQL_DMLParser.g:1063:1: xml_namespaces_clause : xmlnamespaces_key LEFT_PAREN ( concatenation_wrapper column_alias )? ( COMMA concatenation_wrapper column_alias )* ( ( default_key )=> xml_general_default_part )? RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::xml_namespaces_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1064:5: ( xmlnamespaces_key LEFT_PAREN ( concatenation_wrapper column_alias )? ( COMMA concatenation_wrapper column_alias )* ( ( default_key )=> xml_general_default_part )? RIGHT_PAREN )
        // PLSQL_DMLParser.g:1064:10: xmlnamespaces_key LEFT_PAREN ( concatenation_wrapper column_alias )? ( COMMA concatenation_wrapper column_alias )* ( ( default_key )=> xml_general_default_part )? RIGHT_PAREN
        {
            this->followPush(FOLLOW_xmlnamespaces_key_in_xml_namespaces_clause10085);
            m_gPLSQLParser->xmlnamespaces_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_namespaces_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_xml_namespaces_clause10095);
            if  (this->hasException())
            {
                goto rulexml_namespaces_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1066:13: ( concatenation_wrapper column_alias )?
            {
                int alt344=2;
                {
                    int LA344_0 = this->LA(1);
                    if ( (LA344_0 == APPROXIMATE_NUM_LIT || LA344_0 == BINDVAR || ((LA344_0 >= CHAR_STRING) && (LA344_0 <= COLON)) || LA344_0 == DELIMITED_ID || LA344_0 == EXACT_NUM_LIT || LA344_0 == INTRODUCER || LA344_0 == LEFT_PAREN || ((LA344_0 >= MINUS_SIGN) && (LA344_0 <= NATIONAL_CHAR_STRING_LIT)) || LA344_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA344_0 == PLUS_SIGN || LA344_0 == REGULAR_ID || LA344_0 == SQL92_RESERVED_ALL || LA344_0 == SQL92_RESERVED_ANY || LA344_0 == SQL92_RESERVED_CASE || LA344_0 == SQL92_RESERVED_DATE || LA344_0 == SQL92_RESERVED_DISTINCT || ((LA344_0 >= SQL92_RESERVED_EXISTS) && (LA344_0 <= SQL92_RESERVED_FALSE)) || LA344_0 == SQL92_RESERVED_NULL || LA344_0 == SQL92_RESERVED_PRIOR || LA344_0 == SQL92_RESERVED_TRUE || LA344_0 == UNSIGNED_INTEGER))
                    {
                        alt344=1;
                    }
                    else if ( (LA344_0 == SQL92_RESERVED_DEFAULT))
                    {
                        alt344=1;
                    }
                }
                switch (alt344)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1066:14: concatenation_wrapper column_alias
            	    {
            	        this->followPush(FOLLOW_concatenation_wrapper_in_xml_namespaces_clause10110);
            	        concatenation_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_namespaces_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_alias_in_xml_namespaces_clause10112);
            	        m_gPLSQLParser->column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_namespaces_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:1067:17: ( COMMA concatenation_wrapper column_alias )*

            for (;;)
            {
                int alt345=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA345_0 = this->LA(1);
                    if ( (LA345_0 == COMMA))
                    {
                        alt345=1;
                    }

                }
                switch (alt345)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1067:18: COMMA concatenation_wrapper column_alias
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_xml_namespaces_clause10133);
            	        if  (this->hasException())
            	        {
            	            goto rulexml_namespaces_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_concatenation_wrapper_in_xml_namespaces_clause10135);
            	        concatenation_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_namespaces_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_alias_in_xml_namespaces_clause10137);
            	        m_gPLSQLParser->column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_namespaces_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop345;	/* break out of the loop */
            	    break;
                }
            }
            loop345: ; /* Jump out to here if this rule does not match */


            // PLSQL_DMLParser.g:1068:13: ( ( default_key )=> xml_general_default_part )?
            {
                int alt346=2;
                {
                    int LA346_0 = this->LA(1);
                    if ( (LA346_0 == SQL92_RESERVED_DEFAULT) && (this->msynpred( antlr3::ClassForwarder<synpred50_PLSQL_DMLParser>() )))
                    {
                        alt346=1;
                    }
                }
                switch (alt346)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1068:14: ( default_key )=> xml_general_default_part
            	    {
            	        this->followPush(FOLLOW_xml_general_default_part_in_xml_namespaces_clause10159);
            	        xml_general_default_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_namespaces_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_xml_namespaces_clause10171);
            if  (this->hasException())
            {
                goto rulexml_namespaces_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexml_namespaces_clauseEx; /* Prevent compiler warnings */
    rulexml_namespaces_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xml_namespaces_clause */

/**
 * $ANTLR start xml_table_column
 * PLSQL_DMLParser.g:1072:1: xml_table_column : xml_column_name ( for_key ordinality_key | type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )? ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::xml_table_column()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1073:5: ( xml_column_name ( for_key ordinality_key | type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )? ) )
        // PLSQL_DMLParser.g:1073:10: xml_column_name ( for_key ordinality_key | type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )? )
        {
            this->followPush(FOLLOW_xml_column_name_in_xml_table_column10191);
            m_gPLSQLParser->xml_column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_table_columnEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1074:5: ( for_key ordinality_key | type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )? )
            {
                int alt349=2;
                {
                    int LA349_0 = this->LA(1);
                    if ( (LA349_0 == SQL92_RESERVED_FOR))
                    {
                        alt349=1;
                    }
                    else if ( (LA349_0 == DELIMITED_ID || LA349_0 == REGULAR_ID || LA349_0 == SQL92_RESERVED_DATE))
                    {
                        alt349=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 349 );
                        ex->set_state( 0 );


                        goto rulexml_table_columnEx;

                    }
                }
                switch (alt349)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1074:10: for_key ordinality_key
            	    {
            	        this->followPush(FOLLOW_for_key_in_xml_table_column10202);
            	        m_gPLSQLParser->for_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_table_columnEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_ordinality_key_in_xml_table_column10204);
            	        m_gPLSQLParser->ordinality_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_table_columnEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:1075:10: type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )?
            	    {
            	        this->followPush(FOLLOW_type_spec_in_xml_table_column10215);
            	        m_gPLSQLParser->type_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_table_columnEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:1075:20: ( path_key concatenation_wrapper )?
            	        {
            	            int alt347=2;
            	            {
            	                int LA347_0 = this->LA(1);
            	                if ( (LA347_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "PATH"))))
            	                {
            	                    alt347=1;
            	                }
            	            }
            	            switch (alt347)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:1075:21: path_key concatenation_wrapper
            	        	    {
            	        	        this->followPush(FOLLOW_path_key_in_xml_table_column10218);
            	        	        m_gPLSQLParser->path_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexml_table_columnEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_concatenation_wrapper_in_xml_table_column10220);
            	        	        concatenation_wrapper();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexml_table_columnEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQL_DMLParser.g:1075:54: ( ( default_key )=> xml_general_default_part )?
            	        {
            	            int alt348=2;
            	            {
            	                int LA348_0 = this->LA(1);
            	                if ( (LA348_0 == SQL92_RESERVED_DEFAULT) && (this->msynpred( antlr3::ClassForwarder<synpred51_PLSQL_DMLParser>() )))
            	                {
            	                    alt348=1;
            	                }
            	            }
            	            switch (alt348)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:1075:55: ( default_key )=> xml_general_default_part
            	        	    {
            	        	        this->followPush(FOLLOW_xml_general_default_part_in_xml_table_column10230);
            	        	        xml_general_default_part();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexml_table_columnEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulexml_table_columnEx; /* Prevent compiler warnings */
    rulexml_table_columnEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xml_table_column */

/**
 * $ANTLR start xml_general_default_part
 * PLSQL_DMLParser.g:1079:1: xml_general_default_part : default_key concatenation_wrapper ;
 */
void
PLSQLParser_PLSQL_DMLParser::xml_general_default_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1080:5: ( default_key concatenation_wrapper )
        // PLSQL_DMLParser.g:1080:10: default_key concatenation_wrapper
        {
            this->followPush(FOLLOW_default_key_in_xml_general_default_part10258);
            m_gPLSQLParser->default_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_general_default_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_concatenation_wrapper_in_xml_general_default_part10260);
            concatenation_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_general_default_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexml_general_default_partEx; /* Prevent compiler warnings */
    rulexml_general_default_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xml_general_default_part */

/**
 * $ANTLR start xml_multiuse_expression_element
 * PLSQL_DMLParser.g:1083:1: xml_multiuse_expression_element : expression ( as_key ( id_expression | evalname_key concatenation ) )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::xml_multiuse_expression_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1084:5: ( expression ( as_key ( id_expression | evalname_key concatenation ) )? )
        // PLSQL_DMLParser.g:1084:10: expression ( as_key ( id_expression | evalname_key concatenation ) )?
        {
            this->followPush(FOLLOW_expression_in_xml_multiuse_expression_element10280);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_multiuse_expression_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1084:21: ( as_key ( id_expression | evalname_key concatenation ) )?
            {
                int alt351=2;
                {
                    int LA351_0 = this->LA(1);
                    if ( (LA351_0 == SQL92_RESERVED_AS))
                    {
                        alt351=1;
                    }
                }
                switch (alt351)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1084:22: as_key ( id_expression | evalname_key concatenation )
            	    {
            	        this->followPush(FOLLOW_as_key_in_xml_multiuse_expression_element10283);
            	        m_gPLSQLParser->as_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_multiuse_expression_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:1084:29: ( id_expression | evalname_key concatenation )
            	        {
            	            int alt350=2;
            	            {
            	                int LA350_0 = this->LA(1);
            	                if ( (LA350_0 == REGULAR_ID))
            	                {
            	                    {
            	                        int LA350_1 = this->LA(2);
            	                        if ( (LA350_1 == COMMA || LA350_1 == RIGHT_PAREN))
            	                        {
            	                            alt350=1;
            	                        }
            	                        else if ( (LA350_1 == APPROXIMATE_NUM_LIT || LA350_1 == BINDVAR || ((LA350_1 >= CHAR_STRING) && (LA350_1 <= COLON)) || LA350_1 == DELIMITED_ID || LA350_1 == EXACT_NUM_LIT || LA350_1 == INTRODUCER || LA350_1 == LEFT_PAREN || ((LA350_1 >= MINUS_SIGN) && (LA350_1 <= NATIONAL_CHAR_STRING_LIT)) || LA350_1 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA350_1 == PLUS_SIGN || LA350_1 == REGULAR_ID || LA350_1 == SQL92_RESERVED_ALL || LA350_1 == SQL92_RESERVED_ANY || LA350_1 == SQL92_RESERVED_CASE || LA350_1 == SQL92_RESERVED_DATE || LA350_1 == SQL92_RESERVED_DEFAULT || LA350_1 == SQL92_RESERVED_DISTINCT || ((LA350_1 >= SQL92_RESERVED_EXISTS) && (LA350_1 <= SQL92_RESERVED_FALSE)) || LA350_1 == SQL92_RESERVED_NULL || LA350_1 == SQL92_RESERVED_PRIOR || LA350_1 == SQL92_RESERVED_TRUE || LA350_1 == UNSIGNED_INTEGER) && ((equalsIgnoreCase(LT(1)->getText(), "EVALNAME"))))
            	                        {
            	                            alt350=2;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 350 );
            	                            ex->set_state( 1 );


            	                            goto rulexml_multiuse_expression_elementEx;

            	                        }
            	                    }
            	                }
            	                else if ( (LA350_0 == DELIMITED_ID))
            	                {
            	                    alt350=1;
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 350 );
            	                    ex->set_state( 0 );


            	                    goto rulexml_multiuse_expression_elementEx;

            	                }
            	            }
            	            switch (alt350)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:1084:30: id_expression
            	        	    {
            	        	        this->followPush(FOLLOW_id_expression_in_xml_multiuse_expression_element10286);
            	        	        m_gPLSQLParser->id_expression();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexml_multiuse_expression_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:1084:45: evalname_key concatenation
            	        	    {
            	        	        this->followPush(FOLLOW_evalname_key_in_xml_multiuse_expression_element10289);
            	        	        m_gPLSQLParser->evalname_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexml_multiuse_expression_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_concatenation_in_xml_multiuse_expression_element10291);
            	        	        concatenation();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexml_multiuse_expression_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulexml_multiuse_expression_elementEx; /* Prevent compiler warnings */
    rulexml_multiuse_expression_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xml_multiuse_expression_element */

/**
 * $ANTLR start xmlroot_param_version_part
 * PLSQL_DMLParser.g:1087:1: xmlroot_param_version_part : version_key ( no_key value_key | expression_wrapper ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::xmlroot_param_version_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1088:5: ( version_key ( no_key value_key | expression_wrapper ) )
        // PLSQL_DMLParser.g:1088:10: version_key ( no_key value_key | expression_wrapper )
        {
            this->followPush(FOLLOW_version_key_in_xmlroot_param_version_part10315);
            m_gPLSQLParser->version_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexmlroot_param_version_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1088:22: ( no_key value_key | expression_wrapper )
            {
                int alt352=2;
                {
                    int LA352_0 = this->LA(1);
                    if ( (LA352_0 == REGULAR_ID))
                    {
                        {
                            int LA352_1 = this->LA(2);
                            if ( (LA352_1 == REGULAR_ID))
                            {
                                {
                                    int LA352_3 = this->LA(3);
                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "NO"))))
                                    {
                                        alt352=1;
                                    }
                                    else if ( (true))
                                    {
                                        alt352=2;
                                    }
                                    else
                                    {
                                        if (this->get_backtracking()>0)
                                        {
                                            this->set_failedflag( true );
                                            return ;
                                        }


                                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                        ex->set_decisionNum( 352 );
                                        ex->set_state( 3 );


                                        goto rulexmlroot_param_version_partEx;

                                    }
                                }
                            }
                            else if ( (LA352_1 == MINUS_SIGN || LA352_1 == PLUS_SIGN))
                            {
                                alt352=2;
                            }
                            else if ( (LA352_1 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA352_1 == SQL92_RESERVED_ALL || LA352_1 == SQL92_RESERVED_DISTINCT || LA352_1 == SQL92_RESERVED_PRIOR) && (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
                                        equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
                                     )) )))
                            {
                                alt352=2;
                            }
                            else if ( (LA352_1 == DELIMITED_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||(( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
                                        equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
                                     )) )))))
                            {
                                alt352=2;
                            }
                            else if ( (LA352_1 == SQL92_RESERVED_CASE))
                            {
                                alt352=2;
                            }
                            else if ( (LA352_1 == SQL92_RESERVED_ANY || LA352_1 == SQL92_RESERVED_EXISTS) && (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
                                        equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
                                     )) )))
                            {
                                alt352=2;
                            }
                            else if ( (LA352_1 == INTRODUCER) && ((((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||(( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
                                        equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
                                     )) )))))
                            {
                                alt352=2;
                            }
                            else if ( (LA352_1 == BINDVAR || LA352_1 == COLON))
                            {
                                alt352=2;
                            }
                            else if ( (LA352_1 == APPROXIMATE_NUM_LIT || LA352_1 == EXACT_NUM_LIT || LA352_1 == SQL92_RESERVED_DATE || LA352_1 == UNSIGNED_INTEGER) && (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
                                        equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
                                     )) )))
                            {
                                alt352=2;
                            }
                            else if ( (((LA352_1 >= CHAR_STRING) && (LA352_1 <= CHAR_STRING_PERL)) || LA352_1 == NATIONAL_CHAR_STRING_LIT))
                            {
                                alt352=2;
                            }
                            else if ( (LA352_1 == SQL92_RESERVED_DEFAULT || LA352_1 == SQL92_RESERVED_FALSE || LA352_1 == SQL92_RESERVED_NULL || LA352_1 == SQL92_RESERVED_TRUE) && (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
                                        equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
                                     )) )))
                            {
                                alt352=2;
                            }
                            else if ( (LA352_1 == ASTERISK || LA352_1 == CARRET_OPERATOR_PART || LA352_1 == COMMA || LA352_1 == CONCATENATION_OP || LA352_1 == EQUALS_OP || LA352_1 == EXCLAMATION_OPERATOR_PART || ((LA352_1 >= GREATER_THAN_OP) && (LA352_1 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA352_1 >= LEFT_BRACKET) && (LA352_1 <= LESS_THAN_OR_EQUALS_OP)) || LA352_1 == NOT_EQUAL_OP || LA352_1 == PERIOD || LA352_1 == RIGHT_PAREN || LA352_1 == SOLIDUS || LA352_1 == SQL92_RESERVED_AND || LA352_1 == SQL92_RESERVED_BETWEEN || LA352_1 == SQL92_RESERVED_IN || ((LA352_1 >= SQL92_RESERVED_IS) && (LA352_1 <= SQL92_RESERVED_NOT)) || LA352_1 == SQL92_RESERVED_OR || LA352_1 == VERTICAL_BAR))
                            {
                                alt352=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 352 );
                                ex->set_state( 1 );


                                goto rulexmlroot_param_version_partEx;

                            }
                        }
                    }
                    else if ( (LA352_0 == APPROXIMATE_NUM_LIT || LA352_0 == BINDVAR || ((LA352_0 >= CHAR_STRING) && (LA352_0 <= COLON)) || LA352_0 == DELIMITED_ID || LA352_0 == EXACT_NUM_LIT || LA352_0 == INTRODUCER || LA352_0 == LEFT_PAREN || ((LA352_0 >= MINUS_SIGN) && (LA352_0 <= NATIONAL_CHAR_STRING_LIT)) || LA352_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA352_0 == PLUS_SIGN || LA352_0 == SQL92_RESERVED_ALL || LA352_0 == SQL92_RESERVED_ANY || LA352_0 == SQL92_RESERVED_CASE || ((LA352_0 >= SQL92_RESERVED_CURSOR) && (LA352_0 <= SQL92_RESERVED_DATE)) || LA352_0 == SQL92_RESERVED_DEFAULT || LA352_0 == SQL92_RESERVED_DISTINCT || ((LA352_0 >= SQL92_RESERVED_EXISTS) && (LA352_0 <= SQL92_RESERVED_FALSE)) || ((LA352_0 >= SQL92_RESERVED_NOT) && (LA352_0 <= SQL92_RESERVED_NULL)) || LA352_0 == SQL92_RESERVED_PRIOR || LA352_0 == SQL92_RESERVED_TRUE || LA352_0 == UNSIGNED_INTEGER))
                    {
                        alt352=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 352 );
                        ex->set_state( 0 );


                        goto rulexmlroot_param_version_partEx;

                    }
                }
                switch (alt352)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1088:23: no_key value_key
            	    {
            	        this->followPush(FOLLOW_no_key_in_xmlroot_param_version_part10318);
            	        m_gPLSQLParser->no_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexmlroot_param_version_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_value_key_in_xmlroot_param_version_part10320);
            	        m_gPLSQLParser->value_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexmlroot_param_version_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:1088:40: expression_wrapper
            	    {
            	        this->followPush(FOLLOW_expression_wrapper_in_xmlroot_param_version_part10322);
            	        expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexmlroot_param_version_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlroot_param_version_partEx; /* Prevent compiler warnings */
    rulexmlroot_param_version_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlroot_param_version_part */

/**
 * $ANTLR start xmlroot_param_standalone_part
 * PLSQL_DMLParser.g:1091:1: xmlroot_param_standalone_part : standalone_key ( yes_key | no_key ( value_key )? ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::xmlroot_param_standalone_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1092:5: ( standalone_key ( yes_key | no_key ( value_key )? ) )
        // PLSQL_DMLParser.g:1092:10: standalone_key ( yes_key | no_key ( value_key )? )
        {
            this->followPush(FOLLOW_standalone_key_in_xmlroot_param_standalone_part10343);
            m_gPLSQLParser->standalone_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexmlroot_param_standalone_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1092:25: ( yes_key | no_key ( value_key )? )
            {
                int alt354=2;
                {
                    int LA354_0 = this->LA(1);
                    if ( (LA354_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "YES")))||((equalsIgnoreCase(LT(1)->getText(), "NO"))))))
                    {
                        {
                            int LA354_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "YES"))))
                            {
                                alt354=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "NO"))))
                            {
                                alt354=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 354 );
                                ex->set_state( 1 );


                                goto rulexmlroot_param_standalone_partEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 354 );
                        ex->set_state( 0 );


                        goto rulexmlroot_param_standalone_partEx;

                    }
                }
                switch (alt354)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1092:26: yes_key
            	    {
            	        this->followPush(FOLLOW_yes_key_in_xmlroot_param_standalone_part10346);
            	        m_gPLSQLParser->yes_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexmlroot_param_standalone_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:1092:34: no_key ( value_key )?
            	    {
            	        this->followPush(FOLLOW_no_key_in_xmlroot_param_standalone_part10348);
            	        m_gPLSQLParser->no_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexmlroot_param_standalone_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:1092:41: ( value_key )?
            	        {
            	            int alt353=2;
            	            {
            	                int LA353_0 = this->LA(1);
            	                if ( (LA353_0 == REGULAR_ID))
            	                {
            	                    alt353=1;
            	                }
            	            }
            	            switch (alt353)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:1092:41: value_key
            	        	    {
            	        	        this->followPush(FOLLOW_value_key_in_xmlroot_param_standalone_part10350);
            	        	        m_gPLSQLParser->value_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexmlroot_param_standalone_partEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlroot_param_standalone_partEx; /* Prevent compiler warnings */
    rulexmlroot_param_standalone_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlroot_param_standalone_part */

/**
 * $ANTLR start xmlserialize_param_enconding_part
 * PLSQL_DMLParser.g:1095:1: xmlserialize_param_enconding_part : encoding_key concatenation_wrapper ;
 */
void
PLSQLParser_PLSQL_DMLParser::xmlserialize_param_enconding_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1096:5: ( encoding_key concatenation_wrapper )
        // PLSQL_DMLParser.g:1096:10: encoding_key concatenation_wrapper
        {
            this->followPush(FOLLOW_encoding_key_in_xmlserialize_param_enconding_part10372);
            m_gPLSQLParser->encoding_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexmlserialize_param_enconding_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_concatenation_wrapper_in_xmlserialize_param_enconding_part10374);
            concatenation_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexmlserialize_param_enconding_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlserialize_param_enconding_partEx; /* Prevent compiler warnings */
    rulexmlserialize_param_enconding_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlserialize_param_enconding_part */

/**
 * $ANTLR start xmlserialize_param_version_part
 * PLSQL_DMLParser.g:1099:1: xmlserialize_param_version_part : version_key concatenation_wrapper ;
 */
void
PLSQLParser_PLSQL_DMLParser::xmlserialize_param_version_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1100:5: ( version_key concatenation_wrapper )
        // PLSQL_DMLParser.g:1100:10: version_key concatenation_wrapper
        {
            this->followPush(FOLLOW_version_key_in_xmlserialize_param_version_part10394);
            m_gPLSQLParser->version_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexmlserialize_param_version_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_concatenation_wrapper_in_xmlserialize_param_version_part10396);
            concatenation_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexmlserialize_param_version_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlserialize_param_version_partEx; /* Prevent compiler warnings */
    rulexmlserialize_param_version_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlserialize_param_version_part */

/**
 * $ANTLR start xmlserialize_param_ident_part
 * PLSQL_DMLParser.g:1103:1: xmlserialize_param_ident_part : ( no_key indent_key | indent_key ( size_key EQUALS_OP concatenation_wrapper )? );
 */
void
PLSQLParser_PLSQL_DMLParser::xmlserialize_param_ident_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:1104:5: ( no_key indent_key | indent_key ( size_key EQUALS_OP concatenation_wrapper )? )

            ANTLR_UINT32 alt356;

            alt356=2;

            {
                int LA356_0 = this->LA(1);
                if ( (LA356_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "NO")))||((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))))
                {
                    {
                        int LA356_1 = this->LA(2);
                        if ( (LA356_1 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "NO")))||((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))))
                        {
                            {
                                int LA356_2 = this->LA(3);
                                if ( (LA356_2 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "NO")))||((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))))
                                {
                                    {
                                        int LA356_4 = this->LA(4);
                                        if ( (LA356_4 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "NO"))))
                                        {
                                            alt356=1;
                                        }
                                        else if ( (LA356_4 == RIGHT_PAREN) && ((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))
                                        {
                                            alt356=2;
                                        }
                                        else
                                        {
                                            if (this->get_backtracking()>0)
                                            {
                                                this->set_failedflag( true );
                                                return ;
                                            }


                                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                            ex->set_decisionNum( 356 );
                                            ex->set_state( 4 );


                                            goto rulexmlserialize_param_ident_partEx;

                                        }
                                    }
                                }
                                else if ( (LA356_2 == RIGHT_PAREN) && ((equalsIgnoreCase(LT(1)->getText(), "NO"))))
                                {
                                    alt356=1;
                                }
                                else
                                {
                                    if (this->get_backtracking()>0)
                                    {
                                        this->set_failedflag( true );
                                        return ;
                                    }


                                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                    ex->set_decisionNum( 356 );
                                    ex->set_state( 2 );


                                    goto rulexmlserialize_param_ident_partEx;

                                }
                            }
                        }
                        else if ( (LA356_1 == RIGHT_PAREN || LA356_1 == SQL92_RESERVED_SIZE) && ((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))
                        {
                            alt356=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 356 );
                            ex->set_state( 1 );


                            goto rulexmlserialize_param_ident_partEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 356 );
                    ex->set_state( 0 );


                    goto rulexmlserialize_param_ident_partEx;

                }
            }
            switch (alt356)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:1104:10: no_key indent_key
        	    {
        	        this->followPush(FOLLOW_no_key_in_xmlserialize_param_ident_part10416);
        	        m_gPLSQLParser->no_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulexmlserialize_param_ident_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_indent_key_in_xmlserialize_param_ident_part10418);
        	        m_gPLSQLParser->indent_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulexmlserialize_param_ident_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:1105:10: indent_key ( size_key EQUALS_OP concatenation_wrapper )?
        	    {
        	        this->followPush(FOLLOW_indent_key_in_xmlserialize_param_ident_part10429);
        	        m_gPLSQLParser->indent_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulexmlserialize_param_ident_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:1105:21: ( size_key EQUALS_OP concatenation_wrapper )?
        	        {
        	            int alt355=2;
        	            {
        	                int LA355_0 = this->LA(1);
        	                if ( (LA355_0 == SQL92_RESERVED_SIZE))
        	                {
        	                    alt355=1;
        	                }
        	            }
        	            switch (alt355)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:1105:22: size_key EQUALS_OP concatenation_wrapper
        	        	    {
        	        	        this->followPush(FOLLOW_size_key_in_xmlserialize_param_ident_part10432);
        	        	        m_gPLSQLParser->size_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulexmlserialize_param_ident_partEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_xmlserialize_param_ident_part10434);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulexmlserialize_param_ident_partEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_xmlserialize_param_ident_part10436);
        	        	        concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulexmlserialize_param_ident_partEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulexmlserialize_param_ident_partEx; /* Prevent compiler warnings */
    rulexmlserialize_param_ident_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlserialize_param_ident_part */

// $ANTLR start synpred1_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred1_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:69:28: ( order_key ( siblings_key )? by_key )
    // PLSQL_DMLParser.g:69:29: order_key ( siblings_key )? by_key
    {
        this->followPush(FOLLOW_order_key_in_synpred1_PLSQL_DMLParser356);
        m_gPLSQLParser->order_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred1_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        // PLSQL_DMLParser.g:69:39: ( siblings_key )?
        {
            int alt357=2;
            {
                int LA357_0 = this->LA(1);
                if ( (LA357_0 == REGULAR_ID) && ((equalsIgnoreCase(LT(1)->getText(), "SIBLINGS"))))
                {
                    alt357=1;
                }
            }
            switch (alt357)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:69:39: siblings_key
        	    {
        	        this->followPush(FOLLOW_siblings_key_in_synpred1_PLSQL_DMLParser358);
        	        m_gPLSQLParser->siblings_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred1_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

        this->followPush(FOLLOW_by_key_in_synpred1_PLSQL_DMLParser361);
        m_gPLSQLParser->by_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred1_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred1_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred1_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred1_PLSQL_DMLParser

// $ANTLR start synpred2_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred2_PLSQL_DMLParser_fragment(  )
{
    {
        //  PLSQL_DMLParser.g:109:10: ( distinct_key | unique_key | all_key )

        ANTLR_UINT32 alt358;

        alt358=3;

        switch ( this->LA(1) )
        {
        case SQL92_RESERVED_DISTINCT:
        	{
        		alt358=1;
        	}
            break;
        case SQL92_RESERVED_UNIQUE:
        	{
        		alt358=2;
        	}
            break;
        case SQL92_RESERVED_ALL:
        	{
        		alt358=3;
        	}
            break;

        default:
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 358 );
            ex->set_state( 0 );


            goto rulesynpred2_PLSQL_DMLParserEx;

        }

        switch (alt358)
        {
    	case 1:
    	    // PLSQL_DMLParser.g:109:11: distinct_key
    	    {
    	        this->followPush(FOLLOW_distinct_key_in_synpred2_PLSQL_DMLParser762);
    	        m_gPLSQLParser->distinct_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred2_PLSQL_DMLParserEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;
    	case 2:
    	    // PLSQL_DMLParser.g:109:24: unique_key
    	    {
    	        this->followPush(FOLLOW_unique_key_in_synpred2_PLSQL_DMLParser764);
    	        m_gPLSQLParser->unique_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred2_PLSQL_DMLParserEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;
    	case 3:
    	    // PLSQL_DMLParser.g:109:35: all_key
    	    {
    	        this->followPush(FOLLOW_all_key_in_synpred2_PLSQL_DMLParser766);
    	        m_gPLSQLParser->all_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred2_PLSQL_DMLParserEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;

        }
    }

goto rulesynpred2_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred2_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred2_PLSQL_DMLParser

// $ANTLR start synpred3_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred3_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:128:10: ( tableview_name PERIOD ASTERISK )
    // PLSQL_DMLParser.g:128:11: tableview_name PERIOD ASTERISK
    {
        this->followPush(FOLLOW_tableview_name_in_synpred3_PLSQL_DMLParser935);
        m_gPLSQLParser->tableview_name();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred3_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred3_PLSQL_DMLParser937);
        if  (this->hasException())
        {
            goto rulesynpred3_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_synpred3_PLSQL_DMLParser939);
        if  (this->hasException())
        {
            goto rulesynpred3_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred3_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred3_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred3_PLSQL_DMLParser

// $ANTLR start synpred4_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred4_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:146:10: ( LEFT_PAREN ( select_key | with_key ) )
    // PLSQL_DMLParser.g:146:11: LEFT_PAREN ( select_key | with_key )
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred4_PLSQL_DMLParser1046);
        if  (this->hasException())
        {
            goto rulesynpred4_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        // PLSQL_DMLParser.g:146:22: ( select_key | with_key )
        {
            int alt359=2;
            {
                int LA359_0 = this->LA(1);
                if ( (LA359_0 == SQL92_RESERVED_SELECT))
                {
                    alt359=1;
                }
                else if ( (LA359_0 == SQL92_RESERVED_WITH))
                {
                    alt359=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 359 );
                    ex->set_state( 0 );


                    goto rulesynpred4_PLSQL_DMLParserEx;

                }
            }
            switch (alt359)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:146:23: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred4_PLSQL_DMLParser1049);
        	        m_gPLSQLParser->select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred4_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:146:34: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred4_PLSQL_DMLParser1051);
        	        m_gPLSQLParser->with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred4_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

    }


goto rulesynpred4_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred4_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred4_PLSQL_DMLParser

// $ANTLR start synpred5_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred5_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:147:10: ( LEFT_PAREN )
    // PLSQL_DMLParser.g:147:11: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred5_PLSQL_DMLParser1076);
        if  (this->hasException())
        {
            goto rulesynpred5_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred5_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred5_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred5_PLSQL_DMLParser

// $ANTLR start synpred6_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred6_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:148:10: ( only_key LEFT_PAREN )
    // PLSQL_DMLParser.g:148:11: only_key LEFT_PAREN
    {
        this->followPush(FOLLOW_only_key_in_synpred6_PLSQL_DMLParser1107);
        m_gPLSQLParser->only_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred6_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred6_PLSQL_DMLParser1109);
        if  (this->hasException())
        {
            goto rulesynpred6_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred6_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred6_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred6_PLSQL_DMLParser

// $ANTLR start synpred7_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred7_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:184:10: ( LEFT_PAREN ( select_key | with_key ) )
    // PLSQL_DMLParser.g:184:11: LEFT_PAREN ( select_key | with_key )
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred7_PLSQL_DMLParser1423);
        if  (this->hasException())
        {
            goto rulesynpred7_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        // PLSQL_DMLParser.g:184:22: ( select_key | with_key )
        {
            int alt360=2;
            {
                int LA360_0 = this->LA(1);
                if ( (LA360_0 == SQL92_RESERVED_SELECT))
                {
                    alt360=1;
                }
                else if ( (LA360_0 == SQL92_RESERVED_WITH))
                {
                    alt360=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 360 );
                    ex->set_state( 0 );


                    goto rulesynpred7_PLSQL_DMLParserEx;

                }
            }
            switch (alt360)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:184:23: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred7_PLSQL_DMLParser1426);
        	        m_gPLSQLParser->select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred7_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:184:34: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred7_PLSQL_DMLParser1428);
        	        m_gPLSQLParser->with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred7_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

    }


goto rulesynpred7_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred7_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred7_PLSQL_DMLParser

// $ANTLR start synpred8_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred8_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:185:10: ( LEFT_PAREN )
    // PLSQL_DMLParser.g:185:11: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred8_PLSQL_DMLParser1450);
        if  (this->hasException())
        {
            goto rulesynpred8_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred8_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred8_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred8_PLSQL_DMLParser

// $ANTLR start synpred9_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred9_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:218:18: ( select_key )
    // PLSQL_DMLParser.g:218:19: select_key
    {
        this->followPush(FOLLOW_select_key_in_synpred9_PLSQL_DMLParser1764);
        m_gPLSQLParser->select_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred9_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred9_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred9_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred9_PLSQL_DMLParser

// $ANTLR start synpred10_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred10_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:219:18: ( any_key )
    // PLSQL_DMLParser.g:219:19: any_key
    {
        this->followPush(FOLLOW_any_key_in_synpred10_PLSQL_DMLParser1789);
        m_gPLSQLParser->any_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred10_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred10_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred10_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred10_PLSQL_DMLParser

// $ANTLR start synpred11_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred11_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:231:10: ( LEFT_PAREN )
    // PLSQL_DMLParser.g:231:11: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred11_PLSQL_DMLParser1905);
        if  (this->hasException())
        {
            goto rulesynpred11_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred11_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred11_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred11_PLSQL_DMLParser

// $ANTLR start synpred12_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred12_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:259:15: ( LEFT_PAREN )
    // PLSQL_DMLParser.g:259:16: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred12_PLSQL_DMLParser2230);
        if  (this->hasException())
        {
            goto rulesynpred12_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred12_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred12_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred12_PLSQL_DMLParser

// $ANTLR start synpred13_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred13_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:274:9: ( group_key )
    // PLSQL_DMLParser.g:274:10: group_key
    {
        this->followPush(FOLLOW_group_key_in_synpred13_PLSQL_DMLParser2361);
        m_gPLSQLParser->group_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred13_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred13_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred13_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred13_PLSQL_DMLParser

// $ANTLR start synpred14_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred14_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:275:14: ( COMMA group_by_elements )
    // PLSQL_DMLParser.g:275:15: COMMA group_by_elements
    {
         this->matchToken(COMMA, &FOLLOW_COMMA_in_synpred14_PLSQL_DMLParser2386);
        if  (this->hasException())
        {
            goto rulesynpred14_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_group_by_elements_in_synpred14_PLSQL_DMLParser2388);
        group_by_elements();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred14_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred14_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred14_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred14_PLSQL_DMLParser

// $ANTLR start synpred15_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred15_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:277:9: ( having_key )
    // PLSQL_DMLParser.g:277:10: having_key
    {
        this->followPush(FOLLOW_having_key_in_synpred15_PLSQL_DMLParser2422);
        m_gPLSQLParser->having_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred15_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred15_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred15_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred15_PLSQL_DMLParser

// $ANTLR start synpred16_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred16_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:279:14: ( COMMA group_by_elements )
    // PLSQL_DMLParser.g:279:15: COMMA group_by_elements
    {
         this->matchToken(COMMA, &FOLLOW_COMMA_in_synpred16_PLSQL_DMLParser2462);
        if  (this->hasException())
        {
            goto rulesynpred16_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_group_by_elements_in_synpred16_PLSQL_DMLParser2464);
        group_by_elements();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred16_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred16_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred16_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred16_PLSQL_DMLParser

// $ANTLR start synpred17_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred17_PLSQL_DMLParser_fragment(  )
{
    {
        //  PLSQL_DMLParser.g:298:10: ( rollup_key | cube_key )

        ANTLR_UINT32 alt361;

        alt361=2;

        {
            int LA361_0 = this->LA(1);
            if ( (LA361_0 == REGULAR_ID) && ((((equalsIgnoreCase(LT(1)->getText(), "CUBE")))||((equalsIgnoreCase(LT(1)->getText(), "ROLLUP"))))))
            {
                {
                    int LA361_1 = this->LA(2);
                    if ( ((equalsIgnoreCase(LT(1)->getText(), "ROLLUP"))))
                    {
                        alt361=1;
                    }
                    else if ( ((equalsIgnoreCase(LT(1)->getText(), "CUBE"))))
                    {
                        alt361=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 361 );
                        ex->set_state( 1 );


                        goto rulesynpred17_PLSQL_DMLParserEx;

                    }
                }
            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }


                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 361 );
                ex->set_state( 0 );


                goto rulesynpred17_PLSQL_DMLParserEx;

            }
        }
        switch (alt361)
        {
    	case 1:
    	    // PLSQL_DMLParser.g:298:11: rollup_key
    	    {
    	        this->followPush(FOLLOW_rollup_key_in_synpred17_PLSQL_DMLParser2620);
    	        m_gPLSQLParser->rollup_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred17_PLSQL_DMLParserEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;
    	case 2:
    	    // PLSQL_DMLParser.g:298:22: cube_key
    	    {
    	        this->followPush(FOLLOW_cube_key_in_synpred17_PLSQL_DMLParser2622);
    	        m_gPLSQLParser->cube_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred17_PLSQL_DMLParserEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;

        }
    }

goto rulesynpred17_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred17_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred17_PLSQL_DMLParser

// $ANTLR start synpred18_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred18_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:299:10: ( LEFT_PAREN )
    // PLSQL_DMLParser.g:299:11: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred18_PLSQL_DMLParser2638);
        if  (this->hasException())
        {
            goto rulesynpred18_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred18_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred18_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred18_PLSQL_DMLParser

// $ANTLR start synpred19_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred19_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:356:34: ( all_key )
    // PLSQL_DMLParser.g:356:35: all_key
    {
        this->followPush(FOLLOW_all_key_in_synpred19_PLSQL_DMLParser3096);
        m_gPLSQLParser->all_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred19_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred19_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred19_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred19_PLSQL_DMLParser

// $ANTLR start synpred20_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred20_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:481:13: ( when_key matched_key )
    // PLSQL_DMLParser.g:481:14: when_key matched_key
    {
        this->followPush(FOLLOW_when_key_in_synpred20_PLSQL_DMLParser4047);
        m_gPLSQLParser->when_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred20_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_matched_key_in_synpred20_PLSQL_DMLParser4049);
        m_gPLSQLParser->matched_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred20_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred20_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred20_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred20_PLSQL_DMLParser

// $ANTLR start synpred21_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred21_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:483:13: ( when_key not_key matched_key )
    // PLSQL_DMLParser.g:483:14: when_key not_key matched_key
    {
        this->followPush(FOLLOW_when_key_in_synpred21_PLSQL_DMLParser4082);
        m_gPLSQLParser->when_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred21_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_not_key_in_synpred21_PLSQL_DMLParser4084);
        m_gPLSQLParser->not_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred21_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_matched_key_in_synpred21_PLSQL_DMLParser4086);
        m_gPLSQLParser->matched_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred21_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred21_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred21_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred21_PLSQL_DMLParser

// $ANTLR start synpred22_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred22_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:558:10: ( LEFT_PAREN )
    // PLSQL_DMLParser.g:558:11: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred22_PLSQL_DMLParser4675);
        if  (this->hasException())
        {
            goto rulesynpred22_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred22_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred22_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred22_PLSQL_DMLParser

// $ANTLR start synpred23_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred23_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:567:32: ( unlimited_key )
    // PLSQL_DMLParser.g:567:33: unlimited_key
    {
        this->followPush(FOLLOW_unlimited_key_in_synpred23_PLSQL_DMLParser4740);
        m_gPLSQLParser->unlimited_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred23_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred23_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred23_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred23_PLSQL_DMLParser

// $ANTLR start synpred24_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred24_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:578:12: ( LEFT_PAREN ( select_key | with_key ) )
    // PLSQL_DMLParser.g:578:13: LEFT_PAREN ( select_key | with_key )
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred24_PLSQL_DMLParser4839);
        if  (this->hasException())
        {
            goto rulesynpred24_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        // PLSQL_DMLParser.g:578:24: ( select_key | with_key )
        {
            int alt362=2;
            {
                int LA362_0 = this->LA(1);
                if ( (LA362_0 == SQL92_RESERVED_SELECT))
                {
                    alt362=1;
                }
                else if ( (LA362_0 == SQL92_RESERVED_WITH))
                {
                    alt362=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 362 );
                    ex->set_state( 0 );


                    goto rulesynpred24_PLSQL_DMLParserEx;

                }
            }
            switch (alt362)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:578:25: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred24_PLSQL_DMLParser4842);
        	        m_gPLSQLParser->select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred24_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:578:38: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred24_PLSQL_DMLParser4846);
        	        m_gPLSQLParser->with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred24_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

    }


goto rulesynpred24_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred24_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred24_PLSQL_DMLParser

// $ANTLR start synpred25_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred25_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:620:10: ( cursor_key LEFT_PAREN ( select_key | with_key ) )
    // PLSQL_DMLParser.g:620:11: cursor_key LEFT_PAREN ( select_key | with_key )
    {
        this->followPush(FOLLOW_cursor_key_in_synpred25_PLSQL_DMLParser5149);
        m_gPLSQLParser->cursor_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred25_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred25_PLSQL_DMLParser5151);
        if  (this->hasException())
        {
            goto rulesynpred25_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        // PLSQL_DMLParser.g:620:33: ( select_key | with_key )
        {
            int alt363=2;
            {
                int LA363_0 = this->LA(1);
                if ( (LA363_0 == SQL92_RESERVED_SELECT))
                {
                    alt363=1;
                }
                else if ( (LA363_0 == SQL92_RESERVED_WITH))
                {
                    alt363=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 363 );
                    ex->set_state( 0 );


                    goto rulesynpred25_PLSQL_DMLParserEx;

                }
            }
            switch (alt363)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:620:34: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred25_PLSQL_DMLParser5154);
        	        m_gPLSQLParser->select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred25_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:620:45: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred25_PLSQL_DMLParser5156);
        	        m_gPLSQLParser->with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred25_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

    }


goto rulesynpred25_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred25_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred25_PLSQL_DMLParser

// $ANTLR start synpred26_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred26_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:689:10: ( ( LEFT_PAREN )+ ( select_key | with_key ) )
    // PLSQL_DMLParser.g:689:11: ( LEFT_PAREN )+ ( select_key | with_key )
    {
        // PLSQL_DMLParser.g:689:11: ( LEFT_PAREN )+
        {
            int cnt364=0;

            for (;;)
            {
                int alt364=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA364_0 = this->LA(1);
        	    if ( (LA364_0 == LEFT_PAREN))
        	    {
        	        alt364=1;
        	    }

        	}
        	switch (alt364)
        	{
        	    case 1:
        	        // PLSQL_DMLParser.g:689:11: LEFT_PAREN
        	        {
        	             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred26_PLSQL_DMLParser5766);
        	            if  (this->hasException())
        	            {
        	                goto rulesynpred26_PLSQL_DMLParserEx;
        	            }
        	            if (this->hasFailed())
        	            {
        	                return ;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt364 >= 1 )
        		{
        		    goto loop364;
        		}
        		if (this->get_backtracking()>0)
        		{
        		    this->set_failedflag( true );
        		    return ;
        		}

        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto rulesynpred26_PLSQL_DMLParserEx;
        	}
        	cnt364++;
            }
            loop364: ;	/* Jump to here if this rule does not match */
        }

        // PLSQL_DMLParser.g:689:23: ( select_key | with_key )
        {
            int alt365=2;
            {
                int LA365_0 = this->LA(1);
                if ( (LA365_0 == SQL92_RESERVED_SELECT))
                {
                    alt365=1;
                }
                else if ( (LA365_0 == SQL92_RESERVED_WITH))
                {
                    alt365=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 365 );
                    ex->set_state( 0 );


                    goto rulesynpred26_PLSQL_DMLParserEx;

                }
            }
            switch (alt365)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:689:24: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred26_PLSQL_DMLParser5770);
        	        m_gPLSQLParser->select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred26_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:689:35: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred26_PLSQL_DMLParser5772);
        	        m_gPLSQLParser->with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred26_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

    }


goto rulesynpred26_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred26_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred26_PLSQL_DMLParser

// $ANTLR start synpred27_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred27_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:719:10: ( interval_expression )
    // PLSQL_DMLParser.g:719:11: interval_expression
    {
        this->followPush(FOLLOW_interval_expression_in_synpred27_PLSQL_DMLParser6033);
        interval_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred27_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred27_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred27_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred27_PLSQL_DMLParser

// $ANTLR start synpred28_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred28_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:734:11: ( any_key )
    // PLSQL_DMLParser.g:734:12: any_key
    {
        this->followPush(FOLLOW_any_key_in_synpred28_PLSQL_DMLParser6172);
        m_gPLSQLParser->any_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred28_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred28_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred28_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred28_PLSQL_DMLParser

// $ANTLR start synpred29_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred29_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:734:58: ( any_key )
    // PLSQL_DMLParser.g:734:59: any_key
    {
        this->followPush(FOLLOW_any_key_in_synpred29_PLSQL_DMLParser6186);
        m_gPLSQLParser->any_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred29_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred29_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred29_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred29_PLSQL_DMLParser

// $ANTLR start synpred30_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred30_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:759:18: ( select_key )
    // PLSQL_DMLParser.g:759:19: select_key
    {
        this->followPush(FOLLOW_select_key_in_synpred30_PLSQL_DMLParser6431);
        m_gPLSQLParser->select_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred30_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred30_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred30_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred30_PLSQL_DMLParser

// $ANTLR start synpred31_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred31_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:760:18: ( LEFT_PAREN )
    // PLSQL_DMLParser.g:760:19: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred31_PLSQL_DMLParser6455);
        if  (this->hasException())
        {
            goto rulesynpred31_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred31_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred31_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred31_PLSQL_DMLParser

// $ANTLR start synpred36_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred36_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:779:10: ({...}? => new_key unary_expression )
    // PLSQL_DMLParser.g:779:10: {...}? => new_key unary_expression
    {
        if ( !(( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
                    equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
                 )) )
        {
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), " // input.LT(1).getText().equalsIgnoreCase(\"new\") && !input.LT(2).getText().equals(\".\")}?\n            equalsIgnoreCase(LT(1)->getText(), \"NEW\") && !equalsIgnoreCase(LT(2)->getText(), \".\" )\n         " );
                ex->set_ruleName( "synpred36_PLSQL_DMLParser" );


        }

        this->followPush(FOLLOW_new_key_in_synpred36_PLSQL_DMLParser6601);
        m_gPLSQLParser->new_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred36_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_unary_expression_in_synpred36_PLSQL_DMLParser6603);
        unary_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred36_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred36_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred36_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred36_PLSQL_DMLParser

// $ANTLR start synpred38_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred38_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:783:10: ( all_key unary_expression )
    // PLSQL_DMLParser.g:783:10: all_key unary_expression
    {
        this->followPush(FOLLOW_all_key_in_synpred38_PLSQL_DMLParser6627);
        m_gPLSQLParser->all_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred38_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_unary_expression_in_synpred38_PLSQL_DMLParser6629);
        unary_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred38_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred38_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred38_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred38_PLSQL_DMLParser

// $ANTLR start synpred39_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred39_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:784:10: ({...}? case_statement[false] )
    // PLSQL_DMLParser.g:784:10: {...}? case_statement[false]
    {
        if ( !(( LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE )) )
        {
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), " LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE " );
                ex->set_ruleName( "synpred39_PLSQL_DMLParser" );


        }

        this->followPush(FOLLOW_case_statement_in_synpred39_PLSQL_DMLParser6642);
        case_statement(false);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred39_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred39_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred39_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred39_PLSQL_DMLParser

// $ANTLR start synpred40_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred40_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:785:10: ( quantified_expression )
    // PLSQL_DMLParser.g:785:10: quantified_expression
    {
        this->followPush(FOLLOW_quantified_expression_in_synpred40_PLSQL_DMLParser6654);
        quantified_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred40_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred40_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred40_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred40_PLSQL_DMLParser

// $ANTLR start synpred41_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred41_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:786:10: ( standard_function )
    // PLSQL_DMLParser.g:786:10: standard_function
    {
        this->followPush(FOLLOW_standard_function_in_synpred41_PLSQL_DMLParser6665);
        standard_function();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred41_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred41_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred41_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred41_PLSQL_DMLParser

// $ANTLR start synpred42_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred42_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:795:10: ( ( label_name )? case_key when_key )
    // PLSQL_DMLParser.g:795:11: ( label_name )? case_key when_key
    {
        // PLSQL_DMLParser.g:795:11: ( label_name )?
        {
            int alt366=2;
            {
                int LA366_0 = this->LA(1);
                if ( (LA366_0 == DELIMITED_ID || LA366_0 == REGULAR_ID))
                {
                    alt366=1;
                }
            }
            switch (alt366)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:795:11: label_name
        	    {
        	        this->followPush(FOLLOW_label_name_in_synpred42_PLSQL_DMLParser6714);
        	        m_gPLSQLParser->label_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred42_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

        this->followPush(FOLLOW_case_key_in_synpred42_PLSQL_DMLParser6717);
        m_gPLSQLParser->case_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred42_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_when_key_in_synpred42_PLSQL_DMLParser6719);
        m_gPLSQLParser->when_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred42_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred42_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred42_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred42_PLSQL_DMLParser

// $ANTLR start synpred43_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred43_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:833:10: ( table_element outer_join_sign )
    // PLSQL_DMLParser.g:833:11: table_element outer_join_sign
    {
        this->followPush(FOLLOW_table_element_in_synpred43_PLSQL_DMLParser6994);
        m_gPLSQLParser->table_element();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred43_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_outer_join_sign_in_synpred43_PLSQL_DMLParser6996);
        m_gPLSQLParser->outer_join_sign();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred43_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred43_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred43_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred43_PLSQL_DMLParser

// $ANTLR start synpred45_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred45_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:835:10: ( constant )
    // PLSQL_DMLParser.g:835:10: constant
    {
        this->followPush(FOLLOW_constant_in_synpred45_PLSQL_DMLParser7025);
        m_gPLSQLParser->constant();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred45_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred45_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred45_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred45_PLSQL_DMLParser

// $ANTLR start synpred46_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred46_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:836:10: ( general_element )
    // PLSQL_DMLParser.g:836:10: general_element
    {
        this->followPush(FOLLOW_general_element_in_synpred46_PLSQL_DMLParser7036);
        m_gPLSQLParser->general_element();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred46_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred46_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred46_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred46_PLSQL_DMLParser

// $ANTLR start synpred47_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred47_PLSQL_DMLParser_fragment(  )
{
    {
        //  PLSQL_DMLParser.g:839:15: ( select_key | with_key )

        ANTLR_UINT32 alt367;

        alt367=2;

        {
            int LA367_0 = this->LA(1);
            if ( (LA367_0 == SQL92_RESERVED_SELECT))
            {
                alt367=1;
            }
            else if ( (LA367_0 == SQL92_RESERVED_WITH))
            {
                alt367=2;
            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }


                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 367 );
                ex->set_state( 0 );


                goto rulesynpred47_PLSQL_DMLParserEx;

            }
        }
        switch (alt367)
        {
    	case 1:
    	    // PLSQL_DMLParser.g:839:17: select_key
    	    {
    	        this->followPush(FOLLOW_select_key_in_synpred47_PLSQL_DMLParser7076);
    	        m_gPLSQLParser->select_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred47_PLSQL_DMLParserEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;
    	case 2:
    	    // PLSQL_DMLParser.g:839:30: with_key
    	    {
    	        this->followPush(FOLLOW_with_key_in_synpred47_PLSQL_DMLParser7080);
    	        m_gPLSQLParser->with_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred47_PLSQL_DMLParserEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;

        }
    }

goto rulesynpred47_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred47_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred47_PLSQL_DMLParser

// $ANTLR start synpred48_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred48_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:854:12: ( LEFT_PAREN ( select_key | with_key ) )
    // PLSQL_DMLParser.g:854:13: LEFT_PAREN ( select_key | with_key )
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred48_PLSQL_DMLParser7224);
        if  (this->hasException())
        {
            goto rulesynpred48_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        // PLSQL_DMLParser.g:854:24: ( select_key | with_key )
        {
            int alt368=2;
            {
                int LA368_0 = this->LA(1);
                if ( (LA368_0 == SQL92_RESERVED_SELECT))
                {
                    alt368=1;
                }
                else if ( (LA368_0 == SQL92_RESERVED_WITH))
                {
                    alt368=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 368 );
                    ex->set_state( 0 );


                    goto rulesynpred48_PLSQL_DMLParserEx;

                }
            }
            switch (alt368)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:854:25: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred48_PLSQL_DMLParser7227);
        	        m_gPLSQLParser->select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred48_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:854:36: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred48_PLSQL_DMLParser7229);
        	        m_gPLSQLParser->with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred48_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

    }


goto rulesynpred48_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred48_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred48_PLSQL_DMLParser

// $ANTLR start synpred49_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred49_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:868:12: ( multiset_key ( LEFT_PAREN )+ ( select_key | with_key ) )
    // PLSQL_DMLParser.g:868:13: multiset_key ( LEFT_PAREN )+ ( select_key | with_key )
    {
        this->followPush(FOLLOW_multiset_key_in_synpred49_PLSQL_DMLParser7431);
        m_gPLSQLParser->multiset_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred49_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        // PLSQL_DMLParser.g:868:26: ( LEFT_PAREN )+
        {
            int cnt369=0;

            for (;;)
            {
                int alt369=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA369_0 = this->LA(1);
        	    if ( (LA369_0 == LEFT_PAREN))
        	    {
        	        alt369=1;
        	    }

        	}
        	switch (alt369)
        	{
        	    case 1:
        	        // PLSQL_DMLParser.g:868:26: LEFT_PAREN
        	        {
        	             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred49_PLSQL_DMLParser7433);
        	            if  (this->hasException())
        	            {
        	                goto rulesynpred49_PLSQL_DMLParserEx;
        	            }
        	            if (this->hasFailed())
        	            {
        	                return ;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt369 >= 1 )
        		{
        		    goto loop369;
        		}
        		if (this->get_backtracking()>0)
        		{
        		    this->set_failedflag( true );
        		    return ;
        		}

        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto rulesynpred49_PLSQL_DMLParserEx;
        	}
        	cnt369++;
            }
            loop369: ;	/* Jump to here if this rule does not match */
        }

        // PLSQL_DMLParser.g:868:38: ( select_key | with_key )
        {
            int alt370=2;
            {
                int LA370_0 = this->LA(1);
                if ( (LA370_0 == SQL92_RESERVED_SELECT))
                {
                    alt370=1;
                }
                else if ( (LA370_0 == SQL92_RESERVED_WITH))
                {
                    alt370=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 370 );
                    ex->set_state( 0 );


                    goto rulesynpred49_PLSQL_DMLParserEx;

                }
            }
            switch (alt370)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:868:39: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred49_PLSQL_DMLParser7437);
        	        m_gPLSQLParser->select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred49_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:868:50: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred49_PLSQL_DMLParser7439);
        	        m_gPLSQLParser->with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred49_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

    }


goto rulesynpred49_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred49_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred49_PLSQL_DMLParser

// $ANTLR start synpred50_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred50_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:1068:14: ( default_key )
    // PLSQL_DMLParser.g:1068:15: default_key
    {
        this->followPush(FOLLOW_default_key_in_synpred50_PLSQL_DMLParser10155);
        m_gPLSQLParser->default_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred50_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred50_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred50_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred50_PLSQL_DMLParser

// $ANTLR start synpred51_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred51_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:1075:55: ( default_key )
    // PLSQL_DMLParser.g:1075:56: default_key
    {
        this->followPush(FOLLOW_default_key_in_synpred51_PLSQL_DMLParser10226);
        m_gPLSQLParser->default_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred51_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred51_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred51_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred51_PLSQL_DMLParser
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred11_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred11_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred13_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred13_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred20_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred20_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred26_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred26_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred31_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred31_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred40_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred40_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred22_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred22_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred1_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred1_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred45_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred45_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred12_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred12_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred14_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred14_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred21_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred21_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred16_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred16_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred4_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred4_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred47_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred47_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred19_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred19_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred8_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred8_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred9_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred9_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred27_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred27_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred6_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred6_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred39_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred39_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred2_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred2_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred28_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred28_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred51_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred51_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred23_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred23_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred10_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred10_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred18_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred18_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred17_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred17_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred24_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred24_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred38_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred38_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred25_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred25_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred3_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred3_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred50_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred50_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred5_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred5_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred42_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred42_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred46_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred46_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred43_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred43_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred48_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred48_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred7_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred7_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred36_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred36_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred30_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred30_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred15_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred15_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred41_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred41_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred49_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred49_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred29_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred29_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

}

/* End of code
 * =============================================================================
 */
