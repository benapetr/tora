/** \file
 *  This C++ source file was generated by $ANTLR version 3.5.1-SNAPSHOT
 *
 *     -  From the grammar source file : PLSQL_DMLParser.g
 *     -                            On : 2013-06-21 14:01:34
 *     -                for the parser : PLSQLParser_PLSQL_DMLParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "PLSQLParser_PLSQL_DMLParser.hpp"
// Include delegator definition header files
//
#include "PLSQLParser.hpp" 

/* ----------------------------------------- */

/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

namespace  User  {
using namespace antlr3;

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "PLSQL_DMLParser.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* PLSQLParser_PLSQL_DMLParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new PLSQLParser_PLSQL_DMLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PLSQLParser_PLSQL_DMLParser::PLSQLParser_PLSQL_DMLParser( StreamType* instream, PLSQLParser* gPLSQLParser)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream, gPLSQLParser);
}

/** \brief Create a new PLSQLParser_PLSQL_DMLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
PLSQLParser_PLSQL_DMLParser::PLSQLParser_PLSQL_DMLParser( StreamType* instream, RecognizerSharedStateType* state, PLSQLParser* gPLSQLParser)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream , gPLSQLParser);
}

void PLSQLParser_PLSQL_DMLParser::init(StreamType* instream, PLSQLParser* gPLSQLParser)
{
     	// Install the pointers back to lexers that will delegate us to perform certain functions
     	// for them.
     	//
     		m_gPLSQLParser = gPLSQLParser;
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( PLSQLParserTokenNames );


}

void
PLSQLParser_PLSQL_DMLParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
PLSQLParser_PLSQL_DMLParser::~PLSQLParser_PLSQL_DMLParser()
 {
}

/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return PLSQLParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_explain_key_in_explain_statement187_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_explain_key_in_explain_statement187( FOLLOW_explain_key_in_explain_statement187_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_plan_key_in_explain_statement189_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080400000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_plan_key_in_explain_statement189( FOLLOW_plan_key_in_explain_statement189_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_set_key_in_explain_statement201_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_set_key_in_explain_statement201( FOLLOW_set_key_in_explain_statement201_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_statement_id_key_in_explain_statement203_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_statement_id_key_in_explain_statement203( FOLLOW_statement_id_key_in_explain_statement203_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_explain_statement205_bits[]	= { ANTLR_UINT64_LIT(0x0000000400003000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_explain_statement205( FOLLOW_EQUALS_OP_in_explain_statement205_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_explain_statement207_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080400000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_quoted_string_in_explain_statement207( FOLLOW_quoted_string_in_explain_statement207_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_into_key_in_explain_statement221_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_into_key_in_explain_statement221( FOLLOW_into_key_in_explain_statement221_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_explain_statement223_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_explain_statement223( FOLLOW_tableview_name_in_explain_statement223_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_key_in_explain_statement236_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0020001000000400), ANTLR_UINT64_LIT(0x0000000000108040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_key_in_explain_statement236( FOLLOW_for_key_in_explain_statement236_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_explain_statement249_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_statement_in_explain_statement249( FOLLOW_select_statement_in_explain_statement249_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_update_statement_in_explain_statement262_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_update_statement_in_explain_statement262( FOLLOW_update_statement_in_explain_statement262_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_delete_statement_in_explain_statement275_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_delete_statement_in_explain_statement275( FOLLOW_delete_statement_in_explain_statement275_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_insert_statement_in_explain_statement288_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_insert_statement_in_explain_statement288( FOLLOW_insert_statement_in_explain_statement288_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_merge_statement_in_explain_statement301_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_merge_statement_in_explain_statement301( FOLLOW_merge_statement_in_explain_statement301_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_factoring_clause_in_select_statement332_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_factoring_clause_in_select_statement332( FOLLOW_subquery_factoring_clause_in_select_statement332_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_select_statement343_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000400000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_select_statement343( FOLLOW_subquery_in_select_statement343_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_update_clause_in_select_statement354_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000400000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_update_clause_in_select_statement354( FOLLOW_for_update_clause_in_select_statement354_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_select_statement366_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000400000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_by_clause_in_select_statement366( FOLLOW_order_by_clause_in_select_statement366_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_subquery_factoring_clause389_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_subquery_factoring_clause389( FOLLOW_with_key_in_subquery_factoring_clause389_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_factoring_element_in_subquery_factoring_clause391_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_factoring_element_in_subquery_factoring_clause391( FOLLOW_factoring_element_in_subquery_factoring_clause391_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_subquery_factoring_clause394_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_subquery_factoring_clause394( FOLLOW_COMMA_in_subquery_factoring_clause394_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_factoring_element_in_subquery_factoring_clause396_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_factoring_element_in_subquery_factoring_clause396( FOLLOW_factoring_element_in_subquery_factoring_clause396_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_query_name_in_factoring_element418_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000400000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_query_name_in_factoring_element418( FOLLOW_query_name_in_factoring_element418_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_factoring_element421_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_factoring_element421( FOLLOW_LEFT_PAREN_in_factoring_element421_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_factoring_element423_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_factoring_element423( FOLLOW_column_name_in_factoring_element423_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_factoring_element426_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_factoring_element426( FOLLOW_COMMA_in_factoring_element426_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_factoring_element428_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_factoring_element428( FOLLOW_column_name_in_factoring_element428_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_factoring_element432_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000400000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_factoring_element432( FOLLOW_RIGHT_PAREN_in_factoring_element432_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_factoring_element436_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_as_key_in_factoring_element436( FOLLOW_as_key_in_factoring_element436_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_factoring_element438_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_factoring_element438( FOLLOW_LEFT_PAREN_in_factoring_element438_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_factoring_element440_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_factoring_element440( FOLLOW_subquery_in_factoring_element440_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_factoring_element442_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_by_clause_in_factoring_element442( FOLLOW_order_by_clause_in_factoring_element442_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_factoring_element445_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_factoring_element445( FOLLOW_RIGHT_PAREN_in_factoring_element445_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_search_clause_in_factoring_element456_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_search_clause_in_factoring_element456( FOLLOW_search_clause_in_factoring_element456_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cycle_clause_in_factoring_element468_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cycle_clause_in_factoring_element468( FOLLOW_cycle_clause_in_factoring_element468_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_search_key_in_search_clause489_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_search_key_in_search_clause489( FOLLOW_search_key_in_search_clause489_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_depth_key_in_search_clause493_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_depth_key_in_search_clause493( FOLLOW_depth_key_in_search_clause493_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_breadth_key_in_search_clause497_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_breadth_key_in_search_clause497( FOLLOW_breadth_key_in_search_clause497_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_first_key_in_search_clause501_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_first_key_in_search_clause501( FOLLOW_first_key_in_search_clause501_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_search_clause503_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_search_clause503( FOLLOW_by_key_in_search_clause503_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_search_clause518_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000002000800400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_search_clause518( FOLLOW_column_name_in_search_clause518_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_asc_key_in_search_clause520_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000002000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_asc_key_in_search_clause520( FOLLOW_asc_key_in_search_clause520_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_desc_key_in_search_clause524_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_desc_key_in_search_clause524( FOLLOW_desc_key_in_search_clause524_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_search_clause529_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nulls_key_in_search_clause529( FOLLOW_nulls_key_in_search_clause529_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_first_key_in_search_clause531_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_first_key_in_search_clause531( FOLLOW_first_key_in_search_clause531_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_search_clause536_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nulls_key_in_search_clause536( FOLLOW_nulls_key_in_search_clause536_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_last_key_in_search_clause538_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_last_key_in_search_clause538( FOLLOW_last_key_in_search_clause538_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_search_clause556_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_search_clause556( FOLLOW_COMMA_in_search_clause556_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_search_clause558_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000002000800400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_search_clause558( FOLLOW_column_name_in_search_clause558_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_asc_key_in_search_clause560_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000002000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_asc_key_in_search_clause560( FOLLOW_asc_key_in_search_clause560_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_desc_key_in_search_clause564_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_desc_key_in_search_clause564( FOLLOW_desc_key_in_search_clause564_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_search_clause569_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nulls_key_in_search_clause569( FOLLOW_nulls_key_in_search_clause569_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_first_key_in_search_clause571_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_first_key_in_search_clause571( FOLLOW_first_key_in_search_clause571_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_search_clause576_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nulls_key_in_search_clause576( FOLLOW_nulls_key_in_search_clause576_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_last_key_in_search_clause578_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_last_key_in_search_clause578( FOLLOW_last_key_in_search_clause578_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_set_key_in_search_clause598_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_set_key_in_search_clause598( FOLLOW_set_key_in_search_clause598_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_search_clause600_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_search_clause600( FOLLOW_column_name_in_search_clause600_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cycle_key_in_cycle_clause620_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cycle_key_in_cycle_clause620( FOLLOW_cycle_key_in_cycle_clause620_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_cycle_clause622_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_cycle_clause622( FOLLOW_column_name_in_cycle_clause622_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_cycle_clause626_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_cycle_clause626( FOLLOW_COMMA_in_cycle_clause626_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_cycle_clause628_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_cycle_clause628( FOLLOW_column_name_in_cycle_clause628_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_set_key_in_cycle_clause632_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_set_key_in_cycle_clause632( FOLLOW_set_key_in_cycle_clause632_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_cycle_clause634_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_cycle_clause634( FOLLOW_column_name_in_cycle_clause634_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_to_key_in_cycle_clause636_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_to_key_in_cycle_clause636( FOLLOW_to_key_in_cycle_clause636_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_cycle_clause638_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000800000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_cycle_clause638( FOLLOW_expression_in_cycle_clause638_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_default_key_in_cycle_clause640_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_default_key_in_cycle_clause640( FOLLOW_default_key_in_cycle_clause640_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_cycle_clause642_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_cycle_clause642( FOLLOW_expression_in_cycle_clause642_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_basic_elements_in_subquery662_bits[]	= { ANTLR_UINT64_LIT(0x0080000000000002), ANTLR_UINT64_LIT(0x0040000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_basic_elements_in_subquery662( FOLLOW_subquery_basic_elements_in_subquery662_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_operation_part_in_subquery664_bits[]	= { ANTLR_UINT64_LIT(0x0080000000000002), ANTLR_UINT64_LIT(0x0040000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_operation_part_in_subquery664( FOLLOW_subquery_operation_part_in_subquery664_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_union_key_in_subquery_operation_part686_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_union_key_in_subquery_operation_part686( FOLLOW_union_key_in_subquery_operation_part686_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_subquery_operation_part688_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_subquery_operation_part688( FOLLOW_all_key_in_subquery_operation_part688_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_intersect_key_in_subquery_operation_part691_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_intersect_key_in_subquery_operation_part691( FOLLOW_intersect_key_in_subquery_operation_part691_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_minus_key_in_subquery_operation_part693_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_minus_key_in_subquery_operation_part693( FOLLOW_minus_key_in_subquery_operation_part693_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_basic_elements_in_subquery_operation_part696_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_basic_elements_in_subquery_operation_part696( FOLLOW_subquery_basic_elements_in_subquery_operation_part696_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_query_block_in_subquery_basic_elements716_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_query_block_in_subquery_basic_elements716( FOLLOW_query_block_in_subquery_basic_elements716_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_subquery_basic_elements727_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_subquery_basic_elements727( FOLLOW_LEFT_PAREN_in_subquery_basic_elements727_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_subquery_basic_elements729_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_subquery_basic_elements729( FOLLOW_subquery_in_subquery_basic_elements729_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_subquery_basic_elements731_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_subquery_basic_elements731( FOLLOW_RIGHT_PAREN_in_subquery_basic_elements731_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_query_block751_bits[]	= { ANTLR_UINT64_LIT(0x00000086504472A0), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000805004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_query_block751( FOLLOW_select_key_in_query_block751_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_distinct_key_in_query_block772_bits[]	= { ANTLR_UINT64_LIT(0x00000086504472A0), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_distinct_key_in_query_block772( FOLLOW_distinct_key_in_query_block772_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unique_key_in_query_block774_bits[]	= { ANTLR_UINT64_LIT(0x00000086504472A0), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unique_key_in_query_block774( FOLLOW_unique_key_in_query_block774_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_query_block776_bits[]	= { ANTLR_UINT64_LIT(0x00000086504472A0), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_query_block776( FOLLOW_all_key_in_query_block776_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_query_block790_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080800000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_ASTERISK_in_query_block790( FOLLOW_ASTERISK_in_query_block790_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_selected_element_in_query_block794_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0080800000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_selected_element_in_query_block794( FOLLOW_selected_element_in_query_block794_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_query_block797_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_query_block797( FOLLOW_COMMA_in_query_block797_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_selected_element_in_query_block799_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0080800000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_selected_element_in_query_block799( FOLLOW_selected_element_in_query_block799_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_into_clause_in_query_block812_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_into_clause_in_query_block812( FOLLOW_into_clause_in_query_block812_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_from_clause_in_query_block823_bits[]	= { ANTLR_UINT64_LIT(0x2000020000000002), ANTLR_UINT64_LIT(0x000C000020000000), ANTLR_UINT64_LIT(0x0000000000080000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_from_clause_in_query_block823( FOLLOW_from_clause_in_query_block823_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_where_clause_in_query_block834_bits[]	= { ANTLR_UINT64_LIT(0x2000020000000002), ANTLR_UINT64_LIT(0x000C000020000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_where_clause_in_query_block834( FOLLOW_where_clause_in_query_block834_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_hierarchical_query_clause_in_query_block846_bits[]	= { ANTLR_UINT64_LIT(0x0000020000000002), ANTLR_UINT64_LIT(0x000C000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_hierarchical_query_clause_in_query_block846( FOLLOW_hierarchical_query_clause_in_query_block846_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_by_clause_in_query_block858_bits[]	= { ANTLR_UINT64_LIT(0x0000020000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_by_clause_in_query_block858( FOLLOW_group_by_clause_in_query_block858_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_clause_in_query_block869_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_clause_in_query_block869( FOLLOW_model_clause_in_query_block869_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_list_elements_in_selected_element890_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_list_elements_in_selected_element890( FOLLOW_select_list_elements_in_selected_element890_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_selected_element892_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_alias_in_selected_element892( FOLLOW_column_alias_in_selected_element892_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_from_key_in_from_clause913_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_from_key_in_from_clause913( FOLLOW_from_key_in_from_clause913_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_ref_list_in_from_clause915_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_ref_list_in_from_clause915( FOLLOW_table_ref_list_in_from_clause915_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_select_list_elements944_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_select_list_elements944( FOLLOW_tableview_name_in_select_list_elements944_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_select_list_elements946_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_select_list_elements946( FOLLOW_PERIOD_in_select_list_elements946_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_select_list_elements948_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_ASTERISK_in_select_list_elements948( FOLLOW_ASTERISK_in_select_list_elements948_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_select_list_elements959_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_select_list_elements959( FOLLOW_expression_in_select_list_elements959_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_ref_in_table_ref_list979_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_ref_in_table_ref_list979( FOLLOW_table_ref_in_table_ref_list979_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_table_ref_list982_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_table_ref_list982( FOLLOW_COMMA_in_table_ref_list982_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_ref_in_table_ref_list984_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_ref_in_table_ref_list984( FOLLOW_table_ref_in_table_ref_list984_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_ref_aux_in_table_ref1010_bits[]	= { ANTLR_UINT64_LIT(0x00000C0000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_ref_aux_in_table_ref1010( FOLLOW_table_ref_aux_in_table_ref1010_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_join_clause_in_table_ref1012_bits[]	= { ANTLR_UINT64_LIT(0x00000C0000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_join_clause_in_table_ref1012( FOLLOW_join_clause_in_table_ref1012_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_clause_in_table_ref1016_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_clause_in_table_ref1016( FOLLOW_pivot_clause_in_table_ref1016_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unpivot_clause_in_table_ref1018_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unpivot_clause_in_table_ref1018( FOLLOW_unpivot_clause_in_table_ref1018_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_dml_table_expression_clause_in_table_ref_aux1058_bits[]	= { ANTLR_UINT64_LIT(0x00000C0410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_dml_table_expression_clause_in_table_ref_aux1058( FOLLOW_dml_table_expression_clause_in_table_ref_aux1058_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_clause_in_table_ref_aux1061_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_clause_in_table_ref_aux1061( FOLLOW_pivot_clause_in_table_ref_aux1061_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unpivot_clause_in_table_ref_aux1063_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unpivot_clause_in_table_ref_aux1063( FOLLOW_unpivot_clause_in_table_ref_aux1063_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_table_ref_aux1082_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_table_ref_aux1082( FOLLOW_LEFT_PAREN_in_table_ref_aux1082_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_ref_in_table_ref_aux1084_bits[]	= { ANTLR_UINT64_LIT(0x0080000000000000), ANTLR_UINT64_LIT(0x0040000000001000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_ref_in_table_ref_aux1084( FOLLOW_table_ref_in_table_ref_aux1084_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_operation_part_in_table_ref_aux1086_bits[]	= { ANTLR_UINT64_LIT(0x0080000000000000), ANTLR_UINT64_LIT(0x0040000000001000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_operation_part_in_table_ref_aux1086( FOLLOW_subquery_operation_part_in_table_ref_aux1086_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_table_ref_aux1089_bits[]	= { ANTLR_UINT64_LIT(0x00000C0410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_table_ref_aux1089( FOLLOW_RIGHT_PAREN_in_table_ref_aux1089_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_clause_in_table_ref_aux1092_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_clause_in_table_ref_aux1092( FOLLOW_pivot_clause_in_table_ref_aux1092_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unpivot_clause_in_table_ref_aux1094_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unpivot_clause_in_table_ref_aux1094( FOLLOW_unpivot_clause_in_table_ref_aux1094_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_only_key_in_table_ref_aux1115_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_only_key_in_table_ref_aux1115( FOLLOW_only_key_in_table_ref_aux1115_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_table_ref_aux1117_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_table_ref_aux1117( FOLLOW_LEFT_PAREN_in_table_ref_aux1117_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_dml_table_expression_clause_in_table_ref_aux1119_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_dml_table_expression_clause_in_table_ref_aux1119( FOLLOW_dml_table_expression_clause_in_table_ref_aux1119_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_table_ref_aux1121_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_table_ref_aux1121( FOLLOW_RIGHT_PAREN_in_table_ref_aux1121_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_dml_table_expression_clause_in_table_ref_aux1132_bits[]	= { ANTLR_UINT64_LIT(0x00000C0410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_dml_table_expression_clause_in_table_ref_aux1132( FOLLOW_dml_table_expression_clause_in_table_ref_aux1132_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_clause_in_table_ref_aux1135_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_clause_in_table_ref_aux1135( FOLLOW_pivot_clause_in_table_ref_aux1135_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unpivot_clause_in_table_ref_aux1137_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unpivot_clause_in_table_ref_aux1137( FOLLOW_unpivot_clause_in_table_ref_aux1137_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_flashback_query_clause_in_table_ref_aux1155_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_flashback_query_clause_in_table_ref_aux1155( FOLLOW_flashback_query_clause_in_table_ref_aux1155_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_alias_in_table_ref_aux1169_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_alias_in_table_ref_aux1169( FOLLOW_table_alias_in_table_ref_aux1169_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_query_partition_clause_in_join_clause1191_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_query_partition_clause_in_join_clause1191( FOLLOW_query_partition_clause_in_join_clause1191_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cross_key_in_join_clause1203_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cross_key_in_join_clause1203( FOLLOW_cross_key_in_join_clause1203_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_natural_key_in_join_clause1205_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_natural_key_in_join_clause1205( FOLLOW_natural_key_in_join_clause1205_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_inner_key_in_join_clause1210_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_inner_key_in_join_clause1210( FOLLOW_inner_key_in_join_clause1210_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_outer_join_type_in_join_clause1212_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_outer_join_type_in_join_clause1212( FOLLOW_outer_join_type_in_join_clause1212_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_join_key_in_join_clause1216_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_join_key_in_join_clause1216( FOLLOW_join_key_in_join_clause1216_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_ref_aux_in_join_clause1226_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000002), ANTLR_UINT64_LIT(0x2000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_ref_aux_in_join_clause1226( FOLLOW_table_ref_aux_in_join_clause1226_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_query_partition_clause_in_join_clause1236_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000002), ANTLR_UINT64_LIT(0x2000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_query_partition_clause_in_join_clause1236( FOLLOW_query_partition_clause_in_join_clause1236_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_join_on_part_in_join_clause1248_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000002), ANTLR_UINT64_LIT(0x2000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_join_on_part_in_join_clause1248( FOLLOW_join_on_part_in_join_clause1248_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_join_using_part_in_join_clause1259_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000002), ANTLR_UINT64_LIT(0x2000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_join_using_part_in_join_clause1259( FOLLOW_join_using_part_in_join_clause1259_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_on_key_in_join_on_part1286_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_on_key_in_join_on_part1286( FOLLOW_on_key_in_join_on_part1286_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_join_on_part1288_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_in_join_on_part1288( FOLLOW_condition_in_join_on_part1288_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_using_key_in_join_using_part1308_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_using_key_in_join_using_part1308( FOLLOW_using_key_in_join_using_part1308_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_join_using_part1310_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_join_using_part1310( FOLLOW_LEFT_PAREN_in_join_using_part1310_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_join_using_part1312_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_join_using_part1312( FOLLOW_column_name_in_join_using_part1312_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_join_using_part1315_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_join_using_part1315( FOLLOW_COMMA_in_join_using_part1315_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_join_using_part1317_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_join_using_part1317( FOLLOW_column_name_in_join_using_part1317_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_join_using_part1321_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_join_using_part1321( FOLLOW_RIGHT_PAREN_in_join_using_part1321_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_full_key_in_outer_join_type1351_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_full_key_in_outer_join_type1351( FOLLOW_full_key_in_outer_join_type1351_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_left_key_in_outer_join_type1362_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_left_key_in_outer_join_type1362( FOLLOW_left_key_in_outer_join_type1362_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_right_key_in_outer_join_type1373_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_right_key_in_outer_join_type1373( FOLLOW_right_key_in_outer_join_type1373_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_outer_key_in_outer_join_type1389_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_outer_key_in_outer_join_type1389( FOLLOW_outer_key_in_outer_join_type1389_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_partition_key_in_query_partition_clause1410_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_partition_key_in_query_partition_clause1410( FOLLOW_partition_key_in_query_partition_clause1410_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_query_partition_clause1412_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_query_partition_clause1412( FOLLOW_by_key_in_query_partition_clause1412_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_query_partition_clause1435_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_query_partition_clause1435( FOLLOW_LEFT_PAREN_in_query_partition_clause1435_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_query_partition_clause1437_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_query_partition_clause1437( FOLLOW_subquery_in_query_partition_clause1437_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_query_partition_clause1439_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_query_partition_clause1439( FOLLOW_RIGHT_PAREN_in_query_partition_clause1439_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_query_partition_clause1455_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_list_in_query_partition_clause1455( FOLLOW_expression_list_in_query_partition_clause1455_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_query_partition_clause1466_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_query_partition_clause1466( FOLLOW_expression_in_query_partition_clause1466_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_query_partition_clause1469_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_query_partition_clause1469( FOLLOW_COMMA_in_query_partition_clause1469_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_query_partition_clause1471_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_query_partition_clause1471( FOLLOW_expression_in_query_partition_clause1471_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_versions_key_in_flashback_query_clause1499_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000002000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_versions_key_in_flashback_query_clause1499( FOLLOW_versions_key_in_flashback_query_clause1499_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_between_key_in_flashback_query_clause1501_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_between_key_in_flashback_query_clause1501( FOLLOW_between_key_in_flashback_query_clause1501_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_scn_key_in_flashback_query_clause1504_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_scn_key_in_flashback_query_clause1504( FOLLOW_scn_key_in_flashback_query_clause1504_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_timestamp_key_in_flashback_query_clause1506_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_timestamp_key_in_flashback_query_clause1506( FOLLOW_timestamp_key_in_flashback_query_clause1506_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_flashback_query_clause1509_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_flashback_query_clause1509( FOLLOW_expression_in_flashback_query_clause1509_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_flashback_query_clause1520_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_as_key_in_flashback_query_clause1520( FOLLOW_as_key_in_flashback_query_clause1520_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_of_key_in_flashback_query_clause1522_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_of_key_in_flashback_query_clause1522( FOLLOW_of_key_in_flashback_query_clause1522_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_scn_key_in_flashback_query_clause1525_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_scn_key_in_flashback_query_clause1525( FOLLOW_scn_key_in_flashback_query_clause1525_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_timestamp_key_in_flashback_query_clause1527_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_timestamp_key_in_flashback_query_clause1527( FOLLOW_timestamp_key_in_flashback_query_clause1527_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_snapshot_key_in_flashback_query_clause1529_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_snapshot_key_in_flashback_query_clause1529( FOLLOW_snapshot_key_in_flashback_query_clause1529_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_flashback_query_clause1532_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_flashback_query_clause1532( FOLLOW_expression_in_flashback_query_clause1532_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_key_in_pivot_clause1552_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_key_in_pivot_clause1552( FOLLOW_pivot_key_in_pivot_clause1552_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_key_in_pivot_clause1554_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_key_in_pivot_clause1554( FOLLOW_xml_key_in_pivot_clause1554_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_pivot_clause1565_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_pivot_clause1565( FOLLOW_LEFT_PAREN_in_pivot_clause1565_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_element_in_pivot_clause1579_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_element_in_pivot_clause1579( FOLLOW_pivot_element_in_pivot_clause1579_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_pivot_clause1582_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_pivot_clause1582( FOLLOW_COMMA_in_pivot_clause1582_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_element_in_pivot_clause1584_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_element_in_pivot_clause1584( FOLLOW_pivot_element_in_pivot_clause1584_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_for_clause_in_pivot_clause1600_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0010000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_for_clause_in_pivot_clause1600( FOLLOW_pivot_for_clause_in_pivot_clause1600_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_in_clause_in_pivot_clause1614_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_in_clause_in_pivot_clause1614( FOLLOW_pivot_in_clause_in_pivot_clause1614_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_pivot_clause1626_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_pivot_clause1626( FOLLOW_RIGHT_PAREN_in_pivot_clause1626_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_aggregate_function_name_in_pivot_element1646_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_aggregate_function_name_in_pivot_element1646( FOLLOW_aggregate_function_name_in_pivot_element1646_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_pivot_element1648_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_pivot_element1648( FOLLOW_LEFT_PAREN_in_pivot_element1648_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_pivot_element1650_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_pivot_element1650( FOLLOW_expression_in_pivot_element1650_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_pivot_element1652_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_pivot_element1652( FOLLOW_RIGHT_PAREN_in_pivot_element1652_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_pivot_element1654_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_alias_in_pivot_element1654( FOLLOW_column_alias_in_pivot_element1654_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_key_in_pivot_for_clause1675_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_key_in_pivot_for_clause1675( FOLLOW_for_key_in_pivot_for_clause1675_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_pivot_for_clause1687_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_pivot_for_clause1687( FOLLOW_column_name_in_pivot_for_clause1687_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_pivot_for_clause1698_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_pivot_for_clause1698( FOLLOW_LEFT_PAREN_in_pivot_for_clause1698_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_pivot_for_clause1700_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_pivot_for_clause1700( FOLLOW_column_name_in_pivot_for_clause1700_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_pivot_for_clause1703_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_pivot_for_clause1703( FOLLOW_COMMA_in_pivot_for_clause1703_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_pivot_for_clause1705_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_pivot_for_clause1705( FOLLOW_column_name_in_pivot_for_clause1705_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_pivot_for_clause1709_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_pivot_for_clause1709( FOLLOW_RIGHT_PAREN_in_pivot_for_clause1709_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_pivot_in_clause1735_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_in_key_in_pivot_in_clause1735( FOLLOW_in_key_in_pivot_in_clause1735_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_pivot_in_clause1745_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801044) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_pivot_in_clause1745( FOLLOW_LEFT_PAREN_in_pivot_in_clause1745_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_pivot_in_clause1769_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_pivot_in_clause1769( FOLLOW_subquery_in_pivot_in_clause1769_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_any_key_in_pivot_in_clause1794_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_any_key_in_pivot_in_clause1794( FOLLOW_any_key_in_pivot_in_clause1794_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_pivot_in_clause1797_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_pivot_in_clause1797( FOLLOW_COMMA_in_pivot_in_clause1797_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_any_key_in_pivot_in_clause1799_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_any_key_in_pivot_in_clause1799( FOLLOW_any_key_in_pivot_in_clause1799_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_in_clause_element_in_pivot_in_clause1820_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_in_clause_element_in_pivot_in_clause1820( FOLLOW_pivot_in_clause_element_in_pivot_in_clause1820_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_pivot_in_clause1823_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_pivot_in_clause1823( FOLLOW_COMMA_in_pivot_in_clause1823_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_in_clause_element_in_pivot_in_clause1825_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_in_clause_element_in_pivot_in_clause1825( FOLLOW_pivot_in_clause_element_in_pivot_in_clause1825_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_pivot_in_clause1851_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_pivot_in_clause1851( FOLLOW_RIGHT_PAREN_in_pivot_in_clause1851_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_in_clause_elements_in_pivot_in_clause_element1871_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_in_clause_elements_in_pivot_in_clause_element1871( FOLLOW_pivot_in_clause_elements_in_pivot_in_clause_element1871_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_pivot_in_clause_element1873_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_alias_in_pivot_in_clause_element1873( FOLLOW_column_alias_in_pivot_in_clause_element1873_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_pivot_in_clause_elements1894_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_pivot_in_clause_elements1894( FOLLOW_expression_in_pivot_in_clause_elements1894_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_pivot_in_clause_elements1910_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_list_in_pivot_in_clause_elements1910( FOLLOW_expression_list_in_pivot_in_clause_elements1910_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unpivot_key_in_unpivot_clause1930_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unpivot_key_in_unpivot_clause1930( FOLLOW_unpivot_key_in_unpivot_clause1930_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_include_key_in_unpivot_clause1943_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_include_key_in_unpivot_clause1943( FOLLOW_include_key_in_unpivot_clause1943_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_exclude_key_in_unpivot_clause1945_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_exclude_key_in_unpivot_clause1945( FOLLOW_exclude_key_in_unpivot_clause1945_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_unpivot_clause1948_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nulls_key_in_unpivot_clause1948( FOLLOW_nulls_key_in_unpivot_clause1948_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_unpivot_clause1960_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_unpivot_clause1960( FOLLOW_LEFT_PAREN_in_unpivot_clause1960_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_unpivot_clause1979_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_unpivot_clause1979( FOLLOW_column_name_in_unpivot_clause1979_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_unpivot_clause1998_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_unpivot_clause1998( FOLLOW_LEFT_PAREN_in_unpivot_clause1998_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_unpivot_clause2000_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_unpivot_clause2000( FOLLOW_column_name_in_unpivot_clause2000_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_unpivot_clause2003_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_unpivot_clause2003( FOLLOW_COMMA_in_unpivot_clause2003_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_unpivot_clause2005_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_unpivot_clause2005( FOLLOW_column_name_in_unpivot_clause2005_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_unpivot_clause2009_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_unpivot_clause2009( FOLLOW_RIGHT_PAREN_in_unpivot_clause2009_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_pivot_for_clause_in_unpivot_clause2037_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0010000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_pivot_for_clause_in_unpivot_clause2037( FOLLOW_pivot_for_clause_in_unpivot_clause2037_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unpivot_in_clause_in_unpivot_clause2051_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unpivot_in_clause_in_unpivot_clause2051( FOLLOW_unpivot_in_clause_in_unpivot_clause2051_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_unpivot_clause2061_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_unpivot_clause2061( FOLLOW_RIGHT_PAREN_in_unpivot_clause2061_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_unpivot_in_clause2081_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_in_key_in_unpivot_in_clause2081( FOLLOW_in_key_in_unpivot_in_clause2081_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_unpivot_in_clause2091_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_unpivot_in_clause2091( FOLLOW_LEFT_PAREN_in_unpivot_in_clause2091_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unpivot_in_elements_in_unpivot_in_clause2105_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unpivot_in_elements_in_unpivot_in_clause2105( FOLLOW_unpivot_in_elements_in_unpivot_in_clause2105_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_unpivot_in_clause2108_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_unpivot_in_clause2108( FOLLOW_COMMA_in_unpivot_in_clause2108_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unpivot_in_elements_in_unpivot_in_clause2110_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unpivot_in_elements_in_unpivot_in_clause2110( FOLLOW_unpivot_in_elements_in_unpivot_in_clause2110_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_unpivot_in_clause2122_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_unpivot_in_clause2122( FOLLOW_RIGHT_PAREN_in_unpivot_in_clause2122_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_unpivot_in_elements2146_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000400000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_unpivot_in_elements2146( FOLLOW_column_name_in_unpivot_in_elements2146_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_unpivot_in_elements2161_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_unpivot_in_elements2161( FOLLOW_LEFT_PAREN_in_unpivot_in_elements2161_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_unpivot_in_elements2163_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_unpivot_in_elements2163( FOLLOW_column_name_in_unpivot_in_elements2163_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_unpivot_in_elements2166_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_unpivot_in_elements2166( FOLLOW_COMMA_in_unpivot_in_elements2166_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_unpivot_in_elements2168_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_unpivot_in_elements2168( FOLLOW_column_name_in_unpivot_in_elements2168_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_unpivot_in_elements2172_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000400000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_unpivot_in_elements2172( FOLLOW_RIGHT_PAREN_in_unpivot_in_elements2172_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_unpivot_in_elements2198_bits[]	= { ANTLR_UINT64_LIT(0x0000000440403020), ANTLR_UINT64_LIT(0x0800100A00000400), ANTLR_UINT64_LIT(0x0000000000801000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_as_key_in_unpivot_in_elements2198( FOLLOW_as_key_in_unpivot_in_elements2198_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_constant_in_unpivot_in_elements2214_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_constant_in_unpivot_in_elements2214( FOLLOW_constant_in_unpivot_in_elements2214_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_unpivot_in_elements2235_bits[]	= { ANTLR_UINT64_LIT(0x0000000400403020), ANTLR_UINT64_LIT(0x0800100A00000400), ANTLR_UINT64_LIT(0x0000000000801000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_unpivot_in_elements2235( FOLLOW_LEFT_PAREN_in_unpivot_in_elements2235_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_constant_in_unpivot_in_elements2237_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_constant_in_unpivot_in_elements2237( FOLLOW_constant_in_unpivot_in_elements2237_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_unpivot_in_elements2240_bits[]	= { ANTLR_UINT64_LIT(0x0000000400403020), ANTLR_UINT64_LIT(0x0800100A00000400), ANTLR_UINT64_LIT(0x0000000000801000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_unpivot_in_elements2240( FOLLOW_COMMA_in_unpivot_in_elements2240_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_constant_in_unpivot_in_elements2242_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_constant_in_unpivot_in_elements2242( FOLLOW_constant_in_unpivot_in_elements2242_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_unpivot_in_elements2246_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_unpivot_in_elements2246( FOLLOW_RIGHT_PAREN_in_unpivot_in_elements2246_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_connect_key_in_hierarchical_query_clause2288_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_connect_key_in_hierarchical_query_clause2288( FOLLOW_connect_key_in_hierarchical_query_clause2288_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_hierarchical_query_clause2290_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_hierarchical_query_clause2290( FOLLOW_by_key_in_hierarchical_query_clause2290_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nocycle_key_in_hierarchical_query_clause2292_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nocycle_key_in_hierarchical_query_clause2292( FOLLOW_nocycle_key_in_hierarchical_query_clause2292_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_hierarchical_query_clause2295_bits[]	= { ANTLR_UINT64_LIT(0x2000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_in_hierarchical_query_clause2295( FOLLOW_condition_in_hierarchical_query_clause2295_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_start_part_in_hierarchical_query_clause2297_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_start_part_in_hierarchical_query_clause2297( FOLLOW_start_part_in_hierarchical_query_clause2297_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_start_part_in_hierarchical_query_clause2309_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000020000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_start_part_in_hierarchical_query_clause2309( FOLLOW_start_part_in_hierarchical_query_clause2309_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_connect_key_in_hierarchical_query_clause2311_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_connect_key_in_hierarchical_query_clause2311( FOLLOW_connect_key_in_hierarchical_query_clause2311_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_hierarchical_query_clause2313_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_hierarchical_query_clause2313( FOLLOW_by_key_in_hierarchical_query_clause2313_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nocycle_key_in_hierarchical_query_clause2315_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nocycle_key_in_hierarchical_query_clause2315( FOLLOW_nocycle_key_in_hierarchical_query_clause2315_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_hierarchical_query_clause2318_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_in_hierarchical_query_clause2318( FOLLOW_condition_in_hierarchical_query_clause2318_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_start_key_in_start_part2338_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_start_key_in_start_part2338( FOLLOW_start_key_in_start_part2338_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_start_part2340_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_start_part2340( FOLLOW_with_key_in_start_part2340_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_start_part2342_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_in_start_part2342( FOLLOW_condition_in_start_part2342_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_key_in_group_by_clause2367_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_key_in_group_by_clause2367( FOLLOW_group_key_in_group_by_clause2367_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_group_by_clause2369_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_group_by_clause2369( FOLLOW_by_key_in_group_by_clause2369_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_by_elements_in_group_by_clause2371_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002), ANTLR_UINT64_LIT(0x0008000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_by_elements_in_group_by_clause2371( FOLLOW_group_by_elements_in_group_by_clause2371_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_group_by_clause2393_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_group_by_clause2393( FOLLOW_COMMA_in_group_by_clause2393_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_by_elements_in_group_by_clause2395_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002), ANTLR_UINT64_LIT(0x0008000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_by_elements_in_group_by_clause2395( FOLLOW_group_by_elements_in_group_by_clause2395_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_having_clause_in_group_by_clause2411_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_having_clause_in_group_by_clause2411( FOLLOW_having_clause_in_group_by_clause2411_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_having_clause_in_group_by_clause2428_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0004000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_having_clause_in_group_by_clause2428( FOLLOW_having_clause_in_group_by_clause2428_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_key_in_group_by_clause2443_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_key_in_group_by_clause2443( FOLLOW_group_key_in_group_by_clause2443_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_group_by_clause2445_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_group_by_clause2445( FOLLOW_by_key_in_group_by_clause2445_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_by_elements_in_group_by_clause2447_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_by_elements_in_group_by_clause2447( FOLLOW_group_by_elements_in_group_by_clause2447_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_group_by_clause2469_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_group_by_clause2469( FOLLOW_COMMA_in_group_by_clause2469_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_by_elements_in_group_by_clause2471_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_by_elements_in_group_by_clause2471( FOLLOW_group_by_elements_in_group_by_clause2471_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_grouping_sets_clause_in_group_by_elements2495_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_grouping_sets_clause_in_group_by_elements2495( FOLLOW_grouping_sets_clause_in_group_by_elements2495_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_rollup_cube_clause_in_group_by_elements2506_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_rollup_cube_clause_in_group_by_elements2506( FOLLOW_rollup_cube_clause_in_group_by_elements2506_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_group_by_elements2518_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_group_by_elements2518( FOLLOW_expression_in_group_by_elements2518_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_rollup_key_in_rollup_cube_clause2539_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_rollup_key_in_rollup_cube_clause2539( FOLLOW_rollup_key_in_rollup_cube_clause2539_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cube_key_in_rollup_cube_clause2541_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cube_key_in_rollup_cube_clause2541( FOLLOW_cube_key_in_rollup_cube_clause2541_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_rollup_cube_clause2544_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_rollup_cube_clause2544( FOLLOW_LEFT_PAREN_in_rollup_cube_clause2544_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_grouping_sets_elements_in_rollup_cube_clause2546_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_grouping_sets_elements_in_rollup_cube_clause2546( FOLLOW_grouping_sets_elements_in_rollup_cube_clause2546_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_rollup_cube_clause2549_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_rollup_cube_clause2549( FOLLOW_COMMA_in_rollup_cube_clause2549_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_grouping_sets_elements_in_rollup_cube_clause2551_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_grouping_sets_elements_in_rollup_cube_clause2551( FOLLOW_grouping_sets_elements_in_rollup_cube_clause2551_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_rollup_cube_clause2555_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_rollup_cube_clause2555( FOLLOW_RIGHT_PAREN_in_rollup_cube_clause2555_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_grouping_key_in_grouping_sets_clause2576_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_grouping_key_in_grouping_sets_clause2576( FOLLOW_grouping_key_in_grouping_sets_clause2576_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_sets_key_in_grouping_sets_clause2578_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_sets_key_in_grouping_sets_clause2578( FOLLOW_sets_key_in_grouping_sets_clause2578_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_grouping_sets_clause2589_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_grouping_sets_clause2589( FOLLOW_LEFT_PAREN_in_grouping_sets_clause2589_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_grouping_sets_elements_in_grouping_sets_clause2591_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_grouping_sets_elements_in_grouping_sets_clause2591( FOLLOW_grouping_sets_elements_in_grouping_sets_clause2591_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_grouping_sets_clause2594_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_grouping_sets_clause2594( FOLLOW_COMMA_in_grouping_sets_clause2594_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_grouping_sets_elements_in_grouping_sets_clause2596_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_grouping_sets_elements_in_grouping_sets_clause2596( FOLLOW_grouping_sets_elements_in_grouping_sets_clause2596_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_grouping_sets_clause2600_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_grouping_sets_clause2600( FOLLOW_RIGHT_PAREN_in_grouping_sets_clause2600_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_rollup_cube_clause_in_grouping_sets_elements2627_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_rollup_cube_clause_in_grouping_sets_elements2627( FOLLOW_rollup_cube_clause_in_grouping_sets_elements2627_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_grouping_sets_elements2643_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_list_in_grouping_sets_elements2643( FOLLOW_expression_list_in_grouping_sets_elements2643_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_grouping_sets_elements2654_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_grouping_sets_elements2654( FOLLOW_expression_in_grouping_sets_elements2654_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_having_key_in_having_clause2674_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_having_key_in_having_clause2674( FOLLOW_having_key_in_having_clause2674_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_having_clause2676_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_in_having_clause2676( FOLLOW_condition_in_having_clause2676_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_key_in_model_clause2696_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000004000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_key_in_model_clause2696( FOLLOW_model_key_in_model_clause2696_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cell_reference_options_in_model_clause2698_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000004000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cell_reference_options_in_model_clause2698( FOLLOW_cell_reference_options_in_model_clause2698_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_return_rows_clause_in_model_clause2701_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_return_rows_clause_in_model_clause2701( FOLLOW_return_rows_clause_in_model_clause2701_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_reference_model_in_model_clause2704_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_reference_model_in_model_clause2704( FOLLOW_reference_model_in_model_clause2704_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_main_model_in_model_clause2707_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_main_model_in_model_clause2707( FOLLOW_main_model_in_model_clause2707_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_ignore_key_in_cell_reference_options2728_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_ignore_key_in_cell_reference_options2728( FOLLOW_ignore_key_in_cell_reference_options2728_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_keep_key_in_cell_reference_options2730_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_keep_key_in_cell_reference_options2730( FOLLOW_keep_key_in_cell_reference_options2730_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nav_key_in_cell_reference_options2733_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nav_key_in_cell_reference_options2733( FOLLOW_nav_key_in_cell_reference_options2733_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unique_key_in_cell_reference_options2744_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unique_key_in_cell_reference_options2744( FOLLOW_unique_key_in_cell_reference_options2744_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_dimension_key_in_cell_reference_options2747_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_dimension_key_in_cell_reference_options2747( FOLLOW_dimension_key_in_cell_reference_options2747_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_single_key_in_cell_reference_options2749_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_single_key_in_cell_reference_options2749( FOLLOW_single_key_in_cell_reference_options2749_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_reference_key_in_cell_reference_options2751_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_reference_key_in_cell_reference_options2751( FOLLOW_reference_key_in_cell_reference_options2751_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_return_key_in_return_rows_clause2773_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000040400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_return_key_in_return_rows_clause2773( FOLLOW_return_key_in_return_rows_clause2773_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_updated_key_in_return_rows_clause2776_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_updated_key_in_return_rows_clause2776( FOLLOW_updated_key_in_return_rows_clause2776_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_return_rows_clause2778_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_return_rows_clause2778( FOLLOW_all_key_in_return_rows_clause2778_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_rows_key_in_return_rows_clause2781_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_rows_key_in_return_rows_clause2781( FOLLOW_rows_key_in_return_rows_clause2781_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_reference_key_in_reference_model2801_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_reference_key_in_reference_model2801( FOLLOW_reference_key_in_reference_model2801_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_reference_model_name_in_reference_model2803_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_reference_model_name_in_reference_model2803( FOLLOW_reference_model_name_in_reference_model2803_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_on_key_in_reference_model2805_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_on_key_in_reference_model2805( FOLLOW_on_key_in_reference_model2805_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_reference_model2820_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_reference_model2820( FOLLOW_LEFT_PAREN_in_reference_model2820_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_reference_model2822_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_reference_model2822( FOLLOW_subquery_in_reference_model2822_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_reference_model2824_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_reference_model2824( FOLLOW_RIGHT_PAREN_in_reference_model2824_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_column_clauses_in_reference_model2826_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000004000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_column_clauses_in_reference_model2826( FOLLOW_model_column_clauses_in_reference_model2826_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cell_reference_options_in_reference_model2841_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000004000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cell_reference_options_in_reference_model2841( FOLLOW_cell_reference_options_in_reference_model2841_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_main_key_in_main_model2863_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_main_key_in_main_model2863( FOLLOW_main_key_in_main_model2863_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_main_model_name_in_main_model2865_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_main_model_name_in_main_model2865( FOLLOW_main_model_name_in_main_model2865_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_column_clauses_in_main_model2869_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000004000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_column_clauses_in_main_model2869( FOLLOW_model_column_clauses_in_main_model2869_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cell_reference_options_in_main_model2871_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000004000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cell_reference_options_in_main_model2871( FOLLOW_cell_reference_options_in_main_model2871_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_rules_clause_in_main_model2874_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_rules_clause_in_main_model2874( FOLLOW_model_rules_clause_in_main_model2874_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_column_partition_part_in_model_column_clauses2894_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_column_partition_part_in_model_column_clauses2894( FOLLOW_model_column_partition_part_in_model_column_clauses2894_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_dimension_key_in_model_column_clauses2905_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_dimension_key_in_model_column_clauses2905( FOLLOW_dimension_key_in_model_column_clauses2905_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_model_column_clauses2907_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_model_column_clauses2907( FOLLOW_by_key_in_model_column_clauses2907_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_column_list_in_model_column_clauses2909_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_column_list_in_model_column_clauses2909( FOLLOW_model_column_list_in_model_column_clauses2909_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_measures_key_in_model_column_clauses2911_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_measures_key_in_model_column_clauses2911( FOLLOW_measures_key_in_model_column_clauses2911_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_column_list_in_model_column_clauses2913_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_column_list_in_model_column_clauses2913( FOLLOW_model_column_list_in_model_column_clauses2913_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_partition_key_in_model_column_partition_part2933_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_partition_key_in_model_column_partition_part2933( FOLLOW_partition_key_in_model_column_partition_part2933_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_model_column_partition_part2935_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_model_column_partition_part2935( FOLLOW_by_key_in_model_column_partition_part2935_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_column_list_in_model_column_partition_part2937_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_column_list_in_model_column_partition_part2937( FOLLOW_model_column_list_in_model_column_partition_part2937_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_model_column_list2957_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_model_column_list2957( FOLLOW_LEFT_PAREN_in_model_column_list2957_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_column_in_model_column_list2959_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_column_in_model_column_list2959( FOLLOW_model_column_in_model_column_list2959_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_model_column_list2962_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_model_column_list2962( FOLLOW_COMMA_in_model_column_list2962_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_column_in_model_column_list2964_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_column_in_model_column_list2964( FOLLOW_model_column_in_model_column_list2964_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_model_column_list2969_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_model_column_list2969( FOLLOW_RIGHT_PAREN_in_model_column_list2969_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_model_column2989_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_model_column2989( FOLLOW_expression_in_model_column2989_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_alias_in_model_column2991_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_alias_in_model_column2991( FOLLOW_table_alias_in_model_column2991_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_rules_part_in_model_rules_clause3012_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_rules_part_in_model_rules_clause3012( FOLLOW_model_rules_part_in_model_rules_clause3012_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_model_rules_clause3015_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000809004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_model_rules_clause3015( FOLLOW_LEFT_PAREN_in_model_rules_clause3015_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_rules_element_in_model_rules_clause3017_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_rules_element_in_model_rules_clause3017( FOLLOW_model_rules_element_in_model_rules_clause3017_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_model_rules_clause3020_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000809004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_model_rules_clause3020( FOLLOW_COMMA_in_model_rules_clause3020_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_rules_element_in_model_rules_clause3022_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_rules_element_in_model_rules_clause3022( FOLLOW_model_rules_element_in_model_rules_clause3022_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_model_rules_clause3026_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_model_rules_clause3026( FOLLOW_RIGHT_PAREN_in_model_rules_clause3026_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_rules_key_in_model_rules_part3046_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_rules_key_in_model_rules_part3046( FOLLOW_rules_key_in_model_rules_part3046_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_update_key_in_model_rules_part3049_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_update_key_in_model_rules_part3049( FOLLOW_update_key_in_model_rules_part3049_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_upsert_key_in_model_rules_part3051_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000040400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_upsert_key_in_model_rules_part3051( FOLLOW_upsert_key_in_model_rules_part3051_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_model_rules_part3053_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_model_rules_part3053( FOLLOW_all_key_in_model_rules_part3053_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_automatic_key_in_model_rules_part3060_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_automatic_key_in_model_rules_part3060( FOLLOW_automatic_key_in_model_rules_part3060_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_sequential_key_in_model_rules_part3062_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_sequential_key_in_model_rules_part3062( FOLLOW_sequential_key_in_model_rules_part3062_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_key_in_model_rules_part3065_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_key_in_model_rules_part3065( FOLLOW_order_key_in_model_rules_part3065_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_iterate_clause_in_model_rules_part3069_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_iterate_clause_in_model_rules_part3069( FOLLOW_model_iterate_clause_in_model_rules_part3069_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_update_key_in_model_rules_element3091_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_update_key_in_model_rules_element3091( FOLLOW_update_key_in_model_rules_element3091_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_upsert_key_in_model_rules_element3093_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_upsert_key_in_model_rules_element3093( FOLLOW_upsert_key_in_model_rules_element3093_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_model_rules_element3101_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_model_rules_element3101( FOLLOW_all_key_in_model_rules_element3101_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cell_assignment_in_model_rules_element3115_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cell_assignment_in_model_rules_element3115( FOLLOW_cell_assignment_in_model_rules_element3115_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_model_rules_element3133_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_by_clause_in_model_rules_element3133( FOLLOW_order_by_clause_in_model_rules_element3133_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_model_rules_element3148_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_model_rules_element3148( FOLLOW_EQUALS_OP_in_model_rules_element3148_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_model_rules_element3150_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_model_rules_element3150( FOLLOW_expression_in_model_rules_element3150_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_expression_in_cell_assignment3170_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_expression_in_cell_assignment3170( FOLLOW_model_expression_in_cell_assignment3170_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_iterate_key_in_model_iterate_clause3190_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_iterate_key_in_model_iterate_clause3190( FOLLOW_iterate_key_in_model_iterate_clause3190_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_model_iterate_clause3192_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_model_iterate_clause3192( FOLLOW_LEFT_PAREN_in_model_iterate_clause3192_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_model_iterate_clause3194_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_model_iterate_clause3194( FOLLOW_expression_in_model_iterate_clause3194_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_model_iterate_clause3196_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_model_iterate_clause3196( FOLLOW_RIGHT_PAREN_in_model_iterate_clause3196_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_until_part_in_model_iterate_clause3198_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_until_part_in_model_iterate_clause3198( FOLLOW_until_part_in_model_iterate_clause3198_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_until_key_in_until_part3219_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_until_key_in_until_part3219( FOLLOW_until_key_in_until_part3219_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_until_part3221_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_until_part3221( FOLLOW_LEFT_PAREN_in_until_part3221_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_until_part3223_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_in_until_part3223( FOLLOW_condition_in_until_part3223_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_until_part3225_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_until_part3225( FOLLOW_RIGHT_PAREN_in_until_part3225_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_key_in_order_by_clause3245_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_key_in_order_by_clause3245( FOLLOW_order_key_in_order_by_clause3245_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_siblings_key_in_order_by_clause3247_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_siblings_key_in_order_by_clause3247( FOLLOW_siblings_key_in_order_by_clause3247_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_order_by_clause3250_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_order_by_clause3250( FOLLOW_by_key_in_order_by_clause3250_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_by_elements_in_order_by_clause3252_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_by_elements_in_order_by_clause3252( FOLLOW_order_by_elements_in_order_by_clause3252_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_order_by_clause3255_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_order_by_clause3255( FOLLOW_COMMA_in_order_by_clause3255_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_by_elements_in_order_by_clause3257_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_by_elements_in_order_by_clause3257( FOLLOW_order_by_elements_in_order_by_clause3257_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_order_by_elements3279_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000002000800400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_order_by_elements3279( FOLLOW_expression_in_order_by_elements3279_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_asc_key_in_order_by_elements3282_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_asc_key_in_order_by_elements3282( FOLLOW_asc_key_in_order_by_elements3282_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_desc_key_in_order_by_elements3284_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_desc_key_in_order_by_elements3284( FOLLOW_desc_key_in_order_by_elements3284_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nulls_key_in_order_by_elements3289_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nulls_key_in_order_by_elements3289( FOLLOW_nulls_key_in_order_by_elements3289_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_first_key_in_order_by_elements3292_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_first_key_in_order_by_elements3292( FOLLOW_first_key_in_order_by_elements3292_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_last_key_in_order_by_elements3294_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_last_key_in_order_by_elements3294( FOLLOW_last_key_in_order_by_elements3294_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_key_in_for_update_clause3317_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_key_in_for_update_clause3317( FOLLOW_for_key_in_for_update_clause3317_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_update_key_in_for_update_clause3319_bits[]	= { ANTLR_UINT64_LIT(0x0400000000000002), ANTLR_UINT64_LIT(0x1000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_update_key_in_for_update_clause3319( FOLLOW_update_key_in_for_update_clause3319_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_update_of_part_in_for_update_clause3321_bits[]	= { ANTLR_UINT64_LIT(0x0400000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_update_of_part_in_for_update_clause3321( FOLLOW_for_update_of_part_in_for_update_clause3321_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_update_options_in_for_update_clause3324_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_update_options_in_for_update_clause3324( FOLLOW_for_update_options_in_for_update_clause3324_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_of_key_in_for_update_of_part3345_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_of_key_in_for_update_of_part3345( FOLLOW_of_key_in_for_update_of_part3345_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_for_update_of_part3347_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_for_update_of_part3347( FOLLOW_column_name_in_for_update_of_part3347_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_for_update_of_part3350_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_for_update_of_part3350( FOLLOW_COMMA_in_for_update_of_part3350_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_for_update_of_part3352_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_for_update_of_part3352( FOLLOW_column_name_in_for_update_of_part3352_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_skip_key_in_for_update_options3374_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_skip_key_in_for_update_options3374( FOLLOW_skip_key_in_for_update_options3374_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_locked_key_in_for_update_options3376_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_locked_key_in_for_update_options3376( FOLLOW_locked_key_in_for_update_options3376_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nowait_key_in_for_update_options3387_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nowait_key_in_for_update_options3387( FOLLOW_nowait_key_in_for_update_options3387_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_wait_key_in_for_update_options3398_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_wait_key_in_for_update_options3398( FOLLOW_wait_key_in_for_update_options3398_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_for_update_options3400_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_for_update_options3400( FOLLOW_expression_in_for_update_options3400_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_update_key_in_update_statement3422_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_update_key_in_update_statement3422( FOLLOW_update_key_in_update_statement3422_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_table_ref_in_update_statement3424_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_table_ref_in_update_statement3424( FOLLOW_general_table_ref_in_update_statement3424_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_update_set_clause_in_update_statement3434_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000080000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_update_set_clause_in_update_statement3434( FOLLOW_update_set_clause_in_update_statement3434_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_where_clause_in_update_statement3444_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_where_clause_in_update_statement3444( FOLLOW_where_clause_in_update_statement3444_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_static_returning_clause_in_update_statement3447_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_static_returning_clause_in_update_statement3447( FOLLOW_static_returning_clause_in_update_statement3447_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_error_logging_clause_in_update_statement3450_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_error_logging_clause_in_update_statement3450( FOLLOW_error_logging_clause_in_update_statement3450_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_set_key_in_update_set_clause3472_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_set_key_in_update_set_clause3472( FOLLOW_set_key_in_update_set_clause3472_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_based_update_set_clause_in_update_set_clause3483_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_based_update_set_clause_in_update_set_clause3483( FOLLOW_column_based_update_set_clause_in_update_set_clause3483_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_update_set_clause3486_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_update_set_clause3486( FOLLOW_COMMA_in_update_set_clause3486_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_based_update_set_clause_in_update_set_clause3488_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_based_update_set_clause_in_update_set_clause3488( FOLLOW_column_based_update_set_clause_in_update_set_clause3488_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_value_key_in_update_set_clause3501_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_value_key_in_update_set_clause3501( FOLLOW_value_key_in_update_set_clause3501_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_update_set_clause3503_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_update_set_clause3503( FOLLOW_LEFT_PAREN_in_update_set_clause3503_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_id_in_update_set_clause3505_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_id_in_update_set_clause3505( FOLLOW_id_in_update_set_clause3505_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_update_set_clause3507_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_update_set_clause3507( FOLLOW_RIGHT_PAREN_in_update_set_clause3507_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_update_set_clause3509_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_update_set_clause3509( FOLLOW_EQUALS_OP_in_update_set_clause3509_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_update_set_clause3511_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_update_set_clause3511( FOLLOW_expression_in_update_set_clause3511_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_column_based_update_set_clause3537_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_column_based_update_set_clause3537( FOLLOW_column_name_in_column_based_update_set_clause3537_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_column_based_update_set_clause3539_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_column_based_update_set_clause3539( FOLLOW_EQUALS_OP_in_column_based_update_set_clause3539_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_column_based_update_set_clause3541_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_column_based_update_set_clause3541( FOLLOW_expression_in_column_based_update_set_clause3541_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_column_based_update_set_clause3552_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_column_based_update_set_clause3552( FOLLOW_LEFT_PAREN_in_column_based_update_set_clause3552_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_column_based_update_set_clause3554_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_column_based_update_set_clause3554( FOLLOW_column_name_in_column_based_update_set_clause3554_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_column_based_update_set_clause3557_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_column_based_update_set_clause3557( FOLLOW_COMMA_in_column_based_update_set_clause3557_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_column_based_update_set_clause3559_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_column_based_update_set_clause3559( FOLLOW_column_name_in_column_based_update_set_clause3559_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_column_based_update_set_clause3563_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_column_based_update_set_clause3563( FOLLOW_RIGHT_PAREN_in_column_based_update_set_clause3563_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_column_based_update_set_clause3565_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_column_based_update_set_clause3565( FOLLOW_EQUALS_OP_in_column_based_update_set_clause3565_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_column_based_update_set_clause3567_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_column_based_update_set_clause3567( FOLLOW_subquery_in_column_based_update_set_clause3567_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_delete_key_in_delete_statement3589_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000800000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_delete_key_in_delete_statement3589( FOLLOW_delete_key_in_delete_statement3589_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_from_key_in_delete_statement3591_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_from_key_in_delete_statement3591( FOLLOW_from_key_in_delete_statement3591_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_table_ref_in_delete_statement3602_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000080000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_table_ref_in_delete_statement3602( FOLLOW_general_table_ref_in_delete_statement3602_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_where_clause_in_delete_statement3612_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_where_clause_in_delete_statement3612( FOLLOW_where_clause_in_delete_statement3612_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_static_returning_clause_in_delete_statement3615_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_static_returning_clause_in_delete_statement3615( FOLLOW_static_returning_clause_in_delete_statement3615_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_error_logging_clause_in_delete_statement3618_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_error_logging_clause_in_delete_statement3618( FOLLOW_error_logging_clause_in_delete_statement3618_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_insert_key_in_insert_statement3639_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000040400), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_insert_key_in_insert_statement3639( FOLLOW_insert_key_in_insert_statement3639_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_single_table_insert_in_insert_statement3650_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_single_table_insert_in_insert_statement3650( FOLLOW_single_table_insert_in_insert_statement3650_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multi_table_insert_in_insert_statement3661_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multi_table_insert_in_insert_statement3661( FOLLOW_multi_table_insert_in_insert_statement3661_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_insert_into_clause_in_single_table_insert3689_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000110040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_insert_into_clause_in_single_table_insert3689( FOLLOW_insert_into_clause_in_single_table_insert3689_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_values_clause_in_single_table_insert3700_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_values_clause_in_single_table_insert3700( FOLLOW_values_clause_in_single_table_insert3700_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_static_returning_clause_in_single_table_insert3702_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_static_returning_clause_in_single_table_insert3702( FOLLOW_static_returning_clause_in_single_table_insert3702_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_single_table_insert3714_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_statement_in_single_table_insert3714( FOLLOW_select_statement_in_single_table_insert3714_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_error_logging_clause_in_single_table_insert3730_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_error_logging_clause_in_single_table_insert3730( FOLLOW_error_logging_clause_in_single_table_insert3730_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_multi_table_insert3761_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_multi_table_insert3761( FOLLOW_all_key_in_multi_table_insert3761_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multi_table_element_in_multi_table_insert3763_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0080000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multi_table_element_in_multi_table_insert3763( FOLLOW_multi_table_element_in_multi_table_insert3763_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_conditional_insert_clause_in_multi_table_insert3775_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_conditional_insert_clause_in_multi_table_insert3775( FOLLOW_conditional_insert_clause_in_multi_table_insert3775_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_multi_table_insert3791_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_statement_in_multi_table_insert3791( FOLLOW_select_statement_in_multi_table_insert3791_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_insert_into_clause_in_multi_table_element3811_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000010000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_insert_into_clause_in_multi_table_element3811( FOLLOW_insert_into_clause_in_multi_table_element3811_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_values_clause_in_multi_table_element3813_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_values_clause_in_multi_table_element3813( FOLLOW_values_clause_in_multi_table_element3813_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_error_logging_clause_in_multi_table_element3816_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_error_logging_clause_in_multi_table_element3816( FOLLOW_error_logging_clause_in_multi_table_element3816_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_conditional_insert_clause3838_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_conditional_insert_clause3838( FOLLOW_all_key_in_conditional_insert_clause3838_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_first_key_in_conditional_insert_clause3840_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_first_key_in_conditional_insert_clause3840( FOLLOW_first_key_in_conditional_insert_clause3840_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_conditional_insert_when_part_in_conditional_insert_clause3852_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000010000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_conditional_insert_when_part_in_conditional_insert_clause3852( FOLLOW_conditional_insert_when_part_in_conditional_insert_clause3852_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_conditional_insert_else_part_in_conditional_insert_clause3855_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_conditional_insert_else_part_in_conditional_insert_clause3855( FOLLOW_conditional_insert_else_part_in_conditional_insert_clause3855_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_conditional_insert_when_part3876_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_when_key_in_conditional_insert_when_part3876( FOLLOW_when_key_in_conditional_insert_when_part3876_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_conditional_insert_when_part3878_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_in_conditional_insert_when_part3878( FOLLOW_condition_in_conditional_insert_when_part3878_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_then_key_in_conditional_insert_when_part3880_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_then_key_in_conditional_insert_when_part3880( FOLLOW_then_key_in_conditional_insert_when_part3880_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multi_table_element_in_conditional_insert_when_part3882_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0080000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multi_table_element_in_conditional_insert_when_part3882( FOLLOW_multi_table_element_in_conditional_insert_when_part3882_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_else_key_in_conditional_insert_else_part3903_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_else_key_in_conditional_insert_else_part3903( FOLLOW_else_key_in_conditional_insert_else_part3903_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multi_table_element_in_conditional_insert_else_part3905_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0080000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multi_table_element_in_conditional_insert_else_part3905( FOLLOW_multi_table_element_in_conditional_insert_else_part3905_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_into_key_in_insert_into_clause3926_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_into_key_in_insert_into_clause3926( FOLLOW_into_key_in_insert_into_clause3926_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_table_ref_in_insert_into_clause3928_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_table_ref_in_insert_into_clause3928( FOLLOW_general_table_ref_in_insert_into_clause3928_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_insert_into_clause3940_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_insert_into_clause3940( FOLLOW_LEFT_PAREN_in_insert_into_clause3940_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_insert_into_clause3942_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_insert_into_clause3942( FOLLOW_column_name_in_insert_into_clause3942_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_insert_into_clause3945_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_insert_into_clause3945( FOLLOW_COMMA_in_insert_into_clause3945_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_insert_into_clause3947_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_insert_into_clause3947( FOLLOW_column_name_in_insert_into_clause3947_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_insert_into_clause3951_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_insert_into_clause3951( FOLLOW_RIGHT_PAREN_in_insert_into_clause3951_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_values_key_in_values_clause3973_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_values_key_in_values_clause3973( FOLLOW_values_key_in_values_clause3973_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_values_clause3975_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_list_in_values_clause3975( FOLLOW_expression_list_in_values_clause3975_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_merge_key_in_merge_statement3996_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0080000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_merge_key_in_merge_statement3996( FOLLOW_merge_key_in_merge_statement3996_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_into_key_in_merge_statement3998_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_into_key_in_merge_statement3998( FOLLOW_into_key_in_merge_statement3998_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_merge_statement4000_bits[]	= { ANTLR_UINT64_LIT(0x0000100410043000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_merge_statement4000( FOLLOW_tableview_name_in_merge_statement4000_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_alias_in_merge_statement4002_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_alias_in_merge_statement4002( FOLLOW_table_alias_in_merge_statement4002_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_using_key_in_merge_statement4013_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_using_key_in_merge_statement4013( FOLLOW_using_key_in_merge_statement4013_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_selected_tableview_in_merge_statement4015_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_selected_tableview_in_merge_statement4015( FOLLOW_selected_tableview_in_merge_statement4015_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_on_key_in_merge_statement4017_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_on_key_in_merge_statement4017( FOLLOW_on_key_in_merge_statement4017_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_merge_statement4019_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_merge_statement4019( FOLLOW_LEFT_PAREN_in_merge_statement4019_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_in_merge_statement4021_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_in_merge_statement4021( FOLLOW_condition_in_merge_statement4021_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_merge_statement4023_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_merge_statement4023( FOLLOW_RIGHT_PAREN_in_merge_statement4023_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_merge_update_clause_in_merge_statement4055_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_merge_update_clause_in_merge_statement4055( FOLLOW_merge_update_clause_in_merge_statement4055_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_merge_insert_clause_in_merge_statement4057_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_merge_insert_clause_in_merge_statement4057( FOLLOW_merge_insert_clause_in_merge_statement4057_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_merge_insert_clause_in_merge_statement4092_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_merge_insert_clause_in_merge_statement4092( FOLLOW_merge_insert_clause_in_merge_statement4092_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_merge_update_clause_in_merge_statement4094_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_merge_update_clause_in_merge_statement4094( FOLLOW_merge_update_clause_in_merge_statement4094_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_error_logging_clause_in_merge_statement4116_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_error_logging_clause_in_merge_statement4116( FOLLOW_error_logging_clause_in_merge_statement4116_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_merge_update_clause4139_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_when_key_in_merge_update_clause4139( FOLLOW_when_key_in_merge_update_clause4139_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_matched_key_in_merge_update_clause4141_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_matched_key_in_merge_update_clause4141( FOLLOW_matched_key_in_merge_update_clause4141_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_then_key_in_merge_update_clause4143_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_then_key_in_merge_update_clause4143( FOLLOW_then_key_in_merge_update_clause4143_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_update_key_in_merge_update_clause4145_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_update_key_in_merge_update_clause4145( FOLLOW_update_key_in_merge_update_clause4145_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_set_key_in_merge_update_clause4147_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_set_key_in_merge_update_clause4147( FOLLOW_set_key_in_merge_update_clause4147_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_merge_element_in_merge_update_clause4158_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002), ANTLR_UINT64_LIT(0x0000001000000000), ANTLR_UINT64_LIT(0x0000000000080000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_merge_element_in_merge_update_clause4158( FOLLOW_merge_element_in_merge_update_clause4158_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_merge_update_clause4161_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_merge_update_clause4161( FOLLOW_COMMA_in_merge_update_clause4161_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_merge_element_in_merge_update_clause4163_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002), ANTLR_UINT64_LIT(0x0000001000000000), ANTLR_UINT64_LIT(0x0000000000080000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_merge_element_in_merge_update_clause4163( FOLLOW_merge_element_in_merge_update_clause4163_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_where_clause_in_merge_update_clause4175_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000001000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_where_clause_in_merge_update_clause4175( FOLLOW_where_clause_in_merge_update_clause4175_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_merge_update_delete_part_in_merge_update_clause4178_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_merge_update_delete_part_in_merge_update_clause4178( FOLLOW_merge_update_delete_part_in_merge_update_clause4178_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_merge_element4199_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_merge_element4199( FOLLOW_column_name_in_merge_element4199_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_merge_element4201_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_merge_element4201( FOLLOW_EQUALS_OP_in_merge_element4201_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_merge_element4203_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_merge_element4203( FOLLOW_expression_in_merge_element4203_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_delete_key_in_merge_update_delete_part4223_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000080000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_delete_key_in_merge_update_delete_part4223( FOLLOW_delete_key_in_merge_update_delete_part4223_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_where_clause_in_merge_update_delete_part4225_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_where_clause_in_merge_update_delete_part4225( FOLLOW_where_clause_in_merge_update_delete_part4225_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_merge_insert_clause4245_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0400000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_when_key_in_merge_insert_clause4245( FOLLOW_when_key_in_merge_insert_clause4245_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_not_key_in_merge_insert_clause4247_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_not_key_in_merge_insert_clause4247( FOLLOW_not_key_in_merge_insert_clause4247_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_matched_key_in_merge_insert_clause4249_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_matched_key_in_merge_insert_clause4249( FOLLOW_matched_key_in_merge_insert_clause4249_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_then_key_in_merge_insert_clause4251_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0020000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_then_key_in_merge_insert_clause4251( FOLLOW_then_key_in_merge_insert_clause4251_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_insert_key_in_merge_insert_clause4253_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000010000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_insert_key_in_merge_insert_clause4253( FOLLOW_insert_key_in_merge_insert_clause4253_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_merge_insert_clause4265_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_merge_insert_clause4265( FOLLOW_LEFT_PAREN_in_merge_insert_clause4265_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_merge_insert_clause4267_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_merge_insert_clause4267( FOLLOW_column_name_in_merge_insert_clause4267_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_merge_insert_clause4270_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_merge_insert_clause4270( FOLLOW_COMMA_in_merge_insert_clause4270_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_merge_insert_clause4272_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_merge_insert_clause4272( FOLLOW_column_name_in_merge_insert_clause4272_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_merge_insert_clause4276_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000010000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_merge_insert_clause4276( FOLLOW_RIGHT_PAREN_in_merge_insert_clause4276_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_values_key_in_merge_insert_clause4288_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_values_key_in_merge_insert_clause4288( FOLLOW_values_key_in_merge_insert_clause4288_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_merge_insert_clause4290_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000080000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_list_in_merge_insert_clause4290( FOLLOW_expression_list_in_merge_insert_clause4290_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_where_clause_in_merge_insert_clause4292_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_where_clause_in_merge_insert_clause4292( FOLLOW_where_clause_in_merge_insert_clause4292_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_selected_tableview4315_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_selected_tableview4315( FOLLOW_tableview_name_in_selected_tableview4315_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_selected_tableview4319_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_selected_tableview4319( FOLLOW_LEFT_PAREN_in_selected_tableview4319_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_selected_tableview4321_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_statement_in_selected_tableview4321( FOLLOW_select_statement_in_selected_tableview4321_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_selected_tableview4323_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_selected_tableview4323( FOLLOW_RIGHT_PAREN_in_selected_tableview4323_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_alias_in_selected_tableview4327_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_alias_in_selected_tableview4327( FOLLOW_table_alias_in_selected_tableview4327_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_lock_key_in_lock_table_statement4350_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000100) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_lock_key_in_lock_table_statement4350( FOLLOW_lock_key_in_lock_table_statement4350_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_key_in_lock_table_statement4352_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_key_in_lock_table_statement4352( FOLLOW_table_key_in_lock_table_statement4352_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_lock_table_element_in_lock_table_statement4363_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0010000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_lock_table_element_in_lock_table_statement4363( FOLLOW_lock_table_element_in_lock_table_statement4363_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_lock_table_statement4366_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_lock_table_statement4366( FOLLOW_COMMA_in_lock_table_statement4366_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_lock_table_element_in_lock_table_statement4368_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0010000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_lock_table_element_in_lock_table_statement4368( FOLLOW_lock_table_element_in_lock_table_statement4368_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_lock_table_statement4381_bits[]	= { ANTLR_UINT64_LIT(0x1002000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_in_key_in_lock_table_statement4381( FOLLOW_in_key_in_lock_table_statement4381_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_lock_mode_in_lock_table_statement4383_bits[]	= { ANTLR_UINT64_LIT(0x0100000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_lock_mode_in_lock_table_statement4383( FOLLOW_lock_mode_in_lock_table_statement4383_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_mode_key_in_lock_table_statement4385_bits[]	= { ANTLR_UINT64_LIT(0x0400000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_mode_key_in_lock_table_statement4385( FOLLOW_mode_key_in_lock_table_statement4385_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_wait_nowait_part_in_lock_table_statement4387_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_wait_nowait_part_in_lock_table_statement4387( FOLLOW_wait_nowait_part_in_lock_table_statement4387_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_wait_key_in_wait_nowait_part4408_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_wait_key_in_wait_nowait_part4408( FOLLOW_wait_key_in_wait_nowait_part4408_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_wait_nowait_part4410_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_wait_nowait_part4410( FOLLOW_expression_in_wait_nowait_part4410_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nowait_key_in_wait_nowait_part4421_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nowait_key_in_wait_nowait_part4421( FOLLOW_nowait_key_in_wait_nowait_part4421_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_lock_table_element4443_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_lock_table_element4443( FOLLOW_tableview_name_in_lock_table_element4443_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_partition_extension_clause_in_lock_table_element4445_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_partition_extension_clause_in_lock_table_element4445( FOLLOW_partition_extension_clause_in_lock_table_element4445_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_row_key_in_lock_mode4466_bits[]	= { ANTLR_UINT64_LIT(0x1000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_row_key_in_lock_mode4466( FOLLOW_row_key_in_lock_mode4466_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_share_key_in_lock_mode4468_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_share_key_in_lock_mode4468( FOLLOW_share_key_in_lock_mode4468_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_row_key_in_lock_mode4479_bits[]	= { ANTLR_UINT64_LIT(0x0002000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_row_key_in_lock_mode4479( FOLLOW_row_key_in_lock_mode4479_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_exclusive_key_in_lock_mode4481_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_exclusive_key_in_lock_mode4481( FOLLOW_exclusive_key_in_lock_mode4481_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_share_key_in_lock_mode4492_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_share_key_in_lock_mode4492( FOLLOW_share_key_in_lock_mode4492_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_update_key_in_lock_mode4494_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_update_key_in_lock_mode4494( FOLLOW_update_key_in_lock_mode4494_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_share_key_in_lock_mode4506_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_share_key_in_lock_mode4506( FOLLOW_share_key_in_lock_mode4506_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_row_key_in_lock_mode4508_bits[]	= { ANTLR_UINT64_LIT(0x0002000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_row_key_in_lock_mode4508( FOLLOW_row_key_in_lock_mode4508_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_exclusive_key_in_lock_mode4510_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_exclusive_key_in_lock_mode4510( FOLLOW_exclusive_key_in_lock_mode4510_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_exclusive_key_in_lock_mode4521_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_exclusive_key_in_lock_mode4521( FOLLOW_exclusive_key_in_lock_mode4521_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_dml_table_expression_clause_in_general_table_ref4549_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_dml_table_expression_clause_in_general_table_ref4549( FOLLOW_dml_table_expression_clause_in_general_table_ref4549_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_only_key_in_general_table_ref4564_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_only_key_in_general_table_ref4564( FOLLOW_only_key_in_general_table_ref4564_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_general_table_ref4566_bits[]	= { ANTLR_UINT64_LIT(0x0000000050040000), ANTLR_UINT64_LIT(0x0000000000000400), ANTLR_UINT64_LIT(0x0000000000000300) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_general_table_ref4566( FOLLOW_LEFT_PAREN_in_general_table_ref4566_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_dml_table_expression_clause_in_general_table_ref4568_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_dml_table_expression_clause_in_general_table_ref4568( FOLLOW_dml_table_expression_clause_in_general_table_ref4568_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_general_table_ref4570_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_general_table_ref4570( FOLLOW_RIGHT_PAREN_in_general_table_ref4570_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_alias_in_general_table_ref4585_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_alias_in_general_table_ref4585( FOLLOW_table_alias_in_general_table_ref4585_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_returning_key_in_static_returning_clause4607_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_returning_key_in_static_returning_clause4607( FOLLOW_returning_key_in_static_returning_clause4607_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_return_key_in_static_returning_clause4609_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_return_key_in_static_returning_clause4609( FOLLOW_return_key_in_static_returning_clause4609_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_static_returning_clause4612_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0080000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_static_returning_clause4612( FOLLOW_expression_in_static_returning_clause4612_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_static_returning_clause4615_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_static_returning_clause4615( FOLLOW_COMMA_in_static_returning_clause4615_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_static_returning_clause4617_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0080000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_static_returning_clause4617( FOLLOW_expression_in_static_returning_clause4617_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_into_clause_in_static_returning_clause4630_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_into_clause_in_static_returning_clause4630( FOLLOW_into_clause_in_static_returning_clause4630_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_log_key_in_error_logging_clause4650_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_log_key_in_error_logging_clause4650( FOLLOW_log_key_in_error_logging_clause4650_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_errors_key_in_error_logging_clause4652_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447222), ANTLR_UINT64_LIT(0x0C80184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_errors_key_in_error_logging_clause4652( FOLLOW_errors_key_in_error_logging_clause4652_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_error_logging_into_part_in_error_logging_clause4663_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447222), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_error_logging_into_part_in_error_logging_clause4663( FOLLOW_error_logging_into_part_in_error_logging_clause4663_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_error_logging_clause4680_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_error_logging_clause4680( FOLLOW_expression_wrapper_in_error_logging_clause4680_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_error_logging_reject_part_in_error_logging_clause4692_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_error_logging_reject_part_in_error_logging_clause4692( FOLLOW_error_logging_reject_part_in_error_logging_clause4692_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_into_key_in_error_logging_into_part4713_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_into_key_in_error_logging_into_part4713( FOLLOW_into_key_in_error_logging_into_part4713_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_error_logging_into_part4715_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_error_logging_into_part4715( FOLLOW_tableview_name_in_error_logging_into_part4715_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_reject_key_in_error_logging_reject_part4735_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_reject_key_in_error_logging_reject_part4735( FOLLOW_reject_key_in_error_logging_reject_part4735_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_limit_key_in_error_logging_reject_part4737_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_limit_key_in_error_logging_reject_part4737( FOLLOW_limit_key_in_error_logging_reject_part4737_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unlimited_key_in_error_logging_reject_part4744_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unlimited_key_in_error_logging_reject_part4744( FOLLOW_unlimited_key_in_error_logging_reject_part4744_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_error_logging_reject_part4746_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_error_logging_reject_part4746( FOLLOW_expression_wrapper_in_error_logging_reject_part4746_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_collection_expression_in_dml_table_expression_clause4767_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_collection_expression_in_dml_table_expression_clause4767( FOLLOW_table_collection_expression_in_dml_table_expression_clause4767_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_dml_table_expression_clause4778_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_dml_table_expression_clause4778( FOLLOW_LEFT_PAREN_in_dml_table_expression_clause4778_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_statement_in_dml_table_expression_clause4780_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_statement_in_dml_table_expression_clause4780( FOLLOW_select_statement_in_dml_table_expression_clause4780_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_restriction_clause_in_dml_table_expression_clause4782_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_restriction_clause_in_dml_table_expression_clause4782( FOLLOW_subquery_restriction_clause_in_dml_table_expression_clause4782_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_dml_table_expression_clause4785_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_dml_table_expression_clause4785( FOLLOW_RIGHT_PAREN_in_dml_table_expression_clause4785_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_dml_table_expression_clause4796_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_dml_table_expression_clause4796( FOLLOW_tableview_name_in_dml_table_expression_clause4796_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_sample_clause_in_dml_table_expression_clause4798_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_sample_clause_in_dml_table_expression_clause4798( FOLLOW_sample_clause_in_dml_table_expression_clause4798_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_key_in_table_collection_expression4821_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_key_in_table_collection_expression4821( FOLLOW_table_key_in_table_collection_expression4821_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_the_key_in_table_collection_expression4825_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_the_key_in_table_collection_expression4825( FOLLOW_the_key_in_table_collection_expression4825_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_table_collection_expression4853_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_table_collection_expression4853( FOLLOW_LEFT_PAREN_in_table_collection_expression4853_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_table_collection_expression4855_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_table_collection_expression4855( FOLLOW_subquery_in_table_collection_expression4855_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_table_collection_expression4857_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_table_collection_expression4857( FOLLOW_RIGHT_PAREN_in_table_collection_expression4857_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_table_collection_expression4870_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_table_collection_expression4870( FOLLOW_LEFT_PAREN_in_table_collection_expression4870_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_table_collection_expression4872_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_table_collection_expression4872( FOLLOW_expression_in_table_collection_expression4872_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_table_collection_expression4874_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_table_collection_expression4874( FOLLOW_RIGHT_PAREN_in_table_collection_expression4874_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_subquery_restriction_clause4906_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000010000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_subquery_restriction_clause4906( FOLLOW_with_key_in_subquery_restriction_clause4906_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_read_key_in_subquery_restriction_clause4917_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_read_key_in_subquery_restriction_clause4917( FOLLOW_read_key_in_subquery_restriction_clause4917_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_only_key_in_subquery_restriction_clause4919_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_only_key_in_subquery_restriction_clause4919( FOLLOW_only_key_in_subquery_restriction_clause4919_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_check_key_in_subquery_restriction_clause4930_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x4000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_check_key_in_subquery_restriction_clause4930( FOLLOW_check_key_in_subquery_restriction_clause4930_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_option_key_in_subquery_restriction_clause4932_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_option_key_in_subquery_restriction_clause4932( FOLLOW_option_key_in_subquery_restriction_clause4932_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_constraint_key_in_subquery_restriction_clause4935_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_constraint_key_in_subquery_restriction_clause4935( FOLLOW_constraint_key_in_subquery_restriction_clause4935_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_constraint_name_in_subquery_restriction_clause4937_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_constraint_name_in_subquery_restriction_clause4937( FOLLOW_constraint_name_in_subquery_restriction_clause4937_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_sample_key_in_sample_clause4965_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_sample_key_in_sample_clause4965( FOLLOW_sample_key_in_sample_clause4965_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_block_key_in_sample_clause4967_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_block_key_in_sample_clause4967( FOLLOW_block_key_in_sample_clause4967_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_sample_clause4979_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_sample_clause4979( FOLLOW_LEFT_PAREN_in_sample_clause4979_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_sample_clause4981_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_sample_clause4981( FOLLOW_expression_in_sample_clause4981_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_sample_clause4984_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_sample_clause4984( FOLLOW_COMMA_in_sample_clause4984_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_sample_clause4986_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_sample_clause4986( FOLLOW_expression_in_sample_clause4986_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_sample_clause4990_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_sample_clause4990( FOLLOW_RIGHT_PAREN_in_sample_clause4990_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_seed_part_in_sample_clause5000_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_seed_part_in_sample_clause5000( FOLLOW_seed_part_in_sample_clause5000_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_seed_key_in_seed_part5021_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_seed_key_in_seed_part5021( FOLLOW_seed_key_in_seed_part5021_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_seed_part5023_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_seed_part5023( FOLLOW_LEFT_PAREN_in_seed_part5023_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_seed_part5025_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_seed_part5025( FOLLOW_expression_in_seed_part5025_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_seed_part5027_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_seed_part5027( FOLLOW_RIGHT_PAREN_in_seed_part5027_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_key_in_cursor_expression5050_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cursor_key_in_cursor_expression5050( FOLLOW_cursor_key_in_cursor_expression5050_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_cursor_expression5052_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_cursor_expression5052( FOLLOW_LEFT_PAREN_in_cursor_expression5052_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_cursor_expression5054_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_cursor_expression5054( FOLLOW_subquery_in_cursor_expression5054_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_cursor_expression5056_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_cursor_expression5056( FOLLOW_RIGHT_PAREN_in_cursor_expression5056_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_expression_list5076_bits[]	= { ANTLR_UINT64_LIT(0x000000865044F220), ANTLR_UINT64_LIT(0x0C00184B08241401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_expression_list5076( FOLLOW_LEFT_PAREN_in_expression_list5076_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_expression_list5078_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_expression_list5078( FOLLOW_expression_in_expression_list5078_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_expression_list5082_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_expression_list5082( FOLLOW_COMMA_in_expression_list5082_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_expression_list5084_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_expression_list5084( FOLLOW_expression_in_expression_list5084_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_expression_list5088_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_expression_list5088( FOLLOW_RIGHT_PAREN_in_expression_list5088_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_condition5109_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_condition5109( FOLLOW_expression_in_condition5109_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_condition_wrapper5129_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_condition_wrapper5129( FOLLOW_expression_in_condition_wrapper5129_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_expression_in_expression5163_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cursor_expression_in_expression5163( FOLLOW_cursor_expression_in_expression5163_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_logical_and_expression_in_expression5174_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x8000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_logical_and_expression_in_expression5174( FOLLOW_logical_and_expression_in_expression5174_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_or_key_in_expression5178_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_or_key_in_expression5178( FOLLOW_or_key_in_expression5178_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_logical_and_expression_in_expression5180_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x8000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_logical_and_expression_in_expression5180( FOLLOW_logical_and_expression_in_expression5180_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_expression_wrapper5203_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_expression_wrapper5203( FOLLOW_expression_in_expression_wrapper5203_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_negated_expression_in_logical_and_expression5223_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_negated_expression_in_logical_and_expression5223( FOLLOW_negated_expression_in_logical_and_expression5223_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_and_key_in_logical_and_expression5227_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_and_key_in_logical_and_expression5227( FOLLOW_and_key_in_logical_and_expression5227_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_negated_expression_in_logical_and_expression5229_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_negated_expression_in_logical_and_expression5229( FOLLOW_negated_expression_in_logical_and_expression5229_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_not_key_in_negated_expression5252_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_not_key_in_negated_expression5252( FOLLOW_not_key_in_negated_expression5252_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_negated_expression_in_negated_expression5254_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_negated_expression_in_negated_expression5254( FOLLOW_negated_expression_in_negated_expression5254_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_equality_expression_in_negated_expression5265_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_equality_expression_in_negated_expression5265( FOLLOW_equality_expression_in_negated_expression5265_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multiset_comparsion_in_equality_expression5285_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0100000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multiset_comparsion_in_equality_expression5285( FOLLOW_multiset_comparsion_in_equality_expression5285_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_is_key_in_equality_expression5296_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1C00000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_is_key_in_equality_expression5296( FOLLOW_is_key_in_equality_expression5296_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_not_key_in_equality_expression5298_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x1800000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_not_key_in_equality_expression5298( FOLLOW_not_key_in_equality_expression5298_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_null_key_in_equality_expression5314_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_null_key_in_equality_expression5314( FOLLOW_null_key_in_equality_expression5314_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nan_key_in_equality_expression5329_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nan_key_in_equality_expression5329( FOLLOW_nan_key_in_equality_expression5329_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_present_key_in_equality_expression5344_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_present_key_in_equality_expression5344( FOLLOW_present_key_in_equality_expression5344_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_infinite_key_in_equality_expression5359_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_infinite_key_in_equality_expression5359( FOLLOW_infinite_key_in_equality_expression5359_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_a_key_in_equality_expression5374_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_a_key_in_equality_expression5374( FOLLOW_a_key_in_equality_expression5374_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_set_key_in_equality_expression5376_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_set_key_in_equality_expression5376( FOLLOW_set_key_in_equality_expression5376_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_empty_key_in_equality_expression5391_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_empty_key_in_equality_expression5391( FOLLOW_empty_key_in_equality_expression5391_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_of_key_in_equality_expression5406_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_of_key_in_equality_expression5406( FOLLOW_of_key_in_equality_expression5406_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_type_key_in_equality_expression5408_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_type_key_in_equality_expression5408( FOLLOW_type_key_in_equality_expression5408_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_equality_expression5411_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_equality_expression5411( FOLLOW_LEFT_PAREN_in_equality_expression5411_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_only_key_in_equality_expression5413_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_only_key_in_equality_expression5413( FOLLOW_only_key_in_equality_expression5413_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_equality_expression5416_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_type_spec_in_equality_expression5416( FOLLOW_type_spec_in_equality_expression5416_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_equality_expression5419_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_equality_expression5419( FOLLOW_COMMA_in_equality_expression5419_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_equality_expression5421_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_type_spec_in_equality_expression5421( FOLLOW_type_spec_in_equality_expression5421_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_equality_expression5425_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_equality_expression5425( FOLLOW_RIGHT_PAREN_in_equality_expression5425_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_relational_expression_in_multiset_comparsion5463_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_relational_expression_in_multiset_comparsion5463( FOLLOW_relational_expression_in_multiset_comparsion5463_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multiset_type_in_multiset_comparsion5474_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x1800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multiset_type_in_multiset_comparsion5474( FOLLOW_multiset_type_in_multiset_comparsion5474_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_of_key_in_multiset_comparsion5476_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_of_key_in_multiset_comparsion5476( FOLLOW_of_key_in_multiset_comparsion5476_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_multiset_comparsion5479_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_in_multiset_comparsion5479( FOLLOW_concatenation_in_multiset_comparsion5479_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_member_key_in_multiset_type5501_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_member_key_in_multiset_type5501( FOLLOW_member_key_in_multiset_type5501_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_submultiset_key_in_multiset_type5512_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_submultiset_key_in_multiset_type5512( FOLLOW_submultiset_key_in_multiset_type5512_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_compound_expression_in_relational_expression5532_bits[]	= { ANTLR_UINT64_LIT(0x0000001186A00802) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_compound_expression_in_relational_expression5532( FOLLOW_compound_expression_in_relational_expression5532_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_relational_expression5542_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_relational_expression5542( FOLLOW_EQUALS_OP_in_relational_expression5542_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_not_equal_op_in_relational_expression5546_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_not_equal_op_in_relational_expression5546( FOLLOW_not_equal_op_in_relational_expression5546_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LESS_THAN_OP_in_relational_expression5550_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LESS_THAN_OP_in_relational_expression5550( FOLLOW_LESS_THAN_OP_in_relational_expression5550_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_GREATER_THAN_OP_in_relational_expression5554_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_GREATER_THAN_OP_in_relational_expression5554( FOLLOW_GREATER_THAN_OP_in_relational_expression5554_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_less_than_or_equals_op_in_relational_expression5558_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_less_than_or_equals_op_in_relational_expression5558( FOLLOW_less_than_or_equals_op_in_relational_expression5558_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_greater_than_or_equals_op_in_relational_expression5562_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_greater_than_or_equals_op_in_relational_expression5562( FOLLOW_greater_than_or_equals_op_in_relational_expression5562_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_compound_expression_in_relational_expression5566_bits[]	= { ANTLR_UINT64_LIT(0x0000001186A00802) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_compound_expression_in_relational_expression5566( FOLLOW_compound_expression_in_relational_expression5566_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_compound_expression5588_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0610000002000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_in_compound_expression5588( FOLLOW_concatenation_in_compound_expression5588_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_not_key_in_compound_expression5599_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0210000002000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_not_key_in_compound_expression5599( FOLLOW_not_key_in_compound_expression5599_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_compound_expression5615_bits[]	= { ANTLR_UINT64_LIT(0x0000000450447220), ANTLR_UINT64_LIT(0x0800100A00000400), ANTLR_UINT64_LIT(0x0000000000801000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_in_key_in_compound_expression5615( FOLLOW_in_key_in_compound_expression5615_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_in_elements_in_compound_expression5617_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_in_elements_in_compound_expression5617( FOLLOW_in_elements_in_compound_expression5617_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_between_key_in_compound_expression5632_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_between_key_in_compound_expression5632( FOLLOW_between_key_in_compound_expression5632_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_between_elements_in_compound_expression5634_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_between_elements_in_compound_expression5634( FOLLOW_between_elements_in_compound_expression5634_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_like_type_in_compound_expression5649_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_like_type_in_compound_expression5649( FOLLOW_like_type_in_compound_expression5649_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_compound_expression5651_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_in_compound_expression5651( FOLLOW_concatenation_in_compound_expression5651_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_like_escape_part_in_compound_expression5653_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_like_escape_part_in_compound_expression5653( FOLLOW_like_escape_part_in_compound_expression5653_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_like_key_in_like_type5691_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_like_key_in_like_type5691( FOLLOW_like_key_in_like_type5691_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_likec_key_in_like_type5702_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_likec_key_in_like_type5702( FOLLOW_likec_key_in_like_type5702_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_like2_key_in_like_type5713_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_like2_key_in_like_type5713( FOLLOW_like2_key_in_like_type5713_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_like4_key_in_like_type5724_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_like4_key_in_like_type5724( FOLLOW_like4_key_in_like_type5724_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_escape_key_in_like_escape_part5744_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_escape_key_in_like_escape_part5744( FOLLOW_escape_key_in_like_escape_part5744_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_like_escape_part5746_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_in_like_escape_part5746( FOLLOW_concatenation_in_like_escape_part5746_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_in_elements5779_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_in_elements5779( FOLLOW_LEFT_PAREN_in_in_elements5779_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_in_elements5781_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_in_elements5781( FOLLOW_subquery_in_in_elements5781_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_in_elements5783_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_in_elements5783( FOLLOW_RIGHT_PAREN_in_in_elements5783_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_in_elements5794_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_in_elements5794( FOLLOW_LEFT_PAREN_in_in_elements5794_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_in_elements5796_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_in_elements5796( FOLLOW_concatenation_wrapper_in_in_elements5796_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_in_elements5799_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_in_elements5799( FOLLOW_COMMA_in_in_elements5799_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_in_elements5801_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_in_elements5801( FOLLOW_concatenation_wrapper_in_in_elements5801_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_in_elements5805_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_in_elements5805( FOLLOW_RIGHT_PAREN_in_in_elements5805_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_constant_in_in_elements5816_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_constant_in_in_elements5816( FOLLOW_constant_in_in_elements5816_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_in_elements5827_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_bind_variable_in_in_elements5827( FOLLOW_bind_variable_in_in_elements5827_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_in_in_elements5838_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_in_in_elements5838( FOLLOW_general_element_in_in_elements5838_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_between_elements5858_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_in_between_elements5858( FOLLOW_concatenation_in_between_elements5858_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_and_key_in_between_elements5860_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_and_key_in_between_elements5860( FOLLOW_and_key_in_between_elements5860_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_between_elements5862_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_in_between_elements5862( FOLLOW_concatenation_in_between_elements5862_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_additive_expression_in_concatenation5882_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000001000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_additive_expression_in_concatenation5882( FOLLOW_additive_expression_in_concatenation5882_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_op_in_concatenation5885_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_op_in_concatenation5885( FOLLOW_concatenation_op_in_concatenation5885_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_additive_expression_in_concatenation5887_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000001000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_additive_expression_in_concatenation5887( FOLLOW_additive_expression_in_concatenation5887_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_concatenation_wrapper5909_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_in_concatenation_wrapper5909( FOLLOW_concatenation_in_concatenation_wrapper5909_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multiply_expression_in_additive_expression5929_bits[]	= { ANTLR_UINT64_LIT(0x0000000200000002), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multiply_expression_in_additive_expression5929( FOLLOW_multiply_expression_in_additive_expression5929_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_additive_expression5933_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_set_in_additive_expression5933( FOLLOW_set_in_additive_expression5933_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multiply_expression_in_additive_expression5943_bits[]	= { ANTLR_UINT64_LIT(0x0000000200000002), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multiply_expression_in_additive_expression5943( FOLLOW_multiply_expression_in_additive_expression5943_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_datetime_expression_in_multiply_expression5965_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000082), ANTLR_UINT64_LIT(0x0000000000010000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_datetime_expression_in_multiply_expression5965( FOLLOW_datetime_expression_in_multiply_expression5965_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_set_in_multiply_expression5969_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_set_in_multiply_expression5969( FOLLOW_set_in_multiply_expression5969_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_datetime_expression_in_multiply_expression5979_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000082), ANTLR_UINT64_LIT(0x0000000000010000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_datetime_expression_in_multiply_expression5979( FOLLOW_datetime_expression_in_multiply_expression5979_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_expression_in_datetime_expression6001_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_expression_in_datetime_expression6001( FOLLOW_model_expression_in_datetime_expression6001_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_at_key_in_datetime_expression6012_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_at_key_in_datetime_expression6012( FOLLOW_at_key_in_datetime_expression6012_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_local_key_in_datetime_expression6015_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_local_key_in_datetime_expression6015( FOLLOW_local_key_in_datetime_expression6015_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_time_key_in_datetime_expression6017_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_time_key_in_datetime_expression6017( FOLLOW_time_key_in_datetime_expression6017_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_zone_key_in_datetime_expression6019_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_zone_key_in_datetime_expression6019( FOLLOW_zone_key_in_datetime_expression6019_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_datetime_expression6021_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_datetime_expression6021( FOLLOW_concatenation_wrapper_in_datetime_expression6021_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_interval_expression_in_datetime_expression6038_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_interval_expression_in_datetime_expression6038( FOLLOW_interval_expression_in_datetime_expression6038_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_day_key_in_interval_expression6065_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_day_key_in_interval_expression6065( FOLLOW_day_key_in_interval_expression6065_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_interval_expression6071_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_interval_expression6071( FOLLOW_LEFT_PAREN_in_interval_expression6071_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_interval_expression6073_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_interval_expression6073( FOLLOW_concatenation_wrapper_in_interval_expression6073_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_interval_expression6075_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_interval_expression6075( FOLLOW_RIGHT_PAREN_in_interval_expression6075_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_to_key_in_interval_expression6079_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_to_key_in_interval_expression6079( FOLLOW_to_key_in_interval_expression6079_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_second_key_in_interval_expression6081_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_second_key_in_interval_expression6081( FOLLOW_second_key_in_interval_expression6081_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_interval_expression6084_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_interval_expression6084( FOLLOW_LEFT_PAREN_in_interval_expression6084_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_interval_expression6086_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_interval_expression6086( FOLLOW_concatenation_wrapper_in_interval_expression6086_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_interval_expression6088_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_interval_expression6088( FOLLOW_RIGHT_PAREN_in_interval_expression6088_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_year_key_in_interval_expression6101_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_year_key_in_interval_expression6101( FOLLOW_year_key_in_interval_expression6101_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_interval_expression6104_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_interval_expression6104( FOLLOW_LEFT_PAREN_in_interval_expression6104_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_interval_expression6106_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_interval_expression6106( FOLLOW_concatenation_wrapper_in_interval_expression6106_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_interval_expression6108_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_interval_expression6108( FOLLOW_RIGHT_PAREN_in_interval_expression6108_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_to_key_in_interval_expression6112_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_to_key_in_interval_expression6112( FOLLOW_to_key_in_interval_expression6112_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_month_key_in_interval_expression6114_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_month_key_in_interval_expression6114( FOLLOW_month_key_in_interval_expression6114_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multiset_expression_in_model_expression6134_bits[]	= { ANTLR_UINT64_LIT(0x0000000020000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multiset_expression_in_model_expression6134( FOLLOW_multiset_expression_in_model_expression6134_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_BRACKET_in_model_expression6145_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00584B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_BRACKET_in_model_expression6145( FOLLOW_LEFT_BRACKET_in_model_expression6145_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_expression_element_in_model_expression6147_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_expression_element_in_model_expression6147( FOLLOW_model_expression_element_in_model_expression6147_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_BRACKET_in_model_expression6149_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_BRACKET_in_model_expression6149( FOLLOW_RIGHT_BRACKET_in_model_expression6149_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_any_key_in_model_expression_element6177_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_any_key_in_model_expression_element6177( FOLLOW_any_key_in_model_expression_element6177_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_wrapper_in_model_expression_element6179_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_wrapper_in_model_expression_element6179( FOLLOW_condition_wrapper_in_model_expression_element6179_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_model_expression_element6183_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_model_expression_element6183( FOLLOW_COMMA_in_model_expression_element6183_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_any_key_in_model_expression_element6191_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_any_key_in_model_expression_element6191( FOLLOW_any_key_in_model_expression_element6191_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_wrapper_in_model_expression_element6193_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_wrapper_in_model_expression_element6193( FOLLOW_condition_wrapper_in_model_expression_element6193_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_single_column_for_loop_in_model_expression_element6207_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_single_column_for_loop_in_model_expression_element6207( FOLLOW_single_column_for_loop_in_model_expression_element6207_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_model_expression_element6210_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000400000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_model_expression_element6210( FOLLOW_COMMA_in_model_expression_element6210_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_single_column_for_loop_in_model_expression_element6212_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_single_column_for_loop_in_model_expression_element6212( FOLLOW_single_column_for_loop_in_model_expression_element6212_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multi_column_for_loop_in_model_expression_element6225_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multi_column_for_loop_in_model_expression_element6225( FOLLOW_multi_column_for_loop_in_model_expression_element6225_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_key_in_single_column_for_loop6245_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_key_in_single_column_for_loop6245( FOLLOW_for_key_in_single_column_for_loop6245_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_single_column_for_loop6247_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0210800000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_single_column_for_loop6247( FOLLOW_column_name_in_single_column_for_loop6247_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_single_column_for_loop6259_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_in_key_in_single_column_for_loop6259( FOLLOW_in_key_in_single_column_for_loop6259_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_single_column_for_loop6261_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_list_in_single_column_for_loop6261( FOLLOW_expression_list_in_single_column_for_loop6261_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_like_part_in_single_column_for_loop6272_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_like_part_in_single_column_for_loop6272( FOLLOW_for_like_part_in_single_column_for_loop6272_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_from_key_in_single_column_for_loop6275_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_from_key_in_single_column_for_loop6275( FOLLOW_from_key_in_single_column_for_loop6275_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_single_column_for_loop6279_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000800) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_single_column_for_loop6279( FOLLOW_expression_in_single_column_for_loop6279_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_to_key_in_single_column_for_loop6293_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_to_key_in_single_column_for_loop6293( FOLLOW_to_key_in_single_column_for_loop6293_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_single_column_for_loop6297_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_single_column_for_loop6297( FOLLOW_expression_in_single_column_for_loop6297_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_increment_decrement_type_in_single_column_for_loop6299_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_increment_decrement_type_in_single_column_for_loop6299( FOLLOW_for_increment_decrement_type_in_single_column_for_loop6299_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_single_column_for_loop6303_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_single_column_for_loop6303( FOLLOW_expression_in_single_column_for_loop6303_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_like_key_in_for_like_part6334_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_like_key_in_for_like_part6334( FOLLOW_like_key_in_for_like_part6334_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_for_like_part6336_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_for_like_part6336( FOLLOW_expression_in_for_like_part6336_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_increment_key_in_for_increment_decrement_type6356_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_increment_key_in_for_increment_decrement_type6356( FOLLOW_increment_key_in_for_increment_decrement_type6356_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_decrement_key_in_for_increment_decrement_type6367_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_decrement_key_in_for_increment_decrement_type6367( FOLLOW_decrement_key_in_for_increment_decrement_type6367_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_key_in_multi_column_for_loop6387_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_key_in_multi_column_for_loop6387( FOLLOW_for_key_in_multi_column_for_loop6387_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_multi_column_for_loop6389_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_multi_column_for_loop6389( FOLLOW_LEFT_PAREN_in_multi_column_for_loop6389_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_multi_column_for_loop6391_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_multi_column_for_loop6391( FOLLOW_column_name_in_multi_column_for_loop6391_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_multi_column_for_loop6394_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_multi_column_for_loop6394( FOLLOW_COMMA_in_multi_column_for_loop6394_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_name_in_multi_column_for_loop6396_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_name_in_multi_column_for_loop6396( FOLLOW_column_name_in_multi_column_for_loop6396_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6400_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0010000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6400( FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6400_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_multi_column_for_loop6402_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_in_key_in_multi_column_for_loop6402( FOLLOW_in_key_in_multi_column_for_loop6402_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_multi_column_for_loop6412_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_multi_column_for_loop6412( FOLLOW_LEFT_PAREN_in_multi_column_for_loop6412_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_multi_column_for_loop6436_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_multi_column_for_loop6436( FOLLOW_subquery_in_multi_column_for_loop6436_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_multi_column_for_loop6460_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_multi_column_for_loop6460( FOLLOW_LEFT_PAREN_in_multi_column_for_loop6460_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_multi_column_for_loop6462_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_list_in_multi_column_for_loop6462( FOLLOW_expression_list_in_multi_column_for_loop6462_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_multi_column_for_loop6465_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_multi_column_for_loop6465( FOLLOW_COMMA_in_multi_column_for_loop6465_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_multi_column_for_loop6467_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_list_in_multi_column_for_loop6467( FOLLOW_expression_list_in_multi_column_for_loop6467_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6471_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6471( FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6471_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6495_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6495( FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6495_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_multiset_expression6509_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_multiset_expression6509( FOLLOW_unary_expression_in_multiset_expression6509_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multiset_op_in_multiset_expression6515_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multiset_op_in_multiset_expression6515( FOLLOW_multiset_op_in_multiset_expression6515_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_multiset_expression6517_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_multiset_expression6517( FOLLOW_unary_expression_in_multiset_expression6517_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_MINUS_SIGN_in_unary_expression6546_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_MINUS_SIGN_in_unary_expression6546( FOLLOW_MINUS_SIGN_in_unary_expression6546_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression6548_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression6548( FOLLOW_unary_expression_in_unary_expression6548_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PLUS_SIGN_in_unary_expression6559_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PLUS_SIGN_in_unary_expression6559( FOLLOW_PLUS_SIGN_in_unary_expression6559_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression6561_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression6561( FOLLOW_unary_expression_in_unary_expression6561_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_prior_key_in_unary_expression6572_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_prior_key_in_unary_expression6572( FOLLOW_prior_key_in_unary_expression6572_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression6574_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression6574( FOLLOW_unary_expression_in_unary_expression6574_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_connect_by_root_key_in_unary_expression6585_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_connect_by_root_key_in_unary_expression6585( FOLLOW_connect_by_root_key_in_unary_expression6585_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression6587_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression6587( FOLLOW_unary_expression_in_unary_expression6587_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_new_key_in_unary_expression6602_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_new_key_in_unary_expression6602( FOLLOW_new_key_in_unary_expression6602_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression6604_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression6604( FOLLOW_unary_expression_in_unary_expression6604_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_distinct_key_in_unary_expression6615_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_distinct_key_in_unary_expression6615( FOLLOW_distinct_key_in_unary_expression6615_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression6617_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression6617( FOLLOW_unary_expression_in_unary_expression6617_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_unary_expression6628_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_unary_expression6628( FOLLOW_all_key_in_unary_expression6628_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_unary_expression6630_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_unary_expression6630( FOLLOW_unary_expression_in_unary_expression6630_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_case_statement_in_unary_expression6643_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_case_statement_in_unary_expression6643( FOLLOW_case_statement_in_unary_expression6643_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_quantified_expression_in_unary_expression6655_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_quantified_expression_in_unary_expression6655( FOLLOW_quantified_expression_in_unary_expression6655_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_standard_function_in_unary_expression6666_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_standard_function_in_unary_expression6666( FOLLOW_standard_function_in_unary_expression6666_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_atom_in_unary_expression6677_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_atom_in_unary_expression6677( FOLLOW_atom_in_unary_expression6677_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_searched_case_statement_in_case_statement6724_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_searched_case_statement_in_case_statement6724( FOLLOW_searched_case_statement_in_case_statement6724_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_simple_case_statement_in_case_statement6735_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_simple_case_statement_in_case_statement6735( FOLLOW_simple_case_statement_in_case_statement6735_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_label_name_in_simple_case_statement6757_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000008000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_label_name_in_simple_case_statement6757( FOLLOW_label_name_in_simple_case_statement6757_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_case_key_in_simple_case_statement6762_bits[]	= { ANTLR_UINT64_LIT(0x0000000450447220), ANTLR_UINT64_LIT(0x0800100A00000400), ANTLR_UINT64_LIT(0x0000000000801000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_case_key_in_simple_case_statement6762( FOLLOW_case_key_in_simple_case_statement6762_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_atom_in_simple_case_statement6764_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_atom_in_simple_case_statement6764( FOLLOW_atom_in_simple_case_statement6764_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_simple_case_when_part_in_simple_case_statement6774_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000030000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_simple_case_when_part_in_simple_case_statement6774( FOLLOW_simple_case_when_part_in_simple_case_statement6774_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_case_else_part_in_simple_case_statement6786_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_case_else_part_in_simple_case_statement6786( FOLLOW_case_else_part_in_simple_case_statement6786_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_end_key_in_simple_case_statement6797_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040002), ANTLR_UINT64_LIT(0x0000000008000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_end_key_in_simple_case_statement6797( FOLLOW_end_key_in_simple_case_statement6797_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_case_key_in_simple_case_statement6799_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_case_key_in_simple_case_statement6799( FOLLOW_case_key_in_simple_case_statement6799_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_label_name_in_simple_case_statement6802_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_label_name_in_simple_case_statement6802( FOLLOW_label_name_in_simple_case_statement6802_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_simple_case_when_part6823_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_when_key_in_simple_case_when_part6823( FOLLOW_when_key_in_simple_case_when_part6823_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_simple_case_when_part6825_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_simple_case_when_part6825( FOLLOW_expression_wrapper_in_simple_case_when_part6825_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_then_key_in_simple_case_when_part6827_bits[]	= { ANTLR_UINT64_LIT(0x00480086D0447220), ANTLR_UINT64_LIT(0x0C23785F492C0401), ANTLR_UINT64_LIT(0x000000000090904C) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_then_key_in_simple_case_when_part6827( FOLLOW_then_key_in_simple_case_when_part6827_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_seq_of_statements_in_simple_case_when_part6832_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_seq_of_statements_in_simple_case_when_part6832( FOLLOW_seq_of_statements_in_simple_case_when_part6832_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_simple_case_when_part6836_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_simple_case_when_part6836( FOLLOW_expression_wrapper_in_simple_case_when_part6836_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_label_name_in_searched_case_statement6857_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000008000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_label_name_in_searched_case_statement6857( FOLLOW_label_name_in_searched_case_statement6857_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_case_key_in_searched_case_statement6862_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_case_key_in_searched_case_statement6862( FOLLOW_case_key_in_searched_case_statement6862_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_searched_case_when_part_in_searched_case_statement6872_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000030000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_searched_case_when_part_in_searched_case_statement6872( FOLLOW_searched_case_when_part_in_searched_case_statement6872_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_case_else_part_in_searched_case_statement6883_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000020000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_case_else_part_in_searched_case_statement6883( FOLLOW_case_else_part_in_searched_case_statement6883_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_end_key_in_searched_case_statement6894_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040002), ANTLR_UINT64_LIT(0x0000000008000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_end_key_in_searched_case_statement6894( FOLLOW_end_key_in_searched_case_statement6894_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_case_key_in_searched_case_statement6896_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_case_key_in_searched_case_statement6896( FOLLOW_case_key_in_searched_case_statement6896_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_label_name_in_searched_case_statement6899_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_label_name_in_searched_case_statement6899( FOLLOW_label_name_in_searched_case_statement6899_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_searched_case_when_part6920_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_when_key_in_searched_case_when_part6920( FOLLOW_when_key_in_searched_case_when_part6920_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_condition_wrapper_in_searched_case_when_part6922_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_condition_wrapper_in_searched_case_when_part6922( FOLLOW_condition_wrapper_in_searched_case_when_part6922_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_then_key_in_searched_case_when_part6924_bits[]	= { ANTLR_UINT64_LIT(0x00480086D0447220), ANTLR_UINT64_LIT(0x0C23785F492C0401), ANTLR_UINT64_LIT(0x000000000090904C) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_then_key_in_searched_case_when_part6924( FOLLOW_then_key_in_searched_case_when_part6924_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_seq_of_statements_in_searched_case_when_part6929_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_seq_of_statements_in_searched_case_when_part6929( FOLLOW_seq_of_statements_in_searched_case_when_part6929_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_searched_case_when_part6933_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_searched_case_when_part6933( FOLLOW_expression_wrapper_in_searched_case_when_part6933_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_else_key_in_case_else_part6954_bits[]	= { ANTLR_UINT64_LIT(0x00480086D0447220), ANTLR_UINT64_LIT(0x0C23785F492C0401), ANTLR_UINT64_LIT(0x000000000090904C) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_else_key_in_case_else_part6954( FOLLOW_else_key_in_case_else_part6954_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_seq_of_statements_in_case_else_part6959_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_seq_of_statements_in_case_else_part6959( FOLLOW_seq_of_statements_in_case_else_part6959_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_case_else_part6963_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_case_else_part6963( FOLLOW_expression_wrapper_in_case_else_part6963_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_element_in_atom7002_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_element_in_atom7002( FOLLOW_table_element_in_atom7002_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_outer_join_sign_in_atom7004_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_outer_join_sign_in_atom7004( FOLLOW_outer_join_sign_in_atom7004_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_bind_variable_in_atom7015_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_bind_variable_in_atom7015( FOLLOW_bind_variable_in_atom7015_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_constant_in_atom7026_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_constant_in_atom7026( FOLLOW_constant_in_atom7026_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_in_atom7037_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_in_atom7037( FOLLOW_general_element_in_atom7037_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_atom7048_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801044) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_atom7048( FOLLOW_LEFT_PAREN_in_atom7048_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_atom7085_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_atom7085( FOLLOW_subquery_in_atom7085_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_atom7087_bits[]	= { ANTLR_UINT64_LIT(0x0080000000000002), ANTLR_UINT64_LIT(0x0040000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_atom7087( FOLLOW_RIGHT_PAREN_in_atom7087_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_operation_part_in_atom7089_bits[]	= { ANTLR_UINT64_LIT(0x0080000000000002), ANTLR_UINT64_LIT(0x0040000000000000), ANTLR_UINT64_LIT(0x0000000000002000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_operation_part_in_atom7089( FOLLOW_subquery_operation_part_in_atom7089_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_or_vector_in_atom7108_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_or_vector_in_atom7108( FOLLOW_expression_or_vector_in_atom7108_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_atom7110_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_atom7110( FOLLOW_RIGHT_PAREN_in_atom7110_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_expression_or_vector7141_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_expression_or_vector7141( FOLLOW_expression_in_expression_or_vector7141_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_vector_expr_in_expression_or_vector7144_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_vector_expr_in_expression_or_vector7144( FOLLOW_vector_expr_in_expression_or_vector7144_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_vector_expr7166_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_vector_expr7166( FOLLOW_COMMA_in_vector_expr7166_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_vector_expr7168_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_vector_expr7168( FOLLOW_expression_in_vector_expr7168_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_vector_expr7171_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_vector_expr7171( FOLLOW_COMMA_in_vector_expr7171_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_vector_expr7173_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_vector_expr7173( FOLLOW_expression_in_vector_expr7173_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_some_key_in_quantified_expression7197_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_some_key_in_quantified_expression7197( FOLLOW_some_key_in_quantified_expression7197_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_exists_key_in_quantified_expression7201_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_exists_key_in_quantified_expression7201( FOLLOW_exists_key_in_quantified_expression7201_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_quantified_expression7205_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_quantified_expression7205( FOLLOW_all_key_in_quantified_expression7205_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_any_key_in_quantified_expression7209_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_any_key_in_quantified_expression7209( FOLLOW_any_key_in_quantified_expression7209_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_quantified_expression7236_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_quantified_expression7236( FOLLOW_LEFT_PAREN_in_quantified_expression7236_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_quantified_expression7238_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_quantified_expression7238( FOLLOW_subquery_in_quantified_expression7238_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_quantified_expression7240_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_quantified_expression7240( FOLLOW_RIGHT_PAREN_in_quantified_expression7240_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_quantified_expression7255_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_quantified_expression7255( FOLLOW_LEFT_PAREN_in_quantified_expression7255_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_quantified_expression7257_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_quantified_expression7257( FOLLOW_expression_wrapper_in_quantified_expression7257_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_quantified_expression7259_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_quantified_expression7259( FOLLOW_RIGHT_PAREN_in_quantified_expression7259_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_stantard_function_enabling_over_in_standard_function7290_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_stantard_function_enabling_over_in_standard_function7290( FOLLOW_stantard_function_enabling_over_in_standard_function7290_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_function_argument_analytic_in_standard_function7292_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_function_argument_analytic_in_standard_function7292( FOLLOW_function_argument_analytic_in_standard_function7292_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_over_clause_in_standard_function7294_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_over_clause_in_standard_function7294( FOLLOW_over_clause_in_standard_function7294_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_stantard_function_enabling_using_in_standard_function7306_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_stantard_function_enabling_using_in_standard_function7306( FOLLOW_stantard_function_enabling_using_in_standard_function7306_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_function_argument_modeling_in_standard_function7308_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_function_argument_modeling_in_standard_function7308( FOLLOW_function_argument_modeling_in_standard_function7308_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_using_clause_in_standard_function7310_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_using_clause_in_standard_function7310( FOLLOW_using_clause_in_standard_function7310_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_count_key_in_standard_function7322_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_count_key_in_standard_function7322( FOLLOW_count_key_in_standard_function7322_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function7336_bits[]	= { ANTLR_UINT64_LIT(0x00000086504472A0), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000805004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function7336( FOLLOW_LEFT_PAREN_in_standard_function7336_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_standard_function7356_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_ASTERISK_in_standard_function7356( FOLLOW_ASTERISK_in_standard_function7356_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_distinct_key_in_standard_function7361_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_distinct_key_in_standard_function7361( FOLLOW_distinct_key_in_standard_function7361_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unique_key_in_standard_function7363_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unique_key_in_standard_function7363( FOLLOW_unique_key_in_standard_function7363_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_standard_function7365_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_standard_function7365( FOLLOW_all_key_in_standard_function7365_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function7369_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function7369( FOLLOW_concatenation_wrapper_in_standard_function7369_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function7385_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function7385( FOLLOW_RIGHT_PAREN_in_standard_function7385_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_over_clause_in_standard_function7387_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_over_clause_in_standard_function7387( FOLLOW_over_clause_in_standard_function7387_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cast_key_in_standard_function7400_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cast_key_in_standard_function7400( FOLLOW_cast_key_in_standard_function7400_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlcast_key_in_standard_function7402_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlcast_key_in_standard_function7402( FOLLOW_xmlcast_key_in_standard_function7402_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function7418_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function7418( FOLLOW_LEFT_PAREN_in_standard_function7418_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multiset_key_in_standard_function7446_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multiset_key_in_standard_function7446( FOLLOW_multiset_key_in_standard_function7446_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function7448_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function7448( FOLLOW_LEFT_PAREN_in_standard_function7448_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_subquery_in_standard_function7450_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_subquery_in_standard_function7450( FOLLOW_subquery_in_standard_function7450_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_standard_function7452_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_by_clause_in_standard_function7452( FOLLOW_order_by_clause_in_standard_function7452_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function7455_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000401000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function7455( FOLLOW_RIGHT_PAREN_in_standard_function7455_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_standard_function7469_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_as_key_in_standard_function7469( FOLLOW_as_key_in_standard_function7469_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_standard_function7471_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_type_spec_in_standard_function7471( FOLLOW_type_spec_in_standard_function7471_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function7493_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000400000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function7493( FOLLOW_concatenation_wrapper_in_standard_function7493_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_standard_function7495_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_as_key_in_standard_function7495( FOLLOW_as_key_in_standard_function7495_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_standard_function7497_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_type_spec_in_standard_function7497( FOLLOW_type_spec_in_standard_function7497_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function7529_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function7529( FOLLOW_RIGHT_PAREN_in_standard_function7529_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_chr_key_in_standard_function7540_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_chr_key_in_standard_function7540( FOLLOW_chr_key_in_standard_function7540_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function7554_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function7554( FOLLOW_LEFT_PAREN_in_standard_function7554_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function7573_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function7573( FOLLOW_concatenation_wrapper_in_standard_function7573_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_using_key_in_standard_function7575_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_using_key_in_standard_function7575( FOLLOW_using_key_in_standard_function7575_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nchar_cs_key_in_standard_function7577_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nchar_cs_key_in_standard_function7577( FOLLOW_nchar_cs_key_in_standard_function7577_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function7592_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function7592( FOLLOW_RIGHT_PAREN_in_standard_function7592_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_collect_key_in_standard_function7603_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_collect_key_in_standard_function7603( FOLLOW_collect_key_in_standard_function7603_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function7617_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000805004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function7617( FOLLOW_LEFT_PAREN_in_standard_function7617_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_distinct_key_in_standard_function7637_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_distinct_key_in_standard_function7637( FOLLOW_distinct_key_in_standard_function7637_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unique_key_in_standard_function7639_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unique_key_in_standard_function7639( FOLLOW_unique_key_in_standard_function7639_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function7643_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function7643( FOLLOW_concatenation_wrapper_in_standard_function7643_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_collect_order_by_part_in_standard_function7645_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_collect_order_by_part_in_standard_function7645( FOLLOW_collect_order_by_part_in_standard_function7645_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function7660_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function7660( FOLLOW_RIGHT_PAREN_in_standard_function7660_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_stantard_function_enabling_within_or_over_in_standard_function7671_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_stantard_function_enabling_within_or_over_in_standard_function7671( FOLLOW_stantard_function_enabling_within_or_over_in_standard_function7671_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_function_argument_in_standard_function7686_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_function_argument_in_standard_function7686( FOLLOW_function_argument_in_standard_function7686_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_within_or_over_part_in_standard_function7688_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_within_or_over_part_in_standard_function7688( FOLLOW_within_or_over_part_in_standard_function7688_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_decompose_key_in_standard_function7700_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_decompose_key_in_standard_function7700( FOLLOW_decompose_key_in_standard_function7700_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function7714_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function7714( FOLLOW_LEFT_PAREN_in_standard_function7714_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function7733_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function7733( FOLLOW_concatenation_wrapper_in_standard_function7733_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_canonical_key_in_standard_function7736_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_canonical_key_in_standard_function7736( FOLLOW_canonical_key_in_standard_function7736_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_compatibility_key_in_standard_function7738_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_compatibility_key_in_standard_function7738( FOLLOW_compatibility_key_in_standard_function7738_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function7755_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function7755( FOLLOW_RIGHT_PAREN_in_standard_function7755_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_extract_key_in_standard_function7766_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_extract_key_in_standard_function7766( FOLLOW_extract_key_in_standard_function7766_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function7780_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function7780( FOLLOW_LEFT_PAREN_in_standard_function7780_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_standard_function7798_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_standard_function7798( FOLLOW_REGULAR_ID_in_standard_function7798_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_from_key_in_standard_function7800_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_from_key_in_standard_function7800( FOLLOW_from_key_in_standard_function7800_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function7802_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function7802( FOLLOW_concatenation_wrapper_in_standard_function7802_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function7817_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function7817( FOLLOW_RIGHT_PAREN_in_standard_function7817_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_first_value_key_in_standard_function7829_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_first_value_key_in_standard_function7829( FOLLOW_first_value_key_in_standard_function7829_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_last_value_key_in_standard_function7831_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_last_value_key_in_standard_function7831( FOLLOW_last_value_key_in_standard_function7831_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_function_argument_analytic_in_standard_function7834_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_function_argument_analytic_in_standard_function7834( FOLLOW_function_argument_analytic_in_standard_function7834_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_respect_or_ignore_nulls_in_standard_function7849_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_respect_or_ignore_nulls_in_standard_function7849( FOLLOW_respect_or_ignore_nulls_in_standard_function7849_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_over_clause_in_standard_function7852_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_over_clause_in_standard_function7852( FOLLOW_over_clause_in_standard_function7852_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_stantard_function_pedictions_in_standard_function7863_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_stantard_function_pedictions_in_standard_function7863( FOLLOW_stantard_function_pedictions_in_standard_function7863_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function7877_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function7877( FOLLOW_LEFT_PAREN_in_standard_function7877_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function7895_bits[]	= { ANTLR_UINT64_LIT(0x0000100000008000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function7895( FOLLOW_expression_wrapper_in_standard_function7895_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function7898_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function7898( FOLLOW_COMMA_in_standard_function7898_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function7900_bits[]	= { ANTLR_UINT64_LIT(0x0000100000008000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function7900( FOLLOW_expression_wrapper_in_standard_function7900_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cost_matrix_clause_in_standard_function7904_bits[]	= { ANTLR_UINT64_LIT(0x0000100000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cost_matrix_clause_in_standard_function7904( FOLLOW_cost_matrix_clause_in_standard_function7904_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_using_clause_in_standard_function7907_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_using_clause_in_standard_function7907( FOLLOW_using_clause_in_standard_function7907_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function7923_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function7923( FOLLOW_RIGHT_PAREN_in_standard_function7923_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_translate_key_in_standard_function7934_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_translate_key_in_standard_function7934( FOLLOW_translate_key_in_standard_function7934_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function7948_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function7948( FOLLOW_LEFT_PAREN_in_standard_function7948_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function7967_bits[]	= { ANTLR_UINT64_LIT(0x0000100000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function7967( FOLLOW_expression_wrapper_in_standard_function7967_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_using_key_in_standard_function7970_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_using_key_in_standard_function7970( FOLLOW_using_key_in_standard_function7970_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_char_cs_key_in_standard_function7973_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_char_cs_key_in_standard_function7973( FOLLOW_char_cs_key_in_standard_function7973_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_nchar_cs_key_in_standard_function7975_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_nchar_cs_key_in_standard_function7975( FOLLOW_nchar_cs_key_in_standard_function7975_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function8002_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function8002( FOLLOW_COMMA_in_standard_function8002_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function8004_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function8004( FOLLOW_expression_wrapper_in_standard_function8004_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8021_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8021( FOLLOW_RIGHT_PAREN_in_standard_function8021_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_treat_key_in_standard_function8032_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_treat_key_in_standard_function8032( FOLLOW_treat_key_in_standard_function8032_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8046_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8046( FOLLOW_LEFT_PAREN_in_standard_function8046_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function8064_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000400000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function8064( FOLLOW_expression_wrapper_in_standard_function8064_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_standard_function8066_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_as_key_in_standard_function8066( FOLLOW_as_key_in_standard_function8066_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_ref_key_in_standard_function8068_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_ref_key_in_standard_function8068( FOLLOW_ref_key_in_standard_function8068_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_standard_function8071_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_type_spec_in_standard_function8071( FOLLOW_type_spec_in_standard_function8071_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8086_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8086( FOLLOW_RIGHT_PAREN_in_standard_function8086_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_trim_key_in_standard_function8097_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_trim_key_in_standard_function8097( FOLLOW_trim_key_in_standard_function8097_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8111_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800984A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8111( FOLLOW_LEFT_PAREN_in_standard_function8111_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_leading_key_in_standard_function8132_bits[]	= { ANTLR_UINT64_LIT(0x0000000400003000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_leading_key_in_standard_function8132( FOLLOW_leading_key_in_standard_function8132_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_trailing_key_in_standard_function8134_bits[]	= { ANTLR_UINT64_LIT(0x0000000400003000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_trailing_key_in_standard_function8134( FOLLOW_trailing_key_in_standard_function8134_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_both_key_in_standard_function8136_bits[]	= { ANTLR_UINT64_LIT(0x0000000400003000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_both_key_in_standard_function8136( FOLLOW_both_key_in_standard_function8136_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_quoted_string_in_standard_function8140_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000800000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_quoted_string_in_standard_function8140( FOLLOW_quoted_string_in_standard_function8140_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_from_key_in_standard_function8143_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_from_key_in_standard_function8143( FOLLOW_from_key_in_standard_function8143_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function8163_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function8163( FOLLOW_concatenation_wrapper_in_standard_function8163_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8177_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8177( FOLLOW_RIGHT_PAREN_in_standard_function8177_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlagg_key_in_standard_function8188_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlagg_key_in_standard_function8188( FOLLOW_xmlagg_key_in_standard_function8188_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8202_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8202( FOLLOW_LEFT_PAREN_in_standard_function8202_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function8221_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function8221( FOLLOW_expression_wrapper_in_standard_function8221_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_standard_function8223_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_by_clause_in_standard_function8223( FOLLOW_order_by_clause_in_standard_function8223_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8239_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8239( FOLLOW_RIGHT_PAREN_in_standard_function8239_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function8254_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function8254( FOLLOW_PERIOD_in_standard_function8254_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function8256_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function8256( FOLLOW_general_element_part_in_standard_function8256_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlcolattval_key_in_standard_function8270_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlcolattval_key_in_standard_function8270( FOLLOW_xmlcolattval_key_in_standard_function8270_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlforest_key_in_standard_function8272_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlforest_key_in_standard_function8272( FOLLOW_xmlforest_key_in_standard_function8272_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8288_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8288( FOLLOW_LEFT_PAREN_in_standard_function8288_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_multiuse_expression_element_in_standard_function8306_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_multiuse_expression_element_in_standard_function8306( FOLLOW_xml_multiuse_expression_element_in_standard_function8306_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function8309_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function8309( FOLLOW_COMMA_in_standard_function8309_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_multiuse_expression_element_in_standard_function8311_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_multiuse_expression_element_in_standard_function8311( FOLLOW_xml_multiuse_expression_element_in_standard_function8311_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8327_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8327( FOLLOW_RIGHT_PAREN_in_standard_function8327_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function8342_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function8342( FOLLOW_PERIOD_in_standard_function8342_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function8344_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function8344( FOLLOW_general_element_part_in_standard_function8344_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlelement_key_in_standard_function8357_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlelement_key_in_standard_function8357( FOLLOW_xmlelement_key_in_standard_function8357_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8371_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8371( FOLLOW_LEFT_PAREN_in_standard_function8371_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_entityescaping_key_in_standard_function8390_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_entityescaping_key_in_standard_function8390( FOLLOW_entityescaping_key_in_standard_function8390_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_noentityescaping_key_in_standard_function8392_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_noentityescaping_key_in_standard_function8392( FOLLOW_noentityescaping_key_in_standard_function8392_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_name_key_in_standard_function8413_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_name_key_in_standard_function8413( FOLLOW_name_key_in_standard_function8413_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_evalname_key_in_standard_function8415_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_evalname_key_in_standard_function8415( FOLLOW_evalname_key_in_standard_function8415_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function8419_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function8419( FOLLOW_expression_wrapper_in_standard_function8419_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function8440_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function8440( FOLLOW_COMMA_in_standard_function8440_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_attributes_clause_in_standard_function8442_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_attributes_clause_in_standard_function8442( FOLLOW_xml_attributes_clause_in_standard_function8442_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function8463_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function8463( FOLLOW_COMMA_in_standard_function8463_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function8465_bits[]	= { ANTLR_UINT64_LIT(0x000000041004B000), ANTLR_UINT64_LIT(0x0000000000401400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function8465( FOLLOW_expression_wrapper_in_standard_function8465_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_standard_function8467_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_alias_in_standard_function8467( FOLLOW_column_alias_in_standard_function8467_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8484_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8484( FOLLOW_RIGHT_PAREN_in_standard_function8484_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function8499_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function8499( FOLLOW_PERIOD_in_standard_function8499_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function8501_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function8501( FOLLOW_general_element_part_in_standard_function8501_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlexists_key_in_standard_function8514_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlexists_key_in_standard_function8514( FOLLOW_xmlexists_key_in_standard_function8514_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8528_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8528( FOLLOW_LEFT_PAREN_in_standard_function8528_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_standard_function8546_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_standard_function8546( FOLLOW_expression_wrapper_in_standard_function8546_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_passing_clause_in_standard_function8564_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_passing_clause_in_standard_function8564( FOLLOW_xml_passing_clause_in_standard_function8564_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8579_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8579( FOLLOW_RIGHT_PAREN_in_standard_function8579_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlparse_key_in_standard_function8590_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlparse_key_in_standard_function8590( FOLLOW_xmlparse_key_in_standard_function8590_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8604_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8604( FOLLOW_LEFT_PAREN_in_standard_function8604_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_document_key_in_standard_function8624_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_document_key_in_standard_function8624( FOLLOW_document_key_in_standard_function8624_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_content_key_in_standard_function8626_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_content_key_in_standard_function8626( FOLLOW_content_key_in_standard_function8626_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function8629_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function8629( FOLLOW_concatenation_wrapper_in_standard_function8629_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_wellformed_key_in_standard_function8631_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_wellformed_key_in_standard_function8631( FOLLOW_wellformed_key_in_standard_function8631_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8646_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8646( FOLLOW_RIGHT_PAREN_in_standard_function8646_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function8661_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function8661( FOLLOW_PERIOD_in_standard_function8661_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function8663_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function8663( FOLLOW_general_element_part_in_standard_function8663_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlpi_key_in_standard_function8676_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlpi_key_in_standard_function8676( FOLLOW_xmlpi_key_in_standard_function8676_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8690_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8690( FOLLOW_LEFT_PAREN_in_standard_function8690_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_name_key_in_standard_function8714_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_name_key_in_standard_function8714( FOLLOW_name_key_in_standard_function8714_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_id_in_standard_function8716_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_id_in_standard_function8716( FOLLOW_id_in_standard_function8716_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_evalname_key_in_standard_function8739_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_evalname_key_in_standard_function8739( FOLLOW_evalname_key_in_standard_function8739_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function8741_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function8741( FOLLOW_concatenation_wrapper_in_standard_function8741_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function8778_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function8778( FOLLOW_COMMA_in_standard_function8778_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function8780_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function8780( FOLLOW_concatenation_wrapper_in_standard_function8780_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8796_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8796( FOLLOW_RIGHT_PAREN_in_standard_function8796_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function8811_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function8811( FOLLOW_PERIOD_in_standard_function8811_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function8813_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function8813( FOLLOW_general_element_part_in_standard_function8813_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlquery_key_in_standard_function8826_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlquery_key_in_standard_function8826( FOLLOW_xmlquery_key_in_standard_function8826_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8840_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8840( FOLLOW_LEFT_PAREN_in_standard_function8840_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function8859_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function8859( FOLLOW_concatenation_wrapper_in_standard_function8859_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_passing_clause_in_standard_function8861_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_passing_clause_in_standard_function8861( FOLLOW_xml_passing_clause_in_standard_function8861_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_returning_key_in_standard_function8880_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_returning_key_in_standard_function8880( FOLLOW_returning_key_in_standard_function8880_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_content_key_in_standard_function8882_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0800000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_content_key_in_standard_function8882( FOLLOW_content_key_in_standard_function8882_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_null_key_in_standard_function8885_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x2000000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_null_key_in_standard_function8885( FOLLOW_null_key_in_standard_function8885_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_on_key_in_standard_function8887_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_on_key_in_standard_function8887( FOLLOW_on_key_in_standard_function8887_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_empty_key_in_standard_function8889_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_empty_key_in_standard_function8889( FOLLOW_empty_key_in_standard_function8889_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function8905_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function8905( FOLLOW_RIGHT_PAREN_in_standard_function8905_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function8920_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function8920( FOLLOW_PERIOD_in_standard_function8920_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function8922_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function8922( FOLLOW_general_element_part_in_standard_function8922_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlroot_key_in_standard_function8935_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlroot_key_in_standard_function8935( FOLLOW_xmlroot_key_in_standard_function8935_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function8949_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function8949( FOLLOW_LEFT_PAREN_in_standard_function8949_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function8967_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function8967( FOLLOW_concatenation_wrapper_in_standard_function8967_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlroot_param_version_part_in_standard_function8989_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlroot_param_version_part_in_standard_function8989( FOLLOW_xmlroot_param_version_part_in_standard_function8989_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function9012_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function9012( FOLLOW_COMMA_in_standard_function9012_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlroot_param_standalone_part_in_standard_function9014_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlroot_param_standalone_part_in_standard_function9014( FOLLOW_xmlroot_param_standalone_part_in_standard_function9014_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function9030_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function9030( FOLLOW_RIGHT_PAREN_in_standard_function9030_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function9045_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function9045( FOLLOW_PERIOD_in_standard_function9045_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function9047_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function9047( FOLLOW_general_element_part_in_standard_function9047_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlserialize_key_in_standard_function9060_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlserialize_key_in_standard_function9060( FOLLOW_xmlserialize_key_in_standard_function9060_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function9074_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function9074( FOLLOW_LEFT_PAREN_in_standard_function9074_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_document_key_in_standard_function9093_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_document_key_in_standard_function9093( FOLLOW_document_key_in_standard_function9093_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_content_key_in_standard_function9095_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_content_key_in_standard_function9095( FOLLOW_content_key_in_standard_function9095_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function9114_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000401400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function9114( FOLLOW_concatenation_wrapper_in_standard_function9114_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_standard_function9117_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000200000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_as_key_in_standard_function9117( FOLLOW_as_key_in_standard_function9117_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_standard_function9119_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_type_spec_in_standard_function9119( FOLLOW_type_spec_in_standard_function9119_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlserialize_param_enconding_part_in_standard_function9139_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlserialize_param_enconding_part_in_standard_function9139( FOLLOW_xmlserialize_param_enconding_part_in_standard_function9139_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlserialize_param_version_part_in_standard_function9158_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlserialize_param_version_part_in_standard_function9158( FOLLOW_xmlserialize_param_version_part_in_standard_function9158_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlserialize_param_ident_part_in_standard_function9177_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlserialize_param_ident_part_in_standard_function9177( FOLLOW_xmlserialize_param_ident_part_in_standard_function9177_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_hide_key_in_standard_function9198_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_hide_key_in_standard_function9198( FOLLOW_hide_key_in_standard_function9198_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_show_key_in_standard_function9200_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_show_key_in_standard_function9200( FOLLOW_show_key_in_standard_function9200_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_defaults_key_in_standard_function9203_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_defaults_key_in_standard_function9203( FOLLOW_defaults_key_in_standard_function9203_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function9219_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function9219( FOLLOW_RIGHT_PAREN_in_standard_function9219_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function9234_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function9234( FOLLOW_PERIOD_in_standard_function9234_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function9236_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function9236( FOLLOW_general_element_part_in_standard_function9236_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmltable_key_in_standard_function9249_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmltable_key_in_standard_function9249( FOLLOW_xmltable_key_in_standard_function9249_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_standard_function9263_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_standard_function9263( FOLLOW_LEFT_PAREN_in_standard_function9263_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_namespaces_clause_in_standard_function9281_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_namespaces_clause_in_standard_function9281( FOLLOW_xml_namespaces_clause_in_standard_function9281_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_standard_function9300_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_standard_function9300( FOLLOW_concatenation_wrapper_in_standard_function9300_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_passing_clause_in_standard_function9318_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_passing_clause_in_standard_function9318( FOLLOW_xml_passing_clause_in_standard_function9318_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_columns_key_in_standard_function9338_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_columns_key_in_standard_function9338( FOLLOW_columns_key_in_standard_function9338_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_table_column_in_standard_function9340_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_table_column_in_standard_function9340( FOLLOW_xml_table_column_in_standard_function9340_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_standard_function9343_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_standard_function9343( FOLLOW_COMMA_in_standard_function9343_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_table_column_in_standard_function9345_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_table_column_in_standard_function9345( FOLLOW_xml_table_column_in_standard_function9345_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_standard_function9362_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_standard_function9362( FOLLOW_RIGHT_PAREN_in_standard_function9362_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_standard_function9377_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_standard_function9377( FOLLOW_PERIOD_in_standard_function9377_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_part_in_standard_function9379_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_part_in_standard_function9379( FOLLOW_general_element_part_in_standard_function9379_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_stantard_function_enabling_over9404_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_stantard_function_enabling_over9404( FOLLOW_REGULAR_ID_in_stantard_function_enabling_over9404_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_stantard_function_enabling_using9427_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_stantard_function_enabling_using9427( FOLLOW_REGULAR_ID_in_stantard_function_enabling_using9427_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_stantard_function_enabling_within_or_over9450_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_stantard_function_enabling_within_or_over9450( FOLLOW_REGULAR_ID_in_stantard_function_enabling_within_or_over9450_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_REGULAR_ID_in_stantard_function_pedictions9473_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_REGULAR_ID_in_stantard_function_pedictions9473( FOLLOW_REGULAR_ID_in_stantard_function_pedictions9473_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_over_key_in_over_clause9493_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_over_key_in_over_clause9493( FOLLOW_over_key_in_over_clause9493_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_over_clause9503_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_over_clause9503( FOLLOW_LEFT_PAREN_in_over_clause9503_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_query_partition_clause_in_over_clause9517_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_query_partition_clause_in_over_clause9517( FOLLOW_query_partition_clause_in_over_clause9517_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_over_clause9533_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_by_clause_in_over_clause9533( FOLLOW_order_by_clause_in_over_clause9533_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_windowing_clause_in_over_clause9535_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_windowing_clause_in_over_clause9535( FOLLOW_windowing_clause_in_over_clause9535_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_over_clause9548_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_over_clause9548( FOLLOW_RIGHT_PAREN_in_over_clause9548_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_windowing_type_in_windowing_clause9568_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A8A240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_windowing_type_in_windowing_clause9568( FOLLOW_windowing_type_in_windowing_clause9568_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_between_key_in_windowing_clause9579_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A88240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_between_key_in_windowing_clause9579( FOLLOW_between_key_in_windowing_clause9579_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_windowing_elements_in_windowing_clause9581_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_windowing_elements_in_windowing_clause9581( FOLLOW_windowing_elements_in_windowing_clause9581_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_and_key_in_windowing_clause9583_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A88240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_and_key_in_windowing_clause9583( FOLLOW_and_key_in_windowing_clause9583_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_windowing_elements_in_windowing_clause9585_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_windowing_elements_in_windowing_clause9585( FOLLOW_windowing_elements_in_windowing_clause9585_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_windowing_elements_in_windowing_clause9596_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_windowing_elements_in_windowing_clause9596( FOLLOW_windowing_elements_in_windowing_clause9596_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_rows_key_in_windowing_type9621_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_rows_key_in_windowing_type9621( FOLLOW_rows_key_in_windowing_type9621_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_range_key_in_windowing_type9632_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_range_key_in_windowing_type9632( FOLLOW_range_key_in_windowing_type9632_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unbounded_key_in_windowing_elements9652_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unbounded_key_in_windowing_elements9652( FOLLOW_unbounded_key_in_windowing_elements9652_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_preceding_key_in_windowing_elements9654_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_preceding_key_in_windowing_elements9654( FOLLOW_preceding_key_in_windowing_elements9654_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_current_key_in_windowing_elements9665_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_current_key_in_windowing_elements9665( FOLLOW_current_key_in_windowing_elements9665_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_row_key_in_windowing_elements9667_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_row_key_in_windowing_elements9667( FOLLOW_row_key_in_windowing_elements9667_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_windowing_elements9678_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_windowing_elements9678( FOLLOW_concatenation_wrapper_in_windowing_elements9678_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_preceding_key_in_windowing_elements9681_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_preceding_key_in_windowing_elements9681( FOLLOW_preceding_key_in_windowing_elements9681_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_following_key_in_windowing_elements9683_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_following_key_in_windowing_elements9683( FOLLOW_following_key_in_windowing_elements9683_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_using_key_in_using_clause9704_bits[]	= { ANTLR_UINT64_LIT(0x00000086504472A0), ANTLR_UINT64_LIT(0x0C10184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_using_key_in_using_clause9704( FOLLOW_using_key_in_using_clause9704_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_using_clause9715_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_ASTERISK_in_using_clause9715( FOLLOW_ASTERISK_in_using_clause9715_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_using_element_in_using_clause9726_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_using_element_in_using_clause9726( FOLLOW_using_element_in_using_clause9726_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_using_clause9729_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C10184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_using_clause9729( FOLLOW_COMMA_in_using_clause9729_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_using_element_in_using_clause9731_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_using_element_in_using_clause9731( FOLLOW_using_element_in_using_clause9731_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_in_key_in_using_element9760_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_in_key_in_using_element9760( FOLLOW_in_key_in_using_element9760_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_out_key_in_using_element9762_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_out_key_in_using_element9762( FOLLOW_out_key_in_using_element9762_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_out_key_in_using_element9765_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_out_key_in_using_element9765( FOLLOW_out_key_in_using_element9765_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_list_elements_in_using_element9769_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_list_elements_in_using_element9769( FOLLOW_select_list_elements_in_using_element9769_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_using_element9771_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_alias_in_using_element9771( FOLLOW_column_alias_in_using_element9771_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_key_in_collect_order_by_part9792_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_key_in_collect_order_by_part9792( FOLLOW_order_key_in_collect_order_by_part9792_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_collect_order_by_part9794_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_collect_order_by_part9794( FOLLOW_by_key_in_collect_order_by_part9794_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_collect_order_by_part9796_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_collect_order_by_part9796( FOLLOW_concatenation_wrapper_in_collect_order_by_part9796_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_within_key_in_within_or_over_part9816_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0004000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_within_key_in_within_or_over_part9816( FOLLOW_within_key_in_within_or_over_part9816_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_key_in_within_or_over_part9818_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_key_in_within_or_over_part9818( FOLLOW_group_key_in_within_or_over_part9818_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_within_or_over_part9820_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000001) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_within_or_over_part9820( FOLLOW_LEFT_PAREN_in_within_or_over_part9820_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_by_clause_in_within_or_over_part9822_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_by_clause_in_within_or_over_part9822( FOLLOW_order_by_clause_in_within_or_over_part9822_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_within_or_over_part9824_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_within_or_over_part9824( FOLLOW_RIGHT_PAREN_in_within_or_over_part9824_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_over_clause_in_within_or_over_part9835_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_over_clause_in_within_or_over_part9835( FOLLOW_over_clause_in_within_or_over_part9835_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cost_key_in_cost_matrix_clause9855_bits[]	= { ANTLR_UINT64_LIT(0x0000020040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cost_key_in_cost_matrix_clause9855( FOLLOW_cost_key_in_cost_matrix_clause9855_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_model_key_in_cost_matrix_clause9866_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_model_key_in_cost_matrix_clause9866( FOLLOW_model_key_in_cost_matrix_clause9866_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_auto_key_in_cost_matrix_clause9868_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_auto_key_in_cost_matrix_clause9868( FOLLOW_auto_key_in_cost_matrix_clause9868_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_cost_matrix_clause9880_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_cost_matrix_clause9880( FOLLOW_LEFT_PAREN_in_cost_matrix_clause9880_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cost_class_name_in_cost_matrix_clause9882_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cost_class_name_in_cost_matrix_clause9882( FOLLOW_cost_class_name_in_cost_matrix_clause9882_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_cost_matrix_clause9885_bits[]	= { ANTLR_UINT64_LIT(0x0000000010040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_cost_matrix_clause9885( FOLLOW_COMMA_in_cost_matrix_clause9885_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cost_class_name_in_cost_matrix_clause9887_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cost_class_name_in_cost_matrix_clause9887( FOLLOW_cost_class_name_in_cost_matrix_clause9887_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_cost_matrix_clause9891_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000010000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_cost_matrix_clause9891( FOLLOW_RIGHT_PAREN_in_cost_matrix_clause9891_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_values_key_in_cost_matrix_clause9893_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_values_key_in_cost_matrix_clause9893( FOLLOW_values_key_in_cost_matrix_clause9893_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_list_in_cost_matrix_clause9908_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_list_in_cost_matrix_clause9908( FOLLOW_expression_list_in_cost_matrix_clause9908_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_passing_key_in_xml_passing_clause9934_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B0C240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_passing_key_in_xml_passing_clause9934( FOLLOW_passing_key_in_xml_passing_clause9934_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_xml_passing_clause9937_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_xml_passing_clause9937( FOLLOW_by_key_in_xml_passing_clause9937_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_value_key_in_xml_passing_clause9939_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_value_key_in_xml_passing_clause9939( FOLLOW_value_key_in_xml_passing_clause9939_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_xml_passing_clause9955_bits[]	= { ANTLR_UINT64_LIT(0x000000041004B000), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_xml_passing_clause9955( FOLLOW_expression_wrapper_in_xml_passing_clause9955_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_xml_passing_clause9957_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_alias_in_xml_passing_clause9957( FOLLOW_column_alias_in_xml_passing_clause9957_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_xml_passing_clause9961_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_xml_passing_clause9961( FOLLOW_COMMA_in_xml_passing_clause9961_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_xml_passing_clause9963_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043002), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_xml_passing_clause9963( FOLLOW_expression_wrapper_in_xml_passing_clause9963_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_xml_passing_clause9965_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_alias_in_xml_passing_clause9965( FOLLOW_column_alias_in_xml_passing_clause9965_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlattributes_key_in_xml_attributes_clause9987_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlattributes_key_in_xml_attributes_clause9987( FOLLOW_xmlattributes_key_in_xml_attributes_clause9987_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_xml_attributes_clause9997_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_xml_attributes_clause9997( FOLLOW_LEFT_PAREN_in_xml_attributes_clause9997_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_entityescaping_key_in_xml_attributes_clause10012_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_entityescaping_key_in_xml_attributes_clause10012( FOLLOW_entityescaping_key_in_xml_attributes_clause10012_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_noentityescaping_key_in_xml_attributes_clause10014_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_noentityescaping_key_in_xml_attributes_clause10014( FOLLOW_noentityescaping_key_in_xml_attributes_clause10014_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_schemacheck_key_in_xml_attributes_clause10031_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_schemacheck_key_in_xml_attributes_clause10031( FOLLOW_schemacheck_key_in_xml_attributes_clause10031_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_noschemacheck_key_in_xml_attributes_clause10033_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_noschemacheck_key_in_xml_attributes_clause10033( FOLLOW_noschemacheck_key_in_xml_attributes_clause10033_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause10049_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause10049( FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause10049_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_xml_attributes_clause10052_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_xml_attributes_clause10052( FOLLOW_COMMA_in_xml_attributes_clause10052_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause10054_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause10054( FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause10054_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_xml_attributes_clause10066_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_xml_attributes_clause10066( FOLLOW_RIGHT_PAREN_in_xml_attributes_clause10066_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xmlnamespaces_key_in_xml_namespaces_clause10086_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xmlnamespaces_key_in_xml_namespaces_clause10086( FOLLOW_xmlnamespaces_key_in_xml_namespaces_clause10086_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_xml_namespaces_clause10096_bits[]	= { ANTLR_UINT64_LIT(0x000000865044F220), ANTLR_UINT64_LIT(0x0800184A08241401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_xml_namespaces_clause10096( FOLLOW_LEFT_PAREN_in_xml_namespaces_clause10096_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xml_namespaces_clause10111_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043000), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xml_namespaces_clause10111( FOLLOW_concatenation_wrapper_in_xml_namespaces_clause10111_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_xml_namespaces_clause10113_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000800001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_alias_in_xml_namespaces_clause10113( FOLLOW_column_alias_in_xml_namespaces_clause10113_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_xml_namespaces_clause10134_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_xml_namespaces_clause10134( FOLLOW_COMMA_in_xml_namespaces_clause10134_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xml_namespaces_clause10136_bits[]	= { ANTLR_UINT64_LIT(0x0000000410043000), ANTLR_UINT64_LIT(0x0000000000400400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xml_namespaces_clause10136( FOLLOW_concatenation_wrapper_in_xml_namespaces_clause10136_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_column_alias_in_xml_namespaces_clause10138_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000), ANTLR_UINT64_LIT(0x0000000800001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_column_alias_in_xml_namespaces_clause10138( FOLLOW_column_alias_in_xml_namespaces_clause10138_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_general_default_part_in_xml_namespaces_clause10160_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000001000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_general_default_part_in_xml_namespaces_clause10160( FOLLOW_xml_general_default_part_in_xml_namespaces_clause10160_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_PAREN_in_xml_namespaces_clause10172_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_RIGHT_PAREN_in_xml_namespaces_clause10172( FOLLOW_RIGHT_PAREN_in_xml_namespaces_clause10172_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_column_name_in_xml_table_column10192_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000400200000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_column_name_in_xml_table_column10192( FOLLOW_xml_column_name_in_xml_table_column10192_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_for_key_in_xml_table_column10203_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_for_key_in_xml_table_column10203( FOLLOW_for_key_in_xml_table_column10203_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_ordinality_key_in_xml_table_column10205_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_ordinality_key_in_xml_table_column10205( FOLLOW_ordinality_key_in_xml_table_column10205_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_type_spec_in_xml_table_column10216_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000800000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_type_spec_in_xml_table_column10216( FOLLOW_type_spec_in_xml_table_column10216_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_path_key_in_xml_table_column10219_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_path_key_in_xml_table_column10219( FOLLOW_path_key_in_xml_table_column10219_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xml_table_column10221_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000800000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xml_table_column10221( FOLLOW_concatenation_wrapper_in_xml_table_column10221_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_xml_general_default_part_in_xml_table_column10231_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_xml_general_default_part_in_xml_table_column10231( FOLLOW_xml_general_default_part_in_xml_table_column10231_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_default_key_in_xml_general_default_part10259_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_default_key_in_xml_general_default_part10259( FOLLOW_default_key_in_xml_general_default_part10259_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xml_general_default_part10261_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xml_general_default_part10261( FOLLOW_concatenation_wrapper_in_xml_general_default_part10261_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_xml_multiuse_expression_element10281_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000400000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_in_xml_multiuse_expression_element10281( FOLLOW_expression_in_xml_multiuse_expression_element10281_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_as_key_in_xml_multiuse_expression_element10284_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_as_key_in_xml_multiuse_expression_element10284( FOLLOW_as_key_in_xml_multiuse_expression_element10284_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_id_expression_in_xml_multiuse_expression_element10287_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_id_expression_in_xml_multiuse_expression_element10287( FOLLOW_id_expression_in_xml_multiuse_expression_element10287_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_evalname_key_in_xml_multiuse_expression_element10290_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_evalname_key_in_xml_multiuse_expression_element10290( FOLLOW_evalname_key_in_xml_multiuse_expression_element10290_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_in_xml_multiuse_expression_element10292_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_in_xml_multiuse_expression_element10292( FOLLOW_concatenation_in_xml_multiuse_expression_element10292_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_version_key_in_xmlroot_param_version_part10316_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_version_key_in_xmlroot_param_version_part10316( FOLLOW_version_key_in_xmlroot_param_version_part10316_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_no_key_in_xmlroot_param_version_part10319_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_no_key_in_xmlroot_param_version_part10319( FOLLOW_no_key_in_xmlroot_param_version_part10319_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_value_key_in_xmlroot_param_version_part10321_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_value_key_in_xmlroot_param_version_part10321( FOLLOW_value_key_in_xmlroot_param_version_part10321_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_expression_wrapper_in_xmlroot_param_version_part10323_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_expression_wrapper_in_xmlroot_param_version_part10323( FOLLOW_expression_wrapper_in_xmlroot_param_version_part10323_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_standalone_key_in_xmlroot_param_standalone_part10344_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_standalone_key_in_xmlroot_param_standalone_part10344( FOLLOW_standalone_key_in_xmlroot_param_standalone_part10344_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_yes_key_in_xmlroot_param_standalone_part10347_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_yes_key_in_xmlroot_param_standalone_part10347( FOLLOW_yes_key_in_xmlroot_param_standalone_part10347_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_no_key_in_xmlroot_param_standalone_part10349_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_no_key_in_xmlroot_param_standalone_part10349( FOLLOW_no_key_in_xmlroot_param_standalone_part10349_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_value_key_in_xmlroot_param_standalone_part10351_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_value_key_in_xmlroot_param_standalone_part10351( FOLLOW_value_key_in_xmlroot_param_standalone_part10351_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_encoding_key_in_xmlserialize_param_enconding_part10373_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_encoding_key_in_xmlserialize_param_enconding_part10373( FOLLOW_encoding_key_in_xmlserialize_param_enconding_part10373_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xmlserialize_param_enconding_part10375_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xmlserialize_param_enconding_part10375( FOLLOW_concatenation_wrapper_in_xmlserialize_param_enconding_part10375_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_version_key_in_xmlserialize_param_version_part10395_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_version_key_in_xmlserialize_param_version_part10395( FOLLOW_version_key_in_xmlserialize_param_version_part10395_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xmlserialize_param_version_part10397_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xmlserialize_param_version_part10397( FOLLOW_concatenation_wrapper_in_xmlserialize_param_version_part10397_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_no_key_in_xmlserialize_param_ident_part10417_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_no_key_in_xmlserialize_param_ident_part10417( FOLLOW_no_key_in_xmlserialize_param_ident_part10417_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_indent_key_in_xmlserialize_param_ident_part10419_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_indent_key_in_xmlserialize_param_ident_part10419( FOLLOW_indent_key_in_xmlserialize_param_ident_part10419_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_indent_key_in_xmlserialize_param_ident_part10430_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000080) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_indent_key_in_xmlserialize_param_ident_part10430( FOLLOW_indent_key_in_xmlserialize_param_ident_part10430_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_size_key_in_xmlserialize_param_ident_part10433_bits[]	= { ANTLR_UINT64_LIT(0x0000000000200000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_size_key_in_xmlserialize_param_ident_part10433( FOLLOW_size_key_in_xmlserialize_param_ident_part10433_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_EQUALS_OP_in_xmlserialize_param_ident_part10435_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_EQUALS_OP_in_xmlserialize_param_ident_part10435( FOLLOW_EQUALS_OP_in_xmlserialize_param_ident_part10435_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_concatenation_wrapper_in_xmlserialize_param_ident_part10437_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_concatenation_wrapper_in_xmlserialize_param_ident_part10437( FOLLOW_concatenation_wrapper_in_xmlserialize_param_ident_part10437_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_order_key_in_synpred1_PLSQL_DMLParser357_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_order_key_in_synpred1_PLSQL_DMLParser357( FOLLOW_order_key_in_synpred1_PLSQL_DMLParser357_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_siblings_key_in_synpred1_PLSQL_DMLParser359_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000004000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_siblings_key_in_synpred1_PLSQL_DMLParser359( FOLLOW_siblings_key_in_synpred1_PLSQL_DMLParser359_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_by_key_in_synpred1_PLSQL_DMLParser362_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_by_key_in_synpred1_PLSQL_DMLParser362( FOLLOW_by_key_in_synpred1_PLSQL_DMLParser362_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_distinct_key_in_synpred2_PLSQL_DMLParser763_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_distinct_key_in_synpred2_PLSQL_DMLParser763( FOLLOW_distinct_key_in_synpred2_PLSQL_DMLParser763_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unique_key_in_synpred2_PLSQL_DMLParser765_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unique_key_in_synpred2_PLSQL_DMLParser765( FOLLOW_unique_key_in_synpred2_PLSQL_DMLParser765_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_synpred2_PLSQL_DMLParser767_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_synpred2_PLSQL_DMLParser767( FOLLOW_all_key_in_synpred2_PLSQL_DMLParser767_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_tableview_name_in_synpred3_PLSQL_DMLParser936_bits[]	= { ANTLR_UINT64_LIT(0x0000004000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_tableview_name_in_synpred3_PLSQL_DMLParser936( FOLLOW_tableview_name_in_synpred3_PLSQL_DMLParser936_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_PERIOD_in_synpred3_PLSQL_DMLParser938_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_PERIOD_in_synpred3_PLSQL_DMLParser938( FOLLOW_PERIOD_in_synpred3_PLSQL_DMLParser938_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_ASTERISK_in_synpred3_PLSQL_DMLParser940_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_ASTERISK_in_synpred3_PLSQL_DMLParser940( FOLLOW_ASTERISK_in_synpred3_PLSQL_DMLParser940_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred4_PLSQL_DMLParser1047_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred4_PLSQL_DMLParser1047( FOLLOW_LEFT_PAREN_in_synpred4_PLSQL_DMLParser1047_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred4_PLSQL_DMLParser1050_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred4_PLSQL_DMLParser1050( FOLLOW_select_key_in_synpred4_PLSQL_DMLParser1050_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred4_PLSQL_DMLParser1052_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_synpred4_PLSQL_DMLParser1052( FOLLOW_with_key_in_synpred4_PLSQL_DMLParser1052_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred5_PLSQL_DMLParser1077_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred5_PLSQL_DMLParser1077( FOLLOW_LEFT_PAREN_in_synpred5_PLSQL_DMLParser1077_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_only_key_in_synpred6_PLSQL_DMLParser1108_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_only_key_in_synpred6_PLSQL_DMLParser1108( FOLLOW_only_key_in_synpred6_PLSQL_DMLParser1108_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred6_PLSQL_DMLParser1110_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred6_PLSQL_DMLParser1110( FOLLOW_LEFT_PAREN_in_synpred6_PLSQL_DMLParser1110_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred7_PLSQL_DMLParser1424_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred7_PLSQL_DMLParser1424( FOLLOW_LEFT_PAREN_in_synpred7_PLSQL_DMLParser1424_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred7_PLSQL_DMLParser1427_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred7_PLSQL_DMLParser1427( FOLLOW_select_key_in_synpred7_PLSQL_DMLParser1427_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred7_PLSQL_DMLParser1429_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_synpred7_PLSQL_DMLParser1429( FOLLOW_with_key_in_synpred7_PLSQL_DMLParser1429_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred8_PLSQL_DMLParser1451_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred8_PLSQL_DMLParser1451( FOLLOW_LEFT_PAREN_in_synpred8_PLSQL_DMLParser1451_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred9_PLSQL_DMLParser1765_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred9_PLSQL_DMLParser1765( FOLLOW_select_key_in_synpred9_PLSQL_DMLParser1765_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_any_key_in_synpred10_PLSQL_DMLParser1790_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_any_key_in_synpred10_PLSQL_DMLParser1790( FOLLOW_any_key_in_synpred10_PLSQL_DMLParser1790_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred11_PLSQL_DMLParser1906_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred11_PLSQL_DMLParser1906( FOLLOW_LEFT_PAREN_in_synpred11_PLSQL_DMLParser1906_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred12_PLSQL_DMLParser2231_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred12_PLSQL_DMLParser2231( FOLLOW_LEFT_PAREN_in_synpred12_PLSQL_DMLParser2231_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_key_in_synpred13_PLSQL_DMLParser2362_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_key_in_synpred13_PLSQL_DMLParser2362( FOLLOW_group_key_in_synpred13_PLSQL_DMLParser2362_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_synpred14_PLSQL_DMLParser2387_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_synpred14_PLSQL_DMLParser2387( FOLLOW_COMMA_in_synpred14_PLSQL_DMLParser2387_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_by_elements_in_synpred14_PLSQL_DMLParser2389_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_by_elements_in_synpred14_PLSQL_DMLParser2389( FOLLOW_group_by_elements_in_synpred14_PLSQL_DMLParser2389_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_having_key_in_synpred15_PLSQL_DMLParser2423_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_having_key_in_synpred15_PLSQL_DMLParser2423( FOLLOW_having_key_in_synpred15_PLSQL_DMLParser2423_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_synpred16_PLSQL_DMLParser2463_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0C00184B08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_COMMA_in_synpred16_PLSQL_DMLParser2463( FOLLOW_COMMA_in_synpred16_PLSQL_DMLParser2463_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_group_by_elements_in_synpred16_PLSQL_DMLParser2465_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_group_by_elements_in_synpred16_PLSQL_DMLParser2465( FOLLOW_group_by_elements_in_synpred16_PLSQL_DMLParser2465_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_rollup_key_in_synpred17_PLSQL_DMLParser2621_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_rollup_key_in_synpred17_PLSQL_DMLParser2621( FOLLOW_rollup_key_in_synpred17_PLSQL_DMLParser2621_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cube_key_in_synpred17_PLSQL_DMLParser2623_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cube_key_in_synpred17_PLSQL_DMLParser2623( FOLLOW_cube_key_in_synpred17_PLSQL_DMLParser2623_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred18_PLSQL_DMLParser2639_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred18_PLSQL_DMLParser2639( FOLLOW_LEFT_PAREN_in_synpred18_PLSQL_DMLParser2639_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_synpred19_PLSQL_DMLParser3097_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_synpred19_PLSQL_DMLParser3097( FOLLOW_all_key_in_synpred19_PLSQL_DMLParser3097_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_synpred20_PLSQL_DMLParser4048_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_when_key_in_synpred20_PLSQL_DMLParser4048( FOLLOW_when_key_in_synpred20_PLSQL_DMLParser4048_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_matched_key_in_synpred20_PLSQL_DMLParser4050_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_matched_key_in_synpred20_PLSQL_DMLParser4050( FOLLOW_matched_key_in_synpred20_PLSQL_DMLParser4050_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_synpred21_PLSQL_DMLParser4083_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0400000000000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_when_key_in_synpred21_PLSQL_DMLParser4083( FOLLOW_when_key_in_synpred21_PLSQL_DMLParser4083_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_not_key_in_synpred21_PLSQL_DMLParser4085_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000400) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_not_key_in_synpred21_PLSQL_DMLParser4085( FOLLOW_not_key_in_synpred21_PLSQL_DMLParser4085_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_matched_key_in_synpred21_PLSQL_DMLParser4087_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_matched_key_in_synpred21_PLSQL_DMLParser4087( FOLLOW_matched_key_in_synpred21_PLSQL_DMLParser4087_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred22_PLSQL_DMLParser4676_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred22_PLSQL_DMLParser4676( FOLLOW_LEFT_PAREN_in_synpred22_PLSQL_DMLParser4676_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unlimited_key_in_synpred23_PLSQL_DMLParser4741_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unlimited_key_in_synpred23_PLSQL_DMLParser4741( FOLLOW_unlimited_key_in_synpred23_PLSQL_DMLParser4741_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred24_PLSQL_DMLParser4840_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred24_PLSQL_DMLParser4840( FOLLOW_LEFT_PAREN_in_synpred24_PLSQL_DMLParser4840_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred24_PLSQL_DMLParser4843_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred24_PLSQL_DMLParser4843( FOLLOW_select_key_in_synpred24_PLSQL_DMLParser4843_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred24_PLSQL_DMLParser4847_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_synpred24_PLSQL_DMLParser4847( FOLLOW_with_key_in_synpred24_PLSQL_DMLParser4847_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_cursor_key_in_synpred25_PLSQL_DMLParser5150_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_cursor_key_in_synpred25_PLSQL_DMLParser5150( FOLLOW_cursor_key_in_synpred25_PLSQL_DMLParser5150_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred25_PLSQL_DMLParser5152_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred25_PLSQL_DMLParser5152( FOLLOW_LEFT_PAREN_in_synpred25_PLSQL_DMLParser5152_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred25_PLSQL_DMLParser5155_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred25_PLSQL_DMLParser5155( FOLLOW_select_key_in_synpred25_PLSQL_DMLParser5155_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred25_PLSQL_DMLParser5157_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_synpred25_PLSQL_DMLParser5157( FOLLOW_with_key_in_synpred25_PLSQL_DMLParser5157_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred26_PLSQL_DMLParser5767_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred26_PLSQL_DMLParser5767( FOLLOW_LEFT_PAREN_in_synpred26_PLSQL_DMLParser5767_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred26_PLSQL_DMLParser5771_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred26_PLSQL_DMLParser5771( FOLLOW_select_key_in_synpred26_PLSQL_DMLParser5771_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred26_PLSQL_DMLParser5773_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_synpred26_PLSQL_DMLParser5773( FOLLOW_with_key_in_synpred26_PLSQL_DMLParser5773_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_interval_expression_in_synpred27_PLSQL_DMLParser6034_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_interval_expression_in_synpred27_PLSQL_DMLParser6034( FOLLOW_interval_expression_in_synpred27_PLSQL_DMLParser6034_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_any_key_in_synpred28_PLSQL_DMLParser6173_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_any_key_in_synpred28_PLSQL_DMLParser6173( FOLLOW_any_key_in_synpred28_PLSQL_DMLParser6173_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_any_key_in_synpred29_PLSQL_DMLParser6187_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_any_key_in_synpred29_PLSQL_DMLParser6187( FOLLOW_any_key_in_synpred29_PLSQL_DMLParser6187_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred30_PLSQL_DMLParser6432_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred30_PLSQL_DMLParser6432( FOLLOW_select_key_in_synpred30_PLSQL_DMLParser6432_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred31_PLSQL_DMLParser6456_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred31_PLSQL_DMLParser6456( FOLLOW_LEFT_PAREN_in_synpred31_PLSQL_DMLParser6456_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_new_key_in_synpred36_PLSQL_DMLParser6602_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_new_key_in_synpred36_PLSQL_DMLParser6602( FOLLOW_new_key_in_synpred36_PLSQL_DMLParser6602_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_synpred36_PLSQL_DMLParser6604_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_synpred36_PLSQL_DMLParser6604( FOLLOW_unary_expression_in_synpred36_PLSQL_DMLParser6604_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_all_key_in_synpred38_PLSQL_DMLParser6628_bits[]	= { ANTLR_UINT64_LIT(0x0000008650447220), ANTLR_UINT64_LIT(0x0800184A08240401), ANTLR_UINT64_LIT(0x0000000000801004) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_all_key_in_synpred38_PLSQL_DMLParser6628( FOLLOW_all_key_in_synpred38_PLSQL_DMLParser6628_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_unary_expression_in_synpred38_PLSQL_DMLParser6630_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_unary_expression_in_synpred38_PLSQL_DMLParser6630( FOLLOW_unary_expression_in_synpred38_PLSQL_DMLParser6630_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_case_statement_in_synpred39_PLSQL_DMLParser6643_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_case_statement_in_synpred39_PLSQL_DMLParser6643( FOLLOW_case_statement_in_synpred39_PLSQL_DMLParser6643_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_quantified_expression_in_synpred40_PLSQL_DMLParser6655_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_quantified_expression_in_synpred40_PLSQL_DMLParser6655( FOLLOW_quantified_expression_in_synpred40_PLSQL_DMLParser6655_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_standard_function_in_synpred41_PLSQL_DMLParser6666_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_standard_function_in_synpred41_PLSQL_DMLParser6666( FOLLOW_standard_function_in_synpred41_PLSQL_DMLParser6666_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_label_name_in_synpred42_PLSQL_DMLParser6715_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000008000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_label_name_in_synpred42_PLSQL_DMLParser6715( FOLLOW_label_name_in_synpred42_PLSQL_DMLParser6715_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_case_key_in_synpred42_PLSQL_DMLParser6718_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000040000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_case_key_in_synpred42_PLSQL_DMLParser6718( FOLLOW_case_key_in_synpred42_PLSQL_DMLParser6718_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_when_key_in_synpred42_PLSQL_DMLParser6720_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_when_key_in_synpred42_PLSQL_DMLParser6720( FOLLOW_when_key_in_synpred42_PLSQL_DMLParser6720_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_table_element_in_synpred43_PLSQL_DMLParser6995_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_table_element_in_synpred43_PLSQL_DMLParser6995( FOLLOW_table_element_in_synpred43_PLSQL_DMLParser6995_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_outer_join_sign_in_synpred43_PLSQL_DMLParser6997_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_outer_join_sign_in_synpred43_PLSQL_DMLParser6997( FOLLOW_outer_join_sign_in_synpred43_PLSQL_DMLParser6997_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_constant_in_synpred45_PLSQL_DMLParser7026_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_constant_in_synpred45_PLSQL_DMLParser7026( FOLLOW_constant_in_synpred45_PLSQL_DMLParser7026_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_general_element_in_synpred46_PLSQL_DMLParser7037_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_general_element_in_synpred46_PLSQL_DMLParser7037( FOLLOW_general_element_in_synpred46_PLSQL_DMLParser7037_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred47_PLSQL_DMLParser7077_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred47_PLSQL_DMLParser7077( FOLLOW_select_key_in_synpred47_PLSQL_DMLParser7077_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred47_PLSQL_DMLParser7081_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_synpred47_PLSQL_DMLParser7081( FOLLOW_with_key_in_synpred47_PLSQL_DMLParser7081_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred48_PLSQL_DMLParser7225_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred48_PLSQL_DMLParser7225( FOLLOW_LEFT_PAREN_in_synpred48_PLSQL_DMLParser7225_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred48_PLSQL_DMLParser7228_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred48_PLSQL_DMLParser7228( FOLLOW_select_key_in_synpred48_PLSQL_DMLParser7228_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred48_PLSQL_DMLParser7230_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_synpred48_PLSQL_DMLParser7230( FOLLOW_with_key_in_synpred48_PLSQL_DMLParser7230_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_multiset_key_in_synpred49_PLSQL_DMLParser7432_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_multiset_key_in_synpred49_PLSQL_DMLParser7432( FOLLOW_multiset_key_in_synpred49_PLSQL_DMLParser7432_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_PAREN_in_synpred49_PLSQL_DMLParser7434_bits[]	= { ANTLR_UINT64_LIT(0x0000000040000000), ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000100040) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_LEFT_PAREN_in_synpred49_PLSQL_DMLParser7434( FOLLOW_LEFT_PAREN_in_synpred49_PLSQL_DMLParser7434_bits, 3 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_select_key_in_synpred49_PLSQL_DMLParser7438_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_select_key_in_synpred49_PLSQL_DMLParser7438( FOLLOW_select_key_in_synpred49_PLSQL_DMLParser7438_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_with_key_in_synpred49_PLSQL_DMLParser7440_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_with_key_in_synpred49_PLSQL_DMLParser7440( FOLLOW_with_key_in_synpred49_PLSQL_DMLParser7440_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_default_key_in_synpred50_PLSQL_DMLParser10156_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_default_key_in_synpred50_PLSQL_DMLParser10156( FOLLOW_default_key_in_synpred50_PLSQL_DMLParser10156_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: PLSQLParser_PLSQL_DMLParser  */
static	ANTLR_BITWORD FOLLOW_default_key_in_synpred51_PLSQL_DMLParser10227_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  PLSQLParser_PLSQL_DMLParserImplTraits::BitsetListType FOLLOW_default_key_in_synpred51_PLSQL_DMLParser10227( FOLLOW_default_key_in_synpred51_PLSQL_DMLParser10227_bits, 1 );



/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    85:70: ( nulls_key last_key )?
 */
static const ANTLR_INT32 dfa18_eot[34] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa18_eof[34] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa18_min[34] =
    {
	15, 18, -1, 15, -1, 18, 18, 18, 15, 18, 15, 18, -1, 18, 18, 18, 18, 18, 
	18, 15, 18, 15, 18, 15, 18, 18, 18, 18, 18, 18, 15, 18, 18, 18
    };
static const ANTLR_INT32 dfa18_max[34] =
    {
	74, 74, -1, 134, -1, 74, 74, 74, 101, 74, 134, 74, -1, 74, 74, 74, 74, 
	74, 74, 134, 74, 139, 74, 86, 74, 74, 74, 74, 74, 74, 139, 74, 74, 74
    };
static const ANTLR_INT32 dfa18_accept[34] =
    {
	-1, -1, 2, -1, 2, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa18_special[34] =
    {
	25, 24, -1, 15, -1, 23, 21, 4, 16, 3, 26, 9, -1, 10, 22, 17, 0, 13, 14, 
	18, 5, 1, 6, 2, 30, 29, 8, 20, 7, 12, 19, 11, 28, 27
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa18_T_empty	 =   NULL;

static const ANTLR_INT32 dfa18_T0[] =
    {
	23, -1, -1, -1, -1, -1, -1, -1, -1, -1, 22, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 23
    };

static const ANTLR_INT32 dfa18_T1[] =
    {
	12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa18_T2[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, -1, -1, 
	-1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12
    };

static const ANTLR_INT32 dfa18_T3[] =
    {
	13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 13
    };

static const ANTLR_INT32 dfa18_T4[] =
    {
	11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 11
    };

static const ANTLR_INT32 dfa18_T5[] =
    {
	26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 26
    };

static const ANTLR_INT32 dfa18_T6[] =
    {
	28, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 28
    };

static const ANTLR_INT32 dfa18_T7[] =
    {
	23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 23
    };

static const ANTLR_INT32 dfa18_T8[] =
    {
	21, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 21
    };

static const ANTLR_INT32 dfa18_T9[] =
    {
	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 8
    };

static const ANTLR_INT32 dfa18_T10[] =
    {
	10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 10
    };

static const ANTLR_INT32 dfa18_T11[] =
    {
	33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 33
    };

static const ANTLR_INT32 dfa18_T12[] =
    {
	32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 32
    };

static const ANTLR_INT32 dfa18_T13[] =
    {
	24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 24
    };

static const ANTLR_INT32 dfa18_T14[] =
    {
	25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 25
    };

static const ANTLR_INT32 dfa18_T15[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, 
	-1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa18_T16[] =
    {
	12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, 
	-1, -1, -1, -1, -1, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 
	12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12
    };

static const ANTLR_INT32 dfa18_T17[] =
    {
	21, -1, -1, -1, -1, -1, -1, -1, -1, -1, 20, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 21
    };

static const ANTLR_INT32 dfa18_T18[] =
    {
	16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, -1, -1, 
	-1, -1, -1, -1, -1, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12
    };

static const ANTLR_INT32 dfa18_T19[] =
    {
	30, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 30
    };

static const ANTLR_INT32 dfa18_T20[] =
    {
	10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 10
    };

static const ANTLR_INT32 dfa18_T21[] =
    {
	19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 19
    };

static const ANTLR_INT32 dfa18_T22[] =
    {
	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 8
    };

static const ANTLR_INT32 dfa18_T23[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 3
    };

static const ANTLR_INT32 dfa18_T24[] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa18_transitions[] =
{
    dfa18_T24, dfa18_T23, NULL, dfa18_T15, NULL, dfa18_T22, dfa18_T20, dfa18_T4, 
    dfa18_T16, dfa18_T3, dfa18_T18, dfa18_T9, NULL, dfa18_T10, dfa18_T21, 
    dfa18_T17, dfa18_T0, dfa18_T13, dfa18_T14, dfa18_T18, dfa18_T5, dfa18_T1, 
    dfa18_T6, dfa18_T2, dfa18_T9, dfa18_T10, dfa18_T8, dfa18_T19, dfa18_T7, 
    dfa18_T12, dfa18_T1, dfa18_T11, dfa18_T8, dfa18_T7
};


/* Declare tracking structure for Cyclic DFA 18
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA18 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA18( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA18_16;

	    		    ANTLR_MARKER index18_16;


	    		    LA18_16 = ctx->LA(1);

	    		     
	    		        index18_16 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_16 == INTRODUCER) )
	    		    {
	    		        s = 22;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_16 == DELIMITED_ID || LA18_16 == REGULAR_ID) )
	    		    {
	    		        s = 23;
	    		    }

	    			 
	    				ctx->seek(index18_16);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA18_21;

	    		    ANTLR_MARKER index18_21;


	    		    LA18_21 = ctx->LA(1);

	    		     
	    		        index18_21 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_21 == PERIOD) )
	    		    {
	    		        s = 27;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) && (LA18_21 == COMMA || LA18_21 == REGULAR_ID) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SET"))) && (LA18_21 == SQL92_RESERVED_TO) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_21);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA18_23;

	    		    ANTLR_MARKER index18_23;


	    		    LA18_23 = ctx->LA(1);

	    		     
	    		        index18_23 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) && (LA18_23 == LEFT_PAREN || LA18_23 == SQL92_RESERVED_AS) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SET"))) && (LA18_23 == COMMA || LA18_23 == PERIOD || LA18_23 == REGULAR_ID) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_23);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA18_9;

	    		    ANTLR_MARKER index18_9;


	    		    LA18_9 = ctx->LA(1);

	    		     
	    		        index18_9 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_9 == DELIMITED_ID || LA18_9 == REGULAR_ID) )
	    		    {
	    		        s = 13;
	    		    }

	    			 
	    				ctx->seek(index18_9);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA18_7;

	    		    ANTLR_MARKER index18_7;


	    		    LA18_7 = ctx->LA(1);

	    		     
	    		        index18_7 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_7 == DELIMITED_ID || LA18_7 == REGULAR_ID) )
	    		    {
	    		        s = 11;
	    		    }

	    			 
	    				ctx->seek(index18_7);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA18_20;

	    		    ANTLR_MARKER index18_20;


	    		    LA18_20 = ctx->LA(1);

	    		     
	    		        index18_20 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_20 == DELIMITED_ID || LA18_20 == REGULAR_ID) )
	    		    {
	    		        s = 26;
	    		    }

	    			 
	    				ctx->seek(index18_20);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA18_22;

	    		    ANTLR_MARKER index18_22;


	    		    LA18_22 = ctx->LA(1);

	    		     
	    		        index18_22 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_22 == DELIMITED_ID || LA18_22 == REGULAR_ID) )
	    		    {
	    		        s = 28;
	    		    }

	    			 
	    				ctx->seek(index18_22);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 7:

	    		{
	    		    ANTLR_UINT32 LA18_28;

	    		    ANTLR_MARKER index18_28;


	    		    LA18_28 = ctx->LA(1);

	    		     
	    		        index18_28 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_28 == PERIOD) )
	    		    {
	    		        s = 31;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_28 == DELIMITED_ID || LA18_28 == REGULAR_ID) )
	    		    {
	    		        s = 23;
	    		    }

	    			 
	    				ctx->seek(index18_28);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 8:

	    		{
	    		    ANTLR_UINT32 LA18_26;

	    		    ANTLR_MARKER index18_26;


	    		    LA18_26 = ctx->LA(1);

	    		     
	    		        index18_26 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_26 == PERIOD) )
	    		    {
	    		        s = 29;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_26 == DELIMITED_ID || LA18_26 == REGULAR_ID) )
	    		    {
	    		        s = 21;
	    		    }

	    			 
	    				ctx->seek(index18_26);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 9:

	    		{
	    		    ANTLR_UINT32 LA18_11;

	    		    ANTLR_MARKER index18_11;


	    		    LA18_11 = ctx->LA(1);

	    		     
	    		        index18_11 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_11 == PERIOD) )
	    		    {
	    		        s = 17;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_11 == DELIMITED_ID || LA18_11 == REGULAR_ID) )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index18_11);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 10:

	    		{
	    		    ANTLR_UINT32 LA18_13;

	    		    ANTLR_MARKER index18_13;


	    		    LA18_13 = ctx->LA(1);

	    		     
	    		        index18_13 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_13 == PERIOD) )
	    		    {
	    		        s = 18;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_13 == DELIMITED_ID || LA18_13 == REGULAR_ID) )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index18_13);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 11:

	    		{
	    		    ANTLR_UINT32 LA18_31;

	    		    ANTLR_MARKER index18_31;


	    		    LA18_31 = ctx->LA(1);

	    		     
	    		        index18_31 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_31 == DELIMITED_ID || LA18_31 == REGULAR_ID) )
	    		    {
	    		        s = 33;
	    		    }

	    			 
	    				ctx->seek(index18_31);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 12:

	    		{
	    		    ANTLR_UINT32 LA18_29;

	    		    ANTLR_MARKER index18_29;


	    		    LA18_29 = ctx->LA(1);

	    		     
	    		        index18_29 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_29 == DELIMITED_ID || LA18_29 == REGULAR_ID) )
	    		    {
	    		        s = 32;
	    		    }

	    			 
	    				ctx->seek(index18_29);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 13:

	    		{
	    		    ANTLR_UINT32 LA18_17;

	    		    ANTLR_MARKER index18_17;


	    		    LA18_17 = ctx->LA(1);

	    		     
	    		        index18_17 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_17 == DELIMITED_ID || LA18_17 == REGULAR_ID) )
	    		    {
	    		        s = 24;
	    		    }

	    			 
	    				ctx->seek(index18_17);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 14:

	    		{
	    		    ANTLR_UINT32 LA18_18;

	    		    ANTLR_MARKER index18_18;


	    		    LA18_18 = ctx->LA(1);

	    		     
	    		        index18_18 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_18 == DELIMITED_ID || LA18_18 == REGULAR_ID) )
	    		    {
	    		        s = 25;
	    		    }

	    			 
	    				ctx->seek(index18_18);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 15:

	    		{
	    		    ANTLR_UINT32 LA18_3;

	    		    ANTLR_MARKER index18_3;


	    		    LA18_3 = ctx->LA(1);

	    		     
	    		        index18_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_3 == COMMA) )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_3 == REGULAR_ID) )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SET"))) && (LA18_3 == LEFT_PAREN || LA18_3 == PERIOD || LA18_3 == SQL92_RESERVED_SELECT) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 16:

	    		{
	    		    ANTLR_UINT32 LA18_8;

	    		    ANTLR_MARKER index18_8;


	    		    LA18_8 = ctx->LA(1);

	    		     
	    		        index18_8 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) && (LA18_8 == COMMA || LA18_8 == PERIOD || LA18_8 == REGULAR_ID || LA18_8 == SQL92_RESERVED_ASC || LA18_8 == SQL92_RESERVED_DESC) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SET"))) && (LA18_8 == LEFT_PAREN || LA18_8 == SQL92_RESERVED_AS) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_8);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 17:

	    		{
	    		    ANTLR_UINT32 LA18_15;

	    		    ANTLR_MARKER index18_15;


	    		    LA18_15 = ctx->LA(1);

	    		     
	    		        index18_15 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_15 == INTRODUCER) )
	    		    {
	    		        s = 20;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_15 == DELIMITED_ID || LA18_15 == REGULAR_ID) )
	    		    {
	    		        s = 21;
	    		    }

	    			 
	    				ctx->seek(index18_15);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 18:

	    		{
	    		    ANTLR_UINT32 LA18_19;

	    		    ANTLR_MARKER index18_19;


	    		    LA18_19 = ctx->LA(1);

	    		     
	    		        index18_19 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_19 == REGULAR_ID) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_19 == COMMA) )
	    		    {
	    		        s = 16;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) && (LA18_19 == LEFT_PAREN || LA18_19 == SQL92_RESERVED_SELECT) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_19 == PERIOD) )
	    		    {
	    		        s = 14;
	    		    }

	    			 
	    				ctx->seek(index18_19);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 19:

	    		{
	    		    ANTLR_UINT32 LA18_30;

	    		    ANTLR_MARKER index18_30;


	    		    LA18_30 = ctx->LA(1);

	    		     
	    		        index18_30 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) && (LA18_30 == COMMA || LA18_30 == REGULAR_ID) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_30 == PERIOD) )
	    		    {
	    		        s = 27;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SET"))) && (LA18_30 == SQL92_RESERVED_TO) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_30);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 20:

	    		{
	    		    ANTLR_UINT32 LA18_27;

	    		    ANTLR_MARKER index18_27;


	    		    LA18_27 = ctx->LA(1);

	    		     
	    		        index18_27 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_27 == DELIMITED_ID || LA18_27 == REGULAR_ID) )
	    		    {
	    		        s = 30;
	    		    }

	    			 
	    				ctx->seek(index18_27);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 21:

	    		{
	    		    ANTLR_UINT32 LA18_6;

	    		    ANTLR_MARKER index18_6;


	    		    LA18_6 = ctx->LA(1);

	    		     
	    		        index18_6 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_6 == INTRODUCER) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_6 == DELIMITED_ID || LA18_6 == REGULAR_ID) )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index18_6);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 22:

	    		{
	    		    ANTLR_UINT32 LA18_14;

	    		    ANTLR_MARKER index18_14;


	    		    LA18_14 = ctx->LA(1);

	    		     
	    		        index18_14 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_14 == DELIMITED_ID || LA18_14 == REGULAR_ID) )
	    		    {
	    		        s = 19;
	    		    }

	    			 
	    				ctx->seek(index18_14);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 23:

	    		{
	    		    ANTLR_UINT32 LA18_5;

	    		    ANTLR_MARKER index18_5;


	    		    LA18_5 = ctx->LA(1);

	    		     
	    		        index18_5 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_5 == INTRODUCER) )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_5 == DELIMITED_ID || LA18_5 == REGULAR_ID) )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index18_5);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 24:

	    		{
	    		    ANTLR_UINT32 LA18_1;

	    		    ANTLR_MARKER index18_1;


	    		    LA18_1 = ctx->LA(1);

	    		     
	    		        index18_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_1 == REGULAR_ID) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SET"))) && (LA18_1 == DELIMITED_ID || LA18_1 == INTRODUCER) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index18_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 25:

	    		{
	    		    ANTLR_UINT32 LA18_0;

	    		    ANTLR_MARKER index18_0;


	    		    LA18_0 = ctx->LA(1);

	    		     
	    		        index18_0 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_0 == REGULAR_ID) )
	    		    {
	    		        s = 1;
	    		    }

	    		    else if ( (LA18_0 == COMMA) )
	    		    {
	    		        s = 2;
	    		    }

	    			 
	    				ctx->seek(index18_0);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 26:

	    		{
	    		    ANTLR_UINT32 LA18_10;

	    		    ANTLR_MARKER index18_10;


	    		    LA18_10 = ctx->LA(1);

	    		     
	    		        index18_10 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_10 == PERIOD) )
	    		    {
	    		        s = 14;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_10 == REGULAR_ID) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_10 == COMMA) )
	    		    {
	    		        s = 16;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) && (LA18_10 == LEFT_PAREN || LA18_10 == SQL92_RESERVED_SELECT) )
	    		    {
	    		        s = 12;
	    		    }

	    			 
	    				ctx->seek(index18_10);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 27:

	    		{
	    		    ANTLR_UINT32 LA18_33;

	    		    ANTLR_MARKER index18_33;


	    		    LA18_33 = ctx->LA(1);

	    		     
	    		        index18_33 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_33 == DELIMITED_ID || LA18_33 == REGULAR_ID) )
	    		    {
	    		        s = 23;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_33 == PERIOD) )
	    		    {
	    		        s = 31;
	    		    }

	    			 
	    				ctx->seek(index18_33);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 28:

	    		{
	    		    ANTLR_UINT32 LA18_32;

	    		    ANTLR_MARKER index18_32;


	    		    LA18_32 = ctx->LA(1);

	    		     
	    		        index18_32 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_32 == DELIMITED_ID || LA18_32 == REGULAR_ID) )
	    		    {
	    		        s = 21;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_32 == PERIOD) )
	    		    {
	    		        s = 29;
	    		    }

	    			 
	    				ctx->seek(index18_32);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 29:

	    		{
	    		    ANTLR_UINT32 LA18_25;

	    		    ANTLR_MARKER index18_25;


	    		    LA18_25 = ctx->LA(1);

	    		     
	    		        index18_25 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_25 == DELIMITED_ID || LA18_25 == REGULAR_ID) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_25 == PERIOD) )
	    		    {
	    		        s = 18;
	    		    }

	    			 
	    				ctx->seek(index18_25);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 30:

	    		{
	    		    ANTLR_UINT32 LA18_24;

	    		    ANTLR_MARKER index18_24;


	    		    LA18_24 = ctx->LA(1);

	    		     
	    		        index18_24 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_24 == DELIMITED_ID || LA18_24 == REGULAR_ID) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA18_24 == PERIOD) )
	    		    {
	    		        s = 17;
	    		    }

	    			 
	    				ctx->seek(index18_24);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "85:70: ( nulls_key last_key )?" );
	    ex->set_decisionNum( 18 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParser_PLSQL_DMLParserCyclicDFA18  cdfa18(
	    18,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"85:70: ( nulls_key last_key )?",
	    dfa18_eot,	    /* EOT table			    */
	    dfa18_eof,	    /* EOF table			    */
	    dfa18_min,	    /* Minimum tokens for each state    */
	    dfa18_max,	    /* Maximum tokens for each state    */
	    dfa18_accept,	/* Accept table			    */
	    dfa18_special,	/* Special transition states	    */
	    dfa18_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 18
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    86:77: ( nulls_key last_key )?
 */
static const ANTLR_INT32 dfa22_eot[34] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa22_eof[34] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa22_min[34] =
    {
	15, 18, -1, 15, -1, 18, 18, 18, 15, 18, 15, 18, 18, 18, 18, -1, 18, 18, 
	15, 18, 15, 18, 15, 18, 18, 18, 18, 18, 18, 18, 15, 18, 18, 18
    };
static const ANTLR_INT32 dfa22_max[34] =
    {
	74, 74, -1, 134, -1, 74, 74, 74, 134, 74, 101, 74, 74, 74, 74, -1, 74, 
	74, 134, 74, 139, 74, 86, 74, 74, 74, 74, 74, 74, 74, 139, 74, 74, 74
    };
static const ANTLR_INT32 dfa22_accept[34] =
    {
	-1, -1, 2, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa22_special[34] =
    {
	7, 13, -1, 8, -1, 24, 25, 4, 26, 3, 18, 11, 23, 19, 0, -1, 12, 16, 20, 
	5, 1, 6, 2, 17, 30, 10, 22, 9, 29, 15, 21, 14, 28, 27
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa22_T_empty	 =   NULL;

static const ANTLR_INT32 dfa22_T0[] =
    {
	22, -1, -1, -1, -1, -1, -1, -1, -1, -1, 21, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 22
    };

static const ANTLR_INT32 dfa22_T1[] =
    {
	15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa22_T2[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, 
	-1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15
    };

static const ANTLR_INT32 dfa22_T3[] =
    {
	16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 16
    };

static const ANTLR_INT32 dfa22_T4[] =
    {
	11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 11
    };

static const ANTLR_INT32 dfa22_T5[] =
    {
	25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 25
    };

static const ANTLR_INT32 dfa22_T6[] =
    {
	27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 27
    };

static const ANTLR_INT32 dfa22_T7[] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 1
    };

static const ANTLR_INT32 dfa22_T8[] =
    {
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, 
	-1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa22_T9[] =
    {
	22, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 22
    };

static const ANTLR_INT32 dfa22_T10[] =
    {
	20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 20
    };

static const ANTLR_INT32 dfa22_T11[] =
    {
	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 8
    };

static const ANTLR_INT32 dfa22_T12[] =
    {
	10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 10
    };

static const ANTLR_INT32 dfa22_T13[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 3
    };

static const ANTLR_INT32 dfa22_T14[] =
    {
	33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 33
    };

static const ANTLR_INT32 dfa22_T15[] =
    {
	32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 32
    };

static const ANTLR_INT32 dfa22_T16[] =
    {
	24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 24
    };

static const ANTLR_INT32 dfa22_T17[] =
    {
	28, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 28
    };

static const ANTLR_INT32 dfa22_T18[] =
    {
	15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, 
	-1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 
	15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15
    };

static const ANTLR_INT32 dfa22_T19[] =
    {
	20, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 20
    };

static const ANTLR_INT32 dfa22_T20[] =
    {
	14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, 
	-1, -1, -1, -1, -1, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15
    };

static const ANTLR_INT32 dfa22_T21[] =
    {
	30, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 30
    };

static const ANTLR_INT32 dfa22_T22[] =
    {
	18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 18
    };

static const ANTLR_INT32 dfa22_T23[] =
    {
	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 8
    };

static const ANTLR_INT32 dfa22_T24[] =
    {
	10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 10
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa22_transitions[] =
{
    dfa22_T7, dfa22_T13, NULL, dfa22_T8, NULL, dfa22_T23, dfa22_T24, dfa22_T4, 
    dfa22_T20, dfa22_T3, dfa22_T18, dfa22_T11, dfa22_T22, dfa22_T19, dfa22_T0, 
    NULL, dfa22_T12, dfa22_T16, dfa22_T20, dfa22_T5, dfa22_T1, dfa22_T6, 
    dfa22_T2, dfa22_T17, dfa22_T11, dfa22_T10, dfa22_T21, dfa22_T9, dfa22_T12, 
    dfa22_T15, dfa22_T1, dfa22_T14, dfa22_T10, dfa22_T9
};


/* Declare tracking structure for Cyclic DFA 22
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA22 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA22( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA22_14;

	    		    ANTLR_MARKER index22_14;


	    		    LA22_14 = ctx->LA(1);

	    		     
	    		        index22_14 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_14 == INTRODUCER) )
	    		    {
	    		        s = 21;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_14 == DELIMITED_ID || LA22_14 == REGULAR_ID) )
	    		    {
	    		        s = 22;
	    		    }

	    			 
	    				ctx->seek(index22_14);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA22_20;

	    		    ANTLR_MARKER index22_20;


	    		    LA22_20 = ctx->LA(1);

	    		     
	    		        index22_20 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_20 == PERIOD) )
	    		    {
	    		        s = 26;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) && (LA22_20 == COMMA || LA22_20 == REGULAR_ID) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SET"))) && (LA22_20 == SQL92_RESERVED_TO) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_20);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA22_22;

	    		    ANTLR_MARKER index22_22;


	    		    LA22_22 = ctx->LA(1);

	    		     
	    		        index22_22 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) && (LA22_22 == LEFT_PAREN || LA22_22 == SQL92_RESERVED_AS) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SET"))) && (LA22_22 == COMMA || LA22_22 == PERIOD || LA22_22 == REGULAR_ID) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_22);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA22_9;

	    		    ANTLR_MARKER index22_9;


	    		    LA22_9 = ctx->LA(1);

	    		     
	    		        index22_9 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_9 == DELIMITED_ID || LA22_9 == REGULAR_ID) )
	    		    {
	    		        s = 16;
	    		    }

	    			 
	    				ctx->seek(index22_9);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA22_7;

	    		    ANTLR_MARKER index22_7;


	    		    LA22_7 = ctx->LA(1);

	    		     
	    		        index22_7 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_7 == DELIMITED_ID || LA22_7 == REGULAR_ID) )
	    		    {
	    		        s = 11;
	    		    }

	    			 
	    				ctx->seek(index22_7);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA22_19;

	    		    ANTLR_MARKER index22_19;


	    		    LA22_19 = ctx->LA(1);

	    		     
	    		        index22_19 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_19 == DELIMITED_ID || LA22_19 == REGULAR_ID) )
	    		    {
	    		        s = 25;
	    		    }

	    			 
	    				ctx->seek(index22_19);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA22_21;

	    		    ANTLR_MARKER index22_21;


	    		    LA22_21 = ctx->LA(1);

	    		     
	    		        index22_21 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_21 == DELIMITED_ID || LA22_21 == REGULAR_ID) )
	    		    {
	    		        s = 27;
	    		    }

	    			 
	    				ctx->seek(index22_21);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 7:

	    		{
	    		    ANTLR_UINT32 LA22_0;

	    		    ANTLR_MARKER index22_0;


	    		    LA22_0 = ctx->LA(1);

	    		     
	    		        index22_0 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_0 == REGULAR_ID) )
	    		    {
	    		        s = 1;
	    		    }

	    		    else if ( (LA22_0 == COMMA) )
	    		    {
	    		        s = 2;
	    		    }

	    			 
	    				ctx->seek(index22_0);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 8:

	    		{
	    		    ANTLR_UINT32 LA22_3;

	    		    ANTLR_MARKER index22_3;


	    		    LA22_3 = ctx->LA(1);

	    		     
	    		        index22_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_3 == REGULAR_ID) )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_3 == COMMA) )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SET"))) && (LA22_3 == LEFT_PAREN || LA22_3 == PERIOD || LA22_3 == SQL92_RESERVED_SELECT) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 9:

	    		{
	    		    ANTLR_UINT32 LA22_27;

	    		    ANTLR_MARKER index22_27;


	    		    LA22_27 = ctx->LA(1);

	    		     
	    		        index22_27 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_27 == PERIOD) )
	    		    {
	    		        s = 31;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_27 == DELIMITED_ID || LA22_27 == REGULAR_ID) )
	    		    {
	    		        s = 22;
	    		    }

	    			 
	    				ctx->seek(index22_27);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 10:

	    		{
	    		    ANTLR_UINT32 LA22_25;

	    		    ANTLR_MARKER index22_25;


	    		    LA22_25 = ctx->LA(1);

	    		     
	    		        index22_25 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_25 == PERIOD) )
	    		    {
	    		        s = 29;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_25 == DELIMITED_ID || LA22_25 == REGULAR_ID) )
	    		    {
	    		        s = 20;
	    		    }

	    			 
	    				ctx->seek(index22_25);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 11:

	    		{
	    		    ANTLR_UINT32 LA22_11;

	    		    ANTLR_MARKER index22_11;


	    		    LA22_11 = ctx->LA(1);

	    		     
	    		        index22_11 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_11 == PERIOD) )
	    		    {
	    		        s = 17;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_11 == DELIMITED_ID || LA22_11 == REGULAR_ID) )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index22_11);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 12:

	    		{
	    		    ANTLR_UINT32 LA22_16;

	    		    ANTLR_MARKER index22_16;


	    		    LA22_16 = ctx->LA(1);

	    		     
	    		        index22_16 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_16 == PERIOD) )
	    		    {
	    		        s = 23;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_16 == DELIMITED_ID || LA22_16 == REGULAR_ID) )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index22_16);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 13:

	    		{
	    		    ANTLR_UINT32 LA22_1;

	    		    ANTLR_MARKER index22_1;


	    		    LA22_1 = ctx->LA(1);

	    		     
	    		        index22_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_1 == REGULAR_ID) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SET"))) && (LA22_1 == DELIMITED_ID || LA22_1 == INTRODUCER) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 14:

	    		{
	    		    ANTLR_UINT32 LA22_31;

	    		    ANTLR_MARKER index22_31;


	    		    LA22_31 = ctx->LA(1);

	    		     
	    		        index22_31 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_31 == DELIMITED_ID || LA22_31 == REGULAR_ID) )
	    		    {
	    		        s = 33;
	    		    }

	    			 
	    				ctx->seek(index22_31);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 15:

	    		{
	    		    ANTLR_UINT32 LA22_29;

	    		    ANTLR_MARKER index22_29;


	    		    LA22_29 = ctx->LA(1);

	    		     
	    		        index22_29 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_29 == DELIMITED_ID || LA22_29 == REGULAR_ID) )
	    		    {
	    		        s = 32;
	    		    }

	    			 
	    				ctx->seek(index22_29);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 16:

	    		{
	    		    ANTLR_UINT32 LA22_17;

	    		    ANTLR_MARKER index22_17;


	    		    LA22_17 = ctx->LA(1);

	    		     
	    		        index22_17 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_17 == DELIMITED_ID || LA22_17 == REGULAR_ID) )
	    		    {
	    		        s = 24;
	    		    }

	    			 
	    				ctx->seek(index22_17);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 17:

	    		{
	    		    ANTLR_UINT32 LA22_23;

	    		    ANTLR_MARKER index22_23;


	    		    LA22_23 = ctx->LA(1);

	    		     
	    		        index22_23 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_23 == DELIMITED_ID || LA22_23 == REGULAR_ID) )
	    		    {
	    		        s = 28;
	    		    }

	    			 
	    				ctx->seek(index22_23);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 18:

	    		{
	    		    ANTLR_UINT32 LA22_10;

	    		    ANTLR_MARKER index22_10;


	    		    LA22_10 = ctx->LA(1);

	    		     
	    		        index22_10 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) && (LA22_10 == COMMA || LA22_10 == PERIOD || LA22_10 == REGULAR_ID || LA22_10 == SQL92_RESERVED_ASC || LA22_10 == SQL92_RESERVED_DESC) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SET"))) && (LA22_10 == LEFT_PAREN || LA22_10 == SQL92_RESERVED_AS) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_10);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 19:

	    		{
	    		    ANTLR_UINT32 LA22_13;

	    		    ANTLR_MARKER index22_13;


	    		    LA22_13 = ctx->LA(1);

	    		     
	    		        index22_13 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_13 == INTRODUCER) )
	    		    {
	    		        s = 19;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_13 == DELIMITED_ID || LA22_13 == REGULAR_ID) )
	    		    {
	    		        s = 20;
	    		    }

	    			 
	    				ctx->seek(index22_13);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 20:

	    		{
	    		    ANTLR_UINT32 LA22_18;

	    		    ANTLR_MARKER index22_18;


	    		    LA22_18 = ctx->LA(1);

	    		     
	    		        index22_18 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_18 == REGULAR_ID) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_18 == COMMA) )
	    		    {
	    		        s = 14;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) && (LA22_18 == LEFT_PAREN || LA22_18 == SQL92_RESERVED_SELECT) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_18 == PERIOD) )
	    		    {
	    		        s = 12;
	    		    }

	    			 
	    				ctx->seek(index22_18);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 21:

	    		{
	    		    ANTLR_UINT32 LA22_30;

	    		    ANTLR_MARKER index22_30;


	    		    LA22_30 = ctx->LA(1);

	    		     
	    		        index22_30 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) && (LA22_30 == COMMA || LA22_30 == REGULAR_ID) )
	    		    {
	    		        s = 15;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_30 == PERIOD) )
	    		    {
	    		        s = 26;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SET"))) && (LA22_30 == SQL92_RESERVED_TO) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index22_30);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 22:

	    		{
	    		    ANTLR_UINT32 LA22_26;

	    		    ANTLR_MARKER index22_26;


	    		    LA22_26 = ctx->LA(1);

	    		     
	    		        index22_26 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_26 == DELIMITED_ID || LA22_26 == REGULAR_ID) )
	    		    {
	    		        s = 30;
	    		    }

	    			 
	    				ctx->seek(index22_26);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 23:

	    		{
	    		    ANTLR_UINT32 LA22_12;

	    		    ANTLR_MARKER index22_12;


	    		    LA22_12 = ctx->LA(1);

	    		     
	    		        index22_12 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_12 == DELIMITED_ID || LA22_12 == REGULAR_ID) )
	    		    {
	    		        s = 18;
	    		    }

	    			 
	    				ctx->seek(index22_12);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 24:

	    		{
	    		    ANTLR_UINT32 LA22_5;

	    		    ANTLR_MARKER index22_5;


	    		    LA22_5 = ctx->LA(1);

	    		     
	    		        index22_5 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_5 == INTRODUCER) )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_5 == DELIMITED_ID || LA22_5 == REGULAR_ID) )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index22_5);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 25:

	    		{
	    		    ANTLR_UINT32 LA22_6;

	    		    ANTLR_MARKER index22_6;


	    		    LA22_6 = ctx->LA(1);

	    		     
	    		        index22_6 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_6 == INTRODUCER) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_6 == DELIMITED_ID || LA22_6 == REGULAR_ID) )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index22_6);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 26:

	    		{
	    		    ANTLR_UINT32 LA22_8;

	    		    ANTLR_MARKER index22_8;


	    		    LA22_8 = ctx->LA(1);

	    		     
	    		        index22_8 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_8 == PERIOD) )
	    		    {
	    		        s = 12;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_8 == REGULAR_ID) )
	    		    {
	    		        s = 13;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_8 == COMMA) )
	    		    {
	    		        s = 14;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))) && (LA22_8 == LEFT_PAREN || LA22_8 == SQL92_RESERVED_SELECT) )
	    		    {
	    		        s = 15;
	    		    }

	    			 
	    				ctx->seek(index22_8);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 27:

	    		{
	    		    ANTLR_UINT32 LA22_33;

	    		    ANTLR_MARKER index22_33;


	    		    LA22_33 = ctx->LA(1);

	    		     
	    		        index22_33 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_33 == DELIMITED_ID || LA22_33 == REGULAR_ID) )
	    		    {
	    		        s = 22;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_33 == PERIOD) )
	    		    {
	    		        s = 31;
	    		    }

	    			 
	    				ctx->seek(index22_33);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 28:

	    		{
	    		    ANTLR_UINT32 LA22_32;

	    		    ANTLR_MARKER index22_32;


	    		    LA22_32 = ctx->LA(1);

	    		     
	    		        index22_32 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_32 == DELIMITED_ID || LA22_32 == REGULAR_ID) )
	    		    {
	    		        s = 20;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_32 == PERIOD) )
	    		    {
	    		        s = 29;
	    		    }

	    			 
	    				ctx->seek(index22_32);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 29:

	    		{
	    		    ANTLR_UINT32 LA22_28;

	    		    ANTLR_MARKER index22_28;


	    		    LA22_28 = ctx->LA(1);

	    		     
	    		        index22_28 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_28 == DELIMITED_ID || LA22_28 == REGULAR_ID) )
	    		    {
	    		        s = 10;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_28 == PERIOD) )
	    		    {
	    		        s = 23;
	    		    }

	    			 
	    				ctx->seek(index22_28);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 30:

	    		{
	    		    ANTLR_UINT32 LA22_24;

	    		    ANTLR_MARKER index22_24;


	    		    LA22_24 = ctx->LA(1);

	    		     
	    		        index22_24 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_24 == DELIMITED_ID || LA22_24 == REGULAR_ID) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA22_24 == PERIOD) )
	    		    {
	    		        s = 17;
	    		    }

	    			 
	    				ctx->seek(index22_24);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "86:77: ( nulls_key last_key )?" );
	    ex->set_decisionNum( 22 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParser_PLSQL_DMLParserCyclicDFA22  cdfa22(
	    22,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"86:77: ( nulls_key last_key )?",
	    dfa22_eot,	    /* EOT table			    */
	    dfa22_eof,	    /* EOF table			    */
	    dfa22_min,	    /* Minimum tokens for each state    */
	    dfa22_max,	    /* Maximum tokens for each state    */
	    dfa22_accept,	/* Accept table			    */
	    dfa22_special,	/* Special transition states	    */
	    dfa22_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 22
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 308:64: ( reference_model )*
 */
static const ANTLR_INT32 dfa99_eot[10] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa99_eof[10] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa99_min[10] =
    {
	74, 18, 18, 74, -1, 18, -1, -1, 18, 18
    };
static const ANTLR_INT32 dfa99_max[10] =
    {
	74, 90, 74, 125, -1, 74, -1, -1, 74, 74
    };
static const ANTLR_INT32 dfa99_accept[10] =
    {
	-1, -1, -1, -1, 2, -1, 2, 1, -1, -1
    };
static const ANTLR_INT32 dfa99_special[10] =
    {
	6, 2, 4, 1, -1, 3, -1, -1, 0, 5
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa99_T_empty	 =   NULL;

static const ANTLR_INT32 dfa99_T0[] =
    {
	9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 9
    };

static const ANTLR_INT32 dfa99_T1[] =
    {
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7
    };

static const ANTLR_INT32 dfa99_T2[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa99_T3[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 3
    };

static const ANTLR_INT32 dfa99_T4[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 5
    };

static const ANTLR_INT32 dfa99_T5[] =
    {
	1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa99_transitions[] =
{
    dfa99_T5, dfa99_T2, dfa99_T4, dfa99_T1, NULL, dfa99_T3, NULL, NULL, 
    dfa99_T0, dfa99_T3
};


/* Declare tracking structure for Cyclic DFA 99
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA99 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA99( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA99_8;

	    		    ANTLR_MARKER index99_8;


	    		    LA99_8 = ctx->LA(1);

	    		     
	    		        index99_8 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) && (LA99_8 == DELIMITED_ID || LA99_8 == REGULAR_ID) )
	    		    {
	    		        s = 9;
	    		    }

	    			 
	    				ctx->seek(index99_8);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA99_3;

	    		    ANTLR_MARKER index99_3;


	    		    LA99_3 = ctx->LA(1);

	    		     
	    		        index99_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "MAIN"))) && (LA99_3 == REGULAR_ID) )
	    		    {
	    		        s = 6;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "REFERENCE"))) && (LA99_3 == SQL92_RESERVED_ON) )
	    		    {
	    		        s = 7;
	    		    }

	    			 
	    				ctx->seek(index99_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA99_1;

	    		    ANTLR_MARKER index99_1;


	    		    LA99_1 = ctx->LA(1);

	    		     
	    		        index99_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) && (LA99_1 == INTRODUCER) )
	    		    {
	    		        s = 2;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) && (LA99_1 == DELIMITED_ID || LA99_1 == REGULAR_ID) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "DIMENSION")))||((equalsIgnoreCase(LT(1)->getText(), "PARTITION"))))) && (LA99_1 == SQL92_RESERVED_BY) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index99_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA99_5;

	    		    ANTLR_MARKER index99_5;


	    		    LA99_5 = ctx->LA(1);

	    		     
	    		        index99_5 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) && (LA99_5 == PERIOD) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) && (LA99_5 == DELIMITED_ID || LA99_5 == REGULAR_ID) )
	    		    {
	    		        s = 3;
	    		    }

	    			 
	    				ctx->seek(index99_5);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA99_2;

	    		    ANTLR_MARKER index99_2;


	    		    LA99_2 = ctx->LA(1);

	    		     
	    		        index99_2 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) && (LA99_2 == DELIMITED_ID || LA99_2 == REGULAR_ID) )
	    		    {
	    		        s = 5;
	    		    }

	    			 
	    				ctx->seek(index99_2);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA99_9;

	    		    ANTLR_MARKER index99_9;


	    		    LA99_9 = ctx->LA(1);

	    		     
	    		        index99_9 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) && (LA99_9 == DELIMITED_ID || LA99_9 == REGULAR_ID) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) && (LA99_9 == PERIOD) )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index99_9);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA99_0;

	    		    ANTLR_MARKER index99_0;


	    		    LA99_0 = ctx->LA(1);

	    		     
	    		        index99_0 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "DIMENSION")))||((equalsIgnoreCase(LT(1)->getText(), "PARTITION")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) && (LA99_0 == REGULAR_ID) )
	    		    {
	    		        s = 1;
	    		    }

	    			 
	    				ctx->seek(index99_0);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "()* loopback of 308:64: ( reference_model )*" );
	    ex->set_decisionNum( 99 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParser_PLSQL_DMLParserCyclicDFA99  cdfa99(
	    99,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"()* loopback of 308:64: ( reference_model )*",
	    dfa99_eot,	    /* EOT table			    */
	    dfa99_eof,	    /* EOF table			    */
	    dfa99_min,	    /* Minimum tokens for each state    */
	    dfa99_max,	    /* Maximum tokens for each state    */
	    dfa99_accept,	/* Accept table			    */
	    dfa99_special,	/* Special transition states	    */
	    dfa99_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 99
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    557:9: ( error_logging_into_part )?
 */
static const ANTLR_INT32 dfa179_eot[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa179_eof[9] =
    {
	2, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa179_min[9] =
    {
	5, 18, -1, 18, -1, -1, 18, 18, 18
    };
static const ANTLR_INT32 dfa179_max[9] =
    {
	151, 137, -1, 74, -1, -1, 74, 74, 74
    };
static const ANTLR_INT32 dfa179_accept[9] =
    {
	-1, -1, 2, -1, 1, 1, -1, -1, -1
    };
static const ANTLR_INT32 dfa179_special[9] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa179_T_empty	 =   NULL;

static const ANTLR_INT32 dfa179_T0[] =
    {
	2, -1, -1, -1, 2, -1, -1, 2, 2, 2, -1, -1, -1, 2, -1, -1, -1, 2, -1, -1, 
	-1, -1, -1, 2, -1, 2, -1, -1, 2, 2, -1, -1, -1, -1, 2, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, 2, -1, -1, 2, 
	-1, 2, 2, -1, 2, -1, -1, -1, -1, -1, 2, -1, -1, 2, -1, 2, 2, -1, 2, 2, 
	-1, 2, 2, 2, -1, -1, 2, 2, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, 1, -1, 
	-1, 2, 2, -1, -1, -1, -1, -1, -1, 2, 2, -1, -1, 2, -1, -1, -1, -1, -1, 
	2, -1, -1, 2, -1, -1, 2, -1, 2, -1, -1, 2
    };

static const ANTLR_INT32 dfa179_T1[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 5
    };

static const ANTLR_INT32 dfa179_T2[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, 2, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 2
    };

static const ANTLR_INT32 dfa179_T3[] =
    {
	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 8
    };

static const ANTLR_INT32 dfa179_T4[] =
    {
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 6
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa179_transitions[] =
{
    dfa179_T0, dfa179_T2, NULL, dfa179_T4, NULL, NULL, dfa179_T1, dfa179_T3, 
    dfa179_T1
};


/* Declare tracking structure for Cyclic DFA 179
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA179 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA179( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		
	}

};

static PLSQLParser_PLSQL_DMLParserCyclicDFA179  cdfa179(
	    179,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"557:9: ( error_logging_into_part )?",
	    dfa179_eot,	    /* EOT table			    */
	    dfa179_eof,	    /* EOF table			    */
	    dfa179_min,	    /* Minimum tokens for each state    */
	    dfa179_max,	    /* Maximum tokens for each state    */
	    dfa179_accept,	/* Accept table			    */
	    dfa179_special,	/* Special transition states	    */
	    dfa179_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 179
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    828:1: atom options {backtrack=true; } : ( ( table_element outer_join_sign )=> table_element outer_join_sign | bind_variable | constant | general_element | LEFT_PAREN ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN ) );
 */
static const ANTLR_INT32 dfa256_eot[22] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1
    };
static const ANTLR_INT32 dfa256_eof[22] =
    {
	-1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, 
	-1, -1, -1, 10
    };
static const ANTLR_INT32 dfa256_min[22] =
    {
	5, 18, 30, -1, 7, -1, -1, 18, -1, -1, -1, 18, 5, 18, 7, 5, 18, 5, 18, -1, 
	5, 7
    };
static const ANTLR_INT32 dfa256_max[22] =
    {
	151, 74, 38, -1, 152, -1, -1, 74, -1, -1, -1, 74, 151, 74, 152, 151, 74, 
	151, 74, -1, 151, 152
    };
static const ANTLR_INT32 dfa256_accept[22] =
    {
	-1, -1, -1, 2, -1, 3, 5, -1, 1, 1, 4, -1, -1, -1, -1, -1, -1, -1, -1, 1, 
	-1, -1
    };
static const ANTLR_INT32 dfa256_special[22] =
    {
	-1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, 
	-1, 1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa256_T_empty	 =   NULL;

static const ANTLR_INT32 dfa256_T0[] =
    {
	10, -1, -1, -1, 10, 10, 10, -1, 10, -1, 10, 10, -1, 10, 10, -1, 10, -1, 
	10, 10, -1, 10, 10, 12, 10, 10, 10, 10, -1, 10, -1, 11, -1, -1, 10, 10, 
	10, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 10, -1, -1, -1, -1, -1, 
	10, -1, -1, 10, 10, -1, -1, -1, -1, -1, -1, -1, -1, 10, 10, 10, 10, -1, 
	-1, 10, -1, -1, 10, 10, -1, 10, 10, -1, 10, 10, -1, -1, 10, 10, -1, -1, 
	-1, -1, 10, 10, 10, -1, 10, 10, 10, -1, -1, -1, 10, 10, 10, -1, -1, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, -1, -1, 10, -1, 10, 10, -1, -1, 10, -1, 
	-1, 10, -1, -1, -1, 10, 10, -1, 10, -1, 10, -1, -1, 10, 10, 10, -1, -1, 
	-1, 10
    };

static const ANTLR_INT32 dfa256_T1[] =
    {
	14, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 14
    };

static const ANTLR_INT32 dfa256_T2[] =
    {
	5, -1, -1, -1, 3, -1, -1, 5, 5, 3, -1, -1, -1, 4, -1, -1, -1, 5, -1, -1, 
	-1, -1, -1, 1, -1, 6, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 
	-1, 5, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5
    };

static const ANTLR_INT32 dfa256_T3[] =
    {
	10, -1, -1, -1, 10, 10, 10, -1, 10, -1, 10, 10, -1, 10, 10, -1, 10, -1, 
	10, 10, -1, 10, 10, 17, 10, 10, 10, 10, -1, 10, -1, 18, -1, -1, 10, 10, 
	10, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 10, -1, -1, -1, -1, -1, 
	10, -1, -1, 10, 10, -1, -1, -1, -1, -1, -1, -1, -1, 10, 10, 10, 10, -1, 
	-1, 10, -1, -1, 10, 10, -1, 10, 10, -1, 10, 10, -1, -1, 10, 10, -1, -1, 
	-1, -1, 10, 10, 10, -1, 10, 10, 10, -1, -1, -1, 10, 10, 10, -1, -1, 10, 
	10, 10, 10, 10, 10, 10, 10, 10, -1, -1, 10, -1, 10, 10, -1, -1, 10, -1, 
	-1, 10, -1, -1, -1, 10, 10, -1, 10, -1, 10, -1, -1, 10, 10, 10, -1, -1, 
	-1, 10
    };

static const ANTLR_INT32 dfa256_T4[] =
    {
	10, -1, -1, -1, 10, -1, -1, 10, 10, 10, 10, -1, -1, 10, -1, -1, -1, 10, 
	-1, -1, -1, -1, -1, 10, -1, 10, -1, -1, 10, 10, -1, -1, -1, -1, 10, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 20, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, 10, 
	-1, -1, -1, -1, -1, 10, -1, -1, 10, -1, -1, -1, -1, -1, 10, -1, -1, -1, 
	-1, 10, 10, -1, 10, -1, -1, 10, -1, -1, -1, -1, 10, 10, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 10, -1, -1, -1, -1, -1, -1, 10, 
	-1, -1, -1, 10, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 10
    };

static const ANTLR_INT32 dfa256_T5[] =
    {
	10, -1, -1, -1, 10, -1, -1, 10, 10, 10, -1, -1, -1, 10, -1, -1, -1, 10, 
	-1, -1, -1, -1, -1, 10, -1, 10, -1, -1, 10, 10, -1, -1, -1, -1, 10, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, 19, 
	-1, -1, -1, -1, -1, 10, -1, -1, 10, -1, -1, -1, -1, -1, 10, -1, -1, -1, 
	-1, -1, 10, -1, 10, -1, -1, 10, -1, -1, -1, -1, 10, 10, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, 10, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 10
    };

static const ANTLR_INT32 dfa256_T6[] =
    {
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4
    };

static const ANTLR_INT32 dfa256_T7[] =
    {
	10, -1, -1, -1, 10, -1, -1, 10, 10, 10, 10, -1, -1, 10, -1, -1, -1, 10, 
	-1, -1, -1, -1, -1, 10, -1, 10, -1, -1, 10, 10, -1, -1, -1, -1, 10, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, 10, 
	-1, -1, -1, -1, -1, 10, -1, -1, 10, -1, -1, -1, -1, -1, 10, -1, -1, -1, 
	-1, 10, 10, -1, 10, -1, -1, 10, -1, -1, -1, -1, 10, 10, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 10, -1, -1, -1, -1, -1, -1, 10, 
	-1, -1, -1, 10, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 10
    };

static const ANTLR_INT32 dfa256_T8[] =
    {
	7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 7
    };

static const ANTLR_INT32 dfa256_T9[] =
    {
	21, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 21
    };

static const ANTLR_INT32 dfa256_T10[] =
    {
	9, -1, -1, -1, -1, -1, -1, -1, 8
    };

static const ANTLR_INT32 dfa256_T11[] =
    {
	16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 16
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa256_transitions[] =
{
    dfa256_T2, dfa256_T8, dfa256_T10, NULL, dfa256_T0, NULL, NULL, dfa256_T6, 
    NULL, NULL, NULL, dfa256_T1, dfa256_T7, dfa256_T11, dfa256_T3, dfa256_T5, 
    dfa256_T6, dfa256_T4, dfa256_T9, NULL, dfa256_T5, dfa256_T3
};


/* Declare tracking structure for Cyclic DFA 256
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA256 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA256( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA256_15;

	    		    ANTLR_MARKER index256_15;


	    		    LA256_15 = ctx->LA(1);

	    		     
	    		        index256_15 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (this->msynpred( antlr3::ClassForwarder<synpred43_PLSQL_DMLParser>() )) && (LA256_15 == RIGHT_PAREN) )
	    		    {
	    		        s = 19;
	    		    }

	    		    else if ( (LA256_15 == APPROXIMATE_NUM_LIT || LA256_15 == BINDVAR || ((LA256_15 >= CHAR_STRING) && (LA256_15 <= COLON)) || LA256_15 == DELIMITED_ID || LA256_15 == EXACT_NUM_LIT || LA256_15 == INTRODUCER || LA256_15 == LEFT_PAREN || ((LA256_15 >= MINUS_SIGN) && (LA256_15 <= NATIONAL_CHAR_STRING_LIT)) || LA256_15 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA256_15 == PLUS_SIGN || LA256_15 == REGULAR_ID || LA256_15 == SQL92_RESERVED_ALL || LA256_15 == SQL92_RESERVED_ANY || LA256_15 == SQL92_RESERVED_CASE || LA256_15 == SQL92_RESERVED_DATE || LA256_15 == SQL92_RESERVED_DEFAULT || LA256_15 == SQL92_RESERVED_DISTINCT || ((LA256_15 >= SQL92_RESERVED_EXISTS) && (LA256_15 <= SQL92_RESERVED_FALSE)) || LA256_15 == SQL92_RESERVED_NULL || LA256_15 == SQL92_RESERVED_PRIOR || LA256_15 == SQL92_RESERVED_TRUE || LA256_15 == UNSIGNED_INTEGER) )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index256_15);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA256_20;

	    		    ANTLR_MARKER index256_20;


	    		    LA256_20 = ctx->LA(1);

	    		     
	    		        index256_20 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (this->msynpred( antlr3::ClassForwarder<synpred43_PLSQL_DMLParser>() )) && (LA256_20 == RIGHT_PAREN) )
	    		    {
	    		        s = 19;
	    		    }

	    		    else if ( (LA256_20 == APPROXIMATE_NUM_LIT || LA256_20 == BINDVAR || ((LA256_20 >= CHAR_STRING) && (LA256_20 <= COLON)) || LA256_20 == DELIMITED_ID || LA256_20 == EXACT_NUM_LIT || LA256_20 == INTRODUCER || LA256_20 == LEFT_PAREN || ((LA256_20 >= MINUS_SIGN) && (LA256_20 <= NATIONAL_CHAR_STRING_LIT)) || LA256_20 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA256_20 == PLUS_SIGN || LA256_20 == REGULAR_ID || LA256_20 == SQL92_RESERVED_ALL || LA256_20 == SQL92_RESERVED_ANY || LA256_20 == SQL92_RESERVED_CASE || LA256_20 == SQL92_RESERVED_DATE || LA256_20 == SQL92_RESERVED_DEFAULT || LA256_20 == SQL92_RESERVED_DISTINCT || ((LA256_20 >= SQL92_RESERVED_EXISTS) && (LA256_20 <= SQL92_RESERVED_FALSE)) || LA256_20 == SQL92_RESERVED_NULL || LA256_20 == SQL92_RESERVED_PRIOR || LA256_20 == SQL92_RESERVED_TRUE || LA256_20 == UNSIGNED_INTEGER) )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index256_20);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA256_2;

	    		    ANTLR_MARKER index256_2;


	    		    LA256_2 = ctx->LA(1);

	    		     
	    		        index256_2 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( (this->msynpred( antlr3::ClassForwarder<synpred43_PLSQL_DMLParser>() )) && (LA256_2 == PERIOD) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred43_PLSQL_DMLParser>() )) && (LA256_2 == LEFT_PAREN) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( (( ((((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||((equalsIgnoreCase(LT(1)->getText(), "MAXVALUE")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP")))||((equalsIgnoreCase(LT(1)->getText(), "MINVALUE")))||((equalsIgnoreCase(LT(1)->getText(), "SESSIONTIMEZONE")))||((equalsIgnoreCase(LT(1)->getText(), "DBTIMEZONE"))))) && (this->msynpred( antlr3::ClassForwarder<synpred45_PLSQL_DMLParser>() )) )) )
	    		    {
	    		        s = 5;
	    		    }

	    		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred46_PLSQL_DMLParser>() )) )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index256_2);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "828:1: atom options {backtrack=true; } : ( ( table_element outer_join_sign )=> table_element outer_join_sign | bind_variable | constant | general_element | LEFT_PAREN ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN ) );" );
	    ex->set_decisionNum( 256 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParser_PLSQL_DMLParserCyclicDFA256  cdfa256(
	    256,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"828:1: atom options {backtrack=true; } : ( ( table_element outer_join_sign )=> table_element outer_join_sign | bind_variable | constant | general_element | LEFT_PAREN ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN ) );",
	    dfa256_eot,	    /* EOT table			    */
	    dfa256_eof,	    /* EOF table			    */
	    dfa256_min,	    /* Minimum tokens for each state    */
	    dfa256_max,	    /* Maximum tokens for each state    */
	    dfa256_accept,	/* Accept table			    */
	    dfa256_special,	/* Special transition states	    */
	    dfa256_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 256
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    941:17: ( name_key id | evalname_key concatenation_wrapper )
 */
static const ANTLR_INT32 dfa301_eot[11] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa301_eof[11] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR_INT32 dfa301_min[11] =
    {
	74, 5, 18, 0, -1, 0, 18, -1, 18, 0, 18
    };
static const ANTLR_INT32 dfa301_max[11] =
    {
	74, 151, 74, 0, -1, 0, 74, -1, 74, 0, 74
    };
static const ANTLR_INT32 dfa301_accept[11] =
    {
	-1, -1, -1, -1, 2, -1, -1, 1, -1, -1, -1
    };
static const ANTLR_INT32 dfa301_special[11] =
    {
	7, 3, 8, 2, -1, 1, 4, -1, 0, 6, 5
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa301_T_empty	 =   NULL;

static const ANTLR_INT32 dfa301_T0[] =
    {
	10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 10
    };

static const ANTLR_INT32 dfa301_T1[] =
    {
	-1
    };

static const ANTLR_INT32 dfa301_T2[] =
    {
	4, -1, -1, -1, 4, -1, -1, 4, 4, 4, -1, -1, -1, 5, -1, -1, -1, 4, -1, -1, 
	-1, -1, -1, 2, -1, 4, -1, -1, 4, 4, -1, -1, -1, -1, 4, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, 
	-1, 4, -1, -1, 4, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, 4, -1, 4, 
	-1, -1, 4, -1, -1, -1, -1, 4, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR_INT32 dfa301_T3[] =
    {
	9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 9
    };

static const ANTLR_INT32 dfa301_T4[] =
    {
	1
    };

static const ANTLR_INT32 dfa301_T5[] =
    {
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 6
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa301_transitions[] =
{
    dfa301_T4, dfa301_T2, dfa301_T5, dfa301_T1, NULL, dfa301_T1, dfa301_T3, 
    NULL, dfa301_T0, dfa301_T1, dfa301_T3
};


/* Declare tracking structure for Cyclic DFA 301
 */
class PLSQLParser_PLSQL_DMLParserCyclicDFA301 : public CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >, public PLSQLParser_PLSQL_DMLParserTokens
{
public:
	typedef CyclicDFA< PLSQLParser_PLSQL_DMLParserImplTraits, PLSQLParser_PLSQL_DMLParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	//to maintain C-Target compatibility, we need to make some of ctx functions look like member funcs
	CtxType*	m_ctx; 
	

public:
	PLSQLParser_PLSQL_DMLParserCyclicDFA301( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		m_ctx = NULL;
		
	}

    ANTLR_UINT32 LA(ANTLR_INT32 i)
    {
        return m_ctx->LA(i);
    }

    const CtxType::CommonTokenType*  LT(ANTLR_INT32 k)
    {
        return m_ctx->LT(k);
    }
    template<typename PredType>
    bool msynpred( PredType pred )
    {
        return m_ctx->msynpred(pred);
    }

	ANTLR_INT32  specialStateTransition(CtxType * ctx, RecognizerType* recognizer, IntStreamType* is, ANTLR_INT32 s)
	{
	    ANTLR_INT32    _s;

	    m_ctx = ctx;
	    _s	    = s;
	    switch  (s)
	    {
	    	    case 0:

	    		{
	    		    ANTLR_UINT32 LA301_8;

	    		    ANTLR_MARKER index301_8;


	    		    LA301_8 = ctx->LA(1);

	    		     
	    		        index301_8 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) && (LA301_8 == DELIMITED_ID || LA301_8 == REGULAR_ID) )
	    		    {
	    		        s = 10;
	    		    }

	    			 
	    				ctx->seek(index301_8);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 1:

	    		{
	    		    ANTLR_UINT32 LA301_5;

	    		    ANTLR_MARKER index301_5;


	    		    LA301_5 = ctx->LA(1);

	    		     
	    		        index301_5 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "NAME"))) )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "EVALNAME"))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index301_5);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 2:

	    		{
	    		    ANTLR_UINT32 LA301_3;

	    		    ANTLR_MARKER index301_3;


	    		    LA301_3 = ctx->LA(1);

	    		     
	    		        index301_3 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "NAME"))) )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "EVALNAME"))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index301_3);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 3:

	    		{
	    		    ANTLR_UINT32 LA301_1;

	    		    ANTLR_MARKER index301_1;


	    		    LA301_1 = ctx->LA(1);

	    		     
	    		        index301_1 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) && (LA301_1 == INTRODUCER) )
	    		    {
	    		        s = 2;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) && (LA301_1 == REGULAR_ID) )
	    		    {
	    		        s = 3;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "EVALNAME"))) && (LA301_1 == APPROXIMATE_NUM_LIT || LA301_1 == BINDVAR || ((LA301_1 >= CHAR_STRING) && (LA301_1 <= COLON)) || LA301_1 == EXACT_NUM_LIT || LA301_1 == LEFT_PAREN || ((LA301_1 >= MINUS_SIGN) && (LA301_1 <= NATIONAL_CHAR_STRING_LIT)) || LA301_1 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA301_1 == PLUS_SIGN || LA301_1 == SQL92_RESERVED_ALL || LA301_1 == SQL92_RESERVED_ANY || LA301_1 == SQL92_RESERVED_CASE || LA301_1 == SQL92_RESERVED_DATE || LA301_1 == SQL92_RESERVED_DEFAULT || LA301_1 == SQL92_RESERVED_DISTINCT || ((LA301_1 >= SQL92_RESERVED_EXISTS) && (LA301_1 <= SQL92_RESERVED_FALSE)) || LA301_1 == SQL92_RESERVED_NULL || LA301_1 == SQL92_RESERVED_PRIOR || LA301_1 == SQL92_RESERVED_TRUE || LA301_1 == UNSIGNED_INTEGER) )
	    		    {
	    		        s = 4;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) && (LA301_1 == DELIMITED_ID) )
	    		    {
	    		        s = 5;
	    		    }

	    			 
	    				ctx->seek(index301_1);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 4:

	    		{
	    		    ANTLR_UINT32 LA301_6;

	    		    ANTLR_MARKER index301_6;


	    		    LA301_6 = ctx->LA(1);

	    		     
	    		        index301_6 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) && (LA301_6 == PERIOD) )
	    		    {
	    		        s = 8;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) && (LA301_6 == DELIMITED_ID || LA301_6 == REGULAR_ID) )
	    		    {
	    		        s = 9;
	    		    }

	    			 
	    				ctx->seek(index301_6);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 5:

	    		{
	    		    ANTLR_UINT32 LA301_10;

	    		    ANTLR_MARKER index301_10;


	    		    LA301_10 = ctx->LA(1);

	    		     
	    		        index301_10 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) && (LA301_10 == DELIMITED_ID || LA301_10 == REGULAR_ID) )
	    		    {
	    		        s = 9;
	    		    }

	    		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) && (LA301_10 == PERIOD) )
	    		    {
	    		        s = 8;
	    		    }

	    			 
	    				ctx->seek(index301_10);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 6:

	    		{
	    		    ANTLR_UINT32 LA301_9;

	    		    ANTLR_MARKER index301_9;


	    		    LA301_9 = ctx->LA(1);

	    		     
	    		        index301_9 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "NAME"))) )
	    		    {
	    		        s = 7;
	    		    }

	    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "EVALNAME"))) )
	    		    {
	    		        s = 4;
	    		    }

	    			 
	    				ctx->seek(index301_9);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 7:

	    		{
	    		    ANTLR_UINT32 LA301_0;

	    		    ANTLR_MARKER index301_0;


	    		    LA301_0 = ctx->LA(1);

	    		     
	    		        index301_0 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) && (LA301_0 == REGULAR_ID) )
	    		    {
	    		        s = 1;
	    		    }

	    			 
	    				ctx->seek(index301_0);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;

	    	    case 8:

	    		{
	    		    ANTLR_UINT32 LA301_2;

	    		    ANTLR_MARKER index301_2;


	    		    LA301_2 = ctx->LA(1);

	    		     
	    		        index301_2 = ctx->index();

	    		        ctx->rewindLast();

	    		    s = -1;
	    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "EVALNAME")))||((equalsIgnoreCase(LT(1)->getText(), "NAME"))))) && (LA301_2 == DELIMITED_ID || LA301_2 == REGULAR_ID) )
	    		    {
	    		        s = 6;
	    		    }

	    			 
	    				ctx->seek(index301_2);

	    		    if ( s>=0 )
	    		    {
	    			return s;
	    		    }
	    		}
	    		break;
	    }
	    if ( ctx->get_backtracking() > 0)
	    {
		 ctx->set_failedflag( true );
		return	-1;
	    }
	    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( recognizer, "941:17: ( name_key id | evalname_key concatenation_wrapper )" );
	    ex->set_decisionNum( 301 );
	    ex->set_state(_s);
	    return -1;
	}
};

static PLSQLParser_PLSQL_DMLParserCyclicDFA301  cdfa301(
	    301,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"941:17: ( name_key id | evalname_key concatenation_wrapper )",
	    dfa301_eot,	    /* EOT table			    */
	    dfa301_eof,	    /* EOF table			    */
	    dfa301_min,	    /* Minimum tokens for each state    */
	    dfa301_max,	    /* Maximum tokens for each state    */
	    dfa301_accept,	/* Accept table			    */
	    dfa301_special,	/* Special transition states	    */
	    dfa301_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 301
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */

/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start explain_statement
 * PLSQL_DMLParser.g:53:1: explain_statement : explain_key plan_key ( set_key statement_id_key EQUALS_OP quoted_string )? ( into_key tableview_name )? for_key ( select_statement | update_statement | delete_statement | insert_statement | merge_statement ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::explain_statement()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:54:5: ( explain_key plan_key ( set_key statement_id_key EQUALS_OP quoted_string )? ( into_key tableview_name )? for_key ( select_statement | update_statement | delete_statement | insert_statement | merge_statement ) )
        // PLSQL_DMLParser.g:54:10: explain_key plan_key ( set_key statement_id_key EQUALS_OP quoted_string )? ( into_key tableview_name )? for_key ( select_statement | update_statement | delete_statement | insert_statement | merge_statement )
        {
            this->followPush(FOLLOW_explain_key_in_explain_statement187);
            m_gPLSQLParser->explain_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexplain_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_plan_key_in_explain_statement189);
            m_gPLSQLParser->plan_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexplain_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:55:10: ( set_key statement_id_key EQUALS_OP quoted_string )?
            {
                int alt3=2;
                {
                    int LA3_0 = this->LA(1);
                    if ( ((equalsIgnoreCase(LT(1)->getText(), "SET"))) && (LA3_0 == REGULAR_ID))
                    {
                        alt3=1;
                    }
                }
                switch (alt3)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:55:11: set_key statement_id_key EQUALS_OP quoted_string
            	    {
            	        this->followPush(FOLLOW_set_key_in_explain_statement201);
            	        m_gPLSQLParser->set_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_statement_id_key_in_explain_statement203);
            	        m_gPLSQLParser->statement_id_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_explain_statement205);
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_quoted_string_in_explain_statement207);
            	        m_gPLSQLParser->quoted_string();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:56:10: ( into_key tableview_name )?
            {
                int alt4=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_INTO:
                    	{
                    		alt4=1;
                    	}
                        break;
                }

                switch (alt4)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:56:11: into_key tableview_name
            	    {
            	        this->followPush(FOLLOW_into_key_in_explain_statement221);
            	        m_gPLSQLParser->into_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_tableview_name_in_explain_statement223);
            	        m_gPLSQLParser->tableview_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_for_key_in_explain_statement236);
            m_gPLSQLParser->for_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexplain_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:58:10: ( select_statement | update_statement | delete_statement | insert_statement | merge_statement )
            {
                int alt5=5;
                {
                    int LA5_0 = this->LA(1);
                    if ( (LA5_0 == LEFT_PAREN || LA5_0 == SQL92_RESERVED_SELECT || LA5_0 == SQL92_RESERVED_WITH))
                    {
                        alt5=1;
                    }
                    else if ( (LA5_0 == SQL92_RESERVED_UPDATE))
                    {
                        alt5=2;
                    }
                    else if ( (LA5_0 == SQL92_RESERVED_DELETE))
                    {
                        alt5=3;
                    }
                    else if ( (LA5_0 == SQL92_RESERVED_INSERT))
                    {
                        alt5=4;
                    }
                    else if ( ((equalsIgnoreCase(LT(1)->getText(), "MERGE"))) && (LA5_0 == REGULAR_ID))
                    {
                        alt5=5;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 5 );
                        ex->set_state( 0 );


                        goto ruleexplain_statementEx;

                    }
                }
                switch (alt5)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:58:12: select_statement
            	    {
            	        this->followPush(FOLLOW_select_statement_in_explain_statement249);
            	        select_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:59:12: update_statement
            	    {
            	        this->followPush(FOLLOW_update_statement_in_explain_statement262);
            	        update_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQL_DMLParser.g:60:12: delete_statement
            	    {
            	        this->followPush(FOLLOW_delete_statement_in_explain_statement275);
            	        delete_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 4:
            	    // PLSQL_DMLParser.g:61:12: insert_statement
            	    {
            	        this->followPush(FOLLOW_insert_statement_in_explain_statement288);
            	        insert_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 5:
            	    // PLSQL_DMLParser.g:62:12: merge_statement
            	    {
            	        this->followPush(FOLLOW_merge_statement_in_explain_statement301);
            	        merge_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexplain_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexplain_statementEx; /* Prevent compiler warnings */
    ruleexplain_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end explain_statement */

/**
 * $ANTLR start select_statement
 * PLSQL_DMLParser.g:66:1: select_statement : ( subquery_factoring_clause )? subquery ( for_update_clause | ( order_key ( siblings_key )? by_key )=> order_by_clause )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::select_statement()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:67:5: ( ( subquery_factoring_clause )? subquery ( for_update_clause | ( order_key ( siblings_key )? by_key )=> order_by_clause )* )
        // PLSQL_DMLParser.g:67:10: ( subquery_factoring_clause )? subquery ( for_update_clause | ( order_key ( siblings_key )? by_key )=> order_by_clause )*
        {
            // PLSQL_DMLParser.g:67:10: ( subquery_factoring_clause )?
            {
                int alt6=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_WITH:
                    	{
                    		alt6=1;
                    	}
                        break;
                }

                switch (alt6)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:67:10: subquery_factoring_clause
            	    {
            	        this->followPush(FOLLOW_subquery_factoring_clause_in_select_statement332);
            	        subquery_factoring_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselect_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_subquery_in_select_statement343);
            subquery();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleselect_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:69:9: ( for_update_clause | ( order_key ( siblings_key )? by_key )=> order_by_clause )*

            for (;;)
            {
                int alt7=3;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA7_0 = this->LA(1);
                    if ( (LA7_0 == SQL92_RESERVED_FOR))
                    {
                        alt7=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred1_PLSQL_DMLParser>() )) && (LA7_0 == SQL92_RESERVED_ORDER))
                    {
                        alt7=2;
                    }

                }
                switch (alt7)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:69:10: for_update_clause
            	    {
            	        this->followPush(FOLLOW_for_update_clause_in_select_statement354);
            	        for_update_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselect_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:69:28: ( order_key ( siblings_key )? by_key )=> order_by_clause
            	    {
            	        this->followPush(FOLLOW_order_by_clause_in_select_statement366);
            	        order_by_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselect_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleselect_statementEx; /* Prevent compiler warnings */
    ruleselect_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end select_statement */

/**
 * $ANTLR start subquery_factoring_clause
 * PLSQL_DMLParser.g:73:1: subquery_factoring_clause : with_key factoring_element ( COMMA factoring_element )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::subquery_factoring_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:74:5: ( with_key factoring_element ( COMMA factoring_element )* )
        // PLSQL_DMLParser.g:74:10: with_key factoring_element ( COMMA factoring_element )*
        {
            this->followPush(FOLLOW_with_key_in_subquery_factoring_clause389);
            m_gPLSQLParser->with_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubquery_factoring_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_factoring_element_in_subquery_factoring_clause391);
            factoring_element();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubquery_factoring_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:74:37: ( COMMA factoring_element )*

            for (;;)
            {
                int alt8=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt8=1;
                	}
                    break;

                }

                switch (alt8)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:74:38: COMMA factoring_element
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_subquery_factoring_clause394);
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_factoring_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_factoring_element_in_subquery_factoring_clause396);
            	        factoring_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_factoring_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop8;	/* break out of the loop */
            	    break;
                }
            }
            loop8: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubquery_factoring_clauseEx; /* Prevent compiler warnings */
    rulesubquery_factoring_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end subquery_factoring_clause */

/**
 * $ANTLR start factoring_element
 * PLSQL_DMLParser.g:77:1: factoring_element : query_name ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? as_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( search_clause )? ( cycle_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::factoring_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:78:5: ( query_name ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? as_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( search_clause )? ( cycle_clause )? )
        // PLSQL_DMLParser.g:78:10: query_name ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? as_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( search_clause )? ( cycle_clause )?
        {
            this->followPush(FOLLOW_query_name_in_factoring_element418);
            m_gPLSQLParser->query_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefactoring_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:78:21: ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )?
            {
                int alt10=2;
                switch ( this->LA(1) )
                {
                    case LEFT_PAREN:
                    	{
                    		alt10=1;
                    	}
                        break;
                }

                switch (alt10)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:78:22: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_factoring_element421);
            	        if  (this->hasException())
            	        {
            	            goto rulefactoring_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_factoring_element423);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefactoring_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:78:45: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            int alt9=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt9=1;
            	            	}
            	                break;

            	            }

            	            switch (alt9)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:78:46: COMMA column_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_factoring_element426);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefactoring_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_column_name_in_factoring_element428);
            	        	        m_gPLSQLParser->column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulefactoring_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop9;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop9: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_factoring_element432);
            	        if  (this->hasException())
            	        {
            	            goto rulefactoring_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_as_key_in_factoring_element436);
            m_gPLSQLParser->as_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefactoring_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_factoring_element438);
            if  (this->hasException())
            {
                goto rulefactoring_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_subquery_in_factoring_element440);
            subquery();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefactoring_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:78:107: ( order_by_clause )?
            {
                int alt11=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_ORDER:
                    	{
                    		alt11=1;
                    	}
                        break;
                }

                switch (alt11)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:78:107: order_by_clause
            	    {
            	        this->followPush(FOLLOW_order_by_clause_in_factoring_element442);
            	        order_by_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefactoring_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_factoring_element445);
            if  (this->hasException())
            {
                goto rulefactoring_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:79:10: ( search_clause )?
            {
                int alt12=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case REGULAR_ID:
                    		    	{
                    		    		switch ( this->LA(3) )
                    		    		{
                    		    		    case REGULAR_ID:
                    		    		    	{
                    		    		    		switch ( this->LA(4) )
                    		    		    		{
                    		    		    		    case SQL92_RESERVED_BY:
                    		    		    		    	{
                    		    		    		    		alt12=1;
                    		    		    		    	}
                    		    		    		        break;
                    		    		    		}

                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt12)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:79:10: search_clause
            	    {
            	        this->followPush(FOLLOW_search_clause_in_factoring_element456);
            	        search_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefactoring_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:80:10: ( cycle_clause )?
            {
                int alt13=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		alt13=1;
                    	}
                        break;
                }

                switch (alt13)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:80:10: cycle_clause
            	    {
            	        this->followPush(FOLLOW_cycle_clause_in_factoring_element468);
            	        cycle_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefactoring_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulefactoring_elementEx; /* Prevent compiler warnings */
    rulefactoring_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end factoring_element */

/**
 * $ANTLR start search_clause
 * PLSQL_DMLParser.g:83:1: search_clause : search_key ( depth_key | breadth_key ) first_key by_key column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? ( COMMA column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? )* set_key column_name ;
 */
void
PLSQLParser_PLSQL_DMLParser::search_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:84:5: ( search_key ( depth_key | breadth_key ) first_key by_key column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? ( COMMA column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? )* set_key column_name )
        // PLSQL_DMLParser.g:84:10: search_key ( depth_key | breadth_key ) first_key by_key column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? ( COMMA column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? )* set_key column_name
        {
            this->followPush(FOLLOW_search_key_in_search_clause489);
            m_gPLSQLParser->search_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearch_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:84:21: ( depth_key | breadth_key )
            {
                int alt14=2;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		{
                		    int LA14_1 = this->LA(2);
                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "DEPTH"))))
                		    {
                		        alt14=1;
                		    }
                		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "BREADTH"))))
                		    {
                		        alt14=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 14 );
                		        ex->set_state( 1 );


                		        goto rulesearch_clauseEx;

                		    }
                		}
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 14 );
                    ex->set_state( 0 );


                    goto rulesearch_clauseEx;

                }

                switch (alt14)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:84:23: depth_key
            	    {
            	        this->followPush(FOLLOW_depth_key_in_search_clause493);
            	        m_gPLSQLParser->depth_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:84:35: breadth_key
            	    {
            	        this->followPush(FOLLOW_breadth_key_in_search_clause497);
            	        m_gPLSQLParser->breadth_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_first_key_in_search_clause501);
            m_gPLSQLParser->first_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearch_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_by_key_in_search_clause503);
            m_gPLSQLParser->by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearch_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_search_clause518);
            m_gPLSQLParser->column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearch_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:85:26: ( asc_key )?
            {
                int alt15=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_ASC:
                    	{
                    		alt15=1;
                    	}
                        break;
                }

                switch (alt15)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:85:26: asc_key
            	    {
            	        this->followPush(FOLLOW_asc_key_in_search_clause520);
            	        m_gPLSQLParser->asc_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:85:36: ( desc_key )?
            {
                int alt16=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_DESC:
                    	{
                    		alt16=1;
                    	}
                        break;
                }

                switch (alt16)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:85:36: desc_key
            	    {
            	        this->followPush(FOLLOW_desc_key_in_search_clause524);
            	        m_gPLSQLParser->desc_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:85:47: ( nulls_key first_key )?
            {
                int alt17=2;
                {
                    int LA17_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA17_0 == REGULAR_ID))
                    {
                        {
                            int LA17_1 = this->LA(2);
                            if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA17_1 == REGULAR_ID))
                            {
                                {
                                    int LA17_3 = this->LA(3);
                                    if ( ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))
                                    {
                                        alt17=1;
                                    }
                                }
                            }
                        }
                    }
                }
                switch (alt17)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:85:48: nulls_key first_key
            	    {
            	        this->followPush(FOLLOW_nulls_key_in_search_clause529);
            	        m_gPLSQLParser->nulls_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_first_key_in_search_clause531);
            	        m_gPLSQLParser->first_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:85:70: ( nulls_key last_key )?
            {
                int alt18=2;
                alt18 = cdfa18.predict(this, this->get_rec(), this->get_istream(), cdfa18 );
                if  (this->hasException())
                {
                    goto rulesearch_clauseEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }

                switch (alt18)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:85:71: nulls_key last_key
            	    {
            	        this->followPush(FOLLOW_nulls_key_in_search_clause536);
            	        m_gPLSQLParser->nulls_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_last_key_in_search_clause538);
            	        m_gPLSQLParser->last_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:86:14: ( COMMA column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )? )*

            for (;;)
            {
                int alt23=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt23=1;
                	}
                    break;

                }

                switch (alt23)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:86:15: COMMA column_name ( asc_key )? ( desc_key )? ( nulls_key first_key )? ( nulls_key last_key )?
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_search_clause556);
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_search_clause558);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearch_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:86:33: ( asc_key )?
            	        {
            	            int alt19=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_ASC:
            	                	{
            	                		alt19=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt19)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:86:33: asc_key
            	        	    {
            	        	        this->followPush(FOLLOW_asc_key_in_search_clause560);
            	        	        m_gPLSQLParser->asc_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearch_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQL_DMLParser.g:86:43: ( desc_key )?
            	        {
            	            int alt20=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_DESC:
            	                	{
            	                		alt20=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt20)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:86:43: desc_key
            	        	    {
            	        	        this->followPush(FOLLOW_desc_key_in_search_clause564);
            	        	        m_gPLSQLParser->desc_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearch_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQL_DMLParser.g:86:54: ( nulls_key first_key )?
            	        {
            	            int alt21=2;
            	            {
            	                int LA21_0 = this->LA(1);
            	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA21_0 == REGULAR_ID))
            	                {
            	                    {
            	                        int LA21_1 = this->LA(2);
            	                        if ( ((((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))) && (LA21_1 == REGULAR_ID))
            	                        {
            	                            {
            	                                int LA21_3 = this->LA(3);
            	                                if ( ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))
            	                                {
            	                                    alt21=1;
            	                                }
            	                            }
            	                        }
            	                    }
            	                }
            	            }
            	            switch (alt21)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:86:55: nulls_key first_key
            	        	    {
            	        	        this->followPush(FOLLOW_nulls_key_in_search_clause569);
            	        	        m_gPLSQLParser->nulls_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearch_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_first_key_in_search_clause571);
            	        	        m_gPLSQLParser->first_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearch_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQL_DMLParser.g:86:77: ( nulls_key last_key )?
            	        {
            	            int alt22=2;
            	            alt22 = cdfa22.predict(this, this->get_rec(), this->get_istream(), cdfa22 );
            	            if  (this->hasException())
            	            {
            	                goto rulesearch_clauseEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }

            	            switch (alt22)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:86:78: nulls_key last_key
            	        	    {
            	        	        this->followPush(FOLLOW_nulls_key_in_search_clause576);
            	        	        m_gPLSQLParser->nulls_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearch_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_last_key_in_search_clause578);
            	        	        m_gPLSQLParser->last_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesearch_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop23;	/* break out of the loop */
            	    break;
                }
            }
            loop23: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_set_key_in_search_clause598);
            m_gPLSQLParser->set_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearch_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_search_clause600);
            m_gPLSQLParser->column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearch_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesearch_clauseEx; /* Prevent compiler warnings */
    rulesearch_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end search_clause */

/**
 * $ANTLR start cycle_clause
 * PLSQL_DMLParser.g:90:1: cycle_clause : cycle_key column_name ( COMMA column_name )* set_key column_name to_key expression default_key expression ;
 */
void
PLSQLParser_PLSQL_DMLParser::cycle_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:91:5: ( cycle_key column_name ( COMMA column_name )* set_key column_name to_key expression default_key expression )
        // PLSQL_DMLParser.g:91:10: cycle_key column_name ( COMMA column_name )* set_key column_name to_key expression default_key expression
        {
            this->followPush(FOLLOW_cycle_key_in_cycle_clause620);
            m_gPLSQLParser->cycle_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_cycle_clause622);
            m_gPLSQLParser->column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:91:32: ( COMMA column_name )*

            for (;;)
            {
                int alt24=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt24=1;
                	}
                    break;

                }

                switch (alt24)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:91:34: COMMA column_name
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_cycle_clause626);
            	        if  (this->hasException())
            	        {
            	            goto rulecycle_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_cycle_clause628);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecycle_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop24;	/* break out of the loop */
            	    break;
                }
            }
            loop24: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_set_key_in_cycle_clause632);
            m_gPLSQLParser->set_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_cycle_clause634);
            m_gPLSQLParser->column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_to_key_in_cycle_clause636);
            m_gPLSQLParser->to_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_cycle_clause638);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_default_key_in_cycle_clause640);
            m_gPLSQLParser->default_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_cycle_clause642);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecycle_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecycle_clauseEx; /* Prevent compiler warnings */
    rulecycle_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cycle_clause */

/**
 * $ANTLR start subquery
 * PLSQL_DMLParser.g:94:1: subquery : subquery_basic_elements ( subquery_operation_part )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::subquery()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:95:5: ( subquery_basic_elements ( subquery_operation_part )* )
        // PLSQL_DMLParser.g:95:10: subquery_basic_elements ( subquery_operation_part )*
        {
            this->followPush(FOLLOW_subquery_basic_elements_in_subquery662);
            subquery_basic_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubqueryEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:95:34: ( subquery_operation_part )*

            for (;;)
            {
                int alt25=2;
                switch ( this->LA(1) )
                {
                case PLSQL_RESERVED_MINUS:
                case SQL92_RESERVED_INTERSECT:
                case SQL92_RESERVED_UNION:
                	{
                		alt25=1;
                	}
                    break;

                }

                switch (alt25)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:95:34: subquery_operation_part
            	    {
            	        this->followPush(FOLLOW_subquery_operation_part_in_subquery664);
            	        subquery_operation_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubqueryEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop25;	/* break out of the loop */
            	    break;
                }
            }
            loop25: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubqueryEx; /* Prevent compiler warnings */
    rulesubqueryEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end subquery */

/**
 * $ANTLR start subquery_operation_part
 * PLSQL_DMLParser.g:98:1: subquery_operation_part : ( union_key ( all_key )? | intersect_key | minus_key ) subquery_basic_elements ;
 */
void
PLSQLParser_PLSQL_DMLParser::subquery_operation_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:99:5: ( ( union_key ( all_key )? | intersect_key | minus_key ) subquery_basic_elements )
        // PLSQL_DMLParser.g:99:10: ( union_key ( all_key )? | intersect_key | minus_key ) subquery_basic_elements
        {
            // PLSQL_DMLParser.g:99:10: ( union_key ( all_key )? | intersect_key | minus_key )
            {
                int alt27=3;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_UNION:
                	{
                		alt27=1;
                	}
                    break;
                case SQL92_RESERVED_INTERSECT:
                	{
                		alt27=2;
                	}
                    break;
                case PLSQL_RESERVED_MINUS:
                	{
                		alt27=3;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 27 );
                    ex->set_state( 0 );


                    goto rulesubquery_operation_partEx;

                }

                switch (alt27)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:99:11: union_key ( all_key )?
            	    {
            	        this->followPush(FOLLOW_union_key_in_subquery_operation_part686);
            	        m_gPLSQLParser->union_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_operation_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:99:21: ( all_key )?
            	        {
            	            int alt26=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_ALL:
            	                	{
            	                		alt26=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt26)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:99:21: all_key
            	        	    {
            	        	        this->followPush(FOLLOW_all_key_in_subquery_operation_part688);
            	        	        m_gPLSQLParser->all_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesubquery_operation_partEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:99:30: intersect_key
            	    {
            	        this->followPush(FOLLOW_intersect_key_in_subquery_operation_part691);
            	        m_gPLSQLParser->intersect_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_operation_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQL_DMLParser.g:99:44: minus_key
            	    {
            	        this->followPush(FOLLOW_minus_key_in_subquery_operation_part693);
            	        m_gPLSQLParser->minus_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_operation_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_subquery_basic_elements_in_subquery_operation_part696);
            subquery_basic_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubquery_operation_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubquery_operation_partEx; /* Prevent compiler warnings */
    rulesubquery_operation_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end subquery_operation_part */

/**
 * $ANTLR start subquery_basic_elements
 * PLSQL_DMLParser.g:102:1: subquery_basic_elements : ( query_block | LEFT_PAREN subquery RIGHT_PAREN );
 */
void
PLSQLParser_PLSQL_DMLParser::subquery_basic_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:103:5: ( query_block | LEFT_PAREN subquery RIGHT_PAREN )

            ANTLR_UINT32 alt28;

            alt28=2;

            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_SELECT:
            	{
            		alt28=1;
            	}
                break;
            case LEFT_PAREN:
            	{
            		alt28=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 28 );
                ex->set_state( 0 );


                goto rulesubquery_basic_elementsEx;

            }

            switch (alt28)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:103:10: query_block
        	    {
        	        this->followPush(FOLLOW_query_block_in_subquery_basic_elements716);
        	        query_block();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesubquery_basic_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:104:10: LEFT_PAREN subquery RIGHT_PAREN
        	    {
        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_subquery_basic_elements727);
        	        if  (this->hasException())
        	        {
        	            goto rulesubquery_basic_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_subquery_in_subquery_basic_elements729);
        	        subquery();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesubquery_basic_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_subquery_basic_elements731);
        	        if  (this->hasException())
        	        {
        	            goto rulesubquery_basic_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesubquery_basic_elementsEx; /* Prevent compiler warnings */
    rulesubquery_basic_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end subquery_basic_elements */

/**
 * $ANTLR start query_block
 * PLSQL_DMLParser.g:107:1: query_block : select_key ( ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key ) )? ( ASTERISK | selected_element ( COMMA selected_element )* ) ( into_clause )? from_clause ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::query_block()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:108:5: ( select_key ( ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key ) )? ( ASTERISK | selected_element ( COMMA selected_element )* ) ( into_clause )? from_clause ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )? )
        // PLSQL_DMLParser.g:108:10: select_key ( ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key ) )? ( ASTERISK | selected_element ( COMMA selected_element )* ) ( into_clause )? from_clause ( where_clause )? ( hierarchical_query_clause )? ( group_by_clause )? ( model_clause )?
        {
            this->followPush(FOLLOW_select_key_in_query_block751);
            m_gPLSQLParser->select_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulequery_blockEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:109:9: ( ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key ) )?
            {
                int alt30=2;
                {
                    int LA30_0 = this->LA(1);
                    if ( (LA30_0 == SQL92_RESERVED_DISTINCT))
                    {
                        {
                            int LA30_1 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred2_PLSQL_DMLParser>() )))
                            {
                                alt30=1;
                            }
                        }
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred2_PLSQL_DMLParser>() )) && (LA30_0 == SQL92_RESERVED_UNIQUE))
                    {
                        alt30=1;
                    }
                    else if ( (LA30_0 == SQL92_RESERVED_ALL))
                    {
                        {
                            int LA30_3 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred2_PLSQL_DMLParser>() )))
                            {
                                alt30=1;
                            }
                        }
                    }
                }
                switch (alt30)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:109:10: ( distinct_key | unique_key | all_key )=> ( distinct_key | unique_key | all_key )
            	    {
            	        // PLSQL_DMLParser.g:109:46: ( distinct_key | unique_key | all_key )
            	        {
            	            int alt29=3;
            	            switch ( this->LA(1) )
            	            {
            	            case SQL92_RESERVED_DISTINCT:
            	            	{
            	            		alt29=1;
            	            	}
            	                break;
            	            case SQL92_RESERVED_UNIQUE:
            	            	{
            	            		alt29=2;
            	            	}
            	                break;
            	            case SQL92_RESERVED_ALL:
            	            	{
            	            		alt29=3;
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return ;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 29 );
            	                ex->set_state( 0 );


            	                goto rulequery_blockEx;

            	            }

            	            switch (alt29)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:109:47: distinct_key
            	        	    {
            	        	        this->followPush(FOLLOW_distinct_key_in_query_block772);
            	        	        m_gPLSQLParser->distinct_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulequery_blockEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:109:60: unique_key
            	        	    {
            	        	        this->followPush(FOLLOW_unique_key_in_query_block774);
            	        	        m_gPLSQLParser->unique_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulequery_blockEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // PLSQL_DMLParser.g:109:71: all_key
            	        	    {
            	        	        this->followPush(FOLLOW_all_key_in_query_block776);
            	        	        m_gPLSQLParser->all_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulequery_blockEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:110:9: ( ASTERISK | selected_element ( COMMA selected_element )* )
            {
                int alt32=2;
                switch ( this->LA(1) )
                {
                case ASTERISK:
                	{
                		alt32=1;
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case DELIMITED_ID:
                case EXACT_NUM_LIT:
                case INTRODUCER:
                case LEFT_PAREN:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case REGULAR_ID:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURSOR:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt32=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 32 );
                    ex->set_state( 0 );


                    goto rulequery_blockEx;

                }

                switch (alt32)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:110:10: ASTERISK
            	    {
            	         this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_query_block790);
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:110:21: selected_element ( COMMA selected_element )*
            	    {
            	        this->followPush(FOLLOW_selected_element_in_query_block794);
            	        selected_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:110:38: ( COMMA selected_element )*

            	        for (;;)
            	        {
            	            int alt31=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt31=1;
            	            	}
            	                break;

            	            }

            	            switch (alt31)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:110:39: COMMA selected_element
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_query_block797);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulequery_blockEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_selected_element_in_query_block799);
            	        	        selected_element();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulequery_blockEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop31;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop31: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:111:9: ( into_clause )?
            {
                int alt33=2;
                {
                    int LA33_0 = this->LA(1);
                    if ( (LA33_0 == SQL92_RESERVED_INTO))
                    {
                        alt33=1;
                    }
                    else if ( ((equalsIgnoreCase(LT(1)->getText(), "BULK"))) && (LA33_0 == REGULAR_ID))
                    {
                        alt33=1;
                    }
                }
                switch (alt33)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:111:9: into_clause
            	    {
            	        this->followPush(FOLLOW_into_clause_in_query_block812);
            	        m_gPLSQLParser->into_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_from_clause_in_query_block823);
            from_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulequery_blockEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:113:9: ( where_clause )?
            {
                int alt34=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_WHERE:
                    	{
                    		alt34=1;
                    	}
                        break;
                }

                switch (alt34)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:113:9: where_clause
            	    {
            	        this->followPush(FOLLOW_where_clause_in_query_block834);
            	        m_gPLSQLParser->where_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:114:9: ( hierarchical_query_clause )?
            {
                int alt35=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_CONNECT:
                    	{
                    		alt35=1;
                    	}
                        break;
                    case PLSQL_RESERVED_START:
                    	{
                    		alt35=1;
                    	}
                        break;
                }

                switch (alt35)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:114:9: hierarchical_query_clause
            	    {
            	        this->followPush(FOLLOW_hierarchical_query_clause_in_query_block846);
            	        hierarchical_query_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:115:9: ( group_by_clause )?
            {
                int alt36=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_GROUP:
                    	{
                    		alt36=1;
                    	}
                        break;
                    case SQL92_RESERVED_HAVING:
                    	{
                    		alt36=1;
                    	}
                        break;
                }

                switch (alt36)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:115:9: group_by_clause
            	    {
            	        this->followPush(FOLLOW_group_by_clause_in_query_block858);
            	        group_by_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:116:9: ( model_clause )?
            {
                int alt37=2;
                switch ( this->LA(1) )
                {
                    case PLSQL_NON_RESERVED_MODEL:
                    	{
                    		alt37=1;
                    	}
                        break;
                }

                switch (alt37)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:116:9: model_clause
            	    {
            	        this->followPush(FOLLOW_model_clause_in_query_block869);
            	        model_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_blockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulequery_blockEx; /* Prevent compiler warnings */
    rulequery_blockEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end query_block */

/**
 * $ANTLR start selected_element
 * PLSQL_DMLParser.g:119:1: selected_element : select_list_elements ( column_alias )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::selected_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:120:5: ( select_list_elements ( column_alias )? )
        // PLSQL_DMLParser.g:120:10: select_list_elements ( column_alias )?
        {
            this->followPush(FOLLOW_select_list_elements_in_selected_element890);
            select_list_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleselected_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:120:31: ( column_alias )?
            {
                int alt38=2;
                switch ( this->LA(1) )
                {
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case DELIMITED_ID:
                    case INTRODUCER:
                    case NATIONAL_CHAR_STRING_LIT:
                    case SQL92_RESERVED_AS:
                    	{
                    		alt38=1;
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case COMMA:
                    		    case SQL92_RESERVED_FROM:
                    		    case SQL92_RESERVED_INTO:
                    		    	{
                    		    		alt38=1;
                    		    	}
                    		        break;
                    		    case REGULAR_ID:
                    		    	{
                    		    		switch ( this->LA(3) )
                    		    		{
                    		    		    case REGULAR_ID:
                    		    		    	{
                    		    		    		alt38=1;
                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt38)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:120:31: column_alias
            	    {
            	        this->followPush(FOLLOW_column_alias_in_selected_element892);
            	        m_gPLSQLParser->column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleselected_elementEx; /* Prevent compiler warnings */
    ruleselected_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end selected_element */

/**
 * $ANTLR start from_clause
 * PLSQL_DMLParser.g:123:1: from_clause : from_key table_ref_list ;
 */
void
PLSQLParser_PLSQL_DMLParser::from_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:124:5: ( from_key table_ref_list )
        // PLSQL_DMLParser.g:124:10: from_key table_ref_list
        {
            this->followPush(FOLLOW_from_key_in_from_clause913);
            m_gPLSQLParser->from_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefrom_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_table_ref_list_in_from_clause915);
            table_ref_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefrom_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefrom_clauseEx; /* Prevent compiler warnings */
    rulefrom_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end from_clause */

/**
 * $ANTLR start select_list_elements
 * PLSQL_DMLParser.g:127:1: select_list_elements : ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK | expression );
 */
void
PLSQLParser_PLSQL_DMLParser::select_list_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:128:5: ( ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK | expression )

            ANTLR_UINT32 alt39;

            alt39=2;

            switch ( this->LA(1) )
            {
            case INTRODUCER:
            	{
            		{
            		    int LA39_1 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_PLSQL_DMLParser>() )))
            		    {
            		        alt39=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt39=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 39 );
            		        ex->set_state( 1 );


            		        goto ruleselect_list_elementsEx;

            		    }
            		}
            	}
                break;
            case REGULAR_ID:
            	{
            		{
            		    int LA39_2 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_PLSQL_DMLParser>() )))
            		    {
            		        alt39=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt39=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 39 );
            		        ex->set_state( 2 );


            		        goto ruleselect_list_elementsEx;

            		    }
            		}
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case EXACT_NUM_LIT:
            case LEFT_PAREN:
            case MINUS_SIGN:
            case NATIONAL_CHAR_STRING_LIT:
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            case PLUS_SIGN:
            case SQL92_RESERVED_ALL:
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_CASE:
            case SQL92_RESERVED_CURSOR:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_DISTINCT:
            case SQL92_RESERVED_EXISTS:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NOT:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_PRIOR:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt39=2;
            	}
                break;
            case DELIMITED_ID:
            	{
            		{
            		    int LA39_9 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_PLSQL_DMLParser>() )))
            		    {
            		        alt39=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt39=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 39 );
            		        ex->set_state( 9 );


            		        goto ruleselect_list_elementsEx;

            		    }
            		}
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 39 );
                ex->set_state( 0 );


                goto ruleselect_list_elementsEx;

            }

            switch (alt39)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:128:10: ( tableview_name PERIOD ASTERISK )=> tableview_name PERIOD ASTERISK
        	    {
        	        this->followPush(FOLLOW_tableview_name_in_select_list_elements944);
        	        m_gPLSQLParser->tableview_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleselect_list_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_select_list_elements946);
        	        if  (this->hasException())
        	        {
        	            goto ruleselect_list_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_select_list_elements948);
        	        if  (this->hasException())
        	        {
        	            goto ruleselect_list_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:129:10: expression
        	    {
        	        this->followPush(FOLLOW_expression_in_select_list_elements959);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleselect_list_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleselect_list_elementsEx; /* Prevent compiler warnings */
    ruleselect_list_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end select_list_elements */

/**
 * $ANTLR start table_ref_list
 * PLSQL_DMLParser.g:132:1: table_ref_list : table_ref ( COMMA table_ref )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::table_ref_list()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:133:5: ( table_ref ( COMMA table_ref )* )
        // PLSQL_DMLParser.g:133:10: table_ref ( COMMA table_ref )*
        {
            this->followPush(FOLLOW_table_ref_in_table_ref_list979);
            table_ref();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_ref_listEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:133:20: ( COMMA table_ref )*

            for (;;)
            {
                int alt40=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt40=1;
                	}
                    break;

                }

                switch (alt40)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:133:21: COMMA table_ref
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_table_ref_list982);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_table_ref_in_table_ref_list984);
            	        table_ref();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop40;	/* break out of the loop */
            	    break;
                }
            }
            loop40: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_ref_listEx; /* Prevent compiler warnings */
    ruletable_ref_listEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_ref_list */

/**
 * $ANTLR start table_ref
 * PLSQL_DMLParser.g:140:1: table_ref : table_ref_aux ( join_clause )* ( pivot_clause | unpivot_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::table_ref()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:141:5: ( table_ref_aux ( join_clause )* ( pivot_clause | unpivot_clause )? )
        // PLSQL_DMLParser.g:141:10: table_ref_aux ( join_clause )* ( pivot_clause | unpivot_clause )?
        {
            this->followPush(FOLLOW_table_ref_aux_in_table_ref1010);
            table_ref_aux();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletable_refEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:141:24: ( join_clause )*

            for (;;)
            {
                int alt41=2;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    int LA41_2 = this->LA(2);
                		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "FULL")))||((equalsIgnoreCase(LT(1)->getText(), "JOIN")))||((equalsIgnoreCase(LT(1)->getText(), "RIGHT")))||((equalsIgnoreCase(LT(1)->getText(), "INNER")))||((equalsIgnoreCase(LT(1)->getText(), "PARTITION")))||((equalsIgnoreCase(LT(1)->getText(), "LEFT")))||((equalsIgnoreCase(LT(1)->getText(), "CROSS")))||((equalsIgnoreCase(LT(1)->getText(), "NATURAL"))))))
                		    {
                		        alt41=1;
                		    }

                		}
                	}
                    break;

                }

                switch (alt41)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:141:24: join_clause
            	    {
            	        this->followPush(FOLLOW_join_clause_in_table_ref1012);
            	        join_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop41;	/* break out of the loop */
            	    break;
                }
            }
            loop41: ; /* Jump out to here if this rule does not match */


            // PLSQL_DMLParser.g:141:37: ( pivot_clause | unpivot_clause )?
            {
                int alt42=3;
                switch ( this->LA(1) )
                {
                    case PLSQL_NON_RESERVED_PIVOT:
                    	{
                    		alt42=1;
                    	}
                        break;
                    case PLSQL_NON_RESERVED_UNPIVOT:
                    	{
                    		alt42=2;
                    	}
                        break;
                }

                switch (alt42)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:141:38: pivot_clause
            	    {
            	        this->followPush(FOLLOW_pivot_clause_in_table_ref1016);
            	        pivot_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:141:51: unpivot_clause
            	    {
            	        this->followPush(FOLLOW_unpivot_clause_in_table_ref1018);
            	        unpivot_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_refEx; /* Prevent compiler warnings */
    ruletable_refEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_ref */

/**
 * $ANTLR start table_ref_aux
 * PLSQL_DMLParser.g:144:1: table_ref_aux : ( ( LEFT_PAREN ( select_key | with_key ) )=> dml_table_expression_clause ( pivot_clause | unpivot_clause )? | ( LEFT_PAREN )=> LEFT_PAREN table_ref ( subquery_operation_part )* RIGHT_PAREN ( pivot_clause | unpivot_clause )? | ( only_key LEFT_PAREN )=> only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN | dml_table_expression_clause ( pivot_clause | unpivot_clause )? ) ( flashback_query_clause )* ({...}? table_alias )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::table_ref_aux()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:145:5: ( ( ( LEFT_PAREN ( select_key | with_key ) )=> dml_table_expression_clause ( pivot_clause | unpivot_clause )? | ( LEFT_PAREN )=> LEFT_PAREN table_ref ( subquery_operation_part )* RIGHT_PAREN ( pivot_clause | unpivot_clause )? | ( only_key LEFT_PAREN )=> only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN | dml_table_expression_clause ( pivot_clause | unpivot_clause )? ) ( flashback_query_clause )* ({...}? table_alias )? )
        // PLSQL_DMLParser.g:146:5: ( ( LEFT_PAREN ( select_key | with_key ) )=> dml_table_expression_clause ( pivot_clause | unpivot_clause )? | ( LEFT_PAREN )=> LEFT_PAREN table_ref ( subquery_operation_part )* RIGHT_PAREN ( pivot_clause | unpivot_clause )? | ( only_key LEFT_PAREN )=> only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN | dml_table_expression_clause ( pivot_clause | unpivot_clause )? ) ( flashback_query_clause )* ({...}? table_alias )?
        {
            // PLSQL_DMLParser.g:146:5: ( ( LEFT_PAREN ( select_key | with_key ) )=> dml_table_expression_clause ( pivot_clause | unpivot_clause )? | ( LEFT_PAREN )=> LEFT_PAREN table_ref ( subquery_operation_part )* RIGHT_PAREN ( pivot_clause | unpivot_clause )? | ( only_key LEFT_PAREN )=> only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN | dml_table_expression_clause ( pivot_clause | unpivot_clause )? )
            {
                int alt47=4;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_TABLE:
                	{
                		{
                		    int LA47_1 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_PLSQL_DMLParser>() )))
                		    {
                		        alt47=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt47=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 47 );
                		        ex->set_state( 1 );


                		        goto ruletable_ref_auxEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_THE:
                	{
                		{
                		    int LA47_2 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_PLSQL_DMLParser>() )))
                		    {
                		        alt47=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt47=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 47 );
                		        ex->set_state( 2 );


                		        goto ruletable_ref_auxEx;

                		    }
                		}
                	}
                    break;
                case LEFT_PAREN:
                	{
                		{
                		    int LA47_3 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_PLSQL_DMLParser>() )))
                		    {
                		        alt47=1;
                		    }
                		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred5_PLSQL_DMLParser>() )))
                		    {
                		        alt47=2;
                		    }
                		    else if ( (true))
                		    {
                		        alt47=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 47 );
                		        ex->set_state( 3 );


                		        goto ruletable_ref_auxEx;

                		    }
                		}
                	}
                    break;
                case INTRODUCER:
                	{
                		{
                		    int LA47_4 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_PLSQL_DMLParser>() )))
                		    {
                		        alt47=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt47=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 47 );
                		        ex->set_state( 4 );


                		        goto ruletable_ref_auxEx;

                		    }
                		}
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    int LA47_5 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_PLSQL_DMLParser>() )))
                		    {
                		        alt47=1;
                		    }
                		    else if ( (( (this->msynpred( antlr3::ClassForwarder<synpred6_PLSQL_DMLParser>() )) && ((equalsIgnoreCase(LT(1)->getText(), "ONLY"))) )))
                		    {
                		        alt47=3;
                		    }
                		    else if ( (true))
                		    {
                		        alt47=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 47 );
                		        ex->set_state( 5 );


                		        goto ruletable_ref_auxEx;

                		    }
                		}
                	}
                    break;
                case DELIMITED_ID:
                	{
                		{
                		    int LA47_6 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred4_PLSQL_DMLParser>() )))
                		    {
                		        alt47=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt47=4;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 47 );
                		        ex->set_state( 6 );


                		        goto ruletable_ref_auxEx;

                		    }
                		}
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 47 );
                    ex->set_state( 0 );


                    goto ruletable_ref_auxEx;

                }

                switch (alt47)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:146:10: ( LEFT_PAREN ( select_key | with_key ) )=> dml_table_expression_clause ( pivot_clause | unpivot_clause )?
            	    {
            	        this->followPush(FOLLOW_dml_table_expression_clause_in_table_ref_aux1058);
            	        dml_table_expression_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:146:76: ( pivot_clause | unpivot_clause )?
            	        {
            	            int alt43=3;
            	            switch ( this->LA(1) )
            	            {
            	                case PLSQL_NON_RESERVED_PIVOT:
            	                	{
            	                		alt43=1;
            	                	}
            	                    break;
            	                case PLSQL_NON_RESERVED_UNPIVOT:
            	                	{
            	                		alt43=2;
            	                	}
            	                    break;
            	            }

            	            switch (alt43)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:146:77: pivot_clause
            	        	    {
            	        	        this->followPush(FOLLOW_pivot_clause_in_table_ref_aux1061);
            	        	        pivot_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletable_ref_auxEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:146:90: unpivot_clause
            	        	    {
            	        	        this->followPush(FOLLOW_unpivot_clause_in_table_ref_aux1063);
            	        	        unpivot_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletable_ref_auxEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:147:10: ( LEFT_PAREN )=> LEFT_PAREN table_ref ( subquery_operation_part )* RIGHT_PAREN ( pivot_clause | unpivot_clause )?
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_table_ref_aux1082);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_table_ref_in_table_ref_aux1084);
            	        table_ref();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:147:47: ( subquery_operation_part )*

            	        for (;;)
            	        {
            	            int alt44=2;
            	            switch ( this->LA(1) )
            	            {
            	            case PLSQL_RESERVED_MINUS:
            	            case SQL92_RESERVED_INTERSECT:
            	            case SQL92_RESERVED_UNION:
            	            	{
            	            		alt44=1;
            	            	}
            	                break;

            	            }

            	            switch (alt44)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:147:47: subquery_operation_part
            	        	    {
            	        	        this->followPush(FOLLOW_subquery_operation_part_in_table_ref_aux1086);
            	        	        subquery_operation_part();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletable_ref_auxEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop44;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop44: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_table_ref_aux1089);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:147:84: ( pivot_clause | unpivot_clause )?
            	        {
            	            int alt45=3;
            	            switch ( this->LA(1) )
            	            {
            	                case PLSQL_NON_RESERVED_PIVOT:
            	                	{
            	                		alt45=1;
            	                	}
            	                    break;
            	                case PLSQL_NON_RESERVED_UNPIVOT:
            	                	{
            	                		alt45=2;
            	                	}
            	                    break;
            	            }

            	            switch (alt45)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:147:85: pivot_clause
            	        	    {
            	        	        this->followPush(FOLLOW_pivot_clause_in_table_ref_aux1092);
            	        	        pivot_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletable_ref_auxEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:147:98: unpivot_clause
            	        	    {
            	        	        this->followPush(FOLLOW_unpivot_clause_in_table_ref_aux1094);
            	        	        unpivot_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletable_ref_auxEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 3:
            	    // PLSQL_DMLParser.g:148:10: ( only_key LEFT_PAREN )=> only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN
            	    {
            	        this->followPush(FOLLOW_only_key_in_table_ref_aux1115);
            	        m_gPLSQLParser->only_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_table_ref_aux1117);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_dml_table_expression_clause_in_table_ref_aux1119);
            	        dml_table_expression_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_table_ref_aux1121);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 4:
            	    // PLSQL_DMLParser.g:149:10: dml_table_expression_clause ( pivot_clause | unpivot_clause )?
            	    {
            	        this->followPush(FOLLOW_dml_table_expression_clause_in_table_ref_aux1132);
            	        dml_table_expression_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:149:38: ( pivot_clause | unpivot_clause )?
            	        {
            	            int alt46=3;
            	            switch ( this->LA(1) )
            	            {
            	                case PLSQL_NON_RESERVED_PIVOT:
            	                	{
            	                		alt46=1;
            	                	}
            	                    break;
            	                case PLSQL_NON_RESERVED_UNPIVOT:
            	                	{
            	                		alt46=2;
            	                	}
            	                    break;
            	            }

            	            switch (alt46)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:149:39: pivot_clause
            	        	    {
            	        	        this->followPush(FOLLOW_pivot_clause_in_table_ref_aux1135);
            	        	        pivot_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletable_ref_auxEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:149:52: unpivot_clause
            	        	    {
            	        	        this->followPush(FOLLOW_unpivot_clause_in_table_ref_aux1137);
            	        	        unpivot_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruletable_ref_auxEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:151:9: ( flashback_query_clause )*

            for (;;)
            {
                int alt48=2;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    int LA48_2 = this->LA(2);
                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "VERSIONS"))))
                		    {
                		        alt48=1;
                		    }

                		}
                	}
                    break;
                case SQL92_RESERVED_AS:
                	{
                		alt48=1;
                	}
                    break;

                }

                switch (alt48)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:151:9: flashback_query_clause
            	    {
            	        this->followPush(FOLLOW_flashback_query_clause_in_table_ref_aux1155);
            	        flashback_query_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop48;	/* break out of the loop */
            	    break;
                }
            }
            loop48: ; /* Jump out to here if this rule does not match */


            // PLSQL_DMLParser.g:152:9: ({...}? table_alias )?
            {
                int alt49=2;
                switch ( this->LA(1) )
                {
                    case INTRODUCER:
                    	{
                    		{
                    		    int LA49_1 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt49=1;
                    		    }
                    		}
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA49_2 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt49=1;
                    		    }
                    		}
                    	}
                        break;
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case NATIONAL_CHAR_STRING_LIT:
                    	{
                    		{
                    		    int LA49_3 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt49=1;
                    		    }
                    		}
                    	}
                        break;
                    case DELIMITED_ID:
                    	{
                    		{
                    		    int LA49_4 = this->LA(2);
                    		    if ( ((isTableAlias(LT(1), LT(2)))))
                    		    {
                    		        alt49=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt49)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:152:10: {...}? table_alias
            	    {
            	        if ( !((isTableAlias(LT(1), LT(2)))) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return ;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "isTableAlias(LT(1), LT(2))" );
            	                ex->set_ruleName( "table_ref_aux" );


            	        }

            	        this->followPush(FOLLOW_table_alias_in_table_ref_aux1169);
            	        m_gPLSQLParser->table_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_ref_auxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_ref_auxEx; /* Prevent compiler warnings */
    ruletable_ref_auxEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_ref_aux */

/**
 * $ANTLR start join_clause
 * PLSQL_DMLParser.g:155:1: join_clause : ( query_partition_clause )? ( cross_key | natural_key )? ( inner_key | outer_join_type )? join_key table_ref_aux ( query_partition_clause )? ( join_on_part | join_using_part )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::join_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:156:5: ( ( query_partition_clause )? ( cross_key | natural_key )? ( inner_key | outer_join_type )? join_key table_ref_aux ( query_partition_clause )? ( join_on_part | join_using_part )* )
        // PLSQL_DMLParser.g:156:10: ( query_partition_clause )? ( cross_key | natural_key )? ( inner_key | outer_join_type )? join_key table_ref_aux ( query_partition_clause )? ( join_on_part | join_using_part )*
        {
            // PLSQL_DMLParser.g:156:10: ( query_partition_clause )?
            {
                int alt50=2;
                {
                    int LA50_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "FULL")))||((equalsIgnoreCase(LT(1)->getText(), "JOIN")))||((equalsIgnoreCase(LT(1)->getText(), "RIGHT")))||((equalsIgnoreCase(LT(1)->getText(), "INNER")))||((equalsIgnoreCase(LT(1)->getText(), "PARTITION")))||((equalsIgnoreCase(LT(1)->getText(), "CROSS")))||((equalsIgnoreCase(LT(1)->getText(), "LEFT")))||((equalsIgnoreCase(LT(1)->getText(), "NATURAL"))))) && (LA50_0 == REGULAR_ID))
                    {
                        {
                            int LA50_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "PARTITION"))) && (LA50_1 == SQL92_RESERVED_BY))
                            {
                                alt50=1;
                            }
                        }
                    }
                }
                switch (alt50)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:156:10: query_partition_clause
            	    {
            	        this->followPush(FOLLOW_query_partition_clause_in_join_clause1191);
            	        query_partition_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:157:9: ( cross_key | natural_key )?
            {
                int alt51=3;
                {
                    int LA51_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "FULL")))||((equalsIgnoreCase(LT(1)->getText(), "JOIN")))||((equalsIgnoreCase(LT(1)->getText(), "RIGHT")))||((equalsIgnoreCase(LT(1)->getText(), "INNER")))||((equalsIgnoreCase(LT(1)->getText(), "LEFT")))||((equalsIgnoreCase(LT(1)->getText(), "CROSS")))||((equalsIgnoreCase(LT(1)->getText(), "NATURAL"))))) && (LA51_0 == REGULAR_ID))
                    {
                        {
                            int LA51_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "CROSS"))))
                            {
                                alt51=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "NATURAL"))))
                            {
                                alt51=2;
                            }
                        }
                    }
                }
                switch (alt51)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:157:10: cross_key
            	    {
            	        this->followPush(FOLLOW_cross_key_in_join_clause1203);
            	        m_gPLSQLParser->cross_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:157:20: natural_key
            	    {
            	        this->followPush(FOLLOW_natural_key_in_join_clause1205);
            	        m_gPLSQLParser->natural_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:157:34: ( inner_key | outer_join_type )?
            {
                int alt52=3;
                {
                    int LA52_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "FULL")))||((equalsIgnoreCase(LT(1)->getText(), "JOIN")))||((equalsIgnoreCase(LT(1)->getText(), "RIGHT")))||((equalsIgnoreCase(LT(1)->getText(), "INNER")))||((equalsIgnoreCase(LT(1)->getText(), "LEFT"))))) && (LA52_0 == REGULAR_ID))
                    {
                        {
                            int LA52_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "INNER"))))
                            {
                                alt52=1;
                            }
                            else if ( ((((equalsIgnoreCase(LT(1)->getText(), "FULL")))||((equalsIgnoreCase(LT(1)->getText(), "RIGHT")))||((equalsIgnoreCase(LT(1)->getText(), "LEFT"))))))
                            {
                                alt52=2;
                            }
                        }
                    }
                }
                switch (alt52)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:157:35: inner_key
            	    {
            	        this->followPush(FOLLOW_inner_key_in_join_clause1210);
            	        m_gPLSQLParser->inner_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:157:45: outer_join_type
            	    {
            	        this->followPush(FOLLOW_outer_join_type_in_join_clause1212);
            	        outer_join_type();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_join_key_in_join_clause1216);
            m_gPLSQLParser->join_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejoin_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_table_ref_aux_in_join_clause1226);
            table_ref_aux();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejoin_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:159:9: ( query_partition_clause )?
            {
                int alt53=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA53_1 = this->LA(2);
                    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "PARTITION"))))
                    		    {
                    		        alt53=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt53)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:159:9: query_partition_clause
            	    {
            	        this->followPush(FOLLOW_query_partition_clause_in_join_clause1236);
            	        query_partition_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:160:5: ( join_on_part | join_using_part )*

            for (;;)
            {
                int alt54=3;
                switch ( this->LA(1) )
                {
                case PLSQL_NON_RESERVED_USING:
                	{
                		alt54=2;
                	}
                    break;
                case SQL92_RESERVED_ON:
                	{
                		alt54=1;
                	}
                    break;

                }

                switch (alt54)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:160:10: join_on_part
            	    {
            	        this->followPush(FOLLOW_join_on_part_in_join_clause1248);
            	        join_on_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:161:10: join_using_part
            	    {
            	        this->followPush(FOLLOW_join_using_part_in_join_clause1259);
            	        join_using_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop54;	/* break out of the loop */
            	    break;
                }
            }
            loop54: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulejoin_clauseEx; /* Prevent compiler warnings */
    rulejoin_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end join_clause */

/**
 * $ANTLR start join_on_part
 * PLSQL_DMLParser.g:165:1: join_on_part : on_key condition ;
 */
void
PLSQLParser_PLSQL_DMLParser::join_on_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:166:5: ( on_key condition )
        // PLSQL_DMLParser.g:166:10: on_key condition
        {
            this->followPush(FOLLOW_on_key_in_join_on_part1286);
            m_gPLSQLParser->on_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejoin_on_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_condition_in_join_on_part1288);
            condition();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejoin_on_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulejoin_on_partEx; /* Prevent compiler warnings */
    rulejoin_on_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end join_on_part */

/**
 * $ANTLR start join_using_part
 * PLSQL_DMLParser.g:169:1: join_using_part : using_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::join_using_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:170:5: ( using_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
        // PLSQL_DMLParser.g:170:10: using_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
        {
            this->followPush(FOLLOW_using_key_in_join_using_part1308);
            m_gPLSQLParser->using_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejoin_using_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_join_using_part1310);
            if  (this->hasException())
            {
                goto rulejoin_using_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_join_using_part1312);
            m_gPLSQLParser->column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulejoin_using_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:170:43: ( COMMA column_name )*

            for (;;)
            {
                int alt55=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt55=1;
                	}
                    break;

                }

                switch (alt55)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:170:44: COMMA column_name
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_join_using_part1315);
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_using_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_join_using_part1317);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulejoin_using_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop55;	/* break out of the loop */
            	    break;
                }
            }
            loop55: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_join_using_part1321);
            if  (this->hasException())
            {
                goto rulejoin_using_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulejoin_using_partEx; /* Prevent compiler warnings */
    rulejoin_using_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end join_using_part */

/**
 * $ANTLR start outer_join_type
 * PLSQL_DMLParser.g:173:1: outer_join_type : ( full_key | left_key | right_key ) ( outer_key )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::outer_join_type()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:174:5: ( ( full_key | left_key | right_key ) ( outer_key )? )
        // PLSQL_DMLParser.g:175:5: ( full_key | left_key | right_key ) ( outer_key )?
        {
            // PLSQL_DMLParser.g:175:5: ( full_key | left_key | right_key )
            {
                int alt56=3;
                {
                    int LA56_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "FULL")))||((equalsIgnoreCase(LT(1)->getText(), "RIGHT")))||((equalsIgnoreCase(LT(1)->getText(), "LEFT"))))) && (LA56_0 == REGULAR_ID))
                    {
                        {
                            int LA56_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "FULL"))))
                            {
                                alt56=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "LEFT"))))
                            {
                                alt56=2;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "RIGHT"))))
                            {
                                alt56=3;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 56 );
                                ex->set_state( 1 );


                                goto ruleouter_join_typeEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 56 );
                        ex->set_state( 0 );


                        goto ruleouter_join_typeEx;

                    }
                }
                switch (alt56)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:175:10: full_key
            	    {
            	        this->followPush(FOLLOW_full_key_in_outer_join_type1351);
            	        m_gPLSQLParser->full_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleouter_join_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:176:10: left_key
            	    {
            	        this->followPush(FOLLOW_left_key_in_outer_join_type1362);
            	        m_gPLSQLParser->left_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleouter_join_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQL_DMLParser.g:177:10: right_key
            	    {
            	        this->followPush(FOLLOW_right_key_in_outer_join_type1373);
            	        m_gPLSQLParser->right_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleouter_join_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:179:9: ( outer_key )?
            {
                int alt57=2;
                {
                    int LA57_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "OUTER")))||((equalsIgnoreCase(LT(1)->getText(), "JOIN"))))) && (LA57_0 == REGULAR_ID))
                    {
                        {
                            int LA57_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "OUTER"))))
                            {
                                alt57=1;
                            }
                        }
                    }
                }
                switch (alt57)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:179:9: outer_key
            	    {
            	        this->followPush(FOLLOW_outer_key_in_outer_join_type1389);
            	        m_gPLSQLParser->outer_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleouter_join_typeEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleouter_join_typeEx; /* Prevent compiler warnings */
    ruleouter_join_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end outer_join_type */

/**
 * $ANTLR start query_partition_clause
 * PLSQL_DMLParser.g:182:1: query_partition_clause : partition_key by_key ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | ( LEFT_PAREN )=> expression_list | expression ( COMMA expression )* ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::query_partition_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:183:5: ( partition_key by_key ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | ( LEFT_PAREN )=> expression_list | expression ( COMMA expression )* ) )
        // PLSQL_DMLParser.g:183:10: partition_key by_key ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | ( LEFT_PAREN )=> expression_list | expression ( COMMA expression )* )
        {
            this->followPush(FOLLOW_partition_key_in_query_partition_clause1410);
            m_gPLSQLParser->partition_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulequery_partition_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_by_key_in_query_partition_clause1412);
            m_gPLSQLParser->by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulequery_partition_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:184:5: ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | ( LEFT_PAREN )=> expression_list | expression ( COMMA expression )* )
            {
                int alt59=3;
                switch ( this->LA(1) )
                {
                case LEFT_PAREN:
                	{
                		{
                		    int LA59_1 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred7_PLSQL_DMLParser>() )))
                		    {
                		        alt59=1;
                		    }
                		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred8_PLSQL_DMLParser>() )))
                		    {
                		        alt59=2;
                		    }
                		    else if ( (true))
                		    {
                		        alt59=3;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 59 );
                		        ex->set_state( 1 );


                		        goto rulequery_partition_clauseEx;

                		    }
                		}
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case DELIMITED_ID:
                case EXACT_NUM_LIT:
                case INTRODUCER:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case REGULAR_ID:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURSOR:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt59=3;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 59 );
                    ex->set_state( 0 );


                    goto rulequery_partition_clauseEx;

                }

                switch (alt59)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:184:10: ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_query_partition_clause1435);
            	        if  (this->hasException())
            	        {
            	            goto rulequery_partition_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_subquery_in_query_partition_clause1437);
            	        subquery();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_partition_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_query_partition_clause1439);
            	        if  (this->hasException())
            	        {
            	            goto rulequery_partition_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:185:10: ( LEFT_PAREN )=> expression_list
            	    {
            	        this->followPush(FOLLOW_expression_list_in_query_partition_clause1455);
            	        expression_list();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_partition_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQL_DMLParser.g:186:10: expression ( COMMA expression )*
            	    {
            	        this->followPush(FOLLOW_expression_in_query_partition_clause1466);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequery_partition_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:186:21: ( COMMA expression )*

            	        for (;;)
            	        {
            	            int alt58=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt58=1;
            	            	}
            	                break;

            	            }

            	            switch (alt58)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:186:22: COMMA expression
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_query_partition_clause1469);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulequery_partition_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_expression_in_query_partition_clause1471);
            	        	        expression();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulequery_partition_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop58;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop58: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulequery_partition_clauseEx; /* Prevent compiler warnings */
    rulequery_partition_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end query_partition_clause */

/**
 * $ANTLR start flashback_query_clause
 * PLSQL_DMLParser.g:190:1: flashback_query_clause : ( versions_key between_key ( scn_key | timestamp_key ) expression | as_key of_key ( scn_key | timestamp_key | snapshot_key ) expression );
 */
void
PLSQLParser_PLSQL_DMLParser::flashback_query_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:191:5: ( versions_key between_key ( scn_key | timestamp_key ) expression | as_key of_key ( scn_key | timestamp_key | snapshot_key ) expression )

            ANTLR_UINT32 alt62;

            alt62=2;

            {
                int LA62_0 = this->LA(1);
                if ( ((equalsIgnoreCase(LT(1)->getText(), "VERSIONS"))) && (LA62_0 == REGULAR_ID))
                {
                    alt62=1;
                }
                else if ( (LA62_0 == SQL92_RESERVED_AS))
                {
                    alt62=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 62 );
                    ex->set_state( 0 );


                    goto ruleflashback_query_clauseEx;

                }
            }
            switch (alt62)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:191:10: versions_key between_key ( scn_key | timestamp_key ) expression
        	    {
        	        this->followPush(FOLLOW_versions_key_in_flashback_query_clause1499);
        	        m_gPLSQLParser->versions_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleflashback_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_between_key_in_flashback_query_clause1501);
        	        m_gPLSQLParser->between_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleflashback_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:191:35: ( scn_key | timestamp_key )
        	        {
        	            int alt60=2;
        	            switch ( this->LA(1) )
        	            {
        	            case REGULAR_ID:
        	            	{
        	            		{
        	            		    int LA60_1 = this->LA(2);
        	            		    if ( ((equalsIgnoreCase(LT(1)->getText(), "SCN"))))
        	            		    {
        	            		        alt60=1;
        	            		    }
        	            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP"))))
        	            		    {
        	            		        alt60=2;
        	            		    }
        	            		    else
        	            		    {
        	            		        if (this->get_backtracking()>0)
        	            		        {
        	            		            this->set_failedflag( true );
        	            		            return ;
        	            		        }


        	            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            		        ex->set_decisionNum( 60 );
        	            		        ex->set_state( 1 );


        	            		        goto ruleflashback_query_clauseEx;

        	            		    }
        	            		}
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return ;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 60 );
        	                ex->set_state( 0 );


        	                goto ruleflashback_query_clauseEx;

        	            }

        	            switch (alt60)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:191:36: scn_key
        	        	    {
        	        	        this->followPush(FOLLOW_scn_key_in_flashback_query_clause1504);
        	        	        m_gPLSQLParser->scn_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleflashback_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:191:44: timestamp_key
        	        	    {
        	        	        this->followPush(FOLLOW_timestamp_key_in_flashback_query_clause1506);
        	        	        m_gPLSQLParser->timestamp_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleflashback_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_expression_in_flashback_query_clause1509);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleflashback_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:192:10: as_key of_key ( scn_key | timestamp_key | snapshot_key ) expression
        	    {
        	        this->followPush(FOLLOW_as_key_in_flashback_query_clause1520);
        	        m_gPLSQLParser->as_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleflashback_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_of_key_in_flashback_query_clause1522);
        	        m_gPLSQLParser->of_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleflashback_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:192:24: ( scn_key | timestamp_key | snapshot_key )
        	        {
        	            int alt61=3;
        	            switch ( this->LA(1) )
        	            {
        	            case REGULAR_ID:
        	            	{
        	            		{
        	            		    int LA61_1 = this->LA(2);
        	            		    if ( ((equalsIgnoreCase(LT(1)->getText(), "SCN"))))
        	            		    {
        	            		        alt61=1;
        	            		    }
        	            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP"))))
        	            		    {
        	            		        alt61=2;
        	            		    }
        	            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "SNAPSHOT"))))
        	            		    {
        	            		        alt61=3;
        	            		    }
        	            		    else
        	            		    {
        	            		        if (this->get_backtracking()>0)
        	            		        {
        	            		            this->set_failedflag( true );
        	            		            return ;
        	            		        }


        	            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            		        ex->set_decisionNum( 61 );
        	            		        ex->set_state( 1 );


        	            		        goto ruleflashback_query_clauseEx;

        	            		    }
        	            		}
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return ;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 61 );
        	                ex->set_state( 0 );


        	                goto ruleflashback_query_clauseEx;

        	            }

        	            switch (alt61)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:192:25: scn_key
        	        	    {
        	        	        this->followPush(FOLLOW_scn_key_in_flashback_query_clause1525);
        	        	        m_gPLSQLParser->scn_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleflashback_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:192:33: timestamp_key
        	        	    {
        	        	        this->followPush(FOLLOW_timestamp_key_in_flashback_query_clause1527);
        	        	        m_gPLSQLParser->timestamp_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleflashback_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // PLSQL_DMLParser.g:192:47: snapshot_key
        	        	    {
        	        	        this->followPush(FOLLOW_snapshot_key_in_flashback_query_clause1529);
        	        	        m_gPLSQLParser->snapshot_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleflashback_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_expression_in_flashback_query_clause1532);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleflashback_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleflashback_query_clauseEx; /* Prevent compiler warnings */
    ruleflashback_query_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end flashback_query_clause */

/**
 * $ANTLR start pivot_clause
 * PLSQL_DMLParser.g:195:1: pivot_clause : pivot_key ( xml_key )? LEFT_PAREN pivot_element ( COMMA pivot_element )* pivot_for_clause pivot_in_clause RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::pivot_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:196:5: ( pivot_key ( xml_key )? LEFT_PAREN pivot_element ( COMMA pivot_element )* pivot_for_clause pivot_in_clause RIGHT_PAREN )
        // PLSQL_DMLParser.g:196:10: pivot_key ( xml_key )? LEFT_PAREN pivot_element ( COMMA pivot_element )* pivot_for_clause pivot_in_clause RIGHT_PAREN
        {
            this->followPush(FOLLOW_pivot_key_in_pivot_clause1552);
            m_gPLSQLParser->pivot_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:196:20: ( xml_key )?
            {
                int alt63=2;
                {
                    int LA63_0 = this->LA(1);
                    if ( ((equalsIgnoreCase(LT(1)->getText(), "XML"))) && (LA63_0 == REGULAR_ID))
                    {
                        alt63=1;
                    }
                }
                switch (alt63)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:196:20: xml_key
            	    {
            	        this->followPush(FOLLOW_xml_key_in_pivot_clause1554);
            	        m_gPLSQLParser->xml_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_pivot_clause1565);
            if  (this->hasException())
            {
                goto rulepivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_pivot_element_in_pivot_clause1579);
            pivot_element();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:198:27: ( COMMA pivot_element )*

            for (;;)
            {
                int alt64=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt64=1;
                	}
                    break;

                }

                switch (alt64)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:198:28: COMMA pivot_element
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_pivot_clause1582);
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_pivot_element_in_pivot_clause1584);
            	        pivot_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop64;	/* break out of the loop */
            	    break;
                }
            }
            loop64: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_pivot_for_clause_in_pivot_clause1600);
            pivot_for_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_pivot_in_clause_in_pivot_clause1614);
            pivot_in_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_pivot_clause1626);
            if  (this->hasException())
            {
                goto rulepivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepivot_clauseEx; /* Prevent compiler warnings */
    rulepivot_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pivot_clause */

/**
 * $ANTLR start pivot_element
 * PLSQL_DMLParser.g:204:1: pivot_element : aggregate_function_name LEFT_PAREN expression RIGHT_PAREN ( column_alias )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::pivot_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:205:5: ( aggregate_function_name LEFT_PAREN expression RIGHT_PAREN ( column_alias )? )
        // PLSQL_DMLParser.g:205:10: aggregate_function_name LEFT_PAREN expression RIGHT_PAREN ( column_alias )?
        {
            this->followPush(FOLLOW_aggregate_function_name_in_pivot_element1646);
            m_gPLSQLParser->aggregate_function_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_pivot_element1648);
            if  (this->hasException())
            {
                goto rulepivot_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_pivot_element1650);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_pivot_element1652);
            if  (this->hasException())
            {
                goto rulepivot_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:205:68: ( column_alias )?
            {
                int alt65=2;
                switch ( this->LA(1) )
                {
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case DELIMITED_ID:
                    case INTRODUCER:
                    case NATIONAL_CHAR_STRING_LIT:
                    case REGULAR_ID:
                    case SQL92_RESERVED_AS:
                    	{
                    		alt65=1;
                    	}
                        break;
                }

                switch (alt65)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:205:68: column_alias
            	    {
            	        this->followPush(FOLLOW_column_alias_in_pivot_element1654);
            	        m_gPLSQLParser->column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulepivot_elementEx; /* Prevent compiler warnings */
    rulepivot_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pivot_element */

/**
 * $ANTLR start pivot_for_clause
 * PLSQL_DMLParser.g:208:1: pivot_for_clause : for_key ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::pivot_for_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:209:5: ( for_key ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) )
        // PLSQL_DMLParser.g:209:10: for_key ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
        {
            this->followPush(FOLLOW_for_key_in_pivot_for_clause1675);
            m_gPLSQLParser->for_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_for_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:210:5: ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
            {
                int alt67=2;
                switch ( this->LA(1) )
                {
                case DELIMITED_ID:
                case INTRODUCER:
                case REGULAR_ID:
                	{
                		alt67=1;
                	}
                    break;
                case LEFT_PAREN:
                	{
                		alt67=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 67 );
                    ex->set_state( 0 );


                    goto rulepivot_for_clauseEx;

                }

                switch (alt67)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:210:10: column_name
            	    {
            	        this->followPush(FOLLOW_column_name_in_pivot_for_clause1687);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_for_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:211:10: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_pivot_for_clause1698);
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_for_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_pivot_for_clause1700);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_for_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:211:33: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            int alt66=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt66=1;
            	            	}
            	                break;

            	            }

            	            switch (alt66)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:211:34: COMMA column_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_pivot_for_clause1703);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepivot_for_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_column_name_in_pivot_for_clause1705);
            	        	        m_gPLSQLParser->column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepivot_for_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop66;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop66: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_pivot_for_clause1709);
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_for_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulepivot_for_clauseEx; /* Prevent compiler warnings */
    rulepivot_for_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pivot_for_clause */

/**
 * $ANTLR start pivot_in_clause
 * PLSQL_DMLParser.g:215:1: pivot_in_clause : in_key LEFT_PAREN ( ( select_key )=> subquery | ( any_key )=> any_key ( COMMA any_key )* | pivot_in_clause_element ( COMMA pivot_in_clause_element )* ) RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::pivot_in_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:216:5: ( in_key LEFT_PAREN ( ( select_key )=> subquery | ( any_key )=> any_key ( COMMA any_key )* | pivot_in_clause_element ( COMMA pivot_in_clause_element )* ) RIGHT_PAREN )
        // PLSQL_DMLParser.g:216:10: in_key LEFT_PAREN ( ( select_key )=> subquery | ( any_key )=> any_key ( COMMA any_key )* | pivot_in_clause_element ( COMMA pivot_in_clause_element )* ) RIGHT_PAREN
        {
            this->followPush(FOLLOW_in_key_in_pivot_in_clause1735);
            m_gPLSQLParser->in_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_pivot_in_clause1745);
            if  (this->hasException())
            {
                goto rulepivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:218:13: ( ( select_key )=> subquery | ( any_key )=> any_key ( COMMA any_key )* | pivot_in_clause_element ( COMMA pivot_in_clause_element )* )
            {
                int alt70=3;
                {
                    int LA70_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred9_PLSQL_DMLParser>() )) && (LA70_0 == SQL92_RESERVED_SELECT))
                    {
                        alt70=1;
                    }
                    else if ( (LA70_0 == LEFT_PAREN))
                    {
                        {
                            int LA70_2 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred9_PLSQL_DMLParser>() )))
                            {
                                alt70=1;
                            }
                            else if ( (true))
                            {
                                alt70=3;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 70 );
                                ex->set_state( 2 );


                                goto rulepivot_in_clauseEx;

                            }
                        }
                    }
                    else if ( (LA70_0 == SQL92_RESERVED_ANY))
                    {
                        {
                            int LA70_3 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred10_PLSQL_DMLParser>() )))
                            {
                                alt70=2;
                            }
                            else if ( (true))
                            {
                                alt70=3;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 70 );
                                ex->set_state( 3 );


                                goto rulepivot_in_clauseEx;

                            }
                        }
                    }
                    else if ( (LA70_0 == APPROXIMATE_NUM_LIT || LA70_0 == BINDVAR || ((LA70_0 >= CHAR_STRING) && (LA70_0 <= COLON)) || LA70_0 == DELIMITED_ID || LA70_0 == EXACT_NUM_LIT || LA70_0 == INTRODUCER || ((LA70_0 >= MINUS_SIGN) && (LA70_0 <= NATIONAL_CHAR_STRING_LIT)) || LA70_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA70_0 == PLUS_SIGN || LA70_0 == REGULAR_ID || LA70_0 == SQL92_RESERVED_ALL || LA70_0 == SQL92_RESERVED_CASE || ((LA70_0 >= SQL92_RESERVED_CURSOR) && (LA70_0 <= SQL92_RESERVED_DATE)) || LA70_0 == SQL92_RESERVED_DEFAULT || LA70_0 == SQL92_RESERVED_DISTINCT || ((LA70_0 >= SQL92_RESERVED_EXISTS) && (LA70_0 <= SQL92_RESERVED_FALSE)) || ((LA70_0 >= SQL92_RESERVED_NOT) && (LA70_0 <= SQL92_RESERVED_NULL)) || LA70_0 == SQL92_RESERVED_PRIOR || LA70_0 == SQL92_RESERVED_TRUE || LA70_0 == UNSIGNED_INTEGER))
                    {
                        alt70=3;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 70 );
                        ex->set_state( 0 );


                        goto rulepivot_in_clauseEx;

                    }
                }
                switch (alt70)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:218:18: ( select_key )=> subquery
            	    {
            	        this->followPush(FOLLOW_subquery_in_pivot_in_clause1769);
            	        subquery();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_in_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:219:18: ( any_key )=> any_key ( COMMA any_key )*
            	    {
            	        this->followPush(FOLLOW_any_key_in_pivot_in_clause1794);
            	        m_gPLSQLParser->any_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_in_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:219:38: ( COMMA any_key )*

            	        for (;;)
            	        {
            	            int alt68=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt68=1;
            	            	}
            	                break;

            	            }

            	            switch (alt68)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:219:39: COMMA any_key
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_pivot_in_clause1797);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepivot_in_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_any_key_in_pivot_in_clause1799);
            	        	        m_gPLSQLParser->any_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepivot_in_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop68;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop68: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;
            	case 3:
            	    // PLSQL_DMLParser.g:220:18: pivot_in_clause_element ( COMMA pivot_in_clause_element )*
            	    {
            	        this->followPush(FOLLOW_pivot_in_clause_element_in_pivot_in_clause1820);
            	        pivot_in_clause_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_in_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:220:42: ( COMMA pivot_in_clause_element )*

            	        for (;;)
            	        {
            	            int alt69=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt69=1;
            	            	}
            	                break;

            	            }

            	            switch (alt69)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:220:43: COMMA pivot_in_clause_element
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_pivot_in_clause1823);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepivot_in_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_pivot_in_clause_element_in_pivot_in_clause1825);
            	        	        pivot_in_clause_element();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulepivot_in_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop69;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop69: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_pivot_in_clause1851);
            if  (this->hasException())
            {
                goto rulepivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulepivot_in_clauseEx; /* Prevent compiler warnings */
    rulepivot_in_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pivot_in_clause */

/**
 * $ANTLR start pivot_in_clause_element
 * PLSQL_DMLParser.g:225:1: pivot_in_clause_element : pivot_in_clause_elements ( column_alias )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::pivot_in_clause_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:226:5: ( pivot_in_clause_elements ( column_alias )? )
        // PLSQL_DMLParser.g:226:10: pivot_in_clause_elements ( column_alias )?
        {
            this->followPush(FOLLOW_pivot_in_clause_elements_in_pivot_in_clause_element1871);
            pivot_in_clause_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto rulepivot_in_clause_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:226:35: ( column_alias )?
            {
                int alt71=2;
                switch ( this->LA(1) )
                {
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case DELIMITED_ID:
                    case INTRODUCER:
                    case NATIONAL_CHAR_STRING_LIT:
                    case REGULAR_ID:
                    case SQL92_RESERVED_AS:
                    	{
                    		alt71=1;
                    	}
                        break;
                }

                switch (alt71)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:226:35: column_alias
            	    {
            	        this->followPush(FOLLOW_column_alias_in_pivot_in_clause_element1873);
            	        m_gPLSQLParser->column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulepivot_in_clause_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulepivot_in_clause_elementEx; /* Prevent compiler warnings */
    rulepivot_in_clause_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pivot_in_clause_element */

/**
 * $ANTLR start pivot_in_clause_elements
 * PLSQL_DMLParser.g:229:1: pivot_in_clause_elements : ( expression | ( LEFT_PAREN )=> expression_list );
 */
void
PLSQLParser_PLSQL_DMLParser::pivot_in_clause_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:230:5: ( expression | ( LEFT_PAREN )=> expression_list )

            ANTLR_UINT32 alt72;

            alt72=2;

            switch ( this->LA(1) )
            {
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case DELIMITED_ID:
            case EXACT_NUM_LIT:
            case INTRODUCER:
            case MINUS_SIGN:
            case NATIONAL_CHAR_STRING_LIT:
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            case PLUS_SIGN:
            case REGULAR_ID:
            case SQL92_RESERVED_ALL:
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_CASE:
            case SQL92_RESERVED_CURSOR:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_DISTINCT:
            case SQL92_RESERVED_EXISTS:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NOT:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_PRIOR:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt72=1;
            	}
                break;
            case LEFT_PAREN:
            	{
            		{
            		    int LA72_24 = this->LA(2);
            		    if ( (true))
            		    {
            		        alt72=1;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred11_PLSQL_DMLParser>() )))
            		    {
            		        alt72=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 72 );
            		        ex->set_state( 24 );


            		        goto rulepivot_in_clause_elementsEx;

            		    }
            		}
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 72 );
                ex->set_state( 0 );


                goto rulepivot_in_clause_elementsEx;

            }

            switch (alt72)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:230:10: expression
        	    {
        	        this->followPush(FOLLOW_expression_in_pivot_in_clause_elements1894);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepivot_in_clause_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:231:10: ( LEFT_PAREN )=> expression_list
        	    {
        	        this->followPush(FOLLOW_expression_list_in_pivot_in_clause_elements1910);
        	        expression_list();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulepivot_in_clause_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulepivot_in_clause_elementsEx; /* Prevent compiler warnings */
    rulepivot_in_clause_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end pivot_in_clause_elements */

/**
 * $ANTLR start unpivot_clause
 * PLSQL_DMLParser.g:234:1: unpivot_clause : unpivot_key ( ( include_key | exclude_key ) nulls_key )? LEFT_PAREN ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) pivot_for_clause unpivot_in_clause RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::unpivot_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:235:5: ( unpivot_key ( ( include_key | exclude_key ) nulls_key )? LEFT_PAREN ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) pivot_for_clause unpivot_in_clause RIGHT_PAREN )
        // PLSQL_DMLParser.g:235:10: unpivot_key ( ( include_key | exclude_key ) nulls_key )? LEFT_PAREN ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) pivot_for_clause unpivot_in_clause RIGHT_PAREN
        {
            this->followPush(FOLLOW_unpivot_key_in_unpivot_clause1930);
            m_gPLSQLParser->unpivot_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleunpivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:236:9: ( ( include_key | exclude_key ) nulls_key )?
            {
                int alt74=2;
                {
                    int LA74_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "EXCLUDE")))||((equalsIgnoreCase(LT(1)->getText(), "INCLUDE"))))) && (LA74_0 == REGULAR_ID))
                    {
                        alt74=1;
                    }
                }
                switch (alt74)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:236:10: ( include_key | exclude_key ) nulls_key
            	    {
            	        // PLSQL_DMLParser.g:236:10: ( include_key | exclude_key )
            	        {
            	            int alt73=2;
            	            {
            	                int LA73_0 = this->LA(1);
            	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "EXCLUDE")))||((equalsIgnoreCase(LT(1)->getText(), "INCLUDE"))))) && (LA73_0 == REGULAR_ID))
            	                {
            	                    {
            	                        int LA73_1 = this->LA(2);
            	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "INCLUDE"))))
            	                        {
            	                            alt73=1;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "EXCLUDE"))))
            	                        {
            	                            alt73=2;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 73 );
            	                            ex->set_state( 1 );


            	                            goto ruleunpivot_clauseEx;

            	                        }
            	                    }
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 73 );
            	                    ex->set_state( 0 );


            	                    goto ruleunpivot_clauseEx;

            	                }
            	            }
            	            switch (alt73)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:236:11: include_key
            	        	    {
            	        	        this->followPush(FOLLOW_include_key_in_unpivot_clause1943);
            	        	        m_gPLSQLParser->include_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:236:23: exclude_key
            	        	    {
            	        	        this->followPush(FOLLOW_exclude_key_in_unpivot_clause1945);
            	        	        m_gPLSQLParser->exclude_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_nulls_key_in_unpivot_clause1948);
            	        m_gPLSQLParser->nulls_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_unpivot_clause1960);
            if  (this->hasException())
            {
                goto ruleunpivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:238:13: ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
            {
                int alt76=2;
                switch ( this->LA(1) )
                {
                case DELIMITED_ID:
                case INTRODUCER:
                case REGULAR_ID:
                	{
                		alt76=1;
                	}
                    break;
                case LEFT_PAREN:
                	{
                		alt76=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 76 );
                    ex->set_state( 0 );


                    goto ruleunpivot_clauseEx;

                }

                switch (alt76)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:238:18: column_name
            	    {
            	        this->followPush(FOLLOW_column_name_in_unpivot_clause1979);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:239:18: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_unpivot_clause1998);
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_unpivot_clause2000);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:239:41: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            int alt75=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt75=1;
            	            	}
            	                break;

            	            }

            	            switch (alt75)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:239:42: COMMA column_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_unpivot_clause2003);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_column_name_in_unpivot_clause2005);
            	        	        m_gPLSQLParser->column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop75;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop75: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_unpivot_clause2009);
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_pivot_for_clause_in_unpivot_clause2037);
            pivot_for_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleunpivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_unpivot_in_clause_in_unpivot_clause2051);
            unpivot_in_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleunpivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_unpivot_clause2061);
            if  (this->hasException())
            {
                goto ruleunpivot_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunpivot_clauseEx; /* Prevent compiler warnings */
    ruleunpivot_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unpivot_clause */

/**
 * $ANTLR start unpivot_in_clause
 * PLSQL_DMLParser.g:246:1: unpivot_in_clause : in_key LEFT_PAREN unpivot_in_elements ( COMMA unpivot_in_elements )* RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::unpivot_in_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:247:5: ( in_key LEFT_PAREN unpivot_in_elements ( COMMA unpivot_in_elements )* RIGHT_PAREN )
        // PLSQL_DMLParser.g:247:10: in_key LEFT_PAREN unpivot_in_elements ( COMMA unpivot_in_elements )* RIGHT_PAREN
        {
            this->followPush(FOLLOW_in_key_in_unpivot_in_clause2081);
            m_gPLSQLParser->in_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleunpivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_unpivot_in_clause2091);
            if  (this->hasException())
            {
                goto ruleunpivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_unpivot_in_elements_in_unpivot_in_clause2105);
            unpivot_in_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleunpivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:249:33: ( COMMA unpivot_in_elements )*

            for (;;)
            {
                int alt77=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt77=1;
                	}
                    break;

                }

                switch (alt77)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:249:34: COMMA unpivot_in_elements
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_unpivot_in_clause2108);
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_unpivot_in_elements_in_unpivot_in_clause2110);
            	        unpivot_in_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop77;	/* break out of the loop */
            	    break;
                }
            }
            loop77: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_unpivot_in_clause2122);
            if  (this->hasException())
            {
                goto ruleunpivot_in_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunpivot_in_clauseEx; /* Prevent compiler warnings */
    ruleunpivot_in_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unpivot_in_clause */

/**
 * $ANTLR start unpivot_in_elements
 * PLSQL_DMLParser.g:253:1: unpivot_in_elements : ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) ( as_key ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN ) )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::unpivot_in_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:254:5: ( ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) ( as_key ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN ) )? )
        // PLSQL_DMLParser.g:254:9: ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN ) ( as_key ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN ) )?
        {
            // PLSQL_DMLParser.g:254:9: ( column_name | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )
            {
                int alt79=2;
                switch ( this->LA(1) )
                {
                case DELIMITED_ID:
                case INTRODUCER:
                case REGULAR_ID:
                	{
                		alt79=1;
                	}
                    break;
                case LEFT_PAREN:
                	{
                		alt79=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 79 );
                    ex->set_state( 0 );


                    goto ruleunpivot_in_elementsEx;

                }

                switch (alt79)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:254:14: column_name
            	    {
            	        this->followPush(FOLLOW_column_name_in_unpivot_in_elements2146);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:255:14: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_unpivot_in_elements2161);
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_unpivot_in_elements2163);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:255:37: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            int alt78=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt78=1;
            	            	}
            	                break;

            	            }

            	            switch (alt78)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:255:38: COMMA column_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_unpivot_in_elements2166);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_in_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_column_name_in_unpivot_in_elements2168);
            	        	        m_gPLSQLParser->column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_in_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop78;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop78: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_unpivot_in_elements2172);
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:257:9: ( as_key ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN ) )?
            {
                int alt82=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_AS:
                    	{
                    		alt82=1;
                    	}
                        break;
                }

                switch (alt82)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:257:15: as_key ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN )
            	    {
            	        this->followPush(FOLLOW_as_key_in_unpivot_in_elements2198);
            	        m_gPLSQLParser->as_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleunpivot_in_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:258:10: ( constant | ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN )
            	        {
            	            int alt81=2;
            	            {
            	                int LA81_0 = this->LA(1);
            	                if ( (LA81_0 == APPROXIMATE_NUM_LIT || ((LA81_0 >= CHAR_STRING) && (LA81_0 <= CHAR_STRING_PERL)) || LA81_0 == EXACT_NUM_LIT || LA81_0 == NATIONAL_CHAR_STRING_LIT || LA81_0 == REGULAR_ID || LA81_0 == SQL92_RESERVED_DATE || LA81_0 == SQL92_RESERVED_DEFAULT || LA81_0 == SQL92_RESERVED_FALSE || LA81_0 == SQL92_RESERVED_NULL || LA81_0 == SQL92_RESERVED_TRUE || LA81_0 == UNSIGNED_INTEGER))
            	                {
            	                    alt81=1;
            	                }
            	                else if ( (this->msynpred( antlr3::ClassForwarder<synpred12_PLSQL_DMLParser>() )) && (LA81_0 == LEFT_PAREN))
            	                {
            	                    alt81=2;
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 81 );
            	                    ex->set_state( 0 );


            	                    goto ruleunpivot_in_elementsEx;

            	                }
            	            }
            	            switch (alt81)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:258:15: constant
            	        	    {
            	        	        this->followPush(FOLLOW_constant_in_unpivot_in_elements2214);
            	        	        m_gPLSQLParser->constant();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_in_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:259:15: ( LEFT_PAREN )=> LEFT_PAREN constant ( COMMA constant )* RIGHT_PAREN
            	        	    {
            	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_unpivot_in_elements2235);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_in_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_constant_in_unpivot_in_elements2237);
            	        	        m_gPLSQLParser->constant();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_in_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // PLSQL_DMLParser.g:259:50: ( COMMA constant )*

            	        	        for (;;)
            	        	        {
            	        	            int alt80=2;
            	        	            switch ( this->LA(1) )
            	        	            {
            	        	            case COMMA:
            	        	            	{
            	        	            		alt80=1;
            	        	            	}
            	        	                break;

            	        	            }

            	        	            switch (alt80)
            	        	            {
            	        	        	case 1:
            	        	        	    // PLSQL_DMLParser.g:259:51: COMMA constant
            	        	        	    {
            	        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_unpivot_in_elements2240);
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleunpivot_in_elementsEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	        this->followPush(FOLLOW_constant_in_unpivot_in_elements2242);
            	        	        	        m_gPLSQLParser->constant();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleunpivot_in_elementsEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	        	default:
            	        	        	    goto loop80;	/* break out of the loop */
            	        	        	    break;
            	        	            }
            	        	        }
            	        	        loop80: ; /* Jump out to here if this rule does not match */


            	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_unpivot_in_elements2246);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleunpivot_in_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunpivot_in_elementsEx; /* Prevent compiler warnings */
    ruleunpivot_in_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unpivot_in_elements */

/**
 * $ANTLR start hierarchical_query_clause
 * PLSQL_DMLParser.g:264:1: hierarchical_query_clause : ( connect_key by_key ( nocycle_key )? condition ( start_part )? | start_part connect_key by_key ( nocycle_key )? condition );
 */
void
PLSQLParser_PLSQL_DMLParser::hierarchical_query_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:265:5: ( connect_key by_key ( nocycle_key )? condition ( start_part )? | start_part connect_key by_key ( nocycle_key )? condition )

            ANTLR_UINT32 alt86;

            alt86=2;

            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_CONNECT:
            	{
            		alt86=1;
            	}
                break;
            case PLSQL_RESERVED_START:
            	{
            		alt86=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 86 );
                ex->set_state( 0 );


                goto rulehierarchical_query_clauseEx;

            }

            switch (alt86)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:265:10: connect_key by_key ( nocycle_key )? condition ( start_part )?
        	    {
        	        this->followPush(FOLLOW_connect_key_in_hierarchical_query_clause2288);
        	        m_gPLSQLParser->connect_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_by_key_in_hierarchical_query_clause2290);
        	        m_gPLSQLParser->by_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:265:29: ( nocycle_key )?
        	        {
        	            int alt83=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    int LA83_1 = this->LA(2);
        	                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "NOCYCLE"))))
        	                		    {
        	                		        alt83=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt83)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:265:29: nocycle_key
        	        	    {
        	        	        this->followPush(FOLLOW_nocycle_key_in_hierarchical_query_clause2292);
        	        	        m_gPLSQLParser->nocycle_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulehierarchical_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_condition_in_hierarchical_query_clause2295);
        	        condition();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:265:52: ( start_part )?
        	        {
        	            int alt84=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PLSQL_RESERVED_START:
        	                	{
        	                		alt84=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt84)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:265:52: start_part
        	        	    {
        	        	        this->followPush(FOLLOW_start_part_in_hierarchical_query_clause2297);
        	        	        start_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulehierarchical_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:266:10: start_part connect_key by_key ( nocycle_key )? condition
        	    {
        	        this->followPush(FOLLOW_start_part_in_hierarchical_query_clause2309);
        	        start_part();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_connect_key_in_hierarchical_query_clause2311);
        	        m_gPLSQLParser->connect_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_by_key_in_hierarchical_query_clause2313);
        	        m_gPLSQLParser->by_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:266:40: ( nocycle_key )?
        	        {
        	            int alt85=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    int LA85_1 = this->LA(2);
        	                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "NOCYCLE"))))
        	                		    {
        	                		        alt85=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt85)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:266:40: nocycle_key
        	        	    {
        	        	        this->followPush(FOLLOW_nocycle_key_in_hierarchical_query_clause2315);
        	        	        m_gPLSQLParser->nocycle_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulehierarchical_query_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_condition_in_hierarchical_query_clause2318);
        	        condition();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulehierarchical_query_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulehierarchical_query_clauseEx; /* Prevent compiler warnings */
    rulehierarchical_query_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end hierarchical_query_clause */

/**
 * $ANTLR start start_part
 * PLSQL_DMLParser.g:269:1: start_part : start_key with_key condition ;
 */
void
PLSQLParser_PLSQL_DMLParser::start_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:270:5: ( start_key with_key condition )
        // PLSQL_DMLParser.g:270:10: start_key with_key condition
        {
            this->followPush(FOLLOW_start_key_in_start_part2338);
            m_gPLSQLParser->start_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestart_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_with_key_in_start_part2340);
            m_gPLSQLParser->with_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestart_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_condition_in_start_part2342);
            condition();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestart_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestart_partEx; /* Prevent compiler warnings */
    rulestart_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end start_part */

/**
 * $ANTLR start group_by_clause
 * PLSQL_DMLParser.g:273:1: group_by_clause : ( ( group_key )=> group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* ( having_clause )? | ( having_key )=> having_clause ( group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* )? );
 */
void
PLSQLParser_PLSQL_DMLParser::group_by_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:274:5: ( ( group_key )=> group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* ( having_clause )? | ( having_key )=> having_clause ( group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* )? )

            ANTLR_UINT32 alt91;

            alt91=2;

            {
                int LA91_0 = this->LA(1);
                if ( (this->msynpred( antlr3::ClassForwarder<synpred13_PLSQL_DMLParser>() )) && (LA91_0 == SQL92_RESERVED_GROUP))
                {
                    alt91=1;
                }
                else if ( (this->msynpred( antlr3::ClassForwarder<synpred15_PLSQL_DMLParser>() )) && (LA91_0 == SQL92_RESERVED_HAVING))
                {
                    alt91=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 91 );
                    ex->set_state( 0 );


                    goto rulegroup_by_clauseEx;

                }
            }
            switch (alt91)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:274:9: ( group_key )=> group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* ( having_clause )?
        	    {
        	        this->followPush(FOLLOW_group_key_in_group_by_clause2367);
        	        m_gPLSQLParser->group_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_by_key_in_group_by_clause2369);
        	        m_gPLSQLParser->by_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_group_by_elements_in_group_by_clause2371);
        	        group_by_elements();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:275:13: ( ( COMMA group_by_elements )=> COMMA group_by_elements )*

        	        for (;;)
        	        {
        	            int alt87=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		{
        	            		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	            		    */
        	            		    int LA87_2 = this->LA(2);
        	            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred14_PLSQL_DMLParser>() )))
        	            		    {
        	            		        alt87=1;
        	            		    }

        	            		}
        	            	}
        	                break;

        	            }

        	            switch (alt87)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:275:14: ( COMMA group_by_elements )=> COMMA group_by_elements
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_group_by_clause2393);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulegroup_by_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_group_by_elements_in_group_by_clause2395);
        	        	        group_by_elements();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulegroup_by_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop87;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop87: ; /* Jump out to here if this rule does not match */


        	        // PLSQL_DMLParser.g:276:13: ( having_clause )?
        	        {
        	            int alt88=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_HAVING:
        	                	{
        	                		alt88=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt88)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:276:13: having_clause
        	        	    {
        	        	        this->followPush(FOLLOW_having_clause_in_group_by_clause2411);
        	        	        having_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulegroup_by_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:277:9: ( having_key )=> having_clause ( group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* )?
        	    {
        	        this->followPush(FOLLOW_having_clause_in_group_by_clause2428);
        	        having_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:278:13: ( group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )* )?
        	        {
        	            int alt90=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_GROUP:
        	                	{
        	                		alt90=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt90)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:278:14: group_key by_key group_by_elements ( ( COMMA group_by_elements )=> COMMA group_by_elements )*
        	        	    {
        	        	        this->followPush(FOLLOW_group_key_in_group_by_clause2443);
        	        	        m_gPLSQLParser->group_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulegroup_by_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_by_key_in_group_by_clause2445);
        	        	        m_gPLSQLParser->by_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulegroup_by_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_group_by_elements_in_group_by_clause2447);
        	        	        group_by_elements();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulegroup_by_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQL_DMLParser.g:279:13: ( ( COMMA group_by_elements )=> COMMA group_by_elements )*

        	        	        for (;;)
        	        	        {
        	        	            int alt89=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	            case COMMA:
        	        	            	{
        	        	            		{
        	        	            		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	        	            		    */
        	        	            		    int LA89_2 = this->LA(2);
        	        	            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred16_PLSQL_DMLParser>() )))
        	        	            		    {
        	        	            		        alt89=1;
        	        	            		    }

        	        	            		}
        	        	            	}
        	        	                break;

        	        	            }

        	        	            switch (alt89)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:279:14: ( COMMA group_by_elements )=> COMMA group_by_elements
        	        	        	    {
        	        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_group_by_clause2469);
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulegroup_by_clauseEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        this->followPush(FOLLOW_group_by_elements_in_group_by_clause2471);
        	        	        	        group_by_elements();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulegroup_by_clauseEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	        	default:
        	        	        	    goto loop89;	/* break out of the loop */
        	        	        	    break;
        	        	            }
        	        	        }
        	        	        loop89: ; /* Jump out to here if this rule does not match */


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulegroup_by_clauseEx; /* Prevent compiler warnings */
    rulegroup_by_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end group_by_clause */

/**
 * $ANTLR start group_by_elements
 * PLSQL_DMLParser.g:282:1: group_by_elements : ( grouping_sets_clause | rollup_cube_clause | expression );
 */
void
PLSQLParser_PLSQL_DMLParser::group_by_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:283:5: ( grouping_sets_clause | rollup_cube_clause | expression )

            ANTLR_UINT32 alt92;

            alt92=3;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    int LA92_1 = this->LA(2);
            		    if ( ((equalsIgnoreCase(LT(1)->getText(), "GROUPING"))))
            		    {
            		        alt92=1;
            		    }
            		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "CUBE")))||((equalsIgnoreCase(LT(1)->getText(), "ROLLUP"))))))
            		    {
            		        alt92=2;
            		    }
            		    else if ( (true))
            		    {
            		        alt92=3;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 92 );
            		        ex->set_state( 1 );


            		        goto rulegroup_by_elementsEx;

            		    }
            		}
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case DELIMITED_ID:
            case EXACT_NUM_LIT:
            case INTRODUCER:
            case LEFT_PAREN:
            case MINUS_SIGN:
            case NATIONAL_CHAR_STRING_LIT:
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            case PLUS_SIGN:
            case SQL92_RESERVED_ALL:
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_CASE:
            case SQL92_RESERVED_CURSOR:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_DISTINCT:
            case SQL92_RESERVED_EXISTS:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NOT:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_PRIOR:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt92=3;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 92 );
                ex->set_state( 0 );


                goto rulegroup_by_elementsEx;

            }

            switch (alt92)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:283:10: grouping_sets_clause
        	    {
        	        this->followPush(FOLLOW_grouping_sets_clause_in_group_by_elements2495);
        	        grouping_sets_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:284:10: rollup_cube_clause
        	    {
        	        this->followPush(FOLLOW_rollup_cube_clause_in_group_by_elements2506);
        	        rollup_cube_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:285:10: expression
        	    {
        	        this->followPush(FOLLOW_expression_in_group_by_elements2518);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegroup_by_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulegroup_by_elementsEx; /* Prevent compiler warnings */
    rulegroup_by_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end group_by_elements */

/**
 * $ANTLR start rollup_cube_clause
 * PLSQL_DMLParser.g:288:1: rollup_cube_clause : ( rollup_key | cube_key ) LEFT_PAREN grouping_sets_elements ( COMMA grouping_sets_elements )* RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::rollup_cube_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:289:5: ( ( rollup_key | cube_key ) LEFT_PAREN grouping_sets_elements ( COMMA grouping_sets_elements )* RIGHT_PAREN )
        // PLSQL_DMLParser.g:289:10: ( rollup_key | cube_key ) LEFT_PAREN grouping_sets_elements ( COMMA grouping_sets_elements )* RIGHT_PAREN
        {
            // PLSQL_DMLParser.g:289:10: ( rollup_key | cube_key )
            {
                int alt93=2;
                {
                    int LA93_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "CUBE")))||((equalsIgnoreCase(LT(1)->getText(), "ROLLUP"))))) && (LA93_0 == REGULAR_ID))
                    {
                        {
                            int LA93_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "ROLLUP"))))
                            {
                                alt93=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "CUBE"))))
                            {
                                alt93=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 93 );
                                ex->set_state( 1 );


                                goto rulerollup_cube_clauseEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 93 );
                        ex->set_state( 0 );


                        goto rulerollup_cube_clauseEx;

                    }
                }
                switch (alt93)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:289:11: rollup_key
            	    {
            	        this->followPush(FOLLOW_rollup_key_in_rollup_cube_clause2539);
            	        m_gPLSQLParser->rollup_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerollup_cube_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:289:22: cube_key
            	    {
            	        this->followPush(FOLLOW_cube_key_in_rollup_cube_clause2541);
            	        m_gPLSQLParser->cube_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerollup_cube_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_rollup_cube_clause2544);
            if  (this->hasException())
            {
                goto rulerollup_cube_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_grouping_sets_elements_in_rollup_cube_clause2546);
            grouping_sets_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerollup_cube_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:289:66: ( COMMA grouping_sets_elements )*

            for (;;)
            {
                int alt94=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt94=1;
                	}
                    break;

                }

                switch (alt94)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:289:67: COMMA grouping_sets_elements
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_rollup_cube_clause2549);
            	        if  (this->hasException())
            	        {
            	            goto rulerollup_cube_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_grouping_sets_elements_in_rollup_cube_clause2551);
            	        grouping_sets_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerollup_cube_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop94;	/* break out of the loop */
            	    break;
                }
            }
            loop94: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_rollup_cube_clause2555);
            if  (this->hasException())
            {
                goto rulerollup_cube_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerollup_cube_clauseEx; /* Prevent compiler warnings */
    rulerollup_cube_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end rollup_cube_clause */

/**
 * $ANTLR start grouping_sets_clause
 * PLSQL_DMLParser.g:292:1: grouping_sets_clause : grouping_key sets_key LEFT_PAREN grouping_sets_elements ( COMMA grouping_sets_elements )* RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::grouping_sets_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:293:5: ( grouping_key sets_key LEFT_PAREN grouping_sets_elements ( COMMA grouping_sets_elements )* RIGHT_PAREN )
        // PLSQL_DMLParser.g:293:10: grouping_key sets_key LEFT_PAREN grouping_sets_elements ( COMMA grouping_sets_elements )* RIGHT_PAREN
        {
            this->followPush(FOLLOW_grouping_key_in_grouping_sets_clause2576);
            m_gPLSQLParser->grouping_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulegrouping_sets_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_sets_key_in_grouping_sets_clause2578);
            m_gPLSQLParser->sets_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulegrouping_sets_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_grouping_sets_clause2589);
            if  (this->hasException())
            {
                goto rulegrouping_sets_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_grouping_sets_elements_in_grouping_sets_clause2591);
            grouping_sets_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto rulegrouping_sets_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:294:43: ( COMMA grouping_sets_elements )*

            for (;;)
            {
                int alt95=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt95=1;
                	}
                    break;

                }

                switch (alt95)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:294:44: COMMA grouping_sets_elements
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_grouping_sets_clause2594);
            	        if  (this->hasException())
            	        {
            	            goto rulegrouping_sets_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_grouping_sets_elements_in_grouping_sets_clause2596);
            	        grouping_sets_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegrouping_sets_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop95;	/* break out of the loop */
            	    break;
                }
            }
            loop95: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_grouping_sets_clause2600);
            if  (this->hasException())
            {
                goto rulegrouping_sets_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulegrouping_sets_clauseEx; /* Prevent compiler warnings */
    rulegrouping_sets_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end grouping_sets_clause */

/**
 * $ANTLR start grouping_sets_elements
 * PLSQL_DMLParser.g:297:1: grouping_sets_elements : ( ( rollup_key | cube_key )=> rollup_cube_clause | ( LEFT_PAREN )=> expression_list | expression );
 */
void
PLSQLParser_PLSQL_DMLParser::grouping_sets_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:298:5: ( ( rollup_key | cube_key )=> rollup_cube_clause | ( LEFT_PAREN )=> expression_list | expression )

            ANTLR_UINT32 alt96;

            alt96=3;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    int LA96_1 = this->LA(2);
            		    if ( (( ((((equalsIgnoreCase(LT(1)->getText(), "CUBE")))||((equalsIgnoreCase(LT(1)->getText(), "ROLLUP"))))) && (this->msynpred( antlr3::ClassForwarder<synpred17_PLSQL_DMLParser>() )) )))
            		    {
            		        alt96=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt96=3;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 96 );
            		        ex->set_state( 1 );


            		        goto rulegrouping_sets_elementsEx;

            		    }
            		}
            	}
                break;
            case LEFT_PAREN:
            	{
            		{
            		    int LA96_2 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred18_PLSQL_DMLParser>() )))
            		    {
            		        alt96=2;
            		    }
            		    else if ( (true))
            		    {
            		        alt96=3;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 96 );
            		        ex->set_state( 2 );


            		        goto rulegrouping_sets_elementsEx;

            		    }
            		}
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case DELIMITED_ID:
            case EXACT_NUM_LIT:
            case INTRODUCER:
            case MINUS_SIGN:
            case NATIONAL_CHAR_STRING_LIT:
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            case PLUS_SIGN:
            case SQL92_RESERVED_ALL:
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_CASE:
            case SQL92_RESERVED_CURSOR:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_DISTINCT:
            case SQL92_RESERVED_EXISTS:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NOT:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_PRIOR:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt96=3;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 96 );
                ex->set_state( 0 );


                goto rulegrouping_sets_elementsEx;

            }

            switch (alt96)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:298:10: ( rollup_key | cube_key )=> rollup_cube_clause
        	    {
        	        this->followPush(FOLLOW_rollup_cube_clause_in_grouping_sets_elements2627);
        	        rollup_cube_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegrouping_sets_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:299:10: ( LEFT_PAREN )=> expression_list
        	    {
        	        this->followPush(FOLLOW_expression_list_in_grouping_sets_elements2643);
        	        expression_list();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegrouping_sets_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:300:10: expression
        	    {
        	        this->followPush(FOLLOW_expression_in_grouping_sets_elements2654);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulegrouping_sets_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulegrouping_sets_elementsEx; /* Prevent compiler warnings */
    rulegrouping_sets_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end grouping_sets_elements */

/**
 * $ANTLR start having_clause
 * PLSQL_DMLParser.g:303:1: having_clause : having_key condition ;
 */
void
PLSQLParser_PLSQL_DMLParser::having_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:304:5: ( having_key condition )
        // PLSQL_DMLParser.g:304:10: having_key condition
        {
            this->followPush(FOLLOW_having_key_in_having_clause2674);
            m_gPLSQLParser->having_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulehaving_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_condition_in_having_clause2676);
            condition();

            this->followPop();
            if  (this->hasException())
            {
                goto rulehaving_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulehaving_clauseEx; /* Prevent compiler warnings */
    rulehaving_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end having_clause */

/**
 * $ANTLR start model_clause
 * PLSQL_DMLParser.g:307:1: model_clause : model_key ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* main_model ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:308:5: ( model_key ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* main_model )
        // PLSQL_DMLParser.g:308:10: model_key ( cell_reference_options )* ( return_rows_clause )? ( reference_model )* main_model
        {
            this->followPush(FOLLOW_model_key_in_model_clause2696);
            m_gPLSQLParser->model_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:308:20: ( cell_reference_options )*

            for (;;)
            {
                int alt97=2;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		switch ( this->LA(2) )
                		{
                		case REGULAR_ID:
                			{
                				{
                				   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                				    */
                				    int LA97_3 = this->LA(3);
                				    if ( ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))))
                				    {
                				        alt97=1;
                				    }

                				}
                			}
                		    break;

                		}

                	}
                    break;
                case SQL92_RESERVED_UNIQUE:
                	{
                		alt97=1;
                	}
                    break;

                }

                switch (alt97)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:308:20: cell_reference_options
            	    {
            	        this->followPush(FOLLOW_cell_reference_options_in_model_clause2698);
            	        cell_reference_options();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop97;	/* break out of the loop */
            	    break;
                }
            }
            loop97: ; /* Jump out to here if this rule does not match */


            // PLSQL_DMLParser.g:308:44: ( return_rows_clause )?
            {
                int alt98=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case REGULAR_ID:
                    		    	{
                    		    		switch ( this->LA(3) )
                    		    		{
                    		    		    case REGULAR_ID:
                    		    		    	{
                    		    		    		switch ( this->LA(4) )
                    		    		    		{
                    		    		    		    case REGULAR_ID:
                    		    		    		    	{
                    		    		    		    		alt98=1;
                    		    		    		    	}
                    		    		    		        break;
                    		    		    		}

                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		    case SQL92_RESERVED_ALL:
                    		    	{
                    		    		alt98=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt98)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:308:44: return_rows_clause
            	    {
            	        this->followPush(FOLLOW_return_rows_clause_in_model_clause2701);
            	        return_rows_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:308:64: ( reference_model )*

            for (;;)
            {
                int alt99=2;
                alt99 = cdfa99.predict(this, this->get_rec(), this->get_istream(), cdfa99 );
                if  (this->hasException())
                {
                    goto rulemodel_clauseEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }

                switch (alt99)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:308:64: reference_model
            	    {
            	        this->followPush(FOLLOW_reference_model_in_model_clause2704);
            	        reference_model();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop99;	/* break out of the loop */
            	    break;
                }
            }
            loop99: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_main_model_in_model_clause2707);
            main_model();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_clauseEx; /* Prevent compiler warnings */
    rulemodel_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_clause */

/**
 * $ANTLR start cell_reference_options
 * PLSQL_DMLParser.g:311:1: cell_reference_options : ( ( ignore_key | keep_key ) nav_key | unique_key ( dimension_key | single_key reference_key ) );
 */
void
PLSQLParser_PLSQL_DMLParser::cell_reference_options()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:312:5: ( ( ignore_key | keep_key ) nav_key | unique_key ( dimension_key | single_key reference_key ) )

            ANTLR_UINT32 alt102;

            alt102=2;

            {
                int LA102_0 = this->LA(1);
                if ( ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))) && (LA102_0 == REGULAR_ID))
                {
                    alt102=1;
                }
                else if ( (LA102_0 == SQL92_RESERVED_UNIQUE))
                {
                    alt102=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 102 );
                    ex->set_state( 0 );


                    goto rulecell_reference_optionsEx;

                }
            }
            switch (alt102)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:312:10: ( ignore_key | keep_key ) nav_key
        	    {
        	        // PLSQL_DMLParser.g:312:10: ( ignore_key | keep_key )
        	        {
        	            int alt100=2;
        	            {
        	                int LA100_0 = this->LA(1);
        	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))) && (LA100_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA100_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "IGNORE"))))
        	                        {
        	                            alt100=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))
        	                        {
        	                            alt100=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 100 );
        	                            ex->set_state( 1 );


        	                            goto rulecell_reference_optionsEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 100 );
        	                    ex->set_state( 0 );


        	                    goto rulecell_reference_optionsEx;

        	                }
        	            }
        	            switch (alt100)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:312:11: ignore_key
        	        	    {
        	        	        this->followPush(FOLLOW_ignore_key_in_cell_reference_options2728);
        	        	        m_gPLSQLParser->ignore_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecell_reference_optionsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:312:22: keep_key
        	        	    {
        	        	        this->followPush(FOLLOW_keep_key_in_cell_reference_options2730);
        	        	        m_gPLSQLParser->keep_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecell_reference_optionsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_nav_key_in_cell_reference_options2733);
        	        m_gPLSQLParser->nav_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecell_reference_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:313:10: unique_key ( dimension_key | single_key reference_key )
        	    {
        	        this->followPush(FOLLOW_unique_key_in_cell_reference_options2744);
        	        m_gPLSQLParser->unique_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecell_reference_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:313:21: ( dimension_key | single_key reference_key )
        	        {
        	            int alt101=2;
        	            {
        	                int LA101_0 = this->LA(1);
        	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "SINGLE")))||((equalsIgnoreCase(LT(1)->getText(), "DIMENSION"))))) && (LA101_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA101_1 = this->LA(2);
        	                        if ( ((((equalsIgnoreCase(LT(1)->getText(), "SINGLE")))||((equalsIgnoreCase(LT(1)->getText(), "DIMENSION"))))) && (LA101_1 == REGULAR_ID))
        	                        {
        	                            {
        	                                int LA101_2 = this->LA(3);
        	                                if ( ((equalsIgnoreCase(LT(1)->getText(), "DIMENSION"))))
        	                                {
        	                                    alt101=1;
        	                                }
        	                                else if ( ((equalsIgnoreCase(LT(1)->getText(), "SINGLE"))))
        	                                {
        	                                    alt101=2;
        	                                }
        	                                else
        	                                {
        	                                    if (this->get_backtracking()>0)
        	                                    {
        	                                        this->set_failedflag( true );
        	                                        return ;
        	                                    }


        	                                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                                    ex->set_decisionNum( 101 );
        	                                    ex->set_state( 2 );


        	                                    goto rulecell_reference_optionsEx;

        	                                }
        	                            }
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "DIMENSION"))) && (LA101_1 == LEFT_PAREN || LA101_1 == SQL92_RESERVED_UNIQUE))
        	                        {
        	                            alt101=1;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 101 );
        	                            ex->set_state( 1 );


        	                            goto rulecell_reference_optionsEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 101 );
        	                    ex->set_state( 0 );


        	                    goto rulecell_reference_optionsEx;

        	                }
        	            }
        	            switch (alt101)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:313:22: dimension_key
        	        	    {
        	        	        this->followPush(FOLLOW_dimension_key_in_cell_reference_options2747);
        	        	        m_gPLSQLParser->dimension_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecell_reference_optionsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:313:36: single_key reference_key
        	        	    {
        	        	        this->followPush(FOLLOW_single_key_in_cell_reference_options2749);
        	        	        m_gPLSQLParser->single_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecell_reference_optionsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_reference_key_in_cell_reference_options2751);
        	        	        m_gPLSQLParser->reference_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecell_reference_optionsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulecell_reference_optionsEx; /* Prevent compiler warnings */
    rulecell_reference_optionsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cell_reference_options */

/**
 * $ANTLR start return_rows_clause
 * PLSQL_DMLParser.g:316:1: return_rows_clause : return_key ( updated_key | all_key ) rows_key ;
 */
void
PLSQLParser_PLSQL_DMLParser::return_rows_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:317:5: ( return_key ( updated_key | all_key ) rows_key )
        // PLSQL_DMLParser.g:317:10: return_key ( updated_key | all_key ) rows_key
        {
            this->followPush(FOLLOW_return_key_in_return_rows_clause2773);
            m_gPLSQLParser->return_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereturn_rows_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:317:21: ( updated_key | all_key )
            {
                int alt103=2;
                {
                    int LA103_0 = this->LA(1);
                    if ( ((equalsIgnoreCase(LT(1)->getText(), "UPDATED"))) && (LA103_0 == REGULAR_ID))
                    {
                        alt103=1;
                    }
                    else if ( (LA103_0 == SQL92_RESERVED_ALL))
                    {
                        alt103=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 103 );
                        ex->set_state( 0 );


                        goto rulereturn_rows_clauseEx;

                    }
                }
                switch (alt103)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:317:22: updated_key
            	    {
            	        this->followPush(FOLLOW_updated_key_in_return_rows_clause2776);
            	        m_gPLSQLParser->updated_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulereturn_rows_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:317:34: all_key
            	    {
            	        this->followPush(FOLLOW_all_key_in_return_rows_clause2778);
            	        m_gPLSQLParser->all_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulereturn_rows_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_rows_key_in_return_rows_clause2781);
            m_gPLSQLParser->rows_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereturn_rows_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereturn_rows_clauseEx; /* Prevent compiler warnings */
    rulereturn_rows_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end return_rows_clause */

/**
 * $ANTLR start reference_model
 * PLSQL_DMLParser.g:320:1: reference_model : reference_key reference_model_name on_key LEFT_PAREN subquery RIGHT_PAREN model_column_clauses ( cell_reference_options )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::reference_model()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:321:5: ( reference_key reference_model_name on_key LEFT_PAREN subquery RIGHT_PAREN model_column_clauses ( cell_reference_options )* )
        // PLSQL_DMLParser.g:321:10: reference_key reference_model_name on_key LEFT_PAREN subquery RIGHT_PAREN model_column_clauses ( cell_reference_options )*
        {
            this->followPush(FOLLOW_reference_key_in_reference_model2801);
            m_gPLSQLParser->reference_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_reference_model_name_in_reference_model2803);
            m_gPLSQLParser->reference_model_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_on_key_in_reference_model2805);
            m_gPLSQLParser->on_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_reference_model2820);
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_subquery_in_reference_model2822);
            subquery();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_reference_model2824);
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_model_column_clauses_in_reference_model2826);
            model_column_clauses();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereference_modelEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:323:13: ( cell_reference_options )*

            for (;;)
            {
                int alt104=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA104_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "DIMENSION")))||((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "PARTITION")))||((equalsIgnoreCase(LT(1)->getText(), "KEEP")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) && (LA104_0 == REGULAR_ID))
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA104_1 = this->LA(2);
                            if ( ((((equalsIgnoreCase(LT(1)->getText(), "REFERENCE")))||((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "KEEP")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) && (LA104_1 == REGULAR_ID))
                            {
                                {
                                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                                    */
                                    int LA104_4 = this->LA(3);
                                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))))
                                    {
                                        alt104=1;
                                    }

                                }
                            }

                        }
                    }
                    else if ( (LA104_0 == SQL92_RESERVED_UNIQUE))
                    {
                        alt104=1;
                    }

                }
                switch (alt104)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:323:13: cell_reference_options
            	    {
            	        this->followPush(FOLLOW_cell_reference_options_in_reference_model2841);
            	        cell_reference_options();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulereference_modelEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop104;	/* break out of the loop */
            	    break;
                }
            }
            loop104: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereference_modelEx; /* Prevent compiler warnings */
    rulereference_modelEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end reference_model */

/**
 * $ANTLR start main_model
 * PLSQL_DMLParser.g:326:1: main_model : ( main_key main_model_name )? model_column_clauses ( cell_reference_options )* model_rules_clause ;
 */
void
PLSQLParser_PLSQL_DMLParser::main_model()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:327:5: ( ( main_key main_model_name )? model_column_clauses ( cell_reference_options )* model_rules_clause )
        // PLSQL_DMLParser.g:327:10: ( main_key main_model_name )? model_column_clauses ( cell_reference_options )* model_rules_clause
        {
            // PLSQL_DMLParser.g:327:10: ( main_key main_model_name )?
            {
                int alt105=2;
                {
                    int LA105_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "DIMENSION")))||((equalsIgnoreCase(LT(1)->getText(), "PARTITION")))||((equalsIgnoreCase(LT(1)->getText(), "MAIN"))))) && (LA105_0 == REGULAR_ID))
                    {
                        {
                            int LA105_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "MAIN"))) && (LA105_1 == DELIMITED_ID || LA105_1 == INTRODUCER || LA105_1 == REGULAR_ID))
                            {
                                alt105=1;
                            }
                        }
                    }
                }
                switch (alt105)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:327:11: main_key main_model_name
            	    {
            	        this->followPush(FOLLOW_main_key_in_main_model2863);
            	        m_gPLSQLParser->main_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemain_modelEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_main_model_name_in_main_model2865);
            	        m_gPLSQLParser->main_model_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemain_modelEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_model_column_clauses_in_main_model2869);
            model_column_clauses();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemain_modelEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:327:59: ( cell_reference_options )*

            for (;;)
            {
                int alt106=2;
                {
                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                    */
                    int LA106_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "RULES")))||((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))) && (LA106_0 == REGULAR_ID))
                    {
                        {
                           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                            */
                            int LA106_1 = this->LA(2);
                            if ( ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "RULES")))||((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))) && (LA106_1 == REGULAR_ID))
                            {
                                {
                                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                                    */
                                    int LA106_5 = this->LA(3);
                                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "KEEP"))))))
                                    {
                                        alt106=1;
                                    }

                                }
                            }

                        }
                    }
                    else if ( (LA106_0 == SQL92_RESERVED_UNIQUE))
                    {
                        alt106=1;
                    }

                }
                switch (alt106)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:327:59: cell_reference_options
            	    {
            	        this->followPush(FOLLOW_cell_reference_options_in_main_model2871);
            	        cell_reference_options();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemain_modelEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop106;	/* break out of the loop */
            	    break;
                }
            }
            loop106: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_model_rules_clause_in_main_model2874);
            model_rules_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemain_modelEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemain_modelEx; /* Prevent compiler warnings */
    rulemain_modelEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end main_model */

/**
 * $ANTLR start model_column_clauses
 * PLSQL_DMLParser.g:330:1: model_column_clauses : ( model_column_partition_part )? dimension_key by_key model_column_list measures_key model_column_list ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_column_clauses()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:331:5: ( ( model_column_partition_part )? dimension_key by_key model_column_list measures_key model_column_list )
        // PLSQL_DMLParser.g:331:10: ( model_column_partition_part )? dimension_key by_key model_column_list measures_key model_column_list
        {
            // PLSQL_DMLParser.g:331:10: ( model_column_partition_part )?
            {
                int alt107=2;
                {
                    int LA107_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "DIMENSION")))||((equalsIgnoreCase(LT(1)->getText(), "PARTITION"))))) && (LA107_0 == REGULAR_ID))
                    {
                        {
                            int LA107_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "PARTITION"))))
                            {
                                alt107=1;
                            }
                        }
                    }
                }
                switch (alt107)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:331:10: model_column_partition_part
            	    {
            	        this->followPush(FOLLOW_model_column_partition_part_in_model_column_clauses2894);
            	        model_column_partition_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_column_clausesEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_dimension_key_in_model_column_clauses2905);
            m_gPLSQLParser->dimension_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_clausesEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_by_key_in_model_column_clauses2907);
            m_gPLSQLParser->by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_clausesEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_model_column_list_in_model_column_clauses2909);
            model_column_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_clausesEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_measures_key_in_model_column_clauses2911);
            m_gPLSQLParser->measures_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_clausesEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_model_column_list_in_model_column_clauses2913);
            model_column_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_clausesEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_column_clausesEx; /* Prevent compiler warnings */
    rulemodel_column_clausesEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_column_clauses */

/**
 * $ANTLR start model_column_partition_part
 * PLSQL_DMLParser.g:335:1: model_column_partition_part : partition_key by_key model_column_list ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_column_partition_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:336:5: ( partition_key by_key model_column_list )
        // PLSQL_DMLParser.g:336:10: partition_key by_key model_column_list
        {
            this->followPush(FOLLOW_partition_key_in_model_column_partition_part2933);
            m_gPLSQLParser->partition_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_partition_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_by_key_in_model_column_partition_part2935);
            m_gPLSQLParser->by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_partition_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_model_column_list_in_model_column_partition_part2937);
            model_column_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_partition_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_column_partition_partEx; /* Prevent compiler warnings */
    rulemodel_column_partition_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_column_partition_part */

/**
 * $ANTLR start model_column_list
 * PLSQL_DMLParser.g:339:1: model_column_list : LEFT_PAREN model_column ( COMMA model_column )* RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_column_list()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:340:5: ( LEFT_PAREN model_column ( COMMA model_column )* RIGHT_PAREN )
        // PLSQL_DMLParser.g:340:10: LEFT_PAREN model_column ( COMMA model_column )* RIGHT_PAREN
        {
             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_model_column_list2957);
            if  (this->hasException())
            {
                goto rulemodel_column_listEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_model_column_in_model_column_list2959);
            model_column();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_column_listEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:340:34: ( COMMA model_column )*

            for (;;)
            {
                int alt108=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt108=1;
                	}
                    break;

                }

                switch (alt108)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:340:35: COMMA model_column
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_model_column_list2962);
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_column_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_model_column_in_model_column_list2964);
            	        model_column();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_column_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop108;	/* break out of the loop */
            	    break;
                }
            }
            loop108: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_model_column_list2969);
            if  (this->hasException())
            {
                goto rulemodel_column_listEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_column_listEx; /* Prevent compiler warnings */
    rulemodel_column_listEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_column_list */

/**
 * $ANTLR start model_column
 * PLSQL_DMLParser.g:343:1: model_column : expression ( table_alias )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_column()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:344:5: ( expression ( table_alias )? )
        // PLSQL_DMLParser.g:344:10: expression ( table_alias )?
        {
            this->followPush(FOLLOW_expression_in_model_column2989);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_columnEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:344:21: ( table_alias )?
            {
                int alt109=2;
                switch ( this->LA(1) )
                {
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case DELIMITED_ID:
                    case INTRODUCER:
                    case NATIONAL_CHAR_STRING_LIT:
                    case REGULAR_ID:
                    	{
                    		alt109=1;
                    	}
                        break;
                }

                switch (alt109)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:344:21: table_alias
            	    {
            	        this->followPush(FOLLOW_table_alias_in_model_column2991);
            	        m_gPLSQLParser->table_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_columnEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_columnEx; /* Prevent compiler warnings */
    rulemodel_columnEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_column */

/**
 * $ANTLR start model_rules_clause
 * PLSQL_DMLParser.g:347:1: model_rules_clause : ( model_rules_part )? LEFT_PAREN model_rules_element ( COMMA model_rules_element )* RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_rules_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:348:5: ( ( model_rules_part )? LEFT_PAREN model_rules_element ( COMMA model_rules_element )* RIGHT_PAREN )
        // PLSQL_DMLParser.g:348:10: ( model_rules_part )? LEFT_PAREN model_rules_element ( COMMA model_rules_element )* RIGHT_PAREN
        {
            // PLSQL_DMLParser.g:348:10: ( model_rules_part )?
            {
                int alt110=2;
                {
                    int LA110_0 = this->LA(1);
                    if ( ((equalsIgnoreCase(LT(1)->getText(), "RULES"))) && (LA110_0 == REGULAR_ID))
                    {
                        alt110=1;
                    }
                }
                switch (alt110)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:348:10: model_rules_part
            	    {
            	        this->followPush(FOLLOW_model_rules_part_in_model_rules_clause3012);
            	        model_rules_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_model_rules_clause3015);
            if  (this->hasException())
            {
                goto rulemodel_rules_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_model_rules_element_in_model_rules_clause3017);
            model_rules_element();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_rules_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:348:59: ( COMMA model_rules_element )*

            for (;;)
            {
                int alt111=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt111=1;
                	}
                    break;

                }

                switch (alt111)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:348:60: COMMA model_rules_element
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_model_rules_clause3020);
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_model_rules_element_in_model_rules_clause3022);
            	        model_rules_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop111;	/* break out of the loop */
            	    break;
                }
            }
            loop111: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_model_rules_clause3026);
            if  (this->hasException())
            {
                goto rulemodel_rules_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_rules_clauseEx; /* Prevent compiler warnings */
    rulemodel_rules_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_rules_clause */

/**
 * $ANTLR start model_rules_part
 * PLSQL_DMLParser.g:351:1: model_rules_part : rules_key ( update_key | upsert_key ( all_key )? )? ( ( automatic_key | sequential_key ) order_key )? ( model_iterate_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_rules_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:352:5: ( rules_key ( update_key | upsert_key ( all_key )? )? ( ( automatic_key | sequential_key ) order_key )? ( model_iterate_clause )? )
        // PLSQL_DMLParser.g:352:10: rules_key ( update_key | upsert_key ( all_key )? )? ( ( automatic_key | sequential_key ) order_key )? ( model_iterate_clause )?
        {
            this->followPush(FOLLOW_rules_key_in_model_rules_part3046);
            m_gPLSQLParser->rules_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_rules_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:352:20: ( update_key | upsert_key ( all_key )? )?
            {
                int alt113=3;
                {
                    int LA113_0 = this->LA(1);
                    if ( (LA113_0 == SQL92_RESERVED_UPDATE))
                    {
                        alt113=1;
                    }
                    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "AUTOMATIC")))||((equalsIgnoreCase(LT(1)->getText(), "UPSERT")))||((equalsIgnoreCase(LT(1)->getText(), "ITERATE")))||((equalsIgnoreCase(LT(1)->getText(), "SEQUENTIAL"))))) && (LA113_0 == REGULAR_ID))
                    {
                        {
                            int LA113_2 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "UPSERT"))))
                            {
                                alt113=2;
                            }
                        }
                    }
                }
                switch (alt113)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:352:21: update_key
            	    {
            	        this->followPush(FOLLOW_update_key_in_model_rules_part3049);
            	        m_gPLSQLParser->update_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:352:32: upsert_key ( all_key )?
            	    {
            	        this->followPush(FOLLOW_upsert_key_in_model_rules_part3051);
            	        m_gPLSQLParser->upsert_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:352:43: ( all_key )?
            	        {
            	            int alt112=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_ALL:
            	                	{
            	                		alt112=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt112)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:352:43: all_key
            	        	    {
            	        	        this->followPush(FOLLOW_all_key_in_model_rules_part3053);
            	        	        m_gPLSQLParser->all_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemodel_rules_partEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:352:54: ( ( automatic_key | sequential_key ) order_key )?
            {
                int alt115=2;
                {
                    int LA115_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "AUTOMATIC")))||((equalsIgnoreCase(LT(1)->getText(), "ITERATE")))||((equalsIgnoreCase(LT(1)->getText(), "SEQUENTIAL"))))) && (LA115_0 == REGULAR_ID))
                    {
                        {
                            int LA115_1 = this->LA(2);
                            if ( ((((equalsIgnoreCase(LT(1)->getText(), "AUTOMATIC")))||((equalsIgnoreCase(LT(1)->getText(), "SEQUENTIAL"))))) && (LA115_1 == SQL92_RESERVED_ORDER))
                            {
                                alt115=1;
                            }
                        }
                    }
                }
                switch (alt115)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:352:55: ( automatic_key | sequential_key ) order_key
            	    {
            	        // PLSQL_DMLParser.g:352:55: ( automatic_key | sequential_key )
            	        {
            	            int alt114=2;
            	            {
            	                int LA114_0 = this->LA(1);
            	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "AUTOMATIC")))||((equalsIgnoreCase(LT(1)->getText(), "SEQUENTIAL"))))) && (LA114_0 == REGULAR_ID))
            	                {
            	                    {
            	                        int LA114_1 = this->LA(2);
            	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "AUTOMATIC"))))
            	                        {
            	                            alt114=1;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "SEQUENTIAL"))))
            	                        {
            	                            alt114=2;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 114 );
            	                            ex->set_state( 1 );


            	                            goto rulemodel_rules_partEx;

            	                        }
            	                    }
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 114 );
            	                    ex->set_state( 0 );


            	                    goto rulemodel_rules_partEx;

            	                }
            	            }
            	            switch (alt114)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:352:56: automatic_key
            	        	    {
            	        	        this->followPush(FOLLOW_automatic_key_in_model_rules_part3060);
            	        	        m_gPLSQLParser->automatic_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemodel_rules_partEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:352:70: sequential_key
            	        	    {
            	        	        this->followPush(FOLLOW_sequential_key_in_model_rules_part3062);
            	        	        m_gPLSQLParser->sequential_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemodel_rules_partEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_order_key_in_model_rules_part3065);
            	        m_gPLSQLParser->order_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:352:98: ( model_iterate_clause )?
            {
                int alt116=2;
                {
                    int LA116_0 = this->LA(1);
                    if ( ((equalsIgnoreCase(LT(1)->getText(), "ITERATE"))) && (LA116_0 == REGULAR_ID))
                    {
                        alt116=1;
                    }
                }
                switch (alt116)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:352:98: model_iterate_clause
            	    {
            	        this->followPush(FOLLOW_model_iterate_clause_in_model_rules_part3069);
            	        model_iterate_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_rules_partEx; /* Prevent compiler warnings */
    rulemodel_rules_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_rules_part */

/**
 * $ANTLR start model_rules_element
 * PLSQL_DMLParser.g:355:1: model_rules_element : ( update_key | upsert_key ( ( all_key )=> all_key )? )? cell_assignment ( order_by_clause )? EQUALS_OP expression ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_rules_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:356:5: ( ( update_key | upsert_key ( ( all_key )=> all_key )? )? cell_assignment ( order_by_clause )? EQUALS_OP expression )
        // PLSQL_DMLParser.g:356:10: ( update_key | upsert_key ( ( all_key )=> all_key )? )? cell_assignment ( order_by_clause )? EQUALS_OP expression
        {
            // PLSQL_DMLParser.g:356:10: ( update_key | upsert_key ( ( all_key )=> all_key )? )?
            {
                int alt118=3;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_UPDATE:
                    	{
                    		alt118=1;
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA118_2 = this->LA(2);
                    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "UPSERT"))))
                    		    {
                    		        alt118=2;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt118)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:356:11: update_key
            	    {
            	        this->followPush(FOLLOW_update_key_in_model_rules_element3091);
            	        m_gPLSQLParser->update_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:356:22: upsert_key ( ( all_key )=> all_key )?
            	    {
            	        this->followPush(FOLLOW_upsert_key_in_model_rules_element3093);
            	        m_gPLSQLParser->upsert_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:356:33: ( ( all_key )=> all_key )?
            	        {
            	            int alt117=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_ALL:
            	                	{
            	                		{
            	                		    int LA117_1 = this->LA(2);
            	                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred19_PLSQL_DMLParser>() )))
            	                		    {
            	                		        alt117=1;
            	                		    }
            	                		}
            	                	}
            	                    break;
            	            }

            	            switch (alt117)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:356:34: ( all_key )=> all_key
            	        	    {
            	        	        this->followPush(FOLLOW_all_key_in_model_rules_element3101);
            	        	        m_gPLSQLParser->all_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemodel_rules_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_cell_assignment_in_model_rules_element3115);
            cell_assignment();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_rules_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:358:17: ( order_by_clause )?
            {
                int alt119=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_ORDER:
                    	{
                    		alt119=1;
                    	}
                        break;
                }

                switch (alt119)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:358:17: order_by_clause
            	    {
            	        this->followPush(FOLLOW_order_by_clause_in_model_rules_element3133);
            	        order_by_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_rules_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_model_rules_element3148);
            if  (this->hasException())
            {
                goto rulemodel_rules_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_model_rules_element3150);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_rules_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_rules_elementEx; /* Prevent compiler warnings */
    rulemodel_rules_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_rules_element */

/**
 * $ANTLR start cell_assignment
 * PLSQL_DMLParser.g:362:1: cell_assignment : model_expression ;
 */
void
PLSQLParser_PLSQL_DMLParser::cell_assignment()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:363:5: ( model_expression )
        // PLSQL_DMLParser.g:363:10: model_expression
        {
            this->followPush(FOLLOW_model_expression_in_cell_assignment3170);
            model_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecell_assignmentEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecell_assignmentEx; /* Prevent compiler warnings */
    rulecell_assignmentEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cell_assignment */

/**
 * $ANTLR start model_iterate_clause
 * PLSQL_DMLParser.g:366:1: model_iterate_clause : iterate_key LEFT_PAREN expression RIGHT_PAREN ( until_part )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_iterate_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:367:5: ( iterate_key LEFT_PAREN expression RIGHT_PAREN ( until_part )? )
        // PLSQL_DMLParser.g:367:10: iterate_key LEFT_PAREN expression RIGHT_PAREN ( until_part )?
        {
            this->followPush(FOLLOW_iterate_key_in_model_iterate_clause3190);
            m_gPLSQLParser->iterate_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_iterate_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_model_iterate_clause3192);
            if  (this->hasException())
            {
                goto rulemodel_iterate_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_model_iterate_clause3194);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_iterate_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_model_iterate_clause3196);
            if  (this->hasException())
            {
                goto rulemodel_iterate_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:367:56: ( until_part )?
            {
                int alt120=2;
                {
                    int LA120_0 = this->LA(1);
                    if ( ((equalsIgnoreCase(LT(1)->getText(), "UNTIL"))) && (LA120_0 == REGULAR_ID))
                    {
                        alt120=1;
                    }
                }
                switch (alt120)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:367:56: until_part
            	    {
            	        this->followPush(FOLLOW_until_part_in_model_iterate_clause3198);
            	        until_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_iterate_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_iterate_clauseEx; /* Prevent compiler warnings */
    rulemodel_iterate_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_iterate_clause */

/**
 * $ANTLR start until_part
 * PLSQL_DMLParser.g:370:1: until_part : until_key LEFT_PAREN condition RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::until_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:371:5: ( until_key LEFT_PAREN condition RIGHT_PAREN )
        // PLSQL_DMLParser.g:371:10: until_key LEFT_PAREN condition RIGHT_PAREN
        {
            this->followPush(FOLLOW_until_key_in_until_part3219);
            m_gPLSQLParser->until_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleuntil_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_until_part3221);
            if  (this->hasException())
            {
                goto ruleuntil_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_condition_in_until_part3223);
            condition();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleuntil_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_until_part3225);
            if  (this->hasException())
            {
                goto ruleuntil_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleuntil_partEx; /* Prevent compiler warnings */
    ruleuntil_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end until_part */

/**
 * $ANTLR start order_by_clause
 * PLSQL_DMLParser.g:374:1: order_by_clause : order_key ( siblings_key )? by_key order_by_elements ( COMMA order_by_elements )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::order_by_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:375:5: ( order_key ( siblings_key )? by_key order_by_elements ( COMMA order_by_elements )* )
        // PLSQL_DMLParser.g:375:10: order_key ( siblings_key )? by_key order_by_elements ( COMMA order_by_elements )*
        {
            this->followPush(FOLLOW_order_key_in_order_by_clause3245);
            m_gPLSQLParser->order_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleorder_by_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:375:20: ( siblings_key )?
            {
                int alt121=2;
                {
                    int LA121_0 = this->LA(1);
                    if ( ((equalsIgnoreCase(LT(1)->getText(), "SIBLINGS"))) && (LA121_0 == REGULAR_ID))
                    {
                        alt121=1;
                    }
                }
                switch (alt121)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:375:20: siblings_key
            	    {
            	        this->followPush(FOLLOW_siblings_key_in_order_by_clause3247);
            	        m_gPLSQLParser->siblings_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_by_key_in_order_by_clause3250);
            m_gPLSQLParser->by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleorder_by_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_order_by_elements_in_order_by_clause3252);
            order_by_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleorder_by_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:375:59: ( COMMA order_by_elements )*

            for (;;)
            {
                int alt122=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt122=1;
                	}
                    break;

                }

                switch (alt122)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:375:60: COMMA order_by_elements
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_order_by_clause3255);
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_order_by_elements_in_order_by_clause3257);
            	        order_by_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop122;	/* break out of the loop */
            	    break;
                }
            }
            loop122: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleorder_by_clauseEx; /* Prevent compiler warnings */
    ruleorder_by_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end order_by_clause */

/**
 * $ANTLR start order_by_elements
 * PLSQL_DMLParser.g:378:1: order_by_elements : expression ( asc_key | desc_key )? ( nulls_key ( first_key | last_key ) )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::order_by_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:379:5: ( expression ( asc_key | desc_key )? ( nulls_key ( first_key | last_key ) )? )
        // PLSQL_DMLParser.g:379:10: expression ( asc_key | desc_key )? ( nulls_key ( first_key | last_key ) )?
        {
            this->followPush(FOLLOW_expression_in_order_by_elements3279);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleorder_by_elementsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:379:21: ( asc_key | desc_key )?
            {
                int alt123=3;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_ASC:
                    	{
                    		alt123=1;
                    	}
                        break;
                    case SQL92_RESERVED_DESC:
                    	{
                    		alt123=2;
                    	}
                        break;
                }

                switch (alt123)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:379:22: asc_key
            	    {
            	        this->followPush(FOLLOW_asc_key_in_order_by_elements3282);
            	        m_gPLSQLParser->asc_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:379:30: desc_key
            	    {
            	        this->followPush(FOLLOW_desc_key_in_order_by_elements3284);
            	        m_gPLSQLParser->desc_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:379:41: ( nulls_key ( first_key | last_key ) )?
            {
                int alt125=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case REGULAR_ID:
                    		    	{
                    		    		{
                    		    		    int LA125_3 = this->LA(3);
                    		    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "NULLS"))))
                    		    		    {
                    		    		        alt125=1;
                    		    		    }
                    		    		}
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt125)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:379:42: nulls_key ( first_key | last_key )
            	    {
            	        this->followPush(FOLLOW_nulls_key_in_order_by_elements3289);
            	        m_gPLSQLParser->nulls_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleorder_by_elementsEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:379:52: ( first_key | last_key )
            	        {
            	            int alt124=2;
            	            {
            	                int LA124_0 = this->LA(1);
            	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "FIRST")))||((equalsIgnoreCase(LT(1)->getText(), "LAST"))))) && (LA124_0 == REGULAR_ID))
            	                {
            	                    {
            	                        int LA124_1 = this->LA(2);
            	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "FIRST"))))
            	                        {
            	                            alt124=1;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "LAST"))))
            	                        {
            	                            alt124=2;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 124 );
            	                            ex->set_state( 1 );


            	                            goto ruleorder_by_elementsEx;

            	                        }
            	                    }
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 124 );
            	                    ex->set_state( 0 );


            	                    goto ruleorder_by_elementsEx;

            	                }
            	            }
            	            switch (alt124)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:379:53: first_key
            	        	    {
            	        	        this->followPush(FOLLOW_first_key_in_order_by_elements3292);
            	        	        m_gPLSQLParser->first_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleorder_by_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:379:63: last_key
            	        	    {
            	        	        this->followPush(FOLLOW_last_key_in_order_by_elements3294);
            	        	        m_gPLSQLParser->last_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleorder_by_elementsEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleorder_by_elementsEx; /* Prevent compiler warnings */
    ruleorder_by_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end order_by_elements */

/**
 * $ANTLR start for_update_clause
 * PLSQL_DMLParser.g:382:1: for_update_clause : for_key update_key ( for_update_of_part )? ( for_update_options )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::for_update_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:383:5: ( for_key update_key ( for_update_of_part )? ( for_update_options )? )
        // PLSQL_DMLParser.g:383:10: for_key update_key ( for_update_of_part )? ( for_update_options )?
        {
            this->followPush(FOLLOW_for_key_in_for_update_clause3317);
            m_gPLSQLParser->for_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_update_key_in_for_update_clause3319);
            m_gPLSQLParser->update_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:383:29: ( for_update_of_part )?
            {
                int alt126=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_OF:
                    	{
                    		alt126=1;
                    	}
                        break;
                }

                switch (alt126)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:383:29: for_update_of_part
            	    {
            	        this->followPush(FOLLOW_for_update_of_part_in_for_update_clause3321);
            	        for_update_of_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefor_update_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:383:49: ( for_update_options )?
            {
                int alt127=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA127_1 = this->LA(2);
                    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SKIP")))||((equalsIgnoreCase(LT(1)->getText(), "WAIT"))))))
                    		    {
                    		        alt127=1;
                    		    }
                    		}
                    	}
                        break;
                    case PLSQL_RESERVED_NOWAIT:
                    	{
                    		alt127=1;
                    	}
                        break;
                }

                switch (alt127)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:383:49: for_update_options
            	    {
            	        this->followPush(FOLLOW_for_update_options_in_for_update_clause3324);
            	        for_update_options();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefor_update_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulefor_update_clauseEx; /* Prevent compiler warnings */
    rulefor_update_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end for_update_clause */

/**
 * $ANTLR start for_update_of_part
 * PLSQL_DMLParser.g:386:1: for_update_of_part : of_key column_name ( COMMA column_name )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::for_update_of_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:387:5: ( of_key column_name ( COMMA column_name )* )
        // PLSQL_DMLParser.g:387:10: of_key column_name ( COMMA column_name )*
        {
            this->followPush(FOLLOW_of_key_in_for_update_of_part3345);
            m_gPLSQLParser->of_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_update_of_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_for_update_of_part3347);
            m_gPLSQLParser->column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_update_of_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:387:29: ( COMMA column_name )*

            for (;;)
            {
                int alt128=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt128=1;
                	}
                    break;

                }

                switch (alt128)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:387:30: COMMA column_name
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_for_update_of_part3350);
            	        if  (this->hasException())
            	        {
            	            goto rulefor_update_of_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_for_update_of_part3352);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefor_update_of_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop128;	/* break out of the loop */
            	    break;
                }
            }
            loop128: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefor_update_of_partEx; /* Prevent compiler warnings */
    rulefor_update_of_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end for_update_of_part */

/**
 * $ANTLR start for_update_options
 * PLSQL_DMLParser.g:390:1: for_update_options : ( skip_key locked_key | nowait_key | wait_key expression );
 */
void
PLSQLParser_PLSQL_DMLParser::for_update_options()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:391:5: ( skip_key locked_key | nowait_key | wait_key expression )

            ANTLR_UINT32 alt129;

            alt129=3;

            {
                int LA129_0 = this->LA(1);
                if ( ((((equalsIgnoreCase(LT(1)->getText(), "SKIP")))||((equalsIgnoreCase(LT(1)->getText(), "WAIT"))))) && (LA129_0 == REGULAR_ID))
                {
                    {
                        int LA129_1 = this->LA(2);
                        if ( ((((equalsIgnoreCase(LT(1)->getText(), "SKIP")))||((equalsIgnoreCase(LT(1)->getText(), "WAIT"))))) && (LA129_1 == REGULAR_ID))
                        {
                            {
                                int LA129_3 = this->LA(3);
                                if ( ((equalsIgnoreCase(LT(1)->getText(), "SKIP"))))
                                {
                                    alt129=1;
                                }
                                else if ( ((equalsIgnoreCase(LT(1)->getText(), "WAIT"))))
                                {
                                    alt129=3;
                                }
                                else
                                {
                                    if (this->get_backtracking()>0)
                                    {
                                        this->set_failedflag( true );
                                        return ;
                                    }


                                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                    ex->set_decisionNum( 129 );
                                    ex->set_state( 3 );


                                    goto rulefor_update_optionsEx;

                                }
                            }
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "WAIT"))) && (LA129_1 == APPROXIMATE_NUM_LIT || LA129_1 == BINDVAR || ((LA129_1 >= CHAR_STRING) && (LA129_1 <= COLON)) || LA129_1 == DELIMITED_ID || LA129_1 == EXACT_NUM_LIT || LA129_1 == INTRODUCER || LA129_1 == LEFT_PAREN || ((LA129_1 >= MINUS_SIGN) && (LA129_1 <= NATIONAL_CHAR_STRING_LIT)) || LA129_1 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA129_1 == PLUS_SIGN || LA129_1 == SQL92_RESERVED_ALL || LA129_1 == SQL92_RESERVED_ANY || LA129_1 == SQL92_RESERVED_CASE || ((LA129_1 >= SQL92_RESERVED_CURSOR) && (LA129_1 <= SQL92_RESERVED_DATE)) || LA129_1 == SQL92_RESERVED_DEFAULT || LA129_1 == SQL92_RESERVED_DISTINCT || ((LA129_1 >= SQL92_RESERVED_EXISTS) && (LA129_1 <= SQL92_RESERVED_FALSE)) || ((LA129_1 >= SQL92_RESERVED_NOT) && (LA129_1 <= SQL92_RESERVED_NULL)) || LA129_1 == SQL92_RESERVED_PRIOR || LA129_1 == SQL92_RESERVED_TRUE || LA129_1 == UNSIGNED_INTEGER))
                        {
                            alt129=3;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 129 );
                            ex->set_state( 1 );


                            goto rulefor_update_optionsEx;

                        }
                    }
                }
                else if ( (LA129_0 == PLSQL_RESERVED_NOWAIT))
                {
                    alt129=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 129 );
                    ex->set_state( 0 );


                    goto rulefor_update_optionsEx;

                }
            }
            switch (alt129)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:391:10: skip_key locked_key
        	    {
        	        this->followPush(FOLLOW_skip_key_in_for_update_options3374);
        	        m_gPLSQLParser->skip_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_update_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_locked_key_in_for_update_options3376);
        	        m_gPLSQLParser->locked_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_update_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:392:10: nowait_key
        	    {
        	        this->followPush(FOLLOW_nowait_key_in_for_update_options3387);
        	        m_gPLSQLParser->nowait_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_update_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:393:10: wait_key expression
        	    {
        	        this->followPush(FOLLOW_wait_key_in_for_update_options3398);
        	        m_gPLSQLParser->wait_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_update_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_in_for_update_options3400);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_update_optionsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulefor_update_optionsEx; /* Prevent compiler warnings */
    rulefor_update_optionsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end for_update_options */

/**
 * $ANTLR start update_statement
 * PLSQL_DMLParser.g:398:1: update_statement : update_key general_table_ref update_set_clause ( where_clause )? ( static_returning_clause )? ( error_logging_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::update_statement()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:399:5: ( update_key general_table_ref update_set_clause ( where_clause )? ( static_returning_clause )? ( error_logging_clause )? )
        // PLSQL_DMLParser.g:399:10: update_key general_table_ref update_set_clause ( where_clause )? ( static_returning_clause )? ( error_logging_clause )?
        {
            this->followPush(FOLLOW_update_key_in_update_statement3422);
            m_gPLSQLParser->update_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleupdate_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_general_table_ref_in_update_statement3424);
            general_table_ref();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleupdate_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_update_set_clause_in_update_statement3434);
            update_set_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleupdate_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:401:9: ( where_clause )?
            {
                int alt130=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_WHERE:
                    	{
                    		alt130=1;
                    	}
                        break;
                }

                switch (alt130)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:401:9: where_clause
            	    {
            	        this->followPush(FOLLOW_where_clause_in_update_statement3444);
            	        m_gPLSQLParser->where_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:401:23: ( static_returning_clause )?
            {
                int alt131=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA131_1 = this->LA(2);
                    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "RETURNING")))||((equalsIgnoreCase(LT(1)->getText(), "RETURN"))))))
                    		    {
                    		        alt131=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt131)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:401:23: static_returning_clause
            	    {
            	        this->followPush(FOLLOW_static_returning_clause_in_update_statement3447);
            	        static_returning_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:401:48: ( error_logging_clause )?
            {
                int alt132=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case REGULAR_ID:
                    		    	{
                    		    		{
                    		    		    int LA132_3 = this->LA(3);
                    		    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "LOG"))))
                    		    		    {
                    		    		        alt132=1;
                    		    		    }
                    		    		}
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt132)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:401:48: error_logging_clause
            	    {
            	        this->followPush(FOLLOW_error_logging_clause_in_update_statement3450);
            	        error_logging_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleupdate_statementEx; /* Prevent compiler warnings */
    ruleupdate_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end update_statement */

/**
 * $ANTLR start update_set_clause
 * PLSQL_DMLParser.g:405:1: update_set_clause : set_key ( column_based_update_set_clause ( COMMA column_based_update_set_clause )* | value_key LEFT_PAREN id RIGHT_PAREN EQUALS_OP expression ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::update_set_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:406:5: ( set_key ( column_based_update_set_clause ( COMMA column_based_update_set_clause )* | value_key LEFT_PAREN id RIGHT_PAREN EQUALS_OP expression ) )
        // PLSQL_DMLParser.g:406:10: set_key ( column_based_update_set_clause ( COMMA column_based_update_set_clause )* | value_key LEFT_PAREN id RIGHT_PAREN EQUALS_OP expression )
        {
            this->followPush(FOLLOW_set_key_in_update_set_clause3472);
            m_gPLSQLParser->set_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleupdate_set_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:407:5: ( column_based_update_set_clause ( COMMA column_based_update_set_clause )* | value_key LEFT_PAREN id RIGHT_PAREN EQUALS_OP expression )
            {
                int alt134=2;
                switch ( this->LA(1) )
                {
                case DELIMITED_ID:
                case INTRODUCER:
                case LEFT_PAREN:
                	{
                		alt134=1;
                	}
                    break;
                case REGULAR_ID:
                	{
                		switch ( this->LA(2) )
                		{
                		case EQUALS_OP:
                		case PERIOD:
                			{
                				alt134=1;
                			}
                		    break;
                		case LEFT_PAREN:
                			{
                				alt134=2;
                			}
                		    break;

                		default:
                		    if (this->get_backtracking()>0)
                		    {
                		        this->set_failedflag( true );
                		        return ;
                		    }

                		    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		    ex->set_decisionNum( 134 );
                		    ex->set_state( 2 );


                		    goto ruleupdate_set_clauseEx;

                		}

                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 134 );
                    ex->set_state( 0 );


                    goto ruleupdate_set_clauseEx;

                }

                switch (alt134)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:407:10: column_based_update_set_clause ( COMMA column_based_update_set_clause )*
            	    {
            	        this->followPush(FOLLOW_column_based_update_set_clause_in_update_set_clause3483);
            	        column_based_update_set_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:407:41: ( COMMA column_based_update_set_clause )*

            	        for (;;)
            	        {
            	            int alt133=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt133=1;
            	            	}
            	                break;

            	            }

            	            switch (alt133)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:407:42: COMMA column_based_update_set_clause
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_update_set_clause3486);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleupdate_set_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_column_based_update_set_clause_in_update_set_clause3488);
            	        	        column_based_update_set_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleupdate_set_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop133;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop133: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:408:10: value_key LEFT_PAREN id RIGHT_PAREN EQUALS_OP expression
            	    {
            	        this->followPush(FOLLOW_value_key_in_update_set_clause3501);
            	        m_gPLSQLParser->value_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_update_set_clause3503);
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_id_in_update_set_clause3505);
            	        m_gPLSQLParser->id();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_update_set_clause3507);
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_update_set_clause3509);
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_update_set_clause3511);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleupdate_set_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleupdate_set_clauseEx; /* Prevent compiler warnings */
    ruleupdate_set_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end update_set_clause */

/**
 * $ANTLR start column_based_update_set_clause
 * PLSQL_DMLParser.g:412:1: column_based_update_set_clause : ( column_name EQUALS_OP expression | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN EQUALS_OP subquery );
 */
void
PLSQLParser_PLSQL_DMLParser::column_based_update_set_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:413:5: ( column_name EQUALS_OP expression | LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN EQUALS_OP subquery )

            ANTLR_UINT32 alt136;

            alt136=2;

            switch ( this->LA(1) )
            {
            case DELIMITED_ID:
            case INTRODUCER:
            case REGULAR_ID:
            	{
            		alt136=1;
            	}
                break;
            case LEFT_PAREN:
            	{
            		alt136=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 136 );
                ex->set_state( 0 );


                goto rulecolumn_based_update_set_clauseEx;

            }

            switch (alt136)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:413:10: column_name EQUALS_OP expression
        	    {
        	        this->followPush(FOLLOW_column_name_in_column_based_update_set_clause3537);
        	        m_gPLSQLParser->column_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_column_based_update_set_clause3539);
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_in_column_based_update_set_clause3541);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:414:10: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN EQUALS_OP subquery
        	    {
        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_column_based_update_set_clause3552);
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_column_name_in_column_based_update_set_clause3554);
        	        m_gPLSQLParser->column_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:414:33: ( COMMA column_name )*

        	        for (;;)
        	        {
        	            int alt135=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt135=1;
        	            	}
        	                break;

        	            }

        	            switch (alt135)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:414:34: COMMA column_name
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_column_based_update_set_clause3557);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecolumn_based_update_set_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_column_name_in_column_based_update_set_clause3559);
        	        	        m_gPLSQLParser->column_name();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulecolumn_based_update_set_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop135;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop135: ; /* Jump out to here if this rule does not match */


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_column_based_update_set_clause3563);
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_column_based_update_set_clause3565);
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_subquery_in_column_based_update_set_clause3567);
        	        subquery();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecolumn_based_update_set_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulecolumn_based_update_set_clauseEx; /* Prevent compiler warnings */
    rulecolumn_based_update_set_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end column_based_update_set_clause */

/**
 * $ANTLR start delete_statement
 * PLSQL_DMLParser.g:419:1: delete_statement : delete_key ( from_key )? general_table_ref ( where_clause )? ( static_returning_clause )? ( error_logging_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::delete_statement()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:420:5: ( delete_key ( from_key )? general_table_ref ( where_clause )? ( static_returning_clause )? ( error_logging_clause )? )
        // PLSQL_DMLParser.g:420:10: delete_key ( from_key )? general_table_ref ( where_clause )? ( static_returning_clause )? ( error_logging_clause )?
        {
            this->followPush(FOLLOW_delete_key_in_delete_statement3589);
            m_gPLSQLParser->delete_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledelete_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:420:21: ( from_key )?
            {
                int alt137=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_FROM:
                    	{
                    		alt137=1;
                    	}
                        break;
                }

                switch (alt137)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:420:21: from_key
            	    {
            	        this->followPush(FOLLOW_from_key_in_delete_statement3591);
            	        m_gPLSQLParser->from_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledelete_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_general_table_ref_in_delete_statement3602);
            general_table_ref();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledelete_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:422:9: ( where_clause )?
            {
                int alt138=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_WHERE:
                    	{
                    		alt138=1;
                    	}
                        break;
                }

                switch (alt138)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:422:9: where_clause
            	    {
            	        this->followPush(FOLLOW_where_clause_in_delete_statement3612);
            	        m_gPLSQLParser->where_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledelete_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:422:23: ( static_returning_clause )?
            {
                int alt139=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA139_1 = this->LA(2);
                    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "RETURNING")))||((equalsIgnoreCase(LT(1)->getText(), "RETURN"))))))
                    		    {
                    		        alt139=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt139)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:422:23: static_returning_clause
            	    {
            	        this->followPush(FOLLOW_static_returning_clause_in_delete_statement3615);
            	        static_returning_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledelete_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:422:48: ( error_logging_clause )?
            {
                int alt140=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case REGULAR_ID:
                    		    	{
                    		    		{
                    		    		    int LA140_3 = this->LA(3);
                    		    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "LOG"))))
                    		    		    {
                    		    		        alt140=1;
                    		    		    }
                    		    		}
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt140)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:422:48: error_logging_clause
            	    {
            	        this->followPush(FOLLOW_error_logging_clause_in_delete_statement3618);
            	        error_logging_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledelete_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruledelete_statementEx; /* Prevent compiler warnings */
    ruledelete_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end delete_statement */

/**
 * $ANTLR start insert_statement
 * PLSQL_DMLParser.g:425:1: insert_statement : insert_key ( single_table_insert | multi_table_insert ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::insert_statement()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:426:5: ( insert_key ( single_table_insert | multi_table_insert ) )
        // PLSQL_DMLParser.g:426:10: insert_key ( single_table_insert | multi_table_insert )
        {
            this->followPush(FOLLOW_insert_key_in_insert_statement3639);
            m_gPLSQLParser->insert_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleinsert_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:427:5: ( single_table_insert | multi_table_insert )
            {
                int alt141=2;
                {
                    int LA141_0 = this->LA(1);
                    if ( (LA141_0 == SQL92_RESERVED_INTO))
                    {
                        alt141=1;
                    }
                    else if ( (LA141_0 == SQL92_RESERVED_ALL))
                    {
                        alt141=2;
                    }
                    else if ( ((equalsIgnoreCase(LT(1)->getText(), "FIRST"))) && (LA141_0 == REGULAR_ID))
                    {
                        alt141=2;
                    }
                    else if ( (LA141_0 == SQL92_RESERVED_WHEN))
                    {
                        alt141=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 141 );
                        ex->set_state( 0 );


                        goto ruleinsert_statementEx;

                    }
                }
                switch (alt141)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:427:10: single_table_insert
            	    {
            	        this->followPush(FOLLOW_single_table_insert_in_insert_statement3650);
            	        single_table_insert();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleinsert_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:428:10: multi_table_insert
            	    {
            	        this->followPush(FOLLOW_multi_table_insert_in_insert_statement3661);
            	        multi_table_insert();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleinsert_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinsert_statementEx; /* Prevent compiler warnings */
    ruleinsert_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end insert_statement */

/**
 * $ANTLR start single_table_insert
 * PLSQL_DMLParser.g:434:1: single_table_insert : insert_into_clause ( values_clause ( static_returning_clause )? | select_statement ) ( error_logging_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::single_table_insert()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:435:5: ( insert_into_clause ( values_clause ( static_returning_clause )? | select_statement ) ( error_logging_clause )? )
        // PLSQL_DMLParser.g:435:10: insert_into_clause ( values_clause ( static_returning_clause )? | select_statement ) ( error_logging_clause )?
        {
            this->followPush(FOLLOW_insert_into_clause_in_single_table_insert3689);
            insert_into_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesingle_table_insertEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:436:5: ( values_clause ( static_returning_clause )? | select_statement )
            {
                int alt143=2;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_VALUES:
                	{
                		alt143=1;
                	}
                    break;
                case LEFT_PAREN:
                case SQL92_RESERVED_SELECT:
                case SQL92_RESERVED_WITH:
                	{
                		alt143=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 143 );
                    ex->set_state( 0 );


                    goto rulesingle_table_insertEx;

                }

                switch (alt143)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:436:10: values_clause ( static_returning_clause )?
            	    {
            	        this->followPush(FOLLOW_values_clause_in_single_table_insert3700);
            	        values_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_table_insertEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:436:24: ( static_returning_clause )?
            	        {
            	            int alt142=2;
            	            switch ( this->LA(1) )
            	            {
            	                case REGULAR_ID:
            	                	{
            	                		{
            	                		    int LA142_1 = this->LA(2);
            	                		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "RETURNING")))||((equalsIgnoreCase(LT(1)->getText(), "RETURN"))))))
            	                		    {
            	                		        alt142=1;
            	                		    }
            	                		}
            	                	}
            	                    break;
            	            }

            	            switch (alt142)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:436:24: static_returning_clause
            	        	    {
            	        	        this->followPush(FOLLOW_static_returning_clause_in_single_table_insert3702);
            	        	        static_returning_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesingle_table_insertEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:437:10: select_statement
            	    {
            	        this->followPush(FOLLOW_select_statement_in_single_table_insert3714);
            	        select_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_table_insertEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:439:9: ( error_logging_clause )?
            {
                int alt144=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case REGULAR_ID:
                    		    	{
                    		    		{
                    		    		    int LA144_3 = this->LA(3);
                    		    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "LOG"))))
                    		    		    {
                    		    		        alt144=1;
                    		    		    }
                    		    		}
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt144)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:439:9: error_logging_clause
            	    {
            	        this->followPush(FOLLOW_error_logging_clause_in_single_table_insert3730);
            	        error_logging_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_table_insertEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesingle_table_insertEx; /* Prevent compiler warnings */
    rulesingle_table_insertEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end single_table_insert */

/**
 * $ANTLR start multi_table_insert
 * PLSQL_DMLParser.g:442:1: multi_table_insert : ( all_key ( multi_table_element )+ | conditional_insert_clause ) select_statement ;
 */
void
PLSQLParser_PLSQL_DMLParser::multi_table_insert()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:443:5: ( ( all_key ( multi_table_element )+ | conditional_insert_clause ) select_statement )
        // PLSQL_DMLParser.g:444:5: ( all_key ( multi_table_element )+ | conditional_insert_clause ) select_statement
        {
            // PLSQL_DMLParser.g:444:5: ( all_key ( multi_table_element )+ | conditional_insert_clause )
            {
                int alt146=2;
                {
                    int LA146_0 = this->LA(1);
                    if ( (LA146_0 == SQL92_RESERVED_ALL))
                    {
                        switch ( this->LA(2) )
                        {
                        case SQL92_RESERVED_INTO:
                        	{
                        		alt146=1;
                        	}
                            break;
                        case SQL92_RESERVED_WHEN:
                        	{
                        		alt146=2;
                        	}
                            break;

                        default:
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }

                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 146 );
                            ex->set_state( 1 );


                            goto rulemulti_table_insertEx;

                        }

                    }
                    else if ( ((equalsIgnoreCase(LT(1)->getText(), "FIRST"))) && (LA146_0 == REGULAR_ID))
                    {
                        alt146=2;
                    }
                    else if ( (LA146_0 == SQL92_RESERVED_WHEN))
                    {
                        alt146=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 146 );
                        ex->set_state( 0 );


                        goto rulemulti_table_insertEx;

                    }
                }
                switch (alt146)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:444:10: all_key ( multi_table_element )+
            	    {
            	        this->followPush(FOLLOW_all_key_in_multi_table_insert3761);
            	        m_gPLSQLParser->all_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_table_insertEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:444:18: ( multi_table_element )+
            	        {
            	            int cnt145=0;

            	            for (;;)
            	            {
            	                int alt145=2;
            	        	switch ( this->LA(1) )
            	        	{
            	        	case SQL92_RESERVED_INTO:
            	        		{
            	        			alt145=1;
            	        		}
            	        	    break;

            	        	}

            	        	switch (alt145)
            	        	{
            	        	    case 1:
            	        	        // PLSQL_DMLParser.g:444:18: multi_table_element
            	        	        {
            	        	            this->followPush(FOLLOW_multi_table_element_in_multi_table_insert3763);
            	        	            multi_table_element();

            	        	            this->followPop();
            	        	            if  (this->hasException())
            	        	            {
            	        	                goto rulemulti_table_insertEx;
            	        	            }
            	        	            if (this->hasFailed())
            	        	            {
            	        	                return ;
            	        	            }


            	        	        }
            	        	        break;

            	        	    default:

            	        		if ( cnt145 >= 1 )
            	        		{
            	        		    goto loop145;
            	        		}
            	        		if (this->get_backtracking()>0)
            	        		{
            	        		    this->set_failedflag( true );
            	        		    return ;
            	        		}

            	        		/* mismatchedSetEx()
            	        		 */
            	        		new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            	        		goto rulemulti_table_insertEx;
            	        	}
            	        	cnt145++;
            	            }
            	            loop145: ;	/* Jump to here if this rule does not match */
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:445:10: conditional_insert_clause
            	    {
            	        this->followPush(FOLLOW_conditional_insert_clause_in_multi_table_insert3775);
            	        conditional_insert_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_table_insertEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_select_statement_in_multi_table_insert3791);
            select_statement();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemulti_table_insertEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemulti_table_insertEx; /* Prevent compiler warnings */
    rulemulti_table_insertEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multi_table_insert */

/**
 * $ANTLR start multi_table_element
 * PLSQL_DMLParser.g:450:1: multi_table_element : insert_into_clause ( values_clause )? ( error_logging_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::multi_table_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:451:5: ( insert_into_clause ( values_clause )? ( error_logging_clause )? )
        // PLSQL_DMLParser.g:451:10: insert_into_clause ( values_clause )? ( error_logging_clause )?
        {
            this->followPush(FOLLOW_insert_into_clause_in_multi_table_element3811);
            insert_into_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemulti_table_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:451:29: ( values_clause )?
            {
                int alt147=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_VALUES:
                    	{
                    		alt147=1;
                    	}
                        break;
                }

                switch (alt147)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:451:29: values_clause
            	    {
            	        this->followPush(FOLLOW_values_clause_in_multi_table_element3813);
            	        values_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_table_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:451:44: ( error_logging_clause )?
            {
                int alt148=2;
                {
                    int LA148_0 = this->LA(1);
                    if ( ((equalsIgnoreCase(LT(1)->getText(), "LOG"))) && (LA148_0 == REGULAR_ID))
                    {
                        alt148=1;
                    }
                }
                switch (alt148)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:451:44: error_logging_clause
            	    {
            	        this->followPush(FOLLOW_error_logging_clause_in_multi_table_element3816);
            	        error_logging_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_table_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemulti_table_elementEx; /* Prevent compiler warnings */
    rulemulti_table_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multi_table_element */

/**
 * $ANTLR start conditional_insert_clause
 * PLSQL_DMLParser.g:454:1: conditional_insert_clause : ( all_key | first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::conditional_insert_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:455:5: ( ( all_key | first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )? )
        // PLSQL_DMLParser.g:455:10: ( all_key | first_key )? ( conditional_insert_when_part )+ ( conditional_insert_else_part )?
        {
            // PLSQL_DMLParser.g:455:10: ( all_key | first_key )?
            {
                int alt149=3;
                {
                    int LA149_0 = this->LA(1);
                    if ( (LA149_0 == SQL92_RESERVED_ALL))
                    {
                        alt149=1;
                    }
                    else if ( ((equalsIgnoreCase(LT(1)->getText(), "FIRST"))) && (LA149_0 == REGULAR_ID))
                    {
                        alt149=2;
                    }
                }
                switch (alt149)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:455:11: all_key
            	    {
            	        this->followPush(FOLLOW_all_key_in_conditional_insert_clause3838);
            	        m_gPLSQLParser->all_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconditional_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:455:19: first_key
            	    {
            	        this->followPush(FOLLOW_first_key_in_conditional_insert_clause3840);
            	        m_gPLSQLParser->first_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconditional_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:456:9: ( conditional_insert_when_part )+
            {
                int cnt150=0;

                for (;;)
                {
                    int alt150=2;
            	switch ( this->LA(1) )
            	{
            	case SQL92_RESERVED_WHEN:
            		{
            			alt150=1;
            		}
            	    break;

            	}

            	switch (alt150)
            	{
            	    case 1:
            	        // PLSQL_DMLParser.g:456:9: conditional_insert_when_part
            	        {
            	            this->followPush(FOLLOW_conditional_insert_when_part_in_conditional_insert_clause3852);
            	            conditional_insert_when_part();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleconditional_insert_clauseEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt150 >= 1 )
            		{
            		    goto loop150;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleconditional_insert_clauseEx;
            	}
            	cnt150++;
                }
                loop150: ;	/* Jump to here if this rule does not match */
            }

            // PLSQL_DMLParser.g:456:39: ( conditional_insert_else_part )?
            {
                int alt151=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_ELSE:
                    	{
                    		alt151=1;
                    	}
                        break;
                }

                switch (alt151)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:456:39: conditional_insert_else_part
            	    {
            	        this->followPush(FOLLOW_conditional_insert_else_part_in_conditional_insert_clause3855);
            	        conditional_insert_else_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconditional_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconditional_insert_clauseEx; /* Prevent compiler warnings */
    ruleconditional_insert_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end conditional_insert_clause */

/**
 * $ANTLR start conditional_insert_when_part
 * PLSQL_DMLParser.g:459:1: conditional_insert_when_part : when_key condition then_key ( multi_table_element )+ ;
 */
void
PLSQLParser_PLSQL_DMLParser::conditional_insert_when_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:460:5: ( when_key condition then_key ( multi_table_element )+ )
        // PLSQL_DMLParser.g:460:10: when_key condition then_key ( multi_table_element )+
        {
            this->followPush(FOLLOW_when_key_in_conditional_insert_when_part3876);
            m_gPLSQLParser->when_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconditional_insert_when_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_condition_in_conditional_insert_when_part3878);
            condition();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconditional_insert_when_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_then_key_in_conditional_insert_when_part3880);
            m_gPLSQLParser->then_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconditional_insert_when_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:460:38: ( multi_table_element )+
            {
                int cnt152=0;

                for (;;)
                {
                    int alt152=2;
            	switch ( this->LA(1) )
            	{
            	case SQL92_RESERVED_INTO:
            		{
            			alt152=1;
            		}
            	    break;

            	}

            	switch (alt152)
            	{
            	    case 1:
            	        // PLSQL_DMLParser.g:460:38: multi_table_element
            	        {
            	            this->followPush(FOLLOW_multi_table_element_in_conditional_insert_when_part3882);
            	            multi_table_element();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleconditional_insert_when_partEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt152 >= 1 )
            		{
            		    goto loop152;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleconditional_insert_when_partEx;
            	}
            	cnt152++;
                }
                loop152: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconditional_insert_when_partEx; /* Prevent compiler warnings */
    ruleconditional_insert_when_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end conditional_insert_when_part */

/**
 * $ANTLR start conditional_insert_else_part
 * PLSQL_DMLParser.g:463:1: conditional_insert_else_part : else_key ( multi_table_element )+ ;
 */
void
PLSQLParser_PLSQL_DMLParser::conditional_insert_else_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:464:5: ( else_key ( multi_table_element )+ )
        // PLSQL_DMLParser.g:464:10: else_key ( multi_table_element )+
        {
            this->followPush(FOLLOW_else_key_in_conditional_insert_else_part3903);
            m_gPLSQLParser->else_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconditional_insert_else_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:464:19: ( multi_table_element )+
            {
                int cnt153=0;

                for (;;)
                {
                    int alt153=2;
            	switch ( this->LA(1) )
            	{
            	case SQL92_RESERVED_INTO:
            		{
            			alt153=1;
            		}
            	    break;

            	}

            	switch (alt153)
            	{
            	    case 1:
            	        // PLSQL_DMLParser.g:464:19: multi_table_element
            	        {
            	            this->followPush(FOLLOW_multi_table_element_in_conditional_insert_else_part3905);
            	            multi_table_element();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleconditional_insert_else_partEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt153 >= 1 )
            		{
            		    goto loop153;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleconditional_insert_else_partEx;
            	}
            	cnt153++;
                }
                loop153: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconditional_insert_else_partEx; /* Prevent compiler warnings */
    ruleconditional_insert_else_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end conditional_insert_else_part */

/**
 * $ANTLR start insert_into_clause
 * PLSQL_DMLParser.g:467:1: insert_into_clause : into_key general_table_ref ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::insert_into_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:468:5: ( into_key general_table_ref ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? )
        // PLSQL_DMLParser.g:468:10: into_key general_table_ref ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )?
        {
            this->followPush(FOLLOW_into_key_in_insert_into_clause3926);
            m_gPLSQLParser->into_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleinsert_into_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_general_table_ref_in_insert_into_clause3928);
            general_table_ref();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleinsert_into_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:469:9: ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )?
            {
                int alt155=2;
                switch ( this->LA(1) )
                {
                    case LEFT_PAREN:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case DELIMITED_ID:
                    		    case INTRODUCER:
                    		    case REGULAR_ID:
                    		    	{
                    		    		alt155=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt155)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:469:10: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_insert_into_clause3940);
            	        if  (this->hasException())
            	        {
            	            goto ruleinsert_into_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_insert_into_clause3942);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleinsert_into_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:469:33: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            int alt154=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt154=1;
            	            	}
            	                break;

            	            }

            	            switch (alt154)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:469:34: COMMA column_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_insert_into_clause3945);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleinsert_into_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_column_name_in_insert_into_clause3947);
            	        	        m_gPLSQLParser->column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleinsert_into_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop154;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop154: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_insert_into_clause3951);
            	        if  (this->hasException())
            	        {
            	            goto ruleinsert_into_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinsert_into_clauseEx; /* Prevent compiler warnings */
    ruleinsert_into_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end insert_into_clause */

/**
 * $ANTLR start values_clause
 * PLSQL_DMLParser.g:472:1: values_clause : values_key expression_list ;
 */
void
PLSQLParser_PLSQL_DMLParser::values_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:473:5: ( values_key expression_list )
        // PLSQL_DMLParser.g:473:10: values_key expression_list
        {
            this->followPush(FOLLOW_values_key_in_values_clause3973);
            m_gPLSQLParser->values_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulevalues_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_list_in_values_clause3975);
            expression_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulevalues_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevalues_clauseEx; /* Prevent compiler warnings */
    rulevalues_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end values_clause */

/**
 * $ANTLR start merge_statement
 * PLSQL_DMLParser.g:477:1: merge_statement : merge_key into_key tableview_name ( table_alias )? using_key selected_tableview on_key LEFT_PAREN condition RIGHT_PAREN ( ( when_key matched_key )=> merge_update_clause ( merge_insert_clause )? | ( when_key not_key matched_key )=> merge_insert_clause ( merge_update_clause )? )? ( error_logging_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::merge_statement()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:478:5: ( merge_key into_key tableview_name ( table_alias )? using_key selected_tableview on_key LEFT_PAREN condition RIGHT_PAREN ( ( when_key matched_key )=> merge_update_clause ( merge_insert_clause )? | ( when_key not_key matched_key )=> merge_insert_clause ( merge_update_clause )? )? ( error_logging_clause )? )
        // PLSQL_DMLParser.g:478:10: merge_key into_key tableview_name ( table_alias )? using_key selected_tableview on_key LEFT_PAREN condition RIGHT_PAREN ( ( when_key matched_key )=> merge_update_clause ( merge_insert_clause )? | ( when_key not_key matched_key )=> merge_insert_clause ( merge_update_clause )? )? ( error_logging_clause )?
        {
            this->followPush(FOLLOW_merge_key_in_merge_statement3996);
            m_gPLSQLParser->merge_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_into_key_in_merge_statement3998);
            m_gPLSQLParser->into_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_tableview_name_in_merge_statement4000);
            m_gPLSQLParser->tableview_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:478:44: ( table_alias )?
            {
                int alt156=2;
                switch ( this->LA(1) )
                {
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case DELIMITED_ID:
                    case INTRODUCER:
                    case NATIONAL_CHAR_STRING_LIT:
                    case REGULAR_ID:
                    	{
                    		alt156=1;
                    	}
                        break;
                }

                switch (alt156)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:478:44: table_alias
            	    {
            	        this->followPush(FOLLOW_table_alias_in_merge_statement4002);
            	        m_gPLSQLParser->table_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_using_key_in_merge_statement4013);
            m_gPLSQLParser->using_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_selected_tableview_in_merge_statement4015);
            selected_tableview();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_on_key_in_merge_statement4017);
            m_gPLSQLParser->on_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_merge_statement4019);
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_condition_in_merge_statement4021);
            condition();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_merge_statement4023);
            if  (this->hasException())
            {
                goto rulemerge_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:480:9: ( ( when_key matched_key )=> merge_update_clause ( merge_insert_clause )? | ( when_key not_key matched_key )=> merge_insert_clause ( merge_update_clause )? )?
            {
                int alt159=3;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_WHEN:
                    	{
                    		{
                    		    int LA159_1 = this->LA(2);
                    		    if ( (this->msynpred( antlr3::ClassForwarder<synpred20_PLSQL_DMLParser>() )) && (LA159_1 == REGULAR_ID))
                    		    {
                    		        alt159=1;
                    		    }
                    		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred21_PLSQL_DMLParser>() )) && (LA159_1 == SQL92_RESERVED_NOT))
                    		    {
                    		        alt159=2;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt159)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:481:13: ( when_key matched_key )=> merge_update_clause ( merge_insert_clause )?
            	    {
            	        this->followPush(FOLLOW_merge_update_clause_in_merge_statement4055);
            	        merge_update_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:481:59: ( merge_insert_clause )?
            	        {
            	            int alt157=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_WHEN:
            	                	{
            	                		alt157=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt157)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:481:59: merge_insert_clause
            	        	    {
            	        	        this->followPush(FOLLOW_merge_insert_clause_in_merge_statement4057);
            	        	        merge_insert_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemerge_statementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:483:13: ( when_key not_key matched_key )=> merge_insert_clause ( merge_update_clause )?
            	    {
            	        this->followPush(FOLLOW_merge_insert_clause_in_merge_statement4092);
            	        merge_insert_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:483:67: ( merge_update_clause )?
            	        {
            	            int alt158=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_WHEN:
            	                	{
            	                		alt158=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt158)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:483:67: merge_update_clause
            	        	    {
            	        	        this->followPush(FOLLOW_merge_update_clause_in_merge_statement4094);
            	        	        merge_update_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemerge_statementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:485:9: ( error_logging_clause )?
            {
                int alt160=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case REGULAR_ID:
                    		    	{
                    		    		{
                    		    		    int LA160_3 = this->LA(3);
                    		    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "LOG"))))
                    		    		    {
                    		    		        alt160=1;
                    		    		    }
                    		    		}
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt160)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:485:9: error_logging_clause
            	    {
            	        this->followPush(FOLLOW_error_logging_clause_in_merge_statement4116);
            	        error_logging_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemerge_statementEx; /* Prevent compiler warnings */
    rulemerge_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end merge_statement */

/**
 * $ANTLR start merge_update_clause
 * PLSQL_DMLParser.g:490:1: merge_update_clause : when_key matched_key then_key update_key set_key merge_element ( COMMA merge_element )* ( where_clause )? ( merge_update_delete_part )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::merge_update_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:491:5: ( when_key matched_key then_key update_key set_key merge_element ( COMMA merge_element )* ( where_clause )? ( merge_update_delete_part )? )
        // PLSQL_DMLParser.g:491:10: when_key matched_key then_key update_key set_key merge_element ( COMMA merge_element )* ( where_clause )? ( merge_update_delete_part )?
        {
            this->followPush(FOLLOW_when_key_in_merge_update_clause4139);
            m_gPLSQLParser->when_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_matched_key_in_merge_update_clause4141);
            m_gPLSQLParser->matched_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_then_key_in_merge_update_clause4143);
            m_gPLSQLParser->then_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_update_key_in_merge_update_clause4145);
            m_gPLSQLParser->update_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_set_key_in_merge_update_clause4147);
            m_gPLSQLParser->set_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_merge_element_in_merge_update_clause4158);
            merge_element();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:492:23: ( COMMA merge_element )*

            for (;;)
            {
                int alt161=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt161=1;
                	}
                    break;

                }

                switch (alt161)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:492:24: COMMA merge_element
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_merge_update_clause4161);
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_update_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_merge_element_in_merge_update_clause4163);
            	        merge_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_update_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop161;	/* break out of the loop */
            	    break;
                }
            }
            loop161: ; /* Jump out to here if this rule does not match */


            // PLSQL_DMLParser.g:493:9: ( where_clause )?
            {
                int alt162=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_WHERE:
                    	{
                    		alt162=1;
                    	}
                        break;
                }

                switch (alt162)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:493:9: where_clause
            	    {
            	        this->followPush(FOLLOW_where_clause_in_merge_update_clause4175);
            	        m_gPLSQLParser->where_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_update_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:493:23: ( merge_update_delete_part )?
            {
                int alt163=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_DELETE:
                    	{
                    		switch ( this->LA(2) )
                    		{
                    		    case SQL92_RESERVED_WHERE:
                    		    	{
                    		    		alt163=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt163)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:493:23: merge_update_delete_part
            	    {
            	        this->followPush(FOLLOW_merge_update_delete_part_in_merge_update_clause4178);
            	        merge_update_delete_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_update_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemerge_update_clauseEx; /* Prevent compiler warnings */
    rulemerge_update_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end merge_update_clause */

/**
 * $ANTLR start merge_element
 * PLSQL_DMLParser.g:496:1: merge_element : column_name EQUALS_OP expression ;
 */
void
PLSQLParser_PLSQL_DMLParser::merge_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:497:5: ( column_name EQUALS_OP expression )
        // PLSQL_DMLParser.g:497:10: column_name EQUALS_OP expression
        {
            this->followPush(FOLLOW_column_name_in_merge_element4199);
            m_gPLSQLParser->column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_merge_element4201);
            if  (this->hasException())
            {
                goto rulemerge_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_merge_element4203);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemerge_elementEx; /* Prevent compiler warnings */
    rulemerge_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end merge_element */

/**
 * $ANTLR start merge_update_delete_part
 * PLSQL_DMLParser.g:500:1: merge_update_delete_part : delete_key where_clause ;
 */
void
PLSQLParser_PLSQL_DMLParser::merge_update_delete_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:501:5: ( delete_key where_clause )
        // PLSQL_DMLParser.g:501:10: delete_key where_clause
        {
            this->followPush(FOLLOW_delete_key_in_merge_update_delete_part4223);
            m_gPLSQLParser->delete_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_delete_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_where_clause_in_merge_update_delete_part4225);
            m_gPLSQLParser->where_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_update_delete_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemerge_update_delete_partEx; /* Prevent compiler warnings */
    rulemerge_update_delete_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end merge_update_delete_part */

/**
 * $ANTLR start merge_insert_clause
 * PLSQL_DMLParser.g:504:1: merge_insert_clause : when_key not_key matched_key then_key insert_key ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? values_key expression_list ( where_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::merge_insert_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:505:5: ( when_key not_key matched_key then_key insert_key ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? values_key expression_list ( where_clause )? )
        // PLSQL_DMLParser.g:505:10: when_key not_key matched_key then_key insert_key ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )? values_key expression_list ( where_clause )?
        {
            this->followPush(FOLLOW_when_key_in_merge_insert_clause4245);
            m_gPLSQLParser->when_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_not_key_in_merge_insert_clause4247);
            m_gPLSQLParser->not_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_matched_key_in_merge_insert_clause4249);
            m_gPLSQLParser->matched_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_then_key_in_merge_insert_clause4251);
            m_gPLSQLParser->then_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_insert_key_in_merge_insert_clause4253);
            m_gPLSQLParser->insert_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:506:9: ( LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN )?
            {
                int alt165=2;
                switch ( this->LA(1) )
                {
                    case LEFT_PAREN:
                    	{
                    		alt165=1;
                    	}
                        break;
                }

                switch (alt165)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:506:10: LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_merge_insert_clause4265);
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_merge_insert_clause4267);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:506:33: ( COMMA column_name )*

            	        for (;;)
            	        {
            	            int alt164=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt164=1;
            	            	}
            	                break;

            	            }

            	            switch (alt164)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:506:34: COMMA column_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_merge_insert_clause4270);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemerge_insert_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_column_name_in_merge_insert_clause4272);
            	        	        m_gPLSQLParser->column_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemerge_insert_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop164;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop164: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_merge_insert_clause4276);
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_values_key_in_merge_insert_clause4288);
            m_gPLSQLParser->values_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_list_in_merge_insert_clause4290);
            expression_list();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemerge_insert_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:507:36: ( where_clause )?
            {
                int alt166=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_WHERE:
                    	{
                    		alt166=1;
                    	}
                        break;
                }

                switch (alt166)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:507:36: where_clause
            	    {
            	        this->followPush(FOLLOW_where_clause_in_merge_insert_clause4292);
            	        m_gPLSQLParser->where_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemerge_insert_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemerge_insert_clauseEx; /* Prevent compiler warnings */
    rulemerge_insert_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end merge_insert_clause */

/**
 * $ANTLR start selected_tableview
 * PLSQL_DMLParser.g:510:1: selected_tableview : ( tableview_name | LEFT_PAREN select_statement RIGHT_PAREN ) ( table_alias )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::selected_tableview()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:511:5: ( ( tableview_name | LEFT_PAREN select_statement RIGHT_PAREN ) ( table_alias )? )
        // PLSQL_DMLParser.g:511:10: ( tableview_name | LEFT_PAREN select_statement RIGHT_PAREN ) ( table_alias )?
        {
            // PLSQL_DMLParser.g:511:10: ( tableview_name | LEFT_PAREN select_statement RIGHT_PAREN )
            {
                int alt167=2;
                switch ( this->LA(1) )
                {
                case DELIMITED_ID:
                case INTRODUCER:
                case REGULAR_ID:
                	{
                		alt167=1;
                	}
                    break;
                case LEFT_PAREN:
                	{
                		alt167=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 167 );
                    ex->set_state( 0 );


                    goto ruleselected_tableviewEx;

                }

                switch (alt167)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:511:12: tableview_name
            	    {
            	        this->followPush(FOLLOW_tableview_name_in_selected_tableview4315);
            	        m_gPLSQLParser->tableview_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_tableviewEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:511:29: LEFT_PAREN select_statement RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_selected_tableview4319);
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_tableviewEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_select_statement_in_selected_tableview4321);
            	        select_statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_tableviewEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_selected_tableview4323);
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_tableviewEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:511:71: ( table_alias )?
            {
                int alt168=2;
                switch ( this->LA(1) )
                {
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case DELIMITED_ID:
                    case INTRODUCER:
                    case NATIONAL_CHAR_STRING_LIT:
                    case REGULAR_ID:
                    	{
                    		alt168=1;
                    	}
                        break;
                }

                switch (alt168)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:511:71: table_alias
            	    {
            	        this->followPush(FOLLOW_table_alias_in_selected_tableview4327);
            	        m_gPLSQLParser->table_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleselected_tableviewEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleselected_tableviewEx; /* Prevent compiler warnings */
    ruleselected_tableviewEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end selected_tableview */

/**
 * $ANTLR start lock_table_statement
 * PLSQL_DMLParser.g:516:1: lock_table_statement : lock_key table_key lock_table_element ( COMMA lock_table_element )* in_key lock_mode mode_key ( wait_nowait_part )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::lock_table_statement()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:517:5: ( lock_key table_key lock_table_element ( COMMA lock_table_element )* in_key lock_mode mode_key ( wait_nowait_part )? )
        // PLSQL_DMLParser.g:517:10: lock_key table_key lock_table_element ( COMMA lock_table_element )* in_key lock_mode mode_key ( wait_nowait_part )?
        {
            this->followPush(FOLLOW_lock_key_in_lock_table_statement4350);
            m_gPLSQLParser->lock_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_table_key_in_lock_table_statement4352);
            m_gPLSQLParser->table_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_lock_table_element_in_lock_table_statement4363);
            lock_table_element();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:518:28: ( COMMA lock_table_element )*

            for (;;)
            {
                int alt169=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt169=1;
                	}
                    break;

                }

                switch (alt169)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:518:29: COMMA lock_table_element
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_lock_table_statement4366);
            	        if  (this->hasException())
            	        {
            	            goto rulelock_table_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_lock_table_element_in_lock_table_statement4368);
            	        lock_table_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulelock_table_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop169;	/* break out of the loop */
            	    break;
                }
            }
            loop169: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_in_key_in_lock_table_statement4381);
            m_gPLSQLParser->in_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_lock_mode_in_lock_table_statement4383);
            lock_mode();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_mode_key_in_lock_table_statement4385);
            m_gPLSQLParser->mode_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:519:35: ( wait_nowait_part )?
            {
                int alt170=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA170_1 = this->LA(2);
                    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "WAIT"))))
                    		    {
                    		        alt170=1;
                    		    }
                    		}
                    	}
                        break;
                    case PLSQL_RESERVED_NOWAIT:
                    	{
                    		alt170=1;
                    	}
                        break;
                }

                switch (alt170)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:519:35: wait_nowait_part
            	    {
            	        this->followPush(FOLLOW_wait_nowait_part_in_lock_table_statement4387);
            	        wait_nowait_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulelock_table_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulelock_table_statementEx; /* Prevent compiler warnings */
    rulelock_table_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end lock_table_statement */

/**
 * $ANTLR start wait_nowait_part
 * PLSQL_DMLParser.g:522:1: wait_nowait_part : ( wait_key expression | nowait_key );
 */
void
PLSQLParser_PLSQL_DMLParser::wait_nowait_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:523:5: ( wait_key expression | nowait_key )

            ANTLR_UINT32 alt171;

            alt171=2;

            {
                int LA171_0 = this->LA(1);
                if ( ((equalsIgnoreCase(LT(1)->getText(), "WAIT"))) && (LA171_0 == REGULAR_ID))
                {
                    alt171=1;
                }
                else if ( (LA171_0 == PLSQL_RESERVED_NOWAIT))
                {
                    alt171=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 171 );
                    ex->set_state( 0 );


                    goto rulewait_nowait_partEx;

                }
            }
            switch (alt171)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:523:10: wait_key expression
        	    {
        	        this->followPush(FOLLOW_wait_key_in_wait_nowait_part4408);
        	        m_gPLSQLParser->wait_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewait_nowait_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_in_wait_nowait_part4410);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewait_nowait_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:524:10: nowait_key
        	    {
        	        this->followPush(FOLLOW_nowait_key_in_wait_nowait_part4421);
        	        m_gPLSQLParser->nowait_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewait_nowait_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulewait_nowait_partEx; /* Prevent compiler warnings */
    rulewait_nowait_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end wait_nowait_part */

/**
 * $ANTLR start lock_table_element
 * PLSQL_DMLParser.g:529:1: lock_table_element : tableview_name ( partition_extension_clause )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::lock_table_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:530:5: ( tableview_name ( partition_extension_clause )? )
        // PLSQL_DMLParser.g:530:10: tableview_name ( partition_extension_clause )?
        {
            this->followPush(FOLLOW_tableview_name_in_lock_table_element4443);
            m_gPLSQLParser->tableview_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelock_table_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:530:25: ( partition_extension_clause )?
            {
                int alt172=2;
                {
                    int LA172_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "PARTITION")))||((equalsIgnoreCase(LT(1)->getText(), "SUBPARTITION"))))) && (LA172_0 == REGULAR_ID))
                    {
                        alt172=1;
                    }
                }
                switch (alt172)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:530:25: partition_extension_clause
            	    {
            	        this->followPush(FOLLOW_partition_extension_clause_in_lock_table_element4445);
            	        m_gPLSQLParser->partition_extension_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulelock_table_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulelock_table_elementEx; /* Prevent compiler warnings */
    rulelock_table_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end lock_table_element */

/**
 * $ANTLR start lock_mode
 * PLSQL_DMLParser.g:533:1: lock_mode : ( row_key share_key | row_key exclusive_key | share_key ( update_key )? | share_key row_key exclusive_key | exclusive_key );
 */
void
PLSQLParser_PLSQL_DMLParser::lock_mode()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:534:5: ( row_key share_key | row_key exclusive_key | share_key ( update_key )? | share_key row_key exclusive_key | exclusive_key )

            ANTLR_UINT32 alt174;

            alt174=5;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		switch ( this->LA(2) )
            		{
            		case PLSQL_RESERVED_SHARE:
            			{
            				alt174=1;
            			}
            		    break;
            		case PLSQL_RESERVED_EXCLUSIVE:
            			{
            				alt174=2;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 174 );
            		    ex->set_state( 1 );


            		    goto rulelock_modeEx;

            		}

            	}
                break;
            case PLSQL_RESERVED_SHARE:
            	{
            		switch ( this->LA(2) )
            		{
            		case PLSQL_RESERVED_MODE:
            		case SQL92_RESERVED_UPDATE:
            			{
            				alt174=3;
            			}
            		    break;
            		case REGULAR_ID:
            			{
            				alt174=4;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 174 );
            		    ex->set_state( 2 );


            		    goto rulelock_modeEx;

            		}

            	}
                break;
            case PLSQL_RESERVED_EXCLUSIVE:
            	{
            		alt174=5;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 174 );
                ex->set_state( 0 );


                goto rulelock_modeEx;

            }

            switch (alt174)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:534:10: row_key share_key
        	    {
        	        this->followPush(FOLLOW_row_key_in_lock_mode4466);
        	        m_gPLSQLParser->row_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_share_key_in_lock_mode4468);
        	        m_gPLSQLParser->share_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:535:10: row_key exclusive_key
        	    {
        	        this->followPush(FOLLOW_row_key_in_lock_mode4479);
        	        m_gPLSQLParser->row_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_exclusive_key_in_lock_mode4481);
        	        m_gPLSQLParser->exclusive_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:536:10: share_key ( update_key )?
        	    {
        	        this->followPush(FOLLOW_share_key_in_lock_mode4492);
        	        m_gPLSQLParser->share_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:536:20: ( update_key )?
        	        {
        	            int alt173=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_UPDATE:
        	                	{
        	                		alt173=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt173)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:536:20: update_key
        	        	    {
        	        	        this->followPush(FOLLOW_update_key_in_lock_mode4494);
        	        	        m_gPLSQLParser->update_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulelock_modeEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 4:
        	    // PLSQL_DMLParser.g:537:10: share_key row_key exclusive_key
        	    {
        	        this->followPush(FOLLOW_share_key_in_lock_mode4506);
        	        m_gPLSQLParser->share_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_row_key_in_lock_mode4508);
        	        m_gPLSQLParser->row_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_exclusive_key_in_lock_mode4510);
        	        m_gPLSQLParser->exclusive_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQL_DMLParser.g:538:10: exclusive_key
        	    {
        	        this->followPush(FOLLOW_exclusive_key_in_lock_mode4521);
        	        m_gPLSQLParser->exclusive_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelock_modeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulelock_modeEx; /* Prevent compiler warnings */
    rulelock_modeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end lock_mode */

/**
 * $ANTLR start general_table_ref
 * PLSQL_DMLParser.g:544:1: general_table_ref : ( dml_table_expression_clause | only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN ) ( table_alias )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::general_table_ref()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:545:5: ( ( dml_table_expression_clause | only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN ) ( table_alias )? )
        // PLSQL_DMLParser.g:545:10: ( dml_table_expression_clause | only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN ) ( table_alias )?
        {
            // PLSQL_DMLParser.g:545:10: ( dml_table_expression_clause | only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN )
            {
                int alt175=2;
                switch ( this->LA(1) )
                {
                case DELIMITED_ID:
                case INTRODUCER:
                case LEFT_PAREN:
                case SQL92_RESERVED_TABLE:
                case SQL92_RESERVED_THE:
                	{
                		alt175=1;
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    int LA175_5 = this->LA(2);
                		    if ( (!( ((equalsIgnoreCase(LT(1)->getText(), "ONLY"))) )))
                		    {
                		        alt175=1;
                		    }
                		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "ONLY"))))
                		    {
                		        alt175=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 175 );
                		        ex->set_state( 5 );


                		        goto rulegeneral_table_refEx;

                		    }
                		}
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 175 );
                    ex->set_state( 0 );


                    goto rulegeneral_table_refEx;

                }

                switch (alt175)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:545:15: dml_table_expression_clause
            	    {
            	        this->followPush(FOLLOW_dml_table_expression_clause_in_general_table_ref4549);
            	        dml_table_expression_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_table_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:546:14: only_key LEFT_PAREN dml_table_expression_clause RIGHT_PAREN
            	    {
            	        this->followPush(FOLLOW_only_key_in_general_table_ref4564);
            	        m_gPLSQLParser->only_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_table_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_general_table_ref4566);
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_table_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_dml_table_expression_clause_in_general_table_ref4568);
            	        dml_table_expression_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_table_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_general_table_ref4570);
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_table_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:547:14: ( table_alias )?
            {
                int alt176=2;
                switch ( this->LA(1) )
                {
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case DELIMITED_ID:
                    case INTRODUCER:
                    case NATIONAL_CHAR_STRING_LIT:
                    	{
                    		alt176=1;
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA176_2 = this->LA(2);
                    		    if ( (!( ((((equalsIgnoreCase(LT(1)->getText(), "RETURNING")))||((equalsIgnoreCase(LT(1)->getText(), "EXPLAIN")))||((equalsIgnoreCase(LT(1)->getText(), "MERGE")))||((equalsIgnoreCase(LT(1)->getText(), "RETURN")))||((equalsIgnoreCase(LT(1)->getText(), "LOG")))||((equalsIgnoreCase(LT(1)->getText(), "SET")))||((equalsIgnoreCase(LT(1)->getText(), "EXIT")))||((equalsIgnoreCase(LT(1)->getText(), "FUNCTION")))||((equalsIgnoreCase(LT(1)->getText(), "SAVE")))||((equalsIgnoreCase(LT(1)->getText(), "WHENEVER"))))) )))
                    		    {
                    		        alt176=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt176)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:547:14: table_alias
            	    {
            	        this->followPush(FOLLOW_table_alias_in_general_table_ref4585);
            	        m_gPLSQLParser->table_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulegeneral_table_refEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulegeneral_table_refEx; /* Prevent compiler warnings */
    rulegeneral_table_refEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end general_table_ref */

/**
 * $ANTLR start static_returning_clause
 * PLSQL_DMLParser.g:550:1: static_returning_clause : ( returning_key | return_key ) expression ( COMMA expression )* into_clause ;
 */
void
PLSQLParser_PLSQL_DMLParser::static_returning_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:551:5: ( ( returning_key | return_key ) expression ( COMMA expression )* into_clause )
        // PLSQL_DMLParser.g:551:10: ( returning_key | return_key ) expression ( COMMA expression )* into_clause
        {
            // PLSQL_DMLParser.g:551:10: ( returning_key | return_key )
            {
                int alt177=2;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		{
                		    int LA177_1 = this->LA(2);
                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "RETURNING"))))
                		    {
                		        alt177=1;
                		    }
                		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "RETURN"))))
                		    {
                		        alt177=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 177 );
                		        ex->set_state( 1 );


                		        goto rulestatic_returning_clauseEx;

                		    }
                		}
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 177 );
                    ex->set_state( 0 );


                    goto rulestatic_returning_clauseEx;

                }

                switch (alt177)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:551:11: returning_key
            	    {
            	        this->followPush(FOLLOW_returning_key_in_static_returning_clause4607);
            	        m_gPLSQLParser->returning_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulestatic_returning_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:551:25: return_key
            	    {
            	        this->followPush(FOLLOW_return_key_in_static_returning_clause4609);
            	        m_gPLSQLParser->return_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulestatic_returning_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_expression_in_static_returning_clause4612);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestatic_returning_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:551:48: ( COMMA expression )*

            for (;;)
            {
                int alt178=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt178=1;
                	}
                    break;

                }

                switch (alt178)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:551:49: COMMA expression
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_static_returning_clause4615);
            	        if  (this->hasException())
            	        {
            	            goto rulestatic_returning_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_static_returning_clause4617);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulestatic_returning_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop178;	/* break out of the loop */
            	    break;
                }
            }
            loop178: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_into_clause_in_static_returning_clause4630);
            m_gPLSQLParser->into_clause();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestatic_returning_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestatic_returning_clauseEx; /* Prevent compiler warnings */
    rulestatic_returning_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end static_returning_clause */

/**
 * $ANTLR start error_logging_clause
 * PLSQL_DMLParser.g:555:1: error_logging_clause : log_key errors_key ( error_logging_into_part )? ( ( LEFT_PAREN )=> expression_wrapper )? ( error_logging_reject_part )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::error_logging_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:556:5: ( log_key errors_key ( error_logging_into_part )? ( ( LEFT_PAREN )=> expression_wrapper )? ( error_logging_reject_part )? )
        // PLSQL_DMLParser.g:556:10: log_key errors_key ( error_logging_into_part )? ( ( LEFT_PAREN )=> expression_wrapper )? ( error_logging_reject_part )?
        {
            this->followPush(FOLLOW_log_key_in_error_logging_clause4650);
            m_gPLSQLParser->log_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleerror_logging_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_errors_key_in_error_logging_clause4652);
            m_gPLSQLParser->errors_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleerror_logging_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:557:9: ( error_logging_into_part )?
            {
                int alt179=2;
                alt179 = cdfa179.predict(this, this->get_rec(), this->get_istream(), cdfa179 );
                if  (this->hasException())
                {
                    goto ruleerror_logging_clauseEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }

                switch (alt179)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:557:9: error_logging_into_part
            	    {
            	        this->followPush(FOLLOW_error_logging_into_part_in_error_logging_clause4663);
            	        error_logging_into_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleerror_logging_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:558:9: ( ( LEFT_PAREN )=> expression_wrapper )?
            {
                int alt180=2;
                {
                    int LA180_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == SQL92_RESERVED_CURSOR))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == SQL92_RESERVED_NOT))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == MINUS_SIGN))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == PLUS_SIGN))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == SQL92_RESERVED_PRIOR))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == REGULAR_ID))
                    {
                        {
                            int LA180_7 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                            {
                                alt180=1;
                            }
                        }
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == SQL92_RESERVED_DISTINCT))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == SQL92_RESERVED_ALL))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == DELIMITED_ID))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == SQL92_RESERVED_CASE))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == SQL92_RESERVED_EXISTS))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == SQL92_RESERVED_ANY))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == INTRODUCER))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == BINDVAR))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == COLON))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == APPROXIMATE_NUM_LIT || LA180_0 == EXACT_NUM_LIT || LA180_0 == UNSIGNED_INTEGER))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == SQL92_RESERVED_DATE))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (((LA180_0 >= CHAR_STRING) && (LA180_0 <= CHAR_STRING_PERL)) || LA180_0 == NATIONAL_CHAR_STRING_LIT))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == SQL92_RESERVED_NULL))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == SQL92_RESERVED_TRUE))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == SQL92_RESERVED_FALSE))
                    {
                        alt180=1;
                    }
                    else if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )) && (LA180_0 == SQL92_RESERVED_DEFAULT))
                    {
                        alt180=1;
                    }
                    else if ( (LA180_0 == LEFT_PAREN))
                    {
                        {
                            int LA180_24 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred22_PLSQL_DMLParser>() )))
                            {
                                alt180=1;
                            }
                        }
                    }
                }
                switch (alt180)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:558:10: ( LEFT_PAREN )=> expression_wrapper
            	    {
            	        this->followPush(FOLLOW_expression_wrapper_in_error_logging_clause4680);
            	        expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleerror_logging_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:559:9: ( error_logging_reject_part )?
            {
                int alt181=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA181_1 = this->LA(2);
                    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "REJECT"))))
                    		    {
                    		        alt181=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt181)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:559:9: error_logging_reject_part
            	    {
            	        this->followPush(FOLLOW_error_logging_reject_part_in_error_logging_clause4692);
            	        error_logging_reject_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleerror_logging_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleerror_logging_clauseEx; /* Prevent compiler warnings */
    ruleerror_logging_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end error_logging_clause */

/**
 * $ANTLR start error_logging_into_part
 * PLSQL_DMLParser.g:562:1: error_logging_into_part : into_key tableview_name ;
 */
void
PLSQLParser_PLSQL_DMLParser::error_logging_into_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:563:5: ( into_key tableview_name )
        // PLSQL_DMLParser.g:563:10: into_key tableview_name
        {
            this->followPush(FOLLOW_into_key_in_error_logging_into_part4713);
            m_gPLSQLParser->into_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleerror_logging_into_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_tableview_name_in_error_logging_into_part4715);
            m_gPLSQLParser->tableview_name();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleerror_logging_into_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleerror_logging_into_partEx; /* Prevent compiler warnings */
    ruleerror_logging_into_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end error_logging_into_part */

/**
 * $ANTLR start error_logging_reject_part
 * PLSQL_DMLParser.g:566:1: error_logging_reject_part : reject_key limit_key ( ( unlimited_key )=> unlimited_key | expression_wrapper ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::error_logging_reject_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:567:5: ( reject_key limit_key ( ( unlimited_key )=> unlimited_key | expression_wrapper ) )
        // PLSQL_DMLParser.g:567:10: reject_key limit_key ( ( unlimited_key )=> unlimited_key | expression_wrapper )
        {
            this->followPush(FOLLOW_reject_key_in_error_logging_reject_part4735);
            m_gPLSQLParser->reject_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleerror_logging_reject_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_limit_key_in_error_logging_reject_part4737);
            m_gPLSQLParser->limit_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleerror_logging_reject_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:567:31: ( ( unlimited_key )=> unlimited_key | expression_wrapper )
            {
                int alt182=2;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		{
                		    int LA182_1 = this->LA(2);
                		    if ( (( ((equalsIgnoreCase(LT(1)->getText(), "UNLIMITED"))) && (this->msynpred( antlr3::ClassForwarder<synpred23_PLSQL_DMLParser>() )) )))
                		    {
                		        alt182=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt182=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 182 );
                		        ex->set_state( 1 );


                		        goto ruleerror_logging_reject_partEx;

                		    }
                		}
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case DELIMITED_ID:
                case EXACT_NUM_LIT:
                case INTRODUCER:
                case LEFT_PAREN:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURSOR:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt182=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 182 );
                    ex->set_state( 0 );


                    goto ruleerror_logging_reject_partEx;

                }

                switch (alt182)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:567:32: ( unlimited_key )=> unlimited_key
            	    {
            	        this->followPush(FOLLOW_unlimited_key_in_error_logging_reject_part4744);
            	        m_gPLSQLParser->unlimited_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleerror_logging_reject_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:567:63: expression_wrapper
            	    {
            	        this->followPush(FOLLOW_expression_wrapper_in_error_logging_reject_part4746);
            	        expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleerror_logging_reject_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleerror_logging_reject_partEx; /* Prevent compiler warnings */
    ruleerror_logging_reject_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end error_logging_reject_part */

/**
 * $ANTLR start dml_table_expression_clause
 * PLSQL_DMLParser.g:570:1: dml_table_expression_clause : ( table_collection_expression | LEFT_PAREN select_statement ( subquery_restriction_clause )? RIGHT_PAREN | tableview_name ( sample_clause )? );
 */
void
PLSQLParser_PLSQL_DMLParser::dml_table_expression_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:571:5: ( table_collection_expression | LEFT_PAREN select_statement ( subquery_restriction_clause )? RIGHT_PAREN | tableview_name ( sample_clause )? )

            ANTLR_UINT32 alt185;

            alt185=3;

            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_TABLE:
            case SQL92_RESERVED_THE:
            	{
            		alt185=1;
            	}
                break;
            case LEFT_PAREN:
            	{
            		alt185=2;
            	}
                break;
            case DELIMITED_ID:
            case INTRODUCER:
            case REGULAR_ID:
            	{
            		alt185=3;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 185 );
                ex->set_state( 0 );


                goto ruledml_table_expression_clauseEx;

            }

            switch (alt185)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:571:10: table_collection_expression
        	    {
        	        this->followPush(FOLLOW_table_collection_expression_in_dml_table_expression_clause4767);
        	        table_collection_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledml_table_expression_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:572:10: LEFT_PAREN select_statement ( subquery_restriction_clause )? RIGHT_PAREN
        	    {
        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_dml_table_expression_clause4778);
        	        if  (this->hasException())
        	        {
        	            goto ruledml_table_expression_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_select_statement_in_dml_table_expression_clause4780);
        	        select_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledml_table_expression_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:572:38: ( subquery_restriction_clause )?
        	        {
        	            int alt183=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_WITH:
        	                	{
        	                		alt183=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt183)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:572:38: subquery_restriction_clause
        	        	    {
        	        	        this->followPush(FOLLOW_subquery_restriction_clause_in_dml_table_expression_clause4782);
        	        	        subquery_restriction_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledml_table_expression_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_dml_table_expression_clause4785);
        	        if  (this->hasException())
        	        {
        	            goto ruledml_table_expression_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:573:10: tableview_name ( sample_clause )?
        	    {
        	        this->followPush(FOLLOW_tableview_name_in_dml_table_expression_clause4796);
        	        m_gPLSQLParser->tableview_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledml_table_expression_clauseEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:573:25: ( sample_clause )?
        	        {
        	            int alt184=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    int LA184_1 = this->LA(2);
        	                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "SAMPLE"))))
        	                		    {
        	                		        alt184=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt184)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:573:25: sample_clause
        	        	    {
        	        	        this->followPush(FOLLOW_sample_clause_in_dml_table_expression_clause4798);
        	        	        sample_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruledml_table_expression_clauseEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruledml_table_expression_clauseEx; /* Prevent compiler warnings */
    ruledml_table_expression_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end dml_table_expression_clause */

/**
 * $ANTLR start table_collection_expression
 * PLSQL_DMLParser.g:576:1: table_collection_expression : ( table_key | the_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression RIGHT_PAREN ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::table_collection_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:577:5: ( ( table_key | the_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression RIGHT_PAREN ) )
        // PLSQL_DMLParser.g:577:10: ( table_key | the_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression RIGHT_PAREN )
        {
            // PLSQL_DMLParser.g:577:10: ( table_key | the_key )
            {
                int alt186=2;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_TABLE:
                	{
                		alt186=1;
                	}
                    break;
                case SQL92_RESERVED_THE:
                	{
                		alt186=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 186 );
                    ex->set_state( 0 );


                    goto ruletable_collection_expressionEx;

                }

                switch (alt186)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:577:12: table_key
            	    {
            	        this->followPush(FOLLOW_table_key_in_table_collection_expression4821);
            	        m_gPLSQLParser->table_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:577:24: the_key
            	    {
            	        this->followPush(FOLLOW_the_key_in_table_collection_expression4825);
            	        m_gPLSQLParser->the_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:578:10: ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression RIGHT_PAREN )
            {
                int alt187=2;
                switch ( this->LA(1) )
                {
                case LEFT_PAREN:
                	{
                		{
                		    int LA187_1 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred24_PLSQL_DMLParser>() )))
                		    {
                		        alt187=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt187=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 187 );
                		        ex->set_state( 1 );


                		        goto ruletable_collection_expressionEx;

                		    }
                		}
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 187 );
                    ex->set_state( 0 );


                    goto ruletable_collection_expressionEx;

                }

                switch (alt187)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:578:12: ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_table_collection_expression4853);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_subquery_in_table_collection_expression4855);
            	        subquery();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_table_collection_expression4857);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:579:12: LEFT_PAREN expression RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_table_collection_expression4870);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_table_collection_expression4872);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_table_collection_expression4874);
            	        if  (this->hasException())
            	        {
            	            goto ruletable_collection_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruletable_collection_expressionEx; /* Prevent compiler warnings */
    ruletable_collection_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end table_collection_expression */

/**
 * $ANTLR start subquery_restriction_clause
 * PLSQL_DMLParser.g:583:1: subquery_restriction_clause : with_key ( read_key only_key | check_key option_key ( constraint_key constraint_name )? ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::subquery_restriction_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:584:5: ( with_key ( read_key only_key | check_key option_key ( constraint_key constraint_name )? ) )
        // PLSQL_DMLParser.g:584:10: with_key ( read_key only_key | check_key option_key ( constraint_key constraint_name )? )
        {
            this->followPush(FOLLOW_with_key_in_subquery_restriction_clause4906);
            m_gPLSQLParser->with_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesubquery_restriction_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:585:5: ( read_key only_key | check_key option_key ( constraint_key constraint_name )? )
            {
                int alt189=2;
                {
                    int LA189_0 = this->LA(1);
                    if ( ((equalsIgnoreCase(LT(1)->getText(), "READ"))) && (LA189_0 == REGULAR_ID))
                    {
                        alt189=1;
                    }
                    else if ( (LA189_0 == SQL92_RESERVED_CHECK))
                    {
                        alt189=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 189 );
                        ex->set_state( 0 );


                        goto rulesubquery_restriction_clauseEx;

                    }
                }
                switch (alt189)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:585:10: read_key only_key
            	    {
            	        this->followPush(FOLLOW_read_key_in_subquery_restriction_clause4917);
            	        m_gPLSQLParser->read_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_restriction_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_only_key_in_subquery_restriction_clause4919);
            	        m_gPLSQLParser->only_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_restriction_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:586:10: check_key option_key ( constraint_key constraint_name )?
            	    {
            	        this->followPush(FOLLOW_check_key_in_subquery_restriction_clause4930);
            	        m_gPLSQLParser->check_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_restriction_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_option_key_in_subquery_restriction_clause4932);
            	        m_gPLSQLParser->option_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesubquery_restriction_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:586:31: ( constraint_key constraint_name )?
            	        {
            	            int alt188=2;
            	            {
            	                int LA188_0 = this->LA(1);
            	                if ( ((equalsIgnoreCase(LT(1)->getText(), "CONSTRAINT"))) && (LA188_0 == REGULAR_ID))
            	                {
            	                    alt188=1;
            	                }
            	            }
            	            switch (alt188)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:586:32: constraint_key constraint_name
            	        	    {
            	        	        this->followPush(FOLLOW_constraint_key_in_subquery_restriction_clause4935);
            	        	        m_gPLSQLParser->constraint_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesubquery_restriction_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_constraint_name_in_subquery_restriction_clause4937);
            	        	        m_gPLSQLParser->constraint_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesubquery_restriction_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesubquery_restriction_clauseEx; /* Prevent compiler warnings */
    rulesubquery_restriction_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end subquery_restriction_clause */

/**
 * $ANTLR start sample_clause
 * PLSQL_DMLParser.g:590:1: sample_clause : sample_key ( block_key )? LEFT_PAREN expression ( COMMA expression )? RIGHT_PAREN ( seed_part )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::sample_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:591:5: ( sample_key ( block_key )? LEFT_PAREN expression ( COMMA expression )? RIGHT_PAREN ( seed_part )? )
        // PLSQL_DMLParser.g:591:10: sample_key ( block_key )? LEFT_PAREN expression ( COMMA expression )? RIGHT_PAREN ( seed_part )?
        {
            this->followPush(FOLLOW_sample_key_in_sample_clause4965);
            m_gPLSQLParser->sample_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesample_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:591:21: ( block_key )?
            {
                int alt190=2;
                {
                    int LA190_0 = this->LA(1);
                    if ( ((equalsIgnoreCase(LT(1)->getText(), "BLOCK"))) && (LA190_0 == REGULAR_ID))
                    {
                        alt190=1;
                    }
                }
                switch (alt190)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:591:21: block_key
            	    {
            	        this->followPush(FOLLOW_block_key_in_sample_clause4967);
            	        m_gPLSQLParser->block_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesample_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_sample_clause4979);
            if  (this->hasException())
            {
                goto rulesample_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_sample_clause4981);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesample_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:592:31: ( COMMA expression )?
            {
                int alt191=2;
                switch ( this->LA(1) )
                {
                    case COMMA:
                    	{
                    		alt191=1;
                    	}
                        break;
                }

                switch (alt191)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:592:32: COMMA expression
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_sample_clause4984);
            	        if  (this->hasException())
            	        {
            	            goto rulesample_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_sample_clause4986);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesample_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_sample_clause4990);
            if  (this->hasException())
            {
                goto rulesample_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:593:9: ( seed_part )?
            {
                int alt192=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA192_1 = this->LA(2);
                    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "SEED"))))
                    		    {
                    		        alt192=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt192)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:593:9: seed_part
            	    {
            	        this->followPush(FOLLOW_seed_part_in_sample_clause5000);
            	        seed_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesample_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesample_clauseEx; /* Prevent compiler warnings */
    rulesample_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sample_clause */

/**
 * $ANTLR start seed_part
 * PLSQL_DMLParser.g:596:1: seed_part : seed_key LEFT_PAREN expression RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::seed_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:597:5: ( seed_key LEFT_PAREN expression RIGHT_PAREN )
        // PLSQL_DMLParser.g:597:10: seed_key LEFT_PAREN expression RIGHT_PAREN
        {
            this->followPush(FOLLOW_seed_key_in_seed_part5021);
            m_gPLSQLParser->seed_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleseed_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_seed_part5023);
            if  (this->hasException())
            {
                goto ruleseed_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_seed_part5025);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleseed_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_seed_part5027);
            if  (this->hasException())
            {
                goto ruleseed_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleseed_partEx; /* Prevent compiler warnings */
    ruleseed_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end seed_part */

/**
 * $ANTLR start cursor_expression
 * PLSQL_DMLParser.g:603:1: cursor_expression : cursor_key LEFT_PAREN subquery RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::cursor_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:604:5: ( cursor_key LEFT_PAREN subquery RIGHT_PAREN )
        // PLSQL_DMLParser.g:604:10: cursor_key LEFT_PAREN subquery RIGHT_PAREN
        {
            this->followPush(FOLLOW_cursor_key_in_cursor_expression5050);
            m_gPLSQLParser->cursor_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecursor_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_cursor_expression5052);
            if  (this->hasException())
            {
                goto rulecursor_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_subquery_in_cursor_expression5054);
            subquery();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecursor_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_cursor_expression5056);
            if  (this->hasException())
            {
                goto rulecursor_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecursor_expressionEx; /* Prevent compiler warnings */
    rulecursor_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cursor_expression */

/**
 * $ANTLR start expression_list
 * PLSQL_DMLParser.g:607:1: expression_list : LEFT_PAREN ( expression )? ( COMMA expression )* RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::expression_list()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:608:5: ( LEFT_PAREN ( expression )? ( COMMA expression )* RIGHT_PAREN )
        // PLSQL_DMLParser.g:608:10: LEFT_PAREN ( expression )? ( COMMA expression )* RIGHT_PAREN
        {
             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_expression_list5076);
            if  (this->hasException())
            {
                goto ruleexpression_listEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:608:21: ( expression )?
            {
                int alt193=2;
                switch ( this->LA(1) )
                {
                    case APPROXIMATE_NUM_LIT:
                    case BINDVAR:
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case COLON:
                    case DELIMITED_ID:
                    case EXACT_NUM_LIT:
                    case INTRODUCER:
                    case LEFT_PAREN:
                    case MINUS_SIGN:
                    case NATIONAL_CHAR_STRING_LIT:
                    case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                    case PLUS_SIGN:
                    case REGULAR_ID:
                    case SQL92_RESERVED_ALL:
                    case SQL92_RESERVED_ANY:
                    case SQL92_RESERVED_CASE:
                    case SQL92_RESERVED_CURSOR:
                    case SQL92_RESERVED_DATE:
                    case SQL92_RESERVED_DEFAULT:
                    case SQL92_RESERVED_DISTINCT:
                    case SQL92_RESERVED_EXISTS:
                    case SQL92_RESERVED_FALSE:
                    case SQL92_RESERVED_NOT:
                    case SQL92_RESERVED_NULL:
                    case SQL92_RESERVED_PRIOR:
                    case SQL92_RESERVED_TRUE:
                    case UNSIGNED_INTEGER:
                    	{
                    		alt193=1;
                    	}
                        break;
                }

                switch (alt193)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:608:21: expression
            	    {
            	        this->followPush(FOLLOW_expression_in_expression_list5078);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexpression_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:608:33: ( COMMA expression )*

            for (;;)
            {
                int alt194=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt194=1;
                	}
                    break;

                }

                switch (alt194)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:608:34: COMMA expression
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_expression_list5082);
            	        if  (this->hasException())
            	        {
            	            goto ruleexpression_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_expression_list5084);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexpression_listEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop194;	/* break out of the loop */
            	    break;
                }
            }
            loop194: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_expression_list5088);
            if  (this->hasException())
            {
                goto ruleexpression_listEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexpression_listEx; /* Prevent compiler warnings */
    ruleexpression_listEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end expression_list */

/**
 * $ANTLR start condition
 * PLSQL_DMLParser.g:611:1: condition : expression ;
 */
void
PLSQLParser_PLSQL_DMLParser::condition()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:612:5: ( expression )
        // PLSQL_DMLParser.g:612:11: expression
        {
            this->followPush(FOLLOW_expression_in_condition5109);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconditionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconditionEx; /* Prevent compiler warnings */
    ruleconditionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end condition */

/**
 * $ANTLR start condition_wrapper
 * PLSQL_DMLParser.g:615:1: condition_wrapper : expression ;
 */
void
PLSQLParser_PLSQL_DMLParser::condition_wrapper()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:616:5: ( expression )
        // PLSQL_DMLParser.g:616:10: expression
        {
            this->followPush(FOLLOW_expression_in_condition_wrapper5129);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecondition_wrapperEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecondition_wrapperEx; /* Prevent compiler warnings */
    rulecondition_wrapperEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end condition_wrapper */

/**
 * $ANTLR start expression
 * PLSQL_DMLParser.g:619:1: expression : ( ( cursor_key LEFT_PAREN ( select_key | with_key ) )=> cursor_expression | logical_and_expression ( or_key logical_and_expression )* );
 */
void
PLSQLParser_PLSQL_DMLParser::expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:620:5: ( ( cursor_key LEFT_PAREN ( select_key | with_key ) )=> cursor_expression | logical_and_expression ( or_key logical_and_expression )* )

            ANTLR_UINT32 alt196;

            alt196=2;

            {
                int LA196_0 = this->LA(1);
                if ( (this->msynpred( antlr3::ClassForwarder<synpred25_PLSQL_DMLParser>() )) && (LA196_0 == SQL92_RESERVED_CURSOR))
                {
                    alt196=1;
                }
                else if ( (LA196_0 == APPROXIMATE_NUM_LIT || LA196_0 == BINDVAR || ((LA196_0 >= CHAR_STRING) && (LA196_0 <= COLON)) || LA196_0 == DELIMITED_ID || LA196_0 == EXACT_NUM_LIT || LA196_0 == INTRODUCER || LA196_0 == LEFT_PAREN || ((LA196_0 >= MINUS_SIGN) && (LA196_0 <= NATIONAL_CHAR_STRING_LIT)) || LA196_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA196_0 == PLUS_SIGN || LA196_0 == REGULAR_ID || LA196_0 == SQL92_RESERVED_ALL || LA196_0 == SQL92_RESERVED_ANY || LA196_0 == SQL92_RESERVED_CASE || LA196_0 == SQL92_RESERVED_DATE || LA196_0 == SQL92_RESERVED_DEFAULT || LA196_0 == SQL92_RESERVED_DISTINCT || ((LA196_0 >= SQL92_RESERVED_EXISTS) && (LA196_0 <= SQL92_RESERVED_FALSE)) || ((LA196_0 >= SQL92_RESERVED_NOT) && (LA196_0 <= SQL92_RESERVED_NULL)) || LA196_0 == SQL92_RESERVED_PRIOR || LA196_0 == SQL92_RESERVED_TRUE || LA196_0 == UNSIGNED_INTEGER))
                {
                    alt196=2;
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 196 );
                    ex->set_state( 0 );


                    goto ruleexpressionEx;

                }
            }
            switch (alt196)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:620:10: ( cursor_key LEFT_PAREN ( select_key | with_key ) )=> cursor_expression
        	    {
        	        this->followPush(FOLLOW_cursor_expression_in_expression5163);
        	        cursor_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleexpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:621:10: logical_and_expression ( or_key logical_and_expression )*
        	    {
        	        this->followPush(FOLLOW_logical_and_expression_in_expression5174);
        	        logical_and_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleexpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:621:33: ( or_key logical_and_expression )*

        	        for (;;)
        	        {
        	            int alt195=2;
        	            switch ( this->LA(1) )
        	            {
        	            case SQL92_RESERVED_OR:
        	            	{
        	            		alt195=1;
        	            	}
        	                break;

        	            }

        	            switch (alt195)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:621:35: or_key logical_and_expression
        	        	    {
        	        	        this->followPush(FOLLOW_or_key_in_expression5178);
        	        	        m_gPLSQLParser->or_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleexpressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_logical_and_expression_in_expression5180);
        	        	        logical_and_expression();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleexpressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop195;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop195: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end expression */

/**
 * $ANTLR start expression_wrapper
 * PLSQL_DMLParser.g:624:1: expression_wrapper : expression ;
 */
void
PLSQLParser_PLSQL_DMLParser::expression_wrapper()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:625:5: ( expression )
        // PLSQL_DMLParser.g:625:10: expression
        {
            this->followPush(FOLLOW_expression_in_expression_wrapper5203);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexpression_wrapperEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexpression_wrapperEx; /* Prevent compiler warnings */
    ruleexpression_wrapperEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end expression_wrapper */

/**
 * $ANTLR start logical_and_expression
 * PLSQL_DMLParser.g:628:1: logical_and_expression : negated_expression ( and_key negated_expression )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::logical_and_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:629:5: ( negated_expression ( and_key negated_expression )* )
        // PLSQL_DMLParser.g:629:10: negated_expression ( and_key negated_expression )*
        {
            this->followPush(FOLLOW_negated_expression_in_logical_and_expression5223);
            negated_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelogical_and_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:629:29: ( and_key negated_expression )*

            for (;;)
            {
                int alt197=2;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_AND:
                	{
                		alt197=1;
                	}
                    break;

                }

                switch (alt197)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:629:31: and_key negated_expression
            	    {
            	        this->followPush(FOLLOW_and_key_in_logical_and_expression5227);
            	        m_gPLSQLParser->and_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulelogical_and_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_negated_expression_in_logical_and_expression5229);
            	        negated_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulelogical_and_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop197;	/* break out of the loop */
            	    break;
                }
            }
            loop197: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelogical_and_expressionEx; /* Prevent compiler warnings */
    rulelogical_and_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end logical_and_expression */

/**
 * $ANTLR start negated_expression
 * PLSQL_DMLParser.g:632:1: negated_expression : ( not_key negated_expression | equality_expression );
 */
void
PLSQLParser_PLSQL_DMLParser::negated_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:633:5: ( not_key negated_expression | equality_expression )

            ANTLR_UINT32 alt198;

            alt198=2;

            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_NOT:
            	{
            		alt198=1;
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case DELIMITED_ID:
            case EXACT_NUM_LIT:
            case INTRODUCER:
            case LEFT_PAREN:
            case MINUS_SIGN:
            case NATIONAL_CHAR_STRING_LIT:
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            case PLUS_SIGN:
            case REGULAR_ID:
            case SQL92_RESERVED_ALL:
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_CASE:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_DISTINCT:
            case SQL92_RESERVED_EXISTS:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_PRIOR:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt198=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 198 );
                ex->set_state( 0 );


                goto rulenegated_expressionEx;

            }

            switch (alt198)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:633:10: not_key negated_expression
        	    {
        	        this->followPush(FOLLOW_not_key_in_negated_expression5252);
        	        m_gPLSQLParser->not_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenegated_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_negated_expression_in_negated_expression5254);
        	        negated_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenegated_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:634:10: equality_expression
        	    {
        	        this->followPush(FOLLOW_equality_expression_in_negated_expression5265);
        	        equality_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulenegated_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulenegated_expressionEx; /* Prevent compiler warnings */
    rulenegated_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end negated_expression */

/**
 * $ANTLR start equality_expression
 * PLSQL_DMLParser.g:637:1: equality_expression : multiset_comparsion ( is_key ( not_key )? ( null_key | nan_key | present_key | infinite_key | a_key set_key | empty_key | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN ) )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::equality_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:638:5: ( multiset_comparsion ( is_key ( not_key )? ( null_key | nan_key | present_key | infinite_key | a_key set_key | empty_key | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN ) )? )
        // PLSQL_DMLParser.g:638:10: multiset_comparsion ( is_key ( not_key )? ( null_key | nan_key | present_key | infinite_key | a_key set_key | empty_key | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN ) )?
        {
            this->followPush(FOLLOW_multiset_comparsion_in_equality_expression5285);
            multiset_comparsion();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleequality_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:639:5: ( is_key ( not_key )? ( null_key | nan_key | present_key | infinite_key | a_key set_key | empty_key | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN ) )?
            {
                int alt204=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_IS:
                    	{
                    		alt204=1;
                    	}
                        break;
                }

                switch (alt204)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:639:10: is_key ( not_key )? ( null_key | nan_key | present_key | infinite_key | a_key set_key | empty_key | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN )
            	    {
            	        this->followPush(FOLLOW_is_key_in_equality_expression5296);
            	        m_gPLSQLParser->is_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleequality_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:639:17: ( not_key )?
            	        {
            	            int alt199=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_NOT:
            	                	{
            	                		alt199=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt199)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:639:17: not_key
            	        	    {
            	        	        this->followPush(FOLLOW_not_key_in_equality_expression5298);
            	        	        m_gPLSQLParser->not_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQL_DMLParser.g:640:9: ( null_key | nan_key | present_key | infinite_key | a_key set_key | empty_key | of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN )
            	        {
            	            int alt203=7;
            	            {
            	                int LA203_0 = this->LA(1);
            	                if ( (LA203_0 == SQL92_RESERVED_NULL))
            	                {
            	                    alt203=1;
            	                }
            	                else if ( ((((equalsIgnoreCase(LT(1)->getText(), "EMPTY")))||((equalsIgnoreCase(LT(1)->getText(), "A")))||((equalsIgnoreCase(LT(1)->getText(), "PRESENT")))||((equalsIgnoreCase(LT(1)->getText(), "NAN")))||((equalsIgnoreCase(LT(1)->getText(), "INFINITE"))))) && (LA203_0 == REGULAR_ID))
            	                {
            	                    {
            	                        int LA203_2 = this->LA(2);
            	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "A"))) && (LA203_2 == REGULAR_ID))
            	                        {
            	                            alt203=5;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NAN"))))
            	                        {
            	                            alt203=2;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "PRESENT"))))
            	                        {
            	                            alt203=3;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "INFINITE"))))
            	                        {
            	                            alt203=4;
            	                        }
            	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "EMPTY"))))
            	                        {
            	                            alt203=6;
            	                        }
            	                        else
            	                        {
            	                            if (this->get_backtracking()>0)
            	                            {
            	                                this->set_failedflag( true );
            	                                return ;
            	                            }


            	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                            ex->set_decisionNum( 203 );
            	                            ex->set_state( 2 );


            	                            goto ruleequality_expressionEx;

            	                        }
            	                    }
            	                }
            	                else if ( (LA203_0 == SQL92_RESERVED_OF))
            	                {
            	                    alt203=7;
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 203 );
            	                    ex->set_state( 0 );


            	                    goto ruleequality_expressionEx;

            	                }
            	            }
            	            switch (alt203)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:640:14: null_key
            	        	    {
            	        	        this->followPush(FOLLOW_null_key_in_equality_expression5314);
            	        	        m_gPLSQLParser->null_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:641:14: nan_key
            	        	    {
            	        	        this->followPush(FOLLOW_nan_key_in_equality_expression5329);
            	        	        m_gPLSQLParser->nan_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // PLSQL_DMLParser.g:642:14: present_key
            	        	    {
            	        	        this->followPush(FOLLOW_present_key_in_equality_expression5344);
            	        	        m_gPLSQLParser->present_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 4:
            	        	    // PLSQL_DMLParser.g:643:14: infinite_key
            	        	    {
            	        	        this->followPush(FOLLOW_infinite_key_in_equality_expression5359);
            	        	        m_gPLSQLParser->infinite_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 5:
            	        	    // PLSQL_DMLParser.g:644:14: a_key set_key
            	        	    {
            	        	        this->followPush(FOLLOW_a_key_in_equality_expression5374);
            	        	        m_gPLSQLParser->a_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_set_key_in_equality_expression5376);
            	        	        m_gPLSQLParser->set_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 6:
            	        	    // PLSQL_DMLParser.g:645:14: empty_key
            	        	    {
            	        	        this->followPush(FOLLOW_empty_key_in_equality_expression5391);
            	        	        m_gPLSQLParser->empty_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 7:
            	        	    // PLSQL_DMLParser.g:646:14: of_key ( type_key )? LEFT_PAREN ( only_key )? type_spec ( COMMA type_spec )* RIGHT_PAREN
            	        	    {
            	        	        this->followPush(FOLLOW_of_key_in_equality_expression5406);
            	        	        m_gPLSQLParser->of_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // PLSQL_DMLParser.g:646:21: ( type_key )?
            	        	        {
            	        	            int alt200=2;
            	        	            {
            	        	                int LA200_0 = this->LA(1);
            	        	                if ( ((equalsIgnoreCase(LT(1)->getText(), "TYPE"))) && (LA200_0 == REGULAR_ID))
            	        	                {
            	        	                    alt200=1;
            	        	                }
            	        	            }
            	        	            switch (alt200)
            	        	            {
            	        	        	case 1:
            	        	        	    // PLSQL_DMLParser.g:646:21: type_key
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_type_key_in_equality_expression5408);
            	        	        	        m_gPLSQLParser->type_key();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleequality_expressionEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_equality_expression5411);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // PLSQL_DMLParser.g:646:42: ( only_key )?
            	        	        {
            	        	            int alt201=2;
            	        	            switch ( this->LA(1) )
            	        	            {
            	        	                case REGULAR_ID:
            	        	                	{
            	        	                		{
            	        	                		    int LA201_1 = this->LA(2);
            	        	                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "ONLY"))))
            	        	                		    {
            	        	                		        alt201=1;
            	        	                		    }
            	        	                		}
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt201)
            	        	            {
            	        	        	case 1:
            	        	        	    // PLSQL_DMLParser.g:646:42: only_key
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_only_key_in_equality_expression5413);
            	        	        	        m_gPLSQLParser->only_key();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleequality_expressionEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        this->followPush(FOLLOW_type_spec_in_equality_expression5416);
            	        	        m_gPLSQLParser->type_spec();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // PLSQL_DMLParser.g:646:62: ( COMMA type_spec )*

            	        	        for (;;)
            	        	        {
            	        	            int alt202=2;
            	        	            switch ( this->LA(1) )
            	        	            {
            	        	            case COMMA:
            	        	            	{
            	        	            		alt202=1;
            	        	            	}
            	        	                break;

            	        	            }

            	        	            switch (alt202)
            	        	            {
            	        	        	case 1:
            	        	        	    // PLSQL_DMLParser.g:646:63: COMMA type_spec
            	        	        	    {
            	        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_equality_expression5419);
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleequality_expressionEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	        this->followPush(FOLLOW_type_spec_in_equality_expression5421);
            	        	        	        m_gPLSQLParser->type_spec();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleequality_expressionEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	        	default:
            	        	        	    goto loop202;	/* break out of the loop */
            	        	        	    break;
            	        	            }
            	        	        }
            	        	        loop202: ; /* Jump out to here if this rule does not match */


            	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_equality_expression5425);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleequality_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleequality_expressionEx; /* Prevent compiler warnings */
    ruleequality_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end equality_expression */

/**
 * $ANTLR start multiset_comparsion
 * PLSQL_DMLParser.g:652:1: multiset_comparsion : relational_expression ( multiset_type ( of_key )? concatenation )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::multiset_comparsion()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:653:5: ( relational_expression ( multiset_type ( of_key )? concatenation )? )
        // PLSQL_DMLParser.g:653:10: relational_expression ( multiset_type ( of_key )? concatenation )?
        {
            this->followPush(FOLLOW_relational_expression_in_multiset_comparsion5463);
            relational_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemultiset_comparsionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:654:5: ( multiset_type ( of_key )? concatenation )?
            {
                int alt206=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA206_1 = this->LA(2);
                    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "SUBMULTISET")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))))
                    		    {
                    		        alt206=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt206)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:654:10: multiset_type ( of_key )? concatenation
            	    {
            	        this->followPush(FOLLOW_multiset_type_in_multiset_comparsion5474);
            	        multiset_type();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_comparsionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:654:24: ( of_key )?
            	        {
            	            int alt205=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_OF:
            	                	{
            	                		alt205=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt205)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:654:24: of_key
            	        	    {
            	        	        this->followPush(FOLLOW_of_key_in_multiset_comparsion5476);
            	        	        m_gPLSQLParser->of_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemultiset_comparsionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_concatenation_in_multiset_comparsion5479);
            	        concatenation();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_comparsionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemultiset_comparsionEx; /* Prevent compiler warnings */
    rulemultiset_comparsionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multiset_comparsion */

/**
 * $ANTLR start multiset_type
 * PLSQL_DMLParser.g:657:1: multiset_type : ( member_key | submultiset_key );
 */
void
PLSQLParser_PLSQL_DMLParser::multiset_type()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:658:5: ( member_key | submultiset_key )

            ANTLR_UINT32 alt207;

            alt207=2;

            {
                int LA207_0 = this->LA(1);
                if ( ((((equalsIgnoreCase(LT(1)->getText(), "SUBMULTISET")))||((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))) && (LA207_0 == REGULAR_ID))
                {
                    {
                        int LA207_1 = this->LA(2);
                        if ( ((equalsIgnoreCase(LT(1)->getText(), "MEMBER"))))
                        {
                            alt207=1;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "SUBMULTISET"))))
                        {
                            alt207=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 207 );
                            ex->set_state( 1 );


                            goto rulemultiset_typeEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 207 );
                    ex->set_state( 0 );


                    goto rulemultiset_typeEx;

                }
            }
            switch (alt207)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:658:10: member_key
        	    {
        	        this->followPush(FOLLOW_member_key_in_multiset_type5501);
        	        m_gPLSQLParser->member_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemultiset_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:659:10: submultiset_key
        	    {
        	        this->followPush(FOLLOW_submultiset_key_in_multiset_type5512);
        	        m_gPLSQLParser->submultiset_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemultiset_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulemultiset_typeEx; /* Prevent compiler warnings */
    rulemultiset_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multiset_type */

/**
 * $ANTLR start relational_expression
 * PLSQL_DMLParser.g:662:1: relational_expression : compound_expression ( ( EQUALS_OP | not_equal_op | LESS_THAN_OP | GREATER_THAN_OP | less_than_or_equals_op | greater_than_or_equals_op ) compound_expression )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::relational_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:663:5: ( compound_expression ( ( EQUALS_OP | not_equal_op | LESS_THAN_OP | GREATER_THAN_OP | less_than_or_equals_op | greater_than_or_equals_op ) compound_expression )* )
        // PLSQL_DMLParser.g:663:10: compound_expression ( ( EQUALS_OP | not_equal_op | LESS_THAN_OP | GREATER_THAN_OP | less_than_or_equals_op | greater_than_or_equals_op ) compound_expression )*
        {
            this->followPush(FOLLOW_compound_expression_in_relational_expression5532);
            compound_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulerelational_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:664:5: ( ( EQUALS_OP | not_equal_op | LESS_THAN_OP | GREATER_THAN_OP | less_than_or_equals_op | greater_than_or_equals_op ) compound_expression )*

            for (;;)
            {
                int alt209=2;
                switch ( this->LA(1) )
                {
                case EQUALS_OP:
                	{
                		alt209=1;
                	}
                    break;
                case NOT_EQUAL_OP:
                	{
                		alt209=1;
                	}
                    break;
                case LESS_THAN_OP:
                	{
                		alt209=1;
                	}
                    break;
                case EXCLAMATION_OPERATOR_PART:
                	{
                		alt209=1;
                	}
                    break;
                case CARRET_OPERATOR_PART:
                	{
                		alt209=1;
                	}
                    break;
                case GREATER_THAN_OP:
                	{
                		alt209=1;
                	}
                    break;
                case LESS_THAN_OR_EQUALS_OP:
                	{
                		alt209=1;
                	}
                    break;
                case GREATER_THAN_OR_EQUALS_OP:
                	{
                		alt209=1;
                	}
                    break;

                }

                switch (alt209)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:664:7: ( EQUALS_OP | not_equal_op | LESS_THAN_OP | GREATER_THAN_OP | less_than_or_equals_op | greater_than_or_equals_op ) compound_expression
            	    {
            	        // PLSQL_DMLParser.g:664:7: ( EQUALS_OP | not_equal_op | LESS_THAN_OP | GREATER_THAN_OP | less_than_or_equals_op | greater_than_or_equals_op )
            	        {
            	            int alt208=6;
            	            switch ( this->LA(1) )
            	            {
            	            case EQUALS_OP:
            	            	{
            	            		alt208=1;
            	            	}
            	                break;
            	            case CARRET_OPERATOR_PART:
            	            case EXCLAMATION_OPERATOR_PART:
            	            case NOT_EQUAL_OP:
            	            	{
            	            		alt208=2;
            	            	}
            	                break;
            	            case LESS_THAN_OP:
            	            	{
            	            		switch ( this->LA(2) )
            	            		{
            	            		case GREATER_THAN_OP:
            	            			{
            	            				alt208=2;
            	            			}
            	            		    break;
            	            		case EQUALS_OP:
            	            			{
            	            				alt208=5;
            	            			}
            	            		    break;
            	            		case APPROXIMATE_NUM_LIT:
            	            		case BINDVAR:
            	            		case CHAR_STRING:
            	            		case CHAR_STRING_PERL:
            	            		case COLON:
            	            		case DELIMITED_ID:
            	            		case EXACT_NUM_LIT:
            	            		case INTRODUCER:
            	            		case LEFT_PAREN:
            	            		case MINUS_SIGN:
            	            		case NATIONAL_CHAR_STRING_LIT:
            	            		case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            	            		case PLUS_SIGN:
            	            		case REGULAR_ID:
            	            		case SQL92_RESERVED_ALL:
            	            		case SQL92_RESERVED_ANY:
            	            		case SQL92_RESERVED_CASE:
            	            		case SQL92_RESERVED_DATE:
            	            		case SQL92_RESERVED_DEFAULT:
            	            		case SQL92_RESERVED_DISTINCT:
            	            		case SQL92_RESERVED_EXISTS:
            	            		case SQL92_RESERVED_FALSE:
            	            		case SQL92_RESERVED_NULL:
            	            		case SQL92_RESERVED_PRIOR:
            	            		case SQL92_RESERVED_TRUE:
            	            		case UNSIGNED_INTEGER:
            	            			{
            	            				alt208=3;
            	            			}
            	            		    break;

            	            		default:
            	            		    if (this->get_backtracking()>0)
            	            		    {
            	            		        this->set_failedflag( true );
            	            		        return ;
            	            		    }

            	            		    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            		    ex->set_decisionNum( 208 );
            	            		    ex->set_state( 3 );


            	            		    goto rulerelational_expressionEx;

            	            		}

            	            	}
            	                break;
            	            case GREATER_THAN_OP:
            	            	{
            	            		switch ( this->LA(2) )
            	            		{
            	            		case EQUALS_OP:
            	            			{
            	            				alt208=6;
            	            			}
            	            		    break;
            	            		case APPROXIMATE_NUM_LIT:
            	            		case BINDVAR:
            	            		case CHAR_STRING:
            	            		case CHAR_STRING_PERL:
            	            		case COLON:
            	            		case DELIMITED_ID:
            	            		case EXACT_NUM_LIT:
            	            		case INTRODUCER:
            	            		case LEFT_PAREN:
            	            		case MINUS_SIGN:
            	            		case NATIONAL_CHAR_STRING_LIT:
            	            		case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            	            		case PLUS_SIGN:
            	            		case REGULAR_ID:
            	            		case SQL92_RESERVED_ALL:
            	            		case SQL92_RESERVED_ANY:
            	            		case SQL92_RESERVED_CASE:
            	            		case SQL92_RESERVED_DATE:
            	            		case SQL92_RESERVED_DEFAULT:
            	            		case SQL92_RESERVED_DISTINCT:
            	            		case SQL92_RESERVED_EXISTS:
            	            		case SQL92_RESERVED_FALSE:
            	            		case SQL92_RESERVED_NULL:
            	            		case SQL92_RESERVED_PRIOR:
            	            		case SQL92_RESERVED_TRUE:
            	            		case UNSIGNED_INTEGER:
            	            			{
            	            				alt208=4;
            	            			}
            	            		    break;

            	            		default:
            	            		    if (this->get_backtracking()>0)
            	            		    {
            	            		        this->set_failedflag( true );
            	            		        return ;
            	            		    }

            	            		    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            		    ex->set_decisionNum( 208 );
            	            		    ex->set_state( 4 );


            	            		    goto rulerelational_expressionEx;

            	            		}

            	            	}
            	                break;
            	            case LESS_THAN_OR_EQUALS_OP:
            	            	{
            	            		alt208=5;
            	            	}
            	                break;
            	            case GREATER_THAN_OR_EQUALS_OP:
            	            	{
            	            		alt208=6;
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return ;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 208 );
            	                ex->set_state( 0 );


            	                goto rulerelational_expressionEx;

            	            }

            	            switch (alt208)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:664:9: EQUALS_OP
            	        	    {
            	        	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_relational_expression5542);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerelational_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:664:21: not_equal_op
            	        	    {
            	        	        this->followPush(FOLLOW_not_equal_op_in_relational_expression5546);
            	        	        m_gPLSQLParser->not_equal_op();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerelational_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // PLSQL_DMLParser.g:664:36: LESS_THAN_OP
            	        	    {
            	        	         this->matchToken(LESS_THAN_OP, &FOLLOW_LESS_THAN_OP_in_relational_expression5550);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerelational_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 4:
            	        	    // PLSQL_DMLParser.g:664:51: GREATER_THAN_OP
            	        	    {
            	        	         this->matchToken(GREATER_THAN_OP, &FOLLOW_GREATER_THAN_OP_in_relational_expression5554);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerelational_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 5:
            	        	    // PLSQL_DMLParser.g:664:69: less_than_or_equals_op
            	        	    {
            	        	        this->followPush(FOLLOW_less_than_or_equals_op_in_relational_expression5558);
            	        	        m_gPLSQLParser->less_than_or_equals_op();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerelational_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 6:
            	        	    // PLSQL_DMLParser.g:664:94: greater_than_or_equals_op
            	        	    {
            	        	        this->followPush(FOLLOW_greater_than_or_equals_op_in_relational_expression5562);
            	        	        m_gPLSQLParser->greater_than_or_equals_op();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulerelational_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_compound_expression_in_relational_expression5566);
            	        compound_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulerelational_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop209;	/* break out of the loop */
            	    break;
                }
            }
            loop209: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulerelational_expressionEx; /* Prevent compiler warnings */
    rulerelational_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end relational_expression */

/**
 * $ANTLR start compound_expression
 * PLSQL_DMLParser.g:667:1: compound_expression : concatenation ( ( not_key )? ( in_key in_elements | between_key between_elements | like_type concatenation ( like_escape_part )? ) )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::compound_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:668:5: ( concatenation ( ( not_key )? ( in_key in_elements | between_key between_elements | like_type concatenation ( like_escape_part )? ) )? )
        // PLSQL_DMLParser.g:668:10: concatenation ( ( not_key )? ( in_key in_elements | between_key between_elements | like_type concatenation ( like_escape_part )? ) )?
        {
            this->followPush(FOLLOW_concatenation_in_compound_expression5588);
            concatenation();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecompound_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:669:5: ( ( not_key )? ( in_key in_elements | between_key between_elements | like_type concatenation ( like_escape_part )? ) )?
            {
                int alt213=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_NOT:
                    	{
                    		alt213=1;
                    	}
                        break;
                    case SQL92_RESERVED_IN:
                    	{
                    		alt213=1;
                    	}
                        break;
                    case SQL92_RESERVED_BETWEEN:
                    	{
                    		alt213=1;
                    	}
                        break;
                    case SQL92_RESERVED_LIKE:
                    	{
                    		alt213=1;
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA213_5 = this->LA(2);
                    		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "LIKEC")))||((equalsIgnoreCase(LT(1)->getText(), "LIKE4")))||((equalsIgnoreCase(LT(1)->getText(), "LIKE2"))))))
                    		    {
                    		        alt213=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt213)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:669:10: ( not_key )? ( in_key in_elements | between_key between_elements | like_type concatenation ( like_escape_part )? )
            	    {
            	        // PLSQL_DMLParser.g:669:10: ( not_key )?
            	        {
            	            int alt210=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_NOT:
            	                	{
            	                		alt210=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt210)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:669:10: not_key
            	        	    {
            	        	        this->followPush(FOLLOW_not_key_in_compound_expression5599);
            	        	        m_gPLSQLParser->not_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQL_DMLParser.g:670:9: ( in_key in_elements | between_key between_elements | like_type concatenation ( like_escape_part )? )
            	        {
            	            int alt212=3;
            	            {
            	                int LA212_0 = this->LA(1);
            	                if ( (LA212_0 == SQL92_RESERVED_IN))
            	                {
            	                    alt212=1;
            	                }
            	                else if ( (LA212_0 == SQL92_RESERVED_BETWEEN))
            	                {
            	                    alt212=2;
            	                }
            	                else if ( (LA212_0 == SQL92_RESERVED_LIKE))
            	                {
            	                    alt212=3;
            	                }
            	                else if ( ((((equalsIgnoreCase(LT(1)->getText(), "LIKEC")))||((equalsIgnoreCase(LT(1)->getText(), "LIKE4")))||((equalsIgnoreCase(LT(1)->getText(), "LIKE2"))))) && (LA212_0 == REGULAR_ID))
            	                {
            	                    alt212=3;
            	                }
            	                else
            	                {
            	                    if (this->get_backtracking()>0)
            	                    {
            	                        this->set_failedflag( true );
            	                        return ;
            	                    }


            	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                    ex->set_decisionNum( 212 );
            	                    ex->set_state( 0 );


            	                    goto rulecompound_expressionEx;

            	                }
            	            }
            	            switch (alt212)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:670:14: in_key in_elements
            	        	    {
            	        	        this->followPush(FOLLOW_in_key_in_compound_expression5615);
            	        	        m_gPLSQLParser->in_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_in_elements_in_compound_expression5617);
            	        	        in_elements();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:671:14: between_key between_elements
            	        	    {
            	        	        this->followPush(FOLLOW_between_key_in_compound_expression5632);
            	        	        m_gPLSQLParser->between_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_between_elements_in_compound_expression5634);
            	        	        between_elements();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // PLSQL_DMLParser.g:672:14: like_type concatenation ( like_escape_part )?
            	        	    {
            	        	        this->followPush(FOLLOW_like_type_in_compound_expression5649);
            	        	        like_type();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_concatenation_in_compound_expression5651);
            	        	        concatenation();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecompound_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // PLSQL_DMLParser.g:672:38: ( like_escape_part )?
            	        	        {
            	        	            int alt211=2;
            	        	            switch ( this->LA(1) )
            	        	            {
            	        	                case REGULAR_ID:
            	        	                	{
            	        	                		{
            	        	                		    int LA211_1 = this->LA(2);
            	        	                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "ESCAPE"))))
            	        	                		    {
            	        	                		        alt211=1;
            	        	                		    }
            	        	                		}
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt211)
            	        	            {
            	        	        	case 1:
            	        	        	    // PLSQL_DMLParser.g:672:38: like_escape_part
            	        	        	    {
            	        	        	        this->followPush(FOLLOW_like_escape_part_in_compound_expression5653);
            	        	        	        like_escape_part();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto rulecompound_expressionEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulecompound_expressionEx; /* Prevent compiler warnings */
    rulecompound_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end compound_expression */

/**
 * $ANTLR start like_type
 * PLSQL_DMLParser.g:677:1: like_type : ( like_key | likec_key | like2_key | like4_key );
 */
void
PLSQLParser_PLSQL_DMLParser::like_type()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:678:5: ( like_key | likec_key | like2_key | like4_key )

            ANTLR_UINT32 alt214;

            alt214=4;

            {
                int LA214_0 = this->LA(1);
                if ( (LA214_0 == SQL92_RESERVED_LIKE))
                {
                    alt214=1;
                }
                else if ( ((((equalsIgnoreCase(LT(1)->getText(), "LIKEC")))||((equalsIgnoreCase(LT(1)->getText(), "LIKE4")))||((equalsIgnoreCase(LT(1)->getText(), "LIKE2"))))) && (LA214_0 == REGULAR_ID))
                {
                    {
                        int LA214_2 = this->LA(2);
                        if ( ((equalsIgnoreCase(LT(1)->getText(), "LIKEC"))))
                        {
                            alt214=2;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "LIKE2"))))
                        {
                            alt214=3;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "LIKE4"))))
                        {
                            alt214=4;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 214 );
                            ex->set_state( 2 );


                            goto rulelike_typeEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 214 );
                    ex->set_state( 0 );


                    goto rulelike_typeEx;

                }
            }
            switch (alt214)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:678:10: like_key
        	    {
        	        this->followPush(FOLLOW_like_key_in_like_type5691);
        	        m_gPLSQLParser->like_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelike_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:679:10: likec_key
        	    {
        	        this->followPush(FOLLOW_likec_key_in_like_type5702);
        	        m_gPLSQLParser->likec_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelike_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:680:10: like2_key
        	    {
        	        this->followPush(FOLLOW_like2_key_in_like_type5713);
        	        m_gPLSQLParser->like2_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelike_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQL_DMLParser.g:681:10: like4_key
        	    {
        	        this->followPush(FOLLOW_like4_key_in_like_type5724);
        	        m_gPLSQLParser->like4_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelike_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulelike_typeEx; /* Prevent compiler warnings */
    rulelike_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end like_type */

/**
 * $ANTLR start like_escape_part
 * PLSQL_DMLParser.g:684:1: like_escape_part : escape_key concatenation ;
 */
void
PLSQLParser_PLSQL_DMLParser::like_escape_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:685:5: ( escape_key concatenation )
        // PLSQL_DMLParser.g:685:10: escape_key concatenation
        {
            this->followPush(FOLLOW_escape_key_in_like_escape_part5744);
            m_gPLSQLParser->escape_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelike_escape_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_concatenation_in_like_escape_part5746);
            concatenation();

            this->followPop();
            if  (this->hasException())
            {
                goto rulelike_escape_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulelike_escape_partEx; /* Prevent compiler warnings */
    rulelike_escape_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end like_escape_part */

/**
 * $ANTLR start in_elements
 * PLSQL_DMLParser.g:688:1: in_elements : ( ( ( LEFT_PAREN )+ ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN concatenation_wrapper ( COMMA concatenation_wrapper )* RIGHT_PAREN | constant | bind_variable | general_element );
 */
void
PLSQLParser_PLSQL_DMLParser::in_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:689:5: ( ( ( LEFT_PAREN )+ ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN concatenation_wrapper ( COMMA concatenation_wrapper )* RIGHT_PAREN | constant | bind_variable | general_element )

            ANTLR_UINT32 alt216;

            alt216=5;

            switch ( this->LA(1) )
            {
            case LEFT_PAREN:
            	{
            		{
            		    int LA216_1 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred26_PLSQL_DMLParser>() )))
            		    {
            		        alt216=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt216=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 216 );
            		        ex->set_state( 1 );


            		        goto rulein_elementsEx;

            		    }
            		}
            	}
                break;
            case REGULAR_ID:
            	{
            		{
            		    int LA216_2 = this->LA(2);
            		    if ( ((((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||((equalsIgnoreCase(LT(1)->getText(), "MAXVALUE")))||((equalsIgnoreCase(LT(1)->getText(), "TIMESTAMP")))||((equalsIgnoreCase(LT(1)->getText(), "MINVALUE")))||((equalsIgnoreCase(LT(1)->getText(), "SESSIONTIMEZONE")))||((equalsIgnoreCase(LT(1)->getText(), "DBTIMEZONE"))))))
            		    {
            		        alt216=3;
            		    }
            		    else if ( (true))
            		    {
            		        alt216=5;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 216 );
            		        ex->set_state( 2 );


            		        goto rulein_elementsEx;

            		    }
            		}
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case EXACT_NUM_LIT:
            case NATIONAL_CHAR_STRING_LIT:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt216=3;
            	}
                break;
            case BINDVAR:
            case COLON:
            	{
            		alt216=4;
            	}
                break;
            case DELIMITED_ID:
            case INTRODUCER:
            	{
            		alt216=5;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 216 );
                ex->set_state( 0 );


                goto rulein_elementsEx;

            }

            switch (alt216)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:689:10: ( ( LEFT_PAREN )+ ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN
        	    {
        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_in_elements5779);
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_subquery_in_in_elements5781);
        	        subquery();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_in_elements5783);
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:690:10: LEFT_PAREN concatenation_wrapper ( COMMA concatenation_wrapper )* RIGHT_PAREN
        	    {
        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_in_elements5794);
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_concatenation_wrapper_in_in_elements5796);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:690:43: ( COMMA concatenation_wrapper )*

        	        for (;;)
        	        {
        	            int alt215=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt215=1;
        	            	}
        	                break;

        	            }

        	            switch (alt215)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:690:44: COMMA concatenation_wrapper
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_in_elements5799);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulein_elementsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_in_elements5801);
        	        	        concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulein_elementsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop215;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop215: ; /* Jump out to here if this rule does not match */


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_in_elements5805);
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:691:10: constant
        	    {
        	        this->followPush(FOLLOW_constant_in_in_elements5816);
        	        m_gPLSQLParser->constant();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQL_DMLParser.g:692:10: bind_variable
        	    {
        	        this->followPush(FOLLOW_bind_variable_in_in_elements5827);
        	        m_gPLSQLParser->bind_variable();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQL_DMLParser.g:693:10: general_element
        	    {
        	        this->followPush(FOLLOW_general_element_in_in_elements5838);
        	        m_gPLSQLParser->general_element();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulein_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulein_elementsEx; /* Prevent compiler warnings */
    rulein_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end in_elements */

/**
 * $ANTLR start between_elements
 * PLSQL_DMLParser.g:696:1: between_elements : concatenation and_key concatenation ;
 */
void
PLSQLParser_PLSQL_DMLParser::between_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:697:5: ( concatenation and_key concatenation )
        // PLSQL_DMLParser.g:697:10: concatenation and_key concatenation
        {
            this->followPush(FOLLOW_concatenation_in_between_elements5858);
            concatenation();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebetween_elementsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_and_key_in_between_elements5860);
            m_gPLSQLParser->and_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebetween_elementsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_concatenation_in_between_elements5862);
            concatenation();

            this->followPop();
            if  (this->hasException())
            {
                goto rulebetween_elementsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulebetween_elementsEx; /* Prevent compiler warnings */
    rulebetween_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end between_elements */

/**
 * $ANTLR start concatenation
 * PLSQL_DMLParser.g:700:1: concatenation : additive_expression ( concatenation_op additive_expression )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::concatenation()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:701:5: ( additive_expression ( concatenation_op additive_expression )* )
        // PLSQL_DMLParser.g:701:10: additive_expression ( concatenation_op additive_expression )*
        {
            this->followPush(FOLLOW_additive_expression_in_concatenation5882);
            additive_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconcatenationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:701:30: ( concatenation_op additive_expression )*

            for (;;)
            {
                int alt217=2;
                switch ( this->LA(1) )
                {
                case CONCATENATION_OP:
                	{
                		alt217=1;
                	}
                    break;
                case VERTICAL_BAR:
                	{
                		alt217=1;
                	}
                    break;

                }

                switch (alt217)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:701:31: concatenation_op additive_expression
            	    {
            	        this->followPush(FOLLOW_concatenation_op_in_concatenation5885);
            	        m_gPLSQLParser->concatenation_op();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconcatenationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_additive_expression_in_concatenation5887);
            	        additive_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleconcatenationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop217;	/* break out of the loop */
            	    break;
                }
            }
            loop217: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconcatenationEx; /* Prevent compiler warnings */
    ruleconcatenationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end concatenation */

/**
 * $ANTLR start concatenation_wrapper
 * PLSQL_DMLParser.g:704:1: concatenation_wrapper : concatenation ;
 */
void
PLSQLParser_PLSQL_DMLParser::concatenation_wrapper()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:705:5: ( concatenation )
        // PLSQL_DMLParser.g:705:10: concatenation
        {
            this->followPush(FOLLOW_concatenation_in_concatenation_wrapper5909);
            concatenation();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleconcatenation_wrapperEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleconcatenation_wrapperEx; /* Prevent compiler warnings */
    ruleconcatenation_wrapperEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end concatenation_wrapper */

/**
 * $ANTLR start additive_expression
 * PLSQL_DMLParser.g:708:1: additive_expression : multiply_expression ( ( PLUS_SIGN | MINUS_SIGN ) multiply_expression )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::additive_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:709:5: ( multiply_expression ( ( PLUS_SIGN | MINUS_SIGN ) multiply_expression )* )
        // PLSQL_DMLParser.g:709:10: multiply_expression ( ( PLUS_SIGN | MINUS_SIGN ) multiply_expression )*
        {
            this->followPush(FOLLOW_multiply_expression_in_additive_expression5929);
            multiply_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleadditive_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:709:30: ( ( PLUS_SIGN | MINUS_SIGN ) multiply_expression )*

            for (;;)
            {
                int alt218=2;
                switch ( this->LA(1) )
                {
                case MINUS_SIGN:
                case PLUS_SIGN:
                	{
                		alt218=1;
                	}
                    break;

                }

                switch (alt218)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:709:32: ( PLUS_SIGN | MINUS_SIGN ) multiply_expression
            	    {
            	        if ( this->LA(1) == MINUS_SIGN || this->LA(1) == PLUS_SIGN )
            	        {
            	            this->consume();
            	            this->set_perror_recovery(false);
            	             this->set_failedflag(false); 

            	        }
            	        else
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return ;
            	            }

            	            new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            this->get_exception()->set_expectingSet(NULL);

            	            goto ruleadditive_expressionEx;
            	        }


            	        this->followPush(FOLLOW_multiply_expression_in_additive_expression5943);
            	        multiply_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleadditive_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop218;	/* break out of the loop */
            	    break;
                }
            }
            loop218: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleadditive_expressionEx; /* Prevent compiler warnings */
    ruleadditive_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end additive_expression */

/**
 * $ANTLR start multiply_expression
 * PLSQL_DMLParser.g:712:1: multiply_expression : datetime_expression ( ( ASTERISK | SOLIDUS ) datetime_expression )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::multiply_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:713:5: ( datetime_expression ( ( ASTERISK | SOLIDUS ) datetime_expression )* )
        // PLSQL_DMLParser.g:713:10: datetime_expression ( ( ASTERISK | SOLIDUS ) datetime_expression )*
        {
            this->followPush(FOLLOW_datetime_expression_in_multiply_expression5965);
            datetime_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemultiply_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:713:30: ( ( ASTERISK | SOLIDUS ) datetime_expression )*

            for (;;)
            {
                int alt219=2;
                switch ( this->LA(1) )
                {
                case SOLIDUS:
                	{
                		alt219=1;
                	}
                    break;
                case ASTERISK:
                	{
                		alt219=1;
                	}
                    break;

                }

                switch (alt219)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:713:32: ( ASTERISK | SOLIDUS ) datetime_expression
            	    {
            	        if ( this->LA(1) == ASTERISK || this->LA(1) == SOLIDUS )
            	        {
            	            this->consume();
            	            this->set_perror_recovery(false);
            	             this->set_failedflag(false); 

            	        }
            	        else
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return ;
            	            }

            	            new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            this->get_exception()->set_expectingSet(NULL);

            	            goto rulemultiply_expressionEx;
            	        }


            	        this->followPush(FOLLOW_datetime_expression_in_multiply_expression5979);
            	        datetime_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiply_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop219;	/* break out of the loop */
            	    break;
                }
            }
            loop219: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemultiply_expressionEx; /* Prevent compiler warnings */
    rulemultiply_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multiply_expression */

/**
 * $ANTLR start datetime_expression
 * PLSQL_DMLParser.g:716:1: datetime_expression : model_expression ( at_key ( local_key | time_key zone_key concatenation_wrapper ) | ( interval_expression )=> interval_expression )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::datetime_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:717:5: ( model_expression ( at_key ( local_key | time_key zone_key concatenation_wrapper ) | ( interval_expression )=> interval_expression )? )
        // PLSQL_DMLParser.g:717:10: model_expression ( at_key ( local_key | time_key zone_key concatenation_wrapper ) | ( interval_expression )=> interval_expression )?
        {
            this->followPush(FOLLOW_model_expression_in_datetime_expression6001);
            model_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruledatetime_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:718:5: ( at_key ( local_key | time_key zone_key concatenation_wrapper ) | ( interval_expression )=> interval_expression )?
            {
                int alt221=3;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA221_1 = this->LA(2);
                    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "AT"))))
                    		    {
                    		        alt221=1;
                    		    }
                    		    else if ( (( (this->msynpred( antlr3::ClassForwarder<synpred27_PLSQL_DMLParser>() )) && ((((equalsIgnoreCase(LT(1)->getText(), "DAY")))||((equalsIgnoreCase(LT(1)->getText(), "YEAR"))))) )))
                    		    {
                    		        alt221=2;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt221)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:718:10: at_key ( local_key | time_key zone_key concatenation_wrapper )
            	    {
            	        this->followPush(FOLLOW_at_key_in_datetime_expression6012);
            	        m_gPLSQLParser->at_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledatetime_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:718:17: ( local_key | time_key zone_key concatenation_wrapper )
            	        {
            	            int alt220=2;
            	            switch ( this->LA(1) )
            	            {
            	            case REGULAR_ID:
            	            	{
            	            		{
            	            		    int LA220_1 = this->LA(2);
            	            		    if ( ((equalsIgnoreCase(LT(1)->getText(), "LOCAL"))))
            	            		    {
            	            		        alt220=1;
            	            		    }
            	            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "TIME"))))
            	            		    {
            	            		        alt220=2;
            	            		    }
            	            		    else
            	            		    {
            	            		        if (this->get_backtracking()>0)
            	            		        {
            	            		            this->set_failedflag( true );
            	            		            return ;
            	            		        }


            	            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            		        ex->set_decisionNum( 220 );
            	            		        ex->set_state( 1 );


            	            		        goto ruledatetime_expressionEx;

            	            		    }
            	            		}
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return ;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 220 );
            	                ex->set_state( 0 );


            	                goto ruledatetime_expressionEx;

            	            }

            	            switch (alt220)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:718:18: local_key
            	        	    {
            	        	        this->followPush(FOLLOW_local_key_in_datetime_expression6015);
            	        	        m_gPLSQLParser->local_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruledatetime_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:718:28: time_key zone_key concatenation_wrapper
            	        	    {
            	        	        this->followPush(FOLLOW_time_key_in_datetime_expression6017);
            	        	        m_gPLSQLParser->time_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruledatetime_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_zone_key_in_datetime_expression6019);
            	        	        m_gPLSQLParser->zone_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruledatetime_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_concatenation_wrapper_in_datetime_expression6021);
            	        	        concatenation_wrapper();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruledatetime_expressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:719:10: ( interval_expression )=> interval_expression
            	    {
            	        this->followPush(FOLLOW_interval_expression_in_datetime_expression6038);
            	        interval_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruledatetime_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruledatetime_expressionEx; /* Prevent compiler warnings */
    ruledatetime_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end datetime_expression */

/**
 * $ANTLR start interval_expression
 * PLSQL_DMLParser.g:723:1: interval_expression : ( day_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? to_key second_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? | year_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? to_key month_key );
 */
void
PLSQLParser_PLSQL_DMLParser::interval_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:724:5: ( day_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? to_key second_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? | year_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? to_key month_key )

            ANTLR_UINT32 alt225;

            alt225=2;

            {
                int LA225_0 = this->LA(1);
                if ( ((((equalsIgnoreCase(LT(1)->getText(), "DAY")))||((equalsIgnoreCase(LT(1)->getText(), "YEAR"))))) && (LA225_0 == REGULAR_ID))
                {
                    {
                        int LA225_1 = this->LA(2);
                        if ( ((equalsIgnoreCase(LT(1)->getText(), "DAY"))))
                        {
                            alt225=1;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "YEAR"))))
                        {
                            alt225=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 225 );
                            ex->set_state( 1 );


                            goto ruleinterval_expressionEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 225 );
                    ex->set_state( 0 );


                    goto ruleinterval_expressionEx;

                }
            }
            switch (alt225)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:724:10: day_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? to_key second_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )?
        	    {
        	        this->followPush(FOLLOW_day_key_in_interval_expression6065);
        	        m_gPLSQLParser->day_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinterval_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:724:21: ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )?
        	        {
        	            int alt222=2;
        	            switch ( this->LA(1) )
        	            {
        	                case LEFT_PAREN:
        	                	{
        	                		alt222=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt222)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:724:22: LEFT_PAREN concatenation_wrapper RIGHT_PAREN
        	        	    {
        	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_interval_expression6071);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_interval_expression6073);
        	        	        concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_interval_expression6075);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_to_key_in_interval_expression6079);
        	        m_gPLSQLParser->to_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinterval_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_second_key_in_interval_expression6081);
        	        m_gPLSQLParser->second_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinterval_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:724:87: ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )?
        	        {
        	            int alt223=2;
        	            switch ( this->LA(1) )
        	            {
        	                case LEFT_PAREN:
        	                	{
        	                		alt223=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt223)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:724:88: LEFT_PAREN concatenation_wrapper RIGHT_PAREN
        	        	    {
        	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_interval_expression6084);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_interval_expression6086);
        	        	        concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_interval_expression6088);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:725:10: year_key ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )? to_key month_key
        	    {
        	        this->followPush(FOLLOW_year_key_in_interval_expression6101);
        	        m_gPLSQLParser->year_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinterval_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:725:19: ( LEFT_PAREN concatenation_wrapper RIGHT_PAREN )?
        	        {
        	            int alt224=2;
        	            switch ( this->LA(1) )
        	            {
        	                case LEFT_PAREN:
        	                	{
        	                		alt224=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt224)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:725:20: LEFT_PAREN concatenation_wrapper RIGHT_PAREN
        	        	    {
        	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_interval_expression6104);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_interval_expression6106);
        	        	        concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_interval_expression6108);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleinterval_expressionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_to_key_in_interval_expression6112);
        	        m_gPLSQLParser->to_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinterval_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_month_key_in_interval_expression6114);
        	        m_gPLSQLParser->month_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinterval_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleinterval_expressionEx; /* Prevent compiler warnings */
    ruleinterval_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end interval_expression */

/**
 * $ANTLR start model_expression
 * PLSQL_DMLParser.g:728:1: model_expression : multiset_expression ( LEFT_BRACKET model_expression_element RIGHT_BRACKET )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::model_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:729:5: ( multiset_expression ( LEFT_BRACKET model_expression_element RIGHT_BRACKET )? )
        // PLSQL_DMLParser.g:729:10: multiset_expression ( LEFT_BRACKET model_expression_element RIGHT_BRACKET )?
        {
            this->followPush(FOLLOW_multiset_expression_in_model_expression6134);
            multiset_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemodel_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:730:9: ( LEFT_BRACKET model_expression_element RIGHT_BRACKET )?
            {
                int alt226=2;
                switch ( this->LA(1) )
                {
                    case LEFT_BRACKET:
                    	{
                    		alt226=1;
                    	}
                        break;
                }

                switch (alt226)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:730:10: LEFT_BRACKET model_expression_element RIGHT_BRACKET
            	    {
            	         this->matchToken(LEFT_BRACKET, &FOLLOW_LEFT_BRACKET_in_model_expression6145);
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_model_expression_element_in_model_expression6147);
            	        model_expression_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_BRACKET, &FOLLOW_RIGHT_BRACKET_in_model_expression6149);
            	        if  (this->hasException())
            	        {
            	            goto rulemodel_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulemodel_expressionEx; /* Prevent compiler warnings */
    rulemodel_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_expression */

/**
 * $ANTLR start model_expression_element
 * PLSQL_DMLParser.g:733:1: model_expression_element : ( ( ( any_key )=> any_key | condition_wrapper ) ( COMMA ( ( any_key )=> any_key | condition_wrapper ) )* | single_column_for_loop ( COMMA single_column_for_loop )* | multi_column_for_loop );
 */
void
PLSQLParser_PLSQL_DMLParser::model_expression_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:734:5: ( ( ( any_key )=> any_key | condition_wrapper ) ( COMMA ( ( any_key )=> any_key | condition_wrapper ) )* | single_column_for_loop ( COMMA single_column_for_loop )* | multi_column_for_loop )

            ANTLR_UINT32 alt231;

            alt231=3;

            switch ( this->LA(1) )
            {
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case DELIMITED_ID:
            case EXACT_NUM_LIT:
            case INTRODUCER:
            case LEFT_PAREN:
            case MINUS_SIGN:
            case NATIONAL_CHAR_STRING_LIT:
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            case PLUS_SIGN:
            case REGULAR_ID:
            case SQL92_RESERVED_ALL:
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_CASE:
            case SQL92_RESERVED_CURSOR:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_DISTINCT:
            case SQL92_RESERVED_EXISTS:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NOT:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_PRIOR:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt231=1;
            	}
                break;
            case SQL92_RESERVED_FOR:
            	{
            		switch ( this->LA(2) )
            		{
            		case DELIMITED_ID:
            		case INTRODUCER:
            		case REGULAR_ID:
            			{
            				alt231=2;
            			}
            		    break;
            		case LEFT_PAREN:
            			{
            				alt231=3;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 231 );
            		    ex->set_state( 2 );


            		    goto rulemodel_expression_elementEx;

            		}

            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 231 );
                ex->set_state( 0 );


                goto rulemodel_expression_elementEx;

            }

            switch (alt231)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:734:10: ( ( any_key )=> any_key | condition_wrapper ) ( COMMA ( ( any_key )=> any_key | condition_wrapper ) )*
        	    {
        	        // PLSQL_DMLParser.g:734:10: ( ( any_key )=> any_key | condition_wrapper )
        	        {
        	            int alt227=2;
        	            switch ( this->LA(1) )
        	            {
        	            case SQL92_RESERVED_ANY:
        	            	{
        	            		{
        	            		    int LA227_1 = this->LA(2);
        	            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred28_PLSQL_DMLParser>() )) && (LA227_1 == COMMA))
        	            		    {
        	            		        alt227=1;
        	            		    }
        	            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred28_PLSQL_DMLParser>() )) && (LA227_1 == RIGHT_BRACKET))
        	            		    {
        	            		        alt227=1;
        	            		    }
        	            		    else if ( (LA227_1 == LEFT_PAREN))
        	            		    {
        	            		        alt227=2;
        	            		    }
        	            		    else
        	            		    {
        	            		        if (this->get_backtracking()>0)
        	            		        {
        	            		            this->set_failedflag( true );
        	            		            return ;
        	            		        }


        	            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            		        ex->set_decisionNum( 227 );
        	            		        ex->set_state( 1 );


        	            		        goto rulemodel_expression_elementEx;

        	            		    }
        	            		}
        	            	}
        	                break;
        	            case APPROXIMATE_NUM_LIT:
        	            case BINDVAR:
        	            case CHAR_STRING:
        	            case CHAR_STRING_PERL:
        	            case COLON:
        	            case DELIMITED_ID:
        	            case EXACT_NUM_LIT:
        	            case INTRODUCER:
        	            case LEFT_PAREN:
        	            case MINUS_SIGN:
        	            case NATIONAL_CHAR_STRING_LIT:
        	            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
        	            case PLUS_SIGN:
        	            case REGULAR_ID:
        	            case SQL92_RESERVED_ALL:
        	            case SQL92_RESERVED_CASE:
        	            case SQL92_RESERVED_CURSOR:
        	            case SQL92_RESERVED_DATE:
        	            case SQL92_RESERVED_DEFAULT:
        	            case SQL92_RESERVED_DISTINCT:
        	            case SQL92_RESERVED_EXISTS:
        	            case SQL92_RESERVED_FALSE:
        	            case SQL92_RESERVED_NOT:
        	            case SQL92_RESERVED_NULL:
        	            case SQL92_RESERVED_PRIOR:
        	            case SQL92_RESERVED_TRUE:
        	            case UNSIGNED_INTEGER:
        	            	{
        	            		alt227=2;
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return ;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 227 );
        	                ex->set_state( 0 );


        	                goto rulemodel_expression_elementEx;

        	            }

        	            switch (alt227)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:734:11: ( any_key )=> any_key
        	        	    {
        	        	        this->followPush(FOLLOW_any_key_in_model_expression_element6177);
        	        	        m_gPLSQLParser->any_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemodel_expression_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:734:31: condition_wrapper
        	        	    {
        	        	        this->followPush(FOLLOW_condition_wrapper_in_model_expression_element6179);
        	        	        condition_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemodel_expression_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:734:50: ( COMMA ( ( any_key )=> any_key | condition_wrapper ) )*

        	        for (;;)
        	        {
        	            int alt229=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt229=1;
        	            	}
        	                break;

        	            }

        	            switch (alt229)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:734:51: COMMA ( ( any_key )=> any_key | condition_wrapper )
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_model_expression_element6183);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemodel_expression_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQL_DMLParser.g:734:57: ( ( any_key )=> any_key | condition_wrapper )
        	        	        {
        	        	            int alt228=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	            case SQL92_RESERVED_ANY:
        	        	            	{
        	        	            		{
        	        	            		    int LA228_1 = this->LA(2);
        	        	            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred29_PLSQL_DMLParser>() )) && (LA228_1 == RIGHT_BRACKET))
        	        	            		    {
        	        	            		        alt228=1;
        	        	            		    }
        	        	            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred29_PLSQL_DMLParser>() )) && (LA228_1 == COMMA))
        	        	            		    {
        	        	            		        alt228=1;
        	        	            		    }
        	        	            		    else if ( (LA228_1 == LEFT_PAREN))
        	        	            		    {
        	        	            		        alt228=2;
        	        	            		    }
        	        	            		    else
        	        	            		    {
        	        	            		        if (this->get_backtracking()>0)
        	        	            		        {
        	        	            		            this->set_failedflag( true );
        	        	            		            return ;
        	        	            		        }


        	        	            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	            		        ex->set_decisionNum( 228 );
        	        	            		        ex->set_state( 1 );


        	        	            		        goto rulemodel_expression_elementEx;

        	        	            		    }
        	        	            		}
        	        	            	}
        	        	                break;
        	        	            case APPROXIMATE_NUM_LIT:
        	        	            case BINDVAR:
        	        	            case CHAR_STRING:
        	        	            case CHAR_STRING_PERL:
        	        	            case COLON:
        	        	            case DELIMITED_ID:
        	        	            case EXACT_NUM_LIT:
        	        	            case INTRODUCER:
        	        	            case LEFT_PAREN:
        	        	            case MINUS_SIGN:
        	        	            case NATIONAL_CHAR_STRING_LIT:
        	        	            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
        	        	            case PLUS_SIGN:
        	        	            case REGULAR_ID:
        	        	            case SQL92_RESERVED_ALL:
        	        	            case SQL92_RESERVED_CASE:
        	        	            case SQL92_RESERVED_CURSOR:
        	        	            case SQL92_RESERVED_DATE:
        	        	            case SQL92_RESERVED_DEFAULT:
        	        	            case SQL92_RESERVED_DISTINCT:
        	        	            case SQL92_RESERVED_EXISTS:
        	        	            case SQL92_RESERVED_FALSE:
        	        	            case SQL92_RESERVED_NOT:
        	        	            case SQL92_RESERVED_NULL:
        	        	            case SQL92_RESERVED_PRIOR:
        	        	            case SQL92_RESERVED_TRUE:
        	        	            case UNSIGNED_INTEGER:
        	        	            	{
        	        	            		alt228=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                if (this->get_backtracking()>0)
        	        	                {
        	        	                    this->set_failedflag( true );
        	        	                    return ;
        	        	                }

        	        	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                ex->set_decisionNum( 228 );
        	        	                ex->set_state( 0 );


        	        	                goto rulemodel_expression_elementEx;

        	        	            }

        	        	            switch (alt228)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:734:58: ( any_key )=> any_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_any_key_in_model_expression_element6191);
        	        	        	        m_gPLSQLParser->any_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulemodel_expression_elementEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // PLSQL_DMLParser.g:734:78: condition_wrapper
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_condition_wrapper_in_model_expression_element6193);
        	        	        	        condition_wrapper();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulemodel_expression_elementEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop229;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop229: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:735:10: single_column_for_loop ( COMMA single_column_for_loop )*
        	    {
        	        this->followPush(FOLLOW_single_column_for_loop_in_model_expression_element6207);
        	        single_column_for_loop();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemodel_expression_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:735:33: ( COMMA single_column_for_loop )*

        	        for (;;)
        	        {
        	            int alt230=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt230=1;
        	            	}
        	                break;

        	            }

        	            switch (alt230)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:735:34: COMMA single_column_for_loop
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_model_expression_element6210);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemodel_expression_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_single_column_for_loop_in_model_expression_element6212);
        	        	        single_column_for_loop();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulemodel_expression_elementEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop230;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop230: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:736:10: multi_column_for_loop
        	    {
        	        this->followPush(FOLLOW_multi_column_for_loop_in_model_expression_element6225);
        	        multi_column_for_loop();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulemodel_expression_elementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulemodel_expression_elementEx; /* Prevent compiler warnings */
    rulemodel_expression_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end model_expression_element */

/**
 * $ANTLR start single_column_for_loop
 * PLSQL_DMLParser.g:739:1: single_column_for_loop : for_key column_name ( in_key expression_list | ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::single_column_for_loop()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:740:5: ( for_key column_name ( in_key expression_list | ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression ) )
        // PLSQL_DMLParser.g:740:10: for_key column_name ( in_key expression_list | ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression )
        {
            this->followPush(FOLLOW_for_key_in_single_column_for_loop6245);
            m_gPLSQLParser->for_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesingle_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_single_column_for_loop6247);
            m_gPLSQLParser->column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesingle_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:741:5: ( in_key expression_list | ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression )
            {
                int alt233=2;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_IN:
                	{
                		alt233=1;
                	}
                    break;
                case SQL92_RESERVED_FROM:
                case SQL92_RESERVED_LIKE:
                	{
                		alt233=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 233 );
                    ex->set_state( 0 );


                    goto rulesingle_column_for_loopEx;

                }

                switch (alt233)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:741:10: in_key expression_list
            	    {
            	        this->followPush(FOLLOW_in_key_in_single_column_for_loop6259);
            	        m_gPLSQLParser->in_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_list_in_single_column_for_loop6261);
            	        expression_list();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:742:10: ( for_like_part )? from_key ex1= expression to_key ex2= expression for_increment_decrement_type ex3= expression
            	    {
            	        // PLSQL_DMLParser.g:742:10: ( for_like_part )?
            	        {
            	            int alt232=2;
            	            switch ( this->LA(1) )
            	            {
            	                case SQL92_RESERVED_LIKE:
            	                	{
            	                		alt232=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt232)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:742:10: for_like_part
            	        	    {
            	        	        this->followPush(FOLLOW_for_like_part_in_single_column_for_loop6272);
            	        	        for_like_part();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesingle_column_for_loopEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        this->followPush(FOLLOW_from_key_in_single_column_for_loop6275);
            	        m_gPLSQLParser->from_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_single_column_for_loop6279);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_to_key_in_single_column_for_loop6293);
            	        m_gPLSQLParser->to_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_single_column_for_loop6297);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_for_increment_decrement_type_in_single_column_for_loop6299);
            	        for_increment_decrement_type();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_single_column_for_loop6303);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesingle_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesingle_column_for_loopEx; /* Prevent compiler warnings */
    rulesingle_column_for_loopEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end single_column_for_loop */

/**
 * $ANTLR start for_like_part
 * PLSQL_DMLParser.g:747:1: for_like_part : like_key expression ;
 */
void
PLSQLParser_PLSQL_DMLParser::for_like_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:748:5: ( like_key expression )
        // PLSQL_DMLParser.g:748:10: like_key expression
        {
            this->followPush(FOLLOW_like_key_in_for_like_part6334);
            m_gPLSQLParser->like_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_like_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_for_like_part6336);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefor_like_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefor_like_partEx; /* Prevent compiler warnings */
    rulefor_like_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end for_like_part */

/**
 * $ANTLR start for_increment_decrement_type
 * PLSQL_DMLParser.g:751:1: for_increment_decrement_type : ( increment_key | decrement_key );
 */
void
PLSQLParser_PLSQL_DMLParser::for_increment_decrement_type()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:752:5: ( increment_key | decrement_key )

            ANTLR_UINT32 alt234;

            alt234=2;

            {
                int LA234_0 = this->LA(1);
                if ( ((((equalsIgnoreCase(LT(1)->getText(), "DECREMENT")))||((equalsIgnoreCase(LT(1)->getText(), "INCREMENT"))))) && (LA234_0 == REGULAR_ID))
                {
                    {
                        int LA234_1 = this->LA(2);
                        if ( ((equalsIgnoreCase(LT(1)->getText(), "INCREMENT"))))
                        {
                            alt234=1;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "DECREMENT"))))
                        {
                            alt234=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 234 );
                            ex->set_state( 1 );


                            goto rulefor_increment_decrement_typeEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 234 );
                    ex->set_state( 0 );


                    goto rulefor_increment_decrement_typeEx;

                }
            }
            switch (alt234)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:752:10: increment_key
        	    {
        	        this->followPush(FOLLOW_increment_key_in_for_increment_decrement_type6356);
        	        m_gPLSQLParser->increment_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_increment_decrement_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:753:10: decrement_key
        	    {
        	        this->followPush(FOLLOW_decrement_key_in_for_increment_decrement_type6367);
        	        m_gPLSQLParser->decrement_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulefor_increment_decrement_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulefor_increment_decrement_typeEx; /* Prevent compiler warnings */
    rulefor_increment_decrement_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end for_increment_decrement_type */

/**
 * $ANTLR start multi_column_for_loop
 * PLSQL_DMLParser.g:756:1: multi_column_for_loop : for_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN in_key LEFT_PAREN ( ( select_key )=> subquery | ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN ) RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::multi_column_for_loop()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:757:5: ( for_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN in_key LEFT_PAREN ( ( select_key )=> subquery | ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN ) RIGHT_PAREN )
        // PLSQL_DMLParser.g:757:10: for_key LEFT_PAREN column_name ( COMMA column_name )* RIGHT_PAREN in_key LEFT_PAREN ( ( select_key )=> subquery | ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN ) RIGHT_PAREN
        {
            this->followPush(FOLLOW_for_key_in_multi_column_for_loop6387);
            m_gPLSQLParser->for_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_multi_column_for_loop6389);
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_column_name_in_multi_column_for_loop6391);
            m_gPLSQLParser->column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:757:41: ( COMMA column_name )*

            for (;;)
            {
                int alt235=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt235=1;
                	}
                    break;

                }

                switch (alt235)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:757:42: COMMA column_name
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_multi_column_for_loop6394);
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_name_in_multi_column_for_loop6396);
            	        m_gPLSQLParser->column_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop235;	/* break out of the loop */
            	    break;
                }
            }
            loop235: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6400);
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_in_key_in_multi_column_for_loop6402);
            m_gPLSQLParser->in_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_multi_column_for_loop6412);
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:759:13: ( ( select_key )=> subquery | ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN )
            {
                int alt237=2;
                {
                    int LA237_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred30_PLSQL_DMLParser>() )) && (LA237_0 == SQL92_RESERVED_SELECT))
                    {
                        alt237=1;
                    }
                    else if ( (LA237_0 == LEFT_PAREN))
                    {
                        {
                            int LA237_2 = this->LA(2);
                            if ( (this->msynpred( antlr3::ClassForwarder<synpred30_PLSQL_DMLParser>() )))
                            {
                                alt237=1;
                            }
                            else if ( (this->msynpred( antlr3::ClassForwarder<synpred31_PLSQL_DMLParser>() )))
                            {
                                alt237=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 237 );
                                ex->set_state( 2 );


                                goto rulemulti_column_for_loopEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 237 );
                        ex->set_state( 0 );


                        goto rulemulti_column_for_loopEx;

                    }
                }
                switch (alt237)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:759:18: ( select_key )=> subquery
            	    {
            	        this->followPush(FOLLOW_subquery_in_multi_column_for_loop6436);
            	        subquery();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:760:18: ( LEFT_PAREN )=> LEFT_PAREN expression_list ( COMMA expression_list )* RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_multi_column_for_loop6460);
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_list_in_multi_column_for_loop6462);
            	        expression_list();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:760:60: ( COMMA expression_list )*

            	        for (;;)
            	        {
            	            int alt236=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt236=1;
            	            	}
            	                break;

            	            }

            	            switch (alt236)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:760:61: COMMA expression_list
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_multi_column_for_loop6465);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemulti_column_for_loopEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_expression_list_in_multi_column_for_loop6467);
            	        	        expression_list();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulemulti_column_for_loopEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop236;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop236: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6471);
            	        if  (this->hasException())
            	        {
            	            goto rulemulti_column_for_loopEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_multi_column_for_loop6495);
            if  (this->hasException())
            {
                goto rulemulti_column_for_loopEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemulti_column_for_loopEx; /* Prevent compiler warnings */
    rulemulti_column_for_loopEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multi_column_for_loop */

/**
 * $ANTLR start multiset_expression
 * PLSQL_DMLParser.g:765:1: multiset_expression : unary_expression ( multiset_op unary_expression )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::multiset_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:766:2: ( unary_expression ( multiset_op unary_expression )* )
        // PLSQL_DMLParser.g:766:4: unary_expression ( multiset_op unary_expression )*
        {
            this->followPush(FOLLOW_unary_expression_in_multiset_expression6509);
            unary_expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemultiset_expressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:767:3: ( multiset_op unary_expression )*

            for (;;)
            {
                int alt238=2;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    int LA238_2 = this->LA(2);
                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "MULTISET"))))
                		    {
                		        alt238=1;
                		    }

                		}
                	}
                    break;

                }

                switch (alt238)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:767:5: multiset_op unary_expression
            	    {
            	        this->followPush(FOLLOW_multiset_op_in_multiset_expression6515);
            	        m_gPLSQLParser->multiset_op();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_unary_expression_in_multiset_expression6517);
            	        unary_expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulemultiset_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop238;	/* break out of the loop */
            	    break;
                }
            }
            loop238: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemultiset_expressionEx; /* Prevent compiler warnings */
    rulemultiset_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end multiset_expression */

/**
 * $ANTLR start unary_expression
 * PLSQL_DMLParser.g:770:1: unary_expression options {backtrack=true; } : ( MINUS_SIGN unary_expression | PLUS_SIGN unary_expression | prior_key unary_expression | connect_by_root_key unary_expression |{...}? => new_key unary_expression | distinct_key unary_expression | all_key unary_expression |{...}? case_statement[false] | quantified_expression | standard_function | atom );
 */
void
PLSQLParser_PLSQL_DMLParser::unary_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:775:5: ( MINUS_SIGN unary_expression | PLUS_SIGN unary_expression | prior_key unary_expression | connect_by_root_key unary_expression |{...}? => new_key unary_expression | distinct_key unary_expression | all_key unary_expression |{...}? case_statement[false] | quantified_expression | standard_function | atom )

            ANTLR_UINT32 alt239;

            alt239=11;

            switch ( this->LA(1) )
            {
            case MINUS_SIGN:
            	{
            		alt239=1;
            	}
                break;
            case PLUS_SIGN:
            	{
            		alt239=2;
            	}
                break;
            case SQL92_RESERVED_PRIOR:
            	{
            		alt239=3;
            	}
                break;
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            	{
            		alt239=4;
            	}
                break;
            case REGULAR_ID:
            	{
            		{
            		    int LA239_5 = this->LA(2);
            		    if ( (( (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (this->msynpred( antlr3::ClassForwarder<synpred36_PLSQL_DMLParser>() )) )) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )))
            		    {
            		        alt239=5;
            		    }
            		    else if ( (( (( LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE )) && (this->msynpred( antlr3::ClassForwarder<synpred39_PLSQL_DMLParser>() )) )))
            		    {
            		        alt239=8;
            		    }
            		    else if ( (( (this->msynpred( antlr3::ClassForwarder<synpred40_PLSQL_DMLParser>() )) && ((equalsIgnoreCase(LT(1)->getText(), "SOME"))) )))
            		    {
            		        alt239=9;
            		    }
            		    else if ( (( ((((equalsIgnoreCase(LT(1)->getText(), "COUNT")))||((equalsIgnoreCase(LT(1)->getText(), "XMLROOT")))||((equalsIgnoreCase(LT(1)->getText(), "LAST_VALUE")))||((equalsIgnoreCase(LT(1)->getText(), "XMLPI")))||((enablesWithinOrOverClause(LT(1)->getText())))||((equalsIgnoreCase(LT(1)->getText(), "XMLSERIALIZE")))||((equalsIgnoreCase(LT(1)->getText(), "XMLCAST")))||((isStandardPredictionFunction(LT(1)->getText())))||((equalsIgnoreCase(LT(1)->getText(), "DECOMPOSE")))||((equalsIgnoreCase(LT(1)->getText(), "COLLECT")))||((equalsIgnoreCase(LT(1)->getText(), "XMLELEMENT")))||((equalsIgnoreCase(LT(1)->getText(), "XMLTABLE")))||((equalsIgnoreCase(LT(1)->getText(), "XMLEXISTS")))||((enablesOverClause(LT(1)->getText())))||((enablesUsingClause(LT(1)->getText())))||((equalsIgnoreCase(LT(1)->getText(), "FIRST_VALUE")))||((equalsIgnoreCase(LT(1)->getText(), "CAST")))||((equalsIgnoreCase(LT(1)->getText(), "EXTRACT")))||((equalsIgnoreCase(LT(1)->getText(), "XMLQUERY")))||((equalsIgnoreCase(LT(1)->getText(), "TREAT")))||((equalsIgnoreCase(LT(1)->getText(), "TRANSLATE")))||((equalsIgnoreCase(LT(1)->getText(), "XMLPARSE")))||((equalsIgnoreCase(LT(1)->getText(), "XMLCOLATTVAL")))||((equalsIgnoreCase(LT(1)->getText(), "TRIM")))||((equalsIgnoreCase(LT(1)->getText(), "XMLAGG")))||((equalsIgnoreCase(LT(1)->getText(), "CHR")))||((equalsIgnoreCase(LT(1)->getText(), "XMLFOREST"))))) && (this->msynpred( antlr3::ClassForwarder<synpred41_PLSQL_DMLParser>() )) )))
            		    {
            		        alt239=10;
            		    }
            		    else if ( (true))
            		    {
            		        alt239=11;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 239 );
            		        ex->set_state( 5 );


            		        goto ruleunary_expressionEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_DISTINCT:
            	{
            		alt239=6;
            	}
                break;
            case SQL92_RESERVED_ALL:
            	{
            		{
            		    int LA239_7 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred38_PLSQL_DMLParser>() )))
            		    {
            		        alt239=7;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred40_PLSQL_DMLParser>() )))
            		    {
            		        alt239=9;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 239 );
            		        ex->set_state( 7 );


            		        goto ruleunary_expressionEx;

            		    }
            		}
            	}
                break;
            case DELIMITED_ID:
            	{
            		{
            		    int LA239_8 = this->LA(2);
            		    if ( (( (( LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE )) && (this->msynpred( antlr3::ClassForwarder<synpred39_PLSQL_DMLParser>() )) )))
            		    {
            		        alt239=8;
            		    }
            		    else if ( (true))
            		    {
            		        alt239=11;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 239 );
            		        ex->set_state( 8 );


            		        goto ruleunary_expressionEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_CASE:
            	{
            		alt239=8;
            	}
                break;
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_EXISTS:
            	{
            		alt239=9;
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case EXACT_NUM_LIT:
            case INTRODUCER:
            case LEFT_PAREN:
            case NATIONAL_CHAR_STRING_LIT:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt239=11;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 239 );
                ex->set_state( 0 );


                goto ruleunary_expressionEx;

            }

            switch (alt239)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:775:10: MINUS_SIGN unary_expression
        	    {
        	         this->matchToken(MINUS_SIGN, &FOLLOW_MINUS_SIGN_in_unary_expression6546);
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_unary_expression_in_unary_expression6548);
        	        unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:776:10: PLUS_SIGN unary_expression
        	    {
        	         this->matchToken(PLUS_SIGN, &FOLLOW_PLUS_SIGN_in_unary_expression6559);
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_unary_expression_in_unary_expression6561);
        	        unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:777:10: prior_key unary_expression
        	    {
        	        this->followPush(FOLLOW_prior_key_in_unary_expression6572);
        	        m_gPLSQLParser->prior_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_unary_expression_in_unary_expression6574);
        	        unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQL_DMLParser.g:778:10: connect_by_root_key unary_expression
        	    {
        	        this->followPush(FOLLOW_connect_by_root_key_in_unary_expression6585);
        	        m_gPLSQLParser->connect_by_root_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_unary_expression_in_unary_expression6587);
        	        unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQL_DMLParser.g:779:10: {...}? => new_key unary_expression
        	    {
        	        if ( !(( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
        	                    equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
        	                 )) )
        	        {
        	            if (this->get_backtracking()>0)
        	            {
        	                this->set_failedflag( true );
        	                return ;
        	            }

        	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), " // input.LT(1).getText().equalsIgnoreCase(\"new\") && !input.LT(2).getText().equals(\".\")}?\n            equalsIgnoreCase(LT(1)->getText(), \"NEW\") && !equalsIgnoreCase(LT(2)->getText(), \".\" )\n         " );
        	                ex->set_ruleName( "unary_expression" );


        	        }

        	        this->followPush(FOLLOW_new_key_in_unary_expression6602);
        	        m_gPLSQLParser->new_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_unary_expression_in_unary_expression6604);
        	        unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // PLSQL_DMLParser.g:782:10: distinct_key unary_expression
        	    {
        	        this->followPush(FOLLOW_distinct_key_in_unary_expression6615);
        	        m_gPLSQLParser->distinct_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_unary_expression_in_unary_expression6617);
        	        unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 7:
        	    // PLSQL_DMLParser.g:783:10: all_key unary_expression
        	    {
        	        this->followPush(FOLLOW_all_key_in_unary_expression6628);
        	        m_gPLSQLParser->all_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_unary_expression_in_unary_expression6630);
        	        unary_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 8:
        	    // PLSQL_DMLParser.g:784:10: {...}? case_statement[false]
        	    {
        	        if ( !(( LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE )) )
        	        {
        	            if (this->get_backtracking()>0)
        	            {
        	                this->set_failedflag( true );
        	                return ;
        	            }

        	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), " LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE " );
        	                ex->set_ruleName( "unary_expression" );


        	        }

        	        this->followPush(FOLLOW_case_statement_in_unary_expression6643);
        	        case_statement(false);

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 9:
        	    // PLSQL_DMLParser.g:785:10: quantified_expression
        	    {
        	        this->followPush(FOLLOW_quantified_expression_in_unary_expression6655);
        	        quantified_expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 10:
        	    // PLSQL_DMLParser.g:786:10: standard_function
        	    {
        	        this->followPush(FOLLOW_standard_function_in_unary_expression6666);
        	        standard_function();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 11:
        	    // PLSQL_DMLParser.g:787:10: atom
        	    {
        	        this->followPush(FOLLOW_atom_in_unary_expression6677);
        	        atom();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleunary_expressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleunary_expressionEx; /* Prevent compiler warnings */
    ruleunary_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unary_expression */

/**
 * $ANTLR start case_statement
 * PLSQL_DMLParser.g:790:1: case_statement[int isStatementParameter] : ( ( ( label_name )? case_key when_key )=> searched_case_statement | simple_case_statement );
 */
void
PLSQLParser_PLSQL_DMLParser::case_statement(int isStatementParameter)
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */
    m_case_statement_stack.push(case_statementScope()); 
    m_case_statement_stack.peek().isStatement = isStatementParameter;

 
    {
        {
            //  PLSQL_DMLParser.g:795:5: ( ( ( label_name )? case_key when_key )=> searched_case_statement | simple_case_statement )

            ANTLR_UINT32 alt240;

            alt240=2;

            switch ( this->LA(1) )
            {
            case DELIMITED_ID:
            case REGULAR_ID:
            	{
            		switch ( this->LA(2) )
            		{
            		case SQL92_RESERVED_CASE:
            			{
            				{
            				    int LA240_2 = this->LA(3);
            				    if ( (this->msynpred( antlr3::ClassForwarder<synpred42_PLSQL_DMLParser>() )) && (LA240_2 == SQL92_RESERVED_WHEN))
            				    {
            				        alt240=1;
            				    }
            				    else if ( (LA240_2 == APPROXIMATE_NUM_LIT || LA240_2 == BINDVAR || ((LA240_2 >= CHAR_STRING) && (LA240_2 <= COLON)) || LA240_2 == DELIMITED_ID || LA240_2 == EXACT_NUM_LIT || LA240_2 == INTRODUCER || LA240_2 == LEFT_PAREN || LA240_2 == NATIONAL_CHAR_STRING_LIT || LA240_2 == REGULAR_ID || LA240_2 == SQL92_RESERVED_DATE || LA240_2 == SQL92_RESERVED_DEFAULT || LA240_2 == SQL92_RESERVED_FALSE || LA240_2 == SQL92_RESERVED_NULL || LA240_2 == SQL92_RESERVED_TRUE || LA240_2 == UNSIGNED_INTEGER))
            				    {
            				        alt240=2;
            				    }
            				    else
            				    {
            				        if (this->get_backtracking()>0)
            				        {
            				            this->set_failedflag( true );
            				            m_case_statement_stack.pop(); 

            				            return ;
            				        }


            				        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            				        ex->set_decisionNum( 240 );
            				        ex->set_state( 2 );


            				        goto rulecase_statementEx;

            				    }
            				}
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        m_case_statement_stack.pop(); 

            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 240 );
            		    ex->set_state( 1 );


            		    goto rulecase_statementEx;

            		}

            	}
                break;
            case SQL92_RESERVED_CASE:
            	{
            		{
            		    int LA240_2 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred42_PLSQL_DMLParser>() )) && (LA240_2 == SQL92_RESERVED_WHEN))
            		    {
            		        alt240=1;
            		    }
            		    else if ( (LA240_2 == APPROXIMATE_NUM_LIT || LA240_2 == BINDVAR || ((LA240_2 >= CHAR_STRING) && (LA240_2 <= COLON)) || LA240_2 == DELIMITED_ID || LA240_2 == EXACT_NUM_LIT || LA240_2 == INTRODUCER || LA240_2 == LEFT_PAREN || LA240_2 == NATIONAL_CHAR_STRING_LIT || LA240_2 == REGULAR_ID || LA240_2 == SQL92_RESERVED_DATE || LA240_2 == SQL92_RESERVED_DEFAULT || LA240_2 == SQL92_RESERVED_FALSE || LA240_2 == SQL92_RESERVED_NULL || LA240_2 == SQL92_RESERVED_TRUE || LA240_2 == UNSIGNED_INTEGER))
            		    {
            		        alt240=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            m_case_statement_stack.pop(); 

            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 240 );
            		        ex->set_state( 2 );


            		        goto rulecase_statementEx;

            		    }
            		}
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    m_case_statement_stack.pop(); 

                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 240 );
                ex->set_state( 0 );


                goto rulecase_statementEx;

            }

            switch (alt240)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:795:10: ( ( label_name )? case_key when_key )=> searched_case_statement
        	    {
        	        this->followPush(FOLLOW_searched_case_statement_in_case_statement6724);
        	        searched_case_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecase_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            m_case_statement_stack.pop(); 

        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:796:10: simple_case_statement
        	    {
        	        this->followPush(FOLLOW_simple_case_statement_in_case_statement6735);
        	        simple_case_statement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecase_statementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            m_case_statement_stack.pop(); 

        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulecase_statementEx; /* Prevent compiler warnings */
    rulecase_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    m_case_statement_stack.pop(); 

    return ;
}
/* $ANTLR end case_statement */

/**
 * $ANTLR start simple_case_statement
 * PLSQL_DMLParser.g:801:1: simple_case_statement : ( label_name )? ck1= case_key atom ( simple_case_when_part )+ ( case_else_part )? end_key ( case_key )? ( label_name )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::simple_case_statement()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:802:5: ( ( label_name )? ck1= case_key atom ( simple_case_when_part )+ ( case_else_part )? end_key ( case_key )? ( label_name )? )
        // PLSQL_DMLParser.g:802:10: ( label_name )? ck1= case_key atom ( simple_case_when_part )+ ( case_else_part )? end_key ( case_key )? ( label_name )?
        {
            // PLSQL_DMLParser.g:802:10: ( label_name )?
            {
                int alt241=2;
                switch ( this->LA(1) )
                {
                    case DELIMITED_ID:
                    case REGULAR_ID:
                    	{
                    		alt241=1;
                    	}
                        break;
                }

                switch (alt241)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:802:10: label_name
            	    {
            	        this->followPush(FOLLOW_label_name_in_simple_case_statement6757);
            	        m_gPLSQLParser->label_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_case_key_in_simple_case_statement6762);
            m_gPLSQLParser->case_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_case_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_atom_in_simple_case_statement6764);
            atom();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_case_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:803:9: ( simple_case_when_part )+
            {
                int cnt242=0;

                for (;;)
                {
                    int alt242=2;
            	switch ( this->LA(1) )
            	{
            	case SQL92_RESERVED_WHEN:
            		{
            			alt242=1;
            		}
            	    break;

            	}

            	switch (alt242)
            	{
            	    case 1:
            	        // PLSQL_DMLParser.g:803:9: simple_case_when_part
            	        {
            	            this->followPush(FOLLOW_simple_case_when_part_in_simple_case_statement6774);
            	            simple_case_when_part();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulesimple_case_statementEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt242 >= 1 )
            		{
            		    goto loop242;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto rulesimple_case_statementEx;
            	}
            	cnt242++;
                }
                loop242: ;	/* Jump to here if this rule does not match */
            }

            // PLSQL_DMLParser.g:804:9: ( case_else_part )?
            {
                int alt243=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_ELSE:
                    	{
                    		alt243=1;
                    	}
                        break;
                }

                switch (alt243)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:804:9: case_else_part
            	    {
            	        this->followPush(FOLLOW_case_else_part_in_simple_case_statement6786);
            	        case_else_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_end_key_in_simple_case_statement6797);
            m_gPLSQLParser->end_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_case_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:805:17: ( case_key )?
            {
                int alt244=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_CASE:
                    	{
                    		alt244=1;
                    	}
                        break;
                }

                switch (alt244)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:805:17: case_key
            	    {
            	        this->followPush(FOLLOW_case_key_in_simple_case_statement6799);
            	        m_gPLSQLParser->case_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:805:27: ( label_name )?
            {
                int alt245=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		alt245=1;
                    	}
                        break;
                    case DELIMITED_ID:
                    	{
                    		alt245=1;
                    	}
                        break;
                }

                switch (alt245)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:805:27: label_name
            	    {
            	        this->followPush(FOLLOW_label_name_in_simple_case_statement6802);
            	        m_gPLSQLParser->label_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesimple_case_statementEx; /* Prevent compiler warnings */
    rulesimple_case_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end simple_case_statement */

/**
 * $ANTLR start simple_case_when_part
 * PLSQL_DMLParser.g:808:1: simple_case_when_part : when_key expression_wrapper then_key ({...}? seq_of_statements | expression_wrapper ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::simple_case_when_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:809:5: ( when_key expression_wrapper then_key ({...}? seq_of_statements | expression_wrapper ) )
        // PLSQL_DMLParser.g:809:10: when_key expression_wrapper then_key ({...}? seq_of_statements | expression_wrapper )
        {
            this->followPush(FOLLOW_when_key_in_simple_case_when_part6823);
            m_gPLSQLParser->when_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_case_when_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_wrapper_in_simple_case_when_part6825);
            expression_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_case_when_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_then_key_in_simple_case_when_part6827);
            m_gPLSQLParser->then_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimple_case_when_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:809:47: ({...}? seq_of_statements | expression_wrapper )
            {
                int alt246=2;
                switch ( this->LA(1) )
                {
                case LESS_THAN_OP:
                case PLSQL_RESERVED_IF:
                case PLSQL_RESERVED_LOCK:
                case SQL92_RESERVED_ALTER:
                case SQL92_RESERVED_BEGIN:
                case SQL92_RESERVED_CREATE:
                case SQL92_RESERVED_DECLARE:
                case SQL92_RESERVED_DELETE:
                case SQL92_RESERVED_FETCH:
                case SQL92_RESERVED_FOR:
                case SQL92_RESERVED_GOTO:
                case SQL92_RESERVED_GRANT:
                case SQL92_RESERVED_INSERT:
                case SQL92_RESERVED_PROCEDURE:
                case SQL92_RESERVED_SELECT:
                case SQL92_RESERVED_UPDATE:
                case SQL92_RESERVED_WITH:
                	{
                		alt246=1;
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    int LA246_4 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt246=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt246=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 246 );
                		        ex->set_state( 4 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case INTRODUCER:
                	{
                		{
                		    int LA246_7 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt246=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt246=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 246 );
                		        ex->set_state( 7 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case DELIMITED_ID:
                	{
                		{
                		    int LA246_8 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt246=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt246=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 246 );
                		        ex->set_state( 8 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case BINDVAR:
                	{
                		{
                		    int LA246_9 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt246=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt246=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 246 );
                		        ex->set_state( 9 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case COLON:
                	{
                		{
                		    int LA246_10 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt246=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt246=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 246 );
                		        ex->set_state( 10 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_CURSOR:
                	{
                		{
                		    int LA246_11 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt246=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt246=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 246 );
                		        ex->set_state( 11 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_NULL:
                	{
                		{
                		    int LA246_16 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt246=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt246=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 246 );
                		        ex->set_state( 16 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_CASE:
                	{
                		{
                		    int LA246_17 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt246=1;
                		    }
                		    else if ( (( LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE )))
                		    {
                		        alt246=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 246 );
                		        ex->set_state( 17 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case LEFT_PAREN:
                	{
                		{
                		    int LA246_21 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt246=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt246=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 246 );
                		        ex->set_state( 21 );


                		        goto rulesimple_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case EXACT_NUM_LIT:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt246=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 246 );
                    ex->set_state( 0 );


                    goto rulesimple_case_when_partEx;

                }

                switch (alt246)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:809:48: {...}? seq_of_statements
            	    {
            	        if ( !((m_case_statement_stack.peek().isStatement)) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return ;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "$case_statement::isStatement" );
            	                ex->set_ruleName( "simple_case_when_part" );


            	        }

            	        this->followPush(FOLLOW_seq_of_statements_in_simple_case_when_part6832);
            	        m_gPLSQLParser->seq_of_statements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_case_when_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:809:100: expression_wrapper
            	    {
            	        this->followPush(FOLLOW_expression_wrapper_in_simple_case_when_part6836);
            	        expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesimple_case_when_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesimple_case_when_partEx; /* Prevent compiler warnings */
    rulesimple_case_when_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end simple_case_when_part */

/**
 * $ANTLR start searched_case_statement
 * PLSQL_DMLParser.g:812:1: searched_case_statement : ( label_name )? ck1= case_key ( searched_case_when_part )+ ( case_else_part )? end_key ( case_key )? ( label_name )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::searched_case_statement()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:813:5: ( ( label_name )? ck1= case_key ( searched_case_when_part )+ ( case_else_part )? end_key ( case_key )? ( label_name )? )
        // PLSQL_DMLParser.g:813:10: ( label_name )? ck1= case_key ( searched_case_when_part )+ ( case_else_part )? end_key ( case_key )? ( label_name )?
        {
            // PLSQL_DMLParser.g:813:10: ( label_name )?
            {
                int alt247=2;
                switch ( this->LA(1) )
                {
                    case DELIMITED_ID:
                    case REGULAR_ID:
                    	{
                    		alt247=1;
                    	}
                        break;
                }

                switch (alt247)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:813:10: label_name
            	    {
            	        this->followPush(FOLLOW_label_name_in_searched_case_statement6857);
            	        m_gPLSQLParser->label_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearched_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_case_key_in_searched_case_statement6862);
            m_gPLSQLParser->case_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearched_case_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:814:9: ( searched_case_when_part )+
            {
                int cnt248=0;

                for (;;)
                {
                    int alt248=2;
            	switch ( this->LA(1) )
            	{
            	case SQL92_RESERVED_WHEN:
            		{
            			alt248=1;
            		}
            	    break;

            	}

            	switch (alt248)
            	{
            	    case 1:
            	        // PLSQL_DMLParser.g:814:9: searched_case_when_part
            	        {
            	            this->followPush(FOLLOW_searched_case_when_part_in_searched_case_statement6872);
            	            searched_case_when_part();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto rulesearched_case_statementEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt248 >= 1 )
            		{
            		    goto loop248;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto rulesearched_case_statementEx;
            	}
            	cnt248++;
                }
                loop248: ;	/* Jump to here if this rule does not match */
            }

            // PLSQL_DMLParser.g:815:9: ( case_else_part )?
            {
                int alt249=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_ELSE:
                    	{
                    		alt249=1;
                    	}
                        break;
                }

                switch (alt249)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:815:9: case_else_part
            	    {
            	        this->followPush(FOLLOW_case_else_part_in_searched_case_statement6883);
            	        case_else_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearched_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_end_key_in_searched_case_statement6894);
            m_gPLSQLParser->end_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearched_case_statementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:816:17: ( case_key )?
            {
                int alt250=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_CASE:
                    	{
                    		alt250=1;
                    	}
                        break;
                }

                switch (alt250)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:816:17: case_key
            	    {
            	        this->followPush(FOLLOW_case_key_in_searched_case_statement6896);
            	        m_gPLSQLParser->case_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearched_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:816:27: ( label_name )?
            {
                int alt251=2;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		alt251=1;
                    	}
                        break;
                    case DELIMITED_ID:
                    	{
                    		alt251=1;
                    	}
                        break;
                }

                switch (alt251)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:816:27: label_name
            	    {
            	        this->followPush(FOLLOW_label_name_in_searched_case_statement6899);
            	        m_gPLSQLParser->label_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearched_case_statementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesearched_case_statementEx; /* Prevent compiler warnings */
    rulesearched_case_statementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end searched_case_statement */

/**
 * $ANTLR start searched_case_when_part
 * PLSQL_DMLParser.g:819:1: searched_case_when_part : when_key condition_wrapper then_key ({...}? seq_of_statements | expression_wrapper ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::searched_case_when_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:820:5: ( when_key condition_wrapper then_key ({...}? seq_of_statements | expression_wrapper ) )
        // PLSQL_DMLParser.g:820:10: when_key condition_wrapper then_key ({...}? seq_of_statements | expression_wrapper )
        {
            this->followPush(FOLLOW_when_key_in_searched_case_when_part6920);
            m_gPLSQLParser->when_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearched_case_when_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_condition_wrapper_in_searched_case_when_part6922);
            condition_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearched_case_when_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_then_key_in_searched_case_when_part6924);
            m_gPLSQLParser->then_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesearched_case_when_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:820:46: ({...}? seq_of_statements | expression_wrapper )
            {
                int alt252=2;
                switch ( this->LA(1) )
                {
                case LESS_THAN_OP:
                case PLSQL_RESERVED_IF:
                case PLSQL_RESERVED_LOCK:
                case SQL92_RESERVED_ALTER:
                case SQL92_RESERVED_BEGIN:
                case SQL92_RESERVED_CREATE:
                case SQL92_RESERVED_DECLARE:
                case SQL92_RESERVED_DELETE:
                case SQL92_RESERVED_FETCH:
                case SQL92_RESERVED_FOR:
                case SQL92_RESERVED_GOTO:
                case SQL92_RESERVED_GRANT:
                case SQL92_RESERVED_INSERT:
                case SQL92_RESERVED_PROCEDURE:
                case SQL92_RESERVED_SELECT:
                case SQL92_RESERVED_UPDATE:
                case SQL92_RESERVED_WITH:
                	{
                		alt252=1;
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    int LA252_4 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt252=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt252=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 252 );
                		        ex->set_state( 4 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case INTRODUCER:
                	{
                		{
                		    int LA252_7 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt252=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt252=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 252 );
                		        ex->set_state( 7 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case DELIMITED_ID:
                	{
                		{
                		    int LA252_8 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt252=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt252=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 252 );
                		        ex->set_state( 8 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case BINDVAR:
                	{
                		{
                		    int LA252_9 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt252=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt252=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 252 );
                		        ex->set_state( 9 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case COLON:
                	{
                		{
                		    int LA252_10 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt252=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt252=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 252 );
                		        ex->set_state( 10 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_CURSOR:
                	{
                		{
                		    int LA252_11 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt252=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt252=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 252 );
                		        ex->set_state( 11 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_NULL:
                	{
                		{
                		    int LA252_16 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt252=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt252=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 252 );
                		        ex->set_state( 16 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_CASE:
                	{
                		{
                		    int LA252_17 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt252=1;
                		    }
                		    else if ( (( LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE )))
                		    {
                		        alt252=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 252 );
                		        ex->set_state( 17 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case LEFT_PAREN:
                	{
                		{
                		    int LA252_21 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt252=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt252=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 252 );
                		        ex->set_state( 21 );


                		        goto rulesearched_case_when_partEx;

                		    }
                		}
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case EXACT_NUM_LIT:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt252=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 252 );
                    ex->set_state( 0 );


                    goto rulesearched_case_when_partEx;

                }

                switch (alt252)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:820:47: {...}? seq_of_statements
            	    {
            	        if ( !((m_case_statement_stack.peek().isStatement)) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return ;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "$case_statement::isStatement" );
            	                ex->set_ruleName( "searched_case_when_part" );


            	        }

            	        this->followPush(FOLLOW_seq_of_statements_in_searched_case_when_part6929);
            	        m_gPLSQLParser->seq_of_statements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearched_case_when_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:820:99: expression_wrapper
            	    {
            	        this->followPush(FOLLOW_expression_wrapper_in_searched_case_when_part6933);
            	        expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesearched_case_when_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulesearched_case_when_partEx; /* Prevent compiler warnings */
    rulesearched_case_when_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end searched_case_when_part */

/**
 * $ANTLR start case_else_part
 * PLSQL_DMLParser.g:823:1: case_else_part : else_key ({...}? seq_of_statements | expression_wrapper ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::case_else_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:824:5: ( else_key ({...}? seq_of_statements | expression_wrapper ) )
        // PLSQL_DMLParser.g:824:10: else_key ({...}? seq_of_statements | expression_wrapper )
        {
            this->followPush(FOLLOW_else_key_in_case_else_part6954);
            m_gPLSQLParser->else_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecase_else_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:824:19: ({...}? seq_of_statements | expression_wrapper )
            {
                int alt253=2;
                switch ( this->LA(1) )
                {
                case LESS_THAN_OP:
                case PLSQL_RESERVED_IF:
                case PLSQL_RESERVED_LOCK:
                case SQL92_RESERVED_ALTER:
                case SQL92_RESERVED_BEGIN:
                case SQL92_RESERVED_CREATE:
                case SQL92_RESERVED_DECLARE:
                case SQL92_RESERVED_DELETE:
                case SQL92_RESERVED_FETCH:
                case SQL92_RESERVED_FOR:
                case SQL92_RESERVED_GOTO:
                case SQL92_RESERVED_GRANT:
                case SQL92_RESERVED_INSERT:
                case SQL92_RESERVED_PROCEDURE:
                case SQL92_RESERVED_SELECT:
                case SQL92_RESERVED_UPDATE:
                case SQL92_RESERVED_WITH:
                	{
                		alt253=1;
                	}
                    break;
                case REGULAR_ID:
                	{
                		{
                		    int LA253_4 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt253=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt253=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 253 );
                		        ex->set_state( 4 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case INTRODUCER:
                	{
                		{
                		    int LA253_7 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt253=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt253=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 253 );
                		        ex->set_state( 7 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case DELIMITED_ID:
                	{
                		{
                		    int LA253_8 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt253=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt253=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 253 );
                		        ex->set_state( 8 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case BINDVAR:
                	{
                		{
                		    int LA253_9 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt253=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt253=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 253 );
                		        ex->set_state( 9 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case COLON:
                	{
                		{
                		    int LA253_10 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt253=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt253=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 253 );
                		        ex->set_state( 10 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_CURSOR:
                	{
                		{
                		    int LA253_11 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt253=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt253=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 253 );
                		        ex->set_state( 11 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_NULL:
                	{
                		{
                		    int LA253_16 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt253=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt253=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 253 );
                		        ex->set_state( 16 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case SQL92_RESERVED_CASE:
                	{
                		{
                		    int LA253_17 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt253=1;
                		    }
                		    else if ( (( LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE )))
                		    {
                		        alt253=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 253 );
                		        ex->set_state( 17 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case LEFT_PAREN:
                	{
                		{
                		    int LA253_21 = this->LA(2);
                		    if ( ((m_case_statement_stack.peek().isStatement)))
                		    {
                		        alt253=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt253=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 253 );
                		        ex->set_state( 21 );


                		        goto rulecase_else_partEx;

                		    }
                		}
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case EXACT_NUM_LIT:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt253=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 253 );
                    ex->set_state( 0 );


                    goto rulecase_else_partEx;

                }

                switch (alt253)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:824:20: {...}? seq_of_statements
            	    {
            	        if ( !((m_case_statement_stack.peek().isStatement)) )
            	        {
            	            if (this->get_backtracking()>0)
            	            {
            	                this->set_failedflag( true );
            	                return ;
            	            }

            	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "$case_statement::isStatement" );
            	                ex->set_ruleName( "case_else_part" );


            	        }

            	        this->followPush(FOLLOW_seq_of_statements_in_case_else_part6959);
            	        m_gPLSQLParser->seq_of_statements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecase_else_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:824:72: expression_wrapper
            	    {
            	        this->followPush(FOLLOW_expression_wrapper_in_case_else_part6963);
            	        expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecase_else_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulecase_else_partEx; /* Prevent compiler warnings */
    rulecase_else_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end case_else_part */

/**
 * $ANTLR start atom
 * PLSQL_DMLParser.g:828:1: atom options {backtrack=true; } : ( ( table_element outer_join_sign )=> table_element outer_join_sign | bind_variable | constant | general_element | LEFT_PAREN ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN ) );
 */
void
PLSQLParser_PLSQL_DMLParser::atom()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:833:5: ( ( table_element outer_join_sign )=> table_element outer_join_sign | bind_variable | constant | general_element | LEFT_PAREN ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN ) )

            ANTLR_UINT32 alt256;

            alt256=5;

            alt256 = cdfa256.predict(this, this->get_rec(), this->get_istream(), cdfa256 );
            if  (this->hasException())
            {
                goto ruleatomEx;
            }
            if (this->hasFailed())
            {
                return ;
            }

            switch (alt256)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:833:10: ( table_element outer_join_sign )=> table_element outer_join_sign
        	    {
        	        this->followPush(FOLLOW_table_element_in_atom7002);
        	        m_gPLSQLParser->table_element();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_outer_join_sign_in_atom7004);
        	        m_gPLSQLParser->outer_join_sign();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:834:10: bind_variable
        	    {
        	        this->followPush(FOLLOW_bind_variable_in_atom7015);
        	        m_gPLSQLParser->bind_variable();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:835:10: constant
        	    {
        	        this->followPush(FOLLOW_constant_in_atom7026);
        	        m_gPLSQLParser->constant();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // PLSQL_DMLParser.g:836:10: general_element
        	    {
        	        this->followPush(FOLLOW_general_element_in_atom7037);
        	        m_gPLSQLParser->general_element();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQL_DMLParser.g:837:10: LEFT_PAREN ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN )
        	    {
        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_atom7048);
        	        if  (this->hasException())
        	        {
        	            goto ruleatomEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:838:10: ( ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )* | expression_or_vector RIGHT_PAREN )
        	        {
        	            int alt255=2;
        	            {
        	                int LA255_0 = this->LA(1);
        	                if ( (this->msynpred( antlr3::ClassForwarder<synpred47_PLSQL_DMLParser>() )) && (LA255_0 == SQL92_RESERVED_SELECT))
        	                {
        	                    alt255=1;
        	                }
        	                else if ( (LA255_0 == LEFT_PAREN))
        	                {
        	                    {
        	                        int LA255_2 = this->LA(2);
        	                        if ( (this->msynpred( antlr3::ClassForwarder<synpred47_PLSQL_DMLParser>() )))
        	                        {
        	                            alt255=1;
        	                        }
        	                        else if ( (true))
        	                        {
        	                            alt255=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 255 );
        	                            ex->set_state( 2 );


        	                            goto ruleatomEx;

        	                        }
        	                    }
        	                }
        	                else if ( (LA255_0 == APPROXIMATE_NUM_LIT || LA255_0 == BINDVAR || ((LA255_0 >= CHAR_STRING) && (LA255_0 <= COLON)) || LA255_0 == DELIMITED_ID || LA255_0 == EXACT_NUM_LIT || LA255_0 == INTRODUCER || ((LA255_0 >= MINUS_SIGN) && (LA255_0 <= NATIONAL_CHAR_STRING_LIT)) || LA255_0 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA255_0 == PLUS_SIGN || LA255_0 == REGULAR_ID || LA255_0 == SQL92_RESERVED_ALL || LA255_0 == SQL92_RESERVED_ANY || LA255_0 == SQL92_RESERVED_CASE || ((LA255_0 >= SQL92_RESERVED_CURSOR) && (LA255_0 <= SQL92_RESERVED_DATE)) || LA255_0 == SQL92_RESERVED_DEFAULT || LA255_0 == SQL92_RESERVED_DISTINCT || ((LA255_0 >= SQL92_RESERVED_EXISTS) && (LA255_0 <= SQL92_RESERVED_FALSE)) || ((LA255_0 >= SQL92_RESERVED_NOT) && (LA255_0 <= SQL92_RESERVED_NULL)) || LA255_0 == SQL92_RESERVED_PRIOR || LA255_0 == SQL92_RESERVED_TRUE || LA255_0 == UNSIGNED_INTEGER))
        	                {
        	                    alt255=2;
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 255 );
        	                    ex->set_state( 0 );


        	                    goto ruleatomEx;

        	                }
        	            }
        	            switch (alt255)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:839:15: ( select_key | with_key )=> subquery RIGHT_PAREN ( subquery_operation_part )*
        	        	    {
        	        	        this->followPush(FOLLOW_subquery_in_atom7085);
        	        	        subquery();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_atom7087);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQL_DMLParser.g:839:63: ( subquery_operation_part )*

        	        	        for (;;)
        	        	        {
        	        	            int alt254=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	            case SQL92_RESERVED_UNION:
        	        	            	{
        	        	            		alt254=1;
        	        	            	}
        	        	                break;
        	        	            case SQL92_RESERVED_INTERSECT:
        	        	            	{
        	        	            		alt254=1;
        	        	            	}
        	        	                break;
        	        	            case PLSQL_RESERVED_MINUS:
        	        	            	{
        	        	            		alt254=1;
        	        	            	}
        	        	                break;

        	        	            }

        	        	            switch (alt254)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:839:63: subquery_operation_part
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_subquery_operation_part_in_atom7089);
        	        	        	        subquery_operation_part();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto ruleatomEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	        	default:
        	        	        	    goto loop254;	/* break out of the loop */
        	        	        	    break;
        	        	            }
        	        	        }
        	        	        loop254: ; /* Jump out to here if this rule does not match */


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:840:17: expression_or_vector RIGHT_PAREN
        	        	    {
        	        	        this->followPush(FOLLOW_expression_or_vector_in_atom7108);
        	        	        expression_or_vector();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_atom7110);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleatomEx; /* Prevent compiler warnings */
    ruleatomEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end atom */

/**
 * $ANTLR start expression_or_vector
 * PLSQL_DMLParser.g:844:1: expression_or_vector : expression ( vector_expr )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::expression_or_vector()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:845:5: ( expression ( vector_expr )? )
        // PLSQL_DMLParser.g:845:10: expression ( vector_expr )?
        {
            this->followPush(FOLLOW_expression_in_expression_or_vector7141);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexpression_or_vectorEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:845:21: ( vector_expr )?
            {
                int alt257=2;
                switch ( this->LA(1) )
                {
                    case COMMA:
                    	{
                    		alt257=1;
                    	}
                        break;
                }

                switch (alt257)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:845:22: vector_expr
            	    {
            	        this->followPush(FOLLOW_vector_expr_in_expression_or_vector7144);
            	        vector_expr();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleexpression_or_vectorEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexpression_or_vectorEx; /* Prevent compiler warnings */
    ruleexpression_or_vectorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end expression_or_vector */

/**
 * $ANTLR start vector_expr
 * PLSQL_DMLParser.g:848:1: vector_expr : COMMA expression ( COMMA expression )* ;
 */
void
PLSQLParser_PLSQL_DMLParser::vector_expr()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:849:5: ( COMMA expression ( COMMA expression )* )
        // PLSQL_DMLParser.g:849:10: COMMA expression ( COMMA expression )*
        {
             this->matchToken(COMMA, &FOLLOW_COMMA_in_vector_expr7166);
            if  (this->hasException())
            {
                goto rulevector_exprEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_vector_expr7168);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulevector_exprEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:849:27: ( COMMA expression )*

            for (;;)
            {
                int alt258=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt258=1;
                	}
                    break;

                }

                switch (alt258)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:849:28: COMMA expression
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_vector_expr7171);
            	        if  (this->hasException())
            	        {
            	            goto rulevector_exprEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_vector_expr7173);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulevector_exprEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop258;	/* break out of the loop */
            	    break;
                }
            }
            loop258: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulevector_exprEx; /* Prevent compiler warnings */
    rulevector_exprEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end vector_expr */

/**
 * $ANTLR start quantified_expression
 * PLSQL_DMLParser.g:852:1: quantified_expression : ( some_key | exists_key | all_key | any_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression_wrapper RIGHT_PAREN ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::quantified_expression()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:853:5: ( ( some_key | exists_key | all_key | any_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression_wrapper RIGHT_PAREN ) )
        // PLSQL_DMLParser.g:853:10: ( some_key | exists_key | all_key | any_key ) ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression_wrapper RIGHT_PAREN )
        {
            // PLSQL_DMLParser.g:853:10: ( some_key | exists_key | all_key | any_key )
            {
                int alt259=4;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		alt259=1;
                	}
                    break;
                case SQL92_RESERVED_EXISTS:
                	{
                		alt259=2;
                	}
                    break;
                case SQL92_RESERVED_ALL:
                	{
                		alt259=3;
                	}
                    break;
                case SQL92_RESERVED_ANY:
                	{
                		alt259=4;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 259 );
                    ex->set_state( 0 );


                    goto rulequantified_expressionEx;

                }

                switch (alt259)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:853:12: some_key
            	    {
            	        this->followPush(FOLLOW_some_key_in_quantified_expression7197);
            	        m_gPLSQLParser->some_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:853:23: exists_key
            	    {
            	        this->followPush(FOLLOW_exists_key_in_quantified_expression7201);
            	        m_gPLSQLParser->exists_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // PLSQL_DMLParser.g:853:36: all_key
            	    {
            	        this->followPush(FOLLOW_all_key_in_quantified_expression7205);
            	        m_gPLSQLParser->all_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 4:
            	    // PLSQL_DMLParser.g:853:46: any_key
            	    {
            	        this->followPush(FOLLOW_any_key_in_quantified_expression7209);
            	        m_gPLSQLParser->any_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:854:10: ( ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN | LEFT_PAREN expression_wrapper RIGHT_PAREN )
            {
                int alt260=2;
                switch ( this->LA(1) )
                {
                case LEFT_PAREN:
                	{
                		{
                		    int LA260_1 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred48_PLSQL_DMLParser>() )))
                		    {
                		        alt260=1;
                		    }
                		    else if ( (true))
                		    {
                		        alt260=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 260 );
                		        ex->set_state( 1 );


                		        goto rulequantified_expressionEx;

                		    }
                		}
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 260 );
                    ex->set_state( 0 );


                    goto rulequantified_expressionEx;

                }

                switch (alt260)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:854:12: ( LEFT_PAREN ( select_key | with_key ) )=> LEFT_PAREN subquery RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_quantified_expression7236);
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_subquery_in_quantified_expression7238);
            	        subquery();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_quantified_expression7240);
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:855:14: LEFT_PAREN expression_wrapper RIGHT_PAREN
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_quantified_expression7255);
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_wrapper_in_quantified_expression7257);
            	        expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_quantified_expression7259);
            	        if  (this->hasException())
            	        {
            	            goto rulequantified_expressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulequantified_expressionEx; /* Prevent compiler warnings */
    rulequantified_expressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end quantified_expression */

/**
 * $ANTLR start standard_function
 * PLSQL_DMLParser.g:859:1: standard_function : ( stantard_function_enabling_over function_argument_analytic ( over_clause )? | stantard_function_enabling_using function_argument_modeling ( using_clause )? | count_key LEFT_PAREN ( ASTERISK | ( distinct_key | unique_key | all_key )? concatenation_wrapper ) RIGHT_PAREN ( over_clause )? | ( cast_key | xmlcast_key ) LEFT_PAREN ( ( multiset_key ( LEFT_PAREN )+ ( select_key | with_key ) )=> multiset_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( as_key type_spec )? | concatenation_wrapper as_key type_spec ) RIGHT_PAREN | chr_key LEFT_PAREN concatenation_wrapper using_key nchar_cs_key RIGHT_PAREN | collect_key LEFT_PAREN ( distinct_key | unique_key )? concatenation_wrapper ( collect_order_by_part )? RIGHT_PAREN | stantard_function_enabling_within_or_over function_argument ( within_or_over_part )+ | decompose_key LEFT_PAREN concatenation_wrapper ( canonical_key | compatibility_key )? RIGHT_PAREN | extract_key LEFT_PAREN REGULAR_ID from_key concatenation_wrapper RIGHT_PAREN | ( first_value_key | last_value_key ) function_argument_analytic ( respect_or_ignore_nulls )? over_clause | stantard_function_pedictions LEFT_PAREN expression_wrapper ( COMMA expression_wrapper )* ( cost_matrix_clause )? ( using_clause )? RIGHT_PAREN | translate_key LEFT_PAREN expression_wrapper ( using_key ( char_cs_key | nchar_cs_key ) )? ( COMMA expression_wrapper )* RIGHT_PAREN | treat_key LEFT_PAREN expression_wrapper as_key ( ref_key )? type_spec RIGHT_PAREN | trim_key LEFT_PAREN ( ( leading_key | trailing_key | both_key )? ( quoted_string )? from_key )? concatenation_wrapper RIGHT_PAREN | xmlagg_key LEFT_PAREN expression_wrapper ( order_by_clause )? RIGHT_PAREN ( PERIOD general_element_part )? | ( xmlcolattval_key | xmlforest_key ) LEFT_PAREN xml_multiuse_expression_element ( COMMA xml_multiuse_expression_element )* RIGHT_PAREN ( PERIOD general_element_part )? | xmlelement_key LEFT_PAREN ( entityescaping_key | noentityescaping_key )? ( name_key | evalname_key )? expression_wrapper ({...}? COMMA xml_attributes_clause )? ( COMMA expression_wrapper ( column_alias )? )* RIGHT_PAREN ( PERIOD general_element_part )? | xmlexists_key LEFT_PAREN expression_wrapper ( xml_passing_clause )? RIGHT_PAREN | xmlparse_key LEFT_PAREN ( document_key | content_key ) concatenation_wrapper ( wellformed_key )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlpi_key LEFT_PAREN ( name_key id | evalname_key concatenation_wrapper ) ( COMMA concatenation_wrapper )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlquery_key LEFT_PAREN concatenation_wrapper ( xml_passing_clause )? returning_key content_key ( null_key on_key empty_key )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlroot_key LEFT_PAREN concatenation_wrapper xmlroot_param_version_part ( COMMA xmlroot_param_standalone_part )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlserialize_key LEFT_PAREN ( document_key | content_key ) concatenation_wrapper ( as_key type_spec )? ( xmlserialize_param_enconding_part )? ( xmlserialize_param_version_part )? ( xmlserialize_param_ident_part )? ( ( hide_key | show_key ) defaults_key )? RIGHT_PAREN ( PERIOD general_element_part )? | xmltable_key LEFT_PAREN ( xml_namespaces_clause )? concatenation_wrapper ( xml_passing_clause )? ( columns_key xml_table_column ( COMMA xml_table_column ) )? RIGHT_PAREN ( PERIOD general_element_part )? );
 */
void
PLSQLParser_PLSQL_DMLParser::standard_function()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:860:5: ( stantard_function_enabling_over function_argument_analytic ( over_clause )? | stantard_function_enabling_using function_argument_modeling ( using_clause )? | count_key LEFT_PAREN ( ASTERISK | ( distinct_key | unique_key | all_key )? concatenation_wrapper ) RIGHT_PAREN ( over_clause )? | ( cast_key | xmlcast_key ) LEFT_PAREN ( ( multiset_key ( LEFT_PAREN )+ ( select_key | with_key ) )=> multiset_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( as_key type_spec )? | concatenation_wrapper as_key type_spec ) RIGHT_PAREN | chr_key LEFT_PAREN concatenation_wrapper using_key nchar_cs_key RIGHT_PAREN | collect_key LEFT_PAREN ( distinct_key | unique_key )? concatenation_wrapper ( collect_order_by_part )? RIGHT_PAREN | stantard_function_enabling_within_or_over function_argument ( within_or_over_part )+ | decompose_key LEFT_PAREN concatenation_wrapper ( canonical_key | compatibility_key )? RIGHT_PAREN | extract_key LEFT_PAREN REGULAR_ID from_key concatenation_wrapper RIGHT_PAREN | ( first_value_key | last_value_key ) function_argument_analytic ( respect_or_ignore_nulls )? over_clause | stantard_function_pedictions LEFT_PAREN expression_wrapper ( COMMA expression_wrapper )* ( cost_matrix_clause )? ( using_clause )? RIGHT_PAREN | translate_key LEFT_PAREN expression_wrapper ( using_key ( char_cs_key | nchar_cs_key ) )? ( COMMA expression_wrapper )* RIGHT_PAREN | treat_key LEFT_PAREN expression_wrapper as_key ( ref_key )? type_spec RIGHT_PAREN | trim_key LEFT_PAREN ( ( leading_key | trailing_key | both_key )? ( quoted_string )? from_key )? concatenation_wrapper RIGHT_PAREN | xmlagg_key LEFT_PAREN expression_wrapper ( order_by_clause )? RIGHT_PAREN ( PERIOD general_element_part )? | ( xmlcolattval_key | xmlforest_key ) LEFT_PAREN xml_multiuse_expression_element ( COMMA xml_multiuse_expression_element )* RIGHT_PAREN ( PERIOD general_element_part )? | xmlelement_key LEFT_PAREN ( entityescaping_key | noentityescaping_key )? ( name_key | evalname_key )? expression_wrapper ({...}? COMMA xml_attributes_clause )? ( COMMA expression_wrapper ( column_alias )? )* RIGHT_PAREN ( PERIOD general_element_part )? | xmlexists_key LEFT_PAREN expression_wrapper ( xml_passing_clause )? RIGHT_PAREN | xmlparse_key LEFT_PAREN ( document_key | content_key ) concatenation_wrapper ( wellformed_key )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlpi_key LEFT_PAREN ( name_key id | evalname_key concatenation_wrapper ) ( COMMA concatenation_wrapper )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlquery_key LEFT_PAREN concatenation_wrapper ( xml_passing_clause )? returning_key content_key ( null_key on_key empty_key )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlroot_key LEFT_PAREN concatenation_wrapper xmlroot_param_version_part ( COMMA xmlroot_param_standalone_part )? RIGHT_PAREN ( PERIOD general_element_part )? | xmlserialize_key LEFT_PAREN ( document_key | content_key ) concatenation_wrapper ( as_key type_spec )? ( xmlserialize_param_enconding_part )? ( xmlserialize_param_version_part )? ( xmlserialize_param_ident_part )? ( ( hide_key | show_key ) defaults_key )? RIGHT_PAREN ( PERIOD general_element_part )? | xmltable_key LEFT_PAREN ( xml_namespaces_clause )? concatenation_wrapper ( xml_passing_clause )? ( columns_key xml_table_column ( COMMA xml_table_column ) )? RIGHT_PAREN ( PERIOD general_element_part )? )

            ANTLR_UINT32 alt321;

            alt321=24;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    int LA321_1 = this->LA(2);
            		    if ( ((enablesOverClause(LT(1)->getText()))))
            		    {
            		        alt321=1;
            		    }
            		    else if ( ((enablesUsingClause(LT(1)->getText()))))
            		    {
            		        alt321=2;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "COUNT"))))
            		    {
            		        alt321=3;
            		    }
            		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "CAST")))||((equalsIgnoreCase(LT(1)->getText(), "XMLCAST"))))))
            		    {
            		        alt321=4;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "CHR"))))
            		    {
            		        alt321=5;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "COLLECT"))))
            		    {
            		        alt321=6;
            		    }
            		    else if ( ((enablesWithinOrOverClause(LT(1)->getText()))))
            		    {
            		        alt321=7;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "DECOMPOSE"))))
            		    {
            		        alt321=8;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "EXTRACT"))))
            		    {
            		        alt321=9;
            		    }
            		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "FIRST_VALUE")))||((equalsIgnoreCase(LT(1)->getText(), "LAST_VALUE"))))))
            		    {
            		        alt321=10;
            		    }
            		    else if ( ((isStandardPredictionFunction(LT(1)->getText()))))
            		    {
            		        alt321=11;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "TRANSLATE"))))
            		    {
            		        alt321=12;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "TREAT"))))
            		    {
            		        alt321=13;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "TRIM"))))
            		    {
            		        alt321=14;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLAGG"))))
            		    {
            		        alt321=15;
            		    }
            		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "XMLFOREST")))||((equalsIgnoreCase(LT(1)->getText(), "XMLCOLATTVAL"))))))
            		    {
            		        alt321=16;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLELEMENT"))))
            		    {
            		        alt321=17;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLEXISTS"))))
            		    {
            		        alt321=18;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLPARSE"))))
            		    {
            		        alt321=19;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLPI"))))
            		    {
            		        alt321=20;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLQUERY"))))
            		    {
            		        alt321=21;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLROOT"))))
            		    {
            		        alt321=22;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLSERIALIZE"))))
            		    {
            		        alt321=23;
            		    }
            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLTABLE"))))
            		    {
            		        alt321=24;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 321 );
            		        ex->set_state( 1 );


            		        goto rulestandard_functionEx;

            		    }
            		}
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 321 );
                ex->set_state( 0 );


                goto rulestandard_functionEx;

            }

            switch (alt321)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:860:10: stantard_function_enabling_over function_argument_analytic ( over_clause )?
        	    {
        	        this->followPush(FOLLOW_stantard_function_enabling_over_in_standard_function7290);
        	        stantard_function_enabling_over();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_function_argument_analytic_in_standard_function7292);
        	        m_gPLSQLParser->function_argument_analytic();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:860:69: ( over_clause )?
        	        {
        	            int alt261=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		switch ( this->LA(2) )
        	                		{
        	                		    case LEFT_PAREN:
        	                		    	{
        	                		    		{
        	                		    		    int LA261_3 = this->LA(3);
        	                		    		    if ( (LA261_3 == REGULAR_ID))
        	                		    		    {
        	                		    		        {
        	                		    		            int LA261_11 = this->LA(4);
        	                		    		            if ( ((equalsIgnoreCase(LT(1)->getText(), "OVER"))) && (LA261_11 == SQL92_RESERVED_BY))
        	                		    		            {
        	                		    		                alt261=1;
        	                		    		            }
        	                		    		        }
        	                		    		    }
        	                		    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "OVER"))) && (LA261_3 == RIGHT_PAREN || LA261_3 == SQL92_RESERVED_ORDER))
        	                		    		    {
        	                		    		        alt261=1;
        	                		    		    }
        	                		    		}
        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt261)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:860:69: over_clause
        	        	    {
        	        	        this->followPush(FOLLOW_over_clause_in_standard_function7294);
        	        	        over_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:861:10: stantard_function_enabling_using function_argument_modeling ( using_clause )?
        	    {
        	        this->followPush(FOLLOW_stantard_function_enabling_using_in_standard_function7306);
        	        stantard_function_enabling_using();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_function_argument_modeling_in_standard_function7308);
        	        m_gPLSQLParser->function_argument_modeling();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:861:70: ( using_clause )?
        	        {
        	            int alt262=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PLSQL_NON_RESERVED_USING:
        	                	{
        	                		alt262=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt262)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:861:70: using_clause
        	        	    {
        	        	        this->followPush(FOLLOW_using_clause_in_standard_function7310);
        	        	        using_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:862:10: count_key LEFT_PAREN ( ASTERISK | ( distinct_key | unique_key | all_key )? concatenation_wrapper ) RIGHT_PAREN ( over_clause )?
        	    {
        	        this->followPush(FOLLOW_count_key_in_standard_function7322);
        	        m_gPLSQLParser->count_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function7336);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:864:17: ( ASTERISK | ( distinct_key | unique_key | all_key )? concatenation_wrapper )
        	        {
        	            int alt264=2;
        	            switch ( this->LA(1) )
        	            {
        	            case ASTERISK:
        	            	{
        	            		alt264=1;
        	            	}
        	                break;
        	            case APPROXIMATE_NUM_LIT:
        	            case BINDVAR:
        	            case CHAR_STRING:
        	            case CHAR_STRING_PERL:
        	            case COLON:
        	            case DELIMITED_ID:
        	            case EXACT_NUM_LIT:
        	            case INTRODUCER:
        	            case LEFT_PAREN:
        	            case MINUS_SIGN:
        	            case NATIONAL_CHAR_STRING_LIT:
        	            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
        	            case PLUS_SIGN:
        	            case REGULAR_ID:
        	            case SQL92_RESERVED_ALL:
        	            case SQL92_RESERVED_ANY:
        	            case SQL92_RESERVED_CASE:
        	            case SQL92_RESERVED_DATE:
        	            case SQL92_RESERVED_DEFAULT:
        	            case SQL92_RESERVED_DISTINCT:
        	            case SQL92_RESERVED_EXISTS:
        	            case SQL92_RESERVED_FALSE:
        	            case SQL92_RESERVED_NULL:
        	            case SQL92_RESERVED_PRIOR:
        	            case SQL92_RESERVED_TRUE:
        	            case SQL92_RESERVED_UNIQUE:
        	            case UNSIGNED_INTEGER:
        	            	{
        	            		alt264=2;
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return ;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 264 );
        	                ex->set_state( 0 );


        	                goto rulestandard_functionEx;

        	            }

        	            switch (alt264)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:864:19: ASTERISK
        	        	    {
        	        	         this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_standard_function7356);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:864:30: ( distinct_key | unique_key | all_key )? concatenation_wrapper
        	        	    {
        	        	        // PLSQL_DMLParser.g:864:30: ( distinct_key | unique_key | all_key )?
        	        	        {
        	        	            int alt263=4;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case SQL92_RESERVED_DISTINCT:
        	        	                	{
        	        	                		alt263=1;
        	        	                	}
        	        	                    break;
        	        	                case SQL92_RESERVED_UNIQUE:
        	        	                	{
        	        	                		alt263=2;
        	        	                	}
        	        	                    break;
        	        	                case SQL92_RESERVED_ALL:
        	        	                	{
        	        	                		alt263=3;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt263)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:864:31: distinct_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_distinct_key_in_standard_function7361);
        	        	        	        m_gPLSQLParser->distinct_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // PLSQL_DMLParser.g:864:44: unique_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_unique_key_in_standard_function7363);
        	        	        	        m_gPLSQLParser->unique_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 3:
        	        	        	    // PLSQL_DMLParser.g:864:55: all_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_all_key_in_standard_function7365);
        	        	        	        m_gPLSQLParser->all_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function7369);
        	        	        concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function7385);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:865:25: ( over_clause )?
        	        {
        	            int alt265=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		switch ( this->LA(2) )
        	                		{
        	                		    case LEFT_PAREN:
        	                		    	{
        	                		    		{
        	                		    		    int LA265_3 = this->LA(3);
        	                		    		    if ( (LA265_3 == REGULAR_ID))
        	                		    		    {
        	                		    		        {
        	                		    		            int LA265_11 = this->LA(4);
        	                		    		            if ( ((equalsIgnoreCase(LT(1)->getText(), "OVER"))) && (LA265_11 == SQL92_RESERVED_BY))
        	                		    		            {
        	                		    		                alt265=1;
        	                		    		            }
        	                		    		        }
        	                		    		    }
        	                		    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "OVER"))) && (LA265_3 == RIGHT_PAREN || LA265_3 == SQL92_RESERVED_ORDER))
        	                		    		    {
        	                		    		        alt265=1;
        	                		    		    }
        	                		    		}
        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt265)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:865:25: over_clause
        	        	    {
        	        	        this->followPush(FOLLOW_over_clause_in_standard_function7387);
        	        	        over_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 4:
        	    // PLSQL_DMLParser.g:866:10: ( cast_key | xmlcast_key ) LEFT_PAREN ( ( multiset_key ( LEFT_PAREN )+ ( select_key | with_key ) )=> multiset_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( as_key type_spec )? | concatenation_wrapper as_key type_spec ) RIGHT_PAREN
        	    {
        	        // PLSQL_DMLParser.g:866:10: ( cast_key | xmlcast_key )
        	        {
        	            int alt266=2;
        	            switch ( this->LA(1) )
        	            {
        	            case REGULAR_ID:
        	            	{
        	            		{
        	            		    int LA266_1 = this->LA(2);
        	            		    if ( ((equalsIgnoreCase(LT(1)->getText(), "CAST"))))
        	            		    {
        	            		        alt266=1;
        	            		    }
        	            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLCAST"))))
        	            		    {
        	            		        alt266=2;
        	            		    }
        	            		    else
        	            		    {
        	            		        if (this->get_backtracking()>0)
        	            		        {
        	            		            this->set_failedflag( true );
        	            		            return ;
        	            		        }


        	            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            		        ex->set_decisionNum( 266 );
        	            		        ex->set_state( 1 );


        	            		        goto rulestandard_functionEx;

        	            		    }
        	            		}
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return ;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 266 );
        	                ex->set_state( 0 );


        	                goto rulestandard_functionEx;

        	            }

        	            switch (alt266)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:866:11: cast_key
        	        	    {
        	        	        this->followPush(FOLLOW_cast_key_in_standard_function7400);
        	        	        m_gPLSQLParser->cast_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:866:20: xmlcast_key
        	        	    {
        	        	        this->followPush(FOLLOW_xmlcast_key_in_standard_function7402);
        	        	        m_gPLSQLParser->xmlcast_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function7418);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:868:10: ( ( multiset_key ( LEFT_PAREN )+ ( select_key | with_key ) )=> multiset_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( as_key type_spec )? | concatenation_wrapper as_key type_spec )
        	        {
        	            int alt269=2;
        	            switch ( this->LA(1) )
        	            {
        	            case REGULAR_ID:
        	            	{
        	            		{
        	            		    int LA269_1 = this->LA(2);
        	            		    if ( (( ((equalsIgnoreCase(LT(1)->getText(), "MULTISET"))) && (this->msynpred( antlr3::ClassForwarder<synpred49_PLSQL_DMLParser>() )) )))
        	            		    {
        	            		        alt269=1;
        	            		    }
        	            		    else if ( (true))
        	            		    {
        	            		        alt269=2;
        	            		    }
        	            		    else
        	            		    {
        	            		        if (this->get_backtracking()>0)
        	            		        {
        	            		            this->set_failedflag( true );
        	            		            return ;
        	            		        }


        	            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	            		        ex->set_decisionNum( 269 );
        	            		        ex->set_state( 1 );


        	            		        goto rulestandard_functionEx;

        	            		    }
        	            		}
        	            	}
        	                break;
        	            case APPROXIMATE_NUM_LIT:
        	            case BINDVAR:
        	            case CHAR_STRING:
        	            case CHAR_STRING_PERL:
        	            case COLON:
        	            case DELIMITED_ID:
        	            case EXACT_NUM_LIT:
        	            case INTRODUCER:
        	            case LEFT_PAREN:
        	            case MINUS_SIGN:
        	            case NATIONAL_CHAR_STRING_LIT:
        	            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
        	            case PLUS_SIGN:
        	            case SQL92_RESERVED_ALL:
        	            case SQL92_RESERVED_ANY:
        	            case SQL92_RESERVED_CASE:
        	            case SQL92_RESERVED_DATE:
        	            case SQL92_RESERVED_DEFAULT:
        	            case SQL92_RESERVED_DISTINCT:
        	            case SQL92_RESERVED_EXISTS:
        	            case SQL92_RESERVED_FALSE:
        	            case SQL92_RESERVED_NULL:
        	            case SQL92_RESERVED_PRIOR:
        	            case SQL92_RESERVED_TRUE:
        	            case UNSIGNED_INTEGER:
        	            	{
        	            		alt269=2;
        	            	}
        	                break;

        	            default:
        	                if (this->get_backtracking()>0)
        	                {
        	                    this->set_failedflag( true );
        	                    return ;
        	                }

        	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                ex->set_decisionNum( 269 );
        	                ex->set_state( 0 );


        	                goto rulestandard_functionEx;

        	            }

        	            switch (alt269)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:868:12: ( multiset_key ( LEFT_PAREN )+ ( select_key | with_key ) )=> multiset_key LEFT_PAREN subquery ( order_by_clause )? RIGHT_PAREN ( as_key type_spec )?
        	        	    {
        	        	        this->followPush(FOLLOW_multiset_key_in_standard_function7446);
        	        	        m_gPLSQLParser->multiset_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function7448);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_subquery_in_standard_function7450);
        	        	        subquery();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQL_DMLParser.g:868:97: ( order_by_clause )?
        	        	        {
        	        	            int alt267=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case SQL92_RESERVED_ORDER:
        	        	                	{
        	        	                		alt267=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt267)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:868:97: order_by_clause
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_order_by_clause_in_standard_function7452);
        	        	        	        order_by_clause();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function7455);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQL_DMLParser.g:869:12: ( as_key type_spec )?
        	        	        {
        	        	            int alt268=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case SQL92_RESERVED_AS:
        	        	                	{
        	        	                		alt268=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt268)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:869:13: as_key type_spec
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_as_key_in_standard_function7469);
        	        	        	        m_gPLSQLParser->as_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	        this->followPush(FOLLOW_type_spec_in_standard_function7471);
        	        	        	        m_gPLSQLParser->type_spec();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:870:19: concatenation_wrapper as_key type_spec
        	        	    {
        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function7493);
        	        	        concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_as_key_in_standard_function7495);
        	        	        m_gPLSQLParser->as_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_type_spec_in_standard_function7497);
        	        	        m_gPLSQLParser->type_spec();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function7529);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // PLSQL_DMLParser.g:873:10: chr_key LEFT_PAREN concatenation_wrapper using_key nchar_cs_key RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_chr_key_in_standard_function7540);
        	        m_gPLSQLParser->chr_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function7554);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function7573);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_using_key_in_standard_function7575);
        	        m_gPLSQLParser->using_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_nchar_cs_key_in_standard_function7577);
        	        m_gPLSQLParser->nchar_cs_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function7592);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // PLSQL_DMLParser.g:877:10: collect_key LEFT_PAREN ( distinct_key | unique_key )? concatenation_wrapper ( collect_order_by_part )? RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_collect_key_in_standard_function7603);
        	        m_gPLSQLParser->collect_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function7617);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:879:17: ( distinct_key | unique_key )?
        	        {
        	            int alt270=3;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_DISTINCT:
        	                	{
        	                		alt270=1;
        	                	}
        	                    break;
        	                case SQL92_RESERVED_UNIQUE:
        	                	{
        	                		alt270=2;
        	                	}
        	                    break;
        	            }

        	            switch (alt270)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:879:18: distinct_key
        	        	    {
        	        	        this->followPush(FOLLOW_distinct_key_in_standard_function7637);
        	        	        m_gPLSQLParser->distinct_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:879:31: unique_key
        	        	    {
        	        	        this->followPush(FOLLOW_unique_key_in_standard_function7639);
        	        	        m_gPLSQLParser->unique_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function7643);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:879:66: ( collect_order_by_part )?
        	        {
        	            int alt271=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_ORDER:
        	                	{
        	                		alt271=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt271)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:879:66: collect_order_by_part
        	        	    {
        	        	        this->followPush(FOLLOW_collect_order_by_part_in_standard_function7645);
        	        	        collect_order_by_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function7660);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 7:
        	    // PLSQL_DMLParser.g:881:10: stantard_function_enabling_within_or_over function_argument ( within_or_over_part )+
        	    {
        	        this->followPush(FOLLOW_stantard_function_enabling_within_or_over_in_standard_function7671);
        	        stantard_function_enabling_within_or_over();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_function_argument_in_standard_function7686);
        	        m_gPLSQLParser->function_argument();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:882:31: ( within_or_over_part )+
        	        {
        	            int cnt272=0;

        	            for (;;)
        	            {
        	                int alt272=2;
        	        	switch ( this->LA(1) )
        	        	{
        	        	case REGULAR_ID:
        	        		{
        	        			switch ( this->LA(2) )
        	        			{
        	        			case LEFT_PAREN:
        	        				{
        	        					{
        	        					   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	        					    */
        	        					    int LA272_3 = this->LA(3);
        	        					    if ( (LA272_3 == REGULAR_ID))
        	        					    {
        	        					        {
        	        					           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	        					            */
        	        					            int LA272_13 = this->LA(4);
        	        					            if ( ((equalsIgnoreCase(LT(1)->getText(), "OVER"))) && (LA272_13 == SQL92_RESERVED_BY))
        	        					            {
        	        					                alt272=1;
        	        					            }

        	        					        }
        	        					    }
        	        					    else if ( ((equalsIgnoreCase(LT(1)->getText(), "OVER"))) && (LA272_3 == RIGHT_PAREN || LA272_3 == SQL92_RESERVED_ORDER))
        	        					    {
        	        					        alt272=1;
        	        					    }

        	        					}
        	        				}
        	        			    break;
        	        			case SQL92_RESERVED_GROUP:
        	        				{
        	        					{
        	        					   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	        					    */
        	        					    int LA272_4 = this->LA(3);
        	        					    if ( ((equalsIgnoreCase(LT(1)->getText(), "WITHIN"))) && (LA272_4 == LEFT_PAREN))
        	        					    {
        	        					        alt272=1;
        	        					    }

        	        					}
        	        				}
        	        			    break;

        	        			}

        	        		}
        	        	    break;

        	        	}

        	        	switch (alt272)
        	        	{
        	        	    case 1:
        	        	        // PLSQL_DMLParser.g:882:31: within_or_over_part
        	        	        {
        	        	            this->followPush(FOLLOW_within_or_over_part_in_standard_function7688);
        	        	            within_or_over_part();

        	        	            this->followPop();
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulestandard_functionEx;
        	        	            }
        	        	            if (this->hasFailed())
        	        	            {
        	        	                return ;
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt272 >= 1 )
        	        		{
        	        		    goto loop272;
        	        		}
        	        		if (this->get_backtracking()>0)
        	        		{
        	        		    this->set_failedflag( true );
        	        		    return ;
        	        		}

        	        		/* mismatchedSetEx()
        	        		 */
        	        		new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        	        		goto rulestandard_functionEx;
        	        	}
        	        	cnt272++;
        	            }
        	            loop272: ;	/* Jump to here if this rule does not match */
        	        }

        	    }
        	    break;
        	case 8:
        	    // PLSQL_DMLParser.g:883:10: decompose_key LEFT_PAREN concatenation_wrapper ( canonical_key | compatibility_key )? RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_decompose_key_in_standard_function7700);
        	        m_gPLSQLParser->decompose_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function7714);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function7733);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:885:39: ( canonical_key | compatibility_key )?
        	        {
        	            int alt273=3;
        	            {
        	                int LA273_0 = this->LA(1);
        	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "COMPATIBILITY")))||((equalsIgnoreCase(LT(1)->getText(), "CANONICAL"))))) && (LA273_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA273_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "CANONICAL"))))
        	                        {
        	                            alt273=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "COMPATIBILITY"))))
        	                        {
        	                            alt273=2;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt273)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:885:40: canonical_key
        	        	    {
        	        	        this->followPush(FOLLOW_canonical_key_in_standard_function7736);
        	        	        m_gPLSQLParser->canonical_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:885:54: compatibility_key
        	        	    {
        	        	        this->followPush(FOLLOW_compatibility_key_in_standard_function7738);
        	        	        m_gPLSQLParser->compatibility_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function7755);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 9:
        	    // PLSQL_DMLParser.g:887:10: extract_key LEFT_PAREN REGULAR_ID from_key concatenation_wrapper RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_extract_key_in_standard_function7766);
        	        m_gPLSQLParser->extract_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function7780);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_standard_function7798);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_from_key_in_standard_function7800);
        	        m_gPLSQLParser->from_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function7802);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function7817);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 10:
        	    // PLSQL_DMLParser.g:891:10: ( first_value_key | last_value_key ) function_argument_analytic ( respect_or_ignore_nulls )? over_clause
        	    {
        	        // PLSQL_DMLParser.g:891:10: ( first_value_key | last_value_key )
        	        {
        	            int alt274=2;
        	            {
        	                int LA274_0 = this->LA(1);
        	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "FIRST_VALUE")))||((equalsIgnoreCase(LT(1)->getText(), "LAST_VALUE"))))) && (LA274_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA274_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "FIRST_VALUE"))))
        	                        {
        	                            alt274=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "LAST_VALUE"))))
        	                        {
        	                            alt274=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 274 );
        	                            ex->set_state( 1 );


        	                            goto rulestandard_functionEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 274 );
        	                    ex->set_state( 0 );


        	                    goto rulestandard_functionEx;

        	                }
        	            }
        	            switch (alt274)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:891:11: first_value_key
        	        	    {
        	        	        this->followPush(FOLLOW_first_value_key_in_standard_function7829);
        	        	        m_gPLSQLParser->first_value_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:891:27: last_value_key
        	        	    {
        	        	        this->followPush(FOLLOW_last_value_key_in_standard_function7831);
        	        	        m_gPLSQLParser->last_value_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_function_argument_analytic_in_standard_function7834);
        	        m_gPLSQLParser->function_argument_analytic();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:892:14: ( respect_or_ignore_nulls )?
        	        {
        	            int alt275=2;
        	            {
        	                int LA275_0 = this->LA(1);
        	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "OVER")))||((equalsIgnoreCase(LT(1)->getText(), "RESPECT"))))) && (LA275_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA275_1 = this->LA(2);
        	                        if ( ((((equalsIgnoreCase(LT(1)->getText(), "IGNORE")))||((equalsIgnoreCase(LT(1)->getText(), "RESPECT"))))) && (LA275_1 == REGULAR_ID))
        	                        {
        	                            alt275=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt275)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:892:14: respect_or_ignore_nulls
        	        	    {
        	        	        this->followPush(FOLLOW_respect_or_ignore_nulls_in_standard_function7849);
        	        	        m_gPLSQLParser->respect_or_ignore_nulls();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_over_clause_in_standard_function7852);
        	        over_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 11:
        	    // PLSQL_DMLParser.g:893:10: stantard_function_pedictions LEFT_PAREN expression_wrapper ( COMMA expression_wrapper )* ( cost_matrix_clause )? ( using_clause )? RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_stantard_function_pedictions_in_standard_function7863);
        	        stantard_function_pedictions();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function7877);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function7895);
        	        expression_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:895:36: ( COMMA expression_wrapper )*

        	        for (;;)
        	        {
        	            int alt276=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt276=1;
        	            	}
        	                break;

        	            }

        	            switch (alt276)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:895:37: COMMA expression_wrapper
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function7898);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function7900);
        	        	        expression_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop276;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop276: ; /* Jump out to here if this rule does not match */


        	        // PLSQL_DMLParser.g:895:64: ( cost_matrix_clause )?
        	        {
        	            int alt277=2;
        	            {
        	                int LA277_0 = this->LA(1);
        	                if ( ((equalsIgnoreCase(LT(1)->getText(), "COST"))) && (LA277_0 == REGULAR_ID))
        	                {
        	                    alt277=1;
        	                }
        	            }
        	            switch (alt277)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:895:64: cost_matrix_clause
        	        	    {
        	        	        this->followPush(FOLLOW_cost_matrix_clause_in_standard_function7904);
        	        	        cost_matrix_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:895:84: ( using_clause )?
        	        {
        	            int alt278=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PLSQL_NON_RESERVED_USING:
        	                	{
        	                		alt278=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt278)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:895:84: using_clause
        	        	    {
        	        	        this->followPush(FOLLOW_using_clause_in_standard_function7907);
        	        	        using_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function7923);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 12:
        	    // PLSQL_DMLParser.g:897:10: translate_key LEFT_PAREN expression_wrapper ( using_key ( char_cs_key | nchar_cs_key ) )? ( COMMA expression_wrapper )* RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_translate_key_in_standard_function7934);
        	        m_gPLSQLParser->translate_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function7948);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function7967);
        	        expression_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:899:36: ( using_key ( char_cs_key | nchar_cs_key ) )?
        	        {
        	            int alt280=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PLSQL_NON_RESERVED_USING:
        	                	{
        	                		alt280=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt280)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:899:37: using_key ( char_cs_key | nchar_cs_key )
        	        	    {
        	        	        this->followPush(FOLLOW_using_key_in_standard_function7970);
        	        	        m_gPLSQLParser->using_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQL_DMLParser.g:899:47: ( char_cs_key | nchar_cs_key )
        	        	        {
        	        	            int alt279=2;
        	        	            {
        	        	                int LA279_0 = this->LA(1);
        	        	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "CHAR_CS")))||((equalsIgnoreCase(LT(1)->getText(), "NCHAR_CS"))))) && (LA279_0 == REGULAR_ID))
        	        	                {
        	        	                    {
        	        	                        int LA279_1 = this->LA(2);
        	        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "CHAR_CS"))))
        	        	                        {
        	        	                            alt279=1;
        	        	                        }
        	        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "NCHAR_CS"))))
        	        	                        {
        	        	                            alt279=2;
        	        	                        }
        	        	                        else
        	        	                        {
        	        	                            if (this->get_backtracking()>0)
        	        	                            {
        	        	                                this->set_failedflag( true );
        	        	                                return ;
        	        	                            }


        	        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                            ex->set_decisionNum( 279 );
        	        	                            ex->set_state( 1 );


        	        	                            goto rulestandard_functionEx;

        	        	                        }
        	        	                    }
        	        	                }
        	        	                else
        	        	                {
        	        	                    if (this->get_backtracking()>0)
        	        	                    {
        	        	                        this->set_failedflag( true );
        	        	                        return ;
        	        	                    }


        	        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                    ex->set_decisionNum( 279 );
        	        	                    ex->set_state( 0 );


        	        	                    goto rulestandard_functionEx;

        	        	                }
        	        	            }
        	        	            switch (alt279)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:899:48: char_cs_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_char_cs_key_in_standard_function7973);
        	        	        	        m_gPLSQLParser->char_cs_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // PLSQL_DMLParser.g:899:60: nchar_cs_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_nchar_cs_key_in_standard_function7975);
        	        	        	        m_gPLSQLParser->nchar_cs_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:900:21: ( COMMA expression_wrapper )*

        	        for (;;)
        	        {
        	            int alt281=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt281=1;
        	            	}
        	                break;

        	            }

        	            switch (alt281)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:900:22: COMMA expression_wrapper
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function8002);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function8004);
        	        	        expression_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop281;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop281: ; /* Jump out to here if this rule does not match */


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8021);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 13:
        	    // PLSQL_DMLParser.g:902:10: treat_key LEFT_PAREN expression_wrapper as_key ( ref_key )? type_spec RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_treat_key_in_standard_function8032);
        	        m_gPLSQLParser->treat_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8046);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function8064);
        	        expression_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_as_key_in_standard_function8066);
        	        m_gPLSQLParser->as_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:904:43: ( ref_key )?
        	        {
        	            int alt282=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    int LA282_1 = this->LA(2);
        	                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "REF"))))
        	                		    {
        	                		        alt282=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt282)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:904:43: ref_key
        	        	    {
        	        	        this->followPush(FOLLOW_ref_key_in_standard_function8068);
        	        	        m_gPLSQLParser->ref_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_type_spec_in_standard_function8071);
        	        m_gPLSQLParser->type_spec();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8086);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 14:
        	    // PLSQL_DMLParser.g:906:10: trim_key LEFT_PAREN ( ( leading_key | trailing_key | both_key )? ( quoted_string )? from_key )? concatenation_wrapper RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_trim_key_in_standard_function8097);
        	        m_gPLSQLParser->trim_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8111);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:908:17: ( ( leading_key | trailing_key | both_key )? ( quoted_string )? from_key )?
        	        {
        	            int alt285=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		switch ( this->LA(2) )
        	                		{
        	                		    case CHAR_STRING:
        	                		    case CHAR_STRING_PERL:
        	                		    case NATIONAL_CHAR_STRING_LIT:
        	                		    	{
        	                		    		switch ( this->LA(3) )
        	                		    		{
        	                		    		    case SQL92_RESERVED_FROM:
        	                		    		    	{
        	                		    		    		alt285=1;
        	                		    		    	}
        	                		    		        break;
        	                		    		}

        	                		    	}
        	                		        break;
        	                		    case SQL92_RESERVED_FROM:
        	                		    	{
        	                		    		alt285=1;
        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	                case CHAR_STRING:
        	                case CHAR_STRING_PERL:
        	                case NATIONAL_CHAR_STRING_LIT:
        	                	{
        	                		switch ( this->LA(2) )
        	                		{
        	                		    case SQL92_RESERVED_FROM:
        	                		    	{
        	                		    		alt285=1;
        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	                case SQL92_RESERVED_FROM:
        	                	{
        	                		alt285=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt285)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:908:18: ( leading_key | trailing_key | both_key )? ( quoted_string )? from_key
        	        	    {
        	        	        // PLSQL_DMLParser.g:908:18: ( leading_key | trailing_key | both_key )?
        	        	        {
        	        	            int alt283=4;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case REGULAR_ID:
        	        	                	{
        	        	                		{
        	        	                		    int LA283_1 = this->LA(2);
        	        	                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "LEADING"))))
        	        	                		    {
        	        	                		        alt283=1;
        	        	                		    }
        	        	                		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "TRAILING"))))
        	        	                		    {
        	        	                		        alt283=2;
        	        	                		    }
        	        	                		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "BOTH"))))
        	        	                		    {
        	        	                		        alt283=3;
        	        	                		    }
        	        	                		}
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt283)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:908:19: leading_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_leading_key_in_standard_function8132);
        	        	        	        m_gPLSQLParser->leading_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // PLSQL_DMLParser.g:908:31: trailing_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_trailing_key_in_standard_function8134);
        	        	        	        m_gPLSQLParser->trailing_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 3:
        	        	        	    // PLSQL_DMLParser.g:908:44: both_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_both_key_in_standard_function8136);
        	        	        	        m_gPLSQLParser->both_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        // PLSQL_DMLParser.g:908:55: ( quoted_string )?
        	        	        {
        	        	            int alt284=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case CHAR_STRING:
        	        	                case CHAR_STRING_PERL:
        	        	                case NATIONAL_CHAR_STRING_LIT:
        	        	                	{
        	        	                		alt284=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt284)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:908:55: quoted_string
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_quoted_string_in_standard_function8140);
        	        	        	        m_gPLSQLParser->quoted_string();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        this->followPush(FOLLOW_from_key_in_standard_function8143);
        	        	        m_gPLSQLParser->from_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function8163);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8177);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 15:
        	    // PLSQL_DMLParser.g:911:10: xmlagg_key LEFT_PAREN expression_wrapper ( order_by_clause )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        this->followPush(FOLLOW_xmlagg_key_in_standard_function8188);
        	        m_gPLSQLParser->xmlagg_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8202);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function8221);
        	        expression_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:913:36: ( order_by_clause )?
        	        {
        	            int alt286=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_ORDER:
        	                	{
        	                		alt286=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt286)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:913:36: order_by_clause
        	        	    {
        	        	        this->followPush(FOLLOW_order_by_clause_in_standard_function8223);
        	        	        order_by_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8239);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:915:13: ( PERIOD general_element_part )?
        	        {
        	            int alt287=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PERIOD:
        	                	{
        	                		alt287=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt287)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:915:14: PERIOD general_element_part
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function8254);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function8256);
        	        	        m_gPLSQLParser->general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 16:
        	    // PLSQL_DMLParser.g:916:10: ( xmlcolattval_key | xmlforest_key ) LEFT_PAREN xml_multiuse_expression_element ( COMMA xml_multiuse_expression_element )* RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        // PLSQL_DMLParser.g:916:10: ( xmlcolattval_key | xmlforest_key )
        	        {
        	            int alt288=2;
        	            {
        	                int LA288_0 = this->LA(1);
        	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "XMLFOREST")))||((equalsIgnoreCase(LT(1)->getText(), "XMLCOLATTVAL"))))) && (LA288_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA288_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLCOLATTVAL"))))
        	                        {
        	                            alt288=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLFOREST"))))
        	                        {
        	                            alt288=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 288 );
        	                            ex->set_state( 1 );


        	                            goto rulestandard_functionEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 288 );
        	                    ex->set_state( 0 );


        	                    goto rulestandard_functionEx;

        	                }
        	            }
        	            switch (alt288)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:916:11: xmlcolattval_key
        	        	    {
        	        	        this->followPush(FOLLOW_xmlcolattval_key_in_standard_function8270);
        	        	        m_gPLSQLParser->xmlcolattval_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:916:28: xmlforest_key
        	        	    {
        	        	        this->followPush(FOLLOW_xmlforest_key_in_standard_function8272);
        	        	        m_gPLSQLParser->xmlforest_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8288);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_xml_multiuse_expression_element_in_standard_function8306);
        	        xml_multiuse_expression_element();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:918:49: ( COMMA xml_multiuse_expression_element )*

        	        for (;;)
        	        {
        	            int alt289=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt289=1;
        	            	}
        	                break;

        	            }

        	            switch (alt289)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:918:50: COMMA xml_multiuse_expression_element
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function8309);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_xml_multiuse_expression_element_in_standard_function8311);
        	        	        xml_multiuse_expression_element();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop289;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop289: ; /* Jump out to here if this rule does not match */


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8327);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:920:13: ( PERIOD general_element_part )?
        	        {
        	            int alt290=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PERIOD:
        	                	{
        	                		alt290=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt290)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:920:14: PERIOD general_element_part
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function8342);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function8344);
        	        	        m_gPLSQLParser->general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 17:
        	    // PLSQL_DMLParser.g:921:10: xmlelement_key LEFT_PAREN ( entityescaping_key | noentityescaping_key )? ( name_key | evalname_key )? expression_wrapper ({...}? COMMA xml_attributes_clause )? ( COMMA expression_wrapper ( column_alias )? )* RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        this->followPush(FOLLOW_xmlelement_key_in_standard_function8357);
        	        m_gPLSQLParser->xmlelement_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8371);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:923:17: ( entityescaping_key | noentityescaping_key )?
        	        {
        	            int alt291=3;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    int LA291_1 = this->LA(2);
        	                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "ENTITYESCAPING"))))
        	                		    {
        	                		        alt291=1;
        	                		    }
        	                		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "NOENTITYESCAPING"))))
        	                		    {
        	                		        alt291=2;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt291)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:923:18: entityescaping_key
        	        	    {
        	        	        this->followPush(FOLLOW_entityescaping_key_in_standard_function8390);
        	        	        m_gPLSQLParser->entityescaping_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:923:37: noentityescaping_key
        	        	    {
        	        	        this->followPush(FOLLOW_noentityescaping_key_in_standard_function8392);
        	        	        m_gPLSQLParser->noentityescaping_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:924:17: ( name_key | evalname_key )?
        	        {
        	            int alt292=3;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    int LA292_1 = this->LA(2);
        	                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "NAME"))))
        	                		    {
        	                		        alt292=1;
        	                		    }
        	                		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "EVALNAME"))))
        	                		    {
        	                		        alt292=2;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt292)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:924:18: name_key
        	        	    {
        	        	        this->followPush(FOLLOW_name_key_in_standard_function8413);
        	        	        m_gPLSQLParser->name_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:924:27: evalname_key
        	        	    {
        	        	        this->followPush(FOLLOW_evalname_key_in_standard_function8415);
        	        	        m_gPLSQLParser->evalname_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function8419);
        	        expression_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:925:17: ({...}? COMMA xml_attributes_clause )?
        	        {
        	            int alt293=2;
        	            switch ( this->LA(1) )
        	            {
        	                case COMMA:
        	                	{
        	                		{
        	                		    int LA293_1 = this->LA(2);
        	                		    if ( ((equalsIgnoreCase(LT(2)->getText(), "XMLATTRIBUTES"))))
        	                		    {
        	                		        alt293=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt293)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:925:18: {...}? COMMA xml_attributes_clause
        	        	    {
        	        	        if ( !((equalsIgnoreCase(LT(2)->getText(), "XMLATTRIBUTES"))) )
        	        	        {
        	        	            if (this->get_backtracking()>0)
        	        	            {
        	        	                this->set_failedflag( true );
        	        	                return ;
        	        	            }

        	        	            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "equalsIgnoreCase(LT(2)->getText(), \"XMLATTRIBUTES\")" );
        	        	                ex->set_ruleName( "standard_function" );


        	        	        }

        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function8440);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_xml_attributes_clause_in_standard_function8442);
        	        	        xml_attributes_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:926:17: ( COMMA expression_wrapper ( column_alias )? )*

        	        for (;;)
        	        {
        	            int alt295=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt295=1;
        	            	}
        	                break;

        	            }

        	            switch (alt295)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:926:18: COMMA expression_wrapper ( column_alias )?
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function8463);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function8465);
        	        	        expression_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQL_DMLParser.g:926:43: ( column_alias )?
        	        	        {
        	        	            int alt294=2;
        	        	            switch ( this->LA(1) )
        	        	            {
        	        	                case CHAR_STRING:
        	        	                case CHAR_STRING_PERL:
        	        	                case DELIMITED_ID:
        	        	                case INTRODUCER:
        	        	                case NATIONAL_CHAR_STRING_LIT:
        	        	                case REGULAR_ID:
        	        	                case SQL92_RESERVED_AS:
        	        	                	{
        	        	                		alt294=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt294)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:926:43: column_alias
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_column_alias_in_standard_function8467);
        	        	        	        m_gPLSQLParser->column_alias();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop295;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop295: ; /* Jump out to here if this rule does not match */


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8484);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:928:13: ( PERIOD general_element_part )?
        	        {
        	            int alt296=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PERIOD:
        	                	{
        	                		alt296=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt296)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:928:14: PERIOD general_element_part
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function8499);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function8501);
        	        	        m_gPLSQLParser->general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 18:
        	    // PLSQL_DMLParser.g:929:10: xmlexists_key LEFT_PAREN expression_wrapper ( xml_passing_clause )? RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_xmlexists_key_in_standard_function8514);
        	        m_gPLSQLParser->xmlexists_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8528);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_wrapper_in_standard_function8546);
        	        expression_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:932:17: ( xml_passing_clause )?
        	        {
        	            int alt297=2;
        	            {
        	                int LA297_0 = this->LA(1);
        	                if ( ((equalsIgnoreCase(LT(1)->getText(), "PASSING"))) && (LA297_0 == REGULAR_ID))
        	                {
        	                    alt297=1;
        	                }
        	            }
        	            switch (alt297)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:932:17: xml_passing_clause
        	        	    {
        	        	        this->followPush(FOLLOW_xml_passing_clause_in_standard_function8564);
        	        	        xml_passing_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8579);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 19:
        	    // PLSQL_DMLParser.g:934:10: xmlparse_key LEFT_PAREN ( document_key | content_key ) concatenation_wrapper ( wellformed_key )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        this->followPush(FOLLOW_xmlparse_key_in_standard_function8590);
        	        m_gPLSQLParser->xmlparse_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8604);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:936:17: ( document_key | content_key )
        	        {
        	            int alt298=2;
        	            {
        	                int LA298_0 = this->LA(1);
        	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "DOCUMENT")))||((equalsIgnoreCase(LT(1)->getText(), "CONTENT"))))) && (LA298_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA298_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "DOCUMENT"))))
        	                        {
        	                            alt298=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "CONTENT"))))
        	                        {
        	                            alt298=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 298 );
        	                            ex->set_state( 1 );


        	                            goto rulestandard_functionEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 298 );
        	                    ex->set_state( 0 );


        	                    goto rulestandard_functionEx;

        	                }
        	            }
        	            switch (alt298)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:936:18: document_key
        	        	    {
        	        	        this->followPush(FOLLOW_document_key_in_standard_function8624);
        	        	        m_gPLSQLParser->document_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:936:31: content_key
        	        	    {
        	        	        this->followPush(FOLLOW_content_key_in_standard_function8626);
        	        	        m_gPLSQLParser->content_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function8629);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:936:66: ( wellformed_key )?
        	        {
        	            int alt299=2;
        	            {
        	                int LA299_0 = this->LA(1);
        	                if ( ((equalsIgnoreCase(LT(1)->getText(), "WELLFORMED"))) && (LA299_0 == REGULAR_ID))
        	                {
        	                    alt299=1;
        	                }
        	            }
        	            switch (alt299)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:936:66: wellformed_key
        	        	    {
        	        	        this->followPush(FOLLOW_wellformed_key_in_standard_function8631);
        	        	        m_gPLSQLParser->wellformed_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8646);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:938:13: ( PERIOD general_element_part )?
        	        {
        	            int alt300=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PERIOD:
        	                	{
        	                		alt300=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt300)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:938:14: PERIOD general_element_part
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function8661);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function8663);
        	        	        m_gPLSQLParser->general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 20:
        	    // PLSQL_DMLParser.g:939:10: xmlpi_key LEFT_PAREN ( name_key id | evalname_key concatenation_wrapper ) ( COMMA concatenation_wrapper )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        this->followPush(FOLLOW_xmlpi_key_in_standard_function8676);
        	        m_gPLSQLParser->xmlpi_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8690);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:941:17: ( name_key id | evalname_key concatenation_wrapper )
        	        {
        	            int alt301=2;
        	            alt301 = cdfa301.predict(this, this->get_rec(), this->get_istream(), cdfa301 );
        	            if  (this->hasException())
        	            {
        	                goto rulestandard_functionEx;
        	            }
        	            if (this->hasFailed())
        	            {
        	                return ;
        	            }

        	            switch (alt301)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:941:22: name_key id
        	        	    {
        	        	        this->followPush(FOLLOW_name_key_in_standard_function8714);
        	        	        m_gPLSQLParser->name_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_id_in_standard_function8716);
        	        	        m_gPLSQLParser->id();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:942:22: evalname_key concatenation_wrapper
        	        	    {
        	        	        this->followPush(FOLLOW_evalname_key_in_standard_function8739);
        	        	        m_gPLSQLParser->evalname_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function8741);
        	        	        concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:944:17: ( COMMA concatenation_wrapper )?
        	        {
        	            int alt302=2;
        	            switch ( this->LA(1) )
        	            {
        	                case COMMA:
        	                	{
        	                		alt302=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt302)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:944:18: COMMA concatenation_wrapper
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function8778);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function8780);
        	        	        concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8796);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:946:13: ( PERIOD general_element_part )?
        	        {
        	            int alt303=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PERIOD:
        	                	{
        	                		alt303=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt303)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:946:14: PERIOD general_element_part
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function8811);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function8813);
        	        	        m_gPLSQLParser->general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 21:
        	    // PLSQL_DMLParser.g:947:10: xmlquery_key LEFT_PAREN concatenation_wrapper ( xml_passing_clause )? returning_key content_key ( null_key on_key empty_key )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        this->followPush(FOLLOW_xmlquery_key_in_standard_function8826);
        	        m_gPLSQLParser->xmlquery_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8840);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function8859);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:949:39: ( xml_passing_clause )?
        	        {
        	            int alt304=2;
        	            {
        	                int LA304_0 = this->LA(1);
        	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "RETURNING")))||((equalsIgnoreCase(LT(1)->getText(), "PASSING"))))) && (LA304_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA304_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "PASSING"))) && (LA304_1 == APPROXIMATE_NUM_LIT || LA304_1 == BINDVAR || ((LA304_1 >= CHAR_STRING) && (LA304_1 <= COLON)) || LA304_1 == DELIMITED_ID || LA304_1 == EXACT_NUM_LIT || LA304_1 == INTRODUCER || LA304_1 == LEFT_PAREN || ((LA304_1 >= MINUS_SIGN) && (LA304_1 <= NATIONAL_CHAR_STRING_LIT)) || LA304_1 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA304_1 == PLUS_SIGN || LA304_1 == SQL92_RESERVED_ALL || LA304_1 == SQL92_RESERVED_ANY || ((LA304_1 >= SQL92_RESERVED_BY) && (LA304_1 <= SQL92_RESERVED_CASE)) || ((LA304_1 >= SQL92_RESERVED_CURSOR) && (LA304_1 <= SQL92_RESERVED_DATE)) || LA304_1 == SQL92_RESERVED_DEFAULT || LA304_1 == SQL92_RESERVED_DISTINCT || ((LA304_1 >= SQL92_RESERVED_EXISTS) && (LA304_1 <= SQL92_RESERVED_FALSE)) || ((LA304_1 >= SQL92_RESERVED_NOT) && (LA304_1 <= SQL92_RESERVED_NULL)) || LA304_1 == SQL92_RESERVED_PRIOR || LA304_1 == SQL92_RESERVED_TRUE || LA304_1 == UNSIGNED_INTEGER))
        	                        {
        	                            alt304=1;
        	                        }
        	                        else if ( ((((equalsIgnoreCase(LT(1)->getText(), "RETURNING")))||((equalsIgnoreCase(LT(1)->getText(), "PASSING"))))) && (LA304_1 == REGULAR_ID))
        	                        {
        	                            {
        	                                int LA304_3 = this->LA(3);
        	                                if ( ((equalsIgnoreCase(LT(1)->getText(), "PASSING"))) && (LA304_3 == APPROXIMATE_NUM_LIT || LA304_3 == ASTERISK || LA304_3 == BINDVAR || ((LA304_3 >= CARRET_OPERATOR_PART) && (LA304_3 <= COMMA)) || ((LA304_3 >= CONCATENATION_OP) && (LA304_3 <= DELIMITED_ID)) || ((LA304_3 >= EQUALS_OP) && (LA304_3 <= EXCLAMATION_OPERATOR_PART)) || ((LA304_3 >= GREATER_THAN_OP) && (LA304_3 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA304_3 >= INTRODUCER) && (LA304_3 <= NATIONAL_CHAR_STRING_LIT)) || LA304_3 == NOT_EQUAL_OP || ((LA304_3 >= PERIOD) && (LA304_3 <= PLSQL_NON_RESERVED_CONNECT_BY_ROOT)) || LA304_3 == PLUS_SIGN || LA304_3 == REGULAR_ID || LA304_3 == SOLIDUS || LA304_3 == SQL92_RESERVED_ALL || ((LA304_3 >= SQL92_RESERVED_AND) && (LA304_3 <= SQL92_RESERVED_AS)) || LA304_3 == SQL92_RESERVED_BETWEEN || LA304_3 == SQL92_RESERVED_CASE || LA304_3 == SQL92_RESERVED_DATE || LA304_3 == SQL92_RESERVED_DEFAULT || LA304_3 == SQL92_RESERVED_DISTINCT || ((LA304_3 >= SQL92_RESERVED_EXISTS) && (LA304_3 <= SQL92_RESERVED_FALSE)) || LA304_3 == SQL92_RESERVED_IN || ((LA304_3 >= SQL92_RESERVED_IS) && (LA304_3 <= SQL92_RESERVED_NOT)) || LA304_3 == SQL92_RESERVED_OR || LA304_3 == SQL92_RESERVED_PRIOR || LA304_3 == SQL92_RESERVED_TRUE || ((LA304_3 >= UNSIGNED_INTEGER) && (LA304_3 <= VERTICAL_BAR))))
        	                                {
        	                                    alt304=1;
        	                                }
        	                                else if ( ((((equalsIgnoreCase(LT(1)->getText(), "RETURNING")))||((equalsIgnoreCase(LT(1)->getText(), "PASSING"))))) && (LA304_3 == SQL92_RESERVED_NULL))
        	                                {
        	                                    {
        	                                        int LA304_4 = this->LA(4);
        	                                        if ( ((equalsIgnoreCase(LT(1)->getText(), "PASSING"))) && (LA304_4 == ASTERISK || ((LA304_4 >= CARRET_OPERATOR_PART) && (LA304_4 <= CHAR_STRING_PERL)) || LA304_4 == COMMA || ((LA304_4 >= CONCATENATION_OP) && (LA304_4 <= DELIMITED_ID)) || LA304_4 == EQUALS_OP || LA304_4 == EXCLAMATION_OPERATOR_PART || ((LA304_4 >= GREATER_THAN_OP) && (LA304_4 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA304_4 >= INTRODUCER) && (LA304_4 <= LEFT_BRACKET)) || ((LA304_4 >= LESS_THAN_OP) && (LA304_4 <= NATIONAL_CHAR_STRING_LIT)) || LA304_4 == NOT_EQUAL_OP || LA304_4 == PLUS_SIGN || LA304_4 == REGULAR_ID || LA304_4 == SOLIDUS || LA304_4 == SQL92_RESERVED_AND || LA304_4 == SQL92_RESERVED_AS || LA304_4 == SQL92_RESERVED_BETWEEN || LA304_4 == SQL92_RESERVED_IN || ((LA304_4 >= SQL92_RESERVED_IS) && (LA304_4 <= SQL92_RESERVED_NOT)) || LA304_4 == SQL92_RESERVED_OR || LA304_4 == VERTICAL_BAR))
        	                                        {
        	                                            alt304=1;
        	                                        }
        	                                    }
        	                                }
        	                            }
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt304)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:949:39: xml_passing_clause
        	        	    {
        	        	        this->followPush(FOLLOW_xml_passing_clause_in_standard_function8861);
        	        	        xml_passing_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_returning_key_in_standard_function8880);
        	        m_gPLSQLParser->returning_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_content_key_in_standard_function8882);
        	        m_gPLSQLParser->content_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:950:43: ( null_key on_key empty_key )?
        	        {
        	            int alt305=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_NULL:
        	                	{
        	                		alt305=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt305)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:950:44: null_key on_key empty_key
        	        	    {
        	        	        this->followPush(FOLLOW_null_key_in_standard_function8885);
        	        	        m_gPLSQLParser->null_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_on_key_in_standard_function8887);
        	        	        m_gPLSQLParser->on_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_empty_key_in_standard_function8889);
        	        	        m_gPLSQLParser->empty_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function8905);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:952:13: ( PERIOD general_element_part )?
        	        {
        	            int alt306=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PERIOD:
        	                	{
        	                		alt306=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt306)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:952:14: PERIOD general_element_part
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function8920);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function8922);
        	        	        m_gPLSQLParser->general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 22:
        	    // PLSQL_DMLParser.g:953:10: xmlroot_key LEFT_PAREN concatenation_wrapper xmlroot_param_version_part ( COMMA xmlroot_param_standalone_part )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        this->followPush(FOLLOW_xmlroot_key_in_standard_function8935);
        	        m_gPLSQLParser->xmlroot_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function8949);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function8967);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_xmlroot_param_version_part_in_standard_function8989);
        	        xmlroot_param_version_part();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:957:21: ( COMMA xmlroot_param_standalone_part )?
        	        {
        	            int alt307=2;
        	            switch ( this->LA(1) )
        	            {
        	                case COMMA:
        	                	{
        	                		alt307=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt307)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:957:22: COMMA xmlroot_param_standalone_part
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function9012);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_xmlroot_param_standalone_part_in_standard_function9014);
        	        	        xmlroot_param_standalone_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function9030);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:959:13: ( PERIOD general_element_part )?
        	        {
        	            int alt308=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PERIOD:
        	                	{
        	                		alt308=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt308)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:959:14: PERIOD general_element_part
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function9045);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function9047);
        	        	        m_gPLSQLParser->general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 23:
        	    // PLSQL_DMLParser.g:960:10: xmlserialize_key LEFT_PAREN ( document_key | content_key ) concatenation_wrapper ( as_key type_spec )? ( xmlserialize_param_enconding_part )? ( xmlserialize_param_version_part )? ( xmlserialize_param_ident_part )? ( ( hide_key | show_key ) defaults_key )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        this->followPush(FOLLOW_xmlserialize_key_in_standard_function9060);
        	        m_gPLSQLParser->xmlserialize_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function9074);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:962:17: ( document_key | content_key )
        	        {
        	            int alt309=2;
        	            {
        	                int LA309_0 = this->LA(1);
        	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "DOCUMENT")))||((equalsIgnoreCase(LT(1)->getText(), "CONTENT"))))) && (LA309_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA309_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "DOCUMENT"))))
        	                        {
        	                            alt309=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "CONTENT"))))
        	                        {
        	                            alt309=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 309 );
        	                            ex->set_state( 1 );


        	                            goto rulestandard_functionEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 309 );
        	                    ex->set_state( 0 );


        	                    goto rulestandard_functionEx;

        	                }
        	            }
        	            switch (alt309)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:962:18: document_key
        	        	    {
        	        	        this->followPush(FOLLOW_document_key_in_standard_function9093);
        	        	        m_gPLSQLParser->document_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:962:31: content_key
        	        	    {
        	        	        this->followPush(FOLLOW_content_key_in_standard_function9095);
        	        	        m_gPLSQLParser->content_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function9114);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:963:39: ( as_key type_spec )?
        	        {
        	            int alt310=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_AS:
        	                	{
        	                		alt310=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt310)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:963:40: as_key type_spec
        	        	    {
        	        	        this->followPush(FOLLOW_as_key_in_standard_function9117);
        	        	        m_gPLSQLParser->as_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_type_spec_in_standard_function9119);
        	        	        m_gPLSQLParser->type_spec();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:964:17: ( xmlserialize_param_enconding_part )?
        	        {
        	            int alt311=2;
        	            {
        	                int LA311_0 = this->LA(1);
        	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "HIDE")))||((equalsIgnoreCase(LT(1)->getText(), "SHOW")))||((equalsIgnoreCase(LT(1)->getText(), "NO")))||((equalsIgnoreCase(LT(1)->getText(), "ENCODING")))||((equalsIgnoreCase(LT(1)->getText(), "VERSION")))||((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))) && (LA311_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA311_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "ENCODING"))))
        	                        {
        	                            alt311=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt311)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:964:17: xmlserialize_param_enconding_part
        	        	    {
        	        	        this->followPush(FOLLOW_xmlserialize_param_enconding_part_in_standard_function9139);
        	        	        xmlserialize_param_enconding_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:965:17: ( xmlserialize_param_version_part )?
        	        {
        	            int alt312=2;
        	            {
        	                int LA312_0 = this->LA(1);
        	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "HIDE")))||((equalsIgnoreCase(LT(1)->getText(), "SHOW")))||((equalsIgnoreCase(LT(1)->getText(), "NO")))||((equalsIgnoreCase(LT(1)->getText(), "VERSION")))||((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))) && (LA312_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA312_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "VERSION"))) && (LA312_1 == APPROXIMATE_NUM_LIT || LA312_1 == BINDVAR || ((LA312_1 >= CHAR_STRING) && (LA312_1 <= COLON)) || LA312_1 == DELIMITED_ID || LA312_1 == EXACT_NUM_LIT || LA312_1 == INTRODUCER || LA312_1 == LEFT_PAREN || ((LA312_1 >= MINUS_SIGN) && (LA312_1 <= NATIONAL_CHAR_STRING_LIT)) || LA312_1 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA312_1 == PLUS_SIGN || LA312_1 == SQL92_RESERVED_ALL || LA312_1 == SQL92_RESERVED_ANY || LA312_1 == SQL92_RESERVED_CASE || LA312_1 == SQL92_RESERVED_DATE || LA312_1 == SQL92_RESERVED_DEFAULT || LA312_1 == SQL92_RESERVED_DISTINCT || ((LA312_1 >= SQL92_RESERVED_EXISTS) && (LA312_1 <= SQL92_RESERVED_FALSE)) || LA312_1 == SQL92_RESERVED_NULL || LA312_1 == SQL92_RESERVED_PRIOR || LA312_1 == SQL92_RESERVED_TRUE || LA312_1 == UNSIGNED_INTEGER))
        	                        {
        	                            alt312=1;
        	                        }
        	                        else if ( ((((equalsIgnoreCase(LT(1)->getText(), "HIDE")))||((equalsIgnoreCase(LT(1)->getText(), "SHOW")))||((equalsIgnoreCase(LT(1)->getText(), "NO")))||((equalsIgnoreCase(LT(1)->getText(), "VERSION")))||((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))) && (LA312_1 == REGULAR_ID))
        	                        {
        	                            {
        	                                int LA312_4 = this->LA(3);
        	                                if ( ((equalsIgnoreCase(LT(1)->getText(), "VERSION"))))
        	                                {
        	                                    alt312=1;
        	                                }
        	                            }
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt312)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:965:17: xmlserialize_param_version_part
        	        	    {
        	        	        this->followPush(FOLLOW_xmlserialize_param_version_part_in_standard_function9158);
        	        	        xmlserialize_param_version_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:966:17: ( xmlserialize_param_ident_part )?
        	        {
        	            int alt313=2;
        	            {
        	                int LA313_0 = this->LA(1);
        	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "HIDE")))||((equalsIgnoreCase(LT(1)->getText(), "SHOW")))||((equalsIgnoreCase(LT(1)->getText(), "NO")))||((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))) && (LA313_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA313_1 = this->LA(2);
        	                        if ( ((((equalsIgnoreCase(LT(1)->getText(), "HIDE")))||((equalsIgnoreCase(LT(1)->getText(), "SHOW")))||((equalsIgnoreCase(LT(1)->getText(), "NO")))||((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))) && (LA313_1 == REGULAR_ID))
        	                        {
        	                            {
        	                                int LA313_3 = this->LA(3);
        	                                if ( ((((equalsIgnoreCase(LT(1)->getText(), "NO")))||((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))))
        	                                {
        	                                    alt313=1;
        	                                }
        	                            }
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "INDENT"))) && (LA313_1 == RIGHT_PAREN || LA313_1 == SQL92_RESERVED_SIZE))
        	                        {
        	                            alt313=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt313)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:966:17: xmlserialize_param_ident_part
        	        	    {
        	        	        this->followPush(FOLLOW_xmlserialize_param_ident_part_in_standard_function9177);
        	        	        xmlserialize_param_ident_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:967:17: ( ( hide_key | show_key ) defaults_key )?
        	        {
        	            int alt315=2;
        	            {
        	                int LA315_0 = this->LA(1);
        	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "HIDE")))||((equalsIgnoreCase(LT(1)->getText(), "SHOW"))))) && (LA315_0 == REGULAR_ID))
        	                {
        	                    alt315=1;
        	                }
        	            }
        	            switch (alt315)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:967:18: ( hide_key | show_key ) defaults_key
        	        	    {
        	        	        // PLSQL_DMLParser.g:967:18: ( hide_key | show_key )
        	        	        {
        	        	            int alt314=2;
        	        	            {
        	        	                int LA314_0 = this->LA(1);
        	        	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "HIDE")))||((equalsIgnoreCase(LT(1)->getText(), "SHOW"))))) && (LA314_0 == REGULAR_ID))
        	        	                {
        	        	                    {
        	        	                        int LA314_1 = this->LA(2);
        	        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "HIDE"))))
        	        	                        {
        	        	                            alt314=1;
        	        	                        }
        	        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "SHOW"))))
        	        	                        {
        	        	                            alt314=2;
        	        	                        }
        	        	                        else
        	        	                        {
        	        	                            if (this->get_backtracking()>0)
        	        	                            {
        	        	                                this->set_failedflag( true );
        	        	                                return ;
        	        	                            }


        	        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                            ex->set_decisionNum( 314 );
        	        	                            ex->set_state( 1 );


        	        	                            goto rulestandard_functionEx;

        	        	                        }
        	        	                    }
        	        	                }
        	        	                else
        	        	                {
        	        	                    if (this->get_backtracking()>0)
        	        	                    {
        	        	                        this->set_failedflag( true );
        	        	                        return ;
        	        	                    }


        	        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	        	                    ex->set_decisionNum( 314 );
        	        	                    ex->set_state( 0 );


        	        	                    goto rulestandard_functionEx;

        	        	                }
        	        	            }
        	        	            switch (alt314)
        	        	            {
        	        	        	case 1:
        	        	        	    // PLSQL_DMLParser.g:967:19: hide_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_hide_key_in_standard_function9198);
        	        	        	        m_gPLSQLParser->hide_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // PLSQL_DMLParser.g:967:28: show_key
        	        	        	    {
        	        	        	        this->followPush(FOLLOW_show_key_in_standard_function9200);
        	        	        	        m_gPLSQLParser->show_key();

        	        	        	        this->followPop();
        	        	        	        if  (this->hasException())
        	        	        	        {
        	        	        	            goto rulestandard_functionEx;
        	        	        	        }
        	        	        	        if (this->hasFailed())
        	        	        	        {
        	        	        	            return ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        this->followPush(FOLLOW_defaults_key_in_standard_function9203);
        	        	        m_gPLSQLParser->defaults_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function9219);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:969:13: ( PERIOD general_element_part )?
        	        {
        	            int alt316=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PERIOD:
        	                	{
        	                		alt316=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt316)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:969:14: PERIOD general_element_part
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function9234);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function9236);
        	        	        m_gPLSQLParser->general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 24:
        	    // PLSQL_DMLParser.g:970:10: xmltable_key LEFT_PAREN ( xml_namespaces_clause )? concatenation_wrapper ( xml_passing_clause )? ( columns_key xml_table_column ( COMMA xml_table_column ) )? RIGHT_PAREN ( PERIOD general_element_part )?
        	    {
        	        this->followPush(FOLLOW_xmltable_key_in_standard_function9249);
        	        m_gPLSQLParser->xmltable_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_standard_function9263);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:972:17: ( xml_namespaces_clause )?
        	        {
        	            int alt317=2;
        	            switch ( this->LA(1) )
        	            {
        	                case REGULAR_ID:
        	                	{
        	                		{
        	                		    int LA317_1 = this->LA(2);
        	                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "XMLNAMESPACES"))))
        	                		    {
        	                		        alt317=1;
        	                		    }
        	                		}
        	                	}
        	                    break;
        	            }

        	            switch (alt317)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:972:17: xml_namespaces_clause
        	        	    {
        	        	        this->followPush(FOLLOW_xml_namespaces_clause_in_standard_function9281);
        	        	        xml_namespaces_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        this->followPush(FOLLOW_concatenation_wrapper_in_standard_function9300);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:974:17: ( xml_passing_clause )?
        	        {
        	            int alt318=2;
        	            {
        	                int LA318_0 = this->LA(1);
        	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "COLUMNS")))||((equalsIgnoreCase(LT(1)->getText(), "PASSING"))))) && (LA318_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA318_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "PASSING"))))
        	                        {
        	                            alt318=1;
        	                        }
        	                    }
        	                }
        	            }
        	            switch (alt318)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:974:17: xml_passing_clause
        	        	    {
        	        	        this->followPush(FOLLOW_xml_passing_clause_in_standard_function9318);
        	        	        xml_passing_clause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // PLSQL_DMLParser.g:975:17: ( columns_key xml_table_column ( COMMA xml_table_column ) )?
        	        {
        	            int alt319=2;
        	            {
        	                int LA319_0 = this->LA(1);
        	                if ( ((equalsIgnoreCase(LT(1)->getText(), "COLUMNS"))) && (LA319_0 == REGULAR_ID))
        	                {
        	                    alt319=1;
        	                }
        	            }
        	            switch (alt319)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:975:18: columns_key xml_table_column ( COMMA xml_table_column )
        	        	    {
        	        	        this->followPush(FOLLOW_columns_key_in_standard_function9338);
        	        	        m_gPLSQLParser->columns_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_xml_table_column_in_standard_function9340);
        	        	        xml_table_column();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        // PLSQL_DMLParser.g:975:47: ( COMMA xml_table_column )
        	        	        // PLSQL_DMLParser.g:975:48: COMMA xml_table_column
        	        	        {
        	        	             this->matchToken(COMMA, &FOLLOW_COMMA_in_standard_function9343);
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulestandard_functionEx;
        	        	            }
        	        	            if (this->hasFailed())
        	        	            {
        	        	                return ;
        	        	            }


        	        	            this->followPush(FOLLOW_xml_table_column_in_standard_function9345);
        	        	            xml_table_column();

        	        	            this->followPop();
        	        	            if  (this->hasException())
        	        	            {
        	        	                goto rulestandard_functionEx;
        	        	            }
        	        	            if (this->hasFailed())
        	        	            {
        	        	                return ;
        	        	            }


        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_standard_function9362);
        	        if  (this->hasException())
        	        {
        	            goto rulestandard_functionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:977:13: ( PERIOD general_element_part )?
        	        {
        	            int alt320=2;
        	            switch ( this->LA(1) )
        	            {
        	                case PERIOD:
        	                	{
        	                		alt320=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt320)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:977:14: PERIOD general_element_part
        	        	    {
        	        	         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_standard_function9377);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_general_element_part_in_standard_function9379);
        	        	        m_gPLSQLParser->general_element_part();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulestandard_functionEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulestandard_functionEx; /* Prevent compiler warnings */
    rulestandard_functionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end standard_function */

/**
 * $ANTLR start stantard_function_enabling_over
 * PLSQL_DMLParser.g:980:1: stantard_function_enabling_over :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQL_DMLParser::stantard_function_enabling_over()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:981:5: ({...}? => REGULAR_ID )
        // PLSQL_DMLParser.g:981:10: {...}? => REGULAR_ID
        {
            if ( !((enablesOverClause(LT(1)->getText()))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "enablesOverClause(LT(1)->getText())" );
                    ex->set_ruleName( "stantard_function_enabling_over" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_stantard_function_enabling_over9404);
            if  (this->hasException())
            {
                goto rulestantard_function_enabling_overEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestantard_function_enabling_overEx; /* Prevent compiler warnings */
    rulestantard_function_enabling_overEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end stantard_function_enabling_over */

/**
 * $ANTLR start stantard_function_enabling_using
 * PLSQL_DMLParser.g:984:1: stantard_function_enabling_using :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQL_DMLParser::stantard_function_enabling_using()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:985:5: ({...}? => REGULAR_ID )
        // PLSQL_DMLParser.g:985:10: {...}? => REGULAR_ID
        {
            if ( !((enablesUsingClause(LT(1)->getText()))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "enablesUsingClause(LT(1)->getText())" );
                    ex->set_ruleName( "stantard_function_enabling_using" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_stantard_function_enabling_using9427);
            if  (this->hasException())
            {
                goto rulestantard_function_enabling_usingEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestantard_function_enabling_usingEx; /* Prevent compiler warnings */
    rulestantard_function_enabling_usingEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end stantard_function_enabling_using */

/**
 * $ANTLR start stantard_function_enabling_within_or_over
 * PLSQL_DMLParser.g:988:1: stantard_function_enabling_within_or_over :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQL_DMLParser::stantard_function_enabling_within_or_over()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:989:5: ({...}? => REGULAR_ID )
        // PLSQL_DMLParser.g:989:10: {...}? => REGULAR_ID
        {
            if ( !((enablesWithinOrOverClause(LT(1)->getText()))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "enablesWithinOrOverClause(LT(1)->getText())" );
                    ex->set_ruleName( "stantard_function_enabling_within_or_over" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_stantard_function_enabling_within_or_over9450);
            if  (this->hasException())
            {
                goto rulestantard_function_enabling_within_or_overEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestantard_function_enabling_within_or_overEx; /* Prevent compiler warnings */
    rulestantard_function_enabling_within_or_overEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end stantard_function_enabling_within_or_over */

/**
 * $ANTLR start stantard_function_pedictions
 * PLSQL_DMLParser.g:992:1: stantard_function_pedictions :{...}? => REGULAR_ID ;
 */
void
PLSQLParser_PLSQL_DMLParser::stantard_function_pedictions()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:993:5: ({...}? => REGULAR_ID )
        // PLSQL_DMLParser.g:993:10: {...}? => REGULAR_ID
        {
            if ( !((isStandardPredictionFunction(LT(1)->getText()))) )
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), "isStandardPredictionFunction(LT(1)->getText())" );
                    ex->set_ruleName( "stantard_function_pedictions" );


            }

             this->matchToken(REGULAR_ID, &FOLLOW_REGULAR_ID_in_stantard_function_pedictions9473);
            if  (this->hasException())
            {
                goto rulestantard_function_pedictionsEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestantard_function_pedictionsEx; /* Prevent compiler warnings */
    rulestantard_function_pedictionsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end stantard_function_pedictions */

/**
 * $ANTLR start over_clause
 * PLSQL_DMLParser.g:996:1: over_clause : over_key LEFT_PAREN ( query_partition_clause )? ( order_by_clause ( windowing_clause )? )? RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::over_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:997:5: ( over_key LEFT_PAREN ( query_partition_clause )? ( order_by_clause ( windowing_clause )? )? RIGHT_PAREN )
        // PLSQL_DMLParser.g:997:10: over_key LEFT_PAREN ( query_partition_clause )? ( order_by_clause ( windowing_clause )? )? RIGHT_PAREN
        {
            this->followPush(FOLLOW_over_key_in_over_clause9493);
            m_gPLSQLParser->over_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleover_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_over_clause9503);
            if  (this->hasException())
            {
                goto ruleover_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:999:13: ( query_partition_clause )?
            {
                int alt322=2;
                {
                    int LA322_0 = this->LA(1);
                    if ( ((equalsIgnoreCase(LT(1)->getText(), "PARTITION"))) && (LA322_0 == REGULAR_ID))
                    {
                        alt322=1;
                    }
                }
                switch (alt322)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:999:13: query_partition_clause
            	    {
            	        this->followPush(FOLLOW_query_partition_clause_in_over_clause9517);
            	        query_partition_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleover_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:1000:13: ( order_by_clause ( windowing_clause )? )?
            {
                int alt324=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_ORDER:
                    	{
                    		alt324=1;
                    	}
                        break;
                }

                switch (alt324)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1000:14: order_by_clause ( windowing_clause )?
            	    {
            	        this->followPush(FOLLOW_order_by_clause_in_over_clause9533);
            	        order_by_clause();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleover_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:1000:30: ( windowing_clause )?
            	        {
            	            int alt323=2;
            	            {
            	                int LA323_0 = this->LA(1);
            	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "ROWS")))||((equalsIgnoreCase(LT(1)->getText(), "RANGE"))))) && (LA323_0 == REGULAR_ID))
            	                {
            	                    alt323=1;
            	                }
            	            }
            	            switch (alt323)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:1000:30: windowing_clause
            	        	    {
            	        	        this->followPush(FOLLOW_windowing_clause_in_over_clause9535);
            	        	        windowing_clause();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleover_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_over_clause9548);
            if  (this->hasException())
            {
                goto ruleover_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleover_clauseEx; /* Prevent compiler warnings */
    ruleover_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end over_clause */

/**
 * $ANTLR start windowing_clause
 * PLSQL_DMLParser.g:1004:1: windowing_clause : windowing_type ( between_key windowing_elements and_key windowing_elements | windowing_elements ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::windowing_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1005:5: ( windowing_type ( between_key windowing_elements and_key windowing_elements | windowing_elements ) )
        // PLSQL_DMLParser.g:1005:10: windowing_type ( between_key windowing_elements and_key windowing_elements | windowing_elements )
        {
            this->followPush(FOLLOW_windowing_type_in_windowing_clause9568);
            windowing_type();

            this->followPop();
            if  (this->hasException())
            {
                goto rulewindowing_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1006:5: ( between_key windowing_elements and_key windowing_elements | windowing_elements )
            {
                int alt325=2;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_BETWEEN:
                	{
                		alt325=1;
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case DELIMITED_ID:
                case EXACT_NUM_LIT:
                case INTRODUCER:
                case LEFT_PAREN:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case REGULAR_ID:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURRENT:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt325=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 325 );
                    ex->set_state( 0 );


                    goto rulewindowing_clauseEx;

                }

                switch (alt325)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1006:10: between_key windowing_elements and_key windowing_elements
            	    {
            	        this->followPush(FOLLOW_between_key_in_windowing_clause9579);
            	        m_gPLSQLParser->between_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewindowing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_windowing_elements_in_windowing_clause9581);
            	        windowing_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewindowing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_and_key_in_windowing_clause9583);
            	        m_gPLSQLParser->and_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewindowing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_windowing_elements_in_windowing_clause9585);
            	        windowing_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewindowing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:1007:10: windowing_elements
            	    {
            	        this->followPush(FOLLOW_windowing_elements_in_windowing_clause9596);
            	        windowing_elements();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulewindowing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulewindowing_clauseEx; /* Prevent compiler warnings */
    rulewindowing_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end windowing_clause */

/**
 * $ANTLR start windowing_type
 * PLSQL_DMLParser.g:1010:1: windowing_type : ( rows_key | range_key );
 */
void
PLSQLParser_PLSQL_DMLParser::windowing_type()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:1011:5: ( rows_key | range_key )

            ANTLR_UINT32 alt326;

            alt326=2;

            {
                int LA326_0 = this->LA(1);
                if ( ((((equalsIgnoreCase(LT(1)->getText(), "ROWS")))||((equalsIgnoreCase(LT(1)->getText(), "RANGE"))))) && (LA326_0 == REGULAR_ID))
                {
                    {
                        int LA326_1 = this->LA(2);
                        if ( ((equalsIgnoreCase(LT(1)->getText(), "ROWS"))))
                        {
                            alt326=1;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "RANGE"))))
                        {
                            alt326=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 326 );
                            ex->set_state( 1 );


                            goto rulewindowing_typeEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 326 );
                    ex->set_state( 0 );


                    goto rulewindowing_typeEx;

                }
            }
            switch (alt326)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:1011:10: rows_key
        	    {
        	        this->followPush(FOLLOW_rows_key_in_windowing_type9621);
        	        m_gPLSQLParser->rows_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:1012:10: range_key
        	    {
        	        this->followPush(FOLLOW_range_key_in_windowing_type9632);
        	        m_gPLSQLParser->range_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_typeEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulewindowing_typeEx; /* Prevent compiler warnings */
    rulewindowing_typeEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end windowing_type */

/**
 * $ANTLR start windowing_elements
 * PLSQL_DMLParser.g:1015:1: windowing_elements : ( unbounded_key preceding_key | current_key row_key | concatenation_wrapper ( preceding_key | following_key ) );
 */
void
PLSQLParser_PLSQL_DMLParser::windowing_elements()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:1016:5: ( unbounded_key preceding_key | current_key row_key | concatenation_wrapper ( preceding_key | following_key ) )

            ANTLR_UINT32 alt328;

            alt328=3;

            switch ( this->LA(1) )
            {
            case REGULAR_ID:
            	{
            		{
            		    int LA328_1 = this->LA(2);
            		    if ( (LA328_1 == REGULAR_ID))
            		    {
            		        {
            		            int LA328_4 = this->LA(3);
            		            if ( ((equalsIgnoreCase(LT(1)->getText(), "UNBOUNDED"))))
            		            {
            		                alt328=1;
            		            }
            		            else if ( (true))
            		            {
            		                alt328=3;
            		            }
            		            else
            		            {
            		                if (this->get_backtracking()>0)
            		                {
            		                    this->set_failedflag( true );
            		                    return ;
            		                }


            		                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		                ex->set_decisionNum( 328 );
            		                ex->set_state( 4 );


            		                goto rulewindowing_elementsEx;

            		            }
            		        }
            		    }
            		    else if ( (LA328_1 == MINUS_SIGN || LA328_1 == PLUS_SIGN))
            		    {
            		        alt328=3;
            		    }
            		    else if ( (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )) && (LA328_1 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA328_1 == SQL92_RESERVED_ALL || LA328_1 == SQL92_RESERVED_DISTINCT || LA328_1 == SQL92_RESERVED_PRIOR))
            		    {
            		        alt328=3;
            		    }
            		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||(( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )))) && (LA328_1 == DELIMITED_ID))
            		    {
            		        alt328=3;
            		    }
            		    else if ( (LA328_1 == SQL92_RESERVED_CASE))
            		    {
            		        alt328=3;
            		    }
            		    else if ( (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )) && (LA328_1 == SQL92_RESERVED_ANY || LA328_1 == SQL92_RESERVED_EXISTS))
            		    {
            		        alt328=3;
            		    }
            		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||(( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )))) && (LA328_1 == INTRODUCER))
            		    {
            		        alt328=3;
            		    }
            		    else if ( (LA328_1 == BINDVAR || LA328_1 == COLON))
            		    {
            		        alt328=3;
            		    }
            		    else if ( (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )) && (LA328_1 == APPROXIMATE_NUM_LIT || LA328_1 == EXACT_NUM_LIT || LA328_1 == SQL92_RESERVED_DATE || LA328_1 == UNSIGNED_INTEGER))
            		    {
            		        alt328=3;
            		    }
            		    else if ( (((LA328_1 >= CHAR_STRING) && (LA328_1 <= CHAR_STRING_PERL)) || LA328_1 == NATIONAL_CHAR_STRING_LIT))
            		    {
            		        alt328=3;
            		    }
            		    else if ( (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
            		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
            		             )) )) && (LA328_1 == SQL92_RESERVED_DEFAULT || LA328_1 == SQL92_RESERVED_FALSE || LA328_1 == SQL92_RESERVED_NULL || LA328_1 == SQL92_RESERVED_TRUE))
            		    {
            		        alt328=3;
            		    }
            		    else if ( (LA328_1 == ASTERISK || LA328_1 == CONCATENATION_OP || ((LA328_1 >= LEFT_BRACKET) && (LA328_1 <= LEFT_PAREN)) || LA328_1 == PERIOD || LA328_1 == SOLIDUS || LA328_1 == VERTICAL_BAR))
            		    {
            		        alt328=3;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 328 );
            		        ex->set_state( 1 );


            		        goto rulewindowing_elementsEx;

            		    }
            		}
            	}
                break;
            case SQL92_RESERVED_CURRENT:
            	{
            		alt328=2;
            	}
                break;
            case APPROXIMATE_NUM_LIT:
            case BINDVAR:
            case CHAR_STRING:
            case CHAR_STRING_PERL:
            case COLON:
            case DELIMITED_ID:
            case EXACT_NUM_LIT:
            case INTRODUCER:
            case LEFT_PAREN:
            case MINUS_SIGN:
            case NATIONAL_CHAR_STRING_LIT:
            case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
            case PLUS_SIGN:
            case SQL92_RESERVED_ALL:
            case SQL92_RESERVED_ANY:
            case SQL92_RESERVED_CASE:
            case SQL92_RESERVED_DATE:
            case SQL92_RESERVED_DEFAULT:
            case SQL92_RESERVED_DISTINCT:
            case SQL92_RESERVED_EXISTS:
            case SQL92_RESERVED_FALSE:
            case SQL92_RESERVED_NULL:
            case SQL92_RESERVED_PRIOR:
            case SQL92_RESERVED_TRUE:
            case UNSIGNED_INTEGER:
            	{
            		alt328=3;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 328 );
                ex->set_state( 0 );


                goto rulewindowing_elementsEx;

            }

            switch (alt328)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:1016:10: unbounded_key preceding_key
        	    {
        	        this->followPush(FOLLOW_unbounded_key_in_windowing_elements9652);
        	        m_gPLSQLParser->unbounded_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_preceding_key_in_windowing_elements9654);
        	        m_gPLSQLParser->preceding_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:1017:10: current_key row_key
        	    {
        	        this->followPush(FOLLOW_current_key_in_windowing_elements9665);
        	        m_gPLSQLParser->current_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_row_key_in_windowing_elements9667);
        	        m_gPLSQLParser->row_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // PLSQL_DMLParser.g:1018:10: concatenation_wrapper ( preceding_key | following_key )
        	    {
        	        this->followPush(FOLLOW_concatenation_wrapper_in_windowing_elements9678);
        	        concatenation_wrapper();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewindowing_elementsEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:1018:32: ( preceding_key | following_key )
        	        {
        	            int alt327=2;
        	            {
        	                int LA327_0 = this->LA(1);
        	                if ( ((((equalsIgnoreCase(LT(1)->getText(), "FOLLOWING")))||((equalsIgnoreCase(LT(1)->getText(), "PRECEDING"))))) && (LA327_0 == REGULAR_ID))
        	                {
        	                    {
        	                        int LA327_1 = this->LA(2);
        	                        if ( ((equalsIgnoreCase(LT(1)->getText(), "PRECEDING"))))
        	                        {
        	                            alt327=1;
        	                        }
        	                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "FOLLOWING"))))
        	                        {
        	                            alt327=2;
        	                        }
        	                        else
        	                        {
        	                            if (this->get_backtracking()>0)
        	                            {
        	                                this->set_failedflag( true );
        	                                return ;
        	                            }


        	                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                            ex->set_decisionNum( 327 );
        	                            ex->set_state( 1 );


        	                            goto rulewindowing_elementsEx;

        	                        }
        	                    }
        	                }
        	                else
        	                {
        	                    if (this->get_backtracking()>0)
        	                    {
        	                        this->set_failedflag( true );
        	                        return ;
        	                    }


        	                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        	                    ex->set_decisionNum( 327 );
        	                    ex->set_state( 0 );


        	                    goto rulewindowing_elementsEx;

        	                }
        	            }
        	            switch (alt327)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:1018:33: preceding_key
        	        	    {
        	        	        this->followPush(FOLLOW_preceding_key_in_windowing_elements9681);
        	        	        m_gPLSQLParser->preceding_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulewindowing_elementsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // PLSQL_DMLParser.g:1018:47: following_key
        	        	    {
        	        	        this->followPush(FOLLOW_following_key_in_windowing_elements9683);
        	        	        m_gPLSQLParser->following_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulewindowing_elementsEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulewindowing_elementsEx; /* Prevent compiler warnings */
    rulewindowing_elementsEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end windowing_elements */

/**
 * $ANTLR start using_clause
 * PLSQL_DMLParser.g:1021:1: using_clause : using_key ( ASTERISK | using_element ( COMMA using_element )* ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::using_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1022:5: ( using_key ( ASTERISK | using_element ( COMMA using_element )* ) )
        // PLSQL_DMLParser.g:1022:10: using_key ( ASTERISK | using_element ( COMMA using_element )* )
        {
            this->followPush(FOLLOW_using_key_in_using_clause9704);
            m_gPLSQLParser->using_key();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleusing_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1023:5: ( ASTERISK | using_element ( COMMA using_element )* )
            {
                int alt330=2;
                switch ( this->LA(1) )
                {
                case ASTERISK:
                	{
                		alt330=1;
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case DELIMITED_ID:
                case EXACT_NUM_LIT:
                case INTRODUCER:
                case LEFT_PAREN:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case REGULAR_ID:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURSOR:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_IN:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt330=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 330 );
                    ex->set_state( 0 );


                    goto ruleusing_clauseEx;

                }

                switch (alt330)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1023:10: ASTERISK
            	    {
            	         this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_using_clause9715);
            	        if  (this->hasException())
            	        {
            	            goto ruleusing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:1024:10: using_element ( COMMA using_element )*
            	    {
            	        this->followPush(FOLLOW_using_element_in_using_clause9726);
            	        using_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleusing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:1024:24: ( COMMA using_element )*

            	        for (;;)
            	        {
            	            int alt329=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt329=1;
            	            	}
            	                break;

            	            }

            	            switch (alt329)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:1024:25: COMMA using_element
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_using_clause9729);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleusing_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_using_element_in_using_clause9731);
            	        	        using_element();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleusing_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop329;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop329: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleusing_clauseEx; /* Prevent compiler warnings */
    ruleusing_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end using_clause */

/**
 * $ANTLR start using_element
 * PLSQL_DMLParser.g:1028:1: using_element : ( in_key ( out_key )? | out_key )? select_list_elements ( column_alias )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::using_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1029:5: ( ( in_key ( out_key )? | out_key )? select_list_elements ( column_alias )? )
        // PLSQL_DMLParser.g:1029:10: ( in_key ( out_key )? | out_key )? select_list_elements ( column_alias )?
        {
            // PLSQL_DMLParser.g:1029:10: ( in_key ( out_key )? | out_key )?
            {
                int alt332=3;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_IN:
                    	{
                    		alt332=1;
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA332_2 = this->LA(2);
                    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "OUT"))))
                    		    {
                    		        alt332=2;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt332)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1029:11: in_key ( out_key )?
            	    {
            	        this->followPush(FOLLOW_in_key_in_using_element9760);
            	        m_gPLSQLParser->in_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleusing_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:1029:18: ( out_key )?
            	        {
            	            int alt331=2;
            	            switch ( this->LA(1) )
            	            {
            	                case REGULAR_ID:
            	                	{
            	                		{
            	                		    int LA331_1 = this->LA(2);
            	                		    if ( ((equalsIgnoreCase(LT(1)->getText(), "OUT"))))
            	                		    {
            	                		        alt331=1;
            	                		    }
            	                		}
            	                	}
            	                    break;
            	            }

            	            switch (alt331)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:1029:18: out_key
            	        	    {
            	        	        this->followPush(FOLLOW_out_key_in_using_element9762);
            	        	        m_gPLSQLParser->out_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleusing_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:1029:27: out_key
            	    {
            	        this->followPush(FOLLOW_out_key_in_using_element9765);
            	        m_gPLSQLParser->out_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleusing_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_select_list_elements_in_using_element9769);
            select_list_elements();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleusing_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1029:58: ( column_alias )?
            {
                int alt333=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_AS:
                    	{
                    		alt333=1;
                    	}
                        break;
                    case INTRODUCER:
                    	{
                    		alt333=1;
                    	}
                        break;
                    case REGULAR_ID:
                    	{
                    		alt333=1;
                    	}
                        break;
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case NATIONAL_CHAR_STRING_LIT:
                    	{
                    		alt333=1;
                    	}
                        break;
                    case DELIMITED_ID:
                    	{
                    		alt333=1;
                    	}
                        break;
                }

                switch (alt333)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1029:58: column_alias
            	    {
            	        this->followPush(FOLLOW_column_alias_in_using_element9771);
            	        m_gPLSQLParser->column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleusing_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleusing_elementEx; /* Prevent compiler warnings */
    ruleusing_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end using_element */

/**
 * $ANTLR start collect_order_by_part
 * PLSQL_DMLParser.g:1032:1: collect_order_by_part : order_key by_key concatenation_wrapper ;
 */
void
PLSQLParser_PLSQL_DMLParser::collect_order_by_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1033:5: ( order_key by_key concatenation_wrapper )
        // PLSQL_DMLParser.g:1033:10: order_key by_key concatenation_wrapper
        {
            this->followPush(FOLLOW_order_key_in_collect_order_by_part9792);
            m_gPLSQLParser->order_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecollect_order_by_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_by_key_in_collect_order_by_part9794);
            m_gPLSQLParser->by_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecollect_order_by_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_concatenation_wrapper_in_collect_order_by_part9796);
            concatenation_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecollect_order_by_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecollect_order_by_partEx; /* Prevent compiler warnings */
    rulecollect_order_by_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end collect_order_by_part */

/**
 * $ANTLR start within_or_over_part
 * PLSQL_DMLParser.g:1036:1: within_or_over_part : ( within_key group_key LEFT_PAREN order_by_clause RIGHT_PAREN | over_clause );
 */
void
PLSQLParser_PLSQL_DMLParser::within_or_over_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:1037:5: ( within_key group_key LEFT_PAREN order_by_clause RIGHT_PAREN | over_clause )

            ANTLR_UINT32 alt334;

            alt334=2;

            {
                int LA334_0 = this->LA(1);
                if ( ((((equalsIgnoreCase(LT(1)->getText(), "WITHIN")))||((equalsIgnoreCase(LT(1)->getText(), "OVER"))))) && (LA334_0 == REGULAR_ID))
                {
                    {
                        int LA334_1 = this->LA(2);
                        if ( ((equalsIgnoreCase(LT(1)->getText(), "WITHIN"))) && (LA334_1 == SQL92_RESERVED_GROUP))
                        {
                            alt334=1;
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "OVER"))) && (LA334_1 == LEFT_PAREN))
                        {
                            alt334=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 334 );
                            ex->set_state( 1 );


                            goto rulewithin_or_over_partEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 334 );
                    ex->set_state( 0 );


                    goto rulewithin_or_over_partEx;

                }
            }
            switch (alt334)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:1037:10: within_key group_key LEFT_PAREN order_by_clause RIGHT_PAREN
        	    {
        	        this->followPush(FOLLOW_within_key_in_within_or_over_part9816);
        	        m_gPLSQLParser->within_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewithin_or_over_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_group_key_in_within_or_over_part9818);
        	        m_gPLSQLParser->group_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewithin_or_over_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_within_or_over_part9820);
        	        if  (this->hasException())
        	        {
        	            goto rulewithin_or_over_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_order_by_clause_in_within_or_over_part9822);
        	        order_by_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewithin_or_over_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_within_or_over_part9824);
        	        if  (this->hasException())
        	        {
        	            goto rulewithin_or_over_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:1038:10: over_clause
        	    {
        	        this->followPush(FOLLOW_over_clause_in_within_or_over_part9835);
        	        over_clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulewithin_or_over_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulewithin_or_over_partEx; /* Prevent compiler warnings */
    rulewithin_or_over_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end within_or_over_part */

/**
 * $ANTLR start cost_matrix_clause
 * PLSQL_DMLParser.g:1041:1: cost_matrix_clause : cost_key ( model_key ( auto_key )? | LEFT_PAREN cost_class_name ( COMMA cost_class_name )* RIGHT_PAREN values_key expression_list ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::cost_matrix_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1042:5: ( cost_key ( model_key ( auto_key )? | LEFT_PAREN cost_class_name ( COMMA cost_class_name )* RIGHT_PAREN values_key expression_list ) )
        // PLSQL_DMLParser.g:1042:10: cost_key ( model_key ( auto_key )? | LEFT_PAREN cost_class_name ( COMMA cost_class_name )* RIGHT_PAREN values_key expression_list )
        {
            this->followPush(FOLLOW_cost_key_in_cost_matrix_clause9855);
            m_gPLSQLParser->cost_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecost_matrix_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1043:5: ( model_key ( auto_key )? | LEFT_PAREN cost_class_name ( COMMA cost_class_name )* RIGHT_PAREN values_key expression_list )
            {
                int alt337=2;
                switch ( this->LA(1) )
                {
                case PLSQL_NON_RESERVED_MODEL:
                	{
                		alt337=1;
                	}
                    break;
                case LEFT_PAREN:
                	{
                		alt337=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 337 );
                    ex->set_state( 0 );


                    goto rulecost_matrix_clauseEx;

                }

                switch (alt337)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1043:10: model_key ( auto_key )?
            	    {
            	        this->followPush(FOLLOW_model_key_in_cost_matrix_clause9866);
            	        m_gPLSQLParser->model_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecost_matrix_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:1043:20: ( auto_key )?
            	        {
            	            int alt335=2;
            	            {
            	                int LA335_0 = this->LA(1);
            	                if ( ((equalsIgnoreCase(LT(1)->getText(), "AUTO"))) && (LA335_0 == REGULAR_ID))
            	                {
            	                    alt335=1;
            	                }
            	            }
            	            switch (alt335)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:1043:20: auto_key
            	        	    {
            	        	        this->followPush(FOLLOW_auto_key_in_cost_matrix_clause9868);
            	        	        m_gPLSQLParser->auto_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecost_matrix_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:1044:10: LEFT_PAREN cost_class_name ( COMMA cost_class_name )* RIGHT_PAREN values_key expression_list
            	    {
            	         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_cost_matrix_clause9880);
            	        if  (this->hasException())
            	        {
            	            goto rulecost_matrix_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_cost_class_name_in_cost_matrix_clause9882);
            	        m_gPLSQLParser->cost_class_name();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecost_matrix_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:1044:37: ( COMMA cost_class_name )*

            	        for (;;)
            	        {
            	            int alt336=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt336=1;
            	            	}
            	                break;

            	            }

            	            switch (alt336)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:1044:38: COMMA cost_class_name
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_cost_matrix_clause9885);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecost_matrix_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_cost_class_name_in_cost_matrix_clause9887);
            	        	        m_gPLSQLParser->cost_class_name();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulecost_matrix_clauseEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop336;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop336: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_cost_matrix_clause9891);
            	        if  (this->hasException())
            	        {
            	            goto rulecost_matrix_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_values_key_in_cost_matrix_clause9893);
            	        m_gPLSQLParser->values_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecost_matrix_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_list_in_cost_matrix_clause9908);
            	        expression_list();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecost_matrix_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulecost_matrix_clauseEx; /* Prevent compiler warnings */
    rulecost_matrix_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end cost_matrix_clause */

/**
 * $ANTLR start xml_passing_clause
 * PLSQL_DMLParser.g:1049:1: xml_passing_clause : passing_key ( by_key value_key )? expression_wrapper ( column_alias )? ( COMMA expression_wrapper ( column_alias )? ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::xml_passing_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1050:5: ( passing_key ( by_key value_key )? expression_wrapper ( column_alias )? ( COMMA expression_wrapper ( column_alias )? ) )
        // PLSQL_DMLParser.g:1050:10: passing_key ( by_key value_key )? expression_wrapper ( column_alias )? ( COMMA expression_wrapper ( column_alias )? )
        {
            this->followPush(FOLLOW_passing_key_in_xml_passing_clause9934);
            m_gPLSQLParser->passing_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_passing_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1050:22: ( by_key value_key )?
            {
                int alt338=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_BY:
                    	{
                    		alt338=1;
                    	}
                        break;
                }

                switch (alt338)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1050:23: by_key value_key
            	    {
            	        this->followPush(FOLLOW_by_key_in_xml_passing_clause9937);
            	        m_gPLSQLParser->by_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_passing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_value_key_in_xml_passing_clause9939);
            	        m_gPLSQLParser->value_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_passing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_expression_wrapper_in_xml_passing_clause9955);
            expression_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_passing_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1051:32: ( column_alias )?
            {
                int alt339=2;
                switch ( this->LA(1) )
                {
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case DELIMITED_ID:
                    case INTRODUCER:
                    case NATIONAL_CHAR_STRING_LIT:
                    case REGULAR_ID:
                    case SQL92_RESERVED_AS:
                    	{
                    		alt339=1;
                    	}
                        break;
                }

                switch (alt339)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1051:32: column_alias
            	    {
            	        this->followPush(FOLLOW_column_alias_in_xml_passing_clause9957);
            	        m_gPLSQLParser->column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_passing_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:1051:46: ( COMMA expression_wrapper ( column_alias )? )
            // PLSQL_DMLParser.g:1051:47: COMMA expression_wrapper ( column_alias )?
            {
                 this->matchToken(COMMA, &FOLLOW_COMMA_in_xml_passing_clause9961);
                if  (this->hasException())
                {
                    goto rulexml_passing_clauseEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }


                this->followPush(FOLLOW_expression_wrapper_in_xml_passing_clause9963);
                expression_wrapper();

                this->followPop();
                if  (this->hasException())
                {
                    goto rulexml_passing_clauseEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }


                // PLSQL_DMLParser.g:1051:72: ( column_alias )?
                {
                    int alt340=2;
                    switch ( this->LA(1) )
                    {
                        case CHAR_STRING:
                        case CHAR_STRING_PERL:
                        case DELIMITED_ID:
                        case INTRODUCER:
                        case NATIONAL_CHAR_STRING_LIT:
                        case SQL92_RESERVED_AS:
                        	{
                        		alt340=1;
                        	}
                            break;
                        case REGULAR_ID:
                        	{
                        		{
                        		    int LA340_3 = this->LA(2);
                        		    if ( (!( ((((equalsIgnoreCase(LT(1)->getText(), "RETURNING")))||((equalsIgnoreCase(LT(1)->getText(), "COLUMNS"))))) )))
                        		    {
                        		        alt340=1;
                        		    }
                        		}
                        	}
                            break;
                    }

                    switch (alt340)
                    {
                	case 1:
                	    // PLSQL_DMLParser.g:1051:72: column_alias
                	    {
                	        this->followPush(FOLLOW_column_alias_in_xml_passing_clause9965);
                	        m_gPLSQLParser->column_alias();

                	        this->followPop();
                	        if  (this->hasException())
                	        {
                	            goto rulexml_passing_clauseEx;
                	        }
                	        if (this->hasFailed())
                	        {
                	            return ;
                	        }


                	    }
                	    break;

                    }
                }

            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexml_passing_clauseEx; /* Prevent compiler warnings */
    rulexml_passing_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xml_passing_clause */

/**
 * $ANTLR start xml_attributes_clause
 * PLSQL_DMLParser.g:1054:1: xml_attributes_clause : xmlattributes_key LEFT_PAREN ( entityescaping_key | noentityescaping_key )? ( schemacheck_key | noschemacheck_key )? xml_multiuse_expression_element ( COMMA xml_multiuse_expression_element )* RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::xml_attributes_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1055:5: ( xmlattributes_key LEFT_PAREN ( entityescaping_key | noentityescaping_key )? ( schemacheck_key | noschemacheck_key )? xml_multiuse_expression_element ( COMMA xml_multiuse_expression_element )* RIGHT_PAREN )
        // PLSQL_DMLParser.g:1055:10: xmlattributes_key LEFT_PAREN ( entityescaping_key | noentityescaping_key )? ( schemacheck_key | noschemacheck_key )? xml_multiuse_expression_element ( COMMA xml_multiuse_expression_element )* RIGHT_PAREN
        {
            this->followPush(FOLLOW_xmlattributes_key_in_xml_attributes_clause9987);
            m_gPLSQLParser->xmlattributes_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_attributes_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_xml_attributes_clause9997);
            if  (this->hasException())
            {
                goto rulexml_attributes_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1057:13: ( entityescaping_key | noentityescaping_key )?
            {
                int alt341=3;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA341_1 = this->LA(2);
                    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "ENTITYESCAPING"))))
                    		    {
                    		        alt341=1;
                    		    }
                    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "NOENTITYESCAPING"))))
                    		    {
                    		        alt341=2;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt341)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1057:14: entityescaping_key
            	    {
            	        this->followPush(FOLLOW_entityescaping_key_in_xml_attributes_clause10012);
            	        m_gPLSQLParser->entityescaping_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_attributes_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:1057:33: noentityescaping_key
            	    {
            	        this->followPush(FOLLOW_noentityescaping_key_in_xml_attributes_clause10014);
            	        m_gPLSQLParser->noentityescaping_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_attributes_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:1058:13: ( schemacheck_key | noschemacheck_key )?
            {
                int alt342=3;
                switch ( this->LA(1) )
                {
                    case REGULAR_ID:
                    	{
                    		{
                    		    int LA342_1 = this->LA(2);
                    		    if ( ((equalsIgnoreCase(LT(1)->getText(), "SCHEMACHECK"))))
                    		    {
                    		        alt342=1;
                    		    }
                    		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "NOSCHEMACHECK"))))
                    		    {
                    		        alt342=2;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt342)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1058:14: schemacheck_key
            	    {
            	        this->followPush(FOLLOW_schemacheck_key_in_xml_attributes_clause10031);
            	        m_gPLSQLParser->schemacheck_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_attributes_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:1058:30: noschemacheck_key
            	    {
            	        this->followPush(FOLLOW_noschemacheck_key_in_xml_attributes_clause10033);
            	        m_gPLSQLParser->noschemacheck_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_attributes_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause10049);
            xml_multiuse_expression_element();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_attributes_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1059:45: ( COMMA xml_multiuse_expression_element )*

            for (;;)
            {
                int alt343=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt343=1;
                	}
                    break;

                }

                switch (alt343)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1059:46: COMMA xml_multiuse_expression_element
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_xml_attributes_clause10052);
            	        if  (this->hasException())
            	        {
            	            goto rulexml_attributes_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_xml_multiuse_expression_element_in_xml_attributes_clause10054);
            	        xml_multiuse_expression_element();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_attributes_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop343;	/* break out of the loop */
            	    break;
                }
            }
            loop343: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_xml_attributes_clause10066);
            if  (this->hasException())
            {
                goto rulexml_attributes_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexml_attributes_clauseEx; /* Prevent compiler warnings */
    rulexml_attributes_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xml_attributes_clause */

/**
 * $ANTLR start xml_namespaces_clause
 * PLSQL_DMLParser.g:1063:1: xml_namespaces_clause : xmlnamespaces_key LEFT_PAREN ( concatenation_wrapper column_alias )? ( COMMA concatenation_wrapper column_alias )* ( ( default_key )=> xml_general_default_part )? RIGHT_PAREN ;
 */
void
PLSQLParser_PLSQL_DMLParser::xml_namespaces_clause()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1064:5: ( xmlnamespaces_key LEFT_PAREN ( concatenation_wrapper column_alias )? ( COMMA concatenation_wrapper column_alias )* ( ( default_key )=> xml_general_default_part )? RIGHT_PAREN )
        // PLSQL_DMLParser.g:1064:10: xmlnamespaces_key LEFT_PAREN ( concatenation_wrapper column_alias )? ( COMMA concatenation_wrapper column_alias )* ( ( default_key )=> xml_general_default_part )? RIGHT_PAREN
        {
            this->followPush(FOLLOW_xmlnamespaces_key_in_xml_namespaces_clause10086);
            m_gPLSQLParser->xmlnamespaces_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_namespaces_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_xml_namespaces_clause10096);
            if  (this->hasException())
            {
                goto rulexml_namespaces_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1066:13: ( concatenation_wrapper column_alias )?
            {
                int alt344=2;
                switch ( this->LA(1) )
                {
                    case APPROXIMATE_NUM_LIT:
                    case BINDVAR:
                    case CHAR_STRING:
                    case CHAR_STRING_PERL:
                    case COLON:
                    case DELIMITED_ID:
                    case EXACT_NUM_LIT:
                    case INTRODUCER:
                    case LEFT_PAREN:
                    case MINUS_SIGN:
                    case NATIONAL_CHAR_STRING_LIT:
                    case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                    case PLUS_SIGN:
                    case REGULAR_ID:
                    case SQL92_RESERVED_ALL:
                    case SQL92_RESERVED_ANY:
                    case SQL92_RESERVED_CASE:
                    case SQL92_RESERVED_DATE:
                    case SQL92_RESERVED_DISTINCT:
                    case SQL92_RESERVED_EXISTS:
                    case SQL92_RESERVED_FALSE:
                    case SQL92_RESERVED_NULL:
                    case SQL92_RESERVED_PRIOR:
                    case SQL92_RESERVED_TRUE:
                    case UNSIGNED_INTEGER:
                    	{
                    		alt344=1;
                    	}
                        break;
                    case SQL92_RESERVED_DEFAULT:
                    	{
                    		alt344=1;
                    	}
                        break;
                }

                switch (alt344)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1066:14: concatenation_wrapper column_alias
            	    {
            	        this->followPush(FOLLOW_concatenation_wrapper_in_xml_namespaces_clause10111);
            	        concatenation_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_namespaces_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_alias_in_xml_namespaces_clause10113);
            	        m_gPLSQLParser->column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_namespaces_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // PLSQL_DMLParser.g:1067:17: ( COMMA concatenation_wrapper column_alias )*

            for (;;)
            {
                int alt345=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt345=1;
                	}
                    break;

                }

                switch (alt345)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1067:18: COMMA concatenation_wrapper column_alias
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_xml_namespaces_clause10134);
            	        if  (this->hasException())
            	        {
            	            goto rulexml_namespaces_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_concatenation_wrapper_in_xml_namespaces_clause10136);
            	        concatenation_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_namespaces_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_column_alias_in_xml_namespaces_clause10138);
            	        m_gPLSQLParser->column_alias();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_namespaces_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop345;	/* break out of the loop */
            	    break;
                }
            }
            loop345: ; /* Jump out to here if this rule does not match */


            // PLSQL_DMLParser.g:1068:13: ( ( default_key )=> xml_general_default_part )?
            {
                int alt346=2;
                {
                    int LA346_0 = this->LA(1);
                    if ( (this->msynpred( antlr3::ClassForwarder<synpred50_PLSQL_DMLParser>() )) && (LA346_0 == SQL92_RESERVED_DEFAULT))
                    {
                        alt346=1;
                    }
                }
                switch (alt346)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1068:14: ( default_key )=> xml_general_default_part
            	    {
            	        this->followPush(FOLLOW_xml_general_default_part_in_xml_namespaces_clause10160);
            	        xml_general_default_part();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_namespaces_clauseEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_PAREN, &FOLLOW_RIGHT_PAREN_in_xml_namespaces_clause10172);
            if  (this->hasException())
            {
                goto rulexml_namespaces_clauseEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexml_namespaces_clauseEx; /* Prevent compiler warnings */
    rulexml_namespaces_clauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xml_namespaces_clause */

/**
 * $ANTLR start xml_table_column
 * PLSQL_DMLParser.g:1072:1: xml_table_column : xml_column_name ( for_key ordinality_key | type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )? ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::xml_table_column()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1073:5: ( xml_column_name ( for_key ordinality_key | type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )? ) )
        // PLSQL_DMLParser.g:1073:10: xml_column_name ( for_key ordinality_key | type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )? )
        {
            this->followPush(FOLLOW_xml_column_name_in_xml_table_column10192);
            m_gPLSQLParser->xml_column_name();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_table_columnEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1074:5: ( for_key ordinality_key | type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )? )
            {
                int alt349=2;
                switch ( this->LA(1) )
                {
                case SQL92_RESERVED_FOR:
                	{
                		alt349=1;
                	}
                    break;
                case DELIMITED_ID:
                case REGULAR_ID:
                case SQL92_RESERVED_DATE:
                	{
                		alt349=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 349 );
                    ex->set_state( 0 );


                    goto rulexml_table_columnEx;

                }

                switch (alt349)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1074:10: for_key ordinality_key
            	    {
            	        this->followPush(FOLLOW_for_key_in_xml_table_column10203);
            	        m_gPLSQLParser->for_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_table_columnEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_ordinality_key_in_xml_table_column10205);
            	        m_gPLSQLParser->ordinality_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_table_columnEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:1075:10: type_spec ( path_key concatenation_wrapper )? ( ( default_key )=> xml_general_default_part )?
            	    {
            	        this->followPush(FOLLOW_type_spec_in_xml_table_column10216);
            	        m_gPLSQLParser->type_spec();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_table_columnEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:1075:20: ( path_key concatenation_wrapper )?
            	        {
            	            int alt347=2;
            	            {
            	                int LA347_0 = this->LA(1);
            	                if ( ((equalsIgnoreCase(LT(1)->getText(), "PATH"))) && (LA347_0 == REGULAR_ID))
            	                {
            	                    alt347=1;
            	                }
            	            }
            	            switch (alt347)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:1075:21: path_key concatenation_wrapper
            	        	    {
            	        	        this->followPush(FOLLOW_path_key_in_xml_table_column10219);
            	        	        m_gPLSQLParser->path_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexml_table_columnEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_concatenation_wrapper_in_xml_table_column10221);
            	        	        concatenation_wrapper();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexml_table_columnEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // PLSQL_DMLParser.g:1075:54: ( ( default_key )=> xml_general_default_part )?
            	        {
            	            int alt348=2;
            	            {
            	                int LA348_0 = this->LA(1);
            	                if ( (this->msynpred( antlr3::ClassForwarder<synpred51_PLSQL_DMLParser>() )) && (LA348_0 == SQL92_RESERVED_DEFAULT))
            	                {
            	                    alt348=1;
            	                }
            	            }
            	            switch (alt348)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:1075:55: ( default_key )=> xml_general_default_part
            	        	    {
            	        	        this->followPush(FOLLOW_xml_general_default_part_in_xml_table_column10231);
            	        	        xml_general_default_part();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexml_table_columnEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulexml_table_columnEx; /* Prevent compiler warnings */
    rulexml_table_columnEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xml_table_column */

/**
 * $ANTLR start xml_general_default_part
 * PLSQL_DMLParser.g:1079:1: xml_general_default_part : default_key concatenation_wrapper ;
 */
void
PLSQLParser_PLSQL_DMLParser::xml_general_default_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1080:5: ( default_key concatenation_wrapper )
        // PLSQL_DMLParser.g:1080:10: default_key concatenation_wrapper
        {
            this->followPush(FOLLOW_default_key_in_xml_general_default_part10259);
            m_gPLSQLParser->default_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_general_default_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_concatenation_wrapper_in_xml_general_default_part10261);
            concatenation_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_general_default_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexml_general_default_partEx; /* Prevent compiler warnings */
    rulexml_general_default_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xml_general_default_part */

/**
 * $ANTLR start xml_multiuse_expression_element
 * PLSQL_DMLParser.g:1083:1: xml_multiuse_expression_element : expression ( as_key ( id_expression | evalname_key concatenation ) )? ;
 */
void
PLSQLParser_PLSQL_DMLParser::xml_multiuse_expression_element()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1084:5: ( expression ( as_key ( id_expression | evalname_key concatenation ) )? )
        // PLSQL_DMLParser.g:1084:10: expression ( as_key ( id_expression | evalname_key concatenation ) )?
        {
            this->followPush(FOLLOW_expression_in_xml_multiuse_expression_element10281);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexml_multiuse_expression_elementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1084:21: ( as_key ( id_expression | evalname_key concatenation ) )?
            {
                int alt351=2;
                switch ( this->LA(1) )
                {
                    case SQL92_RESERVED_AS:
                    	{
                    		alt351=1;
                    	}
                        break;
                }

                switch (alt351)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1084:22: as_key ( id_expression | evalname_key concatenation )
            	    {
            	        this->followPush(FOLLOW_as_key_in_xml_multiuse_expression_element10284);
            	        m_gPLSQLParser->as_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexml_multiuse_expression_elementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:1084:29: ( id_expression | evalname_key concatenation )
            	        {
            	            int alt350=2;
            	            switch ( this->LA(1) )
            	            {
            	            case REGULAR_ID:
            	            	{
            	            		{
            	            		    int LA350_1 = this->LA(2);
            	            		    if ( (LA350_1 == COMMA || LA350_1 == RIGHT_PAREN))
            	            		    {
            	            		        alt350=1;
            	            		    }
            	            		    else if ( ((equalsIgnoreCase(LT(1)->getText(), "EVALNAME"))) && (LA350_1 == APPROXIMATE_NUM_LIT || LA350_1 == BINDVAR || ((LA350_1 >= CHAR_STRING) && (LA350_1 <= COLON)) || LA350_1 == DELIMITED_ID || LA350_1 == EXACT_NUM_LIT || LA350_1 == INTRODUCER || LA350_1 == LEFT_PAREN || ((LA350_1 >= MINUS_SIGN) && (LA350_1 <= NATIONAL_CHAR_STRING_LIT)) || LA350_1 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA350_1 == PLUS_SIGN || LA350_1 == REGULAR_ID || LA350_1 == SQL92_RESERVED_ALL || LA350_1 == SQL92_RESERVED_ANY || LA350_1 == SQL92_RESERVED_CASE || LA350_1 == SQL92_RESERVED_DATE || LA350_1 == SQL92_RESERVED_DEFAULT || LA350_1 == SQL92_RESERVED_DISTINCT || ((LA350_1 >= SQL92_RESERVED_EXISTS) && (LA350_1 <= SQL92_RESERVED_FALSE)) || LA350_1 == SQL92_RESERVED_NULL || LA350_1 == SQL92_RESERVED_PRIOR || LA350_1 == SQL92_RESERVED_TRUE || LA350_1 == UNSIGNED_INTEGER))
            	            		    {
            	            		        alt350=2;
            	            		    }
            	            		    else
            	            		    {
            	            		        if (this->get_backtracking()>0)
            	            		        {
            	            		            this->set_failedflag( true );
            	            		            return ;
            	            		        }


            	            		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	            		        ex->set_decisionNum( 350 );
            	            		        ex->set_state( 1 );


            	            		        goto rulexml_multiuse_expression_elementEx;

            	            		    }
            	            		}
            	            	}
            	                break;
            	            case DELIMITED_ID:
            	            	{
            	            		alt350=1;
            	            	}
            	                break;

            	            default:
            	                if (this->get_backtracking()>0)
            	                {
            	                    this->set_failedflag( true );
            	                    return ;
            	                }

            	                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            	                ex->set_decisionNum( 350 );
            	                ex->set_state( 0 );


            	                goto rulexml_multiuse_expression_elementEx;

            	            }

            	            switch (alt350)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:1084:30: id_expression
            	        	    {
            	        	        this->followPush(FOLLOW_id_expression_in_xml_multiuse_expression_element10287);
            	        	        m_gPLSQLParser->id_expression();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexml_multiuse_expression_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // PLSQL_DMLParser.g:1084:45: evalname_key concatenation
            	        	    {
            	        	        this->followPush(FOLLOW_evalname_key_in_xml_multiuse_expression_element10290);
            	        	        m_gPLSQLParser->evalname_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexml_multiuse_expression_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_concatenation_in_xml_multiuse_expression_element10292);
            	        	        concatenation();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexml_multiuse_expression_elementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulexml_multiuse_expression_elementEx; /* Prevent compiler warnings */
    rulexml_multiuse_expression_elementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xml_multiuse_expression_element */

/**
 * $ANTLR start xmlroot_param_version_part
 * PLSQL_DMLParser.g:1087:1: xmlroot_param_version_part : version_key ( no_key value_key | expression_wrapper ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::xmlroot_param_version_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1088:5: ( version_key ( no_key value_key | expression_wrapper ) )
        // PLSQL_DMLParser.g:1088:10: version_key ( no_key value_key | expression_wrapper )
        {
            this->followPush(FOLLOW_version_key_in_xmlroot_param_version_part10316);
            m_gPLSQLParser->version_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexmlroot_param_version_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1088:22: ( no_key value_key | expression_wrapper )
            {
                int alt352=2;
                switch ( this->LA(1) )
                {
                case REGULAR_ID:
                	{
                		{
                		    int LA352_1 = this->LA(2);
                		    if ( (LA352_1 == REGULAR_ID))
                		    {
                		        {
                		            int LA352_3 = this->LA(3);
                		            if ( ((equalsIgnoreCase(LT(1)->getText(), "NO"))))
                		            {
                		                alt352=1;
                		            }
                		            else if ( (true))
                		            {
                		                alt352=2;
                		            }
                		            else
                		            {
                		                if (this->get_backtracking()>0)
                		                {
                		                    this->set_failedflag( true );
                		                    return ;
                		                }


                		                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		                ex->set_decisionNum( 352 );
                		                ex->set_state( 3 );


                		                goto rulexmlroot_param_version_partEx;

                		            }
                		        }
                		    }
                		    else if ( (LA352_1 == MINUS_SIGN || LA352_1 == PLUS_SIGN))
                		    {
                		        alt352=2;
                		    }
                		    else if ( (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
                		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
                		             )) )) && (LA352_1 == PLSQL_NON_RESERVED_CONNECT_BY_ROOT || LA352_1 == SQL92_RESERVED_ALL || LA352_1 == SQL92_RESERVED_DISTINCT || LA352_1 == SQL92_RESERVED_PRIOR))
                		    {
                		        alt352=2;
                		    }
                		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||(( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
                		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
                		             )) )))) && (LA352_1 == DELIMITED_ID))
                		    {
                		        alt352=2;
                		    }
                		    else if ( (LA352_1 == SQL92_RESERVED_CASE))
                		    {
                		        alt352=2;
                		    }
                		    else if ( (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
                		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
                		             )) )) && (LA352_1 == SQL92_RESERVED_ANY || LA352_1 == SQL92_RESERVED_EXISTS))
                		    {
                		        alt352=2;
                		    }
                		    else if ( ((((equalsIgnoreCase(LT(1)->getText(), "INTERVAL")))||(( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
                		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
                		             )) )))) && (LA352_1 == INTRODUCER))
                		    {
                		        alt352=2;
                		    }
                		    else if ( (LA352_1 == BINDVAR || LA352_1 == COLON))
                		    {
                		        alt352=2;
                		    }
                		    else if ( (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
                		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
                		             )) )) && (LA352_1 == APPROXIMATE_NUM_LIT || LA352_1 == EXACT_NUM_LIT || LA352_1 == SQL92_RESERVED_DATE || LA352_1 == UNSIGNED_INTEGER))
                		    {
                		        alt352=2;
                		    }
                		    else if ( (((LA352_1 >= CHAR_STRING) && (LA352_1 <= CHAR_STRING_PERL)) || LA352_1 == NATIONAL_CHAR_STRING_LIT))
                		    {
                		        alt352=2;
                		    }
                		    else if ( (( ((equalsIgnoreCase(LT(1)->getText(), "NEW"))) && (( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
                		                equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
                		             )) )) && (LA352_1 == SQL92_RESERVED_DEFAULT || LA352_1 == SQL92_RESERVED_FALSE || LA352_1 == SQL92_RESERVED_NULL || LA352_1 == SQL92_RESERVED_TRUE))
                		    {
                		        alt352=2;
                		    }
                		    else if ( (LA352_1 == ASTERISK || LA352_1 == CARRET_OPERATOR_PART || LA352_1 == COMMA || LA352_1 == CONCATENATION_OP || LA352_1 == EQUALS_OP || LA352_1 == EXCLAMATION_OPERATOR_PART || ((LA352_1 >= GREATER_THAN_OP) && (LA352_1 <= GREATER_THAN_OR_EQUALS_OP)) || ((LA352_1 >= LEFT_BRACKET) && (LA352_1 <= LESS_THAN_OR_EQUALS_OP)) || LA352_1 == NOT_EQUAL_OP || LA352_1 == PERIOD || LA352_1 == RIGHT_PAREN || LA352_1 == SOLIDUS || LA352_1 == SQL92_RESERVED_AND || LA352_1 == SQL92_RESERVED_BETWEEN || LA352_1 == SQL92_RESERVED_IN || ((LA352_1 >= SQL92_RESERVED_IS) && (LA352_1 <= SQL92_RESERVED_NOT)) || LA352_1 == SQL92_RESERVED_OR || LA352_1 == VERTICAL_BAR))
                		    {
                		        alt352=2;
                		    }
                		    else
                		    {
                		        if (this->get_backtracking()>0)
                		        {
                		            this->set_failedflag( true );
                		            return ;
                		        }


                		        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                		        ex->set_decisionNum( 352 );
                		        ex->set_state( 1 );


                		        goto rulexmlroot_param_version_partEx;

                		    }
                		}
                	}
                    break;
                case APPROXIMATE_NUM_LIT:
                case BINDVAR:
                case CHAR_STRING:
                case CHAR_STRING_PERL:
                case COLON:
                case DELIMITED_ID:
                case EXACT_NUM_LIT:
                case INTRODUCER:
                case LEFT_PAREN:
                case MINUS_SIGN:
                case NATIONAL_CHAR_STRING_LIT:
                case PLSQL_NON_RESERVED_CONNECT_BY_ROOT:
                case PLUS_SIGN:
                case SQL92_RESERVED_ALL:
                case SQL92_RESERVED_ANY:
                case SQL92_RESERVED_CASE:
                case SQL92_RESERVED_CURSOR:
                case SQL92_RESERVED_DATE:
                case SQL92_RESERVED_DEFAULT:
                case SQL92_RESERVED_DISTINCT:
                case SQL92_RESERVED_EXISTS:
                case SQL92_RESERVED_FALSE:
                case SQL92_RESERVED_NOT:
                case SQL92_RESERVED_NULL:
                case SQL92_RESERVED_PRIOR:
                case SQL92_RESERVED_TRUE:
                case UNSIGNED_INTEGER:
                	{
                		alt352=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 352 );
                    ex->set_state( 0 );


                    goto rulexmlroot_param_version_partEx;

                }

                switch (alt352)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1088:23: no_key value_key
            	    {
            	        this->followPush(FOLLOW_no_key_in_xmlroot_param_version_part10319);
            	        m_gPLSQLParser->no_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexmlroot_param_version_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_value_key_in_xmlroot_param_version_part10321);
            	        m_gPLSQLParser->value_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexmlroot_param_version_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:1088:40: expression_wrapper
            	    {
            	        this->followPush(FOLLOW_expression_wrapper_in_xmlroot_param_version_part10323);
            	        expression_wrapper();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexmlroot_param_version_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlroot_param_version_partEx; /* Prevent compiler warnings */
    rulexmlroot_param_version_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlroot_param_version_part */

/**
 * $ANTLR start xmlroot_param_standalone_part
 * PLSQL_DMLParser.g:1091:1: xmlroot_param_standalone_part : standalone_key ( yes_key | no_key ( value_key )? ) ;
 */
void
PLSQLParser_PLSQL_DMLParser::xmlroot_param_standalone_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1092:5: ( standalone_key ( yes_key | no_key ( value_key )? ) )
        // PLSQL_DMLParser.g:1092:10: standalone_key ( yes_key | no_key ( value_key )? )
        {
            this->followPush(FOLLOW_standalone_key_in_xmlroot_param_standalone_part10344);
            m_gPLSQLParser->standalone_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexmlroot_param_standalone_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // PLSQL_DMLParser.g:1092:25: ( yes_key | no_key ( value_key )? )
            {
                int alt354=2;
                {
                    int LA354_0 = this->LA(1);
                    if ( ((((equalsIgnoreCase(LT(1)->getText(), "YES")))||((equalsIgnoreCase(LT(1)->getText(), "NO"))))) && (LA354_0 == REGULAR_ID))
                    {
                        {
                            int LA354_1 = this->LA(2);
                            if ( ((equalsIgnoreCase(LT(1)->getText(), "YES"))))
                            {
                                alt354=1;
                            }
                            else if ( ((equalsIgnoreCase(LT(1)->getText(), "NO"))))
                            {
                                alt354=2;
                            }
                            else
                            {
                                if (this->get_backtracking()>0)
                                {
                                    this->set_failedflag( true );
                                    return ;
                                }


                                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                ex->set_decisionNum( 354 );
                                ex->set_state( 1 );


                                goto rulexmlroot_param_standalone_partEx;

                            }
                        }
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 354 );
                        ex->set_state( 0 );


                        goto rulexmlroot_param_standalone_partEx;

                    }
                }
                switch (alt354)
                {
            	case 1:
            	    // PLSQL_DMLParser.g:1092:26: yes_key
            	    {
            	        this->followPush(FOLLOW_yes_key_in_xmlroot_param_standalone_part10347);
            	        m_gPLSQLParser->yes_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexmlroot_param_standalone_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // PLSQL_DMLParser.g:1092:34: no_key ( value_key )?
            	    {
            	        this->followPush(FOLLOW_no_key_in_xmlroot_param_standalone_part10349);
            	        m_gPLSQLParser->no_key();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulexmlroot_param_standalone_partEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // PLSQL_DMLParser.g:1092:41: ( value_key )?
            	        {
            	            int alt353=2;
            	            switch ( this->LA(1) )
            	            {
            	                case REGULAR_ID:
            	                	{
            	                		alt353=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt353)
            	            {
            	        	case 1:
            	        	    // PLSQL_DMLParser.g:1092:41: value_key
            	        	    {
            	        	        this->followPush(FOLLOW_value_key_in_xmlroot_param_standalone_part10351);
            	        	        m_gPLSQLParser->value_key();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulexmlroot_param_standalone_partEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlroot_param_standalone_partEx; /* Prevent compiler warnings */
    rulexmlroot_param_standalone_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlroot_param_standalone_part */

/**
 * $ANTLR start xmlserialize_param_enconding_part
 * PLSQL_DMLParser.g:1095:1: xmlserialize_param_enconding_part : encoding_key concatenation_wrapper ;
 */
void
PLSQLParser_PLSQL_DMLParser::xmlserialize_param_enconding_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1096:5: ( encoding_key concatenation_wrapper )
        // PLSQL_DMLParser.g:1096:10: encoding_key concatenation_wrapper
        {
            this->followPush(FOLLOW_encoding_key_in_xmlserialize_param_enconding_part10373);
            m_gPLSQLParser->encoding_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexmlserialize_param_enconding_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_concatenation_wrapper_in_xmlserialize_param_enconding_part10375);
            concatenation_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexmlserialize_param_enconding_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlserialize_param_enconding_partEx; /* Prevent compiler warnings */
    rulexmlserialize_param_enconding_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlserialize_param_enconding_part */

/**
 * $ANTLR start xmlserialize_param_version_part
 * PLSQL_DMLParser.g:1099:1: xmlserialize_param_version_part : version_key concatenation_wrapper ;
 */
void
PLSQLParser_PLSQL_DMLParser::xmlserialize_param_version_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // PLSQL_DMLParser.g:1100:5: ( version_key concatenation_wrapper )
        // PLSQL_DMLParser.g:1100:10: version_key concatenation_wrapper
        {
            this->followPush(FOLLOW_version_key_in_xmlserialize_param_version_part10395);
            m_gPLSQLParser->version_key();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexmlserialize_param_version_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_concatenation_wrapper_in_xmlserialize_param_version_part10397);
            concatenation_wrapper();

            this->followPop();
            if  (this->hasException())
            {
                goto rulexmlserialize_param_version_partEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulexmlserialize_param_version_partEx; /* Prevent compiler warnings */
    rulexmlserialize_param_version_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlserialize_param_version_part */

/**
 * $ANTLR start xmlserialize_param_ident_part
 * PLSQL_DMLParser.g:1103:1: xmlserialize_param_ident_part : ( no_key indent_key | indent_key ( size_key EQUALS_OP concatenation_wrapper )? );
 */
void
PLSQLParser_PLSQL_DMLParser::xmlserialize_param_ident_part()
{
        PLSQLParser_PLSQL_DMLParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  PLSQL_DMLParser.g:1104:5: ( no_key indent_key | indent_key ( size_key EQUALS_OP concatenation_wrapper )? )

            ANTLR_UINT32 alt356;

            alt356=2;

            {
                int LA356_0 = this->LA(1);
                if ( ((((equalsIgnoreCase(LT(1)->getText(), "NO")))||((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))) && (LA356_0 == REGULAR_ID))
                {
                    {
                        int LA356_1 = this->LA(2);
                        if ( ((((equalsIgnoreCase(LT(1)->getText(), "NO")))||((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))) && (LA356_1 == REGULAR_ID))
                        {
                            {
                                int LA356_2 = this->LA(3);
                                if ( ((((equalsIgnoreCase(LT(1)->getText(), "NO")))||((equalsIgnoreCase(LT(1)->getText(), "INDENT"))))) && (LA356_2 == REGULAR_ID))
                                {
                                    {
                                        int LA356_4 = this->LA(4);
                                        if ( ((equalsIgnoreCase(LT(1)->getText(), "NO"))) && (LA356_4 == REGULAR_ID))
                                        {
                                            alt356=1;
                                        }
                                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "INDENT"))) && (LA356_4 == RIGHT_PAREN))
                                        {
                                            alt356=2;
                                        }
                                        else
                                        {
                                            if (this->get_backtracking()>0)
                                            {
                                                this->set_failedflag( true );
                                                return ;
                                            }


                                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                            ex->set_decisionNum( 356 );
                                            ex->set_state( 4 );


                                            goto rulexmlserialize_param_ident_partEx;

                                        }
                                    }
                                }
                                else if ( ((equalsIgnoreCase(LT(1)->getText(), "NO"))) && (LA356_2 == RIGHT_PAREN))
                                {
                                    alt356=1;
                                }
                                else
                                {
                                    if (this->get_backtracking()>0)
                                    {
                                        this->set_failedflag( true );
                                        return ;
                                    }


                                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                                    ex->set_decisionNum( 356 );
                                    ex->set_state( 2 );


                                    goto rulexmlserialize_param_ident_partEx;

                                }
                            }
                        }
                        else if ( ((equalsIgnoreCase(LT(1)->getText(), "INDENT"))) && (LA356_1 == RIGHT_PAREN || LA356_1 == SQL92_RESERVED_SIZE))
                        {
                            alt356=2;
                        }
                        else
                        {
                            if (this->get_backtracking()>0)
                            {
                                this->set_failedflag( true );
                                return ;
                            }


                            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                            ex->set_decisionNum( 356 );
                            ex->set_state( 1 );


                            goto rulexmlserialize_param_ident_partEx;

                        }
                    }
                }
                else
                {
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }


                    ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 356 );
                    ex->set_state( 0 );


                    goto rulexmlserialize_param_ident_partEx;

                }
            }
            switch (alt356)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:1104:10: no_key indent_key
        	    {
        	        this->followPush(FOLLOW_no_key_in_xmlserialize_param_ident_part10417);
        	        m_gPLSQLParser->no_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulexmlserialize_param_ident_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_indent_key_in_xmlserialize_param_ident_part10419);
        	        m_gPLSQLParser->indent_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulexmlserialize_param_ident_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:1105:10: indent_key ( size_key EQUALS_OP concatenation_wrapper )?
        	    {
        	        this->followPush(FOLLOW_indent_key_in_xmlserialize_param_ident_part10430);
        	        m_gPLSQLParser->indent_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulexmlserialize_param_ident_partEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // PLSQL_DMLParser.g:1105:21: ( size_key EQUALS_OP concatenation_wrapper )?
        	        {
        	            int alt355=2;
        	            switch ( this->LA(1) )
        	            {
        	                case SQL92_RESERVED_SIZE:
        	                	{
        	                		alt355=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt355)
        	            {
        	        	case 1:
        	        	    // PLSQL_DMLParser.g:1105:22: size_key EQUALS_OP concatenation_wrapper
        	        	    {
        	        	        this->followPush(FOLLOW_size_key_in_xmlserialize_param_ident_part10433);
        	        	        m_gPLSQLParser->size_key();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulexmlserialize_param_ident_partEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(EQUALS_OP, &FOLLOW_EQUALS_OP_in_xmlserialize_param_ident_part10435);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulexmlserialize_param_ident_partEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_concatenation_wrapper_in_xmlserialize_param_ident_part10437);
        	        	        concatenation_wrapper();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulexmlserialize_param_ident_partEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulexmlserialize_param_ident_partEx; /* Prevent compiler warnings */
    rulexmlserialize_param_ident_partEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end xmlserialize_param_ident_part */

// $ANTLR start synpredRule synpred1_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred1_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:69:28: ( order_key ( siblings_key )? by_key )
    // PLSQL_DMLParser.g:69:29: order_key ( siblings_key )? by_key
    {
        this->followPush(FOLLOW_order_key_in_synpred1_PLSQL_DMLParser357);
        m_gPLSQLParser->order_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred1_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        // PLSQL_DMLParser.g:69:39: ( siblings_key )?
        {
            int alt357=2;
            {
                int LA357_0 = this->LA(1);
                if ( ((equalsIgnoreCase(LT(1)->getText(), "SIBLINGS"))) && (LA357_0 == REGULAR_ID))
                {
                    alt357=1;
                }
            }
            switch (alt357)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:69:39: siblings_key
        	    {
        	        this->followPush(FOLLOW_siblings_key_in_synpred1_PLSQL_DMLParser359);
        	        m_gPLSQLParser->siblings_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred1_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

        this->followPush(FOLLOW_by_key_in_synpred1_PLSQL_DMLParser362);
        m_gPLSQLParser->by_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred1_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred1_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred1_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred1_PLSQL_DMLParser

// $ANTLR start synpredRule synpred2_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred2_PLSQL_DMLParser_fragment(  )
{
    {
        //  PLSQL_DMLParser.g:109:10: ( distinct_key | unique_key | all_key )

        ANTLR_UINT32 alt358;

        alt358=3;

        switch ( this->LA(1) )
        {
        case SQL92_RESERVED_DISTINCT:
        	{
        		alt358=1;
        	}
            break;
        case SQL92_RESERVED_UNIQUE:
        	{
        		alt358=2;
        	}
            break;
        case SQL92_RESERVED_ALL:
        	{
        		alt358=3;
        	}
            break;

        default:
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 358 );
            ex->set_state( 0 );


            goto rulesynpred2_PLSQL_DMLParserEx;

        }

        switch (alt358)
        {
    	case 1:
    	    // PLSQL_DMLParser.g:109:11: distinct_key
    	    {
    	        this->followPush(FOLLOW_distinct_key_in_synpred2_PLSQL_DMLParser763);
    	        m_gPLSQLParser->distinct_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred2_PLSQL_DMLParserEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;
    	case 2:
    	    // PLSQL_DMLParser.g:109:24: unique_key
    	    {
    	        this->followPush(FOLLOW_unique_key_in_synpred2_PLSQL_DMLParser765);
    	        m_gPLSQLParser->unique_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred2_PLSQL_DMLParserEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;
    	case 3:
    	    // PLSQL_DMLParser.g:109:35: all_key
    	    {
    	        this->followPush(FOLLOW_all_key_in_synpred2_PLSQL_DMLParser767);
    	        m_gPLSQLParser->all_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred2_PLSQL_DMLParserEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;

        }
    }

goto rulesynpred2_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred2_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred2_PLSQL_DMLParser

// $ANTLR start synpredRule synpred3_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred3_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:128:10: ( tableview_name PERIOD ASTERISK )
    // PLSQL_DMLParser.g:128:11: tableview_name PERIOD ASTERISK
    {
        this->followPush(FOLLOW_tableview_name_in_synpred3_PLSQL_DMLParser936);
        m_gPLSQLParser->tableview_name();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred3_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(PERIOD, &FOLLOW_PERIOD_in_synpred3_PLSQL_DMLParser938);
        if  (this->hasException())
        {
            goto rulesynpred3_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(ASTERISK, &FOLLOW_ASTERISK_in_synpred3_PLSQL_DMLParser940);
        if  (this->hasException())
        {
            goto rulesynpred3_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred3_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred3_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred3_PLSQL_DMLParser

// $ANTLR start synpredRule synpred4_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred4_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:146:10: ( LEFT_PAREN ( select_key | with_key ) )
    // PLSQL_DMLParser.g:146:11: LEFT_PAREN ( select_key | with_key )
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred4_PLSQL_DMLParser1047);
        if  (this->hasException())
        {
            goto rulesynpred4_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        // PLSQL_DMLParser.g:146:22: ( select_key | with_key )
        {
            int alt359=2;
            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_SELECT:
            	{
            		alt359=1;
            	}
                break;
            case SQL92_RESERVED_WITH:
            	{
            		alt359=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 359 );
                ex->set_state( 0 );


                goto rulesynpred4_PLSQL_DMLParserEx;

            }

            switch (alt359)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:146:23: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred4_PLSQL_DMLParser1050);
        	        m_gPLSQLParser->select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred4_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:146:34: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred4_PLSQL_DMLParser1052);
        	        m_gPLSQLParser->with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred4_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

    }


goto rulesynpred4_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred4_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred4_PLSQL_DMLParser

// $ANTLR start synpredRule synpred5_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred5_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:147:10: ( LEFT_PAREN )
    // PLSQL_DMLParser.g:147:11: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred5_PLSQL_DMLParser1077);
        if  (this->hasException())
        {
            goto rulesynpred5_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred5_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred5_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred5_PLSQL_DMLParser

// $ANTLR start synpredRule synpred6_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred6_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:148:10: ( only_key LEFT_PAREN )
    // PLSQL_DMLParser.g:148:11: only_key LEFT_PAREN
    {
        this->followPush(FOLLOW_only_key_in_synpred6_PLSQL_DMLParser1108);
        m_gPLSQLParser->only_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred6_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred6_PLSQL_DMLParser1110);
        if  (this->hasException())
        {
            goto rulesynpred6_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred6_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred6_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred6_PLSQL_DMLParser

// $ANTLR start synpredRule synpred7_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred7_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:184:10: ( LEFT_PAREN ( select_key | with_key ) )
    // PLSQL_DMLParser.g:184:11: LEFT_PAREN ( select_key | with_key )
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred7_PLSQL_DMLParser1424);
        if  (this->hasException())
        {
            goto rulesynpred7_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        // PLSQL_DMLParser.g:184:22: ( select_key | with_key )
        {
            int alt360=2;
            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_SELECT:
            	{
            		alt360=1;
            	}
                break;
            case SQL92_RESERVED_WITH:
            	{
            		alt360=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 360 );
                ex->set_state( 0 );


                goto rulesynpred7_PLSQL_DMLParserEx;

            }

            switch (alt360)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:184:23: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred7_PLSQL_DMLParser1427);
        	        m_gPLSQLParser->select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred7_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:184:34: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred7_PLSQL_DMLParser1429);
        	        m_gPLSQLParser->with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred7_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

    }


goto rulesynpred7_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred7_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred7_PLSQL_DMLParser

// $ANTLR start synpredRule synpred8_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred8_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:185:10: ( LEFT_PAREN )
    // PLSQL_DMLParser.g:185:11: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred8_PLSQL_DMLParser1451);
        if  (this->hasException())
        {
            goto rulesynpred8_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred8_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred8_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred8_PLSQL_DMLParser

// $ANTLR start synpredRule synpred9_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred9_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:218:18: ( select_key )
    // PLSQL_DMLParser.g:218:19: select_key
    {
        this->followPush(FOLLOW_select_key_in_synpred9_PLSQL_DMLParser1765);
        m_gPLSQLParser->select_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred9_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred9_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred9_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred9_PLSQL_DMLParser

// $ANTLR start synpredRule synpred10_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred10_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:219:18: ( any_key )
    // PLSQL_DMLParser.g:219:19: any_key
    {
        this->followPush(FOLLOW_any_key_in_synpred10_PLSQL_DMLParser1790);
        m_gPLSQLParser->any_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred10_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred10_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred10_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred10_PLSQL_DMLParser

// $ANTLR start synpredRule synpred11_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred11_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:231:10: ( LEFT_PAREN )
    // PLSQL_DMLParser.g:231:11: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred11_PLSQL_DMLParser1906);
        if  (this->hasException())
        {
            goto rulesynpred11_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred11_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred11_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred11_PLSQL_DMLParser

// $ANTLR start synpredRule synpred12_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred12_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:259:15: ( LEFT_PAREN )
    // PLSQL_DMLParser.g:259:16: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred12_PLSQL_DMLParser2231);
        if  (this->hasException())
        {
            goto rulesynpred12_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred12_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred12_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred12_PLSQL_DMLParser

// $ANTLR start synpredRule synpred13_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred13_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:274:9: ( group_key )
    // PLSQL_DMLParser.g:274:10: group_key
    {
        this->followPush(FOLLOW_group_key_in_synpred13_PLSQL_DMLParser2362);
        m_gPLSQLParser->group_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred13_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred13_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred13_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred13_PLSQL_DMLParser

// $ANTLR start synpredRule synpred14_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred14_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:275:14: ( COMMA group_by_elements )
    // PLSQL_DMLParser.g:275:15: COMMA group_by_elements
    {
         this->matchToken(COMMA, &FOLLOW_COMMA_in_synpred14_PLSQL_DMLParser2387);
        if  (this->hasException())
        {
            goto rulesynpred14_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_group_by_elements_in_synpred14_PLSQL_DMLParser2389);
        group_by_elements();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred14_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred14_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred14_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred14_PLSQL_DMLParser

// $ANTLR start synpredRule synpred15_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred15_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:277:9: ( having_key )
    // PLSQL_DMLParser.g:277:10: having_key
    {
        this->followPush(FOLLOW_having_key_in_synpred15_PLSQL_DMLParser2423);
        m_gPLSQLParser->having_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred15_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred15_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred15_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred15_PLSQL_DMLParser

// $ANTLR start synpredRule synpred16_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred16_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:279:14: ( COMMA group_by_elements )
    // PLSQL_DMLParser.g:279:15: COMMA group_by_elements
    {
         this->matchToken(COMMA, &FOLLOW_COMMA_in_synpred16_PLSQL_DMLParser2463);
        if  (this->hasException())
        {
            goto rulesynpred16_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_group_by_elements_in_synpred16_PLSQL_DMLParser2465);
        group_by_elements();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred16_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred16_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred16_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred16_PLSQL_DMLParser

// $ANTLR start synpredRule synpred17_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred17_PLSQL_DMLParser_fragment(  )
{
    {
        //  PLSQL_DMLParser.g:298:10: ( rollup_key | cube_key )

        ANTLR_UINT32 alt361;

        alt361=2;

        {
            int LA361_0 = this->LA(1);
            if ( ((((equalsIgnoreCase(LT(1)->getText(), "CUBE")))||((equalsIgnoreCase(LT(1)->getText(), "ROLLUP"))))) && (LA361_0 == REGULAR_ID))
            {
                {
                    int LA361_1 = this->LA(2);
                    if ( ((equalsIgnoreCase(LT(1)->getText(), "ROLLUP"))))
                    {
                        alt361=1;
                    }
                    else if ( ((equalsIgnoreCase(LT(1)->getText(), "CUBE"))))
                    {
                        alt361=2;
                    }
                    else
                    {
                        if (this->get_backtracking()>0)
                        {
                            this->set_failedflag( true );
                            return ;
                        }


                        ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                        ex->set_decisionNum( 361 );
                        ex->set_state( 1 );


                        goto rulesynpred17_PLSQL_DMLParserEx;

                    }
                }
            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }


                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 361 );
                ex->set_state( 0 );


                goto rulesynpred17_PLSQL_DMLParserEx;

            }
        }
        switch (alt361)
        {
    	case 1:
    	    // PLSQL_DMLParser.g:298:11: rollup_key
    	    {
    	        this->followPush(FOLLOW_rollup_key_in_synpred17_PLSQL_DMLParser2621);
    	        m_gPLSQLParser->rollup_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred17_PLSQL_DMLParserEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;
    	case 2:
    	    // PLSQL_DMLParser.g:298:22: cube_key
    	    {
    	        this->followPush(FOLLOW_cube_key_in_synpred17_PLSQL_DMLParser2623);
    	        m_gPLSQLParser->cube_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred17_PLSQL_DMLParserEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;

        }
    }

goto rulesynpred17_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred17_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred17_PLSQL_DMLParser

// $ANTLR start synpredRule synpred18_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred18_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:299:10: ( LEFT_PAREN )
    // PLSQL_DMLParser.g:299:11: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred18_PLSQL_DMLParser2639);
        if  (this->hasException())
        {
            goto rulesynpred18_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred18_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred18_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred18_PLSQL_DMLParser

// $ANTLR start synpredRule synpred19_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred19_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:356:34: ( all_key )
    // PLSQL_DMLParser.g:356:35: all_key
    {
        this->followPush(FOLLOW_all_key_in_synpred19_PLSQL_DMLParser3097);
        m_gPLSQLParser->all_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred19_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred19_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred19_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred19_PLSQL_DMLParser

// $ANTLR start synpredRule synpred20_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred20_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:481:13: ( when_key matched_key )
    // PLSQL_DMLParser.g:481:14: when_key matched_key
    {
        this->followPush(FOLLOW_when_key_in_synpred20_PLSQL_DMLParser4048);
        m_gPLSQLParser->when_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred20_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_matched_key_in_synpred20_PLSQL_DMLParser4050);
        m_gPLSQLParser->matched_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred20_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred20_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred20_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred20_PLSQL_DMLParser

// $ANTLR start synpredRule synpred21_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred21_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:483:13: ( when_key not_key matched_key )
    // PLSQL_DMLParser.g:483:14: when_key not_key matched_key
    {
        this->followPush(FOLLOW_when_key_in_synpred21_PLSQL_DMLParser4083);
        m_gPLSQLParser->when_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred21_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_not_key_in_synpred21_PLSQL_DMLParser4085);
        m_gPLSQLParser->not_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred21_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_matched_key_in_synpred21_PLSQL_DMLParser4087);
        m_gPLSQLParser->matched_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred21_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred21_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred21_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred21_PLSQL_DMLParser

// $ANTLR start synpredRule synpred22_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred22_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:558:10: ( LEFT_PAREN )
    // PLSQL_DMLParser.g:558:11: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred22_PLSQL_DMLParser4676);
        if  (this->hasException())
        {
            goto rulesynpred22_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred22_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred22_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred22_PLSQL_DMLParser

// $ANTLR start synpredRule synpred23_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred23_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:567:32: ( unlimited_key )
    // PLSQL_DMLParser.g:567:33: unlimited_key
    {
        this->followPush(FOLLOW_unlimited_key_in_synpred23_PLSQL_DMLParser4741);
        m_gPLSQLParser->unlimited_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred23_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred23_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred23_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred23_PLSQL_DMLParser

// $ANTLR start synpredRule synpred24_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred24_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:578:12: ( LEFT_PAREN ( select_key | with_key ) )
    // PLSQL_DMLParser.g:578:13: LEFT_PAREN ( select_key | with_key )
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred24_PLSQL_DMLParser4840);
        if  (this->hasException())
        {
            goto rulesynpred24_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        // PLSQL_DMLParser.g:578:24: ( select_key | with_key )
        {
            int alt362=2;
            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_SELECT:
            	{
            		alt362=1;
            	}
                break;
            case SQL92_RESERVED_WITH:
            	{
            		alt362=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 362 );
                ex->set_state( 0 );


                goto rulesynpred24_PLSQL_DMLParserEx;

            }

            switch (alt362)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:578:25: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred24_PLSQL_DMLParser4843);
        	        m_gPLSQLParser->select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred24_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:578:38: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred24_PLSQL_DMLParser4847);
        	        m_gPLSQLParser->with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred24_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

    }


goto rulesynpred24_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred24_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred24_PLSQL_DMLParser

// $ANTLR start synpredRule synpred25_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred25_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:620:10: ( cursor_key LEFT_PAREN ( select_key | with_key ) )
    // PLSQL_DMLParser.g:620:11: cursor_key LEFT_PAREN ( select_key | with_key )
    {
        this->followPush(FOLLOW_cursor_key_in_synpred25_PLSQL_DMLParser5150);
        m_gPLSQLParser->cursor_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred25_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred25_PLSQL_DMLParser5152);
        if  (this->hasException())
        {
            goto rulesynpred25_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        // PLSQL_DMLParser.g:620:33: ( select_key | with_key )
        {
            int alt363=2;
            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_SELECT:
            	{
            		alt363=1;
            	}
                break;
            case SQL92_RESERVED_WITH:
            	{
            		alt363=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 363 );
                ex->set_state( 0 );


                goto rulesynpred25_PLSQL_DMLParserEx;

            }

            switch (alt363)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:620:34: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred25_PLSQL_DMLParser5155);
        	        m_gPLSQLParser->select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred25_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:620:45: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred25_PLSQL_DMLParser5157);
        	        m_gPLSQLParser->with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred25_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

    }


goto rulesynpred25_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred25_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred25_PLSQL_DMLParser

// $ANTLR start synpredRule synpred26_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred26_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:689:10: ( ( LEFT_PAREN )+ ( select_key | with_key ) )
    // PLSQL_DMLParser.g:689:11: ( LEFT_PAREN )+ ( select_key | with_key )
    {
        // PLSQL_DMLParser.g:689:11: ( LEFT_PAREN )+
        {
            int cnt364=0;

            for (;;)
            {
                int alt364=2;
        	switch ( this->LA(1) )
        	{
        	case LEFT_PAREN:
        		{
        			alt364=1;
        		}
        	    break;

        	}

        	switch (alt364)
        	{
        	    case 1:
        	        // PLSQL_DMLParser.g:689:11: LEFT_PAREN
        	        {
        	             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred26_PLSQL_DMLParser5767);
        	            if  (this->hasException())
        	            {
        	                goto rulesynpred26_PLSQL_DMLParserEx;
        	            }
        	            if (this->hasFailed())
        	            {
        	                return ;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt364 >= 1 )
        		{
        		    goto loop364;
        		}
        		if (this->get_backtracking()>0)
        		{
        		    this->set_failedflag( true );
        		    return ;
        		}

        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto rulesynpred26_PLSQL_DMLParserEx;
        	}
        	cnt364++;
            }
            loop364: ;	/* Jump to here if this rule does not match */
        }

        // PLSQL_DMLParser.g:689:23: ( select_key | with_key )
        {
            int alt365=2;
            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_SELECT:
            	{
            		alt365=1;
            	}
                break;
            case SQL92_RESERVED_WITH:
            	{
            		alt365=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 365 );
                ex->set_state( 0 );


                goto rulesynpred26_PLSQL_DMLParserEx;

            }

            switch (alt365)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:689:24: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred26_PLSQL_DMLParser5771);
        	        m_gPLSQLParser->select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred26_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:689:35: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred26_PLSQL_DMLParser5773);
        	        m_gPLSQLParser->with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred26_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

    }


goto rulesynpred26_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred26_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred26_PLSQL_DMLParser

// $ANTLR start synpredRule synpred27_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred27_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:719:10: ( interval_expression )
    // PLSQL_DMLParser.g:719:11: interval_expression
    {
        this->followPush(FOLLOW_interval_expression_in_synpred27_PLSQL_DMLParser6034);
        interval_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred27_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred27_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred27_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred27_PLSQL_DMLParser

// $ANTLR start synpredRule synpred28_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred28_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:734:11: ( any_key )
    // PLSQL_DMLParser.g:734:12: any_key
    {
        this->followPush(FOLLOW_any_key_in_synpred28_PLSQL_DMLParser6173);
        m_gPLSQLParser->any_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred28_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred28_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred28_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred28_PLSQL_DMLParser

// $ANTLR start synpredRule synpred29_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred29_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:734:58: ( any_key )
    // PLSQL_DMLParser.g:734:59: any_key
    {
        this->followPush(FOLLOW_any_key_in_synpred29_PLSQL_DMLParser6187);
        m_gPLSQLParser->any_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred29_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred29_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred29_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred29_PLSQL_DMLParser

// $ANTLR start synpredRule synpred30_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred30_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:759:18: ( select_key )
    // PLSQL_DMLParser.g:759:19: select_key
    {
        this->followPush(FOLLOW_select_key_in_synpred30_PLSQL_DMLParser6432);
        m_gPLSQLParser->select_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred30_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred30_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred30_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred30_PLSQL_DMLParser

// $ANTLR start synpredRule synpred31_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred31_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:760:18: ( LEFT_PAREN )
    // PLSQL_DMLParser.g:760:19: LEFT_PAREN
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred31_PLSQL_DMLParser6456);
        if  (this->hasException())
        {
            goto rulesynpred31_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred31_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred31_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred31_PLSQL_DMLParser

// $ANTLR start synpredRule synpred36_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred36_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:779:10: ({...}? => new_key unary_expression )
    // PLSQL_DMLParser.g:779:10: {...}? => new_key unary_expression
    {
        if ( !(( // input.LT(1).getText().equalsIgnoreCase("new") && !input.LT(2).getText().equals(".")}?
                    equalsIgnoreCase(LT(1)->getText(), "NEW") && !equalsIgnoreCase(LT(2)->getText(), "." )
                 )) )
        {
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), " // input.LT(1).getText().equalsIgnoreCase(\"new\") && !input.LT(2).getText().equals(\".\")}?\n            equalsIgnoreCase(LT(1)->getText(), \"NEW\") && !equalsIgnoreCase(LT(2)->getText(), \".\" )\n         " );
                ex->set_ruleName( "synpred36_PLSQL_DMLParser" );


        }

        this->followPush(FOLLOW_new_key_in_synpred36_PLSQL_DMLParser6602);
        m_gPLSQLParser->new_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred36_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_unary_expression_in_synpred36_PLSQL_DMLParser6604);
        unary_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred36_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred36_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred36_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred36_PLSQL_DMLParser

// $ANTLR start synpredRule synpred38_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred38_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:783:10: ( all_key unary_expression )
    // PLSQL_DMLParser.g:783:10: all_key unary_expression
    {
        this->followPush(FOLLOW_all_key_in_synpred38_PLSQL_DMLParser6628);
        m_gPLSQLParser->all_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred38_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_unary_expression_in_synpred38_PLSQL_DMLParser6630);
        unary_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred38_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred38_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred38_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred38_PLSQL_DMLParser

// $ANTLR start synpredRule synpred39_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred39_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:784:10: ({...}? case_statement[false] )
    // PLSQL_DMLParser.g:784:10: {...}? case_statement[false]
    {
        if ( !(( LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE )) )
        {
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            	ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, FAILED_PREDICATE_EXCEPTION, StreamType>( this->get_rec(), " LA(1) == SQL92_RESERVED_CASE || LA(2) == SQL92_RESERVED_CASE " );
                ex->set_ruleName( "synpred39_PLSQL_DMLParser" );


        }

        this->followPush(FOLLOW_case_statement_in_synpred39_PLSQL_DMLParser6643);
        case_statement(false);

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred39_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred39_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred39_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred39_PLSQL_DMLParser

// $ANTLR start synpredRule synpred40_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred40_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:785:10: ( quantified_expression )
    // PLSQL_DMLParser.g:785:10: quantified_expression
    {
        this->followPush(FOLLOW_quantified_expression_in_synpred40_PLSQL_DMLParser6655);
        quantified_expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred40_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred40_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred40_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred40_PLSQL_DMLParser

// $ANTLR start synpredRule synpred41_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred41_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:786:10: ( standard_function )
    // PLSQL_DMLParser.g:786:10: standard_function
    {
        this->followPush(FOLLOW_standard_function_in_synpred41_PLSQL_DMLParser6666);
        standard_function();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred41_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred41_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred41_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred41_PLSQL_DMLParser

// $ANTLR start synpredRule synpred42_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred42_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:795:10: ( ( label_name )? case_key when_key )
    // PLSQL_DMLParser.g:795:11: ( label_name )? case_key when_key
    {
        // PLSQL_DMLParser.g:795:11: ( label_name )?
        {
            int alt366=2;
            switch ( this->LA(1) )
            {
                case DELIMITED_ID:
                case REGULAR_ID:
                	{
                		alt366=1;
                	}
                    break;
            }

            switch (alt366)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:795:11: label_name
        	    {
        	        this->followPush(FOLLOW_label_name_in_synpred42_PLSQL_DMLParser6715);
        	        m_gPLSQLParser->label_name();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred42_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

        this->followPush(FOLLOW_case_key_in_synpred42_PLSQL_DMLParser6718);
        m_gPLSQLParser->case_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred42_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_when_key_in_synpred42_PLSQL_DMLParser6720);
        m_gPLSQLParser->when_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred42_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred42_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred42_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred42_PLSQL_DMLParser

// $ANTLR start synpredRule synpred43_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred43_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:833:10: ( table_element outer_join_sign )
    // PLSQL_DMLParser.g:833:11: table_element outer_join_sign
    {
        this->followPush(FOLLOW_table_element_in_synpred43_PLSQL_DMLParser6995);
        m_gPLSQLParser->table_element();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred43_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_outer_join_sign_in_synpred43_PLSQL_DMLParser6997);
        m_gPLSQLParser->outer_join_sign();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred43_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred43_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred43_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred43_PLSQL_DMLParser

// $ANTLR start synpredRule synpred45_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred45_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:835:10: ( constant )
    // PLSQL_DMLParser.g:835:10: constant
    {
        this->followPush(FOLLOW_constant_in_synpred45_PLSQL_DMLParser7026);
        m_gPLSQLParser->constant();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred45_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred45_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred45_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred45_PLSQL_DMLParser

// $ANTLR start synpredRule synpred46_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred46_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:836:10: ( general_element )
    // PLSQL_DMLParser.g:836:10: general_element
    {
        this->followPush(FOLLOW_general_element_in_synpred46_PLSQL_DMLParser7037);
        m_gPLSQLParser->general_element();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred46_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred46_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred46_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred46_PLSQL_DMLParser

// $ANTLR start synpredRule synpred47_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred47_PLSQL_DMLParser_fragment(  )
{
    {
        //  PLSQL_DMLParser.g:839:15: ( select_key | with_key )

        ANTLR_UINT32 alt367;

        alt367=2;

        switch ( this->LA(1) )
        {
        case SQL92_RESERVED_SELECT:
        	{
        		alt367=1;
        	}
            break;
        case SQL92_RESERVED_WITH:
        	{
        		alt367=2;
        	}
            break;

        default:
            if (this->get_backtracking()>0)
            {
                this->set_failedflag( true );
                return ;
            }

            ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 367 );
            ex->set_state( 0 );


            goto rulesynpred47_PLSQL_DMLParserEx;

        }

        switch (alt367)
        {
    	case 1:
    	    // PLSQL_DMLParser.g:839:17: select_key
    	    {
    	        this->followPush(FOLLOW_select_key_in_synpred47_PLSQL_DMLParser7077);
    	        m_gPLSQLParser->select_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred47_PLSQL_DMLParserEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;
    	case 2:
    	    // PLSQL_DMLParser.g:839:30: with_key
    	    {
    	        this->followPush(FOLLOW_with_key_in_synpred47_PLSQL_DMLParser7081);
    	        m_gPLSQLParser->with_key();

    	        this->followPop();
    	        if  (this->hasException())
    	        {
    	            goto rulesynpred47_PLSQL_DMLParserEx;
    	        }
    	        if (this->hasFailed())
    	        {
    	            return ;
    	        }


    	    }
    	    break;

        }
    }

goto rulesynpred47_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred47_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred47_PLSQL_DMLParser

// $ANTLR start synpredRule synpred48_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred48_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:854:12: ( LEFT_PAREN ( select_key | with_key ) )
    // PLSQL_DMLParser.g:854:13: LEFT_PAREN ( select_key | with_key )
    {
         this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred48_PLSQL_DMLParser7225);
        if  (this->hasException())
        {
            goto rulesynpred48_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        // PLSQL_DMLParser.g:854:24: ( select_key | with_key )
        {
            int alt368=2;
            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_SELECT:
            	{
            		alt368=1;
            	}
                break;
            case SQL92_RESERVED_WITH:
            	{
            		alt368=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 368 );
                ex->set_state( 0 );


                goto rulesynpred48_PLSQL_DMLParserEx;

            }

            switch (alt368)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:854:25: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred48_PLSQL_DMLParser7228);
        	        m_gPLSQLParser->select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred48_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:854:36: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred48_PLSQL_DMLParser7230);
        	        m_gPLSQLParser->with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred48_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

    }


goto rulesynpred48_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred48_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred48_PLSQL_DMLParser

// $ANTLR start synpredRule synpred49_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred49_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:868:12: ( multiset_key ( LEFT_PAREN )+ ( select_key | with_key ) )
    // PLSQL_DMLParser.g:868:13: multiset_key ( LEFT_PAREN )+ ( select_key | with_key )
    {
        this->followPush(FOLLOW_multiset_key_in_synpred49_PLSQL_DMLParser7432);
        m_gPLSQLParser->multiset_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred49_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        // PLSQL_DMLParser.g:868:26: ( LEFT_PAREN )+
        {
            int cnt369=0;

            for (;;)
            {
                int alt369=2;
        	switch ( this->LA(1) )
        	{
        	case LEFT_PAREN:
        		{
        			alt369=1;
        		}
        	    break;

        	}

        	switch (alt369)
        	{
        	    case 1:
        	        // PLSQL_DMLParser.g:868:26: LEFT_PAREN
        	        {
        	             this->matchToken(LEFT_PAREN, &FOLLOW_LEFT_PAREN_in_synpred49_PLSQL_DMLParser7434);
        	            if  (this->hasException())
        	            {
        	                goto rulesynpred49_PLSQL_DMLParserEx;
        	            }
        	            if (this->hasFailed())
        	            {
        	                return ;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt369 >= 1 )
        		{
        		    goto loop369;
        		}
        		if (this->get_backtracking()>0)
        		{
        		    this->set_failedflag( true );
        		    return ;
        		}

        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto rulesynpred49_PLSQL_DMLParserEx;
        	}
        	cnt369++;
            }
            loop369: ;	/* Jump to here if this rule does not match */
        }

        // PLSQL_DMLParser.g:868:38: ( select_key | with_key )
        {
            int alt370=2;
            switch ( this->LA(1) )
            {
            case SQL92_RESERVED_SELECT:
            	{
            		alt370=1;
            	}
                break;
            case SQL92_RESERVED_WITH:
            	{
            		alt370=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< PLSQLParser_PLSQL_DMLParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 370 );
                ex->set_state( 0 );


                goto rulesynpred49_PLSQL_DMLParserEx;

            }

            switch (alt370)
            {
        	case 1:
        	    // PLSQL_DMLParser.g:868:39: select_key
        	    {
        	        this->followPush(FOLLOW_select_key_in_synpred49_PLSQL_DMLParser7438);
        	        m_gPLSQLParser->select_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred49_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // PLSQL_DMLParser.g:868:50: with_key
        	    {
        	        this->followPush(FOLLOW_with_key_in_synpred49_PLSQL_DMLParser7440);
        	        m_gPLSQLParser->with_key();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred49_PLSQL_DMLParserEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }

    }


goto rulesynpred49_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred49_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred49_PLSQL_DMLParser

// $ANTLR start synpredRule synpred50_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred50_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:1068:14: ( default_key )
    // PLSQL_DMLParser.g:1068:15: default_key
    {
        this->followPush(FOLLOW_default_key_in_synpred50_PLSQL_DMLParser10156);
        m_gPLSQLParser->default_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred50_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred50_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred50_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred50_PLSQL_DMLParser

// $ANTLR start synpredRule synpred51_PLSQL_DMLParser
void PLSQLParser_PLSQL_DMLParser::msynpred51_PLSQL_DMLParser_fragment(  )
{
    // PLSQL_DMLParser.g:1075:55: ( default_key )
    // PLSQL_DMLParser.g:1075:56: default_key
    {
        this->followPush(FOLLOW_default_key_in_synpred51_PLSQL_DMLParser10227);
        m_gPLSQLParser->default_key();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred51_PLSQL_DMLParserEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }


goto rulesynpred51_PLSQL_DMLParserEx; /* Prevent compiler warnings */
rulesynpred51_PLSQL_DMLParserEx: ;
}
// $ANTLR end synpred51_PLSQL_DMLParser
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred11_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred11_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred13_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred13_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred20_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred20_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred26_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred26_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred31_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred31_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred40_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred40_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred22_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred22_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred1_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred1_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred45_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred45_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred12_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred12_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred14_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred14_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred21_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred21_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred16_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred16_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred47_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred47_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred4_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred4_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred19_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred19_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred8_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred8_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred9_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred9_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred27_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred27_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred6_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred6_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred39_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred39_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred2_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred2_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred51_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred51_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred28_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred28_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred23_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred23_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred10_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred10_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred18_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred18_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred17_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred17_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred24_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred24_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred38_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred38_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred25_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred25_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred3_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred3_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred50_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred50_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred5_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred5_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred42_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred42_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred46_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred46_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred43_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred43_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred48_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred48_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred7_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred7_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred36_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred36_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred30_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred30_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred15_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred15_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred41_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred41_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred49_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred49_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool PLSQLParser_PLSQL_DMLParser::msynpred( antlr3::ClassForwarder< synpred29_PLSQL_DMLParser >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred29_PLSQL_DMLParser_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

}

/* End of code
 * =============================================================================
 */
