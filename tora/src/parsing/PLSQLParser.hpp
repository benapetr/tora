/** \file
 *  This C++ header file was generated by $ANTLR version 3.5.1-SNAPSHOT
 *
 *     -  From the grammar source file : PLSQLParser.g
 *     -                            On : 2013-06-21 14:01:13
 *     -                for the parser : PLSQLParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
 * The parser PLSQLParser has the callable functions (rules) shown below,
 * which will invoke the code for the associated rule in the source grammar
 * assuming that the input stream is pointing to a token/text stream that could begin
 * this rule.
 *
 * For instance if you call the first (topmost) rule in a parser grammar, you will
 * get the results of a full parse, but calling a rule half way through the grammar will
 * allow you to pass part of a full token stream to the parser, such as for syntax checking
 * in editors and so on.
 *
 */
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram. 
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#ifndef	_PLSQLParser_H
#define _PLSQLParser_H
/* =============================================================================
 * Standard antlr3 C++ runtime definitions
 */
#include <antlr3.hpp>

/* End of standard antlr 3 runtime definitions
 * =============================================================================
 */


	#include "UserTraits.hpp"
	#include "PLSQLLexer.hpp"


// Include delegate definition header files
//
#include	"PLSQLParser_PLSQLKeys.hpp"
#include	"PLSQLParser_PLSQLCommons.hpp"
#include	"PLSQLParser_PLSQL_DMLParser.hpp"
#include	"PLSQLParser_SQLPLUSParser.hpp"




/**
 * Oracle(c) PL/SQL 11g Parser  
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#ifdef	WIN32
// Disable: Unreferenced parameter,							- Rules with parameters that are not used
//          constant conditional,							- ANTLR realizes that a prediction is always true (synpred usually)
//          initialized but unused variable					- tree rewrite variables declared but not needed
//          Unreferenced local variable						- lexer rule declares but does not always use _type
//          potentially unitialized variable used			- retval always returned from a rule
//			unreferenced local function has been removed	- susually getTokenNames or freeScope, they can go without warnigns
//
// These are only really displayed at warning level /W4 but that is the code ideal I am aiming at
// and the codegen must generate some of these warnings by necessity, apart from 4100, which is
// usually generated when a parser rule is given a parameter that it does not use. Mostly though
// this is a matter of orthogonality hence I disable that one.
//
#pragma warning( disable : 4100 )
#pragma warning( disable : 4101 )
#pragma warning( disable : 4127 )
#pragma warning( disable : 4189 )
#pragma warning( disable : 4505 )
#pragma warning( disable : 4701 )
#endif

/* ========================
 * BACKTRACKING IS ENABLED
 * ========================
 */

namespace  User  {

typedef PLSQLParserTraits PLSQLParserImplTraits;

 struct synpred1_PLSQLParser {}; 
 struct synpred2_PLSQLParser {}; 
 struct synpred3_PLSQLParser {}; 
 struct synpred4_PLSQLParser {}; 
 struct synpred5_PLSQLParser {}; 
 struct synpred6_PLSQLParser {}; 
 struct synpred7_PLSQLParser {}; 
 struct synpred8_PLSQLParser {}; 
 struct synpred9_PLSQLParser {}; 
 struct synpred10_PLSQLParser {}; 
 struct synpred11_PLSQLParser {}; 
 struct synpred12_PLSQLParser {}; 
 struct synpred13_PLSQLParser {}; 
 struct synpred14_PLSQLParser {}; 
 struct synpred15_PLSQLParser {}; 
 struct synpred16_PLSQLParser {}; 
 struct synpred17_PLSQLParser {}; 
 struct synpred18_PLSQLParser {}; 
 struct synpred19_PLSQLParser {}; 
 struct synpred20_PLSQLParser {}; 
 struct synpred22_PLSQLParser {}; 
 struct synpred23_PLSQLParser {}; 
 struct synpred24_PLSQLParser {}; 
 struct synpred26_PLSQLParser {}; 
 struct synpred27_PLSQLParser {}; 
 struct synpred29_PLSQLParser {}; 
 struct synpred30_PLSQLParser {}; 
 struct synpred31_PLSQLParser {}; 
 struct synpred32_PLSQLParser {}; 
 struct synpred33_PLSQLParser {}; 
 struct synpred34_PLSQLParser {}; 
 struct synpred35_PLSQLParser {}; 
 struct synpred36_PLSQLParser {}; 
 struct synpred37_PLSQLParser {}; 
 struct synpred39_PLSQLParser {}; 
 struct synpred40_PLSQLParser {}; 
 struct synpred41_PLSQLParser {}; 
 struct synpred42_PLSQLParser {}; 
 struct synpred43_PLSQLParser {}; 
 struct synpred44_PLSQLParser {}; 
 struct synpred47_PLSQLParser {}; 
 struct synpred48_PLSQLParser {}; 
 struct synpred49_PLSQLParser {}; 
 struct synpred50_PLSQLParser {}; 
 struct synpred51_PLSQLParser {}; 
 struct synpred52_PLSQLParser {}; 
 struct synpred55_PLSQLParser {}; 
 struct synpred56_PLSQLParser {}; 
 struct synpred58_PLSQLParser {}; 
 struct synpred59_PLSQLParser {}; 
 struct synpred60_PLSQLParser {}; 
 struct synpred61_PLSQLParser {}; 
 struct synpred62_PLSQLParser {}; 
 struct synpred65_PLSQLParser {}; 
 struct synpred66_PLSQLParser {}; 

class PLSQLParserTokens
{
public:
	/** Symbolic definitions of all the tokens that the parser will work with.
	 *
	 * Antlr will define EOF, but we can't use that as it it is too common in
	 * in C header files and that would be confusing. There is no way to filter this out at the moment
	 * so we just undef it here for now. That isn't the value we get back from C recognizers
	 * anyway. We are looking for ANTLR_TOKEN_EOF.
	 */
	enum Tokens 
	{
		EOF_TOKEN = PLSQLParserImplTraits::CommonTokenType::TOKEN_EOF
		, AMPERSAND = 4 
		, APPROXIMATE_NUM_LIT = 5 
		, ASSIGN_OP = 6 
		, ASTERISK = 7 
		, AT_SIGN = 8 
		, BINDVAR = 9 
		, BIT_STRING_LIT = 10 
		, CARRET_OPERATOR_PART = 11 
		, CHAR_STRING = 12 
		, CHAR_STRING_PERL = 13 
		, COLON = 14 
		, COMMA = 15 
		, COMMENT = 16 
		, CONCATENATION_OP = 17 
		, DELIMITED_ID = 18 
		, DOUBLE_ASTERISK = 19 
		, DOUBLE_PERIOD = 20 
		, EQUALS_OP = 21 
		, EXACT_NUM_LIT = 22 
		, EXCLAMATION_OPERATOR_PART = 23 
		, FOR_NOTATION = 24 
		, GREATER_THAN_OP = 25 
		, GREATER_THAN_OR_EQUALS_OP = 26 
		, HEX_STRING_LIT = 27 
		, INTRODUCER = 28 
		, LEFT_BRACKET = 29 
		, LEFT_PAREN = 30 
		, LESS_THAN_OP = 31 
		, LESS_THAN_OR_EQUALS_OP = 32 
		, MINUS_SIGN = 33 
		, NATIONAL_CHAR_STRING_LIT = 34 
		, NEWLINE = 35 
		, NOT_EQUAL_OP = 36 
		, PERCENT = 37 
		, PERIOD = 38 
		, PLSQL_NON_RESERVED_CONNECT_BY_ROOT = 39 
		, PLSQL_NON_RESERVED_ELSIF = 40 
		, PLSQL_NON_RESERVED_MODEL = 41 
		, PLSQL_NON_RESERVED_PIVOT = 42 
		, PLSQL_NON_RESERVED_UNPIVOT = 43 
		, PLSQL_NON_RESERVED_USING = 44 
		, PLSQL_RESERVED_CLUSTERS = 45 
		, PLSQL_RESERVED_COLAUTH = 46 
		, PLSQL_RESERVED_COMPRESS = 47 
		, PLSQL_RESERVED_CRASH = 48 
		, PLSQL_RESERVED_EXCLUSIVE = 49 
		, PLSQL_RESERVED_IDENTIFIED = 50 
		, PLSQL_RESERVED_IF = 51 
		, PLSQL_RESERVED_INDEX = 52 
		, PLSQL_RESERVED_INDEXES = 53 
		, PLSQL_RESERVED_LOCK = 54 
		, PLSQL_RESERVED_MINUS = 55 
		, PLSQL_RESERVED_MODE = 56 
		, PLSQL_RESERVED_NOCOMPRESS = 57 
		, PLSQL_RESERVED_NOWAIT = 58 
		, PLSQL_RESERVED_RESOURCE = 59 
		, PLSQL_RESERVED_SHARE = 60 
		, PLSQL_RESERVED_START = 61 
		, PLSQL_RESERVED_TABAUTH = 62 
		, PLSQL_RESERVED_VIEWS = 63 
		, PLUS_SIGN = 64 
		, PROMPT = 65 
		, QS_ANGLE = 66 
		, QS_BRACE = 67 
		, QS_BRACK = 68 
		, QS_OTHER = 69 
		, QS_OTHER_CH = 70 
		, QS_PAREN = 71 
		, QUESTION_MARK = 72 
		, QUOTE = 73 
		, REGULAR_ID = 74 
		, RIGHT_BRACKET = 75 
		, RIGHT_PAREN = 76 
		, SEMICOLON = 77 
		, SEPARATOR = 78 
		, SIMPLE_LETTER = 79 
		, SOLIDUS = 80 
		, SPACE = 81 
		, SQL92_RESERVED_ALL = 82 
		, SQL92_RESERVED_ALTER = 83 
		, SQL92_RESERVED_AND = 84 
		, SQL92_RESERVED_ANY = 85 
		, SQL92_RESERVED_AS = 86 
		, SQL92_RESERVED_ASC = 87 
		, SQL92_RESERVED_BEGIN = 88 
		, SQL92_RESERVED_BETWEEN = 89 
		, SQL92_RESERVED_BY = 90 
		, SQL92_RESERVED_CASE = 91 
		, SQL92_RESERVED_CHECK = 92 
		, SQL92_RESERVED_CONNECT = 93 
		, SQL92_RESERVED_CREATE = 94 
		, SQL92_RESERVED_CURRENT = 95 
		, SQL92_RESERVED_CURSOR = 96 
		, SQL92_RESERVED_DATE = 97 
		, SQL92_RESERVED_DECLARE = 98 
		, SQL92_RESERVED_DEFAULT = 99 
		, SQL92_RESERVED_DELETE = 100 
		, SQL92_RESERVED_DESC = 101 
		, SQL92_RESERVED_DISTINCT = 102 
		, SQL92_RESERVED_DROP = 103 
		, SQL92_RESERVED_ELSE = 104 
		, SQL92_RESERVED_END = 105 
		, SQL92_RESERVED_EXCEPTION = 106 
		, SQL92_RESERVED_EXISTS = 107 
		, SQL92_RESERVED_FALSE = 108 
		, SQL92_RESERVED_FETCH = 109 
		, SQL92_RESERVED_FOR = 110 
		, SQL92_RESERVED_FROM = 111 
		, SQL92_RESERVED_GOTO = 112 
		, SQL92_RESERVED_GRANT = 113 
		, SQL92_RESERVED_GROUP = 114 
		, SQL92_RESERVED_HAVING = 115 
		, SQL92_RESERVED_IN = 116 
		, SQL92_RESERVED_INSERT = 117 
		, SQL92_RESERVED_INTERSECT = 118 
		, SQL92_RESERVED_INTO = 119 
		, SQL92_RESERVED_IS = 120 
		, SQL92_RESERVED_LIKE = 121 
		, SQL92_RESERVED_NOT = 122 
		, SQL92_RESERVED_NULL = 123 
		, SQL92_RESERVED_OF = 124 
		, SQL92_RESERVED_ON = 125 
		, SQL92_RESERVED_OPTION = 126 
		, SQL92_RESERVED_OR = 127 
		, SQL92_RESERVED_ORDER = 128 
		, SQL92_RESERVED_OVERLAPS = 129 
		, SQL92_RESERVED_PRIOR = 130 
		, SQL92_RESERVED_PROCEDURE = 131 
		, SQL92_RESERVED_PUBLIC = 132 
		, SQL92_RESERVED_REVOKE = 133 
		, SQL92_RESERVED_SELECT = 134 
		, SQL92_RESERVED_SIZE = 135 
		, SQL92_RESERVED_TABLE = 136 
		, SQL92_RESERVED_THE = 137 
		, SQL92_RESERVED_THEN = 138 
		, SQL92_RESERVED_TO = 139 
		, SQL92_RESERVED_TRUE = 140 
		, SQL92_RESERVED_UNION = 141 
		, SQL92_RESERVED_UNIQUE = 142 
		, SQL92_RESERVED_UPDATE = 143 
		, SQL92_RESERVED_VALUES = 144 
		, SQL92_RESERVED_VIEW = 145 
		, SQL92_RESERVED_WHEN = 146 
		, SQL92_RESERVED_WHERE = 147 
		, SQL92_RESERVED_WITH = 148 
		, TILDE_OPERATOR_PART = 149 
		, UNDERSCORE = 150 
		, UNSIGNED_INTEGER = 151 
		, VERTICAL_BAR = 152 
		, ZV = 153 
	};

	const ANTLR_UINT8* getTokenName(ANTLR_INT32 index) const;

protected:
	static ANTLR_UINT8* TokenNames[];
};

/** Context tracking structure for PLSQLParser
 */
class PLSQLParser : public PLSQLParserImplTraits::BaseParserType
    , public PLSQLParserTokens
    , PLSQLParserImplTraits::TreeAdaptorType
{
public:
	typedef PLSQLParserImplTraits ImplTraits;
	typedef PLSQLParser ComponentType;
	typedef ComponentType::StreamType StreamType;
	typedef PLSQLParserImplTraits::BaseParserType BaseType;
	typedef ImplTraits::RecognizerSharedStateType<StreamType> RecognizerSharedStateType;
	typedef StreamType InputType;
	typedef PLSQLParserImplTraits::CommonTokenType CommonTokenType;
	typedef PLSQLParserImplTraits::TreeAdaptorType TreeAdaptorType;

	static const bool IsFiltered = false;


private:	
	PLSQLParser_PLSQLKeys*	 m_gPLSQLKeys;
	PLSQLParser_PLSQLCommons*	 m_gPLSQLCommons;
	PLSQLParser_PLSQL_DMLParser*	 m_gPLSQL_DMLParser;
	PLSQLParser_SQLPLUSParser*	 m_gSQLPLUSParser;
public:
    PLSQLParser(InputType* instream);
    PLSQLParser(InputType* instream, RecognizerSharedStateType* state);

    void init(InputType* instream  );


    struct seq_of_statements_return : public PLSQLParserImplTraits::RuleReturnValueType
    {
    public:
        typedef PLSQLParserImplTraits::RuleReturnValueType BaseType;
        seq_of_statements_return()
            : BaseType()
            , p() ,q() 
            { init(); }
        seq_of_statements_return( BaseParserType* parser )
            : BaseType(parser)
            , p() ,q() 
            { init(); }
        seq_of_statements_return( const seq_of_statements_return& other )
            : BaseType(other)
        , p(other.p) , q(other.q) 
        { copy(other); }
        ~seq_of_statements_return()
        {
        }

        seq_of_statements_return&
        operator=( const seq_of_statements_return& other )
        {
            BaseType::operator=( other );
            p = other.p; 
            q = other.q; 
            copy(other);    
        	return *this;
        }
        void init() {  }
        void copy( const seq_of_statements_return& other) {  }    
        void* p;
        void* q;
    };



     void swallow_to_semi (); 
     void compilation_unit (); 
     void sql_script (); 
     void unit_statement (); 
     void drop_function (); 
     void alter_function (); 
     void create_function_body (); 
     void parallel_enable_clause (); 
     void partition_by_clause (); 
     void result_cache_clause (); 
     void relies_on_part (); 
     void streaming_clause (); 
     void drop_package (); 
     void alter_package (); 
     void create_package (); 
     void package_body (); 
     void package_spec (); 
     void package_obj_spec (); 
     void procedure_spec (); 
     void function_spec (); 
     void package_obj_body (); 
     void drop_procedure (); 
     void alter_procedure (); 
     void create_procedure_body (); 
     void drop_trigger (); 
     void alter_trigger (); 
     void create_trigger (); 
     void trigger_follows_clause (); 
     void trigger_when_clause (); 
     void simple_dml_trigger (); 
     void for_each_row (); 
     void compound_dml_trigger (); 
     void non_dml_trigger (); 
     void trigger_body (); 
     void routine_clause (); 
     void compound_trigger_block (); 
     void timing_point_section (); 
     void non_dml_event (); 
     void dml_event_clause (); 
     void dml_event_element (); 
     void dml_event_nested_clause (); 
     void referencing_clause (); 
     void referencing_element (); 
     void drop_type (); 
     void alter_type (); 
     void compile_type_clause (); 
     void replace_type_clause (); 
     void alter_method_spec (); 
     void alter_method_element (); 
     void alter_attribute_definition (); 
     void attribute_definition (); 
     void alter_collection_clauses (); 
     void dependent_handling_clause (); 
     void dependent_exceptions_part (); 
     void create_type (); 
     void type_definition (); 
     void object_type_def (); 
     void object_as_part (); 
     void object_under_part (); 
     void nested_table_type_def (); 
     void sqlj_object_type (); 
     void type_body (); 
     void type_body_elements (); 
     void map_order_func_declaration (); 
     void subprog_decl_in_type (); 
     void proc_decl_in_type (); 
     void func_decl_in_type (); 
     void constructor_declaration (); 
     void modifier_clause (); 
     void object_member_spec (); 
     void sqlj_object_type_attr (); 
     void element_spec (); 
     void element_spec_options (); 
     void subprogram_spec (); 
     void type_procedure_spec (); 
     void type_function_spec (); 
     void constructor_spec (); 
     void map_order_function_spec (); 
     void pragma_clause (); 
     void pragma_elements (); 
     void type_elements_parameter (); 
     void drop_sequence (); 
     void alter_sequence (); 
     void create_sequence (); 
     void sequence_spec (); 
     void sequence_start_clause (); 
     void invoker_rights_clause (); 
     void compiler_parameters_clause (); 
     void call_spec (); 
     void java_spec (); 
     void c_spec (); 
     void c_agent_in_clause (); 
     void c_parameters_clause (); 
     void parameter (); 
     void default_value_part (); 
     void declare_spec (); 
     void variable_declaration (); 
     void subtype_declaration (); 
     void cursor_declaration (); 
     void parameter_spec (); 
     void exception_declaration (); 
     void pragma_declaration (); 
     void record_declaration (); 
     void record_type_dec (); 
     void field_spec (); 
     void record_var_dec (); 
     void table_declaration (); 
     void table_type_dec (); 
     void table_indexed_by_part (); 
     void varray_type_def (); 
     void table_var_dec (); 
     PLSQLParser::seq_of_statements_return seq_of_statements (); 
     void label_declaration (); 
     void statement (); 
     void assignment_statement (); 
     void continue_statement (); 
     void exit_statement (); 
     void goto_statement (); 
     void if_statement (); 
     void elsif_part (); 
     void else_part (); 
     void loop_statement (); 
     void cursor_loop_param (); 
     void forall_statement (); 
     void bounds_clause (); 
     void between_bound (); 
     void lower_bound (); 
     void upper_bound (); 
     void null_statement (); 
     void raise_statement (); 
     void return_statement (); 
     void function_call (); 
     void body (); 
     void exception_clause (); 
     void exception_handler (); 
     void trigger_block (); 
     void block (); 
     void sql_statement (); 
     void execute_immediate (); 
     void dynamic_returning_clause (); 
     void data_manipulation_language_statements (); 
     void cursor_manipulation_statements (); 
     void close_statement (); 
     void open_statement (); 
     void fetch_statement (); 
     void open_for_statement (); 
     void transaction_control_statements (); 
     void set_transaction_command (); 
     void set_constraint_command (); 
     void commit_statement (); 
     void write_clause (); 
     void rollback_statement (); 
     void savepoint_statement (); 























































      bool msynpred( antlr3::ClassForwarder< synpred1_PLSQLParser > );
        void msynpred1_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred2_PLSQLParser > );
        void msynpred2_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred3_PLSQLParser > );
        void msynpred3_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred4_PLSQLParser > );
        void msynpred4_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred5_PLSQLParser > );
        void msynpred5_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred6_PLSQLParser > );
        void msynpred6_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred7_PLSQLParser > );
        void msynpred7_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred8_PLSQLParser > );
        void msynpred8_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred9_PLSQLParser > );
        void msynpred9_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred10_PLSQLParser > );
        void msynpred10_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred11_PLSQLParser > );
        void msynpred11_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred12_PLSQLParser > );
        void msynpred12_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred13_PLSQLParser > );
        void msynpred13_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred14_PLSQLParser > );
        void msynpred14_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred15_PLSQLParser > );
        void msynpred15_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred16_PLSQLParser > );
        void msynpred16_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred17_PLSQLParser > );
        void msynpred17_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred18_PLSQLParser > );
        void msynpred18_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred19_PLSQLParser > );
        void msynpred19_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred20_PLSQLParser > );
        void msynpred20_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred22_PLSQLParser > );
        void msynpred22_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred23_PLSQLParser > );
        void msynpred23_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred24_PLSQLParser > );
        void msynpred24_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred26_PLSQLParser > );
        void msynpred26_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred27_PLSQLParser > );
        void msynpred27_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred29_PLSQLParser > );
        void msynpred29_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred30_PLSQLParser > );
        void msynpred30_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred31_PLSQLParser > );
        void msynpred31_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred32_PLSQLParser > );
        void msynpred32_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred33_PLSQLParser > );
        void msynpred33_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred34_PLSQLParser > );
        void msynpred34_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred35_PLSQLParser > );
        void msynpred35_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred36_PLSQLParser > );
        void msynpred36_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred37_PLSQLParser > );
        void msynpred37_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred39_PLSQLParser > );
        void msynpred39_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred40_PLSQLParser > );
        void msynpred40_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred41_PLSQLParser > );
        void msynpred41_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred42_PLSQLParser > );
        void msynpred42_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred43_PLSQLParser > );
        void msynpred43_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred44_PLSQLParser > );
        void msynpred44_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred47_PLSQLParser > );
        void msynpred47_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred48_PLSQLParser > );
        void msynpred48_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred49_PLSQLParser > );
        void msynpred49_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred50_PLSQLParser > );
        void msynpred50_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred51_PLSQLParser > );
        void msynpred51_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred52_PLSQLParser > );
        void msynpred52_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred55_PLSQLParser > );
        void msynpred55_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred56_PLSQLParser > );
        void msynpred56_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred58_PLSQLParser > );
        void msynpred58_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred59_PLSQLParser > );
        void msynpred59_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred60_PLSQLParser > );
        void msynpred60_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred61_PLSQLParser > );
        void msynpred61_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred62_PLSQLParser > );
        void msynpred62_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred65_PLSQLParser > );
        void msynpred65_PLSQLParser_fragment ();
      bool msynpred( antlr3::ClassForwarder< synpred66_PLSQLParser > );
        void msynpred66_PLSQLParser_fragment ();
    // Delegated rules
    void merge_update_delete_part();

    void numeric();

    void oradata_key();

    void rtrim_key();

    void clob_key();

    void collect_order_by_part();

    void within_or_over_part();

    void routine_name();

    void execute_key();

    void conditional_insert_else_part();

    void min_key();

    void record_key();

    void boolean_key();

    void noentityescaping_key();

    void case_else_part();

    void hextoraw_key();

    void merge_update_clause();

    void hierarchical_query_clause();

    void table_key();

    void if_key();

    void passing_key();

    void constraint_key();

    void the_key();

    void committed_key();

    void cast_key();

    void bit_length_key();

    void type_key();

    void modify_key();

    void single_table_insert();

    void noschemacheck_key();

    void no_key();

    void grouping_key();

    void wait_key();

    void option_key();

    void indexed_key();

    void positiven_key();

    void level_key();

    void outer_key();

    void over_clause();

    void current_of_clause();

    void cluster_key();

    void else_key();

    void unpivot_in_clause();

    void partition_extension_clause();

    void initcap_key();

    void case_statement(int isStatementParameter);

    void binary_double_min_normal_key();

    void percent_rowcount_key();

    void multiset_key();

    void and_key();

    void or_key();

    void zone_key();

    void multiset_comparsion();

    void element_key();

    void nvarchar2_key();

    void reference_key();

    void lock_mode();

    void subpartition_key();

    void current_user_key();

    void type_spec();

    void model_rules_element();

    void none_key();

    void ltrim_key();

    void instantiable_key();

    void share_key();

    void skip_key();

    void siblings_key();

    void infinite_key();

    void sample_clause();

    void likec_key();

    void nominvalue_key();

    void max_key();

    void auto_key();

    void function_argument_modeling();

    void exception_name();

    void round_key();

    void decode_key();

    void dimension_key();

    void intersect_key();

    void inline_key();

    void pragma_key();

    void library_key();

    void float_key();

    void wellformed_key();

    void binary_double_key();

    void a_key();

    void pivot_key();

    void dml_table_expression_clause();

    void selected_element();

    void soundex_key();

    void day_key();

    void before_key();

    void pivot_clause();

    void exception_key();

    void rules_key();

    void first_value_key();

    void join_clause();

    void binary_double_infinity_key();

    void false_key();

    void raise_key();

    void lock_table_element();

    void cursor_expression();

    void oserror_key();

    void timezone_hour_key();

    void current_date_key();

    void constant_key();

    void selected_tableview();

    void alias_quoted_string();

    void pivot_element();

    void cell_reference_options();

    void treat_key();

    void timezone_region_key();

    void exists_key();

    void parameter_name();

    void rename_key();

    void multiset_expression();

    void last_key();

    void present_key();

    void xmlcast_key();

    void xmlpi_key();

    void sysdate_key();

    void audit_key();

    void to_char_key();

    void link_key();

    void standalone_key();

    void binary_float_min_normal_key();

    void additive_expression();

    void column_based_update_set_clause();

    void xmlquery_key();

    void grant_key();

    void general_element_part();

    void dml_key();

    void collection_name();

    void argument();

    void xmlparse_key();

    void keep_key();

    void statement_id_key();

    void rawtohex_key();

    void table_ref_aux();

    void stantard_function_enabling_within_or_over();

    void error_logging_into_part();

    void precision_part();

    void content_key();

    void stantard_function_enabling_over();

    void continue_key();

    void external_key();

    void stantard_function_pedictions();

    void stantard_function_enabling_using();

    void searched_case_when_part();

    void begin_key();

    void off_key();

    void grouping_sets_clause();

    void link_name();

    void bulk_key();

    void yminterval_unconstrained_key();

    void forall_key();

    void from_key();

    void substitutable_key();

    void instr_key();

    void signtype_key();

    void xmlattributes_key();

    void mod_key();

    void reference_model_name();

    void preceding_key();

    void decompose_key();

    void chartorowid_key();

    void unknown_key();

    void model_column_partition_part();

    void not_key();

    void suspend_key();

    void constant();

    void char_cs_key();

    void leading_key();

    void rowidtochar_key();

    void label_name();

    void language_key();

    void date_key();

    void general_table_ref();

    void of_key();

    void deferred_key();

    void compound_key();

    void pivot_in_clause();

    void concat_key();

    void simple_case_statement();

    void default_key();

    void nclob_key();

    void as_key();

    void reverse_key();

    void returning_key();

    void old_key();

    void values_clause();

    void cost_matrix_clause();

    void seed_key();

    void in_key();

    void order_by_elements();

    void connect_by_root_key();

    void xmlcolattval_key();

    void true_key();

    void invalidate_key();

    void national_key();

    void constructor_key();

    void nav_key();

    void out_key();

    void coalesce_key();

    void wait_nowait_part();

    void yes_key();

    void percent_rowtype_key();

    void transaction_key();

    void flashback_query_clause();

    void insert_key();

    void analyze_key();

    void depth_key();

    void logon_key();

    void insert_statement();

    void query_partition_clause();

    void function_key();

    void indices_key();

    void raw_key();

    void char_key();

    void subquery_operation_part();

    void ddl_key();

    void overriding_key();

    void rollup_key();

    void within_key();

    void use_key();

    void under_key();

    void open_key();

    void schema_key();

    void to_date_key();

    void settings_key();

    void abs_key();

    void sqlerror_key();

    void update_key();

    void less_than_or_equals_op();

    void entityescaping_key();

    void conditional_insert_when_part();

    void respect_key();

    void while_key();

    void xmlexists_key();

    void batch_key();

    void percent_found_key();

    void like_type();

    void variable_name();

    void add_key();

    void rows_key();

    void implementation_type_name();

    void ref_key();

    void sequence_key();

    void expression();

    void seed_part();

    void snapshot_key();

    void explain_key();

    void commit_key();

    void by_key();

    void unique_key();

    void insert_into_clause();

    void subquery();

    void cross_key();

    void lpad_key();

    void standard_function();

    void char_length_key();

    void sessiontimezone_key();

    void condition();

    void multiply_expression();

    void real_key();

    void month_key();

    void from_clause();

    void between_elements();

    void corresponding_key();

    void associate_key();

    void block_key();

    void xmlserialize_param_version_part();

    void except_key();

    void debug_key();

    void model_rules_clause();

    void include_key();

    void join_key();

    void smallint_key();

    void group_by_elements();

    void package_name();

    void multi_column_for_loop();

    void binary_float_min_subnormal_key();

    void xml_namespaces_clause();

    void extract_key();

    void system_key();

    void keep_clause();

    void servererror_key();

    void log_key();

    void some_key();

    void increment_key();

    void explain_statement();

    void measures_key();

    void merge_element();

    void advise_key();

    void string_key();

    void chr_key();

    void pivot_in_clause_element();

    void xmlserialize_param_enconding_part();

    void hour_key();

    void whenever_key();

    void constraint_name();

    void work_key();

    void dense_rank_key();

    void sqrt_key();

    void elsif_key();

    void quoted_string();

    void general_element();

    void extend_key();

    void respect_or_ignore_nulls();

    void any_key();

    void percent_notfound_key();

    void cursor_key();

    void start_part();

    void translate_key();

    void model_rules_part();

    void bfile_key();

    void xml_table_column();

    void varying_key();

    void into_clause();

    void maxvalue_key();

    void integer_key();

    void main_model();

    void outer_join_type();

    void columns_key();

    void trigger_key();

    void until_part();

    void loop_key();

    void ignore_key();

    void model_column_list();

    void final_key();

    void fetch_key();

    void asc_key();

    void userenv_key();

    void for_update_options();

    void nothing_key();

    void indicator_key();

    void save_key();

    void corrupt_xid_key();

    void double_key();

    void xmlserialize_key();

    void ceil_key();

    void failure_key();

    void expression_wrapper();

    void nullif_key();

    void interval_key();

    void user_key();

    void current_timestamp_key();

    void procedure_key();

    void binary_double_max_normal_key();

    void percent_isopen_key();

    void table_element();

    void order_by_clause();

    void set_command();

    void bind_variable();

    void greater_than_or_equals_op();

    void cell_assignment();

    void main_model_name();

    void range_key();

    void mode_key();

    void index_key();

    void create_key();

    void dsinterval_unconstrained_key();

    void exceptions_key();

    void object_key();

    void pivot_in_clause_elements();

    void end_key();

    void iterate_key();

    void natural_key();

    void desc_key();

    void table_ref_list();

    void current_key();

    void local_key();

    void binary_double_min_subnormal_key();

    void numeric_key();

    void factoring_element();

    void minute_key();

    void order_key();

    void dump_key();

    void autonomous_transaction_key();

    void array_key();

    void for_like_part();

    void role_key();

    void trailing_key();

    void current_time_key();

    void substring_key();

    void vsize_key();

    void nocycle_key();

    void record_name();

    void greatest_key();

    void compatibility_key();

    void identified_key();

    void rowid_key();

    void deterministic_key();

    void return_key();

    void multi_table_insert();

    void floor_key();

    void referencing_key();

    void xmlforest_key();

    void unpivot_clause();

    void drop_key();

    void startup_key();

    void replace_key();

    void defaults_key();

    void truncate_key();

    void join_on_part();

    void simple_integer_key();

    void id_expression();

    void for_key();

    void customdatum_key();

    void only_key();

    void delete_statement();

    void concatenation();

    void exclusive_key();

    void package_key();

    void each_key();

    void nowait_key();

    void xml_column_name();

    void collect_key();

    void decimal_key();

    void searched_case_statement();

    void interval_expression();

    void timeout_key();

    void xmlroot_key();

    void into_key();

    void nulls_key();

    void empty_key();

    void errors_key();

    void cursor_name();

    void until_key();

    void nocopy_key();

    void concatenation_op();

    void urowid_key();

    void force_key();

    void statistics_key();

    void versions_key();

    void function_name();

    void column_name();

    void submultiset_key();

    void having_key();

    void having_clause();

    void hash_key();

    void comment_key();

    void reuse_key();

    void scn_key();

    void compound_expression();

    void precision_key();

    void function_argument_analytic();

    void binary_float_max_normal_key();

    void null_key();

    void plan_key();

    void with_key();

    void name_key();

    void sqldata_key();

    void unpivot_key();

    void escape_key();

    void noorder_key();

    void hide_key();

    void specification_key();

    void call_key();

    void nchar_key();

    void timezone_minute_key();

    void relational_expression();

    void windowing_elements();

    void show_key();

    void subtype_key();

    void right_key();

    void convert_key();

    void multiset_op();

    void ascii_key();

    void minus_key();

    void disassociate_key();

    void partial_key();

    void unpivot_in_elements();

    void cycle_key();

    void xmltable_key();

    void result_cache_key();

    void long_key();

    void binary_double_nan_key();

    void merge_statement();

    void index_name();

    void pipelined_key();

    void static_returning_clause();

    void native_datatype_element();

    void delete_key();

    void self_key();

    void instead_key();

    void cost_class_name();

    void sample_key();

    void close_key();

    void distinct_key();

    void single_column_for_loop();

    void sequential_key();

    void binary_float_nan_key();

    void document_key();

    void least_key();

    void full_key();

    void nomaxvalue_key();

    void schemacheck_key();

    void binary_double_max_subnormal_key();

    void model_expression();

    void segment_key();

    void connect_key();

    void blob_key();

    void binary_float_key();

    void logoff_key();

    void decrement_key();

    void constraints_key();

    void cascade_key();

    void cost_key();

    void limit_key();

    void cube_key();

    void upsert_key();

    void lock_table_statement();

    void binary_float_infinity_key();

    void char_set_name();

    void variance_key();

    void serializable_key();

    void search_key();

    void select_key();

    void result_key();

    void serveroutput_key();

    void where_clause();

    void warning_key();

    void timestamp_ltz_unconstrained_key();

    void binary_integer_key();

    void condition_wrapper();

    void goto_key();

    void row_key();

    void octet_length_key();

    void for_update_clause();

    void statement_key();

    void read_key();

    void over_key();

    void main_key();

    void context_key();

    void single_key();

    void parameters_key();

    void agent_key();

    void restrict_references_key();

    void conditional_insert_clause();

    void path_key();

    void inout_key();

    void equality_expression();

    void cycle_clause();

    void shutdown_key();

    void nan_key();

    void query_block();

    void c_key();

    void like4_key();

    void parallel_enable_key();

    void definer_key();

    void pls_integer_key();

    void dbtimezone_key();

    void value_key();

    void negated_expression();

    void using_clause();

    void update_set_clause();

    void avg_key();

    void byte_key();

    void left_key();

    void automatic_key();

    void naturaln_key();

    void select_statement();

    void like_escape_part();

    void xmlelement_key();

    void start_key();

    void position_key();

    void group_by_clause();

    void case_key();

    void immediate_key();

    void int_key();

    void updated_key();

    void for_update_of_part();

    void varchar2_key();

    void power_key();

    void simple_case_when_part();

    void body_key();

    void unlimited_key();

    void write_key();

    void table_alias();

    void trim_key();

    void percent_type_key();

    void xml_key();

    void xml_multiuse_expression_element();

    void prior_key();

    void declare_key();

    void group_key();

    void compile_key();

    void search_clause();

    void cache_key();

    void member_key();

    void like2_key();

    void concatenation_wrapper();

    void nested_key();

    void expression_list();

    void join_using_part();

    void dec_key();

    void varray_key();

    void alter_key();

    void when_key();

    void database_key();

    void query_name();

    void authid_key();

    void rollback_segment_name();

    void check_key();

    void to_number_key();

    void nvl_key();

    void static_key();

    void uid_key();

    void type_name();

    void global_key();

    void revoke_key();

    void last_value_key();

    void model_key();

    void guard_key();

    void version_key();

    void rollback_key();

    void system_user_key();

    void resumable_key();

    void tableview_name();

    void sign_key();

    void to_key();

    void where_key();

    void error_logging_clause();

    void xml_passing_clause();

    void following_key();

    void lock_key();

    void year_key();

    void ordinality_key();

    void quantified_expression();

    void both_key();

    void timestamp_key();

    void session_user_key();

    void windowing_type();

    void varchar_key();

    void subquery_factoring_clause();

    void model_expression_element();

    void disable_key();

    void then_key();

    void using_key();

    void collate_key();

    void subquery_restriction_clause();

    void minvalue_key();

    void sets_key();

    void time_key();

    void query_key();

    void map_key();

    void validate_key();

    void relies_on_key();

    void first_key();

    void isolation_key();

    void using_element();

    void parent_key();

    void exit_key();

    void nchar_cs_key();

    void in_elements();

    void locked_key();

    void multiset_type();

    void breadth_key();

    void lower_key();

    void serially_reusable_key();

    void sql_plus_command();

    void pivot_for_clause();

    void id();

    void unbounded_key();

    void encoding_key();

    void for_increment_decrement_type();

    void procedure_name();

    void windowing_clause();

    void model_clause();

    void select_list_elements();

    void oid_key();

    void evalname_key();

    void unary_expression();

    void model_iterate_clause();

    void data_key();

    void between_key();

    void db_role_change_key();

    void enable_key();

    void merge_insert_clause();

    void session_key();

    void timestamp_unconstrained_key();

    void savepoint_name();

    void matched_key();

    void exit_command();

    void vector_expr();

    void attribute_key();

    void size_key();

    void java_key();

    void update_statement();

    void trunc_key();

    void subquery_basic_elements();

    void is_key();

    void after_key();

    void partition_key();

    void variable_key();

    void trigger_name();

    void count_key();

    void nocache_key();

    void canonical_key();

    void xmlroot_param_version_part();

    void atom();

    void module_key();

    void rpad_key();

    void model_column();

    void xmlagg_key();

    void number_key();

    void column_alias();

    void multi_table_element();

    void rollup_cube_clause();

    void timestamp_tz_unconstrained_key();

    void sum_key();

    void all_key();

    void outer_join_sign();

    void attribute_name();

    void indent_key();

    void match_key();

    void expression_or_vector();

    void success_key();

    void xml_general_default_part();

    void aggregate_function_name();

    void prompt_command();

    void xmlnamespaces_key();

    void character_length_key();

    void sequence_name();

    void noaudit_key();

    void set_key();

    void table_var_name();

    void logical_and_expression();

    void xmlroot_param_standalone_part();

    void bit_key();

    void schema_name();

    void inner_key();

    void follows_key();

    void function_argument();

    void datetime_expression();

    void second_key();

    void mlslabel_key();

    void including_key();

    void upper_key();

    void corrupt_xid_all_key();

    void values_key();

    void aggregate_key();

    void merge_key();

    void on_key();

    void xmlserialize_param_ident_part();

    void length_key();

    void whenever_command();

    void new_key();

    void exclude_key();

    void reference_model();

    void datatype();

    void savepoint_key();

    void substr_key();

    void model_column_clauses();

    void stddev_key();

    void grouping_sets_elements();

    void character_key();

    void xml_attributes_clause();

    void like_key();

    void table_collection_expression();

    void not_equal_op();

    void timezone_abbr_key();

    void table_ref();

    void reject_key();

    void positive_key();

    void binary_float_max_subnormal_key();

    void return_rows_clause();

    void parallel_key();

    void error_logging_reject_part();

    void exception_init_key();

    void nextval_key();

    void at_key();

    void union_key();

    const char *    getGrammarFileName();
    void            reset();
    ~PLSQLParser();

};

// Function protoypes for the constructor functions that external translation units
// such as delegators and delegates may wish to call.
//

/* End of token definitions for PLSQLParser
 * =============================================================================
 */

}

#endif

/* END - Note:Keep extra line feed to satisfy UNIX systems */
