// ANTLR runtime includes
#include "antlr3commontoken.h"
#include "antlr3string.h"
#include "antlr3input.h"
#include "antlr3lexer.h"

#include "OracleSQLLexer.h"
#include "tsqllexer.h"
#include "tsqlparse.h"

namespace SQLParser
{

  	class OracleLexer : public Lexer
	{
	public:
		OracleLexer(const QString &statement, const QString &name);			
		virtual QString firstWord();
		virtual QString currentWord(unsigned line, unsigned column);
	private:
		QByteArray QBAinput;
		QByteArray QBAname;

		pANTLR3_INPUT_STREAM input;
		pOracleSQLLexer lxr;
		pANTLR3_COMMON_TOKEN_STREAM tstream;
		pANTLR3_VECTOR lexerTokenVector;
	};

	OracleLexer::OracleLexer(const QString &statement, const QString &name)
		: Lexer(statement, name)
		, QBAinput(statement.toUtf8())
		, QBAname(name.toUtf8())
	{
		input = antlr3StringStreamNew( (pANTLR3_UINT8) QBAinput.data(), ANTLR3_ENC_8BIT, (ANTLR3_UINT64) QBAinput.size(), (pANTLR3_UINT8)QBAname.data());
		input->setUcaseLA(input, ANTLR3_TRUE); // ignore case

		if (input == NULL)
		{
			// TODO throw here
			throw ParseException();
			exit(ANTLR3_ERR_NOMEM);
		}

		// Our input stream is now open and all set to go, so we can create a new instance of our
		// lexer and set the lexer input to our input stream:
		//  (file | memory | ?) --> inputstream -> lexer --> tokenstream --> parser ( --> treeparser )?
		//
		lxr	    = OracleSQLLexerNew(input);	    // CLexerNew is generated by ANTLR
		lxr->pLexer->input->charPositionInLine = 0; // fix off-by-one error for getCharPositionInLine for the 1st row
			
		if ( lxr == NULL )
		{
			// TODO throw here
			throw ParseException();
			exit(ANTLR3_ERR_NOMEM);
		}

		tstream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));
			
		if (tstream == NULL)
		{
			// TODO throw here
			//_mState = P_ERROR;			
			throw ParseException();
			exit(ANTLR3_ERR_NOMEM);
		}
		this->lexerTokenVector = tstream->getTokens(tstream);
		//_mState = P_LEXER;
	};

	/*virtual*/ QString OracleLexer::firstWord()
	{
		ANTLR3_UINT32 size = this->lexerTokenVector->size(lexerTokenVector);
		ANTLR3_UINT32 i;
		for (i=0; i < size; i++) {
			pANTLR3_COMMON_TOKEN token = (pANTLR3_COMMON_TOKEN)lexerTokenVector->get(lexerTokenVector, i);
			if( token->getChannel(token) != HIDDEN)
			{
				return QString((const char*)(token->getText(token)->chars));
			}
		}
		return QString();
	}

	/*virtual*/ QString OracleLexer::currentWord(unsigned line, unsigned column)
	{
		line++; // ANTLR3 starts with 1st while QScintille starts with 0th
		ANTLR3_UINT32 i;
		ANTLR3_UINT32 size = this->lexerTokenVector->size(lexerTokenVector);
		if(size == 0)
			return QString();

		pANTLR3_COMMON_TOKEN tokenZero = (pANTLR3_COMMON_TOKEN)lexerTokenVector->get(lexerTokenVector, 0);
		QString retval((const char*)(tokenZero->getText(tokenZero)->chars));

		for (i=1; i < size; i++) {
			pANTLR3_COMMON_TOKEN token = (pANTLR3_COMMON_TOKEN)lexerTokenVector->get(lexerTokenVector, i);
			if (
				token->getLine(token) > line ||
				( token->getLine(token) == line && token->getCharPositionInLine(token) > column )
				)			       
			{
				return retval;
			}

			if ( token->getChannel(token) != HIDDEN)
			{
				retval = QString((const char*)(token->getText(token)->chars));
			}
		}
		return QString();
	}

};

Util::RegisterInFactory<SQLParser::OracleLexer, LexerFactTwoParmSing> regOracleSQLLexStatement("OracleSQL");
