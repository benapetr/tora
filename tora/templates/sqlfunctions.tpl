Aggregate Functions:COUNT ( *|DISTINCT|ALL expr )=Return the number of rows in the resultset. <CODE>DISTINCT</CODE> specifies that only\ndistinct values are to be counted. If <I>expr</I> is NULL it is not counted. <CODE>*</CODE>\n and <CODE>ALL</CODE> indicates that all rows should be counted.<P>\n<B>Example:</B>\n<PRE>\nSELECT COUNT(*),COUNT(deliverydate) FROM sales;\n\nCOUNT(*) COUNT(deliverydate)\n-------- -------------------\n       8                   7\n</PRE>
Aggregate Functions:COVAR_POP ( expr1 , expr2 )=Get the population covariance of a set of pairs.<P>\n\nPairs where either <I>expr1</I> or <I>expr2</I> are eliminated first. Then the following\ncalculation is performed:\n\n<PRE>\n(SUM(expr1 * expr2) - SUM(expr2) * SUM(expr1) / n) / n\n</PRE>\n\nThe function returns a number, if applied to an empty set NULL is returned.<P>\n<B>Example:</B>\n<PRE>\nSELECT itemid,COVAR_POP(amount,profit) FROM saleitems GROUP BY itemid;\n\n    ITEMID COVAR_POP(AMOUNT,PROFIT)\n---------- ------------------------\n         1                    84000\n         2                   5062.5\n         3                   325000\n         4               4111.11111\n</PRE>
Aggregate Functions:COVAR_SAMP ( expr1 , expr2 )=Get the sample covariance of a set of pairs.<P>\n\nPairs where either <I>expr1</I> or <I>expr2</I> are eliminated first. Then the following\ncalculation is performed:\n\n<PRE>\n(SUM(expr1 * expr2) - SUM(expr2) * SUM(expr1) / n) / (n - 1)\n</PRE>\n\nThe function returns a number, if applied to an empty set NULL is returned.<P>\n<B>Example:</B>\n<PRE>\nSELECT itemid,COVAR_SAMP(amount,profit) FROM saleitems GROUP BY itemid;\n\n    ITEMID COVAR_POP(AMOUNT,PROFIT)\n---------- ------------------------\n         1                    84000\n         2                   5062.5\n         3                   325000\n         4               4111.11111\n</PRE>
Aggregate Functions:GROUPING ( expr )=This function is only usefull in select statements with a group by extension such as <CODE>ROLLUP</CODE>\nor <CODE>CUBE</CODE>. These function generate extra rows with nulls which is the group by aggregate.\nThis function can be use to distinguish these rows from rows that are actually null.<P>\nThe <I>expr</I> must match a group by expression. If the <I>expr</I> is a null that represent an\naggregate row this function returns 1, otherwise it returns 0.<P>\n<B>Example:</B>\n<PRE>\nSELECT DECODE(GROUPING(itemid),1,'Total',itemid) item,\n       SUM(amount) amount,\n       SUM(profit) profit\n  FROM saleitems\n GROUP BY ROLLUP (itemid);\n\nITEM  AMOUNT PROFIT\n----- ------ ------\n1      12000   2200\n2       2760    195\n3      10000   2200\n4       1300    170\nTotal  26060   4765\n</PRE>
Aggregate Functions:MAX( expr )=Get the largest value of <I>expr</I>.<P>\n<B>Example:</B>\n<PRE>\nSELECT MAX(amount) FROM saleitems;\n\nMAX(AMOUNT)\n-----------\n       4000\n</PRE>
Aggregate Functions:MIN ( expr )=Get the smallest value of <I>expr</I>.<P>\n<B>Example:</B>\n<PRE>\nSELECT MIN(amount) FROM saleitems;\n\nMIN(AMOUNT)\n-----------\n        240\n</PRE>
Aggregate Functions:REGR_AVGX ( expr1 , expr2 )=Pairs where either <I>expr1</I> or <I>expr2</I> are eliminated to begin with. Then the following function is calculated:\n<PRE>\nAVG ( expr2 )\n</PRE>\n<B>Expample:</B><P>\n<PRE>\nSELECT TRUNC((SYSDATE - saledate) / 7) WEEK,\n       REGR_AVGX ( SYSDATE - saledate , amount )\n  FROM sales , saleitems\n WHERE sales.saleid = saleitems.saleid\n GROUP BY TRUNC((SYSDATE - saledate) / 7);\n\n      WEEK REGR_AVGX(SYSDATE-SALEDATE,AMOUNT)\n---------- ----------------------------------\n         0                               1280\n         8                                500\n        10                                300\n        13                         3333.33333\n        15                               1360\n        73                               1000\n        74                               1400\n</PRE>
Aggregate Functions:REGR_AVGY ( expr1 , expr2 )=Pairs where either <I>expr1</I> or <I>expr2</I> are eliminated to begin with. Then the following function is calculated:\n<PRE>\nAVG ( expr2 )\n</PRE>\n<B>Expample:</B><P>\n<PRE>\nSELECT TRUNC((SYSDATE - saledate) / 7) WEEK,\n       REGR_AVGY ( SYSDATE - saledate , amount )\n  FROM sales , saleitems\n WHERE sales.saleid = saleitems.saleid\n GROUP BY TRUNC((SYSDATE - saledate) / 7);\n\n      WEEK REGR_AVGY(SYSDATE-SALEDATE,AMOUNT)\n---------- ----------------------------------\n         0                          1.0277662\n         8                         60.0277662\n        10                         71.0277662\n        13                         93.3610995\n        15                         107.027766\n        73                         514.027766\n        74                         518.027766\n</PRE>
Aggregate Functions:REGR_COUNT ( expr1 , expr2 )=Pairs where either <I>expr1</I> or <I>expr2</I> are eliminated to begin with. This function then returns the number of valid pairs left.<P>\n<B>Expample:</B><P>\n<PRE>\nSELECT TRUNC((SYSDATE - saledate) / 7) WEEK,\n       REGR_COUNT ( SYSDATE - saledate , amount )\n  FROM sales , saleitems\n WHERE sales.saleid = saleitems.saleid\n GROUP BY TRUNC((SYSDATE - saledate) / 7);\n\n      WEEK REGR_COUNT(SYSDATE-SALEDATE,AMOUNT)\n---------- -----------------------------------\n         0                                   3\n         8                                   2\n        10                                   1\n        13                                   3\n        15                                   2\n        73                                   1\n        74                                   3\n</PRE>
Aggregate Functions:REGR_INTERCEPT ( expr1 , expr2 )=Calculates the y-intercept of the regression line. Pairs where either <I>expr1</I> or <I>expr2</I> are eliminated to begin with. Then the following function is calculated:\n<PRE>\nAVG ( expr1 ) - REGR_SLOPE ( expr1 , expr2 ) * AVG ( expr2 )\n</PRE>\n<B>Expample:</B><P>\n<PRE>\nSELECT TRUNC((SYSDATE - saledate) / 7) WEEK,\n       REGR_INTERCEPT ( SYSDATE - saledate , amount )\n  FROM sales , saleitems\n WHERE sales.saleid = saleitems.saleid\n GROUP BY TRUNC((SYSDATE - saledate) / 7);\n\n      WEEK REGR_INTERCEPT(SYSDATE-SALEDATE,AMOUNT)\n---------- ---------------------------------------\n         0                              1.02846065\n         8                              60.0284606\n        10\n        13                              100.028461\n        15                              107.028461\n        73\n        74                              518.028461\n</PRE>
Aggregate Functions:REGR_R2 ( expr1 , expr2 )=Represent the determination or goodness of fit for the regression. Pairs where either <I>expr1</I> or <I>expr2</I> are eliminated to begin with. The value of the functions <CODE>VAR_POP ( expr1 )</CODE> and <CODE>VAR_POP ( expr2 )</CODE> is evaluated after null pairs are removed. The returned value is then one of the following:\n<UL>\n<LI>null if <CODE>VAR_POP ( expr2 )</CODE> = 0.\n<LI>1 if <CODE>VAR_POP ( expr1 )</CODE> = 0 and <CODE>VAR_POP ( expr2 )</CODE> != 0.\n<LI><CODE>POWER ( CORR ( expr1 , expr2 ) , 2 )</CODE> if <CODE>VAR_POP ( expr1 )</CODE> > 0 and <CODE>VAR_POP ( expr2 )</CODE> != 0.\n</UL>\n<B>Expample:</B><P>\n<PRE>\nSELECT TRUNC((SYSDATE - saledate) / 7) WEEK,\n       REGR_R2 ( SYSDATE - saledate , amount )\n  FROM sales , saleitems\n WHERE sales.saleid = saleitems.saleid\n GROUP BY TRUNC((SYSDATE - saledate) / 7);\n\n      WEEK REGR_R2(SYSDATE-SALEDATE,AMOUNT)\n---------- --------------------------------\n         0                       1.4215E-39\n         8                       2.8571E-38\n        10\n        13                              .25\n        15                                1\n        73\n        74                                0\n</PRE>
Aggregate Functions:REGR_SLOPE ( expr1 , expr2 )=This function returns the slope of the line. Pairs where either <I>expr1</I> or <I>expr2</I> are eliminated to begin with. Then the following function is calculated:\n<PRE>\nCOVAR_POP ( expr1 , expr2 ) / VAR_POP ( expr2 )\n</PRE>\n<B>Expample:</B><P>\n<PRE>\nSELECT TRUNC((SYSDATE - saledate) / 7) WEEK,\n       REGR_SLOPE ( SYSDATE - saledate , amount )\n  FROM sales , saleitems\n WHERE sales.saleid = saleitems.saleid\n GROUP BY TRUNC((SYSDATE - saledate) / 7);\n\n      WEEK REGR_SLOPE(SYSDATE-SALEDATE,AMOUNT)\n---------- -----------------------------------\n         0                          -3.554E-42\n         8                                   0\n        10\n        13                               -.002\n        15                                   0\n        73\n        74                                   0\n</PRE>
Aggregate Functions:REGR_SXX ( expr1 , expr2 )=Pairs where either <I>expr1</I> or <I>expr2</I> are eliminated to begin with. Then the following function is calculated:\n<PRE>\nREGR_COUNT ( expr1 , expr2 ) / VAR_POP ( expr2 )\n</PRE>\n<B>Expample:</B><P>\n<PRE>\nSELECT TRUNC((SYSDATE - saledate) / 7) WEEK,\n       REGR_SXX ( SYSDATE - saledate , amount )\n  FROM sales , saleitems\n WHERE sales.saleid = saleitems.saleid\n GROUP BY TRUNC((SYSDATE - saledate) / 7);\n\n      WEEK REGR_SXX(SYSDATE-SALEDATE,AMOUNT)\n---------- ---------------------------------\n         0                           4502400\n         8                             20000\n        10                                 0\n        13                        666666.667\n        15                            819200\n        73                                 0\n        74                            560000\n</PRE>
Aggregate Functions:REGR_SXY ( expr1 , expr2 )=Pairs where either <I>expr1</I> or <I>expr2</I> are eliminated to begin with. Then the following function is calculated:\n<PRE>\nREGR_COUNT ( expr1 , expr2 ) / VAR_POP ( expr1 )\n</PRE>\n<B>Expample:</B><P>\n<PRE>\nSELECT TRUNC((SYSDATE - saledate) / 7) WEEK,\n       REGR_SXY ( SYSDATE - saledate , amount )\n  FROM sales , saleitems\n WHERE sales.saleid = saleitems.saleid\n GROUP BY TRUNC((SYSDATE - saledate) / 7);\n\n      WEEK REGR_SXY(SYSDATE-SALEDATE,AMOUNT)\n---------- ---------------------------------\n         0                        1.3000E-35\n         8                        1.0000E-34\n        10                                 0\n        13                        -1333.3333\n        15                                 0\n        73                                 0\n        74                                 0\n</PRE>
Aggregate Functions:REGR_SYY ( expr1 , expr2 )=Pairs where either <I>expr1</I> or <I>expr2</I> are eliminated to begin with. Then the following function is calculated:\n<PRE>\nREGR_COUNT ( expr1 , expr2 ) / COVAR_POP ( expr1 )\n</PRE>\n<B>Expample:</B><P>\n<PRE>\nSELECT TRUNC((SYSDATE - saledate) / 7) WEEK,\n       REGR_SXY ( SYSDATE - saledate , amount )\n  FROM sales , saleitems\n WHERE sales.saleid = saleitems.saleid\n GROUP BY TRUNC((SYSDATE - saledate) / 7);\n\n      WEEK REGR_SXY(SYSDATE-SALEDATE,AMOUNT)\n---------- ---------------------------------\n         0                        -4.000E-36\n         8                                 0\n        10                                 0\n        13                        -1333.3333\n        15                                 0\n        73                                 0\n        74                                 0\n</PRE>
Aggregate Functions:STDDEV ( DISTINCT|ALL expr )=Get the standard deviation of <I>expr</I>. This function differs from <CODE>STDDEV_SAMP</CODE> in what it returns when there is only one input row. This function returns 0 and <CODE>STDDEV_SAMP</CODE> returns null. The standard deviation is the square root of the variance defined for the <CODE>VARIANCE</CODE> function.<P>\n<B>Expample:</B>\n<PRE>\nSELECT AVG(amount),STDDEV(amount) FROM saleitems;\n\nAVG(AMOUNT) STDDEV(AMOUNT)\n----------- --------------\n    1628.75     1225.85412\n</PRE>
Aggregate Functions:STDDEV_POP ( expr )=Get the square root of the population variance. This is the same as the square root of the <CODE>VAR_POP</CODE> function.<P>\n<B>Expample:</B>\n<PRE>\nSELECT STDDEV_POP(profit) FROM saleitems;\n\nSTDDEV_POP(PROFIT)\n------------------\n        277.077205\n</PRE>
Aggregate Functions:STDDEV_SAMP ( DISTINCT|ALL expr )=Get the standard deviation of <I>expr</I>. This function differs from <CODE>STDDEV</CODE> in what it returns when there is only one input row. This function returns null and <CODE>STDDEV</CODE> returns 0. The standard deviation is the square root of the variance defined for the <CODE>VARIANCE</CODE> function.<P>\n<B>Expample:</B>\n<PRE>\nSELECT AVG(amount),STDDEV_SAMP(amount) FROM saleitems;\n\nAVG(AMOUNT) STDDEV_SAMP(AMOUNT)\n----------- -------------------\n    1628.75          1225.85412\n</PRE>
Aggregate Functions:SUM ( DISTINCT|ALL expr )=Get the sum of all <I>expr</I> values. If <CODE>DISTINCT</CODE> is specified only distinct values are calculated.<P>\n<B>Expample:</B>\n<PRE>\nSELECT SUM(profit) FROM saleitems;\n\nSUM(PROFIT)\n-----------\n       4765\n</PRE>
Aggregate Functions:VARIANCE ( DISTINCT|ALL expr )=Get the sample variance of the values in <I>expr</I>, if no values are available null is returned. The following calculation is used.\n<PRE>\n( SUM ( expr * expr ) - SUM ( expr ) * SUM ( expr ) / COUNT ( expr ) ) / \n	( COUNT ( expr ) - 1 )\n</PRE>\nIf applied to an empty set 0 is returned.\n<B>Expample:</B>\n<PRE>\nSELECT VARIANCE(profit) FROM saleitems;\n\nVARIANCE(PROFIT)\n----------------\n      81889.8958\n</PRE>
Aggregate Functions:VAR_POP ( expr )=Get the population variance of the values of <I>expr</I>. This is defined by the following formula.<P>\n<PRE>\n( SUM ( expr * expr ) - SUM ( expr ) * SUM ( expr ) / COUNT ( expr ) ) / \n	COUNT ( expr )\n</PRE>\n<B>Example:</B>\n<PRE>\nSELECT VAR_POP(profit) FROM saleitems;\n\nVAR_POP(PROFIT)\n---------------\n     76771.7773\n</PRE>
Aggregate Functions:VAR_SAMP ( DISTINCT|ALL expr )=Get the sample variance of the values in <I>expr</I>, if no values are available null is returned. The following calculation is used.\n<PRE>\n( SUM ( expr * expr ) - SUM ( expr ) * SUM ( expr ) / COUNT ( expr ) ) / \n	( COUNT ( expr ) - 1 )\n</PRE>\nIf applied to an empty set null is returned.\n<B>Expample:</B>\n<PRE>\nSELECT VAR_SAMP(profit) FROM saleitems;\n\nVAR_SAMP(PROFIT)\n----------------\n      81889.8958\n</PRE>
Analytic Functions:AVG ( DISTINCT|ALL expr ) OVER ( analytic_clause )=Calculates the avarage value of <I>expr</I>.<P>\nIf <CODE>DISTINCT</CODE> is specified duplicates of the same number is only counted as one\nnumber, if <CODE>ALL</CODE> or nothing is specified all numbers are counted equally. If <CODE>DISTINCT</CODE> is specified you can't use order by and windowing specifications in the <I>analytic_clause</I>.
Analytic Functions:CORR ( expr1 , expr2 ) OVER ( analytic_clause )=Calculate the coefficient of correlation of a set of number pairs.<P>\n\nPairs where either <I>expr1</I> or <I>expr2</I> are eliminated first. Then the following\ncalculation is performed:\n\n<PRE>\nCOVAR_POP(expr1, expr2) / (STDDEV_POP(expr1) * STDDEV_POP(expr2))\n</PRE>\n\nThe function returns a number, if applied to an empty set NULL is returned.
Analytic Functions:COUNT ( *|DISTINCT|ALL expr ) OVER ( analytic_clause )=Return the number of rows in the resultset. <CODE>DISTINCT</CODE> specifies that only\ndistinct values are to be counted. If <I>expr</I> is NULL it is not counted. <CODE>*</CODE>\n and <CODE>ALL</CODE> indicates that all rows should be counted. If <CODE>DISTINCT</CODE> is specified you can't use order by and windowing specifications in the <I>analytic_clause</I>.
Analytic Functions:COVAR_POP ( expr1 , expr2 ) OVER ( analytic_clause )=Get the population covariance of a set of pairs.<P>\n\nPairs where either <I>expr1</I> or <I>expr2</I> are eliminated first. Then the following\ncalculation is performed:\n\n<PRE>\n(SUM(expr1 * expr2) - SUM(expr2) * SUM(expr1) / n) / n\n</PRE>\n\nThe function returns a number, if applied to an empty set NULL is returned.<P>\n
Analytic Functions:COVAR_SAMP ( expr1 , expr2 ) OVER ( analytic_clause )=Get the sample covariance of a set of pairs.<P>\n\nPairs where either <I>expr1</I> or <I>expr2</I> are eliminated first. Then the following\ncalculation is performed:\n\n<PRE>\n(SUM(expr1 * expr2) - SUM(expr2) * SUM(expr1) / n) / (n - 1)\n</PRE>\n\nThe function returns a number, if applied to an empty set NULL is returned.<P>\n
Analytic Functions:CUME_DIST ( ) OVER ( analytic_clause )=This computes the relative position of a specified value in a group of values. For a given row the <CODE>CUME_DIST</CODE> of this row is the number of rows with lower than or equal to the value of the specified row divided by the total number of rows being evaluated. The values returned are greated than 0 and less than or equal to 1.
Analytic Functions:DENSE_RANK () OVER ( analytic_clause )=This function computes the rank of each row returned from a query in comparison to the other rows in the query based on the expression in the <CODE>ORDER BY</CODE> of the <I>analytic_clause</I>. Equal values receive the same rank. The next rank is then added with 1 in comparison to the <CODE>RANK</CODE> who adds the number of tied rows.
Analytic Functions:FIRST_VALUE ( expr ) OVER ( analytic_clause )=Returns the first value of <I>expr</I> in an ordered set of values.
Analytic Functions:LAG ( value_expr , offset , default ) OVER ( analytic_clause )=This function gives access to the previous values returned in the query. If <I>offset</I> is specified it indicates the number of rows before the current row to look, the default is 1. The <I>default</I> parameter can be used to specify the values if outside the specified window, the default is null.
Analytic Functions:LAST_VALUE ( expr ) OVER ( analytic_clause )=Returns the last value of <I>expr</I> in an ordered set of values.
Analytic Functions:LEAD ( expr , offset , default ) OVER ( analytic_clause )=This function gives access to future values returned in the query. If <I>offset</I> is specified it indicates the number of rows after the current row to look, the default is 1. The <I>default</I> parameter can be used to specify the values if outside the specified window, the default is null.
Analytic Functions:MAX ( expr ) OVER ( analytic_clause )=Get the largest value of <I>expr</I>.<P>
Analytic Functions:MIN ( expr ) OVER ( analytic_clause )=Get the smallest value of <I>expr</I>.<P>
Analytic Functions:NTILE ( expr ) OVER ( analytic_clause )=This is function divides a dataset into a number of buckets specified by <I>expr</I> and return the number of the bucket for the current row. The number of rows in each bucket can differ at most 1. If <I>expr</U> is larger than the number of rows only rows number of buckets will be filled with 1. Buckets are numbered from 1 to <I>expr</I>.
Analytic Functions:PERCENT_RANK () OVER ( analytic_clause )=This computes the relative position of a specified value in a group of values similar to the <CODE>CUME_DIST</CODE> function. The difference is that instead of counting the number of rows before or equal divided by the total number of rows in the set you first deduct one from both the number of rows before and the total number of rows.
Analytic Functions:RANK ( ) OVER ( analytic_clause )=This function computes the rank of each row returned from a query in comparison to the other rows in the query based on the expression in the <CODE>ORDER BY</CODE> of the <I>analytic_clause</I>. Equal values receive the same rank. The next rank is then added with the number of rows with this rank value.
Analytic Functions:RATIO_TO_REPORT ( expr ) OVER ( analytic_clause )=This function returns the ratio of <I>expr</I> in comparison to the sum of all <I>expr</I> over the entire set. If <I>expr</I> is null, null is also returned.
Analytic Functions:REGR_AVGX ( expr1 , expr2 ) OVER ( analytic_clause )=Pairs where either <I>expr1</I> or <I>expr2</I> are eliminated to begin with. Then the following function is calculated:\n<PRE>\nAVG ( expr2 )\n</PRE>\n
Analytic Functions:REGR_AVGY ( expr1 , expr2 ) OVER ( analytic_clause )=Pairs where either <I>expr1</I> or <I>expr2</I> are eliminated to begin with. Then the following function is calculated:\n<PRE>\nAVG ( expr2 )\n</PRE>\n
Analytic Functions:REGR_COUNT ( expr1 , expr2 ) OVER ( analytic_clause )=Pairs where either <I>expr1</I> or <I>expr2</I> are eliminated to begin with. This function then returns the number of valid pairs left.<P>\n
Analytic Functions:REGR_INTERCEPT ( expr1 , expr2 ) OVER ( analytic_clause )=Calculates the y-intercept of the regression line. Pairs where either <I>expr1</I> or <I>expr2</I> are eliminated to begin with. Then the following function is calculated:\n<PRE>\nAVG ( expr1 ) - REGR_SLOPE ( expr1 , expr2 ) * AVG ( expr2 )\n</PRE>\n
Analytic Functions:REGR_R2 ( expr1 , expr2 ) OVER ( analytic_clause )=Represent the determination or goodness of fit for the regression. Pairs where either <I>expr1</I> or <I>expr2</I> are eliminated to begin with. The value of the functions <CODE>VAR_POP ( expr1 )</CODE> and <CODE>VAR_POP ( expr2 )</CODE> is evaluated after null pairs are removed. The returned value is then one of the following:\n<UL>\n<LI>null if <CODE>VAR_POP ( expr2 )</CODE> = 0.\n<LI>1 if <CODE>VAR_POP ( expr1 )</CODE> = 0 and <CODE>VAR_POP ( expr2 )</CODE> != 0.\n<LI><CODE>POWER ( CORR ( expr1 , expr2 ) , 2 )</CODE> if <CODE>VAR_POP ( expr1 )</CODE> > 0 and <CODE>VAR_POP ( expr2 )</CODE> != 0.\n</UL>\n
Analytic Functions:REGR_SLOPE ( expr1 , expr2 ) OVER ( analytic_clause )=This function returns the slope of the line. Pairs where either <I>expr1</I> or <I>expr2</I> are eliminated to begin with. Then the following function is calculated:\n<PRE>\nCOVAR_POP ( expr1 , expr2 ) / VAR_POP ( expr2 )\n</PRE>\n
Analytic Functions:REGR_SXX ( expr1 , expr2 ) OVER ( analytic_clause )=Pairs where either <I>expr1</I> or <I>expr2</I> are eliminated to begin with. Then the following function is calculated:\n<PRE>\nREGR_COUNT ( expr1 , expr2 ) / VAR_POP ( expr2 )\n</PRE>\n
Analytic Functions:REGR_SXY ( expr1 , expr2 ) OVER ( analytic_clause )=Pairs where either <I>expr1</I> or <I>expr2</I> are eliminated to begin with. Then the following function is calculated:\n<PRE>\nREGR_COUNT ( expr1 , expr2 ) / VAR_POP ( expr1 )\n</PRE>\n
Analytic Functions:REGR_SYY ( expr1 , expr2 ) OVER ( analytic_clause )=Pairs where either <I>expr1</I> or <I>expr2</I> are eliminated to begin with. Then the following function is calculated:\n<PRE>\nREGR_COUNT ( expr1 , expr2 ) / COVAR_POP ( expr1 )\n</PRE>\n
Analytic Functions:ROW_NUMBER ( ) OVER ( analytic_clause )=This function will return a unique value to each row that is returned in the order specify by the <CODE>ORDER BY</CODE> clause of the <I>analytic_clause</I>. The first row returned is 1.
Analytic Functions:STDDEV ( DISTINCT|ALL expr ) OVER ( analytic_clause )=Get the standard deviation of <I>expr</I>. This function differs from <CODE>STDDEV_SAMP</CODE> in what it returns when there is only one input row. This function returns 0 and <CODE>STDDEV_SAMP</CODE> returns null. The standard deviation is the square root of the variance defined for the <CODE>VARIANCE</CODE> function. If <CODE>DISTINCT</CODE> is specified you can't use order by and windowing specifications in the <I>analytic_clause</I>.\n
Analytic Functions:STDDEV_POP ( expr ) OVER ( analytic_clause )=Get the square root of the population variance. This is the same as the square root of the <CODE>VAR_POP</CODE> function.
Analytic Functions:STDDEV_SAMP ( DISTINCT|ALL expr ) OVER ( analytic_clause )=Get the standard deviation of <I>expr</I>. This function differs from <CODE>STDDEV</CODE> in what it returns when there is only one input row. This function returns null and <CODE>STDDEV</CODE> returns 0. The standard deviation is the square root of the variance defined for the <CODE>VARIANCE</CODE> function. If <CODE>DISTINCT</CODE> is specified you can't use order by and windowing specifications in the <I>analytic_clause</I>.\n
Analytic Functions:SUM ( DISTINCT|ALL expr ) OVER ( analytic_clause )=Get the sum of all <I>expr</I> values. If <CODE>DISTINCT</CODE> is specified only distinct values are calculated. If <CODE>DISTINCT</CODE> is specified you can't use order by and windowing specifications in the <I>analytic_clause</I>.
Analytic Functions:VARIANCE ( DISTINCT|ALL expr ) OVER ( analytic_clause )=Get the sample variance of the values in <I>expr</I>, if no values are available null is returned. The following calculation is used.\n<PRE>\n( SUM ( expr * expr ) - SUM ( expr ) * SUM ( expr ) / COUNT ( expr ) ) / \n	( COUNT ( expr ) - 1 )\n</PRE>\nIf applied to an empty set 0 is returned. If <CODE>DISTINCT</CODE> is specified you can't use order by and windowing specifications in the <I>analytic_clause</I>.
Analytic Functions:VAR_POP ( expr ) OVER ( analytic_clause )=Get the population variance of the values of <I>expr</I>. This is defined by the following formula.<P>\n<PRE>\n( SUM ( expr * expr ) - SUM ( expr ) * SUM ( expr ) / COUNT ( expr ) ) / \n	COUNT ( expr )\n</PRE>\n
Analytic Functions:VAR_SAMP ( DISTINCT|ALL expr ) OVER ( analytic_clause )=Get the sample variance of the values in <I>expr</I>, if no values are available null is returned. The following calculation is used.\n<PRE>\n( SUM ( expr * expr ) - SUM ( expr ) * SUM ( expr ) / COUNT ( expr ) ) / \n	( COUNT ( expr ) - 1 )\n</PRE>\nIf applied to an empty set null is returned. If <CODE>DISTINCT</CODE> is specified you can't use order by and windowing specifications in the <I>analytic_clause</I>.
Char to Char Functions:CHR ( n USING NCHAR_CS )=Get the character specified by the binary equivalent of <I>n</I> in the national character set. If <CODE>USING NCHAR_CS</CODE> is used, this function returns the equivalent of the national <CODE>NVARCHAR2</CODE>. Otherwise the <CODE>VARCHAR2</CODE> character set is user.<P>\n<B>Examples:</B>\n<PRE>\nSELECT CHR ( 65 ) || CHR ( 66 ) || CHR ( 67 ) abc FROM DUAL;\n\nABC\n---\nABC\n</PRE>
Char to Char Functions:CONCAT ( char1 , char2 )=This function concatenates the <I>char1</I> string with <I>char2</I>. Which means it will perform the same task as the operator <CODE>||</CODE>.<P>\n<B>Examples:</B>\n<PRE>\nSELECT CONCAT ( 'Foo' , 'bar' ) FROM DUAL;\n\nCONCAT\n------\nFoobar\n</PRE>
Char to Char Functions:INITCAP ( char )=Return the string of <I>char</I> with the first character in uppercase and all the rest in lowercase.<P>\n<B>Examples:</B>\n<PRE>\nSELECT INITCAP ( 'MaUrItZ' ) FROM DUAL;\n\nINITCAP\n-------\nMauritz\n</PRE>
Char to Char Functions:LOWER ( char )=Returns the string <I>char</I> with all letters in lowercase.<P>\n<B>Examples:</B>\n<PRE>\nSELECT LOWER ( 'FoPPa' ) FROM DUAL;\n\nLOWER\n-----\nfoppa\n</PRE>
Char to Char Functions:LPAD ( char1 , n , char2 )=This function returns <I>char1</I> padded from the left to <I>n</I> number of characters. If <I>char2</I> is specified this is used for padding instead of space which is the default.<P>\n<B>Examples:</B>\n<PRE>\nSELECT LPAD ( '>Padding' , 12 , '-=' ) FROM DUAL;\n\nLPAD('>PADDI\n------------\n-=-=>Padding\n</PRE>
Char to Char Functions:LTRIM ( char1 , char2 )=Removes all characters from the <I>char1</I> available in the set defined by the characters available in the string <I>char2</I> from the left until a character not in the set is encountered.<P>\n<B>Examples:</B>\n<PRE>\nSELECT LTRIM ( '-=-=-=->Text' , '-=>' ) FROM DUAL;\n\nLTRI\n----\nText\n</PRE>
Char to Char Functions:NLSSORT ( char , nlsparam )=This function returns a string used for sorting the <I>char</I>. The value of <I>nlsparam</I> has the form <CODE>'NLS_<I>param</I> = <I>value</I>'</CODE> usually <CODE>'NLS_SORT = <I>sort</I>'</CODE> where sort can either be <CODE>BINARY</CODE> or any other sort specifier.<P>\n<B>Examples:</B>\n<PRE>\nSELECT NLSSORT ( 'ABCÅÄÖ' , 'NLS_SORT = Swedish' ) FROM DUAL;\n\nNLSSORT('ABCÅÄÖ','NLS_SORT=SWEDISH')\n----------------------------------------------------\n14191E898A8B0001010101010100\n</PRE>
Char to Char Functions:NLS_INITCAP ( char , nlsparam )=This function returns the string <I>char</I> with the first character is made uppercase and all the other lowercase. The value of <I>nlsparam</I> has the form <CODE>'NLS_<I>param</I> = <I>value</I>'</CODE> usually <CODE>'NLS_SORT = <I>sort</I>'</CODE> where sort can either be <CODE>BINARY</CODE> or any other sort specifier.<P>\n<B>Examples:</B>\n<PRE>\nSELECT NLS_INITCAP ( 'ABCÅÄÖ' , 'NLS_SORT = Swedish' ) FROM DUAL;\n\nNLS_IN\n------\nAbcåäö\n</PRE>
Char to Char Functions:NLS_LOWER ( char , nlsparam )=This function returns the string <I>char</I> with all letters converted to lowercase. The value of <I>nlsparam</I> has the form <CODE>'NLS_<I>param</I> = <I>value</I>'</CODE> usually <CODE>'NLS_SORT = <I>sort</I>'</CODE> where sort can either be <CODE>BINARY</CODE> or any other sort specifier.<P>\n<B>Examples:</B>\n<PRE>\nSELECT NLS_LOWER ( 'ABCÅÄÖ' , 'NLS_SORT = Swedish' ) FROM DUAL;\n\nNLS_LO\n------\nabcåäö\n</PRE>
Char to Char Functions:NLS_UPPER ( char , nlsparam )=This function returns the string <I>char</I> with all letters converted to uppercase. The value of <I>nlsparam</I> has the form <CODE>'NLS_<I>param</I> = <I>value</I>'</CODE> usually <CODE>'NLS_SORT = <I>sort</I>'</CODE> where sort can either be <CODE>BINARY</CODE> or any other sort specifier.<P>\n<B>Examples:</B>\n<PRE>\nSELECT NLS_UPPER ( 'ABCÅÄÖ' , 'NLS_SORT = Swedish' ) FROM DUAL;\n\nNLS_UP\n------\nABCÅÄÖ\n</PRE>
Char to Char Functions:REPLACE ( char , search , replace )=This function will return a string where every occurance in <I>char</I> of the string <I>search</I> is replaced with the <I>replace</I> string.<P>\n<B>Example:</B>\n<PRE>\nSELECT REPLACE ('Gnu','Gnu','Gnu Is Not Unix') FROM DUAL;\n\nREPLACE('GNU','\n---------------\nGnu Is Not Unix\n</PRE>
Char to Char Functions:RPAD ( char1 , n , char2 )=This function returns <I>char1</I> padded from the right to <I>n</I> number of characters. If <I>char2</I> is specified this is used for padding instead of space which is the default.<P>\n<B>Examples:</B>\n<PRE>\nSELECT RPAD ( 'Padding&lt;' , 12 , '=-' ) FROM DUAL;\n\nRPAD('PADDIN\n------------\nPadding&lt;=-=-\n</PRE>
Char to Char Functions:RTRIM ( char1 , char2 )=Removes all characters from the <I>char1</I> available in the set defined by the characters available in the string <I>char2</I> from the right until a character not in the set is encountered.<P>\n<B>Examples:</B>\n<PRE>\nSELECT RTRIM ( 'Text&lt;=-=-=-' , '&lt;-=' ) FROM DUAL;\n\nRTRI\n----\nText\n</PRE>
Char to Char Functions:SOUNDEX ( char )=Returns a string that contains a phonetic representation of <I>char</I>. This is usefull for comparing strings that sound similarly, but are spelled different. The algorithm used is available in <I>The Art of Computer Programming, Volume 3: Sorting and Searching, by Donald E. Knuth</I>.<P>\n<B>Examples:</B>\n<PRE>\nSELECT 'Johnson sounds like Jonsson'\n  FROM DUAL WHERE SOUNDEX ( 'Johnson' ) = SOUNDEX ( 'Jonsson' );\n\n'JOHNSONSOUNDSLIKEJONSSON'\n---------------------------\nJohnson sounds like Jonsson\n</PRE>
Char to Char Functions:SUBSTR ( char , m , n )=This function returns a substring of of the <I>char</I> string. If <I>m</I> is 0 it is treated as 1 which means the beginning of the string, 2 meaning the second character etc. If <I>m</I> is negative it will count from the end of the string with -1 meaning the last character of the string. If <I>n</I> is not specified the rest of the string is returned.<P>\n<B>Examples:</B>\n<PRE>\nSELECT SUBSTR('Henrik P Johnson',8,3) FROM DUAL;\n\nSUB\n---\nP J\n</PRE>
Char to Char Functions:SUBSTRB ( char , m , n )=This function returns a substring of of the <I>char</I> string. The difference from <CODE>SUBSTR</CODE> is that this function counts bytes instead of characters which differs if you use multichar charactersets.<P>\n<B>Examples:</B><P>\nIf run on a UNICODE characterset database.\n<PRE>\nSELECT SUBSTRB('Henrik P Johnson',7,4) FROM DUAL;\n\nSU\n--\nri\n</PRE>
Char to Char Functions:TRANSLATE ( char , from , to )=This function will return a string where every occurance of a character in <I>char</I> is replaced from the character in <I>from</I> with the corresponding character in <I>to</I>. If the character is not available in <I>to</I> it is removed from the result.<P>\n<B>Example:</B>\n<PRE>\nSELECT TRANSLATE ( 'Mauritz' , 'Mauritz' , 'Henrik' ) FROM DUAL;\n\nTRANSL\n------\nHenrik\n</PRE>
Char to Char Functions:TRIM ( LEADING|TRAILING|BOTH trim FROM source )=This function can trim characters from both beginning (If <CODE>LEADING</CODE> or <CODE>BOTH</CODE> is specified) and end (If <CODE>TRAILING</CODE> or <CODE>BOTH</CODE>) with <CODE>BOTH</CODE> being the default. If <I>trim</I> isn't specified any whitespace is the default. Any characyers in the <I>trim</I> set will be removed from the specified ends of <I>source</I>.<P>\n<B>Examples:</B>\n<PRE>\nSELECT TRIM ( '-=-=-=&gt;Text&lt;=-=-=-' , '&lt;-=&gt;' ) FROM DUAL;\n\nTRIM\n----\nText\n</PRE>
Char to Char Functions:UPPER ( char )=Returns the string <I>char</I> with all letters in uppercase.<P>\n<B>Examples:</B>\n<PRE>\nSELECT UPPER ( 'FoPPa' ) FROM DUAL;\n\nUPPER\n-----\nFOPPA\n</PRE>
Char to Number Functions:ASCII ( char )=Get the number representation of the first character in <I>char</I>.<P>\n<B>Example:</B>\n<PRE>\nSELECT ASCII('Aloha') FROM DUAL;\n\nASCII('ALOHA')\n--------------\n            65\n</PRE>
Char to Number Functions:INSTR ( string , substring , pos , occurance )=Search for <I>substring</I> in <I>string</I>. If <I>pos</I> is specified it indicates the character in <I>string</I> to start searching, if negative Oracle will search backwards in the string. If <I>occurance</I> is specified it indicates how many hits to discard before returning (1 meaning the first match). The function returns the position of the charater where the match begins in <I>string</I>.<P>\n<B>Example:</B>\n<PRE>\nSELECT INSTR('excellence','e',3,2) FROM DUAL;\n\nINSTR('EXCELLENCE','E',3,2)\n---------------------------\n                          7\n</PRE>
Char to Number Functions:INSTRB ( str , substring , pos , occurance )=This function is the same as <CODE>INSTR</CODE> except that <I>pos</I> and the returned number is in bytes instead of characters.
Char to Number Functions:LENGTH ( char )=Get the length of <I>char</I> in characters.<P>\n<B>Example:</B>\n<PRE>\nSELECT LENGTH('GlobeCom') FROM DUAL;\n\nLENGTH('GLOBECOM')\n------------------\n                 8\n</PRE>
Char to Number Functions:LENGTHB ( char )=Get the length of <I>char</I> in bytes.<P>\n<B>Example:</B><P>\nIf performed on a UNICODE database.\n<PRE>\nSELECT LENGTHB('GlobeCom') FROM DUAL;\n\nLENGTHB('GLOBECOM')\n-------------------\n                 16\n</PRE>
Conversion Functions:CHARTOROWID ( char )=
Conversion Functions:CONVERT ( char , dest_char_set , source_char_set )=
Conversion Functions:HEXTORAW=
Conversion Functions:NUMTODSINTERVAL=
Conversion Functions:NUMTOYMINTERVAL=
Conversion Functions:RAWTOHEX=
Conversion Functions:ROWIDTOCHAR=
Conversion Functions:TO_CHAR(dateconversion)=
Conversion Functions:TO_CHAR(numberconversion)=
Conversion Functions:TO_DATE=
Conversion Functions:TO_LOB=
Conversion Functions:TO_MULTI_BYTE=
Conversion Functions:TO_NUMBER=
Conversion Functions:TO_SINGLE_BYTE=
Conversion Functions:TRANSLATE...USING=
Date Functions:ADD_MONTHS=
Date Functions:LAST_DAY=
Date Functions:MONTHS_BETWEEN=
Date Functions:NEW_TIME=
Date Functions:NEXT_DAY=
Date Functions:ROUND=
Date Functions:SYSDATE=
Date Functions:TRUNC=
Example Tables=The following SQL script will create the example tables used in these template descriptions.<P>\n<PRE>\n<HR>\nPROMPT CREATE TABLE saleitems\n\nCREATE TABLE saleitems\n(\n    saleid                          NUMBER                          NOT NULL\n  , itemid                          NUMBER                          NOT NULL\n  , quantity                        NUMBER                          \n  , amount                          NUMBER                          \n  , profit                          NUMBER                          \n);\n\nPROMPT ALTER TABLE saleitems ADD CONSTRAINT saleitems_pk PRIMARY KEY\n\nALTER TABLE saleitems ADD CONSTRAINT saleitems_pk PRIMARY KEY\n(\n    saleid,\n    itemid\n);\n\nPROMPT CREATE TABLE sales\n\nCREATE TABLE sales\n(\n    saleid                          NUMBER                          NOT NULL\n  , customerid                      NUMBER                          \n  , saledate                        DATE                            \n  , deliverydate                    DATE                            \n  , sellerid                        NUMBER                          \n)\n;\n\nPROMPT ALTER TABLE sales ADD CONSTRAINT sales_pk PRIMARY KEY\n\nALTER TABLE sales ADD CONSTRAINT sales_pk PRIMARY KEY\n(\n    saleid\n);\n\nPROMPT CONTENTS OF saleitems\n\nINSERT INTO saleitems (saleid,itemid,quantity,amount,profit) VALUES ('1','1','1','1000','200');\nINSERT INTO saleitems (saleid,itemid,quantity,amount,profit) VALUES ('1','2','10','1200','60');\nINSERT INTO saleitems (saleid,itemid,quantity,amount,profit) VALUES ('1','3','2','2000','400');\nINSERT INTO saleitems (saleid,itemid,quantity,amount,profit) VALUES ('2','2','2','240','5');\nINSERT INTO saleitems (saleid,itemid,quantity,amount,profit) VALUES ('2','3','3','3000','600');\nINSERT INTO saleitems (saleid,itemid,quantity,amount,profit) VALUES ('2','4','6','600','100');\nINSERT INTO saleitems (saleid,itemid,quantity,amount,profit) VALUES ('3','3','1','1000','200');\nINSERT INTO saleitems (saleid,itemid,quantity,amount,profit) VALUES ('4','2','6','720','30');\nINSERT INTO saleitems (saleid,itemid,quantity,amount,profit) VALUES ('4','1','2','2000','500');\nINSERT INTO saleitems (saleid,itemid,quantity,amount,profit) VALUES ('5','3','4','4000','1000');\nINSERT INTO saleitems (saleid,itemid,quantity,amount,profit) VALUES ('5','1','3','3000','600');\nINSERT INTO saleitems (saleid,itemid,quantity,amount,profit) VALUES ('6','2','5','600','100');\nINSERT INTO saleitems (saleid,itemid,quantity,amount,profit) VALUES ('6','4','4','400','50');\nINSERT INTO saleitems (saleid,itemid,quantity,amount,profit) VALUES ('7','4','3','300','20');\nINSERT INTO saleitems (saleid,itemid,quantity,amount,profit) VALUES ('8','1','3','3000','400');\nINSERT INTO saleitems (saleid,itemid,quantity,amount,profit) VALUES ('9','1','3','3000','500');\nCOMMIT;\n\nPROMPT CONTENTS OF sales\n\nINSERT INTO sales (saleid,customerid,saledate,deliverydate,sellerid) VALUES ('1','1',TO_DATE('2000-01-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),TO_DATE('2000-01-05 00:00:00','YYYY-MM-DD HH24:MI:SS'),'1');\nINSERT INTO sales (saleid,customerid,saledate,deliverydate,sellerid) VALUES ('2','1',TO_DATE('2001-06-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),NULL,'2');\nINSERT INTO sales (saleid,customerid,saledate,deliverydate,sellerid) VALUES ('3','2',TO_DATE('2000-01-05 00:00:00','YYYY-MM-DD HH24:MI:SS'),TO_DATE('2000-01-20 00:00:00','YYYY-MM-DD HH24:MI:SS'),'3');\nINSERT INTO sales (saleid,customerid,saledate,deliverydate,sellerid) VALUES ('4','2',TO_DATE('2001-02-15 00:00:00','YYYY-MM-DD HH24:MI:SS'),TO_DATE('2001-02-24 00:00:00','YYYY-MM-DD HH24:MI:SS'),'2');\nINSERT INTO sales (saleid,customerid,saledate,deliverydate,sellerid) VALUES ('5','3',TO_DATE('2001-03-02 00:00:00','YYYY-MM-DD HH24:MI:SS'),TO_DATE('2001-03-19 00:00:00','YYYY-MM-DD HH24:MI:SS'),'2');\nINSERT INTO sales (saleid,customerid,saledate,deliverydate,sellerid) VALUES ('6','3',TO_DATE('2001-04-03 00:00:00','YYYY-MM-DD HH24:MI:SS'),TO_DATE('2001-04-13 00:00:00','YYYY-MM-DD HH24:MI:SS'),'3');\nINSERT INTO sales (saleid,customerid,saledate,deliverydate,sellerid) VALUES ('7','2',TO_DATE('2001-03-23 00:00:00','YYYY-MM-DD HH24:MI:SS'),TO_DATE('2001-04-04 00:00:00','YYYY-MM-DD HH24:MI:SS'),'3');\nINSERT INTO sales (saleid,customerid,saledate,deliverydate,sellerid) VALUES ('8','1',TO_DATE('2001-02-26 00:00:00','YYYY-MM-DD HH24:MI:SS'),TO_DATE('2001-03-02 00:00:00','YYYY-MM-DD HH24:MI:SS'),'1');\nCOMMIT;\n\n</PRE>
Misc Single-Row Functions:BFILENAME ( ' directory ' , ' filename ' )=
Misc Single-Row Functions:DUMP=
Misc Single-Row Functions:EMPTY_BLOB=
Misc Single-Row Functions:EMPTY_CLOB=
Misc Single-Row Functions:GREATEST=
Misc Single-Row Functions:LEAST=
Misc Single-Row Functions:NLS_CHARSET_DECL_LEN=
Misc Single-Row Functions:NLS_CHARSET_ID=
Misc Single-Row Functions:NLS_CHARSET_NAME=
Misc Single-Row Functions:NVL=
Misc Single-Row Functions:NVL2=
Misc Single-Row Functions:SYS_CONTEXT=
Misc Single-Row Functions:SYS_GUID=
Misc Single-Row Functions:UID=
Misc Single-Row Functions:USER=
Misc Single-Row Functions:USERENV=
Misc Single-Row Functions:VSIZE=
Number functions:ABS ( n )=ABS returns the absolute value of <I>n</I>.<P>\n<B>Example:</B><P>\n<PRE>\nSELECT ABS(-32) FROM DUAL;\n\nABS(-32)\n--------\n      32\n</PRE>
Number functions:ACOS ( n )=
Number functions:ADD_MONTHS ( d , n )=
Number functions:ASIN ( n )=
Number functions:ATAN ( n )=
Number functions:ATAN2 ( n , m )=
Number functions:BITAND ( argument1 , argument2 )=
Number functions:CEIL ( n )=
Number functions:COS ( n )=
Number functions:COSH ( n )=
Number functions:EXP=
Number functions:FLOOR=
Number functions:LN=
Number functions:LOG=
Number functions:MOD=
Number functions:POWER=
Number functions:ROUND=
Number functions:SIGN=
Number functions:SIN=
Number functions:SINH=
Number functions:SQRT=
Number functions:TAN=
Number functions:TANH=
Number functions:TRUNC=
Object Functions:DEREF=
Object Functions:MAKE_REF=
Object Functions:REF=
Object Functions:REFTOHEX=
Object Functions:VALUE=
