<HTML>
<HEAD>
<TITLE>class toExtract</TITLE>

<META NAME="Generator" CONTENT="KDOC ">
</HEAD>
<BODY bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#000099" alink= "#ffffff">
<TABLE WIDTH="100%" BORDER="0">
<TR>
<TD>
	<TABLE BORDER="0">
		<TR><TD valign="top" align="left" cellspacing="10">
		<h1>class toExtract</h1>
		</TD>
		<TD valign="top" align="right" colspan="1">
 This class can be used to reverse engineered database objects. <small><A HREF="#longdesc">More...</A></small></TD></TR>
	</TABLE>
	<HR>
	<TABLE BORDER="0">
		<TR><TH>Definition</TH><TD><code>#include &lt;<A HREF="toextract_h.html">toextract.h</A>&gt;</code></TD></TR>
<TR><TH><A HREF="full-list-toExtract.html">List of all Methods</A></TH></TR>
	</TABLE>
	</TD>
<TD align="right"><TABLE BORDER="0"><TR><TD><small><A HREF="index-long.html">Annotated List</A></small></TD></TR>
<TR><TD><small><A HREF="header-list.html">Files</A></small></TD></TR>
<TR><TD><small><A HREF="all-globals.html">Globals</A></small></TD></TR>
<TR><TD><small><A HREF="hier.html">Hierarchy</A></small></TD></TR>
<TR><TD><small><A HREF="index.html">Index</A></small></TD></TR>
</TABLE></TD></TR></TABLE>
<h4>Public Types</h4><ul><LI>class <A HREF="toExtract__datatype.html">datatype</A>
</LI>
<LI>class <A HREF="toExtract__extractor.html">extractor</A>
</LI>
<LI>struct <A HREF="toExtract__columnInfo.html">columnInfo</A>
</LI>
</ul><h4>Public Methods</h4><ul><LI>&nbsp;<b><A HREF="#ref36">toExtract</A></b> (<A HREF="toConnection.html">toConnection</A> &conn,<A HREF="#QWidget">QWidget</A> *parent) 
</LI>
<LI>QString &nbsp;<b><A HREF="#ref37">create</A></b> (std::list<QString> &object) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref38">create</A></b> (<A HREF="#QTextStream">QTextStream</A> &stream,std::list<QString> &object) 
</LI>
<LI>std::list<QString> &nbsp;<b><A HREF="#ref39">describe</A></b> (std::list<QString> &object) 
</LI>
<LI>QString &nbsp;<b><A HREF="#ref40">drop</A></b> (std::list<QString> &object) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref41">drop</A></b> (<A HREF="#QTextStream">QTextStream</A> &stream,std::list<QString> &object) 
</LI>
<LI>QString &nbsp;<b><A HREF="#ref42">migrate</A></b> (std::list<QString> &drpLst,std::list<QString> &crtLst) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref43">migrate</A></b> (<A HREF="#QTextStream">QTextStream</A> &stream,std::list<QString> &drpLst,std::list<QString> &crtLst) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref44">setState</A></b> (const QCString &name,const QVariant &val) 
</LI>
<LI>QVariant &nbsp;<b><A HREF="#ref45">state</A></b> (const QCString &name) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref46">setSchema</A></b> (const QString &schema) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref47">setResize</A></b> (const QString &resize) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref48">setPrompt</A></b> (bool prompt) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref49">setHeading</A></b> (bool heading) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref50">setConstraints</A></b> (bool constraints) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref51">setIndexes</A></b> (bool indexes) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref52">setGrants</A></b> (bool val) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref53">setStorage</A></b> (bool val) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref54">setParallel</A></b> (bool val) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref55">setPartition</A></b> (bool val) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref56">setContents</A></b> (bool val,int commitdistance) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref57">setComments</A></b> (bool val) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref58">setCode</A></b> (bool val) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref59">setBlockSize</A></b> (int val) 
</LI>
<LI>const QString &&nbsp;<b><A HREF="#ref60">getSchema</A></b> (void) 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref61">getResize</A></b> (void) 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref62">getPrompt</A></b> (void) 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref63">getHeading</A></b> (void) 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref64">getConstraints</A></b> (void) 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref65">getIndexes</A></b> (void) 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref66">getGrants</A></b> (void) 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref67">getStorage</A></b> (void) 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref68">getParallel</A></b> (void) 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref69">getPartition</A></b> (void) 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref70">getContents</A></b> (void) 
</LI>
<LI>int &nbsp;<b><A HREF="#ref71">getCommitDistance</A></b> (void) 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref72">getComments</A></b> (void) 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref73">getCode</A></b> (void) 
</LI>
<LI>int &nbsp;<b><A HREF="#ref74">getBlockSize</A></b> (void) 
</LI>
<LI><A HREF="toConnection.html">toConnection</A> &&nbsp;<b><A HREF="#ref75">connection</A></b> () 
</LI>
<LI>void &nbsp;<b><A HREF="#ref76">initialNext</A></b> (const QString &blocks,QString &initial,QString &next) 
</LI>
<LI>QString &nbsp;<b><A HREF="#ref77">intSchema</A></b> (const QString &owner,bool desc) 
</LI>
<LI>std::list<datatype> &nbsp;<b><A HREF="#ref78">datatypes</A></b> () 
</LI>
<LI>QString &nbsp;<b><A HREF="#ref79">createFromParse</A></b> (std::list<<A HREF="toSQLParse__statement.html">toSQLParse::statement</A>>::iterator start,
			  std::list<<A HREF="toSQLParse__statement.html">toSQLParse::statement</A>>::iterator end) 
</LI>
</ul><h4>Public Static Methods</h4><ul><LI>static  void &nbsp;<b><A HREF="#ref80">srcDst2DropCreate</A></b> (std::list<QString> &source,std::list<QString> &destination,
				std::list<QString> &drop,std::list<QString> &creat) 
</LI>
<LI>static  bool &nbsp;<b><A HREF="#ref81">canHandle</A></b> (<A HREF="toConnection.html">toConnection</A> &conn) 
</LI>
<LI>static  void &nbsp;<b><A HREF="#ref82">addDescription</A></b> (std::list<QString> &ret,const std::list<QString> &ctx,
			     const QString &arg1=QString::null,const QString &arg2=QString::null,
			     const QString &arg3=QString::null,const QString &arg4=QString::null,
			     const QString &arg5=QString::null,const QString &arg6=QString::null,
			     const QString &arg7=QString::null,const QString &arg8=QString::null,
			     const QString &arg9=QString::null) 
</LI>
<LI>static  std::list<QString> &nbsp;<b><A HREF="#ref83">splitDescribe</A></b> (const QString &str) 
</LI>
<LI>static  QString &nbsp;<b><A HREF="#ref84">partDescribe</A></b> (const QString &str,int level) 
</LI>
<LI>static  QString &nbsp;<b><A HREF="#ref85">contextDescribe</A></b> (const QString &str,int level) 
</LI>
<LI>static  std::list<columnInfo> &nbsp;<b><A HREF="#ref87">parseColumnDescription</A></b> (std::list<QString>::const_iterator begin,
						      std::list<QString>::const_iterator end,
						      int level=3) 
</LI>
<LI>static  std::list<columnInfo> &nbsp;<b><A HREF="#ref88">parseColumnDescription</A></b> (const std::list<QString> &description,int level=3) 
</LI>
</ul><h4>Public Members</h4><ul><LI>friend class <b><A HREF="#ref89">extractor</A></b></LI>
</ul><HR><H2><A NAME="longdesc">Detailed Description</A></H2><p>
 This class can be used to reverse engineered database objects.
 </p>
<A NAME="toExtract__datatype.html"></A><A NAME="ref1"></A><table width="100%"><tr bgcolor="#eeeeee"><td><strong>datatype</strong> <small>(class)</small></td><td align="right"><h3><strong>datatype</strong></h3></td></tr></table><p></p><p> Describes an available datatype for the database.
   </p>
<A NAME="toExtract__extractor.html"></A><A NAME="ref2"></A><table width="100%"><tr bgcolor="#eeeeee"><td><strong>extractor</strong> <small>(class)</small></td><td align="right"><h3><strong>extractor</strong></h3></td></tr></table><p></p><p> This is an abstract class to implement part of an extractor for a database. Observe
 that an extractor must be stateless and threadsafe except for constructors and
 destructors. Use the toExtract::context function for saving context.
   </p>
<A NAME="toExtract"></A><A NAME="ref36"></A><table width="100%"><tr bgcolor="#eeeeee"><td>&nbsp;<strong>toExtract</strong> (<A HREF="toConnection.html">toConnection</A> &conn,<A HREF="#QWidget">QWidget</A> *parent)
<br></td><td align="right"><h3><strong>toExtract</strong></h3></td></tr></table><p></p><p> Create a new extractor.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>conn</i></TD><TD align="left" valign="top">Connection to extract from.
</TD></TR>
<TR><TD align="left" valign="top"><i>parent</i></TD><TD align="left" valign="top">Parent widget of progress indicator.
   </TD></TR>
</TABLE></P>
<A NAME="create"></A><A NAME="ref37"></A><table width="100%"><tr bgcolor="#eeeeee"><td>QString &nbsp;<strong>create</strong> (std::list<QString> &object)
<br></td><td align="right"><h3><strong>create</strong></h3></td></tr></table><p></p><p> Create script to recreate list of objects.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>object</i></TD><TD align="left" valign="top">List of object. This has the format {type}:{schema}.{object}.
               The type is database dependent but can as an example be of
               CONSTRAINT, DATABASE LINK, EXCHANGE INDEX,
               EXCHANGE TABLE, FUNCTION, INDEX, MATERIALIZED VIEW,
               MATERIALIZED VIEW LOG, PACKAGE, PACKAGE BODY, PROCEDURE,
               PROFILE, ROLE, ROLE GRANTS, ROLLBACK SEGMENT, SEQUENCE,
               SNAPSHOT, SNAPSHOT LOG, SYNONYM, TABLE, TABLE FAMILY,
               TABLE CONTENTS, TABLE REFERENCES, TABLESPACE, TRIGGER,
               TRIGGER, TYPE, USER, USER GRANTS for Oracle databases.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: A string containing a script to recreate the specified objects.
   </p>
<A NAME="create"></A><A NAME="ref38"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>create</strong> (<A HREF="#QTextStream">QTextStream</A> &stream,std::list<QString> &object)
<br></td><td align="right"><h3><strong>create</strong></h3></td></tr></table><p></p><p> Create script to recreate list of objects.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>stream</i></TD><TD align="left" valign="top">Stream to write result to.
</TD></TR>
<TR><TD align="left" valign="top"><i>object</i></TD><TD align="left" valign="top">List of object. This has the format {type}:{schema}.{object}.
               The type is database dependent but can as an example be of
               CONSTRAINT, DATABASE LINK, EXCHANGE INDEX,
               EXCHANGE TABLE, FUNCTION, INDEX, MATERIALIZED VIEW,
               MATERIALIZED VIEW LOG, PACKAGE, PACKAGE BODY, PROCEDURE,
               PROFILE, ROLE, ROLE GRANTS, ROLLBACK SEGMENT, SEQUENCE,
               SNAPSHOT, SNAPSHOT LOG, SYNONYM, TABLE, TABLE FAMILY,
               TABLE CONTENTS, TABLE REFERENCES, TABLESPACE, TRIGGER,
               TRIGGER, TYPE, USER, USER GRANTS for Oracle databases.
   </TD></TR>
</TABLE></P>
<A NAME="describe"></A><A NAME="ref39"></A><table width="100%"><tr bgcolor="#eeeeee"><td>std::list<QString> &nbsp;<strong>describe</strong> (std::list<QString> &object)
<br></td><td align="right"><h3><strong>describe</strong></h3></td></tr></table><p></p><p> Create a description of objects.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>object</i></TD><TD align="left" valign="top">List of object. This has the format {type}:{schema}.{object}.
               The type is database dependent but can as an example be of
               CONSTRAINT, DATABASE LINK, EXCHANGE INDEX,
               EXCHANGE TABLE, FUNCTION, INDEX, MATERIALIZED VIEW,
               MATERIALIZED VIEW LOG, PACKAGE, PACKAGE BODY, PROCEDURE,
               PROFILE, ROLE, ROLE GRANTS, ROLLBACK SEGMENT, SEQUENCE,
               SNAPSHOT, SNAPSHOT LOG, SYNONYM, TABLE, TABLE FAMILY,
               TABLE CONTENTS, TABLE REFERENCES, TABLESPACE, TRIGGER,
               TRIGGER, TYPE, USER, USER GRANTS for Oracle databases.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: A list of strings describing the objects. Each string should be
         considered like a list of strings separated by the character '\001'.
         The later in each string the smaller item the change and it is hierachical.
   </p>
<A NAME="drop"></A><A NAME="ref40"></A><table width="100%"><tr bgcolor="#eeeeee"><td>QString &nbsp;<strong>drop</strong> (std::list<QString> &object)
<br></td><td align="right"><h3><strong>drop</strong></h3></td></tr></table><p></p><p> Create script to drop a list of objects.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>object</i></TD><TD align="left" valign="top">List of object. This has the format {type}:{schema}.{object}.
               The type is database dependent but can as an example be of
               CONSTRAINT, DATABASE LINK, EXCHANGE INDEX,
               EXCHANGE TABLE, FUNCTION, INDEX, MATERIALIZED VIEW,
               MATERIALIZED VIEW LOG, PACKAGE, PACKAGE BODY, PROCEDURE,
               PROFILE, ROLE, ROLE GRANTS, ROLLBACK SEGMENT, SEQUENCE,
               SNAPSHOT, SNAPSHOT LOG, SYNONYM, TABLE, TABLE FAMILY,
               TABLE CONTENTS, TABLE REFERENCES, TABLESPACE, TRIGGER,
               TRIGGER, TYPE, USER, USER GRANTS for Oracle databases.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: A string containing a script to drop the specified objects.
   </p>
<A NAME="drop"></A><A NAME="ref41"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>drop</strong> (<A HREF="#QTextStream">QTextStream</A> &stream,std::list<QString> &object)
<br></td><td align="right"><h3><strong>drop</strong></h3></td></tr></table><p></p><p> Create script to drop a list of objects.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>stream</i></TD><TD align="left" valign="top">Stream to write result to.
</TD></TR>
<TR><TD align="left" valign="top"><i>object</i></TD><TD align="left" valign="top">List of object. This has the format {type}:{schema}.{object}.
               The type is database dependent but can as an example be of
               CONSTRAINT, DATABASE LINK, EXCHANGE INDEX,
               EXCHANGE TABLE, FUNCTION, INDEX, MATERIALIZED VIEW,
               MATERIALIZED VIEW LOG, PACKAGE, PACKAGE BODY, PROCEDURE,
               PROFILE, ROLE, ROLE GRANTS, ROLLBACK SEGMENT, SEQUENCE,
               SNAPSHOT, SNAPSHOT LOG, SYNONYM, TABLE, TABLE FAMILY,
               TABLE CONTENTS, TABLE REFERENCES, TABLESPACE, TRIGGER,
               TRIGGER, TYPE, USER, USER GRANTS for Oracle databases.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: A string containing a script to drop the specified objects.
   </p>
<A NAME="migrate"></A><A NAME="ref42"></A><table width="100%"><tr bgcolor="#eeeeee"><td>QString &nbsp;<strong>migrate</strong> (std::list<QString> &drpLst,std::list<QString> &crtLst)
<br></td><td align="right"><h3><strong>migrate</strong></h3></td></tr></table><p></p><p> Called to generate a script to migrate a database object from one description to
 another description.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>stream</i></TD><TD align="left" valign="top">Stream to write result to.
</TD></TR>
<TR><TD align="left" valign="top"><i>src</i></TD><TD align="left" valign="top">Source description list, generated by describes for the same database.
</TD></TR>
<TR><TD align="left" valign="top"><i>dst</i></TD><TD align="left" valign="top">Destination description list, generated by describes for the same database.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: A script to change the src database object to dst.
   </p>
<A NAME="migrate"></A><A NAME="ref43"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>migrate</strong> (<A HREF="#QTextStream">QTextStream</A> &stream,std::list<QString> &drpLst,std::list<QString> &crtLst)
<br></td><td align="right"><h3><strong>migrate</strong></h3></td></tr></table><p></p><p> Called to generate a script to migrate a database object from one description to
 another description.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>stream</i></TD><TD align="left" valign="top">Stream to write result to.
</TD></TR>
<TR><TD align="left" valign="top"><i>src</i></TD><TD align="left" valign="top">Source description list, generated by describes for the same database.
</TD></TR>
<TR><TD align="left" valign="top"><i>dst</i></TD><TD align="left" valign="top">Destination description list, generated by describes for the same database.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: A script to change the src database object to dst.
   </p>
<A NAME="setState"></A><A NAME="ref44"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>setState</strong> (const QCString &name,const QVariant &val)
<br></td><td align="right"><h3><strong>setState</strong></h3></td></tr></table><p></p><p> Set a context for this extractor.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>name</i></TD><TD align="left" valign="top">Name of this context
</TD></TR>
<TR><TD align="left" valign="top"><i>val</i></TD><TD align="left" valign="top">Value of this context
   </TD></TR>
</TABLE></P>
<A NAME="state"></A><A NAME="ref45"></A><table width="100%"><tr bgcolor="#eeeeee"><td>QVariant &nbsp;<strong>state</strong> (const QCString &name)
<br></td><td align="right"><h3><strong>state</strong></h3></td></tr></table><p></p><p> Get the value of a context for the current extractor.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>name</i></TD><TD align="left" valign="top">Name of the context to extract.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The value of the context.
   </p>
<A NAME="setSchema"></A><A NAME="ref46"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>setSchema</strong> (const QString &schema)
<br></td><td align="right"><h3><strong>setSchema</strong></h3></td></tr></table><p></p><p> Set the schema of the extraction.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>schema</i></TD><TD align="left" valign="top">Specify the schema of the output script or description. If empty
               don't specify any object. If the string "1" use same object as input.
               Otherwise use the specified schema.
   </TD></TR>
</TABLE></P>
<A NAME="setResize"></A><A NAME="ref47"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>setResize</strong> (const QString &resize)
<br></td><td align="right"><h3><strong>setResize</strong></h3></td></tr></table><p></p><p> Set sizes to use for resize of object on extraction.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>A</i></TD><TD align="left" valign="top">list of sizes separated by ':'. Should be an even multiple of three where
        the first value is the largest current size to use these values. The next
        value is the initial value to use, the last is the next increment value to
        use. As a special case the string "1" can be used to set up auto resize.
   </TD></TR>
</TABLE></P>
<A NAME="setPrompt"></A><A NAME="ref48"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>setPrompt</strong> (bool prompt)
<br></td><td align="right"><h3><strong>setPrompt</strong></h3></td></tr></table><p></p><p> Set inclusion of prompts.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>prompt</i></TD><TD align="left" valign="top">If prompt generation should be generated.
   </TD></TR>
</TABLE></P>
<A NAME="setHeading"></A><A NAME="ref49"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>setHeading</strong> (bool heading)
<br></td><td align="right"><h3><strong>setHeading</strong></h3></td></tr></table><p></p><p> Include heading in scripts.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>heading</i></TD><TD align="left" valign="top">Include heading in scripts.
   </TD></TR>
</TABLE></P>
<A NAME="setConstraints"></A><A NAME="ref50"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>setConstraints</strong> (bool constraints)
<br></td><td align="right"><h3><strong>setConstraints</strong></h3></td></tr></table><p></p><p> Include constraints in extraction.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>constraints</i></TD><TD align="left" valign="top">Include constraints.
   </TD></TR>
</TABLE></P>
<A NAME="setIndexes"></A><A NAME="ref51"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>setIndexes</strong> (bool indexes)
<br></td><td align="right"><h3><strong>setIndexes</strong></h3></td></tr></table><p></p><p> Include indexes in extraction.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>indexes</i></TD><TD align="left" valign="top">Include indexes.
   </TD></TR>
</TABLE></P>
<A NAME="setGrants"></A><A NAME="ref52"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>setGrants</strong> (bool val)
<br></td><td align="right"><h3><strong>setGrants</strong></h3></td></tr></table><p></p><p> Include grants in extraction.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>val</i></TD><TD align="left" valign="top">Include grants.
   </TD></TR>
</TABLE></P>
<A NAME="setStorage"></A><A NAME="ref53"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>setStorage</strong> (bool val)
<br></td><td align="right"><h3><strong>setStorage</strong></h3></td></tr></table><p></p><p> Include storage specification in extraction.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>val</i></TD><TD align="left" valign="top">Include storage specification.
   </TD></TR>
</TABLE></P>
<A NAME="setParallel"></A><A NAME="ref54"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>setParallel</strong> (bool val)
<br></td><td align="right"><h3><strong>setParallel</strong></h3></td></tr></table><p></p><p> Include parallel specification in extraction.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>val</i></TD><TD align="left" valign="top">Include parallel specification.
   </TD></TR>
</TABLE></P>
<A NAME="setPartition"></A><A NAME="ref55"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>setPartition</strong> (bool val)
<br></td><td align="right"><h3><strong>setPartition</strong></h3></td></tr></table><p></p><p> Include partition specification in extraction.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>val</i></TD><TD align="left" valign="top">Include partition specification.
   </TD></TR>
</TABLE></P>
<A NAME="setContents"></A><A NAME="ref56"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>setContents</strong> (bool val,int commitdistance)
<br></td><td align="right"><h3><strong>setContents</strong></h3></td></tr></table><p></p><p> Include contents of tables in scripts.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>val</i></TD><TD align="left" valign="top">Include contents of tables.
</TD></TR>
<TR><TD align="left" valign="top"><i>commitdistance</i></TD><TD align="left" valign="top">The commit distance of the contents 0 means whole tables.
   </TD></TR>
</TABLE></P>
<A NAME="setComments"></A><A NAME="ref57"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>setComments</strong> (bool val)
<br></td><td align="right"><h3><strong>setComments</strong></h3></td></tr></table><p></p><p> Include comments in extraction.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>val</i></TD><TD align="left" valign="top">Include indexes.
   </TD></TR>
</TABLE></P>
<A NAME="setCode"></A><A NAME="ref58"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>setCode</strong> (bool val)
<br></td><td align="right"><h3><strong>setCode</strong></h3></td></tr></table><p></p><p> Include code in extraction.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>val</i></TD><TD align="left" valign="top">Include code.
   </TD></TR>
</TABLE></P>
<A NAME="setBlockSize"></A><A NAME="ref59"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>setBlockSize</strong> (int val)
<br></td><td align="right"><h3><strong>setBlockSize</strong></h3></td></tr></table><p></p><p> Set blocksize of database.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>val</i></TD><TD align="left" valign="top">New value of blocksize.
   </TD></TR>
</TABLE></P>
<A NAME="getSchema"></A><A NAME="ref60"></A><table width="100%"><tr bgcolor="#eeeeee"><td>const QString &&nbsp;<strong>getSchema</strong> (void)
<br></td><td align="right"><h3><strong>getSchema</strong></h3></td></tr></table><p></p><p> Get schema specification.
</p>
<p><b>Returns</b>: Schema specification.
</p>
<p><b>See also</b>: setSchema</p>
<A NAME="getResize"></A><A NAME="ref61"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>getResize</strong> (void)
<br></td><td align="right"><h3><strong>getResize</strong></h3></td></tr></table><p></p><p> Get resize specification.
</p>
<p><b>Returns</b>: Resize specification.
</p>
<p><b>See also</b>: setResize</p>
<A NAME="getPrompt"></A><A NAME="ref62"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>getPrompt</strong> (void)
<br></td><td align="right"><h3><strong>getPrompt</strong></h3></td></tr></table><p></p><p> Check if prompt are generated.
</p>
<p><b>Returns</b>: If prompts are generated.
   </p>
<A NAME="getHeading"></A><A NAME="ref63"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>getHeading</strong> (void)
<br></td><td align="right"><h3><strong>getHeading</strong></h3></td></tr></table><p></p><p> Check if headings are generated.
</p>
<p><b>Returns</b>: If headings are generated.
   </p>
<A NAME="getConstraints"></A><A NAME="ref64"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>getConstraints</strong> (void)
<br></td><td align="right"><h3><strong>getConstraints</strong></h3></td></tr></table><p></p><p> Check if constraints are generated.
</p>
<p><b>Returns</b>: If constraints are generated.
   </p>
<A NAME="getIndexes"></A><A NAME="ref65"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>getIndexes</strong> (void)
<br></td><td align="right"><h3><strong>getIndexes</strong></h3></td></tr></table><p></p><p> Check if indexes are generated.
</p>
<p><b>Returns</b>: If indexes are generated.
   </p>
<A NAME="getGrants"></A><A NAME="ref66"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>getGrants</strong> (void)
<br></td><td align="right"><h3><strong>getGrants</strong></h3></td></tr></table><p></p><p> Check if grants are generated.
</p>
<p><b>Returns</b>: If grants are generated.
   </p>
<A NAME="getStorage"></A><A NAME="ref67"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>getStorage</strong> (void)
<br></td><td align="right"><h3><strong>getStorage</strong></h3></td></tr></table><p></p><p> Check if storage specification are generated.
</p>
<p><b>Returns</b>: If storage specification are generated.
   </p>
<A NAME="getParallel"></A><A NAME="ref68"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>getParallel</strong> (void)
<br></td><td align="right"><h3><strong>getParallel</strong></h3></td></tr></table><p></p><p> Check if parallell specification are generated.
</p>
<p><b>Returns</b>: If parallell specification are generated.
   </p>
<A NAME="getPartition"></A><A NAME="ref69"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>getPartition</strong> (void)
<br></td><td align="right"><h3><strong>getPartition</strong></h3></td></tr></table><p></p><p> Check if partition specification are generated.
</p>
<p><b>Returns</b>: If partition specification  are generated.
   </p>
<A NAME="getContents"></A><A NAME="ref70"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>getContents</strong> (void)
<br></td><td align="right"><h3><strong>getContents</strong></h3></td></tr></table><p></p><p> Check if contents of tables are generated.
</p>
<p><b>Returns</b>: If content is generated.
   </p>
<A NAME="getCommitDistance"></A><A NAME="ref71"></A><table width="100%"><tr bgcolor="#eeeeee"><td>int &nbsp;<strong>getCommitDistance</strong> (void)
<br></td><td align="right"><h3><strong>getCommitDistance</strong></h3></td></tr></table><p></p><p> Get the distance of the commits when content is generated.
</p>
<p><b>Returns</b>: Commit distance.
   </p>
<A NAME="getComments"></A><A NAME="ref72"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>getComments</strong> (void)
<br></td><td align="right"><h3><strong>getComments</strong></h3></td></tr></table><p></p><p> Check if comments are generated.
</p>
<p><b>Returns</b>: If comments are generated.
   </p>
<A NAME="getCode"></A><A NAME="ref73"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>getCode</strong> (void)
<br></td><td align="right"><h3><strong>getCode</strong></h3></td></tr></table><p></p><p> Check if code is generated.
</p>
<p><b>Returns</b>: If code is generated.
   </p>
<A NAME="getBlockSize"></A><A NAME="ref74"></A><table width="100%"><tr bgcolor="#eeeeee"><td>int &nbsp;<strong>getBlockSize</strong> (void)
<br></td><td align="right"><h3><strong>getBlockSize</strong></h3></td></tr></table><p></p><p> Get blocksize.
   </p>
<A NAME="connection"></A><A NAME="ref75"></A><table width="100%"><tr bgcolor="#eeeeee"><td><A HREF="toConnection.html">toConnection</A> &&nbsp;<strong>connection</strong> ()
<br></td><td align="right"><h3><strong>connection</strong></h3></td></tr></table><p></p><p> Get the connection this extractor is working on.
   </p>
<A NAME="initialNext"></A><A NAME="ref76"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>initialNext</strong> (const QString &blocks,QString &initial,QString &next)
<br></td><td align="right"><h3><strong>initialNext</strong></h3></td></tr></table><p></p><p> Fill in the initial and next value for an object currently holding a number of
 allocated blocks. Uses the resize or default sizes.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>blocks</i></TD><TD align="left" valign="top">Blocks currently allocated.
</TD></TR>
<TR><TD align="left" valign="top"><i>initial</i></TD><TD align="left" valign="top">New initial value.
</TD></TR>
<TR><TD align="left" valign="top"><i>next</i></TD><TD align="left" valign="top">New next value.
   </TD></TR>
</TABLE></P>
<A NAME="intSchema"></A><A NAME="ref77"></A><table width="100%"><tr bgcolor="#eeeeee"><td>QString &nbsp;<strong>intSchema</strong> (const QString &owner,bool desc)
<br></td><td align="right"><h3><strong>intSchema</strong></h3></td></tr></table><p></p><p> Get the schema name specified by the extractor setup. Will include the following '.'
 if needed.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>owner</i></TD><TD align="left" valign="top">Owner of object to get schema for.
</TD></TR>
<TR><TD align="left" valign="top"><i>desc</i></TD><TD align="left" valign="top">Used from describe and not to generate script.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The translated schema.
   </p>
<A NAME="datatypes"></A><A NAME="ref78"></A><table width="100%"><tr bgcolor="#eeeeee"><td>std::list<datatype> &nbsp;<strong>datatypes</strong> ()
<br></td><td align="right"><h3><strong>datatypes</strong></h3></td></tr></table><p></p><p> Get the available datatypes for a database.
</p>
<p><b>Returns</b>: A list of datatypes.
   </p>
<A NAME="createFromParse"></A><A NAME="ref79"></A><table width="100%"><tr bgcolor="#eeeeee"><td>QString &nbsp;<strong>createFromParse</strong> (std::list<<A HREF="toSQLParse__statement.html">toSQLParse::statement</A>>::iterator start,
			  std::list<<A HREF="toSQLParse__statement.html">toSQLParse::statement</A>>::iterator end)
<br></td><td align="right"><h3><strong>createFromParse</strong></h3></td></tr></table><p></p><p> Utility function, creates a statement from the start to the end specified by the
 parameters. The connection used to specify parsing is the one of the extractor.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>start</i></TD><TD align="left" valign="top">Start of parameters.
</TD></TR>
<TR><TD align="left" valign="top"><i>end</i></TD><TD align="left" valign="top">End of parameters.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The indented statement.
   </p>
<A NAME="srcDst2DropCreate"></A><A NAME="ref80"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>srcDst2DropCreate</strong> (std::list<QString> &source,std::list<QString> &destination,
				std::list<QString> &drop,std::list<QString> &creat)
<br></td><td align="right"><h3><strong>srcDst2DropCreate</strong></h3></td></tr></table><p> <small>[static]</small></p><p> Create a source and destination object list to two other lists
 containing dropped and created objects or attributes.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>source</i></TD><TD align="left" valign="top">Source list input (Will not be modified).
</TD></TR>
<TR><TD align="left" valign="top"><i>destination</i></TD><TD align="left" valign="top">Destination list input (Will not be modified).
</TD></TR>
<TR><TD align="left" valign="top"><i>drop</i></TD><TD align="left" valign="top">Drop list output (Will be overwritten).
</TD></TR>
<TR><TD align="left" valign="top"><i>create</i></TD><TD align="left" valign="top">Create list output (Will be overwritten).
   </TD></TR>
</TABLE></P>
<A NAME="canHandle"></A><A NAME="ref81"></A><table width="100%"><tr bgcolor="#eeeeee"><td> bool &nbsp;<strong>canHandle</strong> (<A HREF="toConnection.html">toConnection</A> &conn)
<br></td><td align="right"><h3><strong>canHandle</strong></h3></td></tr></table><p> <small>[static]</small></p><p> Check if a database is supported at all by the extractor.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>conn</i></TD><TD align="left" valign="top">Connection to check for support.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if the database is supported.
   </p>
<A NAME="addDescription"></A><A NAME="ref82"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>addDescription</strong> (std::list<QString> &ret,const std::list<QString> &ctx,
			     const QString &arg1=QString::null,const QString &arg2=QString::null,
			     const QString &arg3=QString::null,const QString &arg4=QString::null,
			     const QString &arg5=QString::null,const QString &arg6=QString::null,
			     const QString &arg7=QString::null,const QString &arg8=QString::null,
			     const QString &arg9=QString::null)
<br></td><td align="right"><h3><strong>addDescription</strong></h3></td></tr></table><p> <small>[static]</small></p><p> Add a list to description.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>ret</i></TD><TD align="left" valign="top">The return list to add a line to.
</TD></TR>
<TR><TD align="left" valign="top"><i>ctx</i></TD><TD align="left" valign="top">The current description context.
</TD></TR>
<TR><TD align="left" valign="top"><i>arg1</i></TD><TD align="left" valign="top">First extra argument to add.
   </TD></TR>
</TABLE></P>
<A NAME="splitDescribe"></A><A NAME="ref83"></A><table width="100%"><tr bgcolor="#eeeeee"><td> std::list<QString> &nbsp;<strong>splitDescribe</strong> (const QString &str)
<br></td><td align="right"><h3><strong>splitDescribe</strong></h3></td></tr></table><p> <small>[static]</small></p><p> Split a description line into its components.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>str</i></TD><TD align="left" valign="top">The description line to split.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The list of components.
   </p>
<A NAME="partDescribe"></A><A NAME="ref84"></A><table width="100%"><tr bgcolor="#eeeeee"><td> QString &nbsp;<strong>partDescribe</strong> (const QString &str,int level)
<br></td><td align="right"><h3><strong>partDescribe</strong></h3></td></tr></table><p> <small>[static]</small></p><p> Get the part of a description indicated by the level
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>str</i></TD><TD align="left" valign="top">Description string
</TD></TR>
<TR><TD align="left" valign="top"><i>level</i></TD><TD align="left" valign="top">The level to get (0 is the first level)
   </TD></TR>
</TABLE></P>
<A NAME="contextDescribe"></A><A NAME="ref85"></A><table width="100%"><tr bgcolor="#eeeeee"><td> QString &nbsp;<strong>contextDescribe</strong> (const QString &str,int level)
<br></td><td align="right"><h3><strong>contextDescribe</strong></h3></td></tr></table><p> <small>[static]</small></p><p> Get the context of a given level.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>str</i></TD><TD align="left" valign="top">Description string
</TD></TR>
<TR><TD align="left" valign="top"><i>level</i></TD><TD align="left" valign="top">The level to get the context for (1 is the first to not return empty string.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The context, if not enough parts are available null is returned.
   </p>
<A NAME="toExtract__columnInfo.html"></A><A NAME="ref86"></A><table width="100%"><tr bgcolor="#eeeeee"><td><strong>columnInfo</strong> <small>(struct)</small></td><td align="right"><h3><strong>columnInfo</strong></h3></td></tr></table><p></p><p> Used to get column information from a describe list
   </p>
<A NAME="parseColumnDescription"></A><A NAME="ref87"></A><table width="100%"><tr bgcolor="#eeeeee"><td> std::list<columnInfo> &nbsp;<strong>parseColumnDescription</strong> (std::list<QString>::const_iterator begin,
						      std::list<QString>::const_iterator end,
						      int level=3)
<br></td><td align="right"><h3><strong>parseColumnDescription</strong></h3></td></tr></table><p> <small>[static]</small></p><p> Parse a column description and return a sorted list of column data.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>begin</i></TD><TD align="left" valign="top">The iterator indicating the beginning to start searching from (Inclusive).
</TD></TR>
<TR><TD align="left" valign="top"><i>end</i></TD><TD align="left" valign="top">The iterator indicating the end to end searching at (Not inclusive).
</TD></TR>
<TR><TD align="left" valign="top"><i>level</i></TD><TD align="left" valign="top">Number of levels of context to discard before looking for "COLUMN" definition.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The list of column definitions. Sorted by column order.
   </p>
<A NAME="parseColumnDescription"></A><A NAME="ref88"></A><table width="100%"><tr bgcolor="#eeeeee"><td> std::list<columnInfo> &nbsp;<strong>parseColumnDescription</strong> (const std::list<QString> &description,int level=3)
<br></td><td align="right"><h3><strong>parseColumnDescription</strong></h3></td></tr></table><p> <small>[static]</small></p><p> Parse a column description and return a sorted list of column data.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>description</i></TD><TD align="left" valign="top">A description list. Will go through entire list.
</TD></TR>
<TR><TD align="left" valign="top"><i>level</i></TD><TD align="left" valign="top">Number of levels of context to discard before looking for "COLUMN" definition.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The list of column definitions. Sorted by column order.
   </p>
<A NAME="extractor"></A><A NAME="ref89"></A><table width="100%"><tr bgcolor="#eeeeee"><td>friend class  <strong>extractor</strong>
</td><td align="right"><h3><strong>extractor</strong></h3></td></tr></table><p></p><HR>
	<table>
	<tr><td><small>Generated by: nneul on skyhawk on Wed Feb 23 19:24:59 2005, using kdoc 2.0a54.</small></td></tr>
	</table>
</BODY>
</HTML>
