<HTML>
<HEAD>
<TITLE>Source: tohighlightedtext.h</TITLE>

<META NAME="Generator" CONTENT="KDOC ">
</HEAD>
<BODY bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#000099" alink= "#ffffff">
<TABLE WIDTH="100%" BORDER="0">
<TR>
<TD>
	<TABLE BORDER="0">
		<TR><TD valign="top" align="left" cellspacing="10">
		<h1>Source: tohighlightedtext.h</h1>
		</TD>
		<TD valign="top" align="right" colspan="1"></TD></TR>
	</TABLE>
	<HR>
	<TABLE BORDER="0">
		
	</TABLE>
	</TD>
<TD align="right"><TABLE BORDER="0"><TR><TD><small><A HREF="index-long.html">Annotated List</A></small></TD></TR>
<TR><TD><small><A HREF="header-list.html">Files</A></small></TD></TR>
<TR><TD><small><A HREF="all-globals.html">Globals</A></small></TD></TR>
<TR><TD><small><A HREF="hier.html">Hierarchy</A></small></TD></TR>
<TR><TD><small><A HREF="index.html">Index</A></small></TD></TR>
</TABLE></TD></TR></TABLE>
<pre>
//***************************************************************************
/* $Id$
**
** Copyright (C) 2000-2001 GlobeCom AB.  All rights reserved.
**
** This file is part of the Toolkit for Oracle.
**
** This file may be distributed under the terms of the Q Public License
** as defined by Trolltech AS of Norway and appearing in the file
** LICENSE included in the packaging of this file.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.globecom.net/tora/ for more information.
**
** Contact tora@globecom.se if any conditions of this licensing are
** not clear to you.
**
**********************************************************************/

#ifndef __TOHIGHLIGHTEDTEXT_H
#define __TOHIGHLIGHTEDTEXT_H

#include &lt;list&gt;
#include &lt;map&gt;

#include "tomarkedtext.h"

class QPainter;
class toSyntaxSetup;

/** This class implements a syntax parser to provide information to
 * a syntax highlighted editor.
 */

class toSyntaxAnalyzer {
public:
  /** Information about how highlighting has changed.
   */
  enum infoType {
    /** Normal text
     */
    Normal=0,
    /** This is a keyword
     */
    Keyword=1,
    /** This is a string
     */
    String=2,
    /** Malformed syntax
     */
    Error=3,
    /** Comment
     */
    Comment=4,
    /** Error in SQL background. Not used by highlighter, but configured in the same way.
     */
    ErrorBkg=5,
    /** Normal background. Not used by highlighter, but configured in the same way.
     */
    NormalBkg=6,
    /** Current background. Not used by highlighter, but configured in the same way.
     */
    CurrentBkg=7
  };
  /** Information about a change in highlighting.
   */
  struct highlightInfo {
    /** New type of highlighting.
     */
    infoType Type;
    /** Start in line for this highlighting.
     */
    int Start;
    highlightInfo(int start,infoType typ=Normal)
    { Start=start; Type=typ; }
  };
private:
  /** Indicate if colors are updated, can't do this in constructor since QApplication
   * isn't initialized yet.
   */
  bool ColorsUpdated;
  /** Colors allocated for the different @ref infoType values.
   */
  QColor Colors[8];
  /** Keeps track of possible hits found so far.
   */
  struct posibleHit {
    posibleHit(const char *);
    /** Where you are in this word to find a hit.
     */
    int Pos;
    /** The text to hit, points into keywords array.
     */
    const char *Text;
  };
  /** An array of lists of keywords, indexed on the first character.
   */
  std::list&lt;const char *&gt; Keywords[256];
protected:
  /** Check if this is part of a symbol or not.
   */
  bool isSymbol(QChar c)
  { return (c.isLetterOrNumber()||c=='_'||c=='#'||c=='$'||c=='.'); }
private:
  /** Get a colordefinition from a @ref infoType value.
   * @param def Color to fill out.
   * @param pos @ref infoType to get color for.
   */
  void readColor(const QColor &amp;def,infoType pos);
  /** Get a string representation of an @ref infoType.
   * @param typ @ref infoType to get string for.
   * @return Description of infotype.
   */
  static QString typeString(infoType typ);
  /** Get an @ref infoType from a string representation of it.
   * @param str Description of @ref infoType.
   * @return @ref infoType described by string.
   */
  static infoType typeString(const QString &amp;str);
  /** Update configuration settings from this class color values.
   */
  void updateSettings(void);
public:
  /** Create a syntax analysed
   * @param keywords A list of keywords.
   */
  toSyntaxAnalyzer(const char **keywords);
  virtual ~toSyntaxAnalyzer()
  { }
  /** Analyze a line. There is no guarantee that lines will be called in any kind of order.
   * @param str Line to analyze.
   * @return A list of where highlighting should change. Start as normal.
   */
  virtual std::list&lt;highlightInfo&gt; analyzeLine(const QString &amp;str);
  /** Get a colordefinition for a @ref infoType value.
   * @param typ @ref infoType to get color for.
   * @return Color of that type.
   */
  QColor getColor(infoType typ)
  { return Colors[typ]; }

  friend class toSyntaxSetup;
};

/** Get the default syntax analyzer.
 * @return Reference to the default analyzer.
 */
toSyntaxAnalyzer &amp;toDefaultAnalyzer(void);

/** A simple editor which supports syntax highlighting.
 */

class toHighlightedText : public toMarkedText {
private:
  Q_OBJECT

  /** Used internally for drawing.
   */
  int LastCol;
  /** Used internally for drawing.
   */
  int LastRow;
  /** Used internally for drawing.
   */
  int LastLength;
  /** Current line has different background than others.
   */
  int Current;
  /** Indicate how many pixels on the left to ignore painting.
   */
  int LeftIgnore;
  /** Indicate if text should be highlighted or not.
   */
  bool Highlight;
  /** Indicate if keywords should be converted to uppercase when displayed.
   */
  bool KeywordUpper;
  /** Used internally for drawing.
   */
  bool Cursor;
  /** Map of rows with errors and their error message.
   */
  std::map&lt;int,QString&gt; Errors;
  /** The syntax analyzer to use.
   */
  toSyntaxAnalyzer *Analyzer;
protected:
  /** Set how much of the left margin to ignore painting.
   */
  void setLeftIgnore(int ignore)
  { LeftIgnore=ignore; }
public:
  /** Convert a linenumber after a change of the buffer to another linenumber. Can be
   * used to convert a specific linenumber after receiving a @ref insertedLines call.
   * @param line Line number.
   * @param start Start of change.
   * @param diff Lines added or removed.
   * @return New linenumber or -1 if line doesn't exist anymore.
   */
  static int convertLine(int line,int start,int diff);
  /** Create a new editor.
   * @param parent Parent of widget.
   * @param name Name of widget.
   */
  toHighlightedText(QWidget *parent,const char *name=NULL);

  /** Clear the editor.
   */
  void clear(void)
  { Errors.clear(); Current=-1; toMarkedText::clear(); }
  /** Set the text of this editor.
   */
  void setText(const QString &amp;str);

  /** Set the error list map.
   * @param errors A map of linenumbers to errorstrings. These will be displayed in the
   *               statusbar if the cursor is placed on the line.
   */
  void setErrors(const std::map&lt;int,QString&gt; &amp;errors);
  /** Set current line. Will be indicated with a different background.
   * @param current Current line.
   */
  void setCurrent(int current);
  /** Get current line.
   * @return Current line.
   */
  int current(void)
  { return Current; update(); }
  /** Set keyword upper flag. If this is set keywords will be converted to uppercase when painted.
   * @param val New value of keyword to upper flag.
   */
  void setKeywordUpper(bool val)
  { KeywordUpper=val; update(); }
  /** The the highlighting flag. If this isn't set no highlighting is done.
   */
  void setHighlight(bool val)
  { Highlight=val; update(); }
  /** Set the syntax highlighter to use.
   * @param analyzer Analyzer to use.
   */
  void setAnalyzer(toSyntaxAnalyzer &amp;analyzer)
  { Analyzer=&amp;analyzer; update(); }
  /** Get the current syntaxhighlighter.
   * @return Analyzer used.
   */
  toSyntaxAnalyzer &amp;analyzer(void)
  { return *Analyzer; }

  /** Reimplemented for internal reasons.
   */
  virtual void paintCell (QPainter *painter,int row,int col);

signals:
  /** Emitted when lines are inserted or removed.
   * @param start Start of line inserted.
   * @param diff Number of lines inserted or removed.
   */
  void insertedLines(int start,int diff);
protected slots:
  void textChanged(void);

public slots:
  /** Go to next error.
   */
  void nextError(void);
  /** Go to previous error.
   */
  void previousError(void);
};

#endif
</pre>
<HR>
	<table>
	</table>
</BODY>
</HTML>
