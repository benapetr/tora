<HTML>
<HEAD>
<TITLE>Source: toconnection.h</TITLE>

<META NAME="Generator" CONTENT="KDOC ">
</HEAD>
<BODY bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#000099" alink= "#ffffff">
<TABLE WIDTH="100%" BORDER="0">
<TR>
<TD>
	<TABLE BORDER="0">
		<TR><TD valign="top" align="left" cellspacing="10">
		<h1>Source: toconnection.h</h1>
		</TD>
		<TD valign="top" align="right" colspan="1"></TD></TR>
	</TABLE>
	<HR>
	<TABLE BORDER="0">
		
	</TABLE>
	</TD>
<TD align="right"><TABLE BORDER="0"><TR><TD><small><A HREF="index-long.html">Annotated List</A></small></TD></TR>
<TR><TD><small><A HREF="header-list.html">Files</A></small></TD></TR>
<TR><TD><small><A HREF="all-globals.html">Globals</A></small></TD></TR>
<TR><TD><small><A HREF="hier.html">Hierarchy</A></small></TD></TR>
<TR><TD><small><A HREF="index.html">Index</A></small></TD></TR>
</TABLE></TD></TR></TABLE>
<pre>
//***************************************************************************
/*
 * TOra - An Oracle Toolkit for DBA's and developers
 * Copyright (C) 2000 GlobeCom AB
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 *      As a special exception, you have permission to link this program
 *      with the Oracle Client libraries and distribute executables, as long
 *      as you follow the requirements of the GNU GPL in regard to all of the
 *      software in the executable aside from Oracle client libraries. You
 *      are also allowed to link this program with the Qt Non Commercial for
 *      Windows.
 *
 *      Specifically you are not permitted to link this program with the
 *      Qt/UNIX or Qt/Windows products of TrollTech. And you are not
 *      permitted to distribute binaries compiled against these libraries
 *      without written consent from GlobeCom AB. Observe that this does not
 *      disallow linking to the Qt Free Edition.
 *
 * All trademarks belong to their respective owners.
 *
 ****************************************************************************/

#ifndef __TOCONNECTION_H
#define __TOCONNECTION_H

#include &lt;list&gt;
#include &lt;map&gt;

#include &lt;qstring.h&gt;

class QWidget;
class toConnection;
class toConnectionProvider;
class toSQL;

/** This class is an abstract definition of an actual connection to a database.
 * Each @ref toConnection object can have one or more actual connections to the
 * database depending on long running queries. Normally you will never need to
 * bother with this class if you aren't creating a new database provider
 * (@ref toConnectionProvider).
 */

class toConnectionSub {
public:
  /** Create connection to database.
   */
  toConnectionSub()
  { }
  /** Close connection.
   */
  virtual ~toConnectionSub()
  { }
};

/** This class is used to perform a query on a database connection.
 */

class toQuery {
public:
  /** Represent different modes to run a query in.
   */
  enum queryMode {
    /** Run the query normally on the main connection of the @ref toConnection object.
     */
    Normal,
    /** Run the query in a separate connection for long running queries.
     */
    Long,
    /** Run the query on all non occupied connections of the @ref toConnection object.
     */
    All
  };

  /** This structure is used to describe the resultset of a query.
   */

  struct queryDescribe {
    /** Column name
     */
    QString Name;
    /** Datatype of string.
     */
    QString Datatype;
    /** If column can contain null values.
     */
    bool Null;
  };
  /** This function is used to represent values that are passed to and from queries
   */
  class queryValue {
    enum {
      intType,
      doubleType,
      stringType,
      nullType
    } Type;
    union {
      int Int;
      double Double;
      QString *String;
    } Value;
  public:
    /** Create null value.
     */
    queryValue(void);
    /** Create integer value.
     * @param i Value.
     */
    queryValue(int i);
    /** Create string value.
     * @param str Value.
     */
    queryValue(const QString &amp;str);
    /** Create double value.
     * @param d Value.
     */
    queryValue(double d);
    /** Destruct query.
     */
    ~queryValue();
    
    /** Create a copy of a value.
     */
    queryValue(const queryValue &amp;copy);
    /** Assign this value from another value.
     */
    const queryValue &amp;operator = (const queryValue &amp;copy);

    /** Check if this is an int value.
     */
    bool isInt(void) const;
    /** Check if this is a double value.
     */
    bool isDouble(void) const;
    /** Check if this is a string value.
     */
    bool isString(void) const;
    /** Check if this value is null.
     */
    bool isNull(void) const;

    /** Get utf8 format of this value.
     */
    QCString utf8Value(void) const;
    /** Get integer representation of this value.
     */
    int toInt(void) const;
    /** Get double representation of this value.
     */
    double toDouble(void) const;

    /** Convert value to a string.
     */
    operator QString() const;
  };
  /** Abstract parent of implementations of a query for a database provider
   * (See @ref toConnection::connectionImpl and @ref toConnectionProvider)
   */
  class queryImpl {
    toQuery *Parent;
  public:
    /** Get the parent query object. All the parameters of the query must be read from here.
     * nothing is passed to the functions.
     */
    toQuery *query()
    { return Parent; }
    
    /** Create a query implementation. The constructor must not perform any actions with the
     * database that could block for a noticable time (Like execute or parse a query). The
     * data for the query may not be available when this object created.
     * @param query Parent query object.
     */
    queryImpl(toQuery *query)
      : Parent(query)
    { }
    /** Destroy query implementation.
     */
    virtual ~queryImpl()
    { }
    /** Execute a query. Parameters can be gotten from the @ref toQuery object.
     */
    virtual void execute(void) = 0;
    /** Read the next value from the stream.
     * @return The value read from the query.
     */
    virtual queryValue readValue(void) = 0;
    /** Check if the end of the query has been reached.
     * @return True if all values have been read.
     */
    virtual bool eof(void) = 0;
    /** Get the number of rows processed in the last executed query.
     */
    virtual int rowsProcessed(void) = 0;
    /** Describe the currently running query.
     * @return A list of column descriptions of the query.
     */
    virtual list&lt;queryDescribe&gt; describe(void) = 0;
    /** Get number of columns in the resultset.
     * @return Column number.
     */
    virtual int columns(void) = 0;
  };

private:
  toConnection &amp;Connection;
  toConnectionSub *ConnectionSub;
  list&lt;queryValue&gt; Params;
  QCString SQL;
  queryMode Mode;

  queryImpl *Query;
  toQuery(const toQuery &amp;);
public:
  toQuery(toConnection &amp;conn,toSQL &amp;sql,const list&lt;queryValue&gt; &amp;params);
  toQuery(toConnection &amp;conn,const QString &amp;sql,const list&lt;queryValue&gt; &amp;params);
  toQuery(toConnection &amp;conn,toSQL &amp;sql,
	  const QString &amp;arg1=QString::null,const QString &amp;arg2=QString::null,
	  const QString &amp;arg3=QString::null,const QString &amp;arg4=QString::null,
	  const QString &amp;arg5=QString::null,const QString &amp;arg6=QString::null,
	  const QString &amp;arg7=QString::null,const QString &amp;arg8=QString::null,
	  const QString &amp;arg9=QString::null);
  toQuery(toConnection &amp;conn,const QString &amp;sql,
	  const QString &amp;arg1=QString::null,const QString &amp;arg2=QString::null,
	  const QString &amp;arg3=QString::null,const QString &amp;arg4=QString::null,
	  const QString &amp;arg5=QString::null,const QString &amp;arg6=QString::null,
	  const QString &amp;arg7=QString::null,const QString &amp;arg8=QString::null,
	  const QString &amp;arg9=QString::null);

  toQuery(toConnection &amp;conn,queryMode mode,toSQL &amp;sql,const list&lt;queryValue&gt; &amp;params);
  toQuery(toConnection &amp;conn,queryMode mode,const QString &amp;sql,const list&lt;queryValue&gt; &amp;params);
  toQuery(toConnection &amp;conn,queryMode mode=Normal);

  virtual ~toQuery();

  void execute(toSQL &amp;sql,const list&lt;queryValue&gt; &amp;params);
  void execute(const QString &amp;sql,const list&lt;queryValue&gt; &amp;params);

  toConnection &amp;connection(void)
  { return Connection; }
  toConnectionSub *connectionSub(void)
  { return ConnectionSub; }
  list&lt;queryValue&gt; &amp;params(void)
  { return Params; }
  QCString sql(void)
  { return SQL; }

  queryValue readValue(void);
  queryValue readValueNull(void);
  bool eof(void);

  int rowsProcessed(void)
  { return Query-&gt;rowsProcessed(); }
  list&lt;queryDescribe&gt; describe(void)
  { return Query-&gt;describe(); }
  int columns(void)
  { return Query-&gt;columns(); }

  static list&lt;queryValue&gt; readQuery(toConnection &amp;conn,
				    toSQL &amp;sql,
				    list&lt;queryValue&gt; &amp;params);
  static list&lt;queryValue&gt; readQuery(toConnection &amp;conn,
				    const QString &amp;sql,
				    list&lt;queryValue&gt; &amp;params);
  static list&lt;queryValue&gt; readQuery(toConnection &amp;conn,toSQL &amp;sql,
				    const QString &amp;arg1=QString::null,const QString &amp;arg2=QString::null,
				    const QString &amp;arg3=QString::null,const QString &amp;arg4=QString::null,
				    const QString &amp;arg5=QString::null,const QString &amp;arg6=QString::null,
				    const QString &amp;arg7=QString::null,const QString &amp;arg8=QString::null,
				    const QString &amp;arg9=QString::null);
  static list&lt;queryValue&gt; readQuery(toConnection &amp;conn,const QString &amp;sql,
				    const QString &amp;arg1=QString::null,const QString &amp;arg2=QString::null,
				    const QString &amp;arg3=QString::null,const QString &amp;arg4=QString::null,
				    const QString &amp;arg5=QString::null,const QString &amp;arg6=QString::null,
				    const QString &amp;arg7=QString::null,const QString &amp;arg8=QString::null,
				    const QString &amp;arg9=QString::null);
};

typedef toQuery::queryValue toQValue;
typedef list&lt;toQValue&gt; toQList;
typedef toQuery::queryDescribe toQDescribe;
typedef list&lt;toQDescribe&gt; toQDescList;

class toConnection {
  toConnectionProvider &amp;Provider;
  QString User;
  QString Password;
  QString Host;
  QString Database;
  QString Mode;
  QString Version;
  list&lt;QWidget *&gt; Widgets;
  list&lt;QCString&gt; InitStrings;
  list&lt;toConnectionSub *&gt; Connections;
  bool NeedCommit;

public:

  class connectionImpl {
    toConnection *Connection;
  public:
    toConnection &amp;connection(void)
    { return *Connection; }
    connectionImpl(toConnection *conn)
    { Connection=conn; };
    virtual ~connectionImpl()
    { }

    virtual void commit(toConnectionSub *) = 0;
    virtual void rollback(toConnectionSub *) = 0;

    virtual toConnectionSub *createConnection(void) = 0;
    virtual void closeConnection(toConnectionSub *) = 0;

    virtual QString version(toConnectionSub *) = 0;
    virtual connectionImpl *clone(toConnection *newConn) const = 0;

    virtual toQuery::queryImpl *createQuery(toQuery *query,toConnectionSub *conn) = 0;
    virtual void execute(toConnectionSub *,const QCString &amp;sql,toQList &amp;params) = 0;
  };

private:

  void addConnection(void);
  list&lt;toConnectionSub *&gt; &amp;connections(void)
  { return Connections; }

  connectionImpl *Connection;

public:
  toConnection(const QString &amp;provider,const QString &amp;user,const QString &amp;password,
	       const QString &amp;host,const QString &amp;database,const QString &amp;mode=QString::null);
  toConnection(const toConnection &amp;conn);
  virtual ~toConnection();

  bool closeWidgets(void);
  const QString &amp;user() const
  { return User; }
  const QString &amp;password() const
  { return Password; }
  const QString &amp;host() const
  { return Host; }
  const QString &amp;database() const
  { return Database; }
  const QString &amp;mode() const
  { return Mode; }
  const QString &amp;version() const
  { return Version; }
  const QString &amp;provider() const;

  toConnectionSub *mainConnection(void);
  toConnectionSub *longConnection(void);
  void freeConnection(toConnectionSub *);

  virtual QString description(void) const;

  void setNeedCommit(bool needCommit=true)
  { NeedCommit=needCommit; }
  bool needCommit(void) const
  { return NeedCommit; }
  virtual void commit(void);
  virtual void rollback(void);

  void execute(toSQL &amp;sql,
	       toQList &amp;params);
  void execute(const QString &amp;sql,
	       toQList &amp;params);
  void execute(toSQL &amp;sql,
	       const QString &amp;arg1=QString::null,const QString &amp;arg2=QString::null,
	       const QString &amp;arg3=QString::null,const QString &amp;arg4=QString::null,
	       const QString &amp;arg5=QString::null,const QString &amp;arg6=QString::null,
	       const QString &amp;arg7=QString::null,const QString &amp;arg8=QString::null,
	       const QString &amp;arg9=QString::null);
  void execute(const QString &amp;sql,
	       const QString &amp;arg1=QString::null,const QString &amp;arg2=QString::null,
	       const QString &amp;arg3=QString::null,const QString &amp;arg4=QString::null,
	       const QString &amp;arg5=QString::null,const QString &amp;arg6=QString::null,
	       const QString &amp;arg7=QString::null,const QString &amp;arg8=QString::null,
	       const QString &amp;arg9=QString::null);

  void allExecute(toSQL &amp;sql,
		  toQList &amp;params);
  void allExecute(const QString &amp;sql,
		  toQList &amp;params);
  void allExecute(toSQL &amp;sql,
		  const QString &amp;arg1=QString::null,const QString &amp;arg2=QString::null,
		  const QString &amp;arg3=QString::null,const QString &amp;arg4=QString::null,
		  const QString &amp;arg5=QString::null,const QString &amp;arg6=QString::null,
		  const QString &amp;arg7=QString::null,const QString &amp;arg8=QString::null,
		  const QString &amp;arg9=QString::null);
  void allExecute(const QString &amp;sql,
		  const QString &amp;arg1=QString::null,const QString &amp;arg2=QString::null,
		  const QString &amp;arg3=QString::null,const QString &amp;arg4=QString::null,
		  const QString &amp;arg5=QString::null,const QString &amp;arg6=QString::null,
		  const QString &amp;arg7=QString::null,const QString &amp;arg8=QString::null,
		  const QString &amp;arg9=QString::null);

  void addWidget(QWidget *widget)
  { Widgets.insert(Widgets.end(),widget); }
  void delWidget(QWidget *widget);

  void addInit(const QString &amp;sql);
  void delInit(const QString &amp;sql);

  friend toQuery;
};

class toConnectionProvider {
  static map&lt;QString,toConnectionProvider *&gt; *Providers;
  QString Provider;
public:
  toConnectionProvider(const QString &amp;provider);
  virtual ~toConnectionProvider();
  const QString &amp;provider(void) const
  { return Provider; }

  virtual toConnection::connectionImpl *connection(toConnection *conn)=0;
  virtual list&lt;QString&gt; modes(void);
  virtual list&lt;QString&gt; hosts(void);
  virtual list&lt;QString&gt; databases(const QString &amp;host)=0;

  static toConnectionProvider &amp;fetchProvider(const QString &amp;provider);
  static list&lt;QString&gt; providers();
  static list&lt;QString&gt; modes(const QString &amp;provider);
  static toConnection::connectionImpl *connection(const QString &amp;provider,toConnection *conn);
  static list&lt;QString&gt; hosts(const QString &amp;provider);
  static list&lt;QString&gt; databases(const QString &amp;provider,const QString &amp;host);
};

#endif
</pre>
<HR>
	<table>
	</table>
</BODY>
</HTML>
